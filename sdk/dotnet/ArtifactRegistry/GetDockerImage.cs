// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.ArtifactRegistry
{
    public static class GetDockerImage
    {
        /// <summary>
        /// This data source fetches information from a provided Artifact Registry repository, including the fully qualified name and URI for an image, based on a the latest version of image name and optional digest or tag.
        /// 
        /// &gt; **Note**
        /// Requires one of the following OAuth scopes: `https://www.googleapis.com/auth/cloud-platform` or `https://www.googleapis.com/auth/cloud-platform.read-only`.
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Gcp = Pulumi.Gcp;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var myRepo = new Gcp.ArtifactRegistry.Repository("my_repo", new()
        ///     {
        ///         Location = "us-west1",
        ///         RepositoryId = "my-repository",
        ///         Format = "DOCKER",
        ///     });
        /// 
        ///     var myImage = Gcp.ArtifactRegistry.GetDockerImage.Invoke(new()
        ///     {
        ///         Location = myRepo.Location,
        ///         RepositoryId = myRepo.RepositoryId,
        ///         ImageName = "my-image:my-tag",
        ///     });
        /// 
        ///     var @default = new Gcp.CloudRunV2.Service("default", new()
        ///     {
        ///         Template = new Gcp.CloudRunV2.Inputs.ServiceTemplateArgs
        ///         {
        ///             Containers = new[]
        ///             {
        ///                 new Gcp.CloudRunV2.Inputs.ServiceTemplateContainerArgs
        ///                 {
        ///                     Image = myImage.Apply(getDockerImageResult =&gt; getDockerImageResult.SelfLink),
        ///                 },
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Task<GetDockerImageResult> InvokeAsync(GetDockerImageArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetDockerImageResult>("gcp:artifactregistry/getDockerImage:getDockerImage", args ?? new GetDockerImageArgs(), options.WithDefaults());

        /// <summary>
        /// This data source fetches information from a provided Artifact Registry repository, including the fully qualified name and URI for an image, based on a the latest version of image name and optional digest or tag.
        /// 
        /// &gt; **Note**
        /// Requires one of the following OAuth scopes: `https://www.googleapis.com/auth/cloud-platform` or `https://www.googleapis.com/auth/cloud-platform.read-only`.
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Gcp = Pulumi.Gcp;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var myRepo = new Gcp.ArtifactRegistry.Repository("my_repo", new()
        ///     {
        ///         Location = "us-west1",
        ///         RepositoryId = "my-repository",
        ///         Format = "DOCKER",
        ///     });
        /// 
        ///     var myImage = Gcp.ArtifactRegistry.GetDockerImage.Invoke(new()
        ///     {
        ///         Location = myRepo.Location,
        ///         RepositoryId = myRepo.RepositoryId,
        ///         ImageName = "my-image:my-tag",
        ///     });
        /// 
        ///     var @default = new Gcp.CloudRunV2.Service("default", new()
        ///     {
        ///         Template = new Gcp.CloudRunV2.Inputs.ServiceTemplateArgs
        ///         {
        ///             Containers = new[]
        ///             {
        ///                 new Gcp.CloudRunV2.Inputs.ServiceTemplateContainerArgs
        ///                 {
        ///                     Image = myImage.Apply(getDockerImageResult =&gt; getDockerImageResult.SelfLink),
        ///                 },
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetDockerImageResult> Invoke(GetDockerImageInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetDockerImageResult>("gcp:artifactregistry/getDockerImage:getDockerImage", args ?? new GetDockerImageInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetDockerImageArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The image name to fetch. If no digest or tag is provided, then the latest modified image will be used.
        /// </summary>
        [Input("imageName", required: true)]
        public string ImageName { get; set; } = null!;

        /// <summary>
        /// The location of the artifact registry.
        /// </summary>
        [Input("location", required: true)]
        public string Location { get; set; } = null!;

        /// <summary>
        /// The project ID in which the resource belongs. If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public string? Project { get; set; }

        /// <summary>
        /// The last part of the repository name to fetch from.
        /// </summary>
        [Input("repositoryId", required: true)]
        public string RepositoryId { get; set; } = null!;

        public GetDockerImageArgs()
        {
        }
        public static new GetDockerImageArgs Empty => new GetDockerImageArgs();
    }

    public sealed class GetDockerImageInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The image name to fetch. If no digest or tag is provided, then the latest modified image will be used.
        /// </summary>
        [Input("imageName", required: true)]
        public Input<string> ImageName { get; set; } = null!;

        /// <summary>
        /// The location of the artifact registry.
        /// </summary>
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        /// <summary>
        /// The project ID in which the resource belongs. If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The last part of the repository name to fetch from.
        /// </summary>
        [Input("repositoryId", required: true)]
        public Input<string> RepositoryId { get; set; } = null!;

        public GetDockerImageInvokeArgs()
        {
        }
        public static new GetDockerImageInvokeArgs Empty => new GetDockerImageInvokeArgs();
    }


    [OutputType]
    public sealed class GetDockerImageResult
    {
        /// <summary>
        /// The time, as a RFC 3339 string, this image was built.
        /// </summary>
        public readonly string BuildTime;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        public readonly string ImageName;
        /// <summary>
        /// Calculated size of the image in bytes.
        /// </summary>
        public readonly string ImageSizeBytes;
        public readonly string Location;
        /// <summary>
        /// Media type of this image, e.g. `application/vnd.docker.distribution.manifest.v2+json`.
        /// </summary>
        public readonly string MediaType;
        /// <summary>
        /// The fully qualified name of the fetched image.  This name has the form: `projects/{{project}}/locations/{{location}}/repository/{{repository_id}}/dockerImages/{{docker_image}}`. For example, 
        /// ```
        /// projects/test-project/locations/us-west4/repositories/test-repo/dockerImages/nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf
        /// ```
        /// </summary>
        public readonly string Name;
        public readonly string? Project;
        public readonly string RepositoryId;
        /// <summary>
        /// The URI to access the image.  For example, 
        /// ```
        /// us-west4-docker.pkg.dev/test-project/test-repo/nginx@sha256:e9954c1fc875017be1c3e36eca16be2d9e9bccc4bf072163515467d6a823c7cf
        /// ```
        /// </summary>
        public readonly string SelfLink;
        /// <summary>
        /// A list of all tags associated with the image.
        /// </summary>
        public readonly ImmutableArray<string> Tags;
        /// <summary>
        /// The time, as a RFC 3339 string, this image was updated.
        /// </summary>
        public readonly string UpdateTime;
        /// <summary>
        /// The time, as a RFC 3339 string, the image was uploaded. For example, `2014-10-02T15:01:23.045123456Z`.
        /// </summary>
        public readonly string UploadTime;

        [OutputConstructor]
        private GetDockerImageResult(
            string buildTime,

            string id,

            string imageName,

            string imageSizeBytes,

            string location,

            string mediaType,

            string name,

            string? project,

            string repositoryId,

            string selfLink,

            ImmutableArray<string> tags,

            string updateTime,

            string uploadTime)
        {
            BuildTime = buildTime;
            Id = id;
            ImageName = imageName;
            ImageSizeBytes = imageSizeBytes;
            Location = location;
            MediaType = mediaType;
            Name = name;
            Project = project;
            RepositoryId = repositoryId;
            SelfLink = selfLink;
            Tags = tags;
            UpdateTime = updateTime;
            UploadTime = uploadTime;
        }
    }
}
