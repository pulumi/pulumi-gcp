// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.NetworkSecurity
{
    /// <summary>
    /// ServerTlsPolicy is a resource that specifies how a server should authenticate incoming requests. This resource itself does not affect configuration unless it is attached to a target HTTPS proxy or endpoint config selector resource.
    /// 
    /// To get more information about ServerTlsPolicy, see:
    /// 
    /// * [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-security/rest/v1beta1/projects.locations.serverTlsPolicies)
    /// 
    /// ## Example Usage
    /// 
    /// ### Network Security Server Tls Policy Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    ///     {
    ///         Name = "my-server-tls-policy",
    ///         Labels = 
    ///         {
    ///             { "foo", "bar" },
    ///         },
    ///         Description = "my description",
    ///         AllowOpen = false,
    ///         ServerCertificate = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateArgs
    ///         {
    ///             CertificateProviderInstance = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs
    ///             {
    ///                 PluginInstance = "google_cloud_private_spiffe",
    ///             },
    ///         },
    ///         MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
    ///         {
    ///             ClientValidationCas = new[]
    ///             {
    ///                 new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyClientValidationCaArgs
    ///                 {
    ///                     GrpcEndpoint = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs
    ///                     {
    ///                         TargetUri = "unix:mypath",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Network Security Server Tls Policy Advanced
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    ///     {
    ///         Name = "my-server-tls-policy",
    ///         Labels = 
    ///         {
    ///             { "foo", "bar" },
    ///         },
    ///         Description = "my description",
    ///         Location = "global",
    ///         AllowOpen = false,
    ///         MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
    ///         {
    ///             ClientValidationMode = "ALLOW_INVALID_OR_MISSING_CLIENT_CERT",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Network Security Server Tls Policy Server Cert
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    ///     {
    ///         Name = "my-server-tls-policy",
    ///         Labels = 
    ///         {
    ///             { "foo", "bar" },
    ///         },
    ///         Description = "my description",
    ///         Location = "global",
    ///         AllowOpen = false,
    ///         ServerCertificate = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateArgs
    ///         {
    ///             GrpcEndpoint = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateGrpcEndpointArgs
    ///             {
    ///                 TargetUri = "unix:mypath",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Network Security Server Tls Policy Mtls
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// using Std = Pulumi.Std;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    ///     var defaultTrustConfig = new Gcp.CertificateManager.TrustConfig("default", new()
    ///     {
    ///         Name = "my-trust-config",
    ///         Description = "sample trust config description",
    ///         Location = "global",
    ///         TrustStores = new[]
    ///         {
    ///             new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreArgs
    ///             {
    ///                 TrustAnchors = new[]
    ///                 {
    ///                     new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreTrustAnchorArgs
    ///                     {
    ///                         PemCertificate = Std.File.Invoke(new()
    ///                         {
    ///                             Input = "test-fixtures/ca_cert.pem",
    ///                         }).Apply(invoke =&gt; invoke.Result),
    ///                     },
    ///                 },
    ///                 IntermediateCas = new[]
    ///                 {
    ///                     new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreIntermediateCaArgs
    ///                     {
    ///                         PemCertificate = Std.File.Invoke(new()
    ///                         {
    ///                             Input = "test-fixtures/ca_cert.pem",
    ///                         }).Apply(invoke =&gt; invoke.Result),
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         Labels = 
    ///         {
    ///             { "foo", "bar" },
    ///         },
    ///     });
    /// 
    ///     var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    ///     {
    ///         Name = "my-server-tls-policy",
    ///         Description = "my description",
    ///         Location = "global",
    ///         AllowOpen = false,
    ///         MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
    ///         {
    ///             ClientValidationMode = "REJECT_INVALID",
    ///             ClientValidationTrustConfig = Output.Tuple(project, defaultTrustConfig.Name).Apply(values =&gt;
    ///             {
    ///                 var project = values.Item1;
    ///                 var name = values.Item2;
    ///                 return $"projects/{project.Apply(getProjectResult =&gt; getProjectResult.Number)}/locations/global/trustConfigs/{name}";
    ///             }),
    ///         },
    ///         Labels = 
    ///         {
    ///             { "foo", "bar" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ServerTlsPolicy can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}`
    /// 
    /// * `{{project}}/{{location}}/{{name}}`
    /// 
    /// * `{{location}}/{{name}}`
    /// 
    /// When using the `pulumi import` command, ServerTlsPolicy can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{project}}/{{location}}/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{location}}/{{name}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy")]
    public partial class ServerTlsPolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
        /// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
        /// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
        /// </summary>
        [Output("allowOpen")]
        public Output<bool?> AllowOpen { get; private set; } = null!;

        /// <summary>
        /// Time the ServerTlsPolicy was created in UTC.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// A free-text description of the resource. Max length 1024 characters.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        [Output("effectiveLabels")]
        public Output<ImmutableDictionary<string, string>> EffectiveLabels { get; private set; } = null!;

        /// <summary>
        /// Set of label tags associated with the ServerTlsPolicy resource.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `effective_labels` for all of the labels present on the resource.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// The location of the server tls policy.
        /// The default value is `global`.
        /// </summary>
        [Output("location")]
        public Output<string?> Location { get; private set; } = null!;

        /// <summary>
        /// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
        /// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
        /// Structure is documented below.
        /// </summary>
        [Output("mtlsPolicy")]
        public Output<Outputs.ServerTlsPolicyMtlsPolicy?> MtlsPolicy { get; private set; } = null!;

        /// <summary>
        /// Name of the ServerTlsPolicy resource.
        /// 
        /// 
        /// - - -
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        [Output("pulumiLabels")]
        public Output<ImmutableDictionary<string, string>> PulumiLabels { get; private set; } = null!;

        /// <summary>
        /// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
        /// Structure is documented below.
        /// </summary>
        [Output("serverCertificate")]
        public Output<Outputs.ServerTlsPolicyServerCertificate?> ServerCertificate { get; private set; } = null!;

        /// <summary>
        /// Time the ServerTlsPolicy was updated in UTC.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;


        /// <summary>
        /// Create a ServerTlsPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ServerTlsPolicy(string name, ServerTlsPolicyArgs? args = null, CustomResourceOptions? options = null)
            : base("gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy", name, args ?? new ServerTlsPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ServerTlsPolicy(string name, Input<string> id, ServerTlsPolicyState? state = null, CustomResourceOptions? options = null)
            : base("gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "effectiveLabels",
                    "pulumiLabels",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ServerTlsPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ServerTlsPolicy Get(string name, Input<string> id, ServerTlsPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ServerTlsPolicy(name, id, state, options);
        }
    }

    public sealed class ServerTlsPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
        /// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
        /// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
        /// </summary>
        [Input("allowOpen")]
        public Input<bool>? AllowOpen { get; set; }

        /// <summary>
        /// A free-text description of the resource. Max length 1024 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Set of label tags associated with the ServerTlsPolicy resource.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `effective_labels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// The location of the server tls policy.
        /// The default value is `global`.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
        /// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
        /// Structure is documented below.
        /// </summary>
        [Input("mtlsPolicy")]
        public Input<Inputs.ServerTlsPolicyMtlsPolicyArgs>? MtlsPolicy { get; set; }

        /// <summary>
        /// Name of the ServerTlsPolicy resource.
        /// 
        /// 
        /// - - -
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
        /// Structure is documented below.
        /// </summary>
        [Input("serverCertificate")]
        public Input<Inputs.ServerTlsPolicyServerCertificateArgs>? ServerCertificate { get; set; }

        public ServerTlsPolicyArgs()
        {
        }
        public static new ServerTlsPolicyArgs Empty => new ServerTlsPolicyArgs();
    }

    public sealed class ServerTlsPolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
        /// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
        /// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
        /// </summary>
        [Input("allowOpen")]
        public Input<bool>? AllowOpen { get; set; }

        /// <summary>
        /// Time the ServerTlsPolicy was created in UTC.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// A free-text description of the resource. Max length 1024 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("effectiveLabels")]
        private InputMap<string>? _effectiveLabels;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveLabels
        {
            get => _effectiveLabels ?? (_effectiveLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _effectiveLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Set of label tags associated with the ServerTlsPolicy resource.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `effective_labels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// The location of the server tls policy.
        /// The default value is `global`.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
        /// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
        /// Structure is documented below.
        /// </summary>
        [Input("mtlsPolicy")]
        public Input<Inputs.ServerTlsPolicyMtlsPolicyGetArgs>? MtlsPolicy { get; set; }

        /// <summary>
        /// Name of the ServerTlsPolicy resource.
        /// 
        /// 
        /// - - -
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("pulumiLabels")]
        private InputMap<string>? _pulumiLabels;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        public InputMap<string> PulumiLabels
        {
            get => _pulumiLabels ?? (_pulumiLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _pulumiLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
        /// Structure is documented below.
        /// </summary>
        [Input("serverCertificate")]
        public Input<Inputs.ServerTlsPolicyServerCertificateGetArgs>? ServerCertificate { get; set; }

        /// <summary>
        /// Time the ServerTlsPolicy was updated in UTC.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        public ServerTlsPolicyState()
        {
        }
        public static new ServerTlsPolicyState Empty => new ServerTlsPolicyState();
    }
}
