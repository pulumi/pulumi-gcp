// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Apigee.Outputs
{

    [OutputType]
    public sealed class TargetServerSSlInfo
    {
        /// <summary>
        /// The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
        /// </summary>
        public readonly ImmutableArray<string> Ciphers;
        /// <summary>
        /// Enables two-way TLS.
        /// </summary>
        public readonly bool? ClientAuthEnabled;
        /// <summary>
        /// The TLS Common Name of the certificate.
        /// Structure is documented below.
        /// </summary>
        public readonly Outputs.TargetServerSSlInfoCommonName? CommonName;
        /// <summary>
        /// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        /// </summary>
        public readonly bool Enabled;
        /// <summary>
        /// If true, TLS is strictly enforced.
        /// </summary>
        public readonly bool? Enforce;
        /// <summary>
        /// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        /// </summary>
        public readonly bool? IgnoreValidationErrors;
        /// <summary>
        /// Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
        /// </summary>
        public readonly string? KeyAlias;
        /// <summary>
        /// Required if clientAuthEnabled is true. The resource ID of the keystore.
        /// </summary>
        public readonly string? KeyStore;
        /// <summary>
        /// The TLS versioins to be used.
        /// </summary>
        public readonly ImmutableArray<string> Protocols;
        /// <summary>
        /// The resource ID of the truststore.
        /// </summary>
        public readonly string? TrustStore;

        [OutputConstructor]
        private TargetServerSSlInfo(
            ImmutableArray<string> ciphers,

            bool? clientAuthEnabled,

            Outputs.TargetServerSSlInfoCommonName? commonName,

            bool enabled,

            bool? enforce,

            bool? ignoreValidationErrors,

            string? keyAlias,

            string? keyStore,

            ImmutableArray<string> protocols,

            string? trustStore)
        {
            Ciphers = ciphers;
            ClientAuthEnabled = clientAuthEnabled;
            CommonName = commonName;
            Enabled = enabled;
            Enforce = enforce;
            IgnoreValidationErrors = ignoreValidationErrors;
            KeyAlias = keyAlias;
            KeyStore = keyStore;
            Protocols = protocols;
            TrustStore = trustStore;
        }
    }
}
