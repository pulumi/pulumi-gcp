// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Apigee.Inputs
{

    public sealed class TargetServerSSlInfoGetArgs : global::Pulumi.ResourceArgs
    {
        [Input("ciphers")]
        private InputList<string>? _ciphers;

        /// <summary>
        /// The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
        /// </summary>
        public InputList<string> Ciphers
        {
            get => _ciphers ?? (_ciphers = new InputList<string>());
            set => _ciphers = value;
        }

        /// <summary>
        /// Enables two-way TLS.
        /// </summary>
        [Input("clientAuthEnabled")]
        public Input<bool>? ClientAuthEnabled { get; set; }

        /// <summary>
        /// The TLS Common Name of the certificate.
        /// Structure is documented below.
        /// </summary>
        [Input("commonName")]
        public Input<Inputs.TargetServerSSlInfoCommonNameGetArgs>? CommonName { get; set; }

        /// <summary>
        /// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        /// </summary>
        [Input("enabled", required: true)]
        public Input<bool> Enabled { get; set; } = null!;

        /// <summary>
        /// If true, TLS is strictly enforced.
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        /// </summary>
        [Input("ignoreValidationErrors")]
        public Input<bool>? IgnoreValidationErrors { get; set; }

        /// <summary>
        /// Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
        /// </summary>
        [Input("keyAlias")]
        public Input<string>? KeyAlias { get; set; }

        /// <summary>
        /// Required if clientAuthEnabled is true. The resource ID of the keystore.
        /// </summary>
        [Input("keyStore")]
        public Input<string>? KeyStore { get; set; }

        [Input("protocols")]
        private InputList<string>? _protocols;

        /// <summary>
        /// The TLS versioins to be used.
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// The resource ID of the truststore.
        /// </summary>
        [Input("trustStore")]
        public Input<string>? TrustStore { get; set; }

        public TargetServerSSlInfoGetArgs()
        {
        }
        public static new TargetServerSSlInfoGetArgs Empty => new TargetServerSSlInfoGetArgs();
    }
}
