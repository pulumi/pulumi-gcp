// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.GkeBackup.Inputs
{

    public sealed class RestorePlanRestoreConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If True, restore all namespaced resources in the Backup.
        /// Setting this field to False will result in an error.
        /// </summary>
        [Input("allNamespaces")]
        public Input<bool>? AllNamespaces { get; set; }

        /// <summary>
        /// Defines the behavior for handling the situation where cluster-scoped resources
        /// being restored already exist in the target cluster.
        /// This MUST be set to a value other than `CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED`
        /// if `clusterResourceRestoreScope` is anyting other than `noGroupKinds`.
        /// See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#clusterresourceconflictpolicy
        /// for more information on each policy option.
        /// Possible values are: `USE_EXISTING_VERSION`, `USE_BACKUP_VERSION`.
        /// </summary>
        [Input("clusterResourceConflictPolicy")]
        public Input<string>? ClusterResourceConflictPolicy { get; set; }

        /// <summary>
        /// Identifies the cluster-scoped resources to restore from the Backup.
        /// Structure is documented below.
        /// </summary>
        [Input("clusterResourceRestoreScope")]
        public Input<Inputs.RestorePlanRestoreConfigClusterResourceRestoreScopeArgs>? ClusterResourceRestoreScope { get; set; }

        /// <summary>
        /// A list of selected namespaces excluded from restoration.
        /// All namespaces except those in this list will be restored.
        /// Structure is documented below.
        /// </summary>
        [Input("excludedNamespaces")]
        public Input<Inputs.RestorePlanRestoreConfigExcludedNamespacesArgs>? ExcludedNamespaces { get; set; }

        /// <summary>
        /// Defines the behavior for handling the situation where sets of namespaced resources
        /// being restored already exist in the target cluster.
        /// This MUST be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
        /// if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
        /// See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#namespacedresourcerestoremode
        /// for more information on each mode.
        /// Possible values are: `DELETE_AND_RESTORE`, `FAIL_ON_CONFLICT`, `MERGE_SKIP_ON_CONFLICT`, `MERGE_REPLACE_VOLUME_ON_CONFLICT`, `MERGE_REPLACE_ON_CONFLICT`.
        /// </summary>
        [Input("namespacedResourceRestoreMode")]
        public Input<string>? NamespacedResourceRestoreMode { get; set; }

        /// <summary>
        /// Do not restore any namespaced resources if set to "True".
        /// Specifying this field to "False" is not allowed.
        /// </summary>
        [Input("noNamespaces")]
        public Input<bool>? NoNamespaces { get; set; }

        /// <summary>
        /// It contains custom ordering to use on a Restore.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreOrder")]
        public Input<Inputs.RestorePlanRestoreConfigRestoreOrderArgs>? RestoreOrder { get; set; }

        /// <summary>
        /// A list of selected ProtectedApplications to restore.
        /// The listed ProtectedApplications and all the resources
        /// to which they refer will be restored.
        /// Structure is documented below.
        /// </summary>
        [Input("selectedApplications")]
        public Input<Inputs.RestorePlanRestoreConfigSelectedApplicationsArgs>? SelectedApplications { get; set; }

        /// <summary>
        /// A list of selected namespaces to restore from the Backup.
        /// The listed Namespaces and all resources contained in them will be restored.
        /// Structure is documented below.
        /// </summary>
        [Input("selectedNamespaces")]
        public Input<Inputs.RestorePlanRestoreConfigSelectedNamespacesArgs>? SelectedNamespaces { get; set; }

        [Input("transformationRules")]
        private InputList<Inputs.RestorePlanRestoreConfigTransformationRuleArgs>? _transformationRules;

        /// <summary>
        /// A list of transformation rules to be applied against Kubernetes
        /// resources as they are selected for restoration from a Backup.
        /// Rules are executed in order defined - this order matters,
        /// as changes made by a rule may impact the filtering logic of subsequent
        /// rules. An empty list means no transformation will occur.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.RestorePlanRestoreConfigTransformationRuleArgs> TransformationRules
        {
            get => _transformationRules ?? (_transformationRules = new InputList<Inputs.RestorePlanRestoreConfigTransformationRuleArgs>());
            set => _transformationRules = value;
        }

        /// <summary>
        /// Specifies the mechanism to be used to restore volume data.
        /// This should be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
        /// if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
        /// If not specified, it will be treated as `NO_VOLUME_DATA_RESTORATION`.
        /// See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
        /// for more information on each policy option.
        /// Possible values are: `RESTORE_VOLUME_DATA_FROM_BACKUP`, `REUSE_VOLUME_HANDLE_FROM_BACKUP`, `NO_VOLUME_DATA_RESTORATION`.
        /// </summary>
        [Input("volumeDataRestorePolicy")]
        public Input<string>? VolumeDataRestorePolicy { get; set; }

        [Input("volumeDataRestorePolicyBindings")]
        private InputList<Inputs.RestorePlanRestoreConfigVolumeDataRestorePolicyBindingArgs>? _volumeDataRestorePolicyBindings;

        /// <summary>
        /// A table that binds volumes by their scope to a restore policy. Bindings
        /// must have a unique scope. Any volumes not scoped in the bindings are
        /// subject to the policy defined in volume_data_restore_policy.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.RestorePlanRestoreConfigVolumeDataRestorePolicyBindingArgs> VolumeDataRestorePolicyBindings
        {
            get => _volumeDataRestorePolicyBindings ?? (_volumeDataRestorePolicyBindings = new InputList<Inputs.RestorePlanRestoreConfigVolumeDataRestorePolicyBindingArgs>());
            set => _volumeDataRestorePolicyBindings = value;
        }

        public RestorePlanRestoreConfigArgs()
        {
        }
        public static new RestorePlanRestoreConfigArgs Empty => new RestorePlanRestoreConfigArgs();
    }
}
