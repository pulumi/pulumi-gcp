// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Dataproc
{
    /// <summary>
    /// A service instance is an instance of the Dataproc operator running on a GDC cluster.
    /// 
    /// To get more information about ServiceInstance, see:
    /// 
    /// * [API documentation](https://cloud.google.com/dataproc-gdc/docs/reference/rest/v1/projects.locations.serviceInstances)
    /// * How-to Guides
    ///     * [Dataproc Intro](https://cloud.google.com/dataproc/)
    /// 
    /// ## Example Usage
    /// 
    /// ### Dataprocgdc Serviceinstance
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var service_instance = new Gcp.Dataproc.GdcServiceInstance("service-instance", new()
    ///     {
    ///         ServiceInstanceId = "tf-e2e-service-instance",
    ///         Project = "my-project",
    ///         Location = "us-west2",
    ///         GdceCluster = new Gcp.Dataproc.Inputs.GdcServiceInstanceGdceClusterArgs
    ///         {
    ///             GdceCluster = "projects/gdce-cluster-monitoring/locations/us-west2/clusters/gdce-prism-prober-ord106",
    ///         },
    ///         DisplayName = "A service instance",
    ///         Labels = 
    ///         {
    ///             { "test-label", "label-value" },
    ///         },
    ///         ServiceAccount = "dataprocgdc-cep-workflows@gdce-cluster-monitoring.iam.gserviceaccount.com",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ServiceInstance can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/serviceInstances/{{service_instance_id}}`
    /// * `{{project}}/{{location}}/{{service_instance_id}}`
    /// * `{{location}}/{{service_instance_id}}`
    /// 
    /// When using the `pulumi import` command, ServiceInstance can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:dataproc/gdcServiceInstance:GdcServiceInstance default projects/{{project}}/locations/{{location}}/serviceInstances/{{service_instance_id}}
    /// $ pulumi import gcp:dataproc/gdcServiceInstance:GdcServiceInstance default {{project}}/{{location}}/{{service_instance_id}}
    /// $ pulumi import gcp:dataproc/gdcServiceInstance:GdcServiceInstance default {{location}}/{{service_instance_id}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:dataproc/gdcServiceInstance:GdcServiceInstance")]
    public partial class GdcServiceInstance : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The timestamp when the resource was created.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// User-provided human-readable name to be used in user interfaces.
        /// </summary>
        [Output("displayName")]
        public Output<string?> DisplayName { get; private set; } = null!;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        [Output("effectiveLabels")]
        public Output<ImmutableDictionary<string, string>> EffectiveLabels { get; private set; } = null!;

        /// <summary>
        /// Effective service account associated with ServiceInstance. This will be the ServiceAccount if specified. Otherwise, it will be an automatically created per-resource P4SA that also automatically has Fleet Workload. Identity bindings applied.
        /// </summary>
        [Output("effectiveServiceAccount")]
        public Output<string> EffectiveServiceAccount { get; private set; } = null!;

        /// <summary>
        /// Gdce cluster information.
        /// Structure is documented below.
        /// </summary>
        [Output("gdceCluster")]
        public Output<Outputs.GdcServiceInstanceGdceCluster?> GdceCluster { get; private set; } = null!;

        /// <summary>
        /// The labels to associate with this service instance. Labels may be used for filtering and billing tracking.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Location of the resource.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Identifier. The name of the service instance.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The combination of labels configured directly on the resource
        ///  and default labels configured on the provider.
        /// </summary>
        [Output("pulumiLabels")]
        public Output<ImmutableDictionary<string, string>> PulumiLabels { get; private set; } = null!;

        /// <summary>
        /// Whether the service instance is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
        /// </summary>
        [Output("reconciling")]
        public Output<bool> Reconciling { get; private set; } = null!;

        /// <summary>
        /// The intended state to which the service instance is reconciling. Possible values:
        /// * `CREATING`
        /// * `ACTIVE`
        /// * `DISCONNECTED`
        /// * `DELETING`
        /// * `STOPPING`
        /// * `STOPPED`
        /// * `STARTING`
        /// * `UPDATING`
        /// * `FAILED`
        /// </summary>
        [Output("requestedState")]
        public Output<string> RequestedState { get; private set; } = null!;

        /// <summary>
        /// Requested service account to associate with ServiceInstance.
        /// </summary>
        [Output("serviceAccount")]
        public Output<string?> ServiceAccount { get; private set; } = null!;

        /// <summary>
        /// Id of the service instance.
        /// </summary>
        [Output("serviceInstanceId")]
        public Output<string> ServiceInstanceId { get; private set; } = null!;

        /// <summary>
        /// Spark-specific service instance configuration.
        /// </summary>
        [Output("sparkServiceInstanceConfig")]
        public Output<Outputs.GdcServiceInstanceSparkServiceInstanceConfig?> SparkServiceInstanceConfig { get; private set; } = null!;

        /// <summary>
        /// The current state. Possible values:
        /// * `CREATING`
        /// * `ACTIVE`
        /// * `DISCONNECTED`
        /// * `DELETING`
        /// * `STOPPING`
        /// * `STOPPED`
        /// * `STARTING`
        /// * `UPDATING`
        /// * `FAILED`
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// A message explaining the current state.
        /// </summary>
        [Output("stateMessage")]
        public Output<string> StateMessage { get; private set; } = null!;

        /// <summary>
        /// System generated unique identifier for this service instance, formatted as UUID4.
        /// </summary>
        [Output("uid")]
        public Output<string> Uid { get; private set; } = null!;

        /// <summary>
        /// The timestamp when the resource was most recently updated.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;


        /// <summary>
        /// Create a GdcServiceInstance resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public GdcServiceInstance(string name, GdcServiceInstanceArgs args, CustomResourceOptions? options = null)
            : base("gcp:dataproc/gdcServiceInstance:GdcServiceInstance", name, args ?? new GdcServiceInstanceArgs(), MakeResourceOptions(options, ""))
        {
        }

        private GdcServiceInstance(string name, Input<string> id, GdcServiceInstanceState? state = null, CustomResourceOptions? options = null)
            : base("gcp:dataproc/gdcServiceInstance:GdcServiceInstance", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "effectiveLabels",
                    "pulumiLabels",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing GdcServiceInstance resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static GdcServiceInstance Get(string name, Input<string> id, GdcServiceInstanceState? state = null, CustomResourceOptions? options = null)
        {
            return new GdcServiceInstance(name, id, state, options);
        }
    }

    public sealed class GdcServiceInstanceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// User-provided human-readable name to be used in user interfaces.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// Gdce cluster information.
        /// Structure is documented below.
        /// </summary>
        [Input("gdceCluster")]
        public Input<Inputs.GdcServiceInstanceGdceClusterArgs>? GdceCluster { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// The labels to associate with this service instance. Labels may be used for filtering and billing tracking.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Location of the resource.
        /// </summary>
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Requested service account to associate with ServiceInstance.
        /// </summary>
        [Input("serviceAccount")]
        public Input<string>? ServiceAccount { get; set; }

        /// <summary>
        /// Id of the service instance.
        /// </summary>
        [Input("serviceInstanceId", required: true)]
        public Input<string> ServiceInstanceId { get; set; } = null!;

        /// <summary>
        /// Spark-specific service instance configuration.
        /// </summary>
        [Input("sparkServiceInstanceConfig")]
        public Input<Inputs.GdcServiceInstanceSparkServiceInstanceConfigArgs>? SparkServiceInstanceConfig { get; set; }

        public GdcServiceInstanceArgs()
        {
        }
        public static new GdcServiceInstanceArgs Empty => new GdcServiceInstanceArgs();
    }

    public sealed class GdcServiceInstanceState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The timestamp when the resource was created.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// User-provided human-readable name to be used in user interfaces.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        [Input("effectiveLabels")]
        private InputMap<string>? _effectiveLabels;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveLabels
        {
            get => _effectiveLabels ?? (_effectiveLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _effectiveLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Effective service account associated with ServiceInstance. This will be the ServiceAccount if specified. Otherwise, it will be an automatically created per-resource P4SA that also automatically has Fleet Workload. Identity bindings applied.
        /// </summary>
        [Input("effectiveServiceAccount")]
        public Input<string>? EffectiveServiceAccount { get; set; }

        /// <summary>
        /// Gdce cluster information.
        /// Structure is documented below.
        /// </summary>
        [Input("gdceCluster")]
        public Input<Inputs.GdcServiceInstanceGdceClusterGetArgs>? GdceCluster { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// The labels to associate with this service instance. Labels may be used for filtering and billing tracking.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Location of the resource.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Identifier. The name of the service instance.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("pulumiLabels")]
        private InputMap<string>? _pulumiLabels;

        /// <summary>
        /// The combination of labels configured directly on the resource
        ///  and default labels configured on the provider.
        /// </summary>
        public InputMap<string> PulumiLabels
        {
            get => _pulumiLabels ?? (_pulumiLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _pulumiLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Whether the service instance is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
        /// </summary>
        [Input("reconciling")]
        public Input<bool>? Reconciling { get; set; }

        /// <summary>
        /// The intended state to which the service instance is reconciling. Possible values:
        /// * `CREATING`
        /// * `ACTIVE`
        /// * `DISCONNECTED`
        /// * `DELETING`
        /// * `STOPPING`
        /// * `STOPPED`
        /// * `STARTING`
        /// * `UPDATING`
        /// * `FAILED`
        /// </summary>
        [Input("requestedState")]
        public Input<string>? RequestedState { get; set; }

        /// <summary>
        /// Requested service account to associate with ServiceInstance.
        /// </summary>
        [Input("serviceAccount")]
        public Input<string>? ServiceAccount { get; set; }

        /// <summary>
        /// Id of the service instance.
        /// </summary>
        [Input("serviceInstanceId")]
        public Input<string>? ServiceInstanceId { get; set; }

        /// <summary>
        /// Spark-specific service instance configuration.
        /// </summary>
        [Input("sparkServiceInstanceConfig")]
        public Input<Inputs.GdcServiceInstanceSparkServiceInstanceConfigGetArgs>? SparkServiceInstanceConfig { get; set; }

        /// <summary>
        /// The current state. Possible values:
        /// * `CREATING`
        /// * `ACTIVE`
        /// * `DISCONNECTED`
        /// * `DELETING`
        /// * `STOPPING`
        /// * `STOPPED`
        /// * `STARTING`
        /// * `UPDATING`
        /// * `FAILED`
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// A message explaining the current state.
        /// </summary>
        [Input("stateMessage")]
        public Input<string>? StateMessage { get; set; }

        /// <summary>
        /// System generated unique identifier for this service instance, formatted as UUID4.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// The timestamp when the resource was most recently updated.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        public GdcServiceInstanceState()
        {
        }
        public static new GdcServiceInstanceState Empty => new GdcServiceInstanceState();
    }
}
