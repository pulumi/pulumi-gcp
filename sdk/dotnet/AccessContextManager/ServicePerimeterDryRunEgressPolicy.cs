// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.AccessContextManager
{
    /// <summary>
    /// Manage a single EgressPolicy in the spec (dry-run) configuration for a service perimeter.
    /// EgressPolicies match requests based on egressFrom and egressTo stanzas.
    /// For an EgressPolicy to match, both egressFrom and egressTo stanzas must be matched.
    /// If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter
    /// boundary. For example, an EgressPolicy can be used to allow VMs on networks
    /// within the ServicePerimeter to access a defined set of projects outside the
    /// perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket
    /// or query against a BigQuery dataset).
    /// 
    /// &gt; **Note:** By default, updates to this resource will remove the EgressPolicy from the
    /// from the perimeter and add it back in a non-atomic manner. To ensure that the new EgressPolicy
    /// is added before the old one is removed, add a `Lifecycle` block with `CreateBeforeDestroy = true` to this resource.
    /// **Note:** If this resource is used alongside a `gcp.accesscontextmanager.ServicePerimeter` resource,
    /// the service perimeter resource must have a `Lifecycle` block with `IgnoreChanges = [spec[0].egress_policies]` so
    /// they don't fight over which egress rules should be in the policy.
    /// 
    /// To get more information about ServicePerimeterDryRunEgressPolicy, see:
    /// 
    /// * [API documentation](https://cloud.google.com/access-context-manager/docs/reference/rest/v1/accessPolicies.servicePerimeters#egresspolicy)
    /// * How-to Guides
    ///     * [Guide to Ingress and Egress Rules](https://cloud.google.com/vpc-service-controls/docs/ingress-egress-rules)
    /// 
    /// ## Example Usage
    /// </summary>
    [GcpResourceType("gcp:accesscontextmanager/servicePerimeterDryRunEgressPolicy:ServicePerimeterDryRunEgressPolicy")]
    public partial class ServicePerimeterDryRunEgressPolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The name of the Access Policy this resource belongs to.
        /// </summary>
        [Output("accessPolicyId")]
        public Output<string> AccessPolicyId { get; private set; } = null!;

        /// <summary>
        /// Defines conditions on the source of a request causing this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Output("egressFrom")]
        public Output<Outputs.ServicePerimeterDryRunEgressPolicyEgressFrom?> EgressFrom { get; private set; } = null!;

        /// <summary>
        /// Defines the conditions on the `ApiOperation` and destination resources that
        /// cause this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Output("egressTo")]
        public Output<Outputs.ServicePerimeterDryRunEgressPolicyEgressTo?> EgressTo { get; private set; } = null!;

        /// <summary>
        /// The perimeter etag is internally used to prevent overwriting the list of policies on PATCH calls. It is retrieved from the same GET perimeter API call that's used to get the current list of policies. The policy defined in this resource is added or removed from that list, and then this etag is sent with the PATCH call along with the updated policies.
        /// </summary>
        [Output("etag")]
        public Output<string> Etag { get; private set; } = null!;

        /// <summary>
        /// The name of the Service Perimeter to add this resource to.
        /// </summary>
        [Output("perimeter")]
        public Output<string> Perimeter { get; private set; } = null!;

        /// <summary>
        /// Human readable title. Must be unique within the perimeter. Does not affect behavior.
        /// </summary>
        [Output("title")]
        public Output<string?> Title { get; private set; } = null!;


        /// <summary>
        /// Create a ServicePerimeterDryRunEgressPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ServicePerimeterDryRunEgressPolicy(string name, ServicePerimeterDryRunEgressPolicyArgs args, CustomResourceOptions? options = null)
            : base("gcp:accesscontextmanager/servicePerimeterDryRunEgressPolicy:ServicePerimeterDryRunEgressPolicy", name, args ?? new ServicePerimeterDryRunEgressPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ServicePerimeterDryRunEgressPolicy(string name, Input<string> id, ServicePerimeterDryRunEgressPolicyState? state = null, CustomResourceOptions? options = null)
            : base("gcp:accesscontextmanager/servicePerimeterDryRunEgressPolicy:ServicePerimeterDryRunEgressPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ServicePerimeterDryRunEgressPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ServicePerimeterDryRunEgressPolicy Get(string name, Input<string> id, ServicePerimeterDryRunEgressPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ServicePerimeterDryRunEgressPolicy(name, id, state, options);
        }
    }

    public sealed class ServicePerimeterDryRunEgressPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Defines conditions on the source of a request causing this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Input("egressFrom")]
        public Input<Inputs.ServicePerimeterDryRunEgressPolicyEgressFromArgs>? EgressFrom { get; set; }

        /// <summary>
        /// Defines the conditions on the `ApiOperation` and destination resources that
        /// cause this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Input("egressTo")]
        public Input<Inputs.ServicePerimeterDryRunEgressPolicyEgressToArgs>? EgressTo { get; set; }

        /// <summary>
        /// The name of the Service Perimeter to add this resource to.
        /// </summary>
        [Input("perimeter", required: true)]
        public Input<string> Perimeter { get; set; } = null!;

        /// <summary>
        /// Human readable title. Must be unique within the perimeter. Does not affect behavior.
        /// </summary>
        [Input("title")]
        public Input<string>? Title { get; set; }

        public ServicePerimeterDryRunEgressPolicyArgs()
        {
        }
        public static new ServicePerimeterDryRunEgressPolicyArgs Empty => new ServicePerimeterDryRunEgressPolicyArgs();
    }

    public sealed class ServicePerimeterDryRunEgressPolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of the Access Policy this resource belongs to.
        /// </summary>
        [Input("accessPolicyId")]
        public Input<string>? AccessPolicyId { get; set; }

        /// <summary>
        /// Defines conditions on the source of a request causing this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Input("egressFrom")]
        public Input<Inputs.ServicePerimeterDryRunEgressPolicyEgressFromGetArgs>? EgressFrom { get; set; }

        /// <summary>
        /// Defines the conditions on the `ApiOperation` and destination resources that
        /// cause this `EgressPolicy` to apply.
        /// Structure is documented below.
        /// </summary>
        [Input("egressTo")]
        public Input<Inputs.ServicePerimeterDryRunEgressPolicyEgressToGetArgs>? EgressTo { get; set; }

        /// <summary>
        /// The perimeter etag is internally used to prevent overwriting the list of policies on PATCH calls. It is retrieved from the same GET perimeter API call that's used to get the current list of policies. The policy defined in this resource is added or removed from that list, and then this etag is sent with the PATCH call along with the updated policies.
        /// </summary>
        [Input("etag")]
        public Input<string>? Etag { get; set; }

        /// <summary>
        /// The name of the Service Perimeter to add this resource to.
        /// </summary>
        [Input("perimeter")]
        public Input<string>? Perimeter { get; set; }

        /// <summary>
        /// Human readable title. Must be unique within the perimeter. Does not affect behavior.
        /// </summary>
        [Input("title")]
        public Input<string>? Title { get; set; }

        public ServicePerimeterDryRunEgressPolicyState()
        {
        }
        public static new ServicePerimeterDryRunEgressPolicyState Empty => new ServicePerimeterDryRunEgressPolicyState();
    }
}
