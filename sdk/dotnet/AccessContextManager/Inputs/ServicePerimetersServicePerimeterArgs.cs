// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.AccessContextManager.Inputs
{

    public sealed class ServicePerimetersServicePerimeterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Output)
        /// Time the AccessPolicy was created in UTC.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// Description of the ServicePerimeter and its use. Does not affect
        /// behavior.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Resource name for the ServicePerimeter. The short_name component must
        /// begin with a letter and only include alphanumeric and '_'.
        /// Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Specifies the type of the Perimeter. There are two types: regular and
        /// bridge. Regular Service Perimeter contains resources, access levels,
        /// and restricted services. Every resource can be in at most
        /// ONE regular Service Perimeter.
        /// In addition to being in a regular service perimeter, a resource can also
        /// be in zero or more perimeter bridges. A perimeter bridge only contains
        /// resources. Cross project operations are permitted if all effected
        /// resources share some perimeter (whether bridge or regular). Perimeter
        /// Bridge does not contain access levels or services: those are governed
        /// entirely by the regular perimeter that resource is in.
        /// Perimeter Bridges are typically useful when building more complex
        /// topologies with many independent perimeters that need to share some data
        /// with a common perimeter, but should not be able to share data among
        /// themselves.
        /// Default value is `PERIMETER_TYPE_REGULAR`.
        /// Possible values are: `PERIMETER_TYPE_REGULAR`, `PERIMETER_TYPE_BRIDGE`.
        /// </summary>
        [Input("perimeterType")]
        public Input<string>? PerimeterType { get; set; }

        /// <summary>
        /// Proposed (or dry run) ServicePerimeter configuration.
        /// This configuration allows to specify and test ServicePerimeter configuration
        /// without enforcing actual access restrictions. Only allowed to be set when
        /// the `useExplicitDryRunSpec` flag is set.
        /// Structure is documented below.
        /// </summary>
        [Input("spec")]
        public Input<Inputs.ServicePerimetersServicePerimeterSpecArgs>? Spec { get; set; }

        /// <summary>
        /// ServicePerimeter configuration. Specifies sets of resources,
        /// restricted services and access levels that determine
        /// perimeter content and boundaries.
        /// Structure is documented below.
        /// </summary>
        [Input("status")]
        public Input<Inputs.ServicePerimetersServicePerimeterStatusArgs>? Status { get; set; }

        /// <summary>
        /// Human readable title. Must be unique within the Policy.
        /// </summary>
        [Input("title", required: true)]
        public Input<string> Title { get; set; } = null!;

        /// <summary>
        /// (Output)
        /// Time the AccessPolicy was updated in UTC.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        /// <summary>
        /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
        /// for all Service Perimeters, and that spec is identical to the status for those
        /// Service Perimeters. When this flag is set, it inhibits the generation of the
        /// implicit spec, thereby allowing the user to explicitly provide a
        /// configuration ("spec") to use in a dry-run version of the Service Perimeter.
        /// This allows the user to test changes to the enforced config ("status") without
        /// actually enforcing them. This testing is done through analyzing the differences
        /// between currently enforced and suggested restrictions. useExplicitDryRunSpec must
        /// bet set to True if any of the fields in the spec are set to non-default values.
        /// </summary>
        [Input("useExplicitDryRunSpec")]
        public Input<bool>? UseExplicitDryRunSpec { get; set; }

        public ServicePerimetersServicePerimeterArgs()
        {
        }
        public static new ServicePerimetersServicePerimeterArgs Empty => new ServicePerimetersServicePerimeterArgs();
    }
}
