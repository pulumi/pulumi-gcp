// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Colab
{
    /// <summary>
    /// 'Colab Enterprise Notebook Execution Schedules.'
    /// 
    /// To get more information about Schedule, see:
    /// 
    /// * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.schedules)
    /// * How-to Guides
    ///     * [Schedule a notebook run](https://cloud.google.com/colab/docs/schedule-notebook-run)
    /// 
    /// ## Example Usage
    /// 
    /// ### Colab Schedule Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var myRuntimeTemplate = new Gcp.Colab.RuntimeTemplate("my_runtime_template", new()
    ///     {
    ///         Name = "runtime-template",
    ///         DisplayName = "Runtime template",
    ///         Location = "us-central1",
    ///         MachineSpec = new Gcp.Colab.Inputs.RuntimeTemplateMachineSpecArgs
    ///         {
    ///             MachineType = "e2-standard-4",
    ///         },
    ///         NetworkSpec = new Gcp.Colab.Inputs.RuntimeTemplateNetworkSpecArgs
    ///         {
    ///             EnableInternetAccess = true,
    ///         },
    ///     });
    /// 
    ///     var outputBucket = new Gcp.Storage.Bucket("output_bucket", new()
    ///     {
    ///         Name = "my_bucket",
    ///         Location = "US",
    ///         ForceDestroy = true,
    ///         UniformBucketLevelAccess = true,
    ///     });
    /// 
    ///     var notebook = new Gcp.Storage.BucketObject("notebook", new()
    ///     {
    ///         Name = "hello_world.ipynb",
    ///         Bucket = outputBucket.Name,
    ///         Content = @"    {
    ///       ""cells"": [
    ///         {
    ///           ""cell_type"": ""code"",
    ///           ""execution_count"": null,
    ///           ""metadata"": {},
    ///           ""outputs"": [],
    ///           ""source"": [
    ///             ""print(\""Hello, World!\"")""
    ///           ]
    ///         }
    ///       ],
    ///       ""metadata"": {
    ///         ""kernelspec"": {
    ///           ""display_name"": ""Python 3"",
    ///           ""language"": ""python"",
    ///           ""name"": ""python3""
    ///         },
    ///         ""language_info"": {
    ///           ""codemirror_mode"": {
    ///             ""name"": ""ipython"",
    ///             ""version"": 3
    ///           },
    ///           ""file_extension"": "".py"",
    ///           ""mimetype"": ""text/x-python"",
    ///           ""name"": ""python"",
    ///           ""nbconvert_exporter"": ""python"",
    ///           ""pygments_lexer"": ""ipython3"",
    ///           ""version"": ""3.8.5""
    ///         }
    ///       },
    ///       ""nbformat"": 4,
    ///       ""nbformat_minor"": 4
    ///     }
    /// ",
    ///     });
    /// 
    ///     var schedule = new Gcp.Colab.Schedule("schedule", new()
    ///     {
    ///         DisplayName = "basic-schedule",
    ///         Location = "us-west1",
    ///         MaxConcurrentRunCount = "2",
    ///         Cron = "TZ=America/Los_Angeles * * * * *",
    ///         CreateNotebookExecutionJobRequest = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestArgs
    ///         {
    ///             NotebookExecutionJob = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs
    ///             {
    ///                 DisplayName = "Notebook execution",
    ///                 GcsNotebookSource = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs
    ///                 {
    ///                     Uri = Output.Tuple(notebook.Bucket, notebook.Name).Apply(values =&gt;
    ///                     {
    ///                         var bucket = values.Item1;
    ///                         var name = values.Item2;
    ///                         return $"gs://{bucket}/{name}";
    ///                     }),
    ///                     Generation = notebook.Generation,
    ///                 },
    ///                 NotebookRuntimeTemplateResourceName = Output.Tuple(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).Apply(values =&gt;
    ///                 {
    ///                     var project = values.Item1;
    ///                     var location = values.Item2;
    ///                     var name = values.Item3;
    ///                     return $"projects/{project}/locations/{location}/notebookRuntimeTemplates/{name}";
    ///                 }),
    ///                 GcsOutputUri = outputBucket.Name.Apply(name =&gt; $"gs://{name}"),
    ///                 ServiceAccount = "my@service-account.com",
    ///             },
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             myRuntimeTemplate,
    ///             outputBucket,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Colab Schedule Paused
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var myRuntimeTemplate = new Gcp.Colab.RuntimeTemplate("my_runtime_template", new()
    ///     {
    ///         Name = "runtime-template",
    ///         DisplayName = "Runtime template",
    ///         Location = "us-central1",
    ///         MachineSpec = new Gcp.Colab.Inputs.RuntimeTemplateMachineSpecArgs
    ///         {
    ///             MachineType = "e2-standard-4",
    ///         },
    ///         NetworkSpec = new Gcp.Colab.Inputs.RuntimeTemplateNetworkSpecArgs
    ///         {
    ///             EnableInternetAccess = true,
    ///         },
    ///     });
    /// 
    ///     var outputBucket = new Gcp.Storage.Bucket("output_bucket", new()
    ///     {
    ///         Name = "my_bucket",
    ///         Location = "US",
    ///         ForceDestroy = true,
    ///         UniformBucketLevelAccess = true,
    ///     });
    /// 
    ///     var notebook = new Gcp.Storage.BucketObject("notebook", new()
    ///     {
    ///         Name = "hello_world.ipynb",
    ///         Bucket = outputBucket.Name,
    ///         Content = @"    {
    ///       ""cells"": [
    ///         {
    ///           ""cell_type"": ""code"",
    ///           ""execution_count"": null,
    ///           ""metadata"": {},
    ///           ""outputs"": [],
    ///           ""source"": [
    ///             ""print(\""Hello, World!\"")""
    ///           ]
    ///         }
    ///       ],
    ///       ""metadata"": {
    ///         ""kernelspec"": {
    ///           ""display_name"": ""Python 3"",
    ///           ""language"": ""python"",
    ///           ""name"": ""python3""
    ///         },
    ///         ""language_info"": {
    ///           ""codemirror_mode"": {
    ///             ""name"": ""ipython"",
    ///             ""version"": 3
    ///           },
    ///           ""file_extension"": "".py"",
    ///           ""mimetype"": ""text/x-python"",
    ///           ""name"": ""python"",
    ///           ""nbconvert_exporter"": ""python"",
    ///           ""pygments_lexer"": ""ipython3"",
    ///           ""version"": ""3.8.5""
    ///         }
    ///       },
    ///       ""nbformat"": 4,
    ///       ""nbformat_minor"": 4
    ///     }
    /// ",
    ///     });
    /// 
    ///     var schedule = new Gcp.Colab.Schedule("schedule", new()
    ///     {
    ///         DisplayName = "paused-schedule",
    ///         Location = "us-west1",
    ///         MaxConcurrentRunCount = "2",
    ///         Cron = "TZ=America/Los_Angeles * * * * *",
    ///         DesiredState = "PAUSED",
    ///         CreateNotebookExecutionJobRequest = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestArgs
    ///         {
    ///             NotebookExecutionJob = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs
    ///             {
    ///                 DisplayName = "Notebook execution",
    ///                 GcsNotebookSource = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs
    ///                 {
    ///                     Uri = Output.Tuple(notebook.Bucket, notebook.Name).Apply(values =&gt;
    ///                     {
    ///                         var bucket = values.Item1;
    ///                         var name = values.Item2;
    ///                         return $"gs://{bucket}/{name}";
    ///                     }),
    ///                     Generation = notebook.Generation,
    ///                 },
    ///                 NotebookRuntimeTemplateResourceName = Output.Tuple(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).Apply(values =&gt;
    ///                 {
    ///                     var project = values.Item1;
    ///                     var location = values.Item2;
    ///                     var name = values.Item3;
    ///                     return $"projects/{project}/locations/{location}/notebookRuntimeTemplates/{name}";
    ///                 }),
    ///                 GcsOutputUri = outputBucket.Name.Apply(name =&gt; $"gs://{name}"),
    ///                 ServiceAccount = "my@service-account.com",
    ///             },
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             myRuntimeTemplate,
    ///             outputBucket,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Colab Schedule Full
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var myRuntimeTemplate = new Gcp.Colab.RuntimeTemplate("my_runtime_template", new()
    ///     {
    ///         Name = "runtime-template",
    ///         DisplayName = "Runtime template",
    ///         Location = "us-central1",
    ///         MachineSpec = new Gcp.Colab.Inputs.RuntimeTemplateMachineSpecArgs
    ///         {
    ///             MachineType = "e2-standard-4",
    ///         },
    ///         NetworkSpec = new Gcp.Colab.Inputs.RuntimeTemplateNetworkSpecArgs
    ///         {
    ///             EnableInternetAccess = true,
    ///         },
    ///     });
    /// 
    ///     var outputBucket = new Gcp.Storage.Bucket("output_bucket", new()
    ///     {
    ///         Name = "my_bucket",
    ///         Location = "US",
    ///         ForceDestroy = true,
    ///         UniformBucketLevelAccess = true,
    ///     });
    /// 
    ///     var secret = new Gcp.SecretManager.Secret("secret", new()
    ///     {
    ///         SecretId = "secret",
    ///         Replication = new Gcp.SecretManager.Inputs.SecretReplicationArgs
    ///         {
    ///             Auto = null,
    ///         },
    ///     });
    /// 
    ///     var secretVersion = new Gcp.SecretManager.SecretVersion("secret_version", new()
    ///     {
    ///         Secret = secret.Id,
    ///         SecretData = "secret-data",
    ///     });
    /// 
    ///     var dataformRepository = new Gcp.Dataform.Repository("dataform_repository", new()
    ///     {
    ///         Name = "dataform-repository",
    ///         DisplayName = "dataform_repository",
    ///         NpmrcEnvironmentVariablesSecretVersion = secretVersion.Id,
    ///         KmsKeyName = "my-key",
    ///         Labels = 
    ///         {
    ///             { "label_foo1", "label-bar1" },
    ///         },
    ///         GitRemoteSettings = new Gcp.Dataform.Inputs.RepositoryGitRemoteSettingsArgs
    ///         {
    ///             Url = "https://github.com/OWNER/REPOSITORY.git",
    ///             DefaultBranch = "main",
    ///             AuthenticationTokenSecretVersion = secretVersion.Id,
    ///         },
    ///         WorkspaceCompilationOverrides = new Gcp.Dataform.Inputs.RepositoryWorkspaceCompilationOverridesArgs
    ///         {
    ///             DefaultDatabase = "database",
    ///             SchemaSuffix = "_suffix",
    ///             TablePrefix = "prefix_",
    ///         },
    ///     });
    /// 
    ///     var schedule = new Gcp.Colab.Schedule("schedule", new()
    ///     {
    ///         DisplayName = "full-schedule",
    ///         Location = "us-west1",
    ///         AllowQueueing = true,
    ///         MaxConcurrentRunCount = "2",
    ///         Cron = "TZ=America/Los_Angeles * * * * *",
    ///         MaxRunCount = "5",
    ///         StartTime = "2014-10-02T15:01:23Z",
    ///         EndTime = "2014-10-10T15:01:23Z",
    ///         DesiredState = "ACTIVE",
    ///         CreateNotebookExecutionJobRequest = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestArgs
    ///         {
    ///             NotebookExecutionJob = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs
    ///             {
    ///                 DisplayName = "Notebook execution",
    ///                 ExecutionTimeout = "86400s",
    ///                 DataformRepositorySource = new Gcp.Colab.Inputs.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceArgs
    ///                 {
    ///                     CommitSha = "randomsha123",
    ///                     DataformRepositoryResourceName = dataformRepository.Name.Apply(name =&gt; $"projects/my-project-name/locations/us-west1/repositories/{name}"),
    ///                 },
    ///                 NotebookRuntimeTemplateResourceName = Output.Tuple(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).Apply(values =&gt;
    ///                 {
    ///                     var project = values.Item1;
    ///                     var location = values.Item2;
    ///                     var name = values.Item3;
    ///                     return $"projects/{project}/locations/{location}/notebookRuntimeTemplates/{name}";
    ///                 }),
    ///                 GcsOutputUri = outputBucket.Name.Apply(name =&gt; $"gs://{name}"),
    ///                 ServiceAccount = "my@service-account.com",
    ///             },
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             myRuntimeTemplate,
    ///             outputBucket,
    ///             secretVersion,
    ///             dataformRepository,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Schedule can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/schedules/{{name}}`
    /// 
    /// * `{{project}}/{{location}}/{{name}}`
    /// 
    /// * `{{location}}/{{name}}`
    /// 
    /// When using the `pulumi import` command, Schedule can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:colab/schedule:Schedule default projects/{{project}}/locations/{{location}}/schedules/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:colab/schedule:Schedule default {{project}}/{{location}}/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:colab/schedule:Schedule default {{location}}/{{name}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:colab/schedule:Schedule")]
    public partial class Schedule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be
        /// queued instead of skipped. Default to false.
        /// </summary>
        [Output("allowQueueing")]
        public Output<bool?> AllowQueueing { get; private set; } = null!;

        /// <summary>
        /// Request for google_colab_notebook_execution.
        /// Structure is documented below.
        /// </summary>
        [Output("createNotebookExecutionJobRequest")]
        public Output<Outputs.ScheduleCreateNotebookExecutionJobRequest> CreateNotebookExecutionJobRequest { get; private set; } = null!;

        /// <summary>
        /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
        /// </summary>
        [Output("cron")]
        public Output<string> Cron { get; private set; } = null!;

        /// <summary>
        /// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
        /// schedule.
        /// </summary>
        [Output("desiredState")]
        public Output<string?> DesiredState { get; private set; } = null!;

        /// <summary>
        /// Required. The display name of the Schedule.
        /// </summary>
        [Output("displayName")]
        public Output<string> DisplayName { get; private set; } = null!;

        /// <summary>
        /// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is
        /// reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
        /// format.
        /// </summary>
        [Output("endTime")]
        public Output<string?> EndTime { get; private set; } = null!;

        /// <summary>
        /// The location for the resource: https://cloud.google.com/colab/docs/locations
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
        /// </summary>
        [Output("maxConcurrentRunCount")]
        public Output<string> MaxConcurrentRunCount { get; private set; } = null!;

        /// <summary>
        /// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;=
        /// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
        /// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        /// </summary>
        [Output("maxRunCount")]
        public Output<string?> MaxRunCount { get; private set; } = null!;

        /// <summary>
        /// The resource name of the Schedule
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
        /// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
        /// </summary>
        [Output("startTime")]
        public Output<string> StartTime { get; private set; } = null!;

        /// <summary>
        /// Output only. The state of the schedule.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;


        /// <summary>
        /// Create a Schedule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Schedule(string name, ScheduleArgs args, CustomResourceOptions? options = null)
            : base("gcp:colab/schedule:Schedule", name, args ?? new ScheduleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Schedule(string name, Input<string> id, ScheduleState? state = null, CustomResourceOptions? options = null)
            : base("gcp:colab/schedule:Schedule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Schedule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Schedule Get(string name, Input<string> id, ScheduleState? state = null, CustomResourceOptions? options = null)
        {
            return new Schedule(name, id, state, options);
        }
    }

    public sealed class ScheduleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be
        /// queued instead of skipped. Default to false.
        /// </summary>
        [Input("allowQueueing")]
        public Input<bool>? AllowQueueing { get; set; }

        /// <summary>
        /// Request for google_colab_notebook_execution.
        /// Structure is documented below.
        /// </summary>
        [Input("createNotebookExecutionJobRequest", required: true)]
        public Input<Inputs.ScheduleCreateNotebookExecutionJobRequestArgs> CreateNotebookExecutionJobRequest { get; set; } = null!;

        /// <summary>
        /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
        /// </summary>
        [Input("cron", required: true)]
        public Input<string> Cron { get; set; } = null!;

        /// <summary>
        /// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
        /// schedule.
        /// </summary>
        [Input("desiredState")]
        public Input<string>? DesiredState { get; set; }

        /// <summary>
        /// Required. The display name of the Schedule.
        /// </summary>
        [Input("displayName", required: true)]
        public Input<string> DisplayName { get; set; } = null!;

        /// <summary>
        /// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is
        /// reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
        /// format.
        /// </summary>
        [Input("endTime")]
        public Input<string>? EndTime { get; set; }

        /// <summary>
        /// The location for the resource: https://cloud.google.com/colab/docs/locations
        /// </summary>
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        /// <summary>
        /// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
        /// </summary>
        [Input("maxConcurrentRunCount", required: true)]
        public Input<string> MaxConcurrentRunCount { get; set; } = null!;

        /// <summary>
        /// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;=
        /// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
        /// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        /// </summary>
        [Input("maxRunCount")]
        public Input<string>? MaxRunCount { get; set; }

        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
        /// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
        /// </summary>
        [Input("startTime")]
        public Input<string>? StartTime { get; set; }

        public ScheduleArgs()
        {
        }
        public static new ScheduleArgs Empty => new ScheduleArgs();
    }

    public sealed class ScheduleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be
        /// queued instead of skipped. Default to false.
        /// </summary>
        [Input("allowQueueing")]
        public Input<bool>? AllowQueueing { get; set; }

        /// <summary>
        /// Request for google_colab_notebook_execution.
        /// Structure is documented below.
        /// </summary>
        [Input("createNotebookExecutionJobRequest")]
        public Input<Inputs.ScheduleCreateNotebookExecutionJobRequestGetArgs>? CreateNotebookExecutionJobRequest { get; set; }

        /// <summary>
        /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
        /// </summary>
        [Input("cron")]
        public Input<string>? Cron { get; set; }

        /// <summary>
        /// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
        /// schedule.
        /// </summary>
        [Input("desiredState")]
        public Input<string>? DesiredState { get; set; }

        /// <summary>
        /// Required. The display name of the Schedule.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is
        /// reached or when scheduled_run_count &gt;= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
        /// format.
        /// </summary>
        [Input("endTime")]
        public Input<string>? EndTime { get; set; }

        /// <summary>
        /// The location for the resource: https://cloud.google.com/colab/docs/locations
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
        /// </summary>
        [Input("maxConcurrentRunCount")]
        public Input<string>? MaxConcurrentRunCount { get; set; }

        /// <summary>
        /// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount &gt;=
        /// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
        /// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        /// </summary>
        [Input("maxRunCount")]
        public Input<string>? MaxRunCount { get; set; }

        /// <summary>
        /// The resource name of the Schedule
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
        /// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
        /// </summary>
        [Input("startTime")]
        public Input<string>? StartTime { get; set; }

        /// <summary>
        /// Output only. The state of the schedule.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        public ScheduleState()
        {
        }
        public static new ScheduleState Empty => new ScheduleState();
    }
}
