// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Ces.Inputs
{

    public sealed class ToolClientFunctionParametersGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Defines the schema for additional properties allowed in an object.
        /// The value must be a valid JSON string representing the Schema object.
        /// (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        /// </summary>
        [Input("additionalProperties")]
        public Input<string>? AdditionalProperties { get; set; }

        /// <summary>
        /// The instance value should be valid against at least one of the schemas in this list.
        /// </summary>
        [Input("anyOf")]
        public Input<string>? AnyOf { get; set; }

        /// <summary>
        /// Default value of the data. Represents a dynamically typed value
        /// which can be either null, a number, a string, a boolean, a struct,
        /// or a list of values. The provided default value must be compatible
        /// with the defined 'type' and other schema constraints.
        /// </summary>
        [Input("default")]
        public Input<string>? Default { get; set; }

        /// <summary>
        /// A map of definitions for use by ref. Only allowed at the root of the schema.
        /// </summary>
        [Input("defs")]
        public Input<string>? Defs { get; set; }

        /// <summary>
        /// The description of the data.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("enums")]
        private InputList<string>? _enums;

        /// <summary>
        /// Possible values of the element of primitive type with enum format.
        /// Examples:
        /// 1. We can define direction as :
        /// {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        /// 2. We can define apartment number as :
        /// {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        /// </summary>
        public InputList<string> Enums
        {
            get => _enums ?? (_enums = new InputList<string>());
            set => _enums = value;
        }

        /// <summary>
        /// Schema of the elements of Type.ARRAY.
        /// </summary>
        [Input("items")]
        public Input<string>? Items { get; set; }

        /// <summary>
        /// Maximum number of the elements for Type.ARRAY. (int64 format)
        /// </summary>
        [Input("maxItems")]
        public Input<int>? MaxItems { get; set; }

        /// <summary>
        /// Maximum value for Type.INTEGER and Type.NUMBER.
        /// </summary>
        [Input("maximum")]
        public Input<double>? Maximum { get; set; }

        /// <summary>
        /// Minimum number of the elements for Type.ARRAY. (int64 format)
        /// </summary>
        [Input("minItems")]
        public Input<int>? MinItems { get; set; }

        /// <summary>
        /// Minimum value for Type.INTEGER and Type.NUMBER.
        /// </summary>
        [Input("minimum")]
        public Input<double>? Minimum { get; set; }

        /// <summary>
        /// Indicates if the value may be null.
        /// </summary>
        [Input("nullable")]
        public Input<bool>? Nullable { get; set; }

        /// <summary>
        /// Schemas of initial elements of Type.ARRAY.
        /// </summary>
        [Input("prefixItems")]
        public Input<string>? PrefixItems { get; set; }

        /// <summary>
        /// Properties of Type.OBJECT.
        /// </summary>
        [Input("properties")]
        public Input<string>? Properties { get; set; }

        /// <summary>
        /// Allows indirect references between schema nodes. The value should be a
        /// valid reference to a child of the root `Defs`.
        /// For example, the following schema defines a reference to a schema node
        /// named "Pet":
        /// type: object
        /// properties:
        /// pet:
        /// ref: #/defs/Pet
        /// defs:
        /// Pet:
        /// type: object
        /// properties:
        /// name:
        /// type: string
        /// The value of the "pet" property is a reference to the schema node
        /// named "Pet".
        /// See details in
        /// https://json-schema.org/understanding-json-schema/structuring.
        /// </summary>
        [Input("ref")]
        public Input<string>? Ref { get; set; }

        [Input("requireds")]
        private InputList<string>? _requireds;

        /// <summary>
        /// Required properties of Type.OBJECT.
        /// </summary>
        public InputList<string> Requireds
        {
            get => _requireds ?? (_requireds = new InputList<string>());
            set => _requireds = value;
        }

        /// <summary>
        /// The title of the schema.
        /// </summary>
        [Input("title")]
        public Input<string>? Title { get; set; }

        /// <summary>
        /// The type of the data.
        /// Possible values:
        /// STRING
        /// INTEGER
        /// NUMBER
        /// BOOLEAN
        /// OBJECT
        /// ARRAY
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        /// </summary>
        [Input("uniqueItems")]
        public Input<bool>? UniqueItems { get; set; }

        public ToolClientFunctionParametersGetArgs()
        {
        }
        public static new ToolClientFunctionParametersGetArgs Empty => new ToolClientFunctionParametersGetArgs();
    }
}
