// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute
{
    /// <summary>
    /// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
    /// 
    /// To get more information about FirewallPolicyRule, see:
    /// 
    /// * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/firewallPolicies/addRule)
    /// 
    /// ## Example Usage
    /// 
    /// ### Firewall Policy Rule
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var basicGlobalNetworksecurityAddressGroup = new Gcp.NetworkSecurity.AddressGroup("basic_global_networksecurity_address_group", new()
    ///     {
    ///         Name = "address-group",
    ///         Parent = "organizations/123456789",
    ///         Description = "Sample global networksecurity_address_group",
    ///         Location = "global",
    ///         Items = new[]
    ///         {
    ///             "208.80.154.224/32",
    ///         },
    ///         Type = "IPV4",
    ///         Capacity = 100,
    ///     });
    /// 
    ///     var folder = new Gcp.Organizations.Folder("folder", new()
    ///     {
    ///         DisplayName = "folder",
    ///         Parent = "organizations/123456789",
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var @default = new Gcp.Compute.FirewallPolicy("default", new()
    ///     {
    ///         Parent = folder.Id,
    ///         ShortName = "fw-policy",
    ///         Description = "Resource created for Terraform acceptance testing",
    ///     });
    /// 
    ///     var primary = new Gcp.Compute.FirewallPolicyRule("primary", new()
    ///     {
    ///         FirewallPolicy = @default.Name,
    ///         Description = "Resource created for Terraform acceptance testing",
    ///         Priority = 9000,
    ///         EnableLogging = true,
    ///         Action = "allow",
    ///         Direction = "EGRESS",
    ///         Disabled = false,
    ///         TargetServiceAccounts = new[]
    ///         {
    ///             "my@service-account.com",
    ///         },
    ///         Match = new Gcp.Compute.Inputs.FirewallPolicyRuleMatchArgs
    ///         {
    ///             DestIpRanges = new[]
    ///             {
    ///                 "11.100.0.1/32",
    ///             },
    ///             DestFqdns = new() { },
    ///             DestRegionCodes = new[]
    ///             {
    ///                 "US",
    ///             },
    ///             DestThreatIntelligences = new[]
    ///             {
    ///                 "iplist-known-malicious-ips",
    ///             },
    ///             SrcAddressGroups = new() { },
    ///             DestAddressGroups = new[]
    ///             {
    ///                 basicGlobalNetworksecurityAddressGroup.Id,
    ///             },
    ///             Layer4Configs = new[]
    ///             {
    ///                 new Gcp.Compute.Inputs.FirewallPolicyRuleMatchLayer4ConfigArgs
    ///                 {
    ///                     IpProtocol = "tcp",
    ///                     Ports = new[]
    ///                     {
    ///                         "8080",
    ///                     },
    ///                 },
    ///                 new Gcp.Compute.Inputs.FirewallPolicyRuleMatchLayer4ConfigArgs
    ///                 {
    ///                     IpProtocol = "udp",
    ///                     Ports = new[]
    ///                     {
    ///                         "22",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firewall Policy Rule Network Scope
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var folder = new Gcp.Organizations.Folder("folder", new()
    ///     {
    ///         DisplayName = "folder",
    ///         Parent = "organizations/123456789",
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var @default = new Gcp.Compute.FirewallPolicy("default", new()
    ///     {
    ///         Parent = folder.Id,
    ///         ShortName = "fw-policy",
    ///         Description = "Firewall policy",
    ///     });
    /// 
    ///     var network = new Gcp.Compute.Network("network", new()
    ///     {
    ///         Name = "network",
    ///         AutoCreateSubnetworks = false,
    ///     });
    /// 
    ///     var primary = new Gcp.Compute.FirewallPolicyRule("primary", new()
    ///     {
    ///         FirewallPolicy = @default.Name,
    ///         Description = "Firewall policy rule with network scope",
    ///         Priority = 9000,
    ///         Action = "allow",
    ///         Direction = "INGRESS",
    ///         Disabled = false,
    ///         Match = new Gcp.Compute.Inputs.FirewallPolicyRuleMatchArgs
    ///         {
    ///             SrcIpRanges = new[]
    ///             {
    ///                 "11.100.0.1/32",
    ///             },
    ///             SrcNetworkScope = "VPC_NETWORKS",
    ///             SrcNetworks = new[]
    ///             {
    ///                 network.Id,
    ///             },
    ///             Layer4Configs = new[]
    ///             {
    ///                 new Gcp.Compute.Inputs.FirewallPolicyRuleMatchLayer4ConfigArgs
    ///                 {
    ///                     IpProtocol = "tcp",
    ///                     Ports = new[]
    ///                     {
    ///                         "8080",
    ///                     },
    ///                 },
    ///                 new Gcp.Compute.Inputs.FirewallPolicyRuleMatchLayer4ConfigArgs
    ///                 {
    ///                     IpProtocol = "udp",
    ///                     Ports = new[]
    ///                     {
    ///                         "22",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// FirewallPolicyRule can be imported using any of these accepted formats:
    /// 
    /// * `locations/global/firewallPolicies/{{firewall_policy}}/rules/{{priority}}`
    /// 
    /// * `{{firewall_policy}}/{{priority}}`
    /// 
    /// When using the `pulumi import` command, FirewallPolicyRule can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/firewallPolicyRule:FirewallPolicyRule default locations/global/firewallPolicies/{{firewall_policy}}/rules/{{priority}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/firewallPolicyRule:FirewallPolicyRule default {{firewall_policy}}/{{priority}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:compute/firewallPolicyRule:FirewallPolicyRule")]
    public partial class FirewallPolicyRule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Output("creationTimestamp")]
        public Output<string> CreationTimestamp { get; private set; } = null!;

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Output("direction")]
        public Output<string> Direction { get; private set; } = null!;

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Output("disabled")]
        public Output<bool?> Disabled { get; private set; } = null!;

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Output("enableLogging")]
        public Output<bool?> EnableLogging { get; private set; } = null!;

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Output("firewallPolicy")]
        public Output<string> FirewallPolicy { get; private set; } = null!;

        /// <summary>
        /// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
        /// </summary>
        [Output("kind")]
        public Output<string> Kind { get; private set; } = null!;

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Output("match")]
        public Output<Outputs.FirewallPolicyRuleMatch> Match { get; private set; } = null!;

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Output("priority")]
        public Output<int> Priority { get; private set; } = null!;

        /// <summary>
        /// Calculation of the complexity of a single firewall policy rule.
        /// </summary>
        [Output("ruleTupleCount")]
        public Output<int> RuleTupleCount { get; private set; } = null!;

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
        /// </summary>
        [Output("securityProfileGroup")]
        public Output<string?> SecurityProfileGroup { get; private set; } = null!;

        /// <summary>
        /// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
        /// this rule. If this field is left blank, all VMs within the organization will receive the rule.
        /// </summary>
        [Output("targetResources")]
        public Output<ImmutableArray<string>> TargetResources { get; private set; } = null!;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        [Output("targetServiceAccounts")]
        public Output<ImmutableArray<string>> TargetServiceAccounts { get; private set; } = null!;

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Output("tlsInspect")]
        public Output<bool?> TlsInspect { get; private set; } = null!;


        /// <summary>
        /// Create a FirewallPolicyRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public FirewallPolicyRule(string name, FirewallPolicyRuleArgs args, CustomResourceOptions? options = null)
            : base("gcp:compute/firewallPolicyRule:FirewallPolicyRule", name, args ?? new FirewallPolicyRuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private FirewallPolicyRule(string name, Input<string> id, FirewallPolicyRuleState? state = null, CustomResourceOptions? options = null)
            : base("gcp:compute/firewallPolicyRule:FirewallPolicyRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing FirewallPolicyRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static FirewallPolicyRule Get(string name, Input<string> id, FirewallPolicyRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new FirewallPolicyRule(name, id, state, options);
        }
    }

    public sealed class FirewallPolicyRuleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Input("direction", required: true)]
        public Input<string> Direction { get; set; } = null!;

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Input("firewallPolicy", required: true)]
        public Input<string> FirewallPolicy { get; set; } = null!;

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Input("match", required: true)]
        public Input<Inputs.FirewallPolicyRuleMatchArgs> Match { get; set; } = null!;

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
        /// </summary>
        [Input("securityProfileGroup")]
        public Input<string>? SecurityProfileGroup { get; set; }

        [Input("targetResources")]
        private InputList<string>? _targetResources;

        /// <summary>
        /// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
        /// this rule. If this field is left blank, all VMs within the organization will receive the rule.
        /// </summary>
        public InputList<string> TargetResources
        {
            get => _targetResources ?? (_targetResources = new InputList<string>());
            set => _targetResources = value;
        }

        [Input("targetServiceAccounts")]
        private InputList<string>? _targetServiceAccounts;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        public InputList<string> TargetServiceAccounts
        {
            get => _targetServiceAccounts ?? (_targetServiceAccounts = new InputList<string>());
            set => _targetServiceAccounts = value;
        }

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Input("tlsInspect")]
        public Input<bool>? TlsInspect { get; set; }

        public FirewallPolicyRuleArgs()
        {
        }
        public static new FirewallPolicyRuleArgs Empty => new FirewallPolicyRuleArgs();
    }

    public sealed class FirewallPolicyRuleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Input("direction")]
        public Input<string>? Direction { get; set; }

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Input("firewallPolicy")]
        public Input<string>? FirewallPolicy { get; set; }

        /// <summary>
        /// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Input("match")]
        public Input<Inputs.FirewallPolicyRuleMatchGetArgs>? Match { get; set; }

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        /// <summary>
        /// Calculation of the complexity of a single firewall policy rule.
        /// </summary>
        [Input("ruleTupleCount")]
        public Input<int>? RuleTupleCount { get; set; }

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
        /// </summary>
        [Input("securityProfileGroup")]
        public Input<string>? SecurityProfileGroup { get; set; }

        [Input("targetResources")]
        private InputList<string>? _targetResources;

        /// <summary>
        /// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
        /// this rule. If this field is left blank, all VMs within the organization will receive the rule.
        /// </summary>
        public InputList<string> TargetResources
        {
            get => _targetResources ?? (_targetResources = new InputList<string>());
            set => _targetResources = value;
        }

        [Input("targetServiceAccounts")]
        private InputList<string>? _targetServiceAccounts;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        public InputList<string> TargetServiceAccounts
        {
            get => _targetServiceAccounts ?? (_targetServiceAccounts = new InputList<string>());
            set => _targetServiceAccounts = value;
        }

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Input("tlsInspect")]
        public Input<bool>? TlsInspect { get; set; }

        public FirewallPolicyRuleState()
        {
        }
        public static new FirewallPolicyRuleState Empty => new FirewallPolicyRuleState();
    }
}
