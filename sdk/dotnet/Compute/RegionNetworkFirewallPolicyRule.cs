// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute
{
    /// <summary>
    /// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
    /// 
    /// To get more information about RegionNetworkFirewallPolicyRule, see:
    /// 
    /// * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/regionNetworkFirewallPolicies/addRule)
    /// 
    /// ## Example Usage
    /// 
    /// ### Region Network Firewall Policy Rule
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var basicRegionalNetworksecurityAddressGroup = new Gcp.NetworkSecurity.AddressGroup("basic_regional_networksecurity_address_group", new()
    ///     {
    ///         Name = "address",
    ///         Parent = "projects/my-project-name",
    ///         Description = "Sample regional networksecurity_address_group",
    ///         Location = "us-west1",
    ///         Items = new[]
    ///         {
    ///             "208.80.154.224/32",
    ///         },
    ///         Type = "IPV4",
    ///         Capacity = 100,
    ///     });
    /// 
    ///     var basicRegionalNetworkFirewallPolicy = new Gcp.Compute.RegionNetworkFirewallPolicy("basic_regional_network_firewall_policy", new()
    ///     {
    ///         Name = "policy",
    ///         Description = "Sample regional network firewall policy",
    ///         Project = "my-project-name",
    ///         Region = "us-west1",
    ///     });
    /// 
    ///     var basicNetwork = new Gcp.Compute.Network("basic_network", new()
    ///     {
    ///         Name = "network",
    ///     });
    /// 
    ///     var basicKey = new Gcp.Tags.TagKey("basic_key", new()
    ///     {
    ///         Description = "For keyname resources.",
    ///         Parent = "organizations/123456789",
    ///         Purpose = "GCE_FIREWALL",
    ///         ShortName = "tagkey",
    ///         PurposeData = 
    ///         {
    ///             { "network", basicNetwork.Name.Apply(name =&gt; $"my-project-name/{name}") },
    ///         },
    ///     });
    /// 
    ///     var basicValue = new Gcp.Tags.TagValue("basic_value", new()
    ///     {
    ///         Description = "For valuename resources.",
    ///         Parent = basicKey.Id,
    ///         ShortName = "tagvalue",
    ///     });
    /// 
    ///     var primary = new Gcp.Compute.RegionNetworkFirewallPolicyRule("primary", new()
    ///     {
    ///         Action = "allow",
    ///         Description = "This is a simple rule description",
    ///         Direction = "INGRESS",
    ///         Disabled = false,
    ///         EnableLogging = true,
    ///         FirewallPolicy = basicRegionalNetworkFirewallPolicy.Name,
    ///         Priority = 1000,
    ///         Region = "us-west1",
    ///         RuleName = "test-rule",
    ///         TargetServiceAccounts = new[]
    ///         {
    ///             "my@service-account.com",
    ///         },
    ///         Match = new Gcp.Compute.Inputs.RegionNetworkFirewallPolicyRuleMatchArgs
    ///         {
    ///             SrcIpRanges = new[]
    ///             {
    ///                 "10.100.0.1/32",
    ///             },
    ///             SrcFqdns = new[]
    ///             {
    ///                 "example.com",
    ///             },
    ///             SrcRegionCodes = new[]
    ///             {
    ///                 "US",
    ///             },
    ///             SrcThreatIntelligences = new[]
    ///             {
    ///                 "iplist-known-malicious-ips",
    ///             },
    ///             Layer4Configs = new[]
    ///             {
    ///                 new Gcp.Compute.Inputs.RegionNetworkFirewallPolicyRuleMatchLayer4ConfigArgs
    ///                 {
    ///                     IpProtocol = "all",
    ///                 },
    ///             },
    ///             SrcSecureTags = new[]
    ///             {
    ///                 new Gcp.Compute.Inputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTagArgs
    ///                 {
    ///                     Name = basicValue.Id,
    ///                 },
    ///             },
    ///             SrcAddressGroups = new[]
    ///             {
    ///                 basicRegionalNetworksecurityAddressGroup.Id,
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// RegionNetworkFirewallPolicyRule can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/regions/{{region}}/firewallPolicies/{{firewall_policy}}/{{priority}}`
    /// 
    /// * `{{project}}/{{region}}/{{firewall_policy}}/{{priority}}`
    /// 
    /// * `{{region}}/{{firewall_policy}}/{{priority}}`
    /// 
    /// * `{{firewall_policy}}/{{priority}}`
    /// 
    /// When using the `pulumi import` command, RegionNetworkFirewallPolicyRule can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule default projects/{{project}}/regions/{{region}}/firewallPolicies/{{firewall_policy}}/{{priority}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule default {{project}}/{{region}}/{{firewall_policy}}/{{priority}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule default {{region}}/{{firewall_policy}}/{{priority}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule default {{firewall_policy}}/{{priority}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule")]
    public partial class RegionNetworkFirewallPolicyRule : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Output("creationTimestamp")]
        public Output<string> CreationTimestamp { get; private set; } = null!;

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Output("direction")]
        public Output<string> Direction { get; private set; } = null!;

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Output("disabled")]
        public Output<bool?> Disabled { get; private set; } = null!;

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Output("enableLogging")]
        public Output<bool?> EnableLogging { get; private set; } = null!;

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Output("firewallPolicy")]
        public Output<string> FirewallPolicy { get; private set; } = null!;

        /// <summary>
        /// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
        /// </summary>
        [Output("kind")]
        public Output<string> Kind { get; private set; } = null!;

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Output("match")]
        public Output<Outputs.RegionNetworkFirewallPolicyRuleMatch> Match { get; private set; } = null!;

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Output("priority")]
        public Output<int> Priority { get; private set; } = null!;

        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The location of this resource.
        /// </summary>
        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        /// <summary>
        /// An optional name for the rule. This field is not a unique identifier and can be updated.
        /// </summary>
        [Output("ruleName")]
        public Output<string?> RuleName { get; private set; } = null!;

        /// <summary>
        /// Calculation of the complexity of a single firewall policy rule.
        /// </summary>
        [Output("ruleTupleCount")]
        public Output<int> RuleTupleCount { get; private set; } = null!;

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions. Security Profile
        /// Group and Firewall Policy Rule must be in the same scope.
        /// </summary>
        [Output("securityProfileGroup")]
        public Output<string?> SecurityProfileGroup { get; private set; } = null!;

        /// <summary>
        /// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
        /// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
        /// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
        /// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
        /// applies to all instances on the specified network. Maximum number of target label tags allowed is 256.
        /// </summary>
        [Output("targetSecureTags")]
        public Output<ImmutableArray<Outputs.RegionNetworkFirewallPolicyRuleTargetSecureTag>> TargetSecureTags { get; private set; } = null!;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        [Output("targetServiceAccounts")]
        public Output<ImmutableArray<string>> TargetServiceAccounts { get; private set; } = null!;

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Output("tlsInspect")]
        public Output<bool?> TlsInspect { get; private set; } = null!;


        /// <summary>
        /// Create a RegionNetworkFirewallPolicyRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public RegionNetworkFirewallPolicyRule(string name, RegionNetworkFirewallPolicyRuleArgs args, CustomResourceOptions? options = null)
            : base("gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule", name, args ?? new RegionNetworkFirewallPolicyRuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private RegionNetworkFirewallPolicyRule(string name, Input<string> id, RegionNetworkFirewallPolicyRuleState? state = null, CustomResourceOptions? options = null)
            : base("gcp:compute/regionNetworkFirewallPolicyRule:RegionNetworkFirewallPolicyRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing RegionNetworkFirewallPolicyRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static RegionNetworkFirewallPolicyRule Get(string name, Input<string> id, RegionNetworkFirewallPolicyRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new RegionNetworkFirewallPolicyRule(name, id, state, options);
        }
    }

    public sealed class RegionNetworkFirewallPolicyRuleArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Input("direction", required: true)]
        public Input<string> Direction { get; set; } = null!;

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Input("firewallPolicy", required: true)]
        public Input<string> FirewallPolicy { get; set; } = null!;

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Input("match", required: true)]
        public Input<Inputs.RegionNetworkFirewallPolicyRuleMatchArgs> Match { get; set; } = null!;

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Input("priority", required: true)]
        public Input<int> Priority { get; set; } = null!;

        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The location of this resource.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// An optional name for the rule. This field is not a unique identifier and can be updated.
        /// </summary>
        [Input("ruleName")]
        public Input<string>? RuleName { get; set; }

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions. Security Profile
        /// Group and Firewall Policy Rule must be in the same scope.
        /// </summary>
        [Input("securityProfileGroup")]
        public Input<string>? SecurityProfileGroup { get; set; }

        [Input("targetSecureTags")]
        private InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagArgs>? _targetSecureTags;

        /// <summary>
        /// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
        /// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
        /// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
        /// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
        /// applies to all instances on the specified network. Maximum number of target label tags allowed is 256.
        /// </summary>
        public InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagArgs> TargetSecureTags
        {
            get => _targetSecureTags ?? (_targetSecureTags = new InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagArgs>());
            set => _targetSecureTags = value;
        }

        [Input("targetServiceAccounts")]
        private InputList<string>? _targetServiceAccounts;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        public InputList<string> TargetServiceAccounts
        {
            get => _targetServiceAccounts ?? (_targetServiceAccounts = new InputList<string>());
            set => _targetServiceAccounts = value;
        }

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Input("tlsInspect")]
        public Input<bool>? TlsInspect { get; set; }

        public RegionNetworkFirewallPolicyRuleArgs()
        {
        }
        public static new RegionNetworkFirewallPolicyRuleArgs Empty => new RegionNetworkFirewallPolicyRuleArgs();
    }

    public sealed class RegionNetworkFirewallPolicyRuleState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "goto_next" and "apply_security_profile_group".
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// An optional description for this resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The direction in which this rule applies.
        /// Possible values are: `INGRESS`, `EGRESS`.
        /// </summary>
        [Input("direction")]
        public Input<string>? Direction { get; set; }

        /// <summary>
        /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
        /// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
        /// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
        /// "goto_next" rules.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The firewall policy of the resource.
        /// </summary>
        [Input("firewallPolicy")]
        public Input<string>? FirewallPolicy { get; set; }

        /// <summary>
        /// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
        /// </summary>
        [Input("kind")]
        public Input<string>? Kind { get; set; }

        /// <summary>
        /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
        /// Structure is documented below.
        /// </summary>
        [Input("match")]
        public Input<Inputs.RegionNetworkFirewallPolicyRuleMatchGetArgs>? Match { get; set; }

        /// <summary>
        /// An integer indicating the priority of a rule in the list.
        /// The priority must be a positive value between 0 and 2147483647.
        /// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The location of this resource.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// An optional name for the rule. This field is not a unique identifier and can be updated.
        /// </summary>
        [Input("ruleName")]
        public Input<string>? RuleName { get; set; }

        /// <summary>
        /// Calculation of the complexity of a single firewall policy rule.
        /// </summary>
        [Input("ruleTupleCount")]
        public Input<int>? RuleTupleCount { get; set; }

        /// <summary>
        /// A fully-qualified URL of a SecurityProfile resource instance. Example:
        /// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
        /// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions. Security Profile
        /// Group and Firewall Policy Rule must be in the same scope.
        /// </summary>
        [Input("securityProfileGroup")]
        public Input<string>? SecurityProfileGroup { get; set; }

        [Input("targetSecureTags")]
        private InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagGetArgs>? _targetSecureTags;

        /// <summary>
        /// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
        /// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
        /// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
        /// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
        /// applies to all instances on the specified network. Maximum number of target label tags allowed is 256.
        /// </summary>
        public InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagGetArgs> TargetSecureTags
        {
            get => _targetSecureTags ?? (_targetSecureTags = new InputList<Inputs.RegionNetworkFirewallPolicyRuleTargetSecureTagGetArgs>());
            set => _targetSecureTags = value;
        }

        [Input("targetServiceAccounts")]
        private InputList<string>? _targetServiceAccounts;

        /// <summary>
        /// A list of service accounts indicating the sets of instances that are applied with this rule.
        /// </summary>
        public InputList<string> TargetServiceAccounts
        {
            get => _targetServiceAccounts ?? (_targetServiceAccounts = new InputList<string>());
            set => _targetServiceAccounts = value;
        }

        /// <summary>
        /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
        /// 'apply_security_profile_group' and cannot be set for other actions.
        /// </summary>
        [Input("tlsInspect")]
        public Input<bool>? TlsInspect { get; set; }

        public RegionNetworkFirewallPolicyRuleState()
        {
        }
        public static new RegionNetworkFirewallPolicyRuleState Empty => new RegionNetworkFirewallPolicyRuleState();
    }
}
