// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute.Inputs
{

    public sealed class RegionNetworkFirewallPolicyRuleMatchArgs : global::Pulumi.ResourceArgs
    {
        [Input("destAddressGroups")]
        private InputList<string>? _destAddressGroups;

        /// <summary>
        /// Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
        /// </summary>
        public InputList<string> DestAddressGroups
        {
            get => _destAddressGroups ?? (_destAddressGroups = new InputList<string>());
            set => _destAddressGroups = value;
        }

        [Input("destFqdns")]
        private InputList<string>? _destFqdns;

        /// <summary>
        /// Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
        /// </summary>
        public InputList<string> DestFqdns
        {
            get => _destFqdns ?? (_destFqdns = new InputList<string>());
            set => _destFqdns = value;
        }

        [Input("destIpRanges")]
        private InputList<string>? _destIpRanges;

        /// <summary>
        /// CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
        /// </summary>
        public InputList<string> DestIpRanges
        {
            get => _destIpRanges ?? (_destIpRanges = new InputList<string>());
            set => _destIpRanges = value;
        }

        /// <summary>
        /// Network scope of the traffic destination.
        /// Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        /// </summary>
        [Input("destNetworkScope")]
        public Input<string>? DestNetworkScope { get; set; }

        [Input("destRegionCodes")]
        private InputList<string>? _destRegionCodes;

        /// <summary>
        /// Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
        /// </summary>
        public InputList<string> DestRegionCodes
        {
            get => _destRegionCodes ?? (_destRegionCodes = new InputList<string>());
            set => _destRegionCodes = value;
        }

        [Input("destThreatIntelligences")]
        private InputList<string>? _destThreatIntelligences;

        /// <summary>
        /// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
        /// </summary>
        public InputList<string> DestThreatIntelligences
        {
            get => _destThreatIntelligences ?? (_destThreatIntelligences = new InputList<string>());
            set => _destThreatIntelligences = value;
        }

        [Input("layer4Configs", required: true)]
        private InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchLayer4ConfigArgs>? _layer4Configs;

        /// <summary>
        /// Pairs of IP protocols and ports that the rule should match.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchLayer4ConfigArgs> Layer4Configs
        {
            get => _layer4Configs ?? (_layer4Configs = new InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchLayer4ConfigArgs>());
            set => _layer4Configs = value;
        }

        [Input("srcAddressGroups")]
        private InputList<string>? _srcAddressGroups;

        /// <summary>
        /// Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
        /// </summary>
        public InputList<string> SrcAddressGroups
        {
            get => _srcAddressGroups ?? (_srcAddressGroups = new InputList<string>());
            set => _srcAddressGroups = value;
        }

        [Input("srcFqdns")]
        private InputList<string>? _srcFqdns;

        /// <summary>
        /// Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
        /// </summary>
        public InputList<string> SrcFqdns
        {
            get => _srcFqdns ?? (_srcFqdns = new InputList<string>());
            set => _srcFqdns = value;
        }

        [Input("srcIpRanges")]
        private InputList<string>? _srcIpRanges;

        /// <summary>
        /// CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
        /// </summary>
        public InputList<string> SrcIpRanges
        {
            get => _srcIpRanges ?? (_srcIpRanges = new InputList<string>());
            set => _srcIpRanges = value;
        }

        /// <summary>
        /// Network scope of the traffic source.
        /// Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
        /// </summary>
        [Input("srcNetworkScope")]
        public Input<string>? SrcNetworkScope { get; set; }

        [Input("srcNetworks")]
        private InputList<string>? _srcNetworks;

        /// <summary>
        /// Networks of the traffic source. It can be either a full or partial url.
        /// </summary>
        public InputList<string> SrcNetworks
        {
            get => _srcNetworks ?? (_srcNetworks = new InputList<string>());
            set => _srcNetworks = value;
        }

        [Input("srcRegionCodes")]
        private InputList<string>? _srcRegionCodes;

        /// <summary>
        /// Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
        /// </summary>
        public InputList<string> SrcRegionCodes
        {
            get => _srcRegionCodes ?? (_srcRegionCodes = new InputList<string>());
            set => _srcRegionCodes = value;
        }

        [Input("srcSecureTags")]
        private InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTagArgs>? _srcSecureTags;

        /// <summary>
        /// List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTagArgs> SrcSecureTags
        {
            get => _srcSecureTags ?? (_srcSecureTags = new InputList<Inputs.RegionNetworkFirewallPolicyRuleMatchSrcSecureTagArgs>());
            set => _srcSecureTags = value;
        }

        [Input("srcThreatIntelligences")]
        private InputList<string>? _srcThreatIntelligences;

        /// <summary>
        /// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
        /// 
        /// 
        /// &lt;a name="nested_match_layer4_configs"&gt;&lt;/a&gt;The `layer4_configs` block supports:
        /// </summary>
        public InputList<string> SrcThreatIntelligences
        {
            get => _srcThreatIntelligences ?? (_srcThreatIntelligences = new InputList<string>());
            set => _srcThreatIntelligences = value;
        }

        public RegionNetworkFirewallPolicyRuleMatchArgs()
        {
        }
        public static new RegionNetworkFirewallPolicyRuleMatchArgs Empty => new RegionNetworkFirewallPolicyRuleMatchArgs();
    }
}
