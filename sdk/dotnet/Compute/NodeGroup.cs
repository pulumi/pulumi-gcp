// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Compute
{
    /// <summary>
    /// Represents a NodeGroup resource to manage a group of sole-tenant nodes.
    /// 
    /// To get more information about NodeGroup, see:
    /// 
    /// * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/nodeGroups)
    /// * How-to Guides
    ///     * [Sole-Tenant Nodes](https://cloud.google.com/compute/docs/nodes/)
    /// 
    /// &gt; **Warning:** Due to limitations of the API, this provider cannot update the
    /// number of nodes in a node group and changes to node group size either
    /// through provider config or through external changes will cause
    /// the provider to delete and recreate the node group.
    /// 
    /// ## Example Usage
    /// 
    /// ### Node Group Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var soletenant_tmpl = new Gcp.Compute.NodeTemplate("soletenant-tmpl", new()
    ///     {
    ///         Name = "soletenant-tmpl",
    ///         Region = "us-central1",
    ///         NodeType = "n1-node-96-624",
    ///     });
    /// 
    ///     var nodes = new Gcp.Compute.NodeGroup("nodes", new()
    ///     {
    ///         Name = "soletenant-group",
    ///         Zone = "us-central1-a",
    ///         Description = "example google_compute_node_group for the Google Provider",
    ///         InitialSize = 1,
    ///         NodeTemplate = soletenant_tmpl.Id,
    ///     });
    /// 
    /// });
    /// ```
    /// ### Node Group Maintenance Interval
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var soletenant_tmpl = new Gcp.Compute.NodeTemplate("soletenant-tmpl", new()
    ///     {
    ///         Name = "soletenant-tmpl",
    ///         Region = "us-central1",
    ///         NodeType = "c2-node-60-240",
    ///     });
    /// 
    ///     var nodes = new Gcp.Compute.NodeGroup("nodes", new()
    ///     {
    ///         Name = "soletenant-group",
    ///         Zone = "us-central1-a",
    ///         Description = "example google_compute_node_group for Terraform Google Provider",
    ///         InitialSize = 1,
    ///         NodeTemplate = soletenant_tmpl.Id,
    ///         MaintenanceInterval = "RECURRENT",
    ///     });
    /// 
    /// });
    /// ```
    /// ### Node Group Autoscaling Policy
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var soletenant_tmpl = new Gcp.Compute.NodeTemplate("soletenant-tmpl", new()
    ///     {
    ///         Name = "soletenant-tmpl",
    ///         Region = "us-central1",
    ///         NodeType = "n1-node-96-624",
    ///     });
    /// 
    ///     var nodes = new Gcp.Compute.NodeGroup("nodes", new()
    ///     {
    ///         Name = "soletenant-group",
    ///         Zone = "us-central1-a",
    ///         Description = "example google_compute_node_group for Google Provider",
    ///         MaintenancePolicy = "RESTART_IN_PLACE",
    ///         MaintenanceWindow = new Gcp.Compute.Inputs.NodeGroupMaintenanceWindowArgs
    ///         {
    ///             StartTime = "08:00",
    ///         },
    ///         InitialSize = 1,
    ///         NodeTemplate = soletenant_tmpl.Id,
    ///         AutoscalingPolicy = new Gcp.Compute.Inputs.NodeGroupAutoscalingPolicyArgs
    ///         {
    ///             Mode = "ONLY_SCALE_OUT",
    ///             MinNodes = 1,
    ///             MaxNodes = 10,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Node Group Share Settings
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var guestProject = new Gcp.Organizations.Project("guest_project", new()
    ///     {
    ///         ProjectId = "project-id",
    ///         Name = "project-name",
    ///         OrgId = "123456789",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var soletenant_tmpl = new Gcp.Compute.NodeTemplate("soletenant-tmpl", new()
    ///     {
    ///         Name = "soletenant-tmpl",
    ///         Region = "us-central1",
    ///         NodeType = "n1-node-96-624",
    ///     });
    /// 
    ///     var nodes = new Gcp.Compute.NodeGroup("nodes", new()
    ///     {
    ///         Name = "soletenant-group",
    ///         Zone = "us-central1-f",
    ///         Description = "example google_compute_node_group for Terraform Google Provider",
    ///         InitialSize = 1,
    ///         NodeTemplate = soletenant_tmpl.Id,
    ///         ShareSettings = new Gcp.Compute.Inputs.NodeGroupShareSettingsArgs
    ///         {
    ///             ShareType = "SPECIFIC_PROJECTS",
    ///             ProjectMaps = new[]
    ///             {
    ///                 new Gcp.Compute.Inputs.NodeGroupShareSettingsProjectMapArgs
    ///                 {
    ///                     Id = guestProject.ProjectId,
    ///                     ProjectId = guestProject.ProjectId,
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// NodeGroup can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/zones/{{zone}}/nodeGroups/{{name}}`
    /// 
    /// * `{{project}}/{{zone}}/{{name}}`
    /// 
    /// * `{{zone}}/{{name}}`
    /// 
    /// * `{{name}}`
    /// 
    /// When using the `pulumi import` command, NodeGroup can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/nodeGroup:NodeGroup default projects/{{project}}/zones/{{zone}}/nodeGroups/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/nodeGroup:NodeGroup default {{project}}/{{zone}}/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/nodeGroup:NodeGroup default {{zone}}/{{name}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:compute/nodeGroup:NodeGroup default {{name}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:compute/nodeGroup:NodeGroup")]
    public partial class NodeGroup : global::Pulumi.CustomResource
    {
        /// <summary>
        /// If you use sole-tenant nodes for your workloads, you can use the node
        /// group autoscaler to automatically manage the sizes of your node groups.
        /// One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// Structure is documented below.
        /// </summary>
        [Output("autoscalingPolicy")]
        public Output<Outputs.NodeGroupAutoscalingPolicy> AutoscalingPolicy { get; private set; } = null!;

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Output("creationTimestamp")]
        public Output<string> CreationTimestamp { get; private set; } = null!;

        /// <summary>
        /// An optional textual description of the resource.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The initial number of nodes in the node group. One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// </summary>
        [Output("initialSize")]
        public Output<int?> InitialSize { get; private set; } = null!;

        /// <summary>
        /// (Optional, Beta)
        /// Specifies the frequency of planned maintenance events. Set to one of the following:
        /// - AS_NEEDED: Hosts are eligible to receive infrastructure and hypervisor updates as they become available.
        /// - RECURRENT: Hosts receive planned infrastructure and hypervisor updates on a periodic basis, but not more frequently than every 28 days. This minimizes the number of planned maintenance operations on individual hosts and reduces the frequency of disruptions, both live migrations and terminations, on individual VMs.
        /// Possible values are: `AS_NEEDED`, `RECURRENT`.
        /// </summary>
        [Output("maintenanceInterval")]
        public Output<string> MaintenanceInterval { get; private set; } = null!;

        /// <summary>
        /// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT.
        /// </summary>
        [Output("maintenancePolicy")]
        public Output<string?> MaintenancePolicy { get; private set; } = null!;

        /// <summary>
        /// contains properties for the timeframe of maintenance
        /// Structure is documented below.
        /// </summary>
        [Output("maintenanceWindow")]
        public Output<Outputs.NodeGroupMaintenanceWindow?> MaintenanceWindow { get; private set; } = null!;

        /// <summary>
        /// Name of the resource.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The URL of the node template to which this node group belongs.
        /// </summary>
        [Output("nodeTemplate")]
        public Output<string> NodeTemplate { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Output("selfLink")]
        public Output<string> SelfLink { get; private set; } = null!;

        /// <summary>
        /// Share settings for the node group.
        /// Structure is documented below.
        /// </summary>
        [Output("shareSettings")]
        public Output<Outputs.NodeGroupShareSettings> ShareSettings { get; private set; } = null!;

        /// <summary>
        /// The total number of nodes in the node group.
        /// </summary>
        [Output("size")]
        public Output<int> Size { get; private set; } = null!;

        /// <summary>
        /// Zone where this node group is located
        /// </summary>
        [Output("zone")]
        public Output<string> Zone { get; private set; } = null!;


        /// <summary>
        /// Create a NodeGroup resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public NodeGroup(string name, NodeGroupArgs args, CustomResourceOptions? options = null)
            : base("gcp:compute/nodeGroup:NodeGroup", name, args ?? new NodeGroupArgs(), MakeResourceOptions(options, ""))
        {
        }

        private NodeGroup(string name, Input<string> id, NodeGroupState? state = null, CustomResourceOptions? options = null)
            : base("gcp:compute/nodeGroup:NodeGroup", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing NodeGroup resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static NodeGroup Get(string name, Input<string> id, NodeGroupState? state = null, CustomResourceOptions? options = null)
        {
            return new NodeGroup(name, id, state, options);
        }
    }

    public sealed class NodeGroupArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If you use sole-tenant nodes for your workloads, you can use the node
        /// group autoscaler to automatically manage the sizes of your node groups.
        /// One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// Structure is documented below.
        /// </summary>
        [Input("autoscalingPolicy")]
        public Input<Inputs.NodeGroupAutoscalingPolicyArgs>? AutoscalingPolicy { get; set; }

        /// <summary>
        /// An optional textual description of the resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The initial number of nodes in the node group. One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// </summary>
        [Input("initialSize")]
        public Input<int>? InitialSize { get; set; }

        /// <summary>
        /// (Optional, Beta)
        /// Specifies the frequency of planned maintenance events. Set to one of the following:
        /// - AS_NEEDED: Hosts are eligible to receive infrastructure and hypervisor updates as they become available.
        /// - RECURRENT: Hosts receive planned infrastructure and hypervisor updates on a periodic basis, but not more frequently than every 28 days. This minimizes the number of planned maintenance operations on individual hosts and reduces the frequency of disruptions, both live migrations and terminations, on individual VMs.
        /// Possible values are: `AS_NEEDED`, `RECURRENT`.
        /// </summary>
        [Input("maintenanceInterval")]
        public Input<string>? MaintenanceInterval { get; set; }

        /// <summary>
        /// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT.
        /// </summary>
        [Input("maintenancePolicy")]
        public Input<string>? MaintenancePolicy { get; set; }

        /// <summary>
        /// contains properties for the timeframe of maintenance
        /// Structure is documented below.
        /// </summary>
        [Input("maintenanceWindow")]
        public Input<Inputs.NodeGroupMaintenanceWindowArgs>? MaintenanceWindow { get; set; }

        /// <summary>
        /// Name of the resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The URL of the node template to which this node group belongs.
        /// </summary>
        [Input("nodeTemplate", required: true)]
        public Input<string> NodeTemplate { get; set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Share settings for the node group.
        /// Structure is documented below.
        /// </summary>
        [Input("shareSettings")]
        public Input<Inputs.NodeGroupShareSettingsArgs>? ShareSettings { get; set; }

        /// <summary>
        /// Zone where this node group is located
        /// </summary>
        [Input("zone")]
        public Input<string>? Zone { get; set; }

        public NodeGroupArgs()
        {
        }
        public static new NodeGroupArgs Empty => new NodeGroupArgs();
    }

    public sealed class NodeGroupState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If you use sole-tenant nodes for your workloads, you can use the node
        /// group autoscaler to automatically manage the sizes of your node groups.
        /// One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// Structure is documented below.
        /// </summary>
        [Input("autoscalingPolicy")]
        public Input<Inputs.NodeGroupAutoscalingPolicyGetArgs>? AutoscalingPolicy { get; set; }

        /// <summary>
        /// Creation timestamp in RFC3339 text format.
        /// </summary>
        [Input("creationTimestamp")]
        public Input<string>? CreationTimestamp { get; set; }

        /// <summary>
        /// An optional textual description of the resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The initial number of nodes in the node group. One of `InitialSize` or `AutoscalingPolicy` must be configured on resource creation.
        /// </summary>
        [Input("initialSize")]
        public Input<int>? InitialSize { get; set; }

        /// <summary>
        /// (Optional, Beta)
        /// Specifies the frequency of planned maintenance events. Set to one of the following:
        /// - AS_NEEDED: Hosts are eligible to receive infrastructure and hypervisor updates as they become available.
        /// - RECURRENT: Hosts receive planned infrastructure and hypervisor updates on a periodic basis, but not more frequently than every 28 days. This minimizes the number of planned maintenance operations on individual hosts and reduces the frequency of disruptions, both live migrations and terminations, on individual VMs.
        /// Possible values are: `AS_NEEDED`, `RECURRENT`.
        /// </summary>
        [Input("maintenanceInterval")]
        public Input<string>? MaintenanceInterval { get; set; }

        /// <summary>
        /// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT.
        /// </summary>
        [Input("maintenancePolicy")]
        public Input<string>? MaintenancePolicy { get; set; }

        /// <summary>
        /// contains properties for the timeframe of maintenance
        /// Structure is documented below.
        /// </summary>
        [Input("maintenanceWindow")]
        public Input<Inputs.NodeGroupMaintenanceWindowGetArgs>? MaintenanceWindow { get; set; }

        /// <summary>
        /// Name of the resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The URL of the node template to which this node group belongs.
        /// </summary>
        [Input("nodeTemplate")]
        public Input<string>? NodeTemplate { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The URI of the created resource.
        /// </summary>
        [Input("selfLink")]
        public Input<string>? SelfLink { get; set; }

        /// <summary>
        /// Share settings for the node group.
        /// Structure is documented below.
        /// </summary>
        [Input("shareSettings")]
        public Input<Inputs.NodeGroupShareSettingsGetArgs>? ShareSettings { get; set; }

        /// <summary>
        /// The total number of nodes in the node group.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// Zone where this node group is located
        /// </summary>
        [Input("zone")]
        public Input<string>? Zone { get; set; }

        public NodeGroupState()
        {
        }
        public static new NodeGroupState Empty => new NodeGroupState();
    }
}
