// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Alloydb
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ### Alloydb Cluster Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var defaultNetwork = new Gcp.Compute.Network("default", new()
    ///     {
    ///         Name = "alloydb-cluster",
    ///     });
    /// 
    ///     var @default = new Gcp.Alloydb.Cluster("default", new()
    ///     {
    ///         ClusterId = "alloydb-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = defaultNetwork.Id,
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// ### Alloydb Cluster Before Upgrade
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = Gcp.Compute.GetNetwork.Invoke(new()
    ///     {
    ///         Name = "alloydb-network",
    ///     });
    /// 
    ///     var defaultCluster = new Gcp.Alloydb.Cluster("default", new()
    ///     {
    ///         ClusterId = "alloydb-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         },
    ///         DatabaseVersion = "POSTGRES_14",
    ///         InitialUser = new Gcp.Alloydb.Inputs.ClusterInitialUserArgs
    ///         {
    ///             Password = "alloydb-cluster",
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var defaultInstance = new Gcp.Alloydb.Instance("default", new()
    ///     {
    ///         Cluster = defaultCluster.Name,
    ///         InstanceId = "alloydb-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Alloydb Cluster After Upgrade
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = Gcp.Compute.GetNetwork.Invoke(new()
    ///     {
    ///         Name = "alloydb-network",
    ///     });
    /// 
    ///     var defaultCluster = new Gcp.Alloydb.Cluster("default", new()
    ///     {
    ///         ClusterId = "alloydb-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         },
    ///         DatabaseVersion = "POSTGRES_15",
    ///         InitialUser = new Gcp.Alloydb.Inputs.ClusterInitialUserArgs
    ///         {
    ///             Password = "alloydb-cluster",
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var defaultInstance = new Gcp.Alloydb.Instance("default", new()
    ///     {
    ///         Cluster = defaultCluster.Name,
    ///         InstanceId = "alloydb-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Alloydb Cluster Full
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.Compute.Network("default", new()
    ///     {
    ///         Name = "alloydb-cluster-full",
    ///     });
    /// 
    ///     var full = new Gcp.Alloydb.Cluster("full", new()
    ///     {
    ///         ClusterId = "alloydb-cluster-full",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Id,
    ///         },
    ///         DatabaseVersion = "POSTGRES_15",
    ///         InitialUser = new Gcp.Alloydb.Inputs.ClusterInitialUserArgs
    ///         {
    ///             User = "alloydb-cluster-full",
    ///             Password = "alloydb-cluster-full",
    ///         },
    ///         ContinuousBackupConfig = new Gcp.Alloydb.Inputs.ClusterContinuousBackupConfigArgs
    ///         {
    ///             Enabled = true,
    ///             RecoveryWindowDays = 14,
    ///         },
    ///         AutomatedBackupPolicy = new Gcp.Alloydb.Inputs.ClusterAutomatedBackupPolicyArgs
    ///         {
    ///             Location = "us-central1",
    ///             BackupWindow = "1800s",
    ///             Enabled = true,
    ///             WeeklySchedule = new Gcp.Alloydb.Inputs.ClusterAutomatedBackupPolicyWeeklyScheduleArgs
    ///             {
    ///                 DaysOfWeeks = new[]
    ///                 {
    ///                     "MONDAY",
    ///                 },
    ///                 StartTimes = new[]
    ///                 {
    ///                     new Gcp.Alloydb.Inputs.ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs
    ///                     {
    ///                         Hours = 23,
    ///                         Minutes = 0,
    ///                         Seconds = 0,
    ///                         Nanos = 0,
    ///                     },
    ///                 },
    ///             },
    ///             QuantityBasedRetention = new Gcp.Alloydb.Inputs.ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs
    ///             {
    ///                 Count = 1,
    ///             },
    ///             Labels = 
    ///             {
    ///                 { "test", "alloydb-cluster-full" },
    ///             },
    ///         },
    ///         Labels = 
    ///         {
    ///             { "test", "alloydb-cluster-full" },
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// ### Alloydb Cluster Restore
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = Gcp.Compute.GetNetwork.Invoke(new()
    ///     {
    ///         Name = "alloydb-network",
    ///     });
    /// 
    ///     var source = new Gcp.Alloydb.Cluster("source", new()
    ///     {
    ///         ClusterId = "alloydb-source-cluster",
    ///         Location = "us-central1",
    ///         Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         InitialUser = new Gcp.Alloydb.Inputs.ClusterInitialUserArgs
    ///         {
    ///             Password = "alloydb-source-cluster",
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var privateIpAlloc = new Gcp.Compute.GlobalAddress("private_ip_alloc", new()
    ///     {
    ///         Name = "alloydb-source-cluster",
    ///         AddressType = "INTERNAL",
    ///         Purpose = "VPC_PEERING",
    ///         PrefixLength = 16,
    ///         Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///     });
    /// 
    ///     var vpcConnection = new Gcp.ServiceNetworking.Connection("vpc_connection", new()
    ///     {
    ///         Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         Service = "servicenetworking.googleapis.com",
    ///         ReservedPeeringRanges = new[]
    ///         {
    ///             privateIpAlloc.Name,
    ///         },
    ///     });
    /// 
    ///     var sourceInstance = new Gcp.Alloydb.Instance("source", new()
    ///     {
    ///         Cluster = source.Name,
    ///         InstanceId = "alloydb-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             vpcConnection,
    ///         },
    ///     });
    /// 
    ///     var sourceBackup = new Gcp.Alloydb.Backup("source", new()
    ///     {
    ///         BackupId = "alloydb-backup",
    ///         Location = "us-central1",
    ///         ClusterName = source.Name,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             sourceInstance,
    ///         },
    ///     });
    /// 
    ///     var restoredFromBackup = new Gcp.Alloydb.Cluster("restored_from_backup", new()
    ///     {
    ///         ClusterId = "alloydb-backup-restored",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         },
    ///         RestoreBackupSource = new Gcp.Alloydb.Inputs.ClusterRestoreBackupSourceArgs
    ///         {
    ///             BackupName = sourceBackup.Name,
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var restoredViaPitr = new Gcp.Alloydb.Cluster("restored_via_pitr", new()
    ///     {
    ///         ClusterId = "alloydb-pitr-restored",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Apply(@default =&gt; @default.Apply(getNetworkResult =&gt; getNetworkResult.Id)),
    ///         },
    ///         RestoreContinuousBackupSource = new Gcp.Alloydb.Inputs.ClusterRestoreContinuousBackupSourceArgs
    ///         {
    ///             Cluster = source.Name,
    ///             PointInTime = "2023-08-03T19:19:00.094Z",
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// ### Alloydb Secondary Cluster Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.Compute.Network("default", new()
    ///     {
    ///         Name = "alloydb-secondary-cluster",
    ///     });
    /// 
    ///     var primary = new Gcp.Alloydb.Cluster("primary", new()
    ///     {
    ///         ClusterId = "alloydb-primary-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Id,
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var privateIpAlloc = new Gcp.Compute.GlobalAddress("private_ip_alloc", new()
    ///     {
    ///         Name = "alloydb-secondary-cluster",
    ///         AddressType = "INTERNAL",
    ///         Purpose = "VPC_PEERING",
    ///         PrefixLength = 16,
    ///         Network = @default.Id,
    ///     });
    /// 
    ///     var vpcConnection = new Gcp.ServiceNetworking.Connection("vpc_connection", new()
    ///     {
    ///         Network = @default.Id,
    ///         Service = "servicenetworking.googleapis.com",
    ///         ReservedPeeringRanges = new[]
    ///         {
    ///             privateIpAlloc.Name,
    ///         },
    ///     });
    /// 
    ///     var primaryInstance = new Gcp.Alloydb.Instance("primary", new()
    ///     {
    ///         Cluster = primary.Name,
    ///         InstanceId = "alloydb-primary-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             vpcConnection,
    ///         },
    ///     });
    /// 
    ///     var secondary = new Gcp.Alloydb.Cluster("secondary", new()
    ///     {
    ///         ClusterId = "alloydb-secondary-cluster",
    ///         Location = "us-east1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Id,
    ///         },
    ///         ClusterType = "SECONDARY",
    ///         ContinuousBackupConfig = new Gcp.Alloydb.Inputs.ClusterContinuousBackupConfigArgs
    ///         {
    ///             Enabled = false,
    ///         },
    ///         SecondaryConfig = new Gcp.Alloydb.Inputs.ClusterSecondaryConfigArgs
    ///         {
    ///             PrimaryClusterName = primary.Name,
    ///         },
    ///         DeletionProtection = false,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             primaryInstance,
    ///         },
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Cluster can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}`
    /// 
    /// * `{{project}}/{{location}}/{{cluster_id}}`
    /// 
    /// * `{{location}}/{{cluster_id}}`
    /// 
    /// * `{{cluster_id}}`
    /// 
    /// When using the `pulumi import` command, Cluster can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:alloydb/cluster:Cluster default projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:alloydb/cluster:Cluster default {{project}}/{{location}}/{{cluster_id}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:alloydb/cluster:Cluster default {{location}}/{{cluster_id}}
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import gcp:alloydb/cluster:Cluster default {{cluster_id}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:alloydb/cluster:Cluster")]
    public partial class Cluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
        /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        /// 
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        [Output("annotations")]
        public Output<ImmutableDictionary<string, string>?> Annotations { get; private set; } = null!;

        /// <summary>
        /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
        /// Structure is documented below.
        /// </summary>
        [Output("automatedBackupPolicy")]
        public Output<Outputs.ClusterAutomatedBackupPolicy> AutomatedBackupPolicy { get; private set; } = null!;

        /// <summary>
        /// Cluster created from backup.
        /// Structure is documented below.
        /// </summary>
        [Output("backupSources")]
        public Output<ImmutableArray<Outputs.ClusterBackupSource>> BackupSources { get; private set; } = null!;

        /// <summary>
        /// Cluster created from a BackupDR backup.
        /// Structure is documented below.
        /// </summary>
        [Output("backupdrBackupSources")]
        public Output<ImmutableArray<Outputs.ClusterBackupdrBackupSource>> BackupdrBackupSources { get; private set; } = null!;

        /// <summary>
        /// The ID of the alloydb cluster.
        /// </summary>
        [Output("clusterId")]
        public Output<string> ClusterId { get; private set; } = null!;

        /// <summary>
        /// The type of cluster. If not set, defaults to PRIMARY.
        /// Default value is `PRIMARY`.
        /// Possible values are: `PRIMARY`, `SECONDARY`.
        /// </summary>
        [Output("clusterType")]
        public Output<string?> ClusterType { get; private set; } = null!;

        /// <summary>
        /// The continuous backup config for this cluster.
        /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
        /// Structure is documented below.
        /// </summary>
        [Output("continuousBackupConfig")]
        public Output<Outputs.ClusterContinuousBackupConfig> ContinuousBackupConfig { get; private set; } = null!;

        /// <summary>
        /// ContinuousBackupInfo describes the continuous backup properties of a cluster.
        /// Structure is documented below.
        /// </summary>
        [Output("continuousBackupInfos")]
        public Output<ImmutableArray<Outputs.ClusterContinuousBackupInfo>> ContinuousBackupInfos { get; private set; } = null!;

        /// <summary>
        /// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
        /// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
        /// </summary>
        [Output("databaseVersion")]
        public Output<string> DatabaseVersion { get; private set; } = null!;

        /// <summary>
        /// Policy to determine if the cluster should be deleted forcefully.
        /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
        /// Deleting a Secondary cluster with a secondary instance REQUIRES setting DeletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
        /// Possible values: DEFAULT, FORCE
        /// </summary>
        [Output("deletionPolicy")]
        public Output<string?> DeletionPolicy { get; private set; } = null!;

        [Output("deletionProtection")]
        public Output<bool?> DeletionProtection { get; private set; } = null!;

        /// <summary>
        /// User-settable and human-readable display name for the Cluster.
        /// </summary>
        [Output("displayName")]
        public Output<string?> DisplayName { get; private set; } = null!;

        [Output("effectiveAnnotations")]
        public Output<ImmutableDictionary<string, string>> EffectiveAnnotations { get; private set; } = null!;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        [Output("effectiveLabels")]
        public Output<ImmutableDictionary<string, string>> EffectiveLabels { get; private set; } = null!;

        /// <summary>
        /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        /// Structure is documented below.
        /// </summary>
        [Output("encryptionConfig")]
        public Output<Outputs.ClusterEncryptionConfig?> EncryptionConfig { get; private set; } = null!;

        /// <summary>
        /// (Output)
        /// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
        /// Structure is documented below.
        /// </summary>
        [Output("encryptionInfos")]
        public Output<ImmutableArray<Outputs.ClusterEncryptionInfo>> EncryptionInfos { get; private set; } = null!;

        /// <summary>
        /// For Resource freshness validation (https://google.aip.dev/154)
        /// </summary>
        [Output("etag")]
        public Output<string?> Etag { get; private set; } = null!;

        /// <summary>
        /// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
        /// Structure is documented below.
        /// </summary>
        [Output("initialUser")]
        public Output<Outputs.ClusterInitialUser?> InitialUser { get; private set; } = null!;

        /// <summary>
        /// User-defined labels for the alloydb cluster.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// The location where the alloydb cluster should reside.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// MaintenanceUpdatePolicy defines the policy for system updates.
        /// Structure is documented below.
        /// </summary>
        [Output("maintenanceUpdatePolicy")]
        public Output<Outputs.ClusterMaintenanceUpdatePolicy?> MaintenanceUpdatePolicy { get; private set; } = null!;

        /// <summary>
        /// Cluster created via DMS migration.
        /// Structure is documented below.
        /// </summary>
        [Output("migrationSources")]
        public Output<ImmutableArray<Outputs.ClusterMigrationSource>> MigrationSources { get; private set; } = null!;

        /// <summary>
        /// The name of the cluster resource.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Metadata related to network configuration.
        /// Structure is documented below.
        /// </summary>
        [Output("networkConfig")]
        public Output<Outputs.ClusterNetworkConfig> NetworkConfig { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the cluster.
        /// Structure is documented below.
        /// </summary>
        [Output("pscConfig")]
        public Output<Outputs.ClusterPscConfig?> PscConfig { get; private set; } = null!;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        [Output("pulumiLabels")]
        public Output<ImmutableDictionary<string, string>> PulumiLabels { get; private set; } = null!;

        /// <summary>
        /// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
        /// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
        /// This can happen due to user-triggered updates or system actions like failover or maintenance.
        /// </summary>
        [Output("reconciling")]
        public Output<bool> Reconciling { get; private set; } = null!;

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Output("restoreBackupSource")]
        public Output<Outputs.ClusterRestoreBackupSource?> RestoreBackupSource { get; private set; } = null!;

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Output("restoreBackupdrBackupSource")]
        public Output<Outputs.ClusterRestoreBackupdrBackupSource?> RestoreBackupdrBackupSource { get; private set; } = null!;

        /// <summary>
        /// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
        /// Structure is documented below.
        /// </summary>
        [Output("restoreBackupdrPitrSource")]
        public Output<Outputs.ClusterRestoreBackupdrPitrSource?> RestoreBackupdrPitrSource { get; private set; } = null!;

        /// <summary>
        /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Output("restoreContinuousBackupSource")]
        public Output<Outputs.ClusterRestoreContinuousBackupSource?> RestoreContinuousBackupSource { get; private set; } = null!;

        /// <summary>
        /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
        /// Structure is documented below.
        /// </summary>
        [Output("secondaryConfig")]
        public Output<Outputs.ClusterSecondaryConfig?> SecondaryConfig { get; private set; } = null!;

        /// <summary>
        /// Set to true to skip awaiting on the major version upgrade of the cluster.
        /// Possible values: true, false
        /// Default value: "true"
        /// </summary>
        [Output("skipAwaitMajorVersionUpgrade")]
        public Output<bool?> SkipAwaitMajorVersionUpgrade { get; private set; } = null!;

        /// <summary>
        /// Output only. The current serving state of the cluster.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// The subscrition type of cluster.
        /// Possible values are: `TRIAL`, `STANDARD`.
        /// </summary>
        [Output("subscriptionType")]
        public Output<string> SubscriptionType { get; private set; } = null!;

        /// <summary>
        /// Contains information and all metadata related to TRIAL clusters.
        /// Structure is documented below.
        /// </summary>
        [Output("trialMetadatas")]
        public Output<ImmutableArray<Outputs.ClusterTrialMetadata>> TrialMetadatas { get; private set; } = null!;

        /// <summary>
        /// The system-generated UID of the resource.
        /// </summary>
        [Output("uid")]
        public Output<string> Uid { get; private set; } = null!;


        /// <summary>
        /// Create a Cluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Cluster(string name, ClusterArgs args, CustomResourceOptions? options = null)
            : base("gcp:alloydb/cluster:Cluster", name, args ?? new ClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Cluster(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
            : base("gcp:alloydb/cluster:Cluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "effectiveLabels",
                    "pulumiLabels",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Cluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Cluster Get(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new Cluster(name, id, state, options);
        }
    }

    public sealed class ClusterArgs : global::Pulumi.ResourceArgs
    {
        [Input("annotations")]
        private InputMap<string>? _annotations;

        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
        /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        /// 
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        public InputMap<string> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<string>());
            set => _annotations = value;
        }

        /// <summary>
        /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
        /// Structure is documented below.
        /// </summary>
        [Input("automatedBackupPolicy")]
        public Input<Inputs.ClusterAutomatedBackupPolicyArgs>? AutomatedBackupPolicy { get; set; }

        /// <summary>
        /// The ID of the alloydb cluster.
        /// </summary>
        [Input("clusterId", required: true)]
        public Input<string> ClusterId { get; set; } = null!;

        /// <summary>
        /// The type of cluster. If not set, defaults to PRIMARY.
        /// Default value is `PRIMARY`.
        /// Possible values are: `PRIMARY`, `SECONDARY`.
        /// </summary>
        [Input("clusterType")]
        public Input<string>? ClusterType { get; set; }

        /// <summary>
        /// The continuous backup config for this cluster.
        /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
        /// Structure is documented below.
        /// </summary>
        [Input("continuousBackupConfig")]
        public Input<Inputs.ClusterContinuousBackupConfigArgs>? ContinuousBackupConfig { get; set; }

        /// <summary>
        /// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
        /// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
        /// </summary>
        [Input("databaseVersion")]
        public Input<string>? DatabaseVersion { get; set; }

        /// <summary>
        /// Policy to determine if the cluster should be deleted forcefully.
        /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
        /// Deleting a Secondary cluster with a secondary instance REQUIRES setting DeletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
        /// Possible values: DEFAULT, FORCE
        /// </summary>
        [Input("deletionPolicy")]
        public Input<string>? DeletionPolicy { get; set; }

        [Input("deletionProtection")]
        public Input<bool>? DeletionProtection { get; set; }

        /// <summary>
        /// User-settable and human-readable display name for the Cluster.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        /// Structure is documented below.
        /// </summary>
        [Input("encryptionConfig")]
        public Input<Inputs.ClusterEncryptionConfigArgs>? EncryptionConfig { get; set; }

        /// <summary>
        /// For Resource freshness validation (https://google.aip.dev/154)
        /// </summary>
        [Input("etag")]
        public Input<string>? Etag { get; set; }

        /// <summary>
        /// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
        /// Structure is documented below.
        /// </summary>
        [Input("initialUser")]
        public Input<Inputs.ClusterInitialUserArgs>? InitialUser { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// User-defined labels for the alloydb cluster.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// The location where the alloydb cluster should reside.
        /// </summary>
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        /// <summary>
        /// MaintenanceUpdatePolicy defines the policy for system updates.
        /// Structure is documented below.
        /// </summary>
        [Input("maintenanceUpdatePolicy")]
        public Input<Inputs.ClusterMaintenanceUpdatePolicyArgs>? MaintenanceUpdatePolicy { get; set; }

        /// <summary>
        /// Metadata related to network configuration.
        /// Structure is documented below.
        /// </summary>
        [Input("networkConfig")]
        public Input<Inputs.ClusterNetworkConfigArgs>? NetworkConfig { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the cluster.
        /// Structure is documented below.
        /// </summary>
        [Input("pscConfig")]
        public Input<Inputs.ClusterPscConfigArgs>? PscConfig { get; set; }

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupSource")]
        public Input<Inputs.ClusterRestoreBackupSourceArgs>? RestoreBackupSource { get; set; }

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupdrBackupSource")]
        public Input<Inputs.ClusterRestoreBackupdrBackupSourceArgs>? RestoreBackupdrBackupSource { get; set; }

        /// <summary>
        /// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupdrPitrSource")]
        public Input<Inputs.ClusterRestoreBackupdrPitrSourceArgs>? RestoreBackupdrPitrSource { get; set; }

        /// <summary>
        /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreContinuousBackupSource")]
        public Input<Inputs.ClusterRestoreContinuousBackupSourceArgs>? RestoreContinuousBackupSource { get; set; }

        /// <summary>
        /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
        /// Structure is documented below.
        /// </summary>
        [Input("secondaryConfig")]
        public Input<Inputs.ClusterSecondaryConfigArgs>? SecondaryConfig { get; set; }

        /// <summary>
        /// Set to true to skip awaiting on the major version upgrade of the cluster.
        /// Possible values: true, false
        /// Default value: "true"
        /// </summary>
        [Input("skipAwaitMajorVersionUpgrade")]
        public Input<bool>? SkipAwaitMajorVersionUpgrade { get; set; }

        /// <summary>
        /// The subscrition type of cluster.
        /// Possible values are: `TRIAL`, `STANDARD`.
        /// </summary>
        [Input("subscriptionType")]
        public Input<string>? SubscriptionType { get; set; }

        public ClusterArgs()
        {
        }
        public static new ClusterArgs Empty => new ClusterArgs();
    }

    public sealed class ClusterState : global::Pulumi.ResourceArgs
    {
        [Input("annotations")]
        private InputMap<string>? _annotations;

        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
        /// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        /// 
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        public InputMap<string> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<string>());
            set => _annotations = value;
        }

        /// <summary>
        /// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
        /// Structure is documented below.
        /// </summary>
        [Input("automatedBackupPolicy")]
        public Input<Inputs.ClusterAutomatedBackupPolicyGetArgs>? AutomatedBackupPolicy { get; set; }

        [Input("backupSources")]
        private InputList<Inputs.ClusterBackupSourceGetArgs>? _backupSources;

        /// <summary>
        /// Cluster created from backup.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterBackupSourceGetArgs> BackupSources
        {
            get => _backupSources ?? (_backupSources = new InputList<Inputs.ClusterBackupSourceGetArgs>());
            set => _backupSources = value;
        }

        [Input("backupdrBackupSources")]
        private InputList<Inputs.ClusterBackupdrBackupSourceGetArgs>? _backupdrBackupSources;

        /// <summary>
        /// Cluster created from a BackupDR backup.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterBackupdrBackupSourceGetArgs> BackupdrBackupSources
        {
            get => _backupdrBackupSources ?? (_backupdrBackupSources = new InputList<Inputs.ClusterBackupdrBackupSourceGetArgs>());
            set => _backupdrBackupSources = value;
        }

        /// <summary>
        /// The ID of the alloydb cluster.
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        /// <summary>
        /// The type of cluster. If not set, defaults to PRIMARY.
        /// Default value is `PRIMARY`.
        /// Possible values are: `PRIMARY`, `SECONDARY`.
        /// </summary>
        [Input("clusterType")]
        public Input<string>? ClusterType { get; set; }

        /// <summary>
        /// The continuous backup config for this cluster.
        /// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
        /// Structure is documented below.
        /// </summary>
        [Input("continuousBackupConfig")]
        public Input<Inputs.ClusterContinuousBackupConfigGetArgs>? ContinuousBackupConfig { get; set; }

        [Input("continuousBackupInfos")]
        private InputList<Inputs.ClusterContinuousBackupInfoGetArgs>? _continuousBackupInfos;

        /// <summary>
        /// ContinuousBackupInfo describes the continuous backup properties of a cluster.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterContinuousBackupInfoGetArgs> ContinuousBackupInfos
        {
            get => _continuousBackupInfos ?? (_continuousBackupInfos = new InputList<Inputs.ClusterContinuousBackupInfoGetArgs>());
            set => _continuousBackupInfos = value;
        }

        /// <summary>
        /// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
        /// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
        /// </summary>
        [Input("databaseVersion")]
        public Input<string>? DatabaseVersion { get; set; }

        /// <summary>
        /// Policy to determine if the cluster should be deleted forcefully.
        /// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
        /// Deleting a Secondary cluster with a secondary instance REQUIRES setting DeletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
        /// Possible values: DEFAULT, FORCE
        /// </summary>
        [Input("deletionPolicy")]
        public Input<string>? DeletionPolicy { get; set; }

        [Input("deletionProtection")]
        public Input<bool>? DeletionProtection { get; set; }

        /// <summary>
        /// User-settable and human-readable display name for the Cluster.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        [Input("effectiveAnnotations")]
        private InputMap<string>? _effectiveAnnotations;
        public InputMap<string> EffectiveAnnotations
        {
            get => _effectiveAnnotations ?? (_effectiveAnnotations = new InputMap<string>());
            set => _effectiveAnnotations = value;
        }

        [Input("effectiveLabels")]
        private InputMap<string>? _effectiveLabels;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveLabels
        {
            get => _effectiveLabels ?? (_effectiveLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _effectiveLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        /// Structure is documented below.
        /// </summary>
        [Input("encryptionConfig")]
        public Input<Inputs.ClusterEncryptionConfigGetArgs>? EncryptionConfig { get; set; }

        [Input("encryptionInfos")]
        private InputList<Inputs.ClusterEncryptionInfoGetArgs>? _encryptionInfos;

        /// <summary>
        /// (Output)
        /// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterEncryptionInfoGetArgs> EncryptionInfos
        {
            get => _encryptionInfos ?? (_encryptionInfos = new InputList<Inputs.ClusterEncryptionInfoGetArgs>());
            set => _encryptionInfos = value;
        }

        /// <summary>
        /// For Resource freshness validation (https://google.aip.dev/154)
        /// </summary>
        [Input("etag")]
        public Input<string>? Etag { get; set; }

        /// <summary>
        /// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
        /// Structure is documented below.
        /// </summary>
        [Input("initialUser")]
        public Input<Inputs.ClusterInitialUserGetArgs>? InitialUser { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// User-defined labels for the alloydb cluster.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// The location where the alloydb cluster should reside.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// MaintenanceUpdatePolicy defines the policy for system updates.
        /// Structure is documented below.
        /// </summary>
        [Input("maintenanceUpdatePolicy")]
        public Input<Inputs.ClusterMaintenanceUpdatePolicyGetArgs>? MaintenanceUpdatePolicy { get; set; }

        [Input("migrationSources")]
        private InputList<Inputs.ClusterMigrationSourceGetArgs>? _migrationSources;

        /// <summary>
        /// Cluster created via DMS migration.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterMigrationSourceGetArgs> MigrationSources
        {
            get => _migrationSources ?? (_migrationSources = new InputList<Inputs.ClusterMigrationSourceGetArgs>());
            set => _migrationSources = value;
        }

        /// <summary>
        /// The name of the cluster resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Metadata related to network configuration.
        /// Structure is documented below.
        /// </summary>
        [Input("networkConfig")]
        public Input<Inputs.ClusterNetworkConfigGetArgs>? NetworkConfig { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the cluster.
        /// Structure is documented below.
        /// </summary>
        [Input("pscConfig")]
        public Input<Inputs.ClusterPscConfigGetArgs>? PscConfig { get; set; }

        [Input("pulumiLabels")]
        private InputMap<string>? _pulumiLabels;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        public InputMap<string> PulumiLabels
        {
            get => _pulumiLabels ?? (_pulumiLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _pulumiLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
        /// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
        /// This can happen due to user-triggered updates or system actions like failover or maintenance.
        /// </summary>
        [Input("reconciling")]
        public Input<bool>? Reconciling { get; set; }

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupSource")]
        public Input<Inputs.ClusterRestoreBackupSourceGetArgs>? RestoreBackupSource { get; set; }

        /// <summary>
        /// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupdrBackupSource")]
        public Input<Inputs.ClusterRestoreBackupdrBackupSourceGetArgs>? RestoreBackupdrBackupSource { get; set; }

        /// <summary>
        /// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreBackupdrPitrSource")]
        public Input<Inputs.ClusterRestoreBackupdrPitrSourceGetArgs>? RestoreBackupdrPitrSource { get; set; }

        /// <summary>
        /// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
        /// Structure is documented below.
        /// </summary>
        [Input("restoreContinuousBackupSource")]
        public Input<Inputs.ClusterRestoreContinuousBackupSourceGetArgs>? RestoreContinuousBackupSource { get; set; }

        /// <summary>
        /// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
        /// Structure is documented below.
        /// </summary>
        [Input("secondaryConfig")]
        public Input<Inputs.ClusterSecondaryConfigGetArgs>? SecondaryConfig { get; set; }

        /// <summary>
        /// Set to true to skip awaiting on the major version upgrade of the cluster.
        /// Possible values: true, false
        /// Default value: "true"
        /// </summary>
        [Input("skipAwaitMajorVersionUpgrade")]
        public Input<bool>? SkipAwaitMajorVersionUpgrade { get; set; }

        /// <summary>
        /// Output only. The current serving state of the cluster.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The subscrition type of cluster.
        /// Possible values are: `TRIAL`, `STANDARD`.
        /// </summary>
        [Input("subscriptionType")]
        public Input<string>? SubscriptionType { get; set; }

        [Input("trialMetadatas")]
        private InputList<Inputs.ClusterTrialMetadataGetArgs>? _trialMetadatas;

        /// <summary>
        /// Contains information and all metadata related to TRIAL clusters.
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterTrialMetadataGetArgs> TrialMetadatas
        {
            get => _trialMetadatas ?? (_trialMetadatas = new InputList<Inputs.ClusterTrialMetadataGetArgs>());
            set => _trialMetadatas = value;
        }

        /// <summary>
        /// The system-generated UID of the resource.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        public ClusterState()
        {
        }
        public static new ClusterState Empty => new ClusterState();
    }
}
