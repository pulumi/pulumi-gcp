// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Alloydb
{
    /// <summary>
    /// A managed alloydb cluster instance.
    /// 
    /// To get more information about Instance, see:
    /// 
    /// * [API documentation](https://cloud.google.com/alloydb/docs/reference/rest/v1/projects.locations.clusters.instances/create)
    /// * How-to Guides
    ///     * [AlloyDB](https://cloud.google.com/alloydb/docs/)
    /// 
    /// &gt; **Warning:** Deleting an instance with instanceType = SECONDARY does not delete the secondary instance, and abandons it instead.
    /// Use DeletionPolicy = "FORCE" in the associated secondary cluster and delete the cluster forcefully to delete the secondary cluster as well its associated secondary instance.
    /// Users can undo the delete secondary instance action by importing the deleted secondary instance by calling terraform import.
    /// 
    /// ## Example Usage
    /// 
    /// ### Alloydb Instance Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var defaultNetwork = new Gcp.Compute.Network("default", new()
    ///     {
    ///         Name = "alloydb-network",
    ///     });
    /// 
    ///     var defaultCluster = new Gcp.Alloydb.Cluster("default", new()
    ///     {
    ///         ClusterId = "alloydb-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = defaultNetwork.Id,
    ///         },
    ///         InitialUser = new Gcp.Alloydb.Inputs.ClusterInitialUserArgs
    ///         {
    ///             Password = "alloydb-cluster",
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var privateIpAlloc = new Gcp.Compute.GlobalAddress("private_ip_alloc", new()
    ///     {
    ///         Name = "alloydb-cluster",
    ///         AddressType = "INTERNAL",
    ///         Purpose = "VPC_PEERING",
    ///         PrefixLength = 16,
    ///         Network = defaultNetwork.Id,
    ///     });
    /// 
    ///     var vpcConnection = new Gcp.ServiceNetworking.Connection("vpc_connection", new()
    ///     {
    ///         Network = defaultNetwork.Id,
    ///         Service = "servicenetworking.googleapis.com",
    ///         ReservedPeeringRanges = new[]
    ///         {
    ///             privateIpAlloc.Name,
    ///         },
    ///     });
    /// 
    ///     var @default = new Gcp.Alloydb.Instance("default", new()
    ///     {
    ///         Cluster = defaultCluster.Name,
    ///         InstanceId = "alloydb-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             vpcConnection,
    ///         },
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// ### Alloydb Secondary Instance Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @default = new Gcp.Compute.Network("default", new()
    ///     {
    ///         Name = "alloydb-secondary-network",
    ///     });
    /// 
    ///     var primary = new Gcp.Alloydb.Cluster("primary", new()
    ///     {
    ///         ClusterId = "alloydb-primary-cluster",
    ///         Location = "us-central1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = @default.Id,
    ///         },
    ///         DeletionProtection = false,
    ///     });
    /// 
    ///     var privateIpAlloc = new Gcp.Compute.GlobalAddress("private_ip_alloc", new()
    ///     {
    ///         Name = "alloydb-secondary-instance",
    ///         AddressType = "INTERNAL",
    ///         Purpose = "VPC_PEERING",
    ///         PrefixLength = 16,
    ///         Network = @default.Id,
    ///     });
    /// 
    ///     var vpcConnection = new Gcp.ServiceNetworking.Connection("vpc_connection", new()
    ///     {
    ///         Network = @default.Id,
    ///         Service = "servicenetworking.googleapis.com",
    ///         ReservedPeeringRanges = new[]
    ///         {
    ///             privateIpAlloc.Name,
    ///         },
    ///     });
    /// 
    ///     var primaryInstance = new Gcp.Alloydb.Instance("primary", new()
    ///     {
    ///         Cluster = primary.Name,
    ///         InstanceId = "alloydb-primary-instance",
    ///         InstanceType = "PRIMARY",
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             vpcConnection,
    ///         },
    ///     });
    /// 
    ///     var secondary = new Gcp.Alloydb.Cluster("secondary", new()
    ///     {
    ///         ClusterId = "alloydb-secondary-cluster",
    ///         Location = "us-east1",
    ///         NetworkConfig = new Gcp.Alloydb.Inputs.ClusterNetworkConfigArgs
    ///         {
    ///             Network = defaultGoogleComputeNetwork.Id,
    ///         },
    ///         ClusterType = "SECONDARY",
    ///         ContinuousBackupConfig = new Gcp.Alloydb.Inputs.ClusterContinuousBackupConfigArgs
    ///         {
    ///             Enabled = false,
    ///         },
    ///         SecondaryConfig = new Gcp.Alloydb.Inputs.ClusterSecondaryConfigArgs
    ///         {
    ///             PrimaryClusterName = primary.Name,
    ///         },
    ///         DeletionPolicy = "FORCE",
    ///         DeletionProtection = false,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             primaryInstance,
    ///         },
    ///     });
    /// 
    ///     var secondaryInstance = new Gcp.Alloydb.Instance("secondary", new()
    ///     {
    ///         Cluster = secondary.Name,
    ///         InstanceId = "alloydb-secondary-instance",
    ///         InstanceType = secondary.ClusterType,
    ///         MachineConfig = new Gcp.Alloydb.Inputs.InstanceMachineConfigArgs
    ///         {
    ///             CpuCount = 2,
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             vpcConnection,
    ///         },
    ///     });
    /// 
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Instance can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/instances/{{instance_id}}`
    /// * `{{project}}/{{location}}/{{cluster}}/{{instance_id}}`
    /// * `{{location}}/{{cluster}}/{{instance_id}}`
    /// 
    /// When using the `pulumi import` command, Instance can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:alloydb/instance:Instance default projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/instances/{{instance_id}}
    /// $ pulumi import gcp:alloydb/instance:Instance default {{project}}/{{location}}/{{cluster}}/{{instance_id}}
    /// $ pulumi import gcp:alloydb/instance:Instance default {{location}}/{{cluster}}/{{instance_id}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:alloydb/instance:Instance")]
    public partial class Instance : global::Pulumi.CustomResource
    {
        /// <summary>
        /// 'Specifies whether an instance needs to spin up. Once the instance is
        /// active, the activation policy can be updated to the `NEVER` to stop the
        /// instance. Likewise, the activation policy can be updated to `ALWAYS` to
        /// start the instance.
        /// There are restrictions around when an instance can/cannot be activated (for
        /// example, a read pool instance should be stopped before stopping primary
        /// etc.). Please refer to the API documentation for more details.
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.'
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.
        /// </summary>
        [Output("activationPolicy")]
        public Output<string> ActivationPolicy { get; private set; } = null!;

        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels.
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        [Output("annotations")]
        public Output<ImmutableDictionary<string, string>?> Annotations { get; private set; } = null!;

        /// <summary>
        /// 'Availability type of an Instance. Defaults to REGIONAL for both primary and read instances.
        /// Note that primary and read instances can have different availability types.
        /// Primary instances can be either ZONAL or REGIONAL. Read Pool instances can also be either ZONAL or REGIONAL.
        /// Read pools of size 1 can only have zonal availability. Read pools with a node count of 2 or more
        /// can have regional availability (nodes are present in 2 or more zones in a region).
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.'
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.
        /// </summary>
        [Output("availabilityType")]
        public Output<string> AvailabilityType { get; private set; } = null!;

        /// <summary>
        /// Client connection specific configurations.
        /// Structure is documented below.
        /// </summary>
        [Output("clientConnectionConfig")]
        public Output<Outputs.InstanceClientConnectionConfig> ClientConnectionConfig { get; private set; } = null!;

        /// <summary>
        /// Identifies the alloydb cluster. Must be in the format
        /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
        /// </summary>
        [Output("cluster")]
        public Output<string> Cluster { get; private set; } = null!;

        /// <summary>
        /// Configuration for Managed Connection Pool.
        /// Structure is documented below.
        /// </summary>
        [Output("connectionPoolConfig")]
        public Output<Outputs.InstanceConnectionPoolConfig?> ConnectionPoolConfig { get; private set; } = null!;

        /// <summary>
        /// Time the Instance was created in UTC.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// Database flags. Set at instance level. * They are copied from primary instance on read instance creation. * Read instances can set new or override existing flags that are relevant for reads, e.g. for enabling columnar cache on a read instance. Flags set on read instance may or may not be present on primary.
        /// </summary>
        [Output("databaseFlags")]
        public Output<ImmutableDictionary<string, string>> DatabaseFlags { get; private set; } = null!;

        /// <summary>
        /// User-settable and human-readable display name for the Instance.
        /// </summary>
        [Output("displayName")]
        public Output<string?> DisplayName { get; private set; } = null!;

        /// <summary>
        /// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
        /// </summary>
        [Output("effectiveAnnotations")]
        public Output<ImmutableDictionary<string, string>> EffectiveAnnotations { get; private set; } = null!;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        [Output("effectiveLabels")]
        public Output<ImmutableDictionary<string, string>> EffectiveLabels { get; private set; } = null!;

        /// <summary>
        /// The Compute Engine zone that the instance should serve from, per https://cloud.google.com/compute/docs/regions-zones This can ONLY be specified for ZONAL instances. If present for a REGIONAL instance, an error will be thrown. If this is absent for a ZONAL instance, instance is created in a random zone with available capacity.
        /// </summary>
        [Output("gceZone")]
        public Output<string?> GceZone { get; private set; } = null!;

        /// <summary>
        /// The ID of the alloydb instance.
        /// </summary>
        [Output("instanceId")]
        public Output<string> InstanceId { get; private set; } = null!;

        /// <summary>
        /// The type of the instance.
        /// If the instance type is READ_POOL, provide the associated PRIMARY/SECONDARY instance in the `DependsOn` meta-data attribute.
        /// If the instance type is SECONDARY, point to the ClusterType of the associated secondary cluster instead of mentioning SECONDARY.
        /// Example: {instance_type = google_alloydb_cluster.&lt;secondary_cluster_name&gt;.cluster_type} instead of {instance_type = SECONDARY}
        /// If the instance type is SECONDARY, the terraform delete instance operation does not delete the secondary instance but abandons it instead.
        /// Use DeletionPolicy = "FORCE" in the associated secondary cluster and delete the cluster forcefully to delete the secondary cluster as well its associated secondary instance.
        /// Users can undo the delete secondary instance action by importing the deleted secondary instance by calling terraform import.
        /// Possible values are: `PRIMARY`, `READ_POOL`, `SECONDARY`.
        /// </summary>
        [Output("instanceType")]
        public Output<string> InstanceType { get; private set; } = null!;

        /// <summary>
        /// The IP address for the Instance. This is the connection endpoint for an end-user application.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// User-defined labels for the alloydb instance.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Configurations for the machines that host the underlying database engine.
        /// Structure is documented below.
        /// </summary>
        [Output("machineConfig")]
        public Output<Outputs.InstanceMachineConfig> MachineConfig { get; private set; } = null!;

        /// <summary>
        /// The name of the instance resource.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Instance level network configuration.
        /// Structure is documented below.
        /// </summary>
        [Output("networkConfig")]
        public Output<Outputs.InstanceNetworkConfig> NetworkConfig { get; private set; } = null!;

        /// <summary>
        /// (Optional, Beta)
        /// Configuration for enhanced query insights.
        /// Structure is documented below.
        /// </summary>
        [Output("observabilityConfig")]
        public Output<Outputs.InstanceObservabilityConfig> ObservabilityConfig { get; private set; } = null!;

        /// <summary>
        /// The outbound public IP addresses for the instance. This is available ONLY when
        /// networkConfig.enableOutboundPublicIp is set to true. These IP addresses are used
        /// for outbound connections.
        /// </summary>
        [Output("outboundPublicIpAddresses")]
        public Output<ImmutableArray<string>> OutboundPublicIpAddresses { get; private set; } = null!;

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the instance.
        /// Structure is documented below.
        /// </summary>
        [Output("pscInstanceConfig")]
        public Output<Outputs.InstancePscInstanceConfig> PscInstanceConfig { get; private set; } = null!;

        /// <summary>
        /// The public IP addresses for the Instance. This is available ONLY when
        /// networkConfig.enablePublicIp is set to true. This is the connection
        /// endpoint for an end-user application.
        /// </summary>
        [Output("publicIpAddress")]
        public Output<string> PublicIpAddress { get; private set; } = null!;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        [Output("pulumiLabels")]
        public Output<ImmutableDictionary<string, string>> PulumiLabels { get; private set; } = null!;

        /// <summary>
        /// Configuration for query insights.
        /// Structure is documented below.
        /// </summary>
        [Output("queryInsightsConfig")]
        public Output<Outputs.InstanceQueryInsightsConfig> QueryInsightsConfig { get; private set; } = null!;

        /// <summary>
        /// Read pool specific config. If the instance type is READ_POOL, this configuration must be provided.
        /// Structure is documented below.
        /// </summary>
        [Output("readPoolConfig")]
        public Output<Outputs.InstanceReadPoolConfig?> ReadPoolConfig { get; private set; } = null!;

        /// <summary>
        /// Set to true if the current state of Instance does not match the user's intended state, and the service is actively updating the resource to reconcile them. This can happen due to user-triggered updates or system actions like failover or maintenance.
        /// </summary>
        [Output("reconciling")]
        public Output<bool> Reconciling { get; private set; } = null!;

        /// <summary>
        /// The current state of the alloydb instance.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// The system-generated UID of the resource.
        /// </summary>
        [Output("uid")]
        public Output<string> Uid { get; private set; } = null!;

        /// <summary>
        /// Time the Instance was updated in UTC.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;


        /// <summary>
        /// Create a Instance resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Instance(string name, InstanceArgs args, CustomResourceOptions? options = null)
            : base("gcp:alloydb/instance:Instance", name, args ?? new InstanceArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Instance(string name, Input<string> id, InstanceState? state = null, CustomResourceOptions? options = null)
            : base("gcp:alloydb/instance:Instance", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "effectiveLabels",
                    "pulumiLabels",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Instance resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Instance Get(string name, Input<string> id, InstanceState? state = null, CustomResourceOptions? options = null)
        {
            return new Instance(name, id, state, options);
        }
    }

    public sealed class InstanceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// 'Specifies whether an instance needs to spin up. Once the instance is
        /// active, the activation policy can be updated to the `NEVER` to stop the
        /// instance. Likewise, the activation policy can be updated to `ALWAYS` to
        /// start the instance.
        /// There are restrictions around when an instance can/cannot be activated (for
        /// example, a read pool instance should be stopped before stopping primary
        /// etc.). Please refer to the API documentation for more details.
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.'
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.
        /// </summary>
        [Input("activationPolicy")]
        public Input<string>? ActivationPolicy { get; set; }

        [Input("annotations")]
        private InputMap<string>? _annotations;

        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels.
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        public InputMap<string> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<string>());
            set => _annotations = value;
        }

        /// <summary>
        /// 'Availability type of an Instance. Defaults to REGIONAL for both primary and read instances.
        /// Note that primary and read instances can have different availability types.
        /// Primary instances can be either ZONAL or REGIONAL. Read Pool instances can also be either ZONAL or REGIONAL.
        /// Read pools of size 1 can only have zonal availability. Read pools with a node count of 2 or more
        /// can have regional availability (nodes are present in 2 or more zones in a region).
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.'
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.
        /// </summary>
        [Input("availabilityType")]
        public Input<string>? AvailabilityType { get; set; }

        /// <summary>
        /// Client connection specific configurations.
        /// Structure is documented below.
        /// </summary>
        [Input("clientConnectionConfig")]
        public Input<Inputs.InstanceClientConnectionConfigArgs>? ClientConnectionConfig { get; set; }

        /// <summary>
        /// Identifies the alloydb cluster. Must be in the format
        /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
        /// </summary>
        [Input("cluster", required: true)]
        public Input<string> Cluster { get; set; } = null!;

        /// <summary>
        /// Configuration for Managed Connection Pool.
        /// Structure is documented below.
        /// </summary>
        [Input("connectionPoolConfig")]
        public Input<Inputs.InstanceConnectionPoolConfigArgs>? ConnectionPoolConfig { get; set; }

        [Input("databaseFlags")]
        private InputMap<string>? _databaseFlags;

        /// <summary>
        /// Database flags. Set at instance level. * They are copied from primary instance on read instance creation. * Read instances can set new or override existing flags that are relevant for reads, e.g. for enabling columnar cache on a read instance. Flags set on read instance may or may not be present on primary.
        /// </summary>
        public InputMap<string> DatabaseFlags
        {
            get => _databaseFlags ?? (_databaseFlags = new InputMap<string>());
            set => _databaseFlags = value;
        }

        /// <summary>
        /// User-settable and human-readable display name for the Instance.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// The Compute Engine zone that the instance should serve from, per https://cloud.google.com/compute/docs/regions-zones This can ONLY be specified for ZONAL instances. If present for a REGIONAL instance, an error will be thrown. If this is absent for a ZONAL instance, instance is created in a random zone with available capacity.
        /// </summary>
        [Input("gceZone")]
        public Input<string>? GceZone { get; set; }

        /// <summary>
        /// The ID of the alloydb instance.
        /// </summary>
        [Input("instanceId", required: true)]
        public Input<string> InstanceId { get; set; } = null!;

        /// <summary>
        /// The type of the instance.
        /// If the instance type is READ_POOL, provide the associated PRIMARY/SECONDARY instance in the `DependsOn` meta-data attribute.
        /// If the instance type is SECONDARY, point to the ClusterType of the associated secondary cluster instead of mentioning SECONDARY.
        /// Example: {instance_type = google_alloydb_cluster.&lt;secondary_cluster_name&gt;.cluster_type} instead of {instance_type = SECONDARY}
        /// If the instance type is SECONDARY, the terraform delete instance operation does not delete the secondary instance but abandons it instead.
        /// Use DeletionPolicy = "FORCE" in the associated secondary cluster and delete the cluster forcefully to delete the secondary cluster as well its associated secondary instance.
        /// Users can undo the delete secondary instance action by importing the deleted secondary instance by calling terraform import.
        /// Possible values are: `PRIMARY`, `READ_POOL`, `SECONDARY`.
        /// </summary>
        [Input("instanceType", required: true)]
        public Input<string> InstanceType { get; set; } = null!;

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// User-defined labels for the alloydb instance.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Configurations for the machines that host the underlying database engine.
        /// Structure is documented below.
        /// </summary>
        [Input("machineConfig")]
        public Input<Inputs.InstanceMachineConfigArgs>? MachineConfig { get; set; }

        /// <summary>
        /// Instance level network configuration.
        /// Structure is documented below.
        /// </summary>
        [Input("networkConfig")]
        public Input<Inputs.InstanceNetworkConfigArgs>? NetworkConfig { get; set; }

        /// <summary>
        /// (Optional, Beta)
        /// Configuration for enhanced query insights.
        /// Structure is documented below.
        /// </summary>
        [Input("observabilityConfig")]
        public Input<Inputs.InstanceObservabilityConfigArgs>? ObservabilityConfig { get; set; }

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the instance.
        /// Structure is documented below.
        /// </summary>
        [Input("pscInstanceConfig")]
        public Input<Inputs.InstancePscInstanceConfigArgs>? PscInstanceConfig { get; set; }

        /// <summary>
        /// Configuration for query insights.
        /// Structure is documented below.
        /// </summary>
        [Input("queryInsightsConfig")]
        public Input<Inputs.InstanceQueryInsightsConfigArgs>? QueryInsightsConfig { get; set; }

        /// <summary>
        /// Read pool specific config. If the instance type is READ_POOL, this configuration must be provided.
        /// Structure is documented below.
        /// </summary>
        [Input("readPoolConfig")]
        public Input<Inputs.InstanceReadPoolConfigArgs>? ReadPoolConfig { get; set; }

        public InstanceArgs()
        {
        }
        public static new InstanceArgs Empty => new InstanceArgs();
    }

    public sealed class InstanceState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// 'Specifies whether an instance needs to spin up. Once the instance is
        /// active, the activation policy can be updated to the `NEVER` to stop the
        /// instance. Likewise, the activation policy can be updated to `ALWAYS` to
        /// start the instance.
        /// There are restrictions around when an instance can/cannot be activated (for
        /// example, a read pool instance should be stopped before stopping primary
        /// etc.). Please refer to the API documentation for more details.
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.'
        /// Possible values are: `ACTIVATION_POLICY_UNSPECIFIED`, `ALWAYS`, `NEVER`.
        /// </summary>
        [Input("activationPolicy")]
        public Input<string>? ActivationPolicy { get; set; }

        [Input("annotations")]
        private InputMap<string>? _annotations;

        /// <summary>
        /// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels.
        /// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
        /// Please refer to the field `EffectiveAnnotations` for all of the annotations present on the resource.
        /// </summary>
        public InputMap<string> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<string>());
            set => _annotations = value;
        }

        /// <summary>
        /// 'Availability type of an Instance. Defaults to REGIONAL for both primary and read instances.
        /// Note that primary and read instances can have different availability types.
        /// Primary instances can be either ZONAL or REGIONAL. Read Pool instances can also be either ZONAL or REGIONAL.
        /// Read pools of size 1 can only have zonal availability. Read pools with a node count of 2 or more
        /// can have regional availability (nodes are present in 2 or more zones in a region).
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.'
        /// Possible values are: `AVAILABILITY_TYPE_UNSPECIFIED`, `ZONAL`, `REGIONAL`.
        /// </summary>
        [Input("availabilityType")]
        public Input<string>? AvailabilityType { get; set; }

        /// <summary>
        /// Client connection specific configurations.
        /// Structure is documented below.
        /// </summary>
        [Input("clientConnectionConfig")]
        public Input<Inputs.InstanceClientConnectionConfigGetArgs>? ClientConnectionConfig { get; set; }

        /// <summary>
        /// Identifies the alloydb cluster. Must be in the format
        /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
        /// </summary>
        [Input("cluster")]
        public Input<string>? Cluster { get; set; }

        /// <summary>
        /// Configuration for Managed Connection Pool.
        /// Structure is documented below.
        /// </summary>
        [Input("connectionPoolConfig")]
        public Input<Inputs.InstanceConnectionPoolConfigGetArgs>? ConnectionPoolConfig { get; set; }

        /// <summary>
        /// Time the Instance was created in UTC.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        [Input("databaseFlags")]
        private InputMap<string>? _databaseFlags;

        /// <summary>
        /// Database flags. Set at instance level. * They are copied from primary instance on read instance creation. * Read instances can set new or override existing flags that are relevant for reads, e.g. for enabling columnar cache on a read instance. Flags set on read instance may or may not be present on primary.
        /// </summary>
        public InputMap<string> DatabaseFlags
        {
            get => _databaseFlags ?? (_databaseFlags = new InputMap<string>());
            set => _databaseFlags = value;
        }

        /// <summary>
        /// User-settable and human-readable display name for the Instance.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        [Input("effectiveAnnotations")]
        private InputMap<string>? _effectiveAnnotations;

        /// <summary>
        /// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveAnnotations
        {
            get => _effectiveAnnotations ?? (_effectiveAnnotations = new InputMap<string>());
            set => _effectiveAnnotations = value;
        }

        [Input("effectiveLabels")]
        private InputMap<string>? _effectiveLabels;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveLabels
        {
            get => _effectiveLabels ?? (_effectiveLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _effectiveLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// The Compute Engine zone that the instance should serve from, per https://cloud.google.com/compute/docs/regions-zones This can ONLY be specified for ZONAL instances. If present for a REGIONAL instance, an error will be thrown. If this is absent for a ZONAL instance, instance is created in a random zone with available capacity.
        /// </summary>
        [Input("gceZone")]
        public Input<string>? GceZone { get; set; }

        /// <summary>
        /// The ID of the alloydb instance.
        /// </summary>
        [Input("instanceId")]
        public Input<string>? InstanceId { get; set; }

        /// <summary>
        /// The type of the instance.
        /// If the instance type is READ_POOL, provide the associated PRIMARY/SECONDARY instance in the `DependsOn` meta-data attribute.
        /// If the instance type is SECONDARY, point to the ClusterType of the associated secondary cluster instead of mentioning SECONDARY.
        /// Example: {instance_type = google_alloydb_cluster.&lt;secondary_cluster_name&gt;.cluster_type} instead of {instance_type = SECONDARY}
        /// If the instance type is SECONDARY, the terraform delete instance operation does not delete the secondary instance but abandons it instead.
        /// Use DeletionPolicy = "FORCE" in the associated secondary cluster and delete the cluster forcefully to delete the secondary cluster as well its associated secondary instance.
        /// Users can undo the delete secondary instance action by importing the deleted secondary instance by calling terraform import.
        /// Possible values are: `PRIMARY`, `READ_POOL`, `SECONDARY`.
        /// </summary>
        [Input("instanceType")]
        public Input<string>? InstanceType { get; set; }

        /// <summary>
        /// The IP address for the Instance. This is the connection endpoint for an end-user application.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// User-defined labels for the alloydb instance.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Configurations for the machines that host the underlying database engine.
        /// Structure is documented below.
        /// </summary>
        [Input("machineConfig")]
        public Input<Inputs.InstanceMachineConfigGetArgs>? MachineConfig { get; set; }

        /// <summary>
        /// The name of the instance resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Instance level network configuration.
        /// Structure is documented below.
        /// </summary>
        [Input("networkConfig")]
        public Input<Inputs.InstanceNetworkConfigGetArgs>? NetworkConfig { get; set; }

        /// <summary>
        /// (Optional, Beta)
        /// Configuration for enhanced query insights.
        /// Structure is documented below.
        /// </summary>
        [Input("observabilityConfig")]
        public Input<Inputs.InstanceObservabilityConfigGetArgs>? ObservabilityConfig { get; set; }

        [Input("outboundPublicIpAddresses")]
        private InputList<string>? _outboundPublicIpAddresses;

        /// <summary>
        /// The outbound public IP addresses for the instance. This is available ONLY when
        /// networkConfig.enableOutboundPublicIp is set to true. These IP addresses are used
        /// for outbound connections.
        /// </summary>
        public InputList<string> OutboundPublicIpAddresses
        {
            get => _outboundPublicIpAddresses ?? (_outboundPublicIpAddresses = new InputList<string>());
            set => _outboundPublicIpAddresses = value;
        }

        /// <summary>
        /// Configuration for Private Service Connect (PSC) for the instance.
        /// Structure is documented below.
        /// </summary>
        [Input("pscInstanceConfig")]
        public Input<Inputs.InstancePscInstanceConfigGetArgs>? PscInstanceConfig { get; set; }

        /// <summary>
        /// The public IP addresses for the Instance. This is available ONLY when
        /// networkConfig.enablePublicIp is set to true. This is the connection
        /// endpoint for an end-user application.
        /// </summary>
        [Input("publicIpAddress")]
        public Input<string>? PublicIpAddress { get; set; }

        [Input("pulumiLabels")]
        private InputMap<string>? _pulumiLabels;

        /// <summary>
        /// The combination of labels configured directly on the resource
        /// and default labels configured on the provider.
        /// </summary>
        public InputMap<string> PulumiLabels
        {
            get => _pulumiLabels ?? (_pulumiLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _pulumiLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Configuration for query insights.
        /// Structure is documented below.
        /// </summary>
        [Input("queryInsightsConfig")]
        public Input<Inputs.InstanceQueryInsightsConfigGetArgs>? QueryInsightsConfig { get; set; }

        /// <summary>
        /// Read pool specific config. If the instance type is READ_POOL, this configuration must be provided.
        /// Structure is documented below.
        /// </summary>
        [Input("readPoolConfig")]
        public Input<Inputs.InstanceReadPoolConfigGetArgs>? ReadPoolConfig { get; set; }

        /// <summary>
        /// Set to true if the current state of Instance does not match the user's intended state, and the service is actively updating the resource to reconcile them. This can happen due to user-triggered updates or system actions like failover or maintenance.
        /// </summary>
        [Input("reconciling")]
        public Input<bool>? Reconciling { get; set; }

        /// <summary>
        /// The current state of the alloydb instance.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// The system-generated UID of the resource.
        /// </summary>
        [Input("uid")]
        public Input<string>? Uid { get; set; }

        /// <summary>
        /// Time the Instance was updated in UTC.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        public InstanceState()
        {
        }
        public static new InstanceState Empty => new InstanceState();
    }
}
