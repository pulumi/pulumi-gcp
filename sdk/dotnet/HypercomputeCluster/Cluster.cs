// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.HypercomputeCluster
{
    /// <summary>
    /// A collection of virtual machines and connected resources forming a high-performance computing cluster capable of running large-scale, tightly coupled workloads. A cluster combines a set a compute resources that perform computations, storage resources that contain inputs and store outputs, an orchestrator that is responsible for assigning jobs to compute resources, and network resources that connect everything together.
    /// 
    /// ## Example Usage
    /// 
    /// ### Hypercomputecluster Cluster Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var project = Gcp.Organizations.GetProject.Invoke();
    /// 
    ///     var projectId = project.Apply(getProjectResult =&gt; getProjectResult.Name);
    /// 
    ///     var cluster = new Gcp.HypercomputeCluster.Cluster("cluster", new()
    ///     {
    ///         ClusterId = "my-cluster",
    ///         Location = "us-central1",
    ///         Description = "Cluster Director instance created through Terraform",
    ///         NetworkResources = new[]
    ///         {
    ///             new Gcp.HypercomputeCluster.Inputs.ClusterNetworkResourceArgs
    ///             {
    ///                 Id = "network1",
    ///                 Config = new Gcp.HypercomputeCluster.Inputs.ClusterNetworkResourceConfigArgs
    ///                 {
    ///                     NewNetwork = new Gcp.HypercomputeCluster.Inputs.ClusterNetworkResourceConfigNewNetworkArgs
    ///                     {
    ///                         Description = "Network one",
    ///                         Network = projectId.Apply(projectId =&gt; $"projects/{projectId}/global/networks/cluster-net1"),
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         ComputeResources = new[]
    ///         {
    ///             new Gcp.HypercomputeCluster.Inputs.ClusterComputeResourceArgs
    ///             {
    ///                 Id = "compute1",
    ///                 Config = new Gcp.HypercomputeCluster.Inputs.ClusterComputeResourceConfigArgs
    ///                 {
    ///                     NewOnDemandInstances = new Gcp.HypercomputeCluster.Inputs.ClusterComputeResourceConfigNewOnDemandInstancesArgs
    ///                     {
    ///                         MachineType = "n2-standard-2",
    ///                         Zone = "us-central1-a",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         Orchestrator = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorArgs
    ///         {
    ///             Slurm = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmArgs
    ///             {
    ///                 LoginNodes = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmLoginNodesArgs
    ///                 {
    ///                     MachineType = "n2-standard-2",
    ///                     Count = "1",
    ///                     Zone = "us-central1-a",
    ///                     BootDisk = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmLoginNodesBootDiskArgs
    ///                     {
    ///                         SizeGb = "100",
    ///                         Type = "pd-balanced",
    ///                     },
    ///                 },
    ///                 NodeSets = new[]
    ///                 {
    ///                     new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmNodeSetArgs
    ///                     {
    ///                         Id = "nodeset1",
    ///                         ComputeId = "compute1",
    ///                         StaticNodeCount = "1",
    ///                         ComputeInstance = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmNodeSetComputeInstanceArgs
    ///                         {
    ///                             BootDisk = new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmNodeSetComputeInstanceBootDiskArgs
    ///                             {
    ///                                 SizeGb = "100",
    ///                                 Type = "pd-balanced",
    ///                             },
    ///                         },
    ///                     },
    ///                 },
    ///                 Partitions = new[]
    ///                 {
    ///                     new Gcp.HypercomputeCluster.Inputs.ClusterOrchestratorSlurmPartitionArgs
    ///                     {
    ///                         Id = "partition1",
    ///                         NodeSetIds = new[]
    ///                         {
    ///                             "nodeset1",
    ///                         },
    ///                     },
    ///                 },
    ///                 DefaultPartition = "partition1",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Cluster can be imported using any of these accepted formats:
    /// 
    /// * `projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}`
    /// * `{{project}}/{{location}}/{{cluster_id}}`
    /// * `{{location}}/{{cluster_id}}`
    /// 
    /// When using the `pulumi import` command, Cluster can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:hypercomputecluster/cluster:Cluster default projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
    /// $ pulumi import gcp:hypercomputecluster/cluster:Cluster default {{project}}/{{location}}/{{cluster_id}}
    /// $ pulumi import gcp:hypercomputecluster/cluster:Cluster default {{location}}/{{cluster_id}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:hypercomputecluster/cluster:Cluster")]
    public partial class Cluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// ID of the cluster to create. Must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// </summary>
        [Output("clusterId")]
        public Output<string> ClusterId { get; private set; } = null!;

        /// <summary>
        /// Compute resources available to the cluster. Keys specify the ID of the
        /// compute resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        [Output("computeResources")]
        public Output<ImmutableArray<Outputs.ClusterComputeResource>> ComputeResources { get; private set; } = null!;

        /// <summary>
        /// Time that the cluster was originally created.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// User-provided description of the cluster.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        [Output("effectiveLabels")]
        public Output<ImmutableDictionary<string, string>> EffectiveLabels { get; private set; } = null!;

        /// <summary>
        /// [Labels](https://cloud.google.com/compute/docs/labeling-resources) applied
        /// to the cluster. Labels can be used to organize clusters and to filter them
        /// in queries.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Resource ID segment making up resource `Name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        /// </summary>
        [Output("location")]
        public Output<string> Location { get; private set; } = null!;

        /// <summary>
        /// Identifier. [Relative resource name](https://google.aip.dev/122) of the cluster, in the
        /// format `projects/{project}/locations/{location}/clusters/{cluster}`.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Network resources available to the cluster. Must contain at most one value.
        /// Keys specify the ID of the network resource by which it can be referenced
        /// elsewhere, and must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        [Output("networkResources")]
        public Output<ImmutableArray<Outputs.ClusterNetworkResource>> NetworkResources { get; private set; } = null!;

        /// <summary>
        /// The component responsible for scheduling and running workloads on the
        /// cluster as well as providing the user interface for interacting with the
        /// cluster at runtime.
        /// Structure is documented below.
        /// </summary>
        [Output("orchestrator")]
        public Output<Outputs.ClusterOrchestrator?> Orchestrator { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The combination of labels configured directly on the resource
        ///  and default labels configured on the provider.
        /// </summary>
        [Output("pulumiLabels")]
        public Output<ImmutableDictionary<string, string>> PulumiLabels { get; private set; } = null!;

        /// <summary>
        /// Indicates whether changes to the cluster are currently in flight. If this
        /// is `True`, then the current state might not match the cluster's intended
        /// state.
        /// </summary>
        [Output("reconciling")]
        public Output<bool> Reconciling { get; private set; } = null!;

        /// <summary>
        /// Storage resources available to the cluster. Keys specify the ID of the
        /// storage resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        [Output("storageResources")]
        public Output<ImmutableArray<Outputs.ClusterStorageResource>> StorageResources { get; private set; } = null!;

        /// <summary>
        /// Time that the cluster was most recently updated.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;


        /// <summary>
        /// Create a Cluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Cluster(string name, ClusterArgs args, CustomResourceOptions? options = null)
            : base("gcp:hypercomputecluster/cluster:Cluster", name, args ?? new ClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Cluster(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
            : base("gcp:hypercomputecluster/cluster:Cluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "effectiveLabels",
                    "pulumiLabels",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Cluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Cluster Get(string name, Input<string> id, ClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new Cluster(name, id, state, options);
        }
    }

    public sealed class ClusterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// ID of the cluster to create. Must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// </summary>
        [Input("clusterId", required: true)]
        public Input<string> ClusterId { get; set; } = null!;

        [Input("computeResources")]
        private InputList<Inputs.ClusterComputeResourceArgs>? _computeResources;

        /// <summary>
        /// Compute resources available to the cluster. Keys specify the ID of the
        /// compute resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterComputeResourceArgs> ComputeResources
        {
            get => _computeResources ?? (_computeResources = new InputList<Inputs.ClusterComputeResourceArgs>());
            set => _computeResources = value;
        }

        /// <summary>
        /// User-provided description of the cluster.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// [Labels](https://cloud.google.com/compute/docs/labeling-resources) applied
        /// to the cluster. Labels can be used to organize clusters and to filter them
        /// in queries.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Resource ID segment making up resource `Name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        /// </summary>
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        [Input("networkResources")]
        private InputList<Inputs.ClusterNetworkResourceArgs>? _networkResources;

        /// <summary>
        /// Network resources available to the cluster. Must contain at most one value.
        /// Keys specify the ID of the network resource by which it can be referenced
        /// elsewhere, and must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterNetworkResourceArgs> NetworkResources
        {
            get => _networkResources ?? (_networkResources = new InputList<Inputs.ClusterNetworkResourceArgs>());
            set => _networkResources = value;
        }

        /// <summary>
        /// The component responsible for scheduling and running workloads on the
        /// cluster as well as providing the user interface for interacting with the
        /// cluster at runtime.
        /// Structure is documented below.
        /// </summary>
        [Input("orchestrator")]
        public Input<Inputs.ClusterOrchestratorArgs>? Orchestrator { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("storageResources")]
        private InputList<Inputs.ClusterStorageResourceArgs>? _storageResources;

        /// <summary>
        /// Storage resources available to the cluster. Keys specify the ID of the
        /// storage resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterStorageResourceArgs> StorageResources
        {
            get => _storageResources ?? (_storageResources = new InputList<Inputs.ClusterStorageResourceArgs>());
            set => _storageResources = value;
        }

        public ClusterArgs()
        {
        }
        public static new ClusterArgs Empty => new ClusterArgs();
    }

    public sealed class ClusterState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// ID of the cluster to create. Must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        [Input("computeResources")]
        private InputList<Inputs.ClusterComputeResourceGetArgs>? _computeResources;

        /// <summary>
        /// Compute resources available to the cluster. Keys specify the ID of the
        /// compute resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterComputeResourceGetArgs> ComputeResources
        {
            get => _computeResources ?? (_computeResources = new InputList<Inputs.ClusterComputeResourceGetArgs>());
            set => _computeResources = value;
        }

        /// <summary>
        /// Time that the cluster was originally created.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// User-provided description of the cluster.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("effectiveLabels")]
        private InputMap<string>? _effectiveLabels;

        /// <summary>
        /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
        /// </summary>
        public InputMap<string> EffectiveLabels
        {
            get => _effectiveLabels ?? (_effectiveLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _effectiveLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// [Labels](https://cloud.google.com/compute/docs/labeling-resources) applied
        /// to the cluster. Labels can be used to organize clusters and to filter them
        /// in queries.
        /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
        /// Please refer to the field `EffectiveLabels` for all of the labels present on the resource.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Resource ID segment making up resource `Name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        /// </summary>
        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// Identifier. [Relative resource name](https://google.aip.dev/122) of the cluster, in the
        /// format `projects/{project}/locations/{location}/clusters/{cluster}`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkResources")]
        private InputList<Inputs.ClusterNetworkResourceGetArgs>? _networkResources;

        /// <summary>
        /// Network resources available to the cluster. Must contain at most one value.
        /// Keys specify the ID of the network resource by which it can be referenced
        /// elsewhere, and must conform to
        /// [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterNetworkResourceGetArgs> NetworkResources
        {
            get => _networkResources ?? (_networkResources = new InputList<Inputs.ClusterNetworkResourceGetArgs>());
            set => _networkResources = value;
        }

        /// <summary>
        /// The component responsible for scheduling and running workloads on the
        /// cluster as well as providing the user interface for interacting with the
        /// cluster at runtime.
        /// Structure is documented below.
        /// </summary>
        [Input("orchestrator")]
        public Input<Inputs.ClusterOrchestratorGetArgs>? Orchestrator { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("pulumiLabels")]
        private InputMap<string>? _pulumiLabels;

        /// <summary>
        /// The combination of labels configured directly on the resource
        ///  and default labels configured on the provider.
        /// </summary>
        public InputMap<string> PulumiLabels
        {
            get => _pulumiLabels ?? (_pulumiLabels = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _pulumiLabels = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        /// <summary>
        /// Indicates whether changes to the cluster are currently in flight. If this
        /// is `True`, then the current state might not match the cluster's intended
        /// state.
        /// </summary>
        [Input("reconciling")]
        public Input<bool>? Reconciling { get; set; }

        [Input("storageResources")]
        private InputList<Inputs.ClusterStorageResourceGetArgs>? _storageResources;

        /// <summary>
        /// Storage resources available to the cluster. Keys specify the ID of the
        /// storage resource by which it can be referenced elsewhere, and must conform
        /// to [RFC-1034](https://datatracker.ietf.org/doc/html/rfc1034) (lower-case,
        /// alphanumeric, and at most 63 characters).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.ClusterStorageResourceGetArgs> StorageResources
        {
            get => _storageResources ?? (_storageResources = new InputList<Inputs.ClusterStorageResourceGetArgs>());
            set => _storageResources = value;
        }

        /// <summary>
        /// Time that the cluster was most recently updated.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        public ClusterState()
        {
        }
        public static new ClusterState Empty => new ClusterState();
    }
}
