// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Kms.Inputs
{

    public sealed class EkmConnectionServiceResolverServerCertificateArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Output)
        /// Output only. The issuer distinguished name in RFC 2253 format. Only present if parsed is true.
        /// </summary>
        [Input("issuer")]
        public Input<string>? Issuer { get; set; }

        /// <summary>
        /// (Output)
        /// Output only. The certificate is not valid after this time. Only present if parsed is true.
        /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        /// </summary>
        [Input("notAfterTime")]
        public Input<string>? NotAfterTime { get; set; }

        /// <summary>
        /// (Output)
        /// Output only. The certificate is not valid before this time. Only present if parsed is true.
        /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        /// </summary>
        [Input("notBeforeTime")]
        public Input<string>? NotBeforeTime { get; set; }

        /// <summary>
        /// (Output)
        /// Output only. True if the certificate was parsed successfully.
        /// </summary>
        [Input("parsed")]
        public Input<bool>? Parsed { get; set; }

        /// <summary>
        /// Required. The raw certificate bytes in DER format. A base64-encoded string.
        /// </summary>
        [Input("rawDer", required: true)]
        public Input<string> RawDer { get; set; } = null!;

        /// <summary>
        /// (Output)
        /// Output only. The certificate serial number as a hex string. Only present if parsed is true.
        /// </summary>
        [Input("serialNumber")]
        public Input<string>? SerialNumber { get; set; }

        /// <summary>
        /// (Output)
        /// Output only. The SHA-256 certificate fingerprint as a hex string. Only present if parsed is true.
        /// </summary>
        [Input("sha256Fingerprint")]
        public Input<string>? Sha256Fingerprint { get; set; }

        /// <summary>
        /// (Output)
        /// Output only. The subject distinguished name in RFC 2253 format. Only present if parsed is true.
        /// </summary>
        [Input("subject")]
        public Input<string>? Subject { get; set; }

        [Input("subjectAlternativeDnsNames")]
        private InputList<string>? _subjectAlternativeDnsNames;

        /// <summary>
        /// (Output)
        /// Output only. The subject Alternative DNS names. Only present if parsed is true.
        /// </summary>
        public InputList<string> SubjectAlternativeDnsNames
        {
            get => _subjectAlternativeDnsNames ?? (_subjectAlternativeDnsNames = new InputList<string>());
            set => _subjectAlternativeDnsNames = value;
        }

        public EkmConnectionServiceResolverServerCertificateArgs()
        {
        }
        public static new EkmConnectionServiceResolverServerCertificateArgs Empty => new EkmConnectionServiceResolverServerCertificateArgs();
    }
}
