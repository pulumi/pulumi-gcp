// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Gcp.Firestore
{
    /// <summary>
    /// Cloud Firestore indexes enable simple and complex queries against documents in a database.
    ///  Both Firestore Native and Datastore Mode indexes are supported.
    ///  This resource manages composite indexes and not single field indexes.
    ///  To manage single field indexes, use the `gcp.firestore.Field` resource instead.
    /// 
    /// To get more information about Index, see:
    /// 
    /// * [API documentation](https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.collectionGroups.indexes)
    /// * How-to Guides
    ///     * [Official Documentation](https://cloud.google.com/firestore/docs/query-data/indexing)
    /// 
    /// &gt; **Warning:** This resource creates a Firestore Index on a project that already has
    /// a Firestore database. If you haven't already created it, you may
    /// create a `gcp.firestore.Database` resource and `location_id` set
    /// to your chosen location. If you wish to use App Engine, you may
    /// instead create a `gcp.appengine.Application` resource.
    /// Your Firestore location will be the same as the App Engine location specified.
    /// 
    /// ## Example Usage
    /// 
    /// ### Firestore Index Basic
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Datastore Mode
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id-dm",
    ///         LocationId = "nam5",
    ///         Type = "DATASTORE_MODE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         QueryScope = "COLLECTION_RECURSIVE",
    ///         ApiScope = "DATASTORE_MODE_API",
    ///         Density = "SPARSE_ALL",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Vector
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id-vector",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "field_name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "__name__",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 VectorConfig = new Gcp.Firestore.Inputs.IndexFieldVectorConfigArgs
    ///                 {
    ///                     Dimension = 128,
    ///                     Flat = null,
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Name Descending
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "__name__",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Mongodb Compatible Scope
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id-mongodb-compatible",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DatabaseEdition = "ENTERPRISE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         ApiScope = "MONGODB_COMPATIBLE_API",
    ///         QueryScope = "COLLECTION_GROUP",
    ///         Multikey = true,
    ///         Density = "DENSE",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Sparse Any
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id-sparse-any",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DatabaseEdition = "ENTERPRISE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         ApiScope = "MONGODB_COMPATIBLE_API",
    ///         QueryScope = "COLLECTION_GROUP",
    ///         Multikey = true,
    ///         Density = "SPARSE_ANY",
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Firestore Index Unique
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Gcp = Pulumi.Gcp;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var database = new Gcp.Firestore.Database("database", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Name = "database-id-unique",
    ///         LocationId = "nam5",
    ///         Type = "FIRESTORE_NATIVE",
    ///         DatabaseEdition = "ENTERPRISE",
    ///         DeleteProtectionState = "DELETE_PROTECTION_DISABLED",
    ///         DeletionPolicy = "DELETE",
    ///     });
    /// 
    ///     var my_index = new Gcp.Firestore.Index("my-index", new()
    ///     {
    ///         Project = "my-project-name",
    ///         Database = database.Name,
    ///         Collection = "atestcollection",
    ///         ApiScope = "MONGODB_COMPATIBLE_API",
    ///         QueryScope = "COLLECTION_GROUP",
    ///         Multikey = true,
    ///         Density = "DENSE",
    ///         Unique = true,
    ///         Fields = new[]
    ///         {
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "name",
    ///                 Order = "ASCENDING",
    ///             },
    ///             new Gcp.Firestore.Inputs.IndexFieldArgs
    ///             {
    ///                 FieldPath = "description",
    ///                 Order = "DESCENDING",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Index can be imported using any of these accepted formats:
    /// 
    /// * `{{name}}`
    /// 
    /// When using the `pulumi import` command, Index can be imported using one of the formats above. For example:
    /// 
    /// ```sh
    /// $ pulumi import gcp:firestore/index:Index default {{name}}
    /// ```
    /// </summary>
    [GcpResourceType("gcp:firestore/index:Index")]
    public partial class Index : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The API scope at which a query is run.
        /// Default value is `ANY_API`.
        /// Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
        /// </summary>
        [Output("apiScope")]
        public Output<string?> ApiScope { get; private set; } = null!;

        /// <summary>
        /// The collection being indexed.
        /// </summary>
        [Output("collection")]
        public Output<string> Collection { get; private set; } = null!;

        /// <summary>
        /// The Firestore database id. Defaults to `"(default)"`.
        /// </summary>
        [Output("database")]
        public Output<string?> Database { get; private set; } = null!;

        /// <summary>
        /// The density configuration for this index.
        /// Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
        /// </summary>
        [Output("density")]
        public Output<string> Density { get; private set; } = null!;

        /// <summary>
        /// The fields supported by this index. The last non-stored field entry is
        /// always for the field path `__name__`. If, on creation, `__name__` was not
        /// specified as the last field, it will be added automatically with the same
        /// direction as that of the last field defined. If the final field in a
        /// composite index is not directional, the `__name__` will be ordered
        /// `"ASCENDING"` (unless explicitly specified otherwise).
        /// Structure is documented below.
        /// </summary>
        [Output("fields")]
        public Output<ImmutableArray<Outputs.IndexField>> Fields { get; private set; } = null!;

        /// <summary>
        /// Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
        /// </summary>
        [Output("multikey")]
        public Output<bool?> Multikey { get; private set; } = null!;

        /// <summary>
        /// A server defined name for this index. Format:
        /// `projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/indexes/{{server_generated_id}}`
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// The scope at which a query is run.
        /// Default value is `COLLECTION`.
        /// Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
        /// </summary>
        [Output("queryScope")]
        public Output<string?> QueryScope { get; private set; } = null!;

        /// <summary>
        /// Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
        /// </summary>
        [Output("unique")]
        public Output<bool> Unique { get; private set; } = null!;


        /// <summary>
        /// Create a Index resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Index(string name, IndexArgs args, CustomResourceOptions? options = null)
            : base("gcp:firestore/index:Index", name, args ?? new IndexArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Index(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
            : base("gcp:firestore/index:Index", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Index resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Index Get(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
        {
            return new Index(name, id, state, options);
        }
    }

    public sealed class IndexArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The API scope at which a query is run.
        /// Default value is `ANY_API`.
        /// Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
        /// </summary>
        [Input("apiScope")]
        public Input<string>? ApiScope { get; set; }

        /// <summary>
        /// The collection being indexed.
        /// </summary>
        [Input("collection", required: true)]
        public Input<string> Collection { get; set; } = null!;

        /// <summary>
        /// The Firestore database id. Defaults to `"(default)"`.
        /// </summary>
        [Input("database")]
        public Input<string>? Database { get; set; }

        /// <summary>
        /// The density configuration for this index.
        /// Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
        /// </summary>
        [Input("density")]
        public Input<string>? Density { get; set; }

        [Input("fields", required: true)]
        private InputList<Inputs.IndexFieldArgs>? _fields;

        /// <summary>
        /// The fields supported by this index. The last non-stored field entry is
        /// always for the field path `__name__`. If, on creation, `__name__` was not
        /// specified as the last field, it will be added automatically with the same
        /// direction as that of the last field defined. If the final field in a
        /// composite index is not directional, the `__name__` will be ordered
        /// `"ASCENDING"` (unless explicitly specified otherwise).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.IndexFieldArgs> Fields
        {
            get => _fields ?? (_fields = new InputList<Inputs.IndexFieldArgs>());
            set => _fields = value;
        }

        /// <summary>
        /// Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
        /// </summary>
        [Input("multikey")]
        public Input<bool>? Multikey { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The scope at which a query is run.
        /// Default value is `COLLECTION`.
        /// Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
        /// </summary>
        [Input("queryScope")]
        public Input<string>? QueryScope { get; set; }

        /// <summary>
        /// Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
        /// </summary>
        [Input("unique")]
        public Input<bool>? Unique { get; set; }

        public IndexArgs()
        {
        }
        public static new IndexArgs Empty => new IndexArgs();
    }

    public sealed class IndexState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The API scope at which a query is run.
        /// Default value is `ANY_API`.
        /// Possible values are: `ANY_API`, `DATASTORE_MODE_API`, `MONGODB_COMPATIBLE_API`.
        /// </summary>
        [Input("apiScope")]
        public Input<string>? ApiScope { get; set; }

        /// <summary>
        /// The collection being indexed.
        /// </summary>
        [Input("collection")]
        public Input<string>? Collection { get; set; }

        /// <summary>
        /// The Firestore database id. Defaults to `"(default)"`.
        /// </summary>
        [Input("database")]
        public Input<string>? Database { get; set; }

        /// <summary>
        /// The density configuration for this index.
        /// Possible values are: `SPARSE_ALL`, `SPARSE_ANY`, `DENSE`.
        /// </summary>
        [Input("density")]
        public Input<string>? Density { get; set; }

        [Input("fields")]
        private InputList<Inputs.IndexFieldGetArgs>? _fields;

        /// <summary>
        /// The fields supported by this index. The last non-stored field entry is
        /// always for the field path `__name__`. If, on creation, `__name__` was not
        /// specified as the last field, it will be added automatically with the same
        /// direction as that of the last field defined. If the final field in a
        /// composite index is not directional, the `__name__` will be ordered
        /// `"ASCENDING"` (unless explicitly specified otherwise).
        /// Structure is documented below.
        /// </summary>
        public InputList<Inputs.IndexFieldGetArgs> Fields
        {
            get => _fields ?? (_fields = new InputList<Inputs.IndexFieldGetArgs>());
            set => _fields = value;
        }

        /// <summary>
        /// Optional. Whether the index is multikey. By default, the index is not multikey. For non-multikey indexes, none of the paths in the index definition reach or traverse an array, except via an explicit array index. For multikey indexes, at most one of the paths in the index definition reach or traverse an array, except via an explicit array index. Violations will result in errors. Note this field only applies to indexes with MONGODB_COMPATIBLE_API ApiScope.
        /// </summary>
        [Input("multikey")]
        public Input<bool>? Multikey { get; set; }

        /// <summary>
        /// A server defined name for this index. Format:
        /// `projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/indexes/{{server_generated_id}}`
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the project in which the resource belongs.
        /// If it is not provided, the provider project is used.
        /// </summary>
        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// The scope at which a query is run.
        /// Default value is `COLLECTION`.
        /// Possible values are: `COLLECTION`, `COLLECTION_GROUP`, `COLLECTION_RECURSIVE`.
        /// </summary>
        [Input("queryScope")]
        public Input<string>? QueryScope { get; set; }

        /// <summary>
        /// Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.
        /// </summary>
        [Input("unique")]
        public Input<bool>? Unique { get; set; }

        public IndexState()
        {
        }
        public static new IndexState Empty => new IndexState();
    }
}
