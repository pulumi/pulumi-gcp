// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dns

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A zone is a subtree of the DNS namespace under one administrative
// responsibility. A ManagedZone is a resource that represents a DNS zone
// hosted by the Cloud DNS service.
//
// To get more information about ManagedZone, see:
//
// * [API documentation](https://cloud.google.com/dns/api/v1/managedZones)
// * How-to Guides
//   - [Managing Zones](https://cloud.google.com/dns/zones/)
//
// ## Example Usage
//
// ### Dns Managed Zone Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dns.NewManagedZone(ctx, "example-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("example-zone"),
//				DnsName:     pulumi.String("my-domain.com."),
//				Description: pulumi.String("Example DNS zone"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Private
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network_1, err := compute.NewNetwork(ctx, "network-1", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-1"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			network_2, err := compute.NewNetwork(ctx, "network-2", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-2"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "private-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("private-zone"),
//				DnsName:     pulumi.String("private.example.com."),
//				Description: pulumi.String("Example private DNS zone"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Visibility: pulumi.String("private"),
//				PrivateVisibilityConfig: &dns.ManagedZonePrivateVisibilityConfigArgs{
//					Networks: dns.ManagedZonePrivateVisibilityConfigNetworkArray{
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network_1.ID(),
//						},
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network_2.ID(),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Private Forwarding
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network_1, err := compute.NewNetwork(ctx, "network-1", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-1"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			network_2, err := compute.NewNetwork(ctx, "network-2", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-2"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "private-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("private-zone"),
//				DnsName:     pulumi.String("private.example.com."),
//				Description: pulumi.String("Example private DNS zone"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Visibility: pulumi.String("private"),
//				PrivateVisibilityConfig: &dns.ManagedZonePrivateVisibilityConfigArgs{
//					Networks: dns.ManagedZonePrivateVisibilityConfigNetworkArray{
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network_1.ID(),
//						},
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network_2.ID(),
//						},
//					},
//				},
//				ForwardingConfig: &dns.ManagedZoneForwardingConfigArgs{
//					TargetNameServers: dns.ManagedZoneForwardingConfigTargetNameServerArray{
//						&dns.ManagedZoneForwardingConfigTargetNameServerArgs{
//							Ipv4Address: pulumi.String("172.16.1.10"),
//						},
//						&dns.ManagedZoneForwardingConfigTargetNameServerArgs{
//							Ipv4Address: pulumi.String("172.16.1.20"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Private Forwarding Ipv6
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network1, err := compute.NewNetwork(ctx, "network_1", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-1"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "private-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("private-zone"),
//				DnsName:     pulumi.String("private.example.com."),
//				Description: pulumi.String("Example private DNS zone"),
//				Visibility:  pulumi.String("private"),
//				PrivateVisibilityConfig: &dns.ManagedZonePrivateVisibilityConfigArgs{
//					Networks: dns.ManagedZonePrivateVisibilityConfigNetworkArray{
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network1.ID(),
//						},
//					},
//				},
//				ForwardingConfig: &dns.ManagedZoneForwardingConfigArgs{
//					TargetNameServers: dns.ManagedZoneForwardingConfigTargetNameServerArray{
//						&dns.ManagedZoneForwardingConfigTargetNameServerArgs{
//							Ipv6Address: pulumi.String("fd20:3e9:7a70:680d:0:8::"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Private Gke
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/container"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network_1, err := compute.NewNetwork(ctx, "network-1", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-1"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			subnetwork_1, err := compute.NewSubnetwork(ctx, "subnetwork-1", &compute.SubnetworkArgs{
//				Name:                  network_1.Name,
//				Network:               network_1.Name,
//				IpCidrRange:           pulumi.String("10.0.36.0/24"),
//				Region:                pulumi.String("us-central1"),
//				PrivateIpGoogleAccess: pulumi.Bool(true),
//				SecondaryIpRanges: compute.SubnetworkSecondaryIpRangeArray{
//					&compute.SubnetworkSecondaryIpRangeArgs{
//						RangeName:   pulumi.String("pod"),
//						IpCidrRange: pulumi.String("10.0.0.0/19"),
//					},
//					&compute.SubnetworkSecondaryIpRangeArgs{
//						RangeName:   pulumi.String("svc"),
//						IpCidrRange: pulumi.String("10.0.32.0/22"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			cluster_1, err := container.NewCluster(ctx, "cluster-1", &container.ClusterArgs{
//				Name:             pulumi.String("cluster-1"),
//				Location:         pulumi.String("us-central1-c"),
//				InitialNodeCount: pulumi.Int(1),
//				NetworkingMode:   pulumi.String("VPC_NATIVE"),
//				DefaultSnatStatus: &container.ClusterDefaultSnatStatusArgs{
//					Disabled: pulumi.Bool(true),
//				},
//				Network:    network_1.Name,
//				Subnetwork: subnetwork_1.Name,
//				PrivateClusterConfig: &container.ClusterPrivateClusterConfigArgs{
//					EnablePrivateEndpoint: pulumi.Bool(true),
//					EnablePrivateNodes:    pulumi.Bool(true),
//					MasterIpv4CidrBlock:   pulumi.String("10.42.0.0/28"),
//					MasterGlobalAccessConfig: &container.ClusterPrivateClusterConfigMasterGlobalAccessConfigArgs{
//						Enabled: pulumi.Bool(true),
//					},
//				},
//				MasterAuthorizedNetworksConfig: &container.ClusterMasterAuthorizedNetworksConfigArgs{},
//				IpAllocationPolicy: &container.ClusterIpAllocationPolicyArgs{
//					ClusterSecondaryRangeName: subnetwork_1.SecondaryIpRanges.ApplyT(func(secondaryIpRanges []compute.SubnetworkSecondaryIpRange) (*string, error) {
//						return &secondaryIpRanges[0].RangeName, nil
//					}).(pulumi.StringPtrOutput),
//					ServicesSecondaryRangeName: subnetwork_1.SecondaryIpRanges.ApplyT(func(secondaryIpRanges []compute.SubnetworkSecondaryIpRange) (*string, error) {
//						return &secondaryIpRanges[1].RangeName, nil
//					}).(pulumi.StringPtrOutput),
//				},
//				DeletionProtection: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "private-zone-gke", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("private-zone"),
//				DnsName:     pulumi.String("private.example.com."),
//				Description: pulumi.String("Example private DNS zone"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Visibility: pulumi.String("private"),
//				PrivateVisibilityConfig: &dns.ManagedZonePrivateVisibilityConfigArgs{
//					GkeClusters: dns.ManagedZonePrivateVisibilityConfigGkeClusterArray{
//						&dns.ManagedZonePrivateVisibilityConfigGkeClusterArgs{
//							GkeClusterName: cluster_1.ID(),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Private Peering
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network_source, err := compute.NewNetwork(ctx, "network-source", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-source"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			network_target, err := compute.NewNetwork(ctx, "network-target", &compute.NetworkArgs{
//				Name:                  pulumi.String("network-target"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "peering-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("peering-zone"),
//				DnsName:     pulumi.String("peering.example.com."),
//				Description: pulumi.String("Example private DNS peering zone"),
//				Visibility:  pulumi.String("private"),
//				PrivateVisibilityConfig: &dns.ManagedZonePrivateVisibilityConfigArgs{
//					Networks: dns.ManagedZonePrivateVisibilityConfigNetworkArray{
//						&dns.ManagedZonePrivateVisibilityConfigNetworkArgs{
//							NetworkUrl: network_source.ID(),
//						},
//					},
//				},
//				PeeringConfig: &dns.ManagedZonePeeringConfigArgs{
//					TargetNetwork: &dns.ManagedZonePeeringConfigTargetNetworkArgs{
//						NetworkUrl: network_target.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Service Directory
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/servicedirectory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := servicedirectory.NewNamespace(ctx, "example", &servicedirectory.NamespaceArgs{
//				NamespaceId: pulumi.String("example"),
//				Location:    pulumi.String("us-central1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewManagedZone(ctx, "sd-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("peering-zone"),
//				DnsName:     pulumi.String("services.example.com."),
//				Description: pulumi.String("Example private DNS Service Directory zone"),
//				Visibility:  pulumi.String("private"),
//				ServiceDirectoryConfig: &dns.ManagedZoneServiceDirectoryConfigArgs{
//					Namespace: &dns.ManagedZoneServiceDirectoryConfigNamespaceArgs{
//						NamespaceUrl: example.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dns Managed Zone Cloud Logging
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/dns"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dns.NewManagedZone(ctx, "cloud-logging-enabled-zone", &dns.ManagedZoneArgs{
//				Name:        pulumi.String("cloud-logging-enabled-zone"),
//				DnsName:     pulumi.String("services.example.com."),
//				Description: pulumi.String("Example cloud logging enabled DNS zone"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				CloudLoggingConfig: &dns.ManagedZoneCloudLoggingConfigArgs{
//					EnableLogging: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ManagedZone can be imported using any of these accepted formats:
//
// * `projects/{{project}}/managedZones/{{name}}`
//
// * `{{project}}/{{name}}`
//
// * `{{name}}`
//
// When using the `pulumi import` command, ManagedZone can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:dns/managedZone:ManagedZone default projects/{{project}}/managedZones/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:dns/managedZone:ManagedZone default {{project}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:dns/managedZone:ManagedZone default {{name}}
// ```
type ManagedZone struct {
	pulumi.CustomResourceState

	// Cloud logging configuration
	// Structure is documented below.
	CloudLoggingConfig ManagedZoneCloudLoggingConfigOutput `pulumi:"cloudLoggingConfig"`
	// The time that this resource was created on the server.
	// This is in RFC3339 text format.
	CreationTime pulumi.StringOutput `pulumi:"creationTime"`
	// A textual description field. Defaults to 'Managed by Pulumi'.
	Description pulumi.StringOutput `pulumi:"description"`
	// The DNS name of this managed zone, for instance "example.com.".
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// DNSSEC configuration
	// Structure is documented below.
	DnssecConfig ManagedZoneDnssecConfigOutput `pulumi:"dnssecConfig"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Set this true to delete all records in the zone.
	ForceDestroy pulumi.BoolPtrOutput `pulumi:"forceDestroy"`
	// The presence for this field indicates that outbound forwarding is enabled
	// for this zone. The value of this field contains the set of destinations
	// to forward to.
	// Structure is documented below.
	ForwardingConfig ManagedZoneForwardingConfigPtrOutput `pulumi:"forwardingConfig"`
	// A set of key/value label pairs to assign to this ManagedZone.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Unique identifier for the resource; defined by the server.
	ManagedZoneId pulumi.StringOutput `pulumi:"managedZoneId"`
	// User assigned name for this resource.
	// Must be unique within the project.
	Name pulumi.StringOutput `pulumi:"name"`
	// Delegate your managedZone to these virtual name servers;
	// defined by the server
	NameServers pulumi.StringArrayOutput `pulumi:"nameServers"`
	// The presence of this field indicates that DNS Peering is enabled for this
	// zone. The value of this field contains the network to peer with.
	// Structure is documented below.
	PeeringConfig ManagedZonePeeringConfigPtrOutput `pulumi:"peeringConfig"`
	// For privately visible zones, the set of Virtual Private Cloud
	// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
	// Structure is documented below.
	PrivateVisibilityConfig ManagedZonePrivateVisibilityConfigPtrOutput `pulumi:"privateVisibilityConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
	// lookup queries using automatically configured records for VPC resources. This only applies
	// to networks listed under `privateVisibilityConfig`.
	ReverseLookup pulumi.BoolPtrOutput `pulumi:"reverseLookup"`
	// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
	// Structure is documented below.
	ServiceDirectoryConfig ManagedZoneServiceDirectoryConfigPtrOutput `pulumi:"serviceDirectoryConfig"`
	// The zone's visibility: public zones are exposed to the Internet,
	// while private zones are visible only to Virtual Private Cloud resources.
	// Default value is `public`.
	// Possible values are: `private`, `public`.
	Visibility pulumi.StringPtrOutput `pulumi:"visibility"`
}

// NewManagedZone registers a new resource with the given unique name, arguments, and options.
func NewManagedZone(ctx *pulumi.Context,
	name string, args *ManagedZoneArgs, opts ...pulumi.ResourceOption) (*ManagedZone, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DnsName == nil {
		return nil, errors.New("invalid value for required argument 'DnsName'")
	}
	if args.Description == nil {
		args.Description = pulumi.StringPtr("Managed by Pulumi")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedZone
	err := ctx.RegisterResource("gcp:dns/managedZone:ManagedZone", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedZone gets an existing ManagedZone resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedZone(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedZoneState, opts ...pulumi.ResourceOption) (*ManagedZone, error) {
	var resource ManagedZone
	err := ctx.ReadResource("gcp:dns/managedZone:ManagedZone", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedZone resources.
type managedZoneState struct {
	// Cloud logging configuration
	// Structure is documented below.
	CloudLoggingConfig *ManagedZoneCloudLoggingConfig `pulumi:"cloudLoggingConfig"`
	// The time that this resource was created on the server.
	// This is in RFC3339 text format.
	CreationTime *string `pulumi:"creationTime"`
	// A textual description field. Defaults to 'Managed by Pulumi'.
	Description *string `pulumi:"description"`
	// The DNS name of this managed zone, for instance "example.com.".
	DnsName *string `pulumi:"dnsName"`
	// DNSSEC configuration
	// Structure is documented below.
	DnssecConfig *ManagedZoneDnssecConfig `pulumi:"dnssecConfig"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Set this true to delete all records in the zone.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// The presence for this field indicates that outbound forwarding is enabled
	// for this zone. The value of this field contains the set of destinations
	// to forward to.
	// Structure is documented below.
	ForwardingConfig *ManagedZoneForwardingConfig `pulumi:"forwardingConfig"`
	// A set of key/value label pairs to assign to this ManagedZone.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// Unique identifier for the resource; defined by the server.
	ManagedZoneId *string `pulumi:"managedZoneId"`
	// User assigned name for this resource.
	// Must be unique within the project.
	Name *string `pulumi:"name"`
	// Delegate your managedZone to these virtual name servers;
	// defined by the server
	NameServers []string `pulumi:"nameServers"`
	// The presence of this field indicates that DNS Peering is enabled for this
	// zone. The value of this field contains the network to peer with.
	// Structure is documented below.
	PeeringConfig *ManagedZonePeeringConfig `pulumi:"peeringConfig"`
	// For privately visible zones, the set of Virtual Private Cloud
	// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
	// Structure is documented below.
	PrivateVisibilityConfig *ManagedZonePrivateVisibilityConfig `pulumi:"privateVisibilityConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
	// lookup queries using automatically configured records for VPC resources. This only applies
	// to networks listed under `privateVisibilityConfig`.
	ReverseLookup *bool `pulumi:"reverseLookup"`
	// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
	// Structure is documented below.
	ServiceDirectoryConfig *ManagedZoneServiceDirectoryConfig `pulumi:"serviceDirectoryConfig"`
	// The zone's visibility: public zones are exposed to the Internet,
	// while private zones are visible only to Virtual Private Cloud resources.
	// Default value is `public`.
	// Possible values are: `private`, `public`.
	Visibility *string `pulumi:"visibility"`
}

type ManagedZoneState struct {
	// Cloud logging configuration
	// Structure is documented below.
	CloudLoggingConfig ManagedZoneCloudLoggingConfigPtrInput
	// The time that this resource was created on the server.
	// This is in RFC3339 text format.
	CreationTime pulumi.StringPtrInput
	// A textual description field. Defaults to 'Managed by Pulumi'.
	Description pulumi.StringPtrInput
	// The DNS name of this managed zone, for instance "example.com.".
	DnsName pulumi.StringPtrInput
	// DNSSEC configuration
	// Structure is documented below.
	DnssecConfig ManagedZoneDnssecConfigPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Set this true to delete all records in the zone.
	ForceDestroy pulumi.BoolPtrInput
	// The presence for this field indicates that outbound forwarding is enabled
	// for this zone. The value of this field contains the set of destinations
	// to forward to.
	// Structure is documented below.
	ForwardingConfig ManagedZoneForwardingConfigPtrInput
	// A set of key/value label pairs to assign to this ManagedZone.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// Unique identifier for the resource; defined by the server.
	ManagedZoneId pulumi.StringPtrInput
	// User assigned name for this resource.
	// Must be unique within the project.
	Name pulumi.StringPtrInput
	// Delegate your managedZone to these virtual name servers;
	// defined by the server
	NameServers pulumi.StringArrayInput
	// The presence of this field indicates that DNS Peering is enabled for this
	// zone. The value of this field contains the network to peer with.
	// Structure is documented below.
	PeeringConfig ManagedZonePeeringConfigPtrInput
	// For privately visible zones, the set of Virtual Private Cloud
	// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
	// Structure is documented below.
	PrivateVisibilityConfig ManagedZonePrivateVisibilityConfigPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
	// lookup queries using automatically configured records for VPC resources. This only applies
	// to networks listed under `privateVisibilityConfig`.
	ReverseLookup pulumi.BoolPtrInput
	// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
	// Structure is documented below.
	ServiceDirectoryConfig ManagedZoneServiceDirectoryConfigPtrInput
	// The zone's visibility: public zones are exposed to the Internet,
	// while private zones are visible only to Virtual Private Cloud resources.
	// Default value is `public`.
	// Possible values are: `private`, `public`.
	Visibility pulumi.StringPtrInput
}

func (ManagedZoneState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedZoneState)(nil)).Elem()
}

type managedZoneArgs struct {
	// Cloud logging configuration
	// Structure is documented below.
	CloudLoggingConfig *ManagedZoneCloudLoggingConfig `pulumi:"cloudLoggingConfig"`
	// A textual description field. Defaults to 'Managed by Pulumi'.
	Description *string `pulumi:"description"`
	// The DNS name of this managed zone, for instance "example.com.".
	DnsName string `pulumi:"dnsName"`
	// DNSSEC configuration
	// Structure is documented below.
	DnssecConfig *ManagedZoneDnssecConfig `pulumi:"dnssecConfig"`
	// Set this true to delete all records in the zone.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// The presence for this field indicates that outbound forwarding is enabled
	// for this zone. The value of this field contains the set of destinations
	// to forward to.
	// Structure is documented below.
	ForwardingConfig *ManagedZoneForwardingConfig `pulumi:"forwardingConfig"`
	// A set of key/value label pairs to assign to this ManagedZone.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// User assigned name for this resource.
	// Must be unique within the project.
	Name *string `pulumi:"name"`
	// The presence of this field indicates that DNS Peering is enabled for this
	// zone. The value of this field contains the network to peer with.
	// Structure is documented below.
	PeeringConfig *ManagedZonePeeringConfig `pulumi:"peeringConfig"`
	// For privately visible zones, the set of Virtual Private Cloud
	// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
	// Structure is documented below.
	PrivateVisibilityConfig *ManagedZonePrivateVisibilityConfig `pulumi:"privateVisibilityConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
	// lookup queries using automatically configured records for VPC resources. This only applies
	// to networks listed under `privateVisibilityConfig`.
	ReverseLookup *bool `pulumi:"reverseLookup"`
	// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
	// Structure is documented below.
	ServiceDirectoryConfig *ManagedZoneServiceDirectoryConfig `pulumi:"serviceDirectoryConfig"`
	// The zone's visibility: public zones are exposed to the Internet,
	// while private zones are visible only to Virtual Private Cloud resources.
	// Default value is `public`.
	// Possible values are: `private`, `public`.
	Visibility *string `pulumi:"visibility"`
}

// The set of arguments for constructing a ManagedZone resource.
type ManagedZoneArgs struct {
	// Cloud logging configuration
	// Structure is documented below.
	CloudLoggingConfig ManagedZoneCloudLoggingConfigPtrInput
	// A textual description field. Defaults to 'Managed by Pulumi'.
	Description pulumi.StringPtrInput
	// The DNS name of this managed zone, for instance "example.com.".
	DnsName pulumi.StringInput
	// DNSSEC configuration
	// Structure is documented below.
	DnssecConfig ManagedZoneDnssecConfigPtrInput
	// Set this true to delete all records in the zone.
	ForceDestroy pulumi.BoolPtrInput
	// The presence for this field indicates that outbound forwarding is enabled
	// for this zone. The value of this field contains the set of destinations
	// to forward to.
	// Structure is documented below.
	ForwardingConfig ManagedZoneForwardingConfigPtrInput
	// A set of key/value label pairs to assign to this ManagedZone.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// User assigned name for this resource.
	// Must be unique within the project.
	Name pulumi.StringPtrInput
	// The presence of this field indicates that DNS Peering is enabled for this
	// zone. The value of this field contains the network to peer with.
	// Structure is documented below.
	PeeringConfig ManagedZonePeeringConfigPtrInput
	// For privately visible zones, the set of Virtual Private Cloud
	// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
	// Structure is documented below.
	PrivateVisibilityConfig ManagedZonePrivateVisibilityConfigPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
	// lookup queries using automatically configured records for VPC resources. This only applies
	// to networks listed under `privateVisibilityConfig`.
	ReverseLookup pulumi.BoolPtrInput
	// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
	// Structure is documented below.
	ServiceDirectoryConfig ManagedZoneServiceDirectoryConfigPtrInput
	// The zone's visibility: public zones are exposed to the Internet,
	// while private zones are visible only to Virtual Private Cloud resources.
	// Default value is `public`.
	// Possible values are: `private`, `public`.
	Visibility pulumi.StringPtrInput
}

func (ManagedZoneArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedZoneArgs)(nil)).Elem()
}

type ManagedZoneInput interface {
	pulumi.Input

	ToManagedZoneOutput() ManagedZoneOutput
	ToManagedZoneOutputWithContext(ctx context.Context) ManagedZoneOutput
}

func (*ManagedZone) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedZone)(nil)).Elem()
}

func (i *ManagedZone) ToManagedZoneOutput() ManagedZoneOutput {
	return i.ToManagedZoneOutputWithContext(context.Background())
}

func (i *ManagedZone) ToManagedZoneOutputWithContext(ctx context.Context) ManagedZoneOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedZoneOutput)
}

// ManagedZoneArrayInput is an input type that accepts ManagedZoneArray and ManagedZoneArrayOutput values.
// You can construct a concrete instance of `ManagedZoneArrayInput` via:
//
//	ManagedZoneArray{ ManagedZoneArgs{...} }
type ManagedZoneArrayInput interface {
	pulumi.Input

	ToManagedZoneArrayOutput() ManagedZoneArrayOutput
	ToManagedZoneArrayOutputWithContext(context.Context) ManagedZoneArrayOutput
}

type ManagedZoneArray []ManagedZoneInput

func (ManagedZoneArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedZone)(nil)).Elem()
}

func (i ManagedZoneArray) ToManagedZoneArrayOutput() ManagedZoneArrayOutput {
	return i.ToManagedZoneArrayOutputWithContext(context.Background())
}

func (i ManagedZoneArray) ToManagedZoneArrayOutputWithContext(ctx context.Context) ManagedZoneArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedZoneArrayOutput)
}

// ManagedZoneMapInput is an input type that accepts ManagedZoneMap and ManagedZoneMapOutput values.
// You can construct a concrete instance of `ManagedZoneMapInput` via:
//
//	ManagedZoneMap{ "key": ManagedZoneArgs{...} }
type ManagedZoneMapInput interface {
	pulumi.Input

	ToManagedZoneMapOutput() ManagedZoneMapOutput
	ToManagedZoneMapOutputWithContext(context.Context) ManagedZoneMapOutput
}

type ManagedZoneMap map[string]ManagedZoneInput

func (ManagedZoneMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedZone)(nil)).Elem()
}

func (i ManagedZoneMap) ToManagedZoneMapOutput() ManagedZoneMapOutput {
	return i.ToManagedZoneMapOutputWithContext(context.Background())
}

func (i ManagedZoneMap) ToManagedZoneMapOutputWithContext(ctx context.Context) ManagedZoneMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedZoneMapOutput)
}

type ManagedZoneOutput struct{ *pulumi.OutputState }

func (ManagedZoneOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedZone)(nil)).Elem()
}

func (o ManagedZoneOutput) ToManagedZoneOutput() ManagedZoneOutput {
	return o
}

func (o ManagedZoneOutput) ToManagedZoneOutputWithContext(ctx context.Context) ManagedZoneOutput {
	return o
}

// Cloud logging configuration
// Structure is documented below.
func (o ManagedZoneOutput) CloudLoggingConfig() ManagedZoneCloudLoggingConfigOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZoneCloudLoggingConfigOutput { return v.CloudLoggingConfig }).(ManagedZoneCloudLoggingConfigOutput)
}

// The time that this resource was created on the server.
// This is in RFC3339 text format.
func (o ManagedZoneOutput) CreationTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.CreationTime }).(pulumi.StringOutput)
}

// A textual description field. Defaults to 'Managed by Pulumi'.
func (o ManagedZoneOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// The DNS name of this managed zone, for instance "example.com.".
func (o ManagedZoneOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.DnsName }).(pulumi.StringOutput)
}

// DNSSEC configuration
// Structure is documented below.
func (o ManagedZoneOutput) DnssecConfig() ManagedZoneDnssecConfigOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZoneDnssecConfigOutput { return v.DnssecConfig }).(ManagedZoneDnssecConfigOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o ManagedZoneOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Set this true to delete all records in the zone.
func (o ManagedZoneOutput) ForceDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.BoolPtrOutput { return v.ForceDestroy }).(pulumi.BoolPtrOutput)
}

// The presence for this field indicates that outbound forwarding is enabled
// for this zone. The value of this field contains the set of destinations
// to forward to.
// Structure is documented below.
func (o ManagedZoneOutput) ForwardingConfig() ManagedZoneForwardingConfigPtrOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZoneForwardingConfigPtrOutput { return v.ForwardingConfig }).(ManagedZoneForwardingConfigPtrOutput)
}

// A set of key/value label pairs to assign to this ManagedZone.
//
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o ManagedZoneOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Unique identifier for the resource; defined by the server.
func (o ManagedZoneOutput) ManagedZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.ManagedZoneId }).(pulumi.StringOutput)
}

// User assigned name for this resource.
// Must be unique within the project.
func (o ManagedZoneOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Delegate your managedZone to these virtual name servers;
// defined by the server
func (o ManagedZoneOutput) NameServers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringArrayOutput { return v.NameServers }).(pulumi.StringArrayOutput)
}

// The presence of this field indicates that DNS Peering is enabled for this
// zone. The value of this field contains the network to peer with.
// Structure is documented below.
func (o ManagedZoneOutput) PeeringConfig() ManagedZonePeeringConfigPtrOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZonePeeringConfigPtrOutput { return v.PeeringConfig }).(ManagedZonePeeringConfigPtrOutput)
}

// For privately visible zones, the set of Virtual Private Cloud
// resources that the zone is visible from. At least one of `gkeClusters` or `networks` must be specified.
// Structure is documented below.
func (o ManagedZoneOutput) PrivateVisibilityConfig() ManagedZonePrivateVisibilityConfigPtrOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZonePrivateVisibilityConfigPtrOutput { return v.PrivateVisibilityConfig }).(ManagedZonePrivateVisibilityConfigPtrOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o ManagedZoneOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o ManagedZoneOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
// lookup queries using automatically configured records for VPC resources. This only applies
// to networks listed under `privateVisibilityConfig`.
func (o ManagedZoneOutput) ReverseLookup() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.BoolPtrOutput { return v.ReverseLookup }).(pulumi.BoolPtrOutput)
}

// The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
// Structure is documented below.
func (o ManagedZoneOutput) ServiceDirectoryConfig() ManagedZoneServiceDirectoryConfigPtrOutput {
	return o.ApplyT(func(v *ManagedZone) ManagedZoneServiceDirectoryConfigPtrOutput { return v.ServiceDirectoryConfig }).(ManagedZoneServiceDirectoryConfigPtrOutput)
}

// The zone's visibility: public zones are exposed to the Internet,
// while private zones are visible only to Virtual Private Cloud resources.
// Default value is `public`.
// Possible values are: `private`, `public`.
func (o ManagedZoneOutput) Visibility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedZone) pulumi.StringPtrOutput { return v.Visibility }).(pulumi.StringPtrOutput)
}

type ManagedZoneArrayOutput struct{ *pulumi.OutputState }

func (ManagedZoneArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedZone)(nil)).Elem()
}

func (o ManagedZoneArrayOutput) ToManagedZoneArrayOutput() ManagedZoneArrayOutput {
	return o
}

func (o ManagedZoneArrayOutput) ToManagedZoneArrayOutputWithContext(ctx context.Context) ManagedZoneArrayOutput {
	return o
}

func (o ManagedZoneArrayOutput) Index(i pulumi.IntInput) ManagedZoneOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedZone {
		return vs[0].([]*ManagedZone)[vs[1].(int)]
	}).(ManagedZoneOutput)
}

type ManagedZoneMapOutput struct{ *pulumi.OutputState }

func (ManagedZoneMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedZone)(nil)).Elem()
}

func (o ManagedZoneMapOutput) ToManagedZoneMapOutput() ManagedZoneMapOutput {
	return o
}

func (o ManagedZoneMapOutput) ToManagedZoneMapOutputWithContext(ctx context.Context) ManagedZoneMapOutput {
	return o
}

func (o ManagedZoneMapOutput) MapIndex(k pulumi.StringInput) ManagedZoneOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedZone {
		return vs[0].(map[string]*ManagedZone)[vs[1].(string)]
	}).(ManagedZoneOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedZoneInput)(nil)).Elem(), &ManagedZone{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedZoneArrayInput)(nil)).Elem(), ManagedZoneArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedZoneMapInput)(nil)).Elem(), ManagedZoneMap{})
	pulumi.RegisterOutputType(ManagedZoneOutput{})
	pulumi.RegisterOutputType(ManagedZoneArrayOutput{})
	pulumi.RegisterOutputType(ManagedZoneMapOutput{})
}
