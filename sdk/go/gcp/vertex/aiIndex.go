// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vertex

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A representation of a collection of database items organized in a way that allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
//
// To get more information about Index, see:
//
// * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes/)
//
// ## Example Usage
//
// ### Vertex Ai Index
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/vertex"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			bucket, err := storage.NewBucket(ctx, "bucket", &storage.BucketArgs{
//				Name:                     pulumi.String("vertex-ai-index-test"),
//				Location:                 pulumi.String("us-central1"),
//				UniformBucketLevelAccess: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			// The sample data comes from the following link:
//			// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
//			_, err = storage.NewBucketObject(ctx, "data", &storage.BucketObjectArgs{
//				Name:    pulumi.String("contents/data.json"),
//				Bucket:  bucket.Name,
//				Content: pulumi.String("{\"id\": \"42\", \"embedding\": [0.5, 1.0], \"restricts\": [{\"namespace\": \"class\", \"allow\": [\"cat\", \"pet\"]},{\"namespace\": \"category\", \"allow\": [\"feline\"]}]}\n{\"id\": \"43\", \"embedding\": [0.6, 1.0], \"restricts\": [{\"namespace\": \"class\", \"allow\": [\"dog\", \"pet\"]},{\"namespace\": \"category\", \"allow\": [\"canine\"]}]}\n"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vertex.NewAiIndex(ctx, "index", &vertex.AiIndexArgs{
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Region:      pulumi.String("us-central1"),
//				DisplayName: pulumi.String("test-index"),
//				Description: pulumi.String("index for test"),
//				Metadata: &vertex.AiIndexMetadataArgs{
//					ContentsDeltaUri: bucket.Name.ApplyT(func(name string) (string, error) {
//						return fmt.Sprintf("gs://%v/contents", name), nil
//					}).(pulumi.StringOutput),
//					Config: &vertex.AiIndexMetadataConfigArgs{
//						Dimensions:                pulumi.Int(2),
//						ApproximateNeighborsCount: pulumi.Int(150),
//						ShardSize:                 pulumi.String("SHARD_SIZE_SMALL"),
//						DistanceMeasureType:       pulumi.String("DOT_PRODUCT_DISTANCE"),
//						AlgorithmConfig: &vertex.AiIndexMetadataConfigAlgorithmConfigArgs{
//							TreeAhConfig: &vertex.AiIndexMetadataConfigAlgorithmConfigTreeAhConfigArgs{
//								LeafNodeEmbeddingCount:   pulumi.Int(500),
//								LeafNodesToSearchPercent: pulumi.Int(7),
//							},
//						},
//					},
//				},
//				IndexUpdateMethod: pulumi.String("BATCH_UPDATE"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Vertex Ai Index Streaming
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/vertex"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			bucket, err := storage.NewBucket(ctx, "bucket", &storage.BucketArgs{
//				Name:                     pulumi.String("vertex-ai-index-test"),
//				Location:                 pulumi.String("us-central1"),
//				UniformBucketLevelAccess: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			// The sample data comes from the following link:
//			// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
//			_, err = storage.NewBucketObject(ctx, "data", &storage.BucketObjectArgs{
//				Name:    pulumi.String("contents/data.json"),
//				Bucket:  bucket.Name,
//				Content: pulumi.String("{\"id\": \"42\", \"embedding\": [0.5, 1.0], \"restricts\": [{\"namespace\": \"class\", \"allow\": [\"cat\", \"pet\"]},{\"namespace\": \"category\", \"allow\": [\"feline\"]}]}\n{\"id\": \"43\", \"embedding\": [0.6, 1.0], \"restricts\": [{\"namespace\": \"class\", \"allow\": [\"dog\", \"pet\"]},{\"namespace\": \"category\", \"allow\": [\"canine\"]}]}\n"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vertex.NewAiIndex(ctx, "index", &vertex.AiIndexArgs{
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Region:      pulumi.String("us-central1"),
//				DisplayName: pulumi.String("test-index"),
//				Description: pulumi.String("index for test"),
//				Metadata: &vertex.AiIndexMetadataArgs{
//					ContentsDeltaUri: bucket.Name.ApplyT(func(name string) (string, error) {
//						return fmt.Sprintf("gs://%v/contents", name), nil
//					}).(pulumi.StringOutput),
//					Config: &vertex.AiIndexMetadataConfigArgs{
//						Dimensions:          pulumi.Int(2),
//						ShardSize:           pulumi.String("SHARD_SIZE_LARGE"),
//						DistanceMeasureType: pulumi.String("COSINE_DISTANCE"),
//						FeatureNormType:     pulumi.String("UNIT_L2_NORM"),
//						AlgorithmConfig: &vertex.AiIndexMetadataConfigAlgorithmConfigArgs{
//							BruteForceConfig: &vertex.AiIndexMetadataConfigAlgorithmConfigBruteForceConfigArgs{},
//						},
//					},
//				},
//				IndexUpdateMethod: pulumi.String("STREAM_UPDATE"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Index can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{region}}/indexes/{{name}}`
//
// * `{{project}}/{{region}}/{{name}}`
//
// * `{{region}}/{{name}}`
//
// * `{{name}}`
//
// When using the `pulumi import` command, Index can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:vertex/aiIndex:AiIndex default projects/{{project}}/locations/{{region}}/indexes/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:vertex/aiIndex:AiIndex default {{project}}/{{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:vertex/aiIndex:AiIndex default {{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:vertex/aiIndex:AiIndex default {{name}}
// ```
type AiIndex struct {
	pulumi.CustomResourceState

	// The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
	// Structure is documented below.
	DeployedIndexes AiIndexDeployedIndexArrayOutput `pulumi:"deployedIndexes"`
	// The description of the Index.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
	//
	// ***
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Used to perform consistent read-modify-write updates.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// Stats of the index resource.
	// Structure is documented below.
	IndexStats AiIndexIndexStatArrayOutput `pulumi:"indexStats"`
	// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
	// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
	// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
	IndexUpdateMethod pulumi.StringPtrOutput `pulumi:"indexUpdateMethod"`
	// The labels with user-defined metadata to organize your Indexes.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// An additional information about the Index
	// Structure is documented below.
	Metadata AiIndexMetadataPtrOutput `pulumi:"metadata"`
	// Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
	MetadataSchemaUri pulumi.StringOutput `pulumi:"metadataSchemaUri"`
	// The resource name of the Index.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// The region of the index. eg us-central1
	Region pulumi.StringPtrOutput `pulumi:"region"`
	// The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewAiIndex registers a new resource with the given unique name, arguments, and options.
func NewAiIndex(ctx *pulumi.Context,
	name string, args *AiIndexArgs, opts ...pulumi.ResourceOption) (*AiIndex, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AiIndex
	err := ctx.RegisterResource("gcp:vertex/aiIndex:AiIndex", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAiIndex gets an existing AiIndex resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAiIndex(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AiIndexState, opts ...pulumi.ResourceOption) (*AiIndex, error) {
	var resource AiIndex
	err := ctx.ReadResource("gcp:vertex/aiIndex:AiIndex", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AiIndex resources.
type aiIndexState struct {
	// The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	CreateTime *string `pulumi:"createTime"`
	// The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
	// Structure is documented below.
	DeployedIndexes []AiIndexDeployedIndex `pulumi:"deployedIndexes"`
	// The description of the Index.
	Description *string `pulumi:"description"`
	// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
	//
	// ***
	DisplayName *string `pulumi:"displayName"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Used to perform consistent read-modify-write updates.
	Etag *string `pulumi:"etag"`
	// Stats of the index resource.
	// Structure is documented below.
	IndexStats []AiIndexIndexStat `pulumi:"indexStats"`
	// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
	// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
	// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
	IndexUpdateMethod *string `pulumi:"indexUpdateMethod"`
	// The labels with user-defined metadata to organize your Indexes.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// An additional information about the Index
	// Structure is documented below.
	Metadata *AiIndexMetadata `pulumi:"metadata"`
	// Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
	MetadataSchemaUri *string `pulumi:"metadataSchemaUri"`
	// The resource name of the Index.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// The region of the index. eg us-central1
	Region *string `pulumi:"region"`
	// The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	UpdateTime *string `pulumi:"updateTime"`
}

type AiIndexState struct {
	// The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	CreateTime pulumi.StringPtrInput
	// The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
	// Structure is documented below.
	DeployedIndexes AiIndexDeployedIndexArrayInput
	// The description of the Index.
	Description pulumi.StringPtrInput
	// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
	//
	// ***
	DisplayName pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Used to perform consistent read-modify-write updates.
	Etag pulumi.StringPtrInput
	// Stats of the index resource.
	// Structure is documented below.
	IndexStats AiIndexIndexStatArrayInput
	// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
	// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
	// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
	IndexUpdateMethod pulumi.StringPtrInput
	// The labels with user-defined metadata to organize your Indexes.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// An additional information about the Index
	// Structure is documented below.
	Metadata AiIndexMetadataPtrInput
	// Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
	MetadataSchemaUri pulumi.StringPtrInput
	// The resource name of the Index.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// The region of the index. eg us-central1
	Region pulumi.StringPtrInput
	// The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
	UpdateTime pulumi.StringPtrInput
}

func (AiIndexState) ElementType() reflect.Type {
	return reflect.TypeOf((*aiIndexState)(nil)).Elem()
}

type aiIndexArgs struct {
	// The description of the Index.
	Description *string `pulumi:"description"`
	// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
	//
	// ***
	DisplayName string `pulumi:"displayName"`
	// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
	// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
	// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
	IndexUpdateMethod *string `pulumi:"indexUpdateMethod"`
	// The labels with user-defined metadata to organize your Indexes.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// An additional information about the Index
	// Structure is documented below.
	Metadata *AiIndexMetadata `pulumi:"metadata"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The region of the index. eg us-central1
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a AiIndex resource.
type AiIndexArgs struct {
	// The description of the Index.
	Description pulumi.StringPtrInput
	// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
	//
	// ***
	DisplayName pulumi.StringInput
	// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
	// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
	// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
	IndexUpdateMethod pulumi.StringPtrInput
	// The labels with user-defined metadata to organize your Indexes.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// An additional information about the Index
	// Structure is documented below.
	Metadata AiIndexMetadataPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The region of the index. eg us-central1
	Region pulumi.StringPtrInput
}

func (AiIndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aiIndexArgs)(nil)).Elem()
}

type AiIndexInput interface {
	pulumi.Input

	ToAiIndexOutput() AiIndexOutput
	ToAiIndexOutputWithContext(ctx context.Context) AiIndexOutput
}

func (*AiIndex) ElementType() reflect.Type {
	return reflect.TypeOf((**AiIndex)(nil)).Elem()
}

func (i *AiIndex) ToAiIndexOutput() AiIndexOutput {
	return i.ToAiIndexOutputWithContext(context.Background())
}

func (i *AiIndex) ToAiIndexOutputWithContext(ctx context.Context) AiIndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AiIndexOutput)
}

// AiIndexArrayInput is an input type that accepts AiIndexArray and AiIndexArrayOutput values.
// You can construct a concrete instance of `AiIndexArrayInput` via:
//
//	AiIndexArray{ AiIndexArgs{...} }
type AiIndexArrayInput interface {
	pulumi.Input

	ToAiIndexArrayOutput() AiIndexArrayOutput
	ToAiIndexArrayOutputWithContext(context.Context) AiIndexArrayOutput
}

type AiIndexArray []AiIndexInput

func (AiIndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AiIndex)(nil)).Elem()
}

func (i AiIndexArray) ToAiIndexArrayOutput() AiIndexArrayOutput {
	return i.ToAiIndexArrayOutputWithContext(context.Background())
}

func (i AiIndexArray) ToAiIndexArrayOutputWithContext(ctx context.Context) AiIndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AiIndexArrayOutput)
}

// AiIndexMapInput is an input type that accepts AiIndexMap and AiIndexMapOutput values.
// You can construct a concrete instance of `AiIndexMapInput` via:
//
//	AiIndexMap{ "key": AiIndexArgs{...} }
type AiIndexMapInput interface {
	pulumi.Input

	ToAiIndexMapOutput() AiIndexMapOutput
	ToAiIndexMapOutputWithContext(context.Context) AiIndexMapOutput
}

type AiIndexMap map[string]AiIndexInput

func (AiIndexMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AiIndex)(nil)).Elem()
}

func (i AiIndexMap) ToAiIndexMapOutput() AiIndexMapOutput {
	return i.ToAiIndexMapOutputWithContext(context.Background())
}

func (i AiIndexMap) ToAiIndexMapOutputWithContext(ctx context.Context) AiIndexMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AiIndexMapOutput)
}

type AiIndexOutput struct{ *pulumi.OutputState }

func (AiIndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AiIndex)(nil)).Elem()
}

func (o AiIndexOutput) ToAiIndexOutput() AiIndexOutput {
	return o
}

func (o AiIndexOutput) ToAiIndexOutputWithContext(ctx context.Context) AiIndexOutput {
	return o
}

// The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
func (o AiIndexOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
// Structure is documented below.
func (o AiIndexOutput) DeployedIndexes() AiIndexDeployedIndexArrayOutput {
	return o.ApplyT(func(v *AiIndex) AiIndexDeployedIndexArrayOutput { return v.DeployedIndexes }).(AiIndexDeployedIndexArrayOutput)
}

// The description of the Index.
func (o AiIndexOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
//
// ***
func (o AiIndexOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o AiIndexOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Used to perform consistent read-modify-write updates.
func (o AiIndexOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

// Stats of the index resource.
// Structure is documented below.
func (o AiIndexOutput) IndexStats() AiIndexIndexStatArrayOutput {
	return o.ApplyT(func(v *AiIndex) AiIndexIndexStatArrayOutput { return v.IndexStats }).(AiIndexIndexStatArrayOutput)
}

// The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
// * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
// * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
func (o AiIndexOutput) IndexUpdateMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringPtrOutput { return v.IndexUpdateMethod }).(pulumi.StringPtrOutput)
}

// The labels with user-defined metadata to organize your Indexes.
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o AiIndexOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// An additional information about the Index
// Structure is documented below.
func (o AiIndexOutput) Metadata() AiIndexMetadataPtrOutput {
	return o.ApplyT(func(v *AiIndex) AiIndexMetadataPtrOutput { return v.Metadata }).(AiIndexMetadataPtrOutput)
}

// Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
func (o AiIndexOutput) MetadataSchemaUri() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.MetadataSchemaUri }).(pulumi.StringOutput)
}

// The resource name of the Index.
func (o AiIndexOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o AiIndexOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o AiIndexOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// The region of the index. eg us-central1
func (o AiIndexOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringPtrOutput { return v.Region }).(pulumi.StringPtrOutput)
}

// The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
func (o AiIndexOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *AiIndex) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

type AiIndexArrayOutput struct{ *pulumi.OutputState }

func (AiIndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AiIndex)(nil)).Elem()
}

func (o AiIndexArrayOutput) ToAiIndexArrayOutput() AiIndexArrayOutput {
	return o
}

func (o AiIndexArrayOutput) ToAiIndexArrayOutputWithContext(ctx context.Context) AiIndexArrayOutput {
	return o
}

func (o AiIndexArrayOutput) Index(i pulumi.IntInput) AiIndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AiIndex {
		return vs[0].([]*AiIndex)[vs[1].(int)]
	}).(AiIndexOutput)
}

type AiIndexMapOutput struct{ *pulumi.OutputState }

func (AiIndexMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AiIndex)(nil)).Elem()
}

func (o AiIndexMapOutput) ToAiIndexMapOutput() AiIndexMapOutput {
	return o
}

func (o AiIndexMapOutput) ToAiIndexMapOutputWithContext(ctx context.Context) AiIndexMapOutput {
	return o
}

func (o AiIndexMapOutput) MapIndex(k pulumi.StringInput) AiIndexOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AiIndex {
		return vs[0].(map[string]*AiIndex)[vs[1].(string)]
	}).(AiIndexOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AiIndexInput)(nil)).Elem(), &AiIndex{})
	pulumi.RegisterInputType(reflect.TypeOf((*AiIndexArrayInput)(nil)).Elem(), AiIndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AiIndexMapInput)(nil)).Elem(), AiIndexMap{})
	pulumi.RegisterOutputType(AiIndexOutput{})
	pulumi.RegisterOutputType(AiIndexArrayOutput{})
	pulumi.RegisterOutputType(AiIndexMapOutput{})
}
