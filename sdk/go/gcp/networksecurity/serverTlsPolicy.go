// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networksecurity

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ServerTlsPolicy is a resource that specifies how a server should authenticate incoming requests. This resource itself does not affect configuration unless it is attached to a target HTTPS proxy or endpoint config selector resource.
//
// To get more information about ServerTlsPolicy, see:
//
// * [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-security/rest/v1beta1/projects.locations.serverTlsPolicies)
// * How-to Guides
//   - [Use ServerTlsPolicy](https://cloud.google.com/load-balancing/docs/mtls)
//
// ## Example Usage
//
// ### Network Security Server Tls Policy Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
//				Name: pulumi.String("my-server-tls-policy"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Description: pulumi.String("my description"),
//				AllowOpen:   pulumi.Bool(false),
//				ServerCertificate: &networksecurity.ServerTlsPolicyServerCertificateArgs{
//					CertificateProviderInstance: &networksecurity.ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs{
//						PluginInstance: pulumi.String("google_cloud_private_spiffe"),
//					},
//				},
//				MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
//					ClientValidationCas: networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaArray{
//						&networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaArgs{
//							GrpcEndpoint: &networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs{
//								TargetUri: pulumi.String("unix:mypath"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Security Server Tls Policy Advanced
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
//				Name: pulumi.String("my-server-tls-policy"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Description: pulumi.String("my description"),
//				Location:    pulumi.String("global"),
//				AllowOpen:   pulumi.Bool(false),
//				MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
//					ClientValidationMode: pulumi.String("ALLOW_INVALID_OR_MISSING_CLIENT_CERT"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Security Server Tls Policy Server Cert
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
//				Name: pulumi.String("my-server-tls-policy"),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//				Description: pulumi.String("my description"),
//				Location:    pulumi.String("global"),
//				AllowOpen:   pulumi.Bool(false),
//				ServerCertificate: &networksecurity.ServerTlsPolicyServerCertificateArgs{
//					GrpcEndpoint: &networksecurity.ServerTlsPolicyServerCertificateGrpcEndpointArgs{
//						TargetUri: pulumi.String("unix:mypath"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Security Server Tls Policy Mtls
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/ca_cert.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			invokeFile1, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/ca_cert.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultTrustConfig, err := certificatemanager.NewTrustConfig(ctx, "default", &certificatemanager.TrustConfigArgs{
//				Name:        pulumi.String("my-trust-config"),
//				Description: pulumi.String("sample trust config description"),
//				Location:    pulumi.String("global"),
//				TrustStores: certificatemanager.TrustConfigTrustStoreArray{
//					&certificatemanager.TrustConfigTrustStoreArgs{
//						TrustAnchors: certificatemanager.TrustConfigTrustStoreTrustAnchorArray{
//							&certificatemanager.TrustConfigTrustStoreTrustAnchorArgs{
//								PemCertificate: pulumi.String(invokeFile.Result),
//							},
//						},
//						IntermediateCas: certificatemanager.TrustConfigTrustStoreIntermediateCaArray{
//							&certificatemanager.TrustConfigTrustStoreIntermediateCaArgs{
//								PemCertificate: pulumi.String(invokeFile1.Result),
//							},
//						},
//					},
//				},
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
//				Name:        pulumi.String("my-server-tls-policy"),
//				Description: pulumi.String("my description"),
//				Location:    pulumi.String("global"),
//				AllowOpen:   pulumi.Bool(false),
//				MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
//					ClientValidationMode: pulumi.String("REJECT_INVALID"),
//					ClientValidationTrustConfig: defaultTrustConfig.Name.ApplyT(func(name string) (string, error) {
//						return fmt.Sprintf("projects/%v/locations/global/trustConfigs/%v", project.Number, name), nil
//					}).(pulumi.StringOutput),
//				},
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ServerTlsPolicy can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}`
// * `{{project}}/{{location}}/{{name}}`
// * `{{location}}/{{name}}`
//
// When using the `pulumi import` command, ServerTlsPolicy can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}
// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{project}}/{{location}}/{{name}}
// $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{location}}/{{name}}
// ```
type ServerTlsPolicy struct {
	pulumi.CustomResourceState

	// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
	// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
	// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
	AllowOpen pulumi.BoolPtrOutput `pulumi:"allowOpen"`
	// Time the ServerTlsPolicy was created in UTC.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// A free-text description of the resource. Max length 1024 characters.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Set of label tags associated with the ServerTlsPolicy resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The location of the server tls policy.
	// The default value is `global`.
	Location pulumi.StringPtrOutput `pulumi:"location"`
	// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
	// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
	// Structure is documented below.
	MtlsPolicy ServerTlsPolicyMtlsPolicyPtrOutput `pulumi:"mtlsPolicy"`
	// Name of the ServerTlsPolicy resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	//  and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
	// Structure is documented below.
	ServerCertificate ServerTlsPolicyServerCertificatePtrOutput `pulumi:"serverCertificate"`
	// Time the ServerTlsPolicy was updated in UTC.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewServerTlsPolicy registers a new resource with the given unique name, arguments, and options.
func NewServerTlsPolicy(ctx *pulumi.Context,
	name string, args *ServerTlsPolicyArgs, opts ...pulumi.ResourceOption) (*ServerTlsPolicy, error) {
	if args == nil {
		args = &ServerTlsPolicyArgs{}
	}

	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServerTlsPolicy
	err := ctx.RegisterResource("gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServerTlsPolicy gets an existing ServerTlsPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServerTlsPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServerTlsPolicyState, opts ...pulumi.ResourceOption) (*ServerTlsPolicy, error) {
	var resource ServerTlsPolicy
	err := ctx.ReadResource("gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServerTlsPolicy resources.
type serverTlsPolicyState struct {
	// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
	// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
	// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
	AllowOpen *bool `pulumi:"allowOpen"`
	// Time the ServerTlsPolicy was created in UTC.
	CreateTime *string `pulumi:"createTime"`
	// A free-text description of the resource. Max length 1024 characters.
	Description *string `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Set of label tags associated with the ServerTlsPolicy resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location of the server tls policy.
	// The default value is `global`.
	Location *string `pulumi:"location"`
	// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
	// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
	// Structure is documented below.
	MtlsPolicy *ServerTlsPolicyMtlsPolicy `pulumi:"mtlsPolicy"`
	// Name of the ServerTlsPolicy resource.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	//  and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
	// Structure is documented below.
	ServerCertificate *ServerTlsPolicyServerCertificate `pulumi:"serverCertificate"`
	// Time the ServerTlsPolicy was updated in UTC.
	UpdateTime *string `pulumi:"updateTime"`
}

type ServerTlsPolicyState struct {
	// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
	// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
	// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
	AllowOpen pulumi.BoolPtrInput
	// Time the ServerTlsPolicy was created in UTC.
	CreateTime pulumi.StringPtrInput
	// A free-text description of the resource. Max length 1024 characters.
	Description pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Set of label tags associated with the ServerTlsPolicy resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location of the server tls policy.
	// The default value is `global`.
	Location pulumi.StringPtrInput
	// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
	// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
	// Structure is documented below.
	MtlsPolicy ServerTlsPolicyMtlsPolicyPtrInput
	// Name of the ServerTlsPolicy resource.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	//  and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
	// Structure is documented below.
	ServerCertificate ServerTlsPolicyServerCertificatePtrInput
	// Time the ServerTlsPolicy was updated in UTC.
	UpdateTime pulumi.StringPtrInput
}

func (ServerTlsPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*serverTlsPolicyState)(nil)).Elem()
}

type serverTlsPolicyArgs struct {
	// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
	// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
	// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
	AllowOpen *bool `pulumi:"allowOpen"`
	// A free-text description of the resource. Max length 1024 characters.
	Description *string `pulumi:"description"`
	// Set of label tags associated with the ServerTlsPolicy resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location of the server tls policy.
	// The default value is `global`.
	Location *string `pulumi:"location"`
	// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
	// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
	// Structure is documented below.
	MtlsPolicy *ServerTlsPolicyMtlsPolicy `pulumi:"mtlsPolicy"`
	// Name of the ServerTlsPolicy resource.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
	// Structure is documented below.
	ServerCertificate *ServerTlsPolicyServerCertificate `pulumi:"serverCertificate"`
}

// The set of arguments for constructing a ServerTlsPolicy resource.
type ServerTlsPolicyArgs struct {
	// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
	// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
	// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
	AllowOpen pulumi.BoolPtrInput
	// A free-text description of the resource. Max length 1024 characters.
	Description pulumi.StringPtrInput
	// Set of label tags associated with the ServerTlsPolicy resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location of the server tls policy.
	// The default value is `global`.
	Location pulumi.StringPtrInput
	// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
	// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
	// Structure is documented below.
	MtlsPolicy ServerTlsPolicyMtlsPolicyPtrInput
	// Name of the ServerTlsPolicy resource.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
	// Structure is documented below.
	ServerCertificate ServerTlsPolicyServerCertificatePtrInput
}

func (ServerTlsPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serverTlsPolicyArgs)(nil)).Elem()
}

type ServerTlsPolicyInput interface {
	pulumi.Input

	ToServerTlsPolicyOutput() ServerTlsPolicyOutput
	ToServerTlsPolicyOutputWithContext(ctx context.Context) ServerTlsPolicyOutput
}

func (*ServerTlsPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerTlsPolicy)(nil)).Elem()
}

func (i *ServerTlsPolicy) ToServerTlsPolicyOutput() ServerTlsPolicyOutput {
	return i.ToServerTlsPolicyOutputWithContext(context.Background())
}

func (i *ServerTlsPolicy) ToServerTlsPolicyOutputWithContext(ctx context.Context) ServerTlsPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerTlsPolicyOutput)
}

// ServerTlsPolicyArrayInput is an input type that accepts ServerTlsPolicyArray and ServerTlsPolicyArrayOutput values.
// You can construct a concrete instance of `ServerTlsPolicyArrayInput` via:
//
//	ServerTlsPolicyArray{ ServerTlsPolicyArgs{...} }
type ServerTlsPolicyArrayInput interface {
	pulumi.Input

	ToServerTlsPolicyArrayOutput() ServerTlsPolicyArrayOutput
	ToServerTlsPolicyArrayOutputWithContext(context.Context) ServerTlsPolicyArrayOutput
}

type ServerTlsPolicyArray []ServerTlsPolicyInput

func (ServerTlsPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServerTlsPolicy)(nil)).Elem()
}

func (i ServerTlsPolicyArray) ToServerTlsPolicyArrayOutput() ServerTlsPolicyArrayOutput {
	return i.ToServerTlsPolicyArrayOutputWithContext(context.Background())
}

func (i ServerTlsPolicyArray) ToServerTlsPolicyArrayOutputWithContext(ctx context.Context) ServerTlsPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerTlsPolicyArrayOutput)
}

// ServerTlsPolicyMapInput is an input type that accepts ServerTlsPolicyMap and ServerTlsPolicyMapOutput values.
// You can construct a concrete instance of `ServerTlsPolicyMapInput` via:
//
//	ServerTlsPolicyMap{ "key": ServerTlsPolicyArgs{...} }
type ServerTlsPolicyMapInput interface {
	pulumi.Input

	ToServerTlsPolicyMapOutput() ServerTlsPolicyMapOutput
	ToServerTlsPolicyMapOutputWithContext(context.Context) ServerTlsPolicyMapOutput
}

type ServerTlsPolicyMap map[string]ServerTlsPolicyInput

func (ServerTlsPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServerTlsPolicy)(nil)).Elem()
}

func (i ServerTlsPolicyMap) ToServerTlsPolicyMapOutput() ServerTlsPolicyMapOutput {
	return i.ToServerTlsPolicyMapOutputWithContext(context.Background())
}

func (i ServerTlsPolicyMap) ToServerTlsPolicyMapOutputWithContext(ctx context.Context) ServerTlsPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerTlsPolicyMapOutput)
}

type ServerTlsPolicyOutput struct{ *pulumi.OutputState }

func (ServerTlsPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerTlsPolicy)(nil)).Elem()
}

func (o ServerTlsPolicyOutput) ToServerTlsPolicyOutput() ServerTlsPolicyOutput {
	return o
}

func (o ServerTlsPolicyOutput) ToServerTlsPolicyOutputWithContext(ctx context.Context) ServerTlsPolicyOutput {
	return o
}

// This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
// Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
// Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
func (o ServerTlsPolicyOutput) AllowOpen() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.BoolPtrOutput { return v.AllowOpen }).(pulumi.BoolPtrOutput)
}

// Time the ServerTlsPolicy was created in UTC.
func (o ServerTlsPolicyOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// A free-text description of the resource. Max length 1024 characters.
func (o ServerTlsPolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o ServerTlsPolicyOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Set of label tags associated with the ServerTlsPolicy resource.
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o ServerTlsPolicyOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The location of the server tls policy.
// The default value is `global`.
func (o ServerTlsPolicyOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringPtrOutput { return v.Location }).(pulumi.StringPtrOutput)
}

// This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
// Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
// Structure is documented below.
func (o ServerTlsPolicyOutput) MtlsPolicy() ServerTlsPolicyMtlsPolicyPtrOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) ServerTlsPolicyMtlsPolicyPtrOutput { return v.MtlsPolicy }).(ServerTlsPolicyMtlsPolicyPtrOutput)
}

// Name of the ServerTlsPolicy resource.
func (o ServerTlsPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o ServerTlsPolicyOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
//
//	and default labels configured on the provider.
func (o ServerTlsPolicyOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
// Structure is documented below.
func (o ServerTlsPolicyOutput) ServerCertificate() ServerTlsPolicyServerCertificatePtrOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) ServerTlsPolicyServerCertificatePtrOutput { return v.ServerCertificate }).(ServerTlsPolicyServerCertificatePtrOutput)
}

// Time the ServerTlsPolicy was updated in UTC.
func (o ServerTlsPolicyOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ServerTlsPolicy) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

type ServerTlsPolicyArrayOutput struct{ *pulumi.OutputState }

func (ServerTlsPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServerTlsPolicy)(nil)).Elem()
}

func (o ServerTlsPolicyArrayOutput) ToServerTlsPolicyArrayOutput() ServerTlsPolicyArrayOutput {
	return o
}

func (o ServerTlsPolicyArrayOutput) ToServerTlsPolicyArrayOutputWithContext(ctx context.Context) ServerTlsPolicyArrayOutput {
	return o
}

func (o ServerTlsPolicyArrayOutput) Index(i pulumi.IntInput) ServerTlsPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServerTlsPolicy {
		return vs[0].([]*ServerTlsPolicy)[vs[1].(int)]
	}).(ServerTlsPolicyOutput)
}

type ServerTlsPolicyMapOutput struct{ *pulumi.OutputState }

func (ServerTlsPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServerTlsPolicy)(nil)).Elem()
}

func (o ServerTlsPolicyMapOutput) ToServerTlsPolicyMapOutput() ServerTlsPolicyMapOutput {
	return o
}

func (o ServerTlsPolicyMapOutput) ToServerTlsPolicyMapOutputWithContext(ctx context.Context) ServerTlsPolicyMapOutput {
	return o
}

func (o ServerTlsPolicyMapOutput) MapIndex(k pulumi.StringInput) ServerTlsPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServerTlsPolicy {
		return vs[0].(map[string]*ServerTlsPolicy)[vs[1].(string)]
	}).(ServerTlsPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServerTlsPolicyInput)(nil)).Elem(), &ServerTlsPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerTlsPolicyArrayInput)(nil)).Elem(), ServerTlsPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerTlsPolicyMapInput)(nil)).Elem(), ServerTlsPolicyMap{})
	pulumi.RegisterOutputType(ServerTlsPolicyOutput{})
	pulumi.RegisterOutputType(ServerTlsPolicyArrayOutput{})
	pulumi.RegisterOutputType(ServerTlsPolicyMapOutput{})
}
