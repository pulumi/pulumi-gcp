// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bigtable

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// App profile is a configuration object describing how Cloud Bigtable should treat traffic from a particular end user application.
//
// To get more information about AppProfile, see:
//
// * [API documentation](https://cloud.google.com/bigtable/docs/reference/admin/rest/v2/projects.instances.appProfiles)
//
// ## Example Usage
//
// ### Bigtable App Profile Anycluster
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/bigtable"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := bigtable.NewInstance(ctx, "instance", &bigtable.InstanceArgs{
//				Name: pulumi.String("bt-instance"),
//				Clusters: bigtable.InstanceClusterArray{
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-1"),
//						Zone:        pulumi.String("us-central1-a"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-2"),
//						Zone:        pulumi.String("us-central1-b"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-3"),
//						Zone:        pulumi.String("us-central1-c"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//				},
//				DeletionProtection: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = bigtable.NewAppProfile(ctx, "ap", &bigtable.AppProfileArgs{
//				Instance:                  instance.Name,
//				AppProfileId:              pulumi.String("bt-profile"),
//				MultiClusterRoutingUseAny: pulumi.Bool(true),
//				IgnoreWarnings:            pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Bigtable App Profile Singlecluster
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/bigtable"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := bigtable.NewInstance(ctx, "instance", &bigtable.InstanceArgs{
//				Name: pulumi.String("bt-instance"),
//				Clusters: bigtable.InstanceClusterArray{
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-1"),
//						Zone:        pulumi.String("us-central1-b"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//				},
//				DeletionProtection: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = bigtable.NewAppProfile(ctx, "ap", &bigtable.AppProfileArgs{
//				Instance:     instance.Name,
//				AppProfileId: pulumi.String("bt-profile"),
//				SingleClusterRouting: &bigtable.AppProfileSingleClusterRoutingArgs{
//					ClusterId:                pulumi.String("cluster-1"),
//					AllowTransactionalWrites: pulumi.Bool(true),
//				},
//				IgnoreWarnings: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Bigtable App Profile Multicluster
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/bigtable"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := bigtable.NewInstance(ctx, "instance", &bigtable.InstanceArgs{
//				Name: pulumi.String("bt-instance"),
//				Clusters: bigtable.InstanceClusterArray{
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-1"),
//						Zone:        pulumi.String("us-central1-a"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-2"),
//						Zone:        pulumi.String("us-central1-b"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-3"),
//						Zone:        pulumi.String("us-central1-c"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//				},
//				DeletionProtection: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = bigtable.NewAppProfile(ctx, "ap", &bigtable.AppProfileArgs{
//				Instance:                  instance.Name,
//				AppProfileId:              pulumi.String("bt-profile"),
//				MultiClusterRoutingUseAny: pulumi.Bool(true),
//				MultiClusterRoutingClusterIds: pulumi.StringArray{
//					pulumi.String("cluster-1"),
//					pulumi.String("cluster-2"),
//				},
//				IgnoreWarnings: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Bigtable App Profile Priority
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/bigtable"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := bigtable.NewInstance(ctx, "instance", &bigtable.InstanceArgs{
//				Name: pulumi.String("bt-instance"),
//				Clusters: bigtable.InstanceClusterArray{
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("cluster-1"),
//						Zone:        pulumi.String("us-central1-b"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//				},
//				DeletionProtection: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = bigtable.NewAppProfile(ctx, "ap", &bigtable.AppProfileArgs{
//				Instance:     instance.Name,
//				AppProfileId: pulumi.String("bt-profile"),
//				SingleClusterRouting: &bigtable.AppProfileSingleClusterRoutingArgs{
//					ClusterId:                pulumi.String("cluster-1"),
//					AllowTransactionalWrites: pulumi.Bool(true),
//				},
//				StandardIsolation: &bigtable.AppProfileStandardIsolationArgs{
//					Priority: pulumi.String("PRIORITY_LOW"),
//				},
//				IgnoreWarnings: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// AppProfile can be imported using any of these accepted formats:
//
// * `projects/{{project}}/instances/{{instance}}/appProfiles/{{app_profile_id}}`
//
// * `{{project}}/{{instance}}/{{app_profile_id}}`
//
// * `{{instance}}/{{app_profile_id}}`
//
// When using the `pulumi import` command, AppProfile can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:bigtable/appProfile:AppProfile default projects/{{project}}/instances/{{instance}}/appProfiles/{{app_profile_id}}
// ```
//
// ```sh
// $ pulumi import gcp:bigtable/appProfile:AppProfile default {{project}}/{{instance}}/{{app_profile_id}}
// ```
//
// ```sh
// $ pulumi import gcp:bigtable/appProfile:AppProfile default {{instance}}/{{app_profile_id}}
// ```
type AppProfile struct {
	pulumi.CustomResourceState

	// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
	AppProfileId pulumi.StringOutput `pulumi:"appProfileId"`
	// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
	// Structure is documented below.
	DataBoostIsolationReadOnly AppProfileDataBoostIsolationReadOnlyPtrOutput `pulumi:"dataBoostIsolationReadOnly"`
	// Long form description of the use case for this app profile.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// If true, ignore safety checks when deleting/updating the app profile.
	IgnoreWarnings pulumi.BoolPtrOutput `pulumi:"ignoreWarnings"`
	// The name of the instance to create the app profile within.
	Instance pulumi.StringPtrOutput `pulumi:"instance"`
	// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
	MultiClusterRoutingClusterIds pulumi.StringArrayOutput `pulumi:"multiClusterRoutingClusterIds"`
	// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
	// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
	// consistency to improve availability.
	MultiClusterRoutingUseAny pulumi.BoolPtrOutput `pulumi:"multiClusterRoutingUseAny"`
	// The unique name of the requested app profile. Values are of the form `projects/<project>/instances/<instance>/appProfiles/<appProfileId>`.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
	RowAffinity pulumi.BoolPtrOutput `pulumi:"rowAffinity"`
	// Use a single-cluster routing policy.
	// Structure is documented below.
	SingleClusterRouting AppProfileSingleClusterRoutingPtrOutput `pulumi:"singleClusterRouting"`
	// The standard options used for isolating this app profile's traffic from other use cases.
	// Structure is documented below.
	StandardIsolation AppProfileStandardIsolationOutput `pulumi:"standardIsolation"`
}

// NewAppProfile registers a new resource with the given unique name, arguments, and options.
func NewAppProfile(ctx *pulumi.Context,
	name string, args *AppProfileArgs, opts ...pulumi.ResourceOption) (*AppProfile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppProfileId == nil {
		return nil, errors.New("invalid value for required argument 'AppProfileId'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("gcp:bigquery/appProfile:AppProfile"),
		},
		{
			Type: pulumi.String("gcp:bigquery/appProfile:AppProfile"),
		},
	})
	opts = append(opts, aliases)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AppProfile
	err := ctx.RegisterResource("gcp:bigtable/appProfile:AppProfile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAppProfile gets an existing AppProfile resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAppProfile(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AppProfileState, opts ...pulumi.ResourceOption) (*AppProfile, error) {
	var resource AppProfile
	err := ctx.ReadResource("gcp:bigtable/appProfile:AppProfile", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AppProfile resources.
type appProfileState struct {
	// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
	AppProfileId *string `pulumi:"appProfileId"`
	// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
	// Structure is documented below.
	DataBoostIsolationReadOnly *AppProfileDataBoostIsolationReadOnly `pulumi:"dataBoostIsolationReadOnly"`
	// Long form description of the use case for this app profile.
	Description *string `pulumi:"description"`
	// If true, ignore safety checks when deleting/updating the app profile.
	IgnoreWarnings *bool `pulumi:"ignoreWarnings"`
	// The name of the instance to create the app profile within.
	Instance *string `pulumi:"instance"`
	// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
	MultiClusterRoutingClusterIds []string `pulumi:"multiClusterRoutingClusterIds"`
	// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
	// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
	// consistency to improve availability.
	MultiClusterRoutingUseAny *bool `pulumi:"multiClusterRoutingUseAny"`
	// The unique name of the requested app profile. Values are of the form `projects/<project>/instances/<instance>/appProfiles/<appProfileId>`.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
	RowAffinity *bool `pulumi:"rowAffinity"`
	// Use a single-cluster routing policy.
	// Structure is documented below.
	SingleClusterRouting *AppProfileSingleClusterRouting `pulumi:"singleClusterRouting"`
	// The standard options used for isolating this app profile's traffic from other use cases.
	// Structure is documented below.
	StandardIsolation *AppProfileStandardIsolation `pulumi:"standardIsolation"`
}

type AppProfileState struct {
	// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
	AppProfileId pulumi.StringPtrInput
	// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
	// Structure is documented below.
	DataBoostIsolationReadOnly AppProfileDataBoostIsolationReadOnlyPtrInput
	// Long form description of the use case for this app profile.
	Description pulumi.StringPtrInput
	// If true, ignore safety checks when deleting/updating the app profile.
	IgnoreWarnings pulumi.BoolPtrInput
	// The name of the instance to create the app profile within.
	Instance pulumi.StringPtrInput
	// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
	MultiClusterRoutingClusterIds pulumi.StringArrayInput
	// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
	// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
	// consistency to improve availability.
	MultiClusterRoutingUseAny pulumi.BoolPtrInput
	// The unique name of the requested app profile. Values are of the form `projects/<project>/instances/<instance>/appProfiles/<appProfileId>`.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
	RowAffinity pulumi.BoolPtrInput
	// Use a single-cluster routing policy.
	// Structure is documented below.
	SingleClusterRouting AppProfileSingleClusterRoutingPtrInput
	// The standard options used for isolating this app profile's traffic from other use cases.
	// Structure is documented below.
	StandardIsolation AppProfileStandardIsolationPtrInput
}

func (AppProfileState) ElementType() reflect.Type {
	return reflect.TypeOf((*appProfileState)(nil)).Elem()
}

type appProfileArgs struct {
	// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
	AppProfileId string `pulumi:"appProfileId"`
	// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
	// Structure is documented below.
	DataBoostIsolationReadOnly *AppProfileDataBoostIsolationReadOnly `pulumi:"dataBoostIsolationReadOnly"`
	// Long form description of the use case for this app profile.
	Description *string `pulumi:"description"`
	// If true, ignore safety checks when deleting/updating the app profile.
	IgnoreWarnings *bool `pulumi:"ignoreWarnings"`
	// The name of the instance to create the app profile within.
	Instance *string `pulumi:"instance"`
	// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
	MultiClusterRoutingClusterIds []string `pulumi:"multiClusterRoutingClusterIds"`
	// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
	// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
	// consistency to improve availability.
	MultiClusterRoutingUseAny *bool `pulumi:"multiClusterRoutingUseAny"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
	RowAffinity *bool `pulumi:"rowAffinity"`
	// Use a single-cluster routing policy.
	// Structure is documented below.
	SingleClusterRouting *AppProfileSingleClusterRouting `pulumi:"singleClusterRouting"`
	// The standard options used for isolating this app profile's traffic from other use cases.
	// Structure is documented below.
	StandardIsolation *AppProfileStandardIsolation `pulumi:"standardIsolation"`
}

// The set of arguments for constructing a AppProfile resource.
type AppProfileArgs struct {
	// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
	AppProfileId pulumi.StringInput
	// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
	// Structure is documented below.
	DataBoostIsolationReadOnly AppProfileDataBoostIsolationReadOnlyPtrInput
	// Long form description of the use case for this app profile.
	Description pulumi.StringPtrInput
	// If true, ignore safety checks when deleting/updating the app profile.
	IgnoreWarnings pulumi.BoolPtrInput
	// The name of the instance to create the app profile within.
	Instance pulumi.StringPtrInput
	// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
	MultiClusterRoutingClusterIds pulumi.StringArrayInput
	// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
	// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
	// consistency to improve availability.
	MultiClusterRoutingUseAny pulumi.BoolPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
	RowAffinity pulumi.BoolPtrInput
	// Use a single-cluster routing policy.
	// Structure is documented below.
	SingleClusterRouting AppProfileSingleClusterRoutingPtrInput
	// The standard options used for isolating this app profile's traffic from other use cases.
	// Structure is documented below.
	StandardIsolation AppProfileStandardIsolationPtrInput
}

func (AppProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*appProfileArgs)(nil)).Elem()
}

type AppProfileInput interface {
	pulumi.Input

	ToAppProfileOutput() AppProfileOutput
	ToAppProfileOutputWithContext(ctx context.Context) AppProfileOutput
}

func (*AppProfile) ElementType() reflect.Type {
	return reflect.TypeOf((**AppProfile)(nil)).Elem()
}

func (i *AppProfile) ToAppProfileOutput() AppProfileOutput {
	return i.ToAppProfileOutputWithContext(context.Background())
}

func (i *AppProfile) ToAppProfileOutputWithContext(ctx context.Context) AppProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppProfileOutput)
}

// AppProfileArrayInput is an input type that accepts AppProfileArray and AppProfileArrayOutput values.
// You can construct a concrete instance of `AppProfileArrayInput` via:
//
//	AppProfileArray{ AppProfileArgs{...} }
type AppProfileArrayInput interface {
	pulumi.Input

	ToAppProfileArrayOutput() AppProfileArrayOutput
	ToAppProfileArrayOutputWithContext(context.Context) AppProfileArrayOutput
}

type AppProfileArray []AppProfileInput

func (AppProfileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppProfile)(nil)).Elem()
}

func (i AppProfileArray) ToAppProfileArrayOutput() AppProfileArrayOutput {
	return i.ToAppProfileArrayOutputWithContext(context.Background())
}

func (i AppProfileArray) ToAppProfileArrayOutputWithContext(ctx context.Context) AppProfileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppProfileArrayOutput)
}

// AppProfileMapInput is an input type that accepts AppProfileMap and AppProfileMapOutput values.
// You can construct a concrete instance of `AppProfileMapInput` via:
//
//	AppProfileMap{ "key": AppProfileArgs{...} }
type AppProfileMapInput interface {
	pulumi.Input

	ToAppProfileMapOutput() AppProfileMapOutput
	ToAppProfileMapOutputWithContext(context.Context) AppProfileMapOutput
}

type AppProfileMap map[string]AppProfileInput

func (AppProfileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppProfile)(nil)).Elem()
}

func (i AppProfileMap) ToAppProfileMapOutput() AppProfileMapOutput {
	return i.ToAppProfileMapOutputWithContext(context.Background())
}

func (i AppProfileMap) ToAppProfileMapOutputWithContext(ctx context.Context) AppProfileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppProfileMapOutput)
}

type AppProfileOutput struct{ *pulumi.OutputState }

func (AppProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppProfile)(nil)).Elem()
}

func (o AppProfileOutput) ToAppProfileOutput() AppProfileOutput {
	return o
}

func (o AppProfileOutput) ToAppProfileOutputWithContext(ctx context.Context) AppProfileOutput {
	return o
}

// The unique name of the app profile in the form `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
func (o AppProfileOutput) AppProfileId() pulumi.StringOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringOutput { return v.AppProfileId }).(pulumi.StringOutput)
}

// Specifies that this app profile is intended for read-only usage via the Data Boost feature.
// Structure is documented below.
func (o AppProfileOutput) DataBoostIsolationReadOnly() AppProfileDataBoostIsolationReadOnlyPtrOutput {
	return o.ApplyT(func(v *AppProfile) AppProfileDataBoostIsolationReadOnlyPtrOutput { return v.DataBoostIsolationReadOnly }).(AppProfileDataBoostIsolationReadOnlyPtrOutput)
}

// Long form description of the use case for this app profile.
func (o AppProfileOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// If true, ignore safety checks when deleting/updating the app profile.
func (o AppProfileOutput) IgnoreWarnings() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.BoolPtrOutput { return v.IgnoreWarnings }).(pulumi.BoolPtrOutput)
}

// The name of the instance to create the app profile within.
func (o AppProfileOutput) Instance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringPtrOutput { return v.Instance }).(pulumi.StringPtrOutput)
}

// The set of clusters to route to. The order is ignored; clusters will be tried in order of distance. If left empty, all clusters are eligible.
func (o AppProfileOutput) MultiClusterRoutingClusterIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringArrayOutput { return v.MultiClusterRoutingClusterIds }).(pulumi.StringArrayOutput)
}

// If true, read/write requests are routed to the nearest cluster in the instance, and will fail over to the nearest cluster that is available
// in the event of transient errors or delays. Clusters in a region are considered equidistant. Choosing this option sacrifices read-your-writes
// consistency to improve availability.
func (o AppProfileOutput) MultiClusterRoutingUseAny() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.BoolPtrOutput { return v.MultiClusterRoutingUseAny }).(pulumi.BoolPtrOutput)
}

// The unique name of the requested app profile. Values are of the form `projects/<project>/instances/<instance>/appProfiles/<appProfileId>`.
func (o AppProfileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o AppProfileOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Must be used with multi-cluster routing. If true, then this app profile will use row affinity sticky routing. With row affinity, Bigtable will route single row key requests based on the row key, rather than randomly. Instead, each row key will be assigned to a cluster by Cloud Bigtable, and will stick to that cluster. Choosing this option improves read-your-writes consistency for most requests under most circumstances, without sacrificing availability. Consistency is not guaranteed, as requests may still fail over between clusters in the event of errors or latency.
func (o AppProfileOutput) RowAffinity() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AppProfile) pulumi.BoolPtrOutput { return v.RowAffinity }).(pulumi.BoolPtrOutput)
}

// Use a single-cluster routing policy.
// Structure is documented below.
func (o AppProfileOutput) SingleClusterRouting() AppProfileSingleClusterRoutingPtrOutput {
	return o.ApplyT(func(v *AppProfile) AppProfileSingleClusterRoutingPtrOutput { return v.SingleClusterRouting }).(AppProfileSingleClusterRoutingPtrOutput)
}

// The standard options used for isolating this app profile's traffic from other use cases.
// Structure is documented below.
func (o AppProfileOutput) StandardIsolation() AppProfileStandardIsolationOutput {
	return o.ApplyT(func(v *AppProfile) AppProfileStandardIsolationOutput { return v.StandardIsolation }).(AppProfileStandardIsolationOutput)
}

type AppProfileArrayOutput struct{ *pulumi.OutputState }

func (AppProfileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppProfile)(nil)).Elem()
}

func (o AppProfileArrayOutput) ToAppProfileArrayOutput() AppProfileArrayOutput {
	return o
}

func (o AppProfileArrayOutput) ToAppProfileArrayOutputWithContext(ctx context.Context) AppProfileArrayOutput {
	return o
}

func (o AppProfileArrayOutput) Index(i pulumi.IntInput) AppProfileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AppProfile {
		return vs[0].([]*AppProfile)[vs[1].(int)]
	}).(AppProfileOutput)
}

type AppProfileMapOutput struct{ *pulumi.OutputState }

func (AppProfileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppProfile)(nil)).Elem()
}

func (o AppProfileMapOutput) ToAppProfileMapOutput() AppProfileMapOutput {
	return o
}

func (o AppProfileMapOutput) ToAppProfileMapOutputWithContext(ctx context.Context) AppProfileMapOutput {
	return o
}

func (o AppProfileMapOutput) MapIndex(k pulumi.StringInput) AppProfileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AppProfile {
		return vs[0].(map[string]*AppProfile)[vs[1].(string)]
	}).(AppProfileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AppProfileInput)(nil)).Elem(), &AppProfile{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppProfileArrayInput)(nil)).Elem(), AppProfileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppProfileMapInput)(nil)).Elem(), AppProfileMap{})
	pulumi.RegisterOutputType(AppProfileOutput{})
	pulumi.RegisterOutputType(AppProfileArrayOutput{})
	pulumi.RegisterOutputType(AppProfileMapOutput{})
}
