// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bigtable

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a Google Cloud Bigtable authorized view inside a table. For more information see
// [the official documentation](https://cloud.google.com/bigtable/) and
// [API](https://cloud.google.com/bigtable/docs/go/reference).
//
// > **Note:** It is strongly recommended to set `lifecycle { preventDestroy = true }`
// on authorized views in order to prevent accidental data loss. See
// Terraform docs
// for more information on lifecycle parameters.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/bigtable"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := bigtable.NewInstance(ctx, "instance", &bigtable.InstanceArgs{
//				Name: pulumi.String("tf-instance"),
//				Clusters: bigtable.InstanceClusterArray{
//					&bigtable.InstanceClusterArgs{
//						ClusterId:   pulumi.String("tf-instance-cluster"),
//						Zone:        pulumi.String("us-central1-b"),
//						NumNodes:    pulumi.Int(3),
//						StorageType: pulumi.String("HDD"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			table, err := bigtable.NewTable(ctx, "table", &bigtable.TableArgs{
//				Name:         pulumi.String("tf-table"),
//				InstanceName: instance.Name,
//				SplitKeys: pulumi.StringArray{
//					pulumi.String("a"),
//					pulumi.String("b"),
//					pulumi.String("c"),
//				},
//				ColumnFamilies: bigtable.TableColumnFamilyArray{
//					&bigtable.TableColumnFamilyArgs{
//						Family: pulumi.String("family-first"),
//					},
//					&bigtable.TableColumnFamilyArgs{
//						Family: pulumi.String("family-second"),
//					},
//				},
//				ChangeStreamRetention: pulumi.String("24h0m0s"),
//			})
//			if err != nil {
//				return err
//			}
//			invokeBase64encode, err := std.Base64encode(ctx, &std.Base64encodeArgs{
//				Input: "prefix#",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			invokeBase64encode1, err := std.Base64encode(ctx, &std.Base64encodeArgs{
//				Input: "qualifier",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			invokeBase64encode2, err := std.Base64encode(ctx, &std.Base64encodeArgs{
//				Input: "qualifier-second",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = bigtable.NewAuthorizedView(ctx, "authorized_view", &bigtable.AuthorizedViewArgs{
//				Name:         pulumi.String("tf-authorized-view"),
//				InstanceName: instance.Name,
//				TableName:    table.Name,
//				SubsetView: &bigtable.AuthorizedViewSubsetViewArgs{
//					RowPrefixes: pulumi.StringArray{
//						pulumi.String(invokeBase64encode.Result),
//					},
//					FamilySubsets: bigtable.AuthorizedViewSubsetViewFamilySubsetArray{
//						&bigtable.AuthorizedViewSubsetViewFamilySubsetArgs{
//							FamilyName: pulumi.String("family-first"),
//							Qualifiers: pulumi.StringArray{
//								pulumi.String(invokeBase64encode1.Result),
//								pulumi.String(invokeBase64encode2.Result),
//							},
//						},
//						&bigtable.AuthorizedViewSubsetViewFamilySubsetArgs{
//							FamilyName: pulumi.String("family-second"),
//							QualifierPrefixes: pulumi.StringArray{
//								pulumi.String(""),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Bigtable Authorized Views can be imported using any of these accepted formats:
//
// * `projects/{{project}}/instances/{{instance_name}}/tables/{{table_name}}/authorizedViews/{{name}}`
// * `{{project}}/{{instance_name}}/{{table_name}}/{{name}}`
// * `{{instance_name}}/{{table_name}}/{{name}}`
//
// When using the `pulumi import` command, Bigtable Authorized Views can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:bigtable/authorizedView:AuthorizedView default projects/{{project}}/instances/{{instance_name}}/tables/{{table_name}}/authorizedViews/{{name}}
// $ pulumi import gcp:bigtable/authorizedView:AuthorizedView default {{project}}/{{instance_name}}/{{table_name}}/{{name}}
// $ pulumi import gcp:bigtable/authorizedView:AuthorizedView default {{instance_name}}/{{table_name}}/{{name}}
// ```
type AuthorizedView struct {
	pulumi.CustomResourceState

	// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
	// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
	DeletionProtection pulumi.StringOutput `pulumi:"deletionProtection"`
	// The name of the Bigtable instance in which the authorized view belongs.
	InstanceName pulumi.StringOutput `pulumi:"instanceName"`
	// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
	//
	// ***
	SubsetView AuthorizedViewSubsetViewPtrOutput `pulumi:"subsetView"`
	// The name of the Bigtable table in which the authorized view belongs.
	TableName pulumi.StringOutput `pulumi:"tableName"`
}

// NewAuthorizedView registers a new resource with the given unique name, arguments, and options.
func NewAuthorizedView(ctx *pulumi.Context,
	name string, args *AuthorizedViewArgs, opts ...pulumi.ResourceOption) (*AuthorizedView, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceName == nil {
		return nil, errors.New("invalid value for required argument 'InstanceName'")
	}
	if args.TableName == nil {
		return nil, errors.New("invalid value for required argument 'TableName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AuthorizedView
	err := ctx.RegisterResource("gcp:bigtable/authorizedView:AuthorizedView", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAuthorizedView gets an existing AuthorizedView resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAuthorizedView(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AuthorizedViewState, opts ...pulumi.ResourceOption) (*AuthorizedView, error) {
	var resource AuthorizedView
	err := ctx.ReadResource("gcp:bigtable/authorizedView:AuthorizedView", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AuthorizedView resources.
type authorizedViewState struct {
	// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
	// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
	DeletionProtection *string `pulumi:"deletionProtection"`
	// The name of the Bigtable instance in which the authorized view belongs.
	InstanceName *string `pulumi:"instanceName"`
	// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
	//
	// ***
	SubsetView *AuthorizedViewSubsetView `pulumi:"subsetView"`
	// The name of the Bigtable table in which the authorized view belongs.
	TableName *string `pulumi:"tableName"`
}

type AuthorizedViewState struct {
	// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
	// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
	DeletionProtection pulumi.StringPtrInput
	// The name of the Bigtable instance in which the authorized view belongs.
	InstanceName pulumi.StringPtrInput
	// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
	//
	// ***
	SubsetView AuthorizedViewSubsetViewPtrInput
	// The name of the Bigtable table in which the authorized view belongs.
	TableName pulumi.StringPtrInput
}

func (AuthorizedViewState) ElementType() reflect.Type {
	return reflect.TypeOf((*authorizedViewState)(nil)).Elem()
}

type authorizedViewArgs struct {
	// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
	// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
	DeletionProtection *string `pulumi:"deletionProtection"`
	// The name of the Bigtable instance in which the authorized view belongs.
	InstanceName string `pulumi:"instanceName"`
	// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
	//
	// ***
	SubsetView *AuthorizedViewSubsetView `pulumi:"subsetView"`
	// The name of the Bigtable table in which the authorized view belongs.
	TableName string `pulumi:"tableName"`
}

// The set of arguments for constructing a AuthorizedView resource.
type AuthorizedViewArgs struct {
	// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
	// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
	DeletionProtection pulumi.StringPtrInput
	// The name of the Bigtable instance in which the authorized view belongs.
	InstanceName pulumi.StringInput
	// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
	//
	// ***
	SubsetView AuthorizedViewSubsetViewPtrInput
	// The name of the Bigtable table in which the authorized view belongs.
	TableName pulumi.StringInput
}

func (AuthorizedViewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*authorizedViewArgs)(nil)).Elem()
}

type AuthorizedViewInput interface {
	pulumi.Input

	ToAuthorizedViewOutput() AuthorizedViewOutput
	ToAuthorizedViewOutputWithContext(ctx context.Context) AuthorizedViewOutput
}

func (*AuthorizedView) ElementType() reflect.Type {
	return reflect.TypeOf((**AuthorizedView)(nil)).Elem()
}

func (i *AuthorizedView) ToAuthorizedViewOutput() AuthorizedViewOutput {
	return i.ToAuthorizedViewOutputWithContext(context.Background())
}

func (i *AuthorizedView) ToAuthorizedViewOutputWithContext(ctx context.Context) AuthorizedViewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorizedViewOutput)
}

// AuthorizedViewArrayInput is an input type that accepts AuthorizedViewArray and AuthorizedViewArrayOutput values.
// You can construct a concrete instance of `AuthorizedViewArrayInput` via:
//
//	AuthorizedViewArray{ AuthorizedViewArgs{...} }
type AuthorizedViewArrayInput interface {
	pulumi.Input

	ToAuthorizedViewArrayOutput() AuthorizedViewArrayOutput
	ToAuthorizedViewArrayOutputWithContext(context.Context) AuthorizedViewArrayOutput
}

type AuthorizedViewArray []AuthorizedViewInput

func (AuthorizedViewArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AuthorizedView)(nil)).Elem()
}

func (i AuthorizedViewArray) ToAuthorizedViewArrayOutput() AuthorizedViewArrayOutput {
	return i.ToAuthorizedViewArrayOutputWithContext(context.Background())
}

func (i AuthorizedViewArray) ToAuthorizedViewArrayOutputWithContext(ctx context.Context) AuthorizedViewArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorizedViewArrayOutput)
}

// AuthorizedViewMapInput is an input type that accepts AuthorizedViewMap and AuthorizedViewMapOutput values.
// You can construct a concrete instance of `AuthorizedViewMapInput` via:
//
//	AuthorizedViewMap{ "key": AuthorizedViewArgs{...} }
type AuthorizedViewMapInput interface {
	pulumi.Input

	ToAuthorizedViewMapOutput() AuthorizedViewMapOutput
	ToAuthorizedViewMapOutputWithContext(context.Context) AuthorizedViewMapOutput
}

type AuthorizedViewMap map[string]AuthorizedViewInput

func (AuthorizedViewMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AuthorizedView)(nil)).Elem()
}

func (i AuthorizedViewMap) ToAuthorizedViewMapOutput() AuthorizedViewMapOutput {
	return i.ToAuthorizedViewMapOutputWithContext(context.Background())
}

func (i AuthorizedViewMap) ToAuthorizedViewMapOutputWithContext(ctx context.Context) AuthorizedViewMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorizedViewMapOutput)
}

type AuthorizedViewOutput struct{ *pulumi.OutputState }

func (AuthorizedViewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AuthorizedView)(nil)).Elem()
}

func (o AuthorizedViewOutput) ToAuthorizedViewOutput() AuthorizedViewOutput {
	return o
}

func (o AuthorizedViewOutput) ToAuthorizedViewOutputWithContext(ctx context.Context) AuthorizedViewOutput {
	return o
}

// A field to make the table protected against data loss i.e. when set to PROTECTED, deleting the table, the column families in the table, and the instance containing the table would be prohibited.
// If not provided, currently deletion protection will be set to UNPROTECTED as it is the API default value. Note this field configs the deletion protection provided by the API in the backend, and should not be confused with Terraform-side deletion protection.
func (o AuthorizedViewOutput) DeletionProtection() pulumi.StringOutput {
	return o.ApplyT(func(v *AuthorizedView) pulumi.StringOutput { return v.DeletionProtection }).(pulumi.StringOutput)
}

// The name of the Bigtable instance in which the authorized view belongs.
func (o AuthorizedViewOutput) InstanceName() pulumi.StringOutput {
	return o.ApplyT(func(v *AuthorizedView) pulumi.StringOutput { return v.InstanceName }).(pulumi.StringOutput)
}

// The name of the authorized view. Must be 1-50 characters and must only contain hyphens, underscores, periods, letters and numbers.
func (o AuthorizedViewOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AuthorizedView) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs. If it
// is not provided, the provider project is used.
func (o AuthorizedViewOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *AuthorizedView) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// An AuthorizedView permitting access to an explicit subset of a Table. Structure is documented below.
//
// ***
func (o AuthorizedViewOutput) SubsetView() AuthorizedViewSubsetViewPtrOutput {
	return o.ApplyT(func(v *AuthorizedView) AuthorizedViewSubsetViewPtrOutput { return v.SubsetView }).(AuthorizedViewSubsetViewPtrOutput)
}

// The name of the Bigtable table in which the authorized view belongs.
func (o AuthorizedViewOutput) TableName() pulumi.StringOutput {
	return o.ApplyT(func(v *AuthorizedView) pulumi.StringOutput { return v.TableName }).(pulumi.StringOutput)
}

type AuthorizedViewArrayOutput struct{ *pulumi.OutputState }

func (AuthorizedViewArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AuthorizedView)(nil)).Elem()
}

func (o AuthorizedViewArrayOutput) ToAuthorizedViewArrayOutput() AuthorizedViewArrayOutput {
	return o
}

func (o AuthorizedViewArrayOutput) ToAuthorizedViewArrayOutputWithContext(ctx context.Context) AuthorizedViewArrayOutput {
	return o
}

func (o AuthorizedViewArrayOutput) Index(i pulumi.IntInput) AuthorizedViewOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AuthorizedView {
		return vs[0].([]*AuthorizedView)[vs[1].(int)]
	}).(AuthorizedViewOutput)
}

type AuthorizedViewMapOutput struct{ *pulumi.OutputState }

func (AuthorizedViewMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AuthorizedView)(nil)).Elem()
}

func (o AuthorizedViewMapOutput) ToAuthorizedViewMapOutput() AuthorizedViewMapOutput {
	return o
}

func (o AuthorizedViewMapOutput) ToAuthorizedViewMapOutputWithContext(ctx context.Context) AuthorizedViewMapOutput {
	return o
}

func (o AuthorizedViewMapOutput) MapIndex(k pulumi.StringInput) AuthorizedViewOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AuthorizedView {
		return vs[0].(map[string]*AuthorizedView)[vs[1].(string)]
	}).(AuthorizedViewOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AuthorizedViewInput)(nil)).Elem(), &AuthorizedView{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuthorizedViewArrayInput)(nil)).Elem(), AuthorizedViewArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuthorizedViewMapInput)(nil)).Elem(), AuthorizedViewMap{})
	pulumi.RegisterOutputType(AuthorizedViewOutput{})
	pulumi.RegisterOutputType(AuthorizedViewArrayOutput{})
	pulumi.RegisterOutputType(AuthorizedViewMapOutput{})
}
