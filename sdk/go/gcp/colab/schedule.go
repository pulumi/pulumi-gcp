// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package colab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// 'Colab Enterprise Notebook Execution Schedules.'
//
// To get more information about Schedule, see:
//
// * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.schedules)
// * How-to Guides
//   - [Schedule a notebook run](https://cloud.google.com/colab/docs/schedule-notebook-run)
//
// ## Example Usage
//
// ### Colab Schedule Basic
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/colab"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myRuntimeTemplate, err := colab.NewRuntimeTemplate(ctx, "my_runtime_template", &colab.RuntimeTemplateArgs{
//				Name:        pulumi.String("runtime-template"),
//				DisplayName: pulumi.String("Runtime template"),
//				Location:    pulumi.String("us-central1"),
//				MachineSpec: &colab.RuntimeTemplateMachineSpecArgs{
//					MachineType: pulumi.String("e2-standard-4"),
//				},
//				NetworkSpec: &colab.RuntimeTemplateNetworkSpecArgs{
//					EnableInternetAccess: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			outputBucket, err := storage.NewBucket(ctx, "output_bucket", &storage.BucketArgs{
//				Name:                     pulumi.String("my_bucket"),
//				Location:                 pulumi.String("US"),
//				ForceDestroy:             pulumi.Bool(true),
//				UniformBucketLevelAccess: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			notebook, err := storage.NewBucketObject(ctx, "notebook", &storage.BucketObjectArgs{
//				Name:   pulumi.String("hello_world.ipynb"),
//				Bucket: outputBucket.Name,
//				Content: pulumi.String(`    {
//	      "cells": [
//	        {
//	          "cell_type": "code",
//	          "execution_count": null,
//	          "metadata": {},
//	          "outputs": [],
//	          "source": [
//	            "print(\"Hello, World!\")"
//	          ]
//	        }
//	      ],
//	      "metadata": {
//	        "kernelspec": {
//	          "display_name": "Python 3",
//	          "language": "python",
//	          "name": "python3"
//	        },
//	        "language_info": {
//	          "codemirror_mode": {
//	            "name": "ipython",
//	            "version": 3
//	          },
//	          "file_extension": ".py",
//	          "mimetype": "text/x-python",
//	          "name": "python",
//	          "nbconvert_exporter": "python",
//	          "pygments_lexer": "ipython3",
//	          "version": "3.8.5"
//	        }
//	      },
//	      "nbformat": 4,
//	      "nbformat_minor": 4
//	    }
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			_, err = colab.NewSchedule(ctx, "schedule", &colab.ScheduleArgs{
//				DisplayName:           pulumi.String("basic-schedule"),
//				Location:              pulumi.String("us-west1"),
//				MaxConcurrentRunCount: pulumi.String("2"),
//				Cron:                  pulumi.String("TZ=America/Los_Angeles * * * * *"),
//				CreateNotebookExecutionJobRequest: &colab.ScheduleCreateNotebookExecutionJobRequestArgs{
//					NotebookExecutionJob: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs{
//						DisplayName: pulumi.String("Notebook execution"),
//						GcsNotebookSource: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs{
//							Uri: pulumi.All(notebook.Bucket, notebook.Name).ApplyT(func(_args []interface{}) (string, error) {
//								bucket := _args[0].(string)
//								name := _args[1].(string)
//								return fmt.Sprintf("gs://%v/%v", bucket, name), nil
//							}).(pulumi.StringOutput),
//							Generation: notebook.Generation,
//						},
//						NotebookRuntimeTemplateResourceName: pulumi.All(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).ApplyT(func(_args []interface{}) (string, error) {
//							project := _args[0].(string)
//							location := _args[1].(string)
//							name := _args[2].(string)
//							return fmt.Sprintf("projects/%v/locations/%v/notebookRuntimeTemplates/%v", project, location, name), nil
//						}).(pulumi.StringOutput),
//						GcsOutputUri: outputBucket.Name.ApplyT(func(name string) (string, error) {
//							return fmt.Sprintf("gs://%v", name), nil
//						}).(pulumi.StringOutput),
//						ServiceAccount: pulumi.String("my@service-account.com"),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				myRuntimeTemplate,
//				outputBucket,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Colab Schedule Paused
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/colab"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myRuntimeTemplate, err := colab.NewRuntimeTemplate(ctx, "my_runtime_template", &colab.RuntimeTemplateArgs{
//				Name:        pulumi.String("runtime-template"),
//				DisplayName: pulumi.String("Runtime template"),
//				Location:    pulumi.String("us-central1"),
//				MachineSpec: &colab.RuntimeTemplateMachineSpecArgs{
//					MachineType: pulumi.String("e2-standard-4"),
//				},
//				NetworkSpec: &colab.RuntimeTemplateNetworkSpecArgs{
//					EnableInternetAccess: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			outputBucket, err := storage.NewBucket(ctx, "output_bucket", &storage.BucketArgs{
//				Name:                     pulumi.String("my_bucket"),
//				Location:                 pulumi.String("US"),
//				ForceDestroy:             pulumi.Bool(true),
//				UniformBucketLevelAccess: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			notebook, err := storage.NewBucketObject(ctx, "notebook", &storage.BucketObjectArgs{
//				Name:   pulumi.String("hello_world.ipynb"),
//				Bucket: outputBucket.Name,
//				Content: pulumi.String(`    {
//	      "cells": [
//	        {
//	          "cell_type": "code",
//	          "execution_count": null,
//	          "metadata": {},
//	          "outputs": [],
//	          "source": [
//	            "print(\"Hello, World!\")"
//	          ]
//	        }
//	      ],
//	      "metadata": {
//	        "kernelspec": {
//	          "display_name": "Python 3",
//	          "language": "python",
//	          "name": "python3"
//	        },
//	        "language_info": {
//	          "codemirror_mode": {
//	            "name": "ipython",
//	            "version": 3
//	          },
//	          "file_extension": ".py",
//	          "mimetype": "text/x-python",
//	          "name": "python",
//	          "nbconvert_exporter": "python",
//	          "pygments_lexer": "ipython3",
//	          "version": "3.8.5"
//	        }
//	      },
//	      "nbformat": 4,
//	      "nbformat_minor": 4
//	    }
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			_, err = colab.NewSchedule(ctx, "schedule", &colab.ScheduleArgs{
//				DisplayName:           pulumi.String("paused-schedule"),
//				Location:              pulumi.String("us-west1"),
//				MaxConcurrentRunCount: pulumi.String("2"),
//				Cron:                  pulumi.String("TZ=America/Los_Angeles * * * * *"),
//				DesiredState:          pulumi.String("PAUSED"),
//				CreateNotebookExecutionJobRequest: &colab.ScheduleCreateNotebookExecutionJobRequestArgs{
//					NotebookExecutionJob: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs{
//						DisplayName: pulumi.String("Notebook execution"),
//						GcsNotebookSource: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceArgs{
//							Uri: pulumi.All(notebook.Bucket, notebook.Name).ApplyT(func(_args []interface{}) (string, error) {
//								bucket := _args[0].(string)
//								name := _args[1].(string)
//								return fmt.Sprintf("gs://%v/%v", bucket, name), nil
//							}).(pulumi.StringOutput),
//							Generation: notebook.Generation,
//						},
//						NotebookRuntimeTemplateResourceName: pulumi.All(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).ApplyT(func(_args []interface{}) (string, error) {
//							project := _args[0].(string)
//							location := _args[1].(string)
//							name := _args[2].(string)
//							return fmt.Sprintf("projects/%v/locations/%v/notebookRuntimeTemplates/%v", project, location, name), nil
//						}).(pulumi.StringOutput),
//						GcsOutputUri: outputBucket.Name.ApplyT(func(name string) (string, error) {
//							return fmt.Sprintf("gs://%v", name), nil
//						}).(pulumi.StringOutput),
//						ServiceAccount: pulumi.String("my@service-account.com"),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				myRuntimeTemplate,
//				outputBucket,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Colab Schedule Full
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/colab"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataform"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myRuntimeTemplate, err := colab.NewRuntimeTemplate(ctx, "my_runtime_template", &colab.RuntimeTemplateArgs{
//				Name:        pulumi.String("runtime-template"),
//				DisplayName: pulumi.String("Runtime template"),
//				Location:    pulumi.String("us-central1"),
//				MachineSpec: &colab.RuntimeTemplateMachineSpecArgs{
//					MachineType: pulumi.String("e2-standard-4"),
//				},
//				NetworkSpec: &colab.RuntimeTemplateNetworkSpecArgs{
//					EnableInternetAccess: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			outputBucket, err := storage.NewBucket(ctx, "output_bucket", &storage.BucketArgs{
//				Name:                     pulumi.String("my_bucket"),
//				Location:                 pulumi.String("US"),
//				ForceDestroy:             pulumi.Bool(true),
//				UniformBucketLevelAccess: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			secret, err := secretmanager.NewSecret(ctx, "secret", &secretmanager.SecretArgs{
//				SecretId: pulumi.String("secret"),
//				Replication: &secretmanager.SecretReplicationArgs{
//					Auto: &secretmanager.SecretReplicationAutoArgs{},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			secretVersion, err := secretmanager.NewSecretVersion(ctx, "secret_version", &secretmanager.SecretVersionArgs{
//				Secret:     secret.ID(),
//				SecretData: pulumi.String("secret-data"),
//			})
//			if err != nil {
//				return err
//			}
//			dataformRepository, err := dataform.NewRepository(ctx, "dataform_repository", &dataform.RepositoryArgs{
//				Name:                                   pulumi.String("dataform-repository"),
//				DisplayName:                            pulumi.String("dataform_repository"),
//				NpmrcEnvironmentVariablesSecretVersion: secretVersion.ID(),
//				KmsKeyName:                             pulumi.String("my-key"),
//				Labels: pulumi.StringMap{
//					"label_foo1": pulumi.String("label-bar1"),
//				},
//				GitRemoteSettings: &dataform.RepositoryGitRemoteSettingsArgs{
//					Url:                              pulumi.String("https://github.com/OWNER/REPOSITORY.git"),
//					DefaultBranch:                    pulumi.String("main"),
//					AuthenticationTokenSecretVersion: secretVersion.ID(),
//				},
//				WorkspaceCompilationOverrides: &dataform.RepositoryWorkspaceCompilationOverridesArgs{
//					DefaultDatabase: pulumi.String("database"),
//					SchemaSuffix:    pulumi.String("_suffix"),
//					TablePrefix:     pulumi.String("prefix_"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = colab.NewSchedule(ctx, "schedule", &colab.ScheduleArgs{
//				DisplayName:           pulumi.String("full-schedule"),
//				Location:              pulumi.String("us-west1"),
//				AllowQueueing:         pulumi.Bool(true),
//				MaxConcurrentRunCount: pulumi.String("2"),
//				Cron:                  pulumi.String("TZ=America/Los_Angeles * * * * *"),
//				MaxRunCount:           pulumi.String("5"),
//				StartTime:             pulumi.String("2014-10-02T15:01:23Z"),
//				EndTime:               pulumi.String("2014-10-10T15:01:23Z"),
//				DesiredState:          pulumi.String("ACTIVE"),
//				CreateNotebookExecutionJobRequest: &colab.ScheduleCreateNotebookExecutionJobRequestArgs{
//					NotebookExecutionJob: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobArgs{
//						DisplayName:      pulumi.String("Notebook execution"),
//						ExecutionTimeout: pulumi.String("86400s"),
//						DataformRepositorySource: &colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceArgs{
//							CommitSha: pulumi.String("randomsha123"),
//							DataformRepositoryResourceName: dataformRepository.Name.ApplyT(func(name string) (string, error) {
//								return fmt.Sprintf("projects/my-project-name/locations/us-west1/repositories/%v", name), nil
//							}).(pulumi.StringOutput),
//						},
//						NotebookRuntimeTemplateResourceName: pulumi.All(myRuntimeTemplate.Project, myRuntimeTemplate.Location, myRuntimeTemplate.Name).ApplyT(func(_args []interface{}) (string, error) {
//							project := _args[0].(string)
//							location := _args[1].(string)
//							name := _args[2].(string)
//							return fmt.Sprintf("projects/%v/locations/%v/notebookRuntimeTemplates/%v", project, location, name), nil
//						}).(pulumi.StringOutput),
//						GcsOutputUri: outputBucket.Name.ApplyT(func(name string) (string, error) {
//							return fmt.Sprintf("gs://%v", name), nil
//						}).(pulumi.StringOutput),
//						ServiceAccount: pulumi.String("my@service-account.com"),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				myRuntimeTemplate,
//				outputBucket,
//				secretVersion,
//				dataformRepository,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Schedule can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/schedules/{{name}}`
//
// * `{{project}}/{{location}}/{{name}}`
//
// * `{{location}}/{{name}}`
//
// When using the `pulumi import` command, Schedule can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:colab/schedule:Schedule default projects/{{project}}/locations/{{location}}/schedules/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:colab/schedule:Schedule default {{project}}/{{location}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:colab/schedule:Schedule default {{location}}/{{name}}
// ```
type Schedule struct {
	pulumi.CustomResourceState

	// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
	// queued instead of skipped. Default to false.
	AllowQueueing pulumi.BoolPtrOutput `pulumi:"allowQueueing"`
	// Request for google_colab_notebook_execution.
	// Structure is documented below.
	CreateNotebookExecutionJobRequest ScheduleCreateNotebookExecutionJobRequestOutput `pulumi:"createNotebookExecutionJobRequest"`
	// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
	Cron pulumi.StringOutput `pulumi:"cron"`
	// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
	// schedule.
	DesiredState pulumi.StringPtrOutput `pulumi:"desiredState"`
	// Required. The display name of the Schedule.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
	// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
	// format.
	EndTime pulumi.StringPtrOutput `pulumi:"endTime"`
	// The location for the resource: https://cloud.google.com/colab/docs/locations
	Location pulumi.StringOutput `pulumi:"location"`
	// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
	MaxConcurrentRunCount pulumi.StringOutput `pulumi:"maxConcurrentRunCount"`
	// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
	// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
	// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
	MaxRunCount pulumi.StringPtrOutput `pulumi:"maxRunCount"`
	// The resource name of the Schedule
	Name    pulumi.StringOutput `pulumi:"name"`
	Project pulumi.StringOutput `pulumi:"project"`
	// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
	// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
	StartTime pulumi.StringOutput `pulumi:"startTime"`
	// Output only. The state of the schedule.
	State pulumi.StringOutput `pulumi:"state"`
}

// NewSchedule registers a new resource with the given unique name, arguments, and options.
func NewSchedule(ctx *pulumi.Context,
	name string, args *ScheduleArgs, opts ...pulumi.ResourceOption) (*Schedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CreateNotebookExecutionJobRequest == nil {
		return nil, errors.New("invalid value for required argument 'CreateNotebookExecutionJobRequest'")
	}
	if args.Cron == nil {
		return nil, errors.New("invalid value for required argument 'Cron'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.MaxConcurrentRunCount == nil {
		return nil, errors.New("invalid value for required argument 'MaxConcurrentRunCount'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Schedule
	err := ctx.RegisterResource("gcp:colab/schedule:Schedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSchedule gets an existing Schedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScheduleState, opts ...pulumi.ResourceOption) (*Schedule, error) {
	var resource Schedule
	err := ctx.ReadResource("gcp:colab/schedule:Schedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Schedule resources.
type scheduleState struct {
	// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
	// queued instead of skipped. Default to false.
	AllowQueueing *bool `pulumi:"allowQueueing"`
	// Request for google_colab_notebook_execution.
	// Structure is documented below.
	CreateNotebookExecutionJobRequest *ScheduleCreateNotebookExecutionJobRequest `pulumi:"createNotebookExecutionJobRequest"`
	// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
	Cron *string `pulumi:"cron"`
	// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
	// schedule.
	DesiredState *string `pulumi:"desiredState"`
	// Required. The display name of the Schedule.
	DisplayName *string `pulumi:"displayName"`
	// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
	// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
	// format.
	EndTime *string `pulumi:"endTime"`
	// The location for the resource: https://cloud.google.com/colab/docs/locations
	Location *string `pulumi:"location"`
	// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
	MaxConcurrentRunCount *string `pulumi:"maxConcurrentRunCount"`
	// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
	// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
	// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
	MaxRunCount *string `pulumi:"maxRunCount"`
	// The resource name of the Schedule
	Name    *string `pulumi:"name"`
	Project *string `pulumi:"project"`
	// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
	// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
	StartTime *string `pulumi:"startTime"`
	// Output only. The state of the schedule.
	State *string `pulumi:"state"`
}

type ScheduleState struct {
	// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
	// queued instead of skipped. Default to false.
	AllowQueueing pulumi.BoolPtrInput
	// Request for google_colab_notebook_execution.
	// Structure is documented below.
	CreateNotebookExecutionJobRequest ScheduleCreateNotebookExecutionJobRequestPtrInput
	// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
	Cron pulumi.StringPtrInput
	// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
	// schedule.
	DesiredState pulumi.StringPtrInput
	// Required. The display name of the Schedule.
	DisplayName pulumi.StringPtrInput
	// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
	// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
	// format.
	EndTime pulumi.StringPtrInput
	// The location for the resource: https://cloud.google.com/colab/docs/locations
	Location pulumi.StringPtrInput
	// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
	MaxConcurrentRunCount pulumi.StringPtrInput
	// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
	// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
	// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
	MaxRunCount pulumi.StringPtrInput
	// The resource name of the Schedule
	Name    pulumi.StringPtrInput
	Project pulumi.StringPtrInput
	// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
	// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
	StartTime pulumi.StringPtrInput
	// Output only. The state of the schedule.
	State pulumi.StringPtrInput
}

func (ScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduleState)(nil)).Elem()
}

type scheduleArgs struct {
	// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
	// queued instead of skipped. Default to false.
	AllowQueueing *bool `pulumi:"allowQueueing"`
	// Request for google_colab_notebook_execution.
	// Structure is documented below.
	CreateNotebookExecutionJobRequest ScheduleCreateNotebookExecutionJobRequest `pulumi:"createNotebookExecutionJobRequest"`
	// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
	Cron string `pulumi:"cron"`
	// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
	// schedule.
	DesiredState *string `pulumi:"desiredState"`
	// Required. The display name of the Schedule.
	DisplayName string `pulumi:"displayName"`
	// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
	// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
	// format.
	EndTime *string `pulumi:"endTime"`
	// The location for the resource: https://cloud.google.com/colab/docs/locations
	Location string `pulumi:"location"`
	// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
	MaxConcurrentRunCount string `pulumi:"maxConcurrentRunCount"`
	// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
	// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
	// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
	MaxRunCount *string `pulumi:"maxRunCount"`
	Project     *string `pulumi:"project"`
	// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
	// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
	StartTime *string `pulumi:"startTime"`
}

// The set of arguments for constructing a Schedule resource.
type ScheduleArgs struct {
	// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
	// queued instead of skipped. Default to false.
	AllowQueueing pulumi.BoolPtrInput
	// Request for google_colab_notebook_execution.
	// Structure is documented below.
	CreateNotebookExecutionJobRequest ScheduleCreateNotebookExecutionJobRequestInput
	// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
	Cron pulumi.StringInput
	// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
	// schedule.
	DesiredState pulumi.StringPtrInput
	// Required. The display name of the Schedule.
	DisplayName pulumi.StringInput
	// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
	// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
	// format.
	EndTime pulumi.StringPtrInput
	// The location for the resource: https://cloud.google.com/colab/docs/locations
	Location pulumi.StringInput
	// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
	MaxConcurrentRunCount pulumi.StringInput
	// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
	// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
	// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
	MaxRunCount pulumi.StringPtrInput
	Project     pulumi.StringPtrInput
	// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
	// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
	StartTime pulumi.StringPtrInput
}

func (ScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduleArgs)(nil)).Elem()
}

type ScheduleInput interface {
	pulumi.Input

	ToScheduleOutput() ScheduleOutput
	ToScheduleOutputWithContext(ctx context.Context) ScheduleOutput
}

func (*Schedule) ElementType() reflect.Type {
	return reflect.TypeOf((**Schedule)(nil)).Elem()
}

func (i *Schedule) ToScheduleOutput() ScheduleOutput {
	return i.ToScheduleOutputWithContext(context.Background())
}

func (i *Schedule) ToScheduleOutputWithContext(ctx context.Context) ScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleOutput)
}

// ScheduleArrayInput is an input type that accepts ScheduleArray and ScheduleArrayOutput values.
// You can construct a concrete instance of `ScheduleArrayInput` via:
//
//	ScheduleArray{ ScheduleArgs{...} }
type ScheduleArrayInput interface {
	pulumi.Input

	ToScheduleArrayOutput() ScheduleArrayOutput
	ToScheduleArrayOutputWithContext(context.Context) ScheduleArrayOutput
}

type ScheduleArray []ScheduleInput

func (ScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Schedule)(nil)).Elem()
}

func (i ScheduleArray) ToScheduleArrayOutput() ScheduleArrayOutput {
	return i.ToScheduleArrayOutputWithContext(context.Background())
}

func (i ScheduleArray) ToScheduleArrayOutputWithContext(ctx context.Context) ScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleArrayOutput)
}

// ScheduleMapInput is an input type that accepts ScheduleMap and ScheduleMapOutput values.
// You can construct a concrete instance of `ScheduleMapInput` via:
//
//	ScheduleMap{ "key": ScheduleArgs{...} }
type ScheduleMapInput interface {
	pulumi.Input

	ToScheduleMapOutput() ScheduleMapOutput
	ToScheduleMapOutputWithContext(context.Context) ScheduleMapOutput
}

type ScheduleMap map[string]ScheduleInput

func (ScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Schedule)(nil)).Elem()
}

func (i ScheduleMap) ToScheduleMapOutput() ScheduleMapOutput {
	return i.ToScheduleMapOutputWithContext(context.Background())
}

func (i ScheduleMap) ToScheduleMapOutputWithContext(ctx context.Context) ScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleMapOutput)
}

type ScheduleOutput struct{ *pulumi.OutputState }

func (ScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Schedule)(nil)).Elem()
}

func (o ScheduleOutput) ToScheduleOutput() ScheduleOutput {
	return o
}

func (o ScheduleOutput) ToScheduleOutputWithContext(ctx context.Context) ScheduleOutput {
	return o
}

// Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be
// queued instead of skipped. Default to false.
func (o ScheduleOutput) AllowQueueing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Schedule) pulumi.BoolPtrOutput { return v.AllowQueueing }).(pulumi.BoolPtrOutput)
}

// Request for google_colab_notebook_execution.
// Structure is documented below.
func (o ScheduleOutput) CreateNotebookExecutionJobRequest() ScheduleCreateNotebookExecutionJobRequestOutput {
	return o.ApplyT(func(v *Schedule) ScheduleCreateNotebookExecutionJobRequestOutput {
		return v.CreateNotebookExecutionJobRequest
	}).(ScheduleCreateNotebookExecutionJobRequestOutput)
}

// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
func (o ScheduleOutput) Cron() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.Cron }).(pulumi.StringOutput)
}

// Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the
// schedule.
func (o ScheduleOutput) DesiredState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringPtrOutput { return v.DesiredState }).(pulumi.StringPtrOutput)
}

// Required. The display name of the Schedule.
func (o ScheduleOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is
// reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt)
// format.
func (o ScheduleOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringPtrOutput { return v.EndTime }).(pulumi.StringPtrOutput)
}

// The location for the resource: https://cloud.google.com/colab/docs/locations
func (o ScheduleOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
func (o ScheduleOutput) MaxConcurrentRunCount() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.MaxConcurrentRunCount }).(pulumi.StringOutput)
}

// Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >=
// maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is
// paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
func (o ScheduleOutput) MaxRunCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringPtrOutput { return v.MaxRunCount }).(pulumi.StringPtrOutput)
}

// The resource name of the Schedule
func (o ScheduleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ScheduleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC
// 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
func (o ScheduleOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.StartTime }).(pulumi.StringOutput)
}

// Output only. The state of the schedule.
func (o ScheduleOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Schedule) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

type ScheduleArrayOutput struct{ *pulumi.OutputState }

func (ScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Schedule)(nil)).Elem()
}

func (o ScheduleArrayOutput) ToScheduleArrayOutput() ScheduleArrayOutput {
	return o
}

func (o ScheduleArrayOutput) ToScheduleArrayOutputWithContext(ctx context.Context) ScheduleArrayOutput {
	return o
}

func (o ScheduleArrayOutput) Index(i pulumi.IntInput) ScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Schedule {
		return vs[0].([]*Schedule)[vs[1].(int)]
	}).(ScheduleOutput)
}

type ScheduleMapOutput struct{ *pulumi.OutputState }

func (ScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Schedule)(nil)).Elem()
}

func (o ScheduleMapOutput) ToScheduleMapOutput() ScheduleMapOutput {
	return o
}

func (o ScheduleMapOutput) ToScheduleMapOutputWithContext(ctx context.Context) ScheduleMapOutput {
	return o
}

func (o ScheduleMapOutput) MapIndex(k pulumi.StringInput) ScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Schedule {
		return vs[0].(map[string]*Schedule)[vs[1].(string)]
	}).(ScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleInput)(nil)).Elem(), &Schedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleArrayInput)(nil)).Elem(), ScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleMapInput)(nil)).Elem(), ScheduleMap{})
	pulumi.RegisterOutputType(ScheduleOutput{})
	pulumi.RegisterOutputType(ScheduleArrayOutput{})
	pulumi.RegisterOutputType(ScheduleMapOutput{})
}
