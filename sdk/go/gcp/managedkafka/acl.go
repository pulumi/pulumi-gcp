// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package managedkafka

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Managed Service for Apache Kafka ACL. Apache Kafka is a trademark owned by the Apache Software Foundation.
//
// ## Example Usage
//
// ### Managedkafka Acl Basic
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/managedkafka"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			cluster, err := managedkafka.NewCluster(ctx, "cluster", &managedkafka.ClusterArgs{
//				ClusterId: pulumi.String("my-cluster"),
//				Location:  pulumi.String("us-central1"),
//				CapacityConfig: &managedkafka.ClusterCapacityConfigArgs{
//					VcpuCount:   pulumi.String("3"),
//					MemoryBytes: pulumi.String("3221225472"),
//				},
//				GcpConfig: &managedkafka.ClusterGcpConfigArgs{
//					AccessConfig: &managedkafka.ClusterGcpConfigAccessConfigArgs{
//						NetworkConfigs: managedkafka.ClusterGcpConfigAccessConfigNetworkConfigArray{
//							&managedkafka.ClusterGcpConfigAccessConfigNetworkConfigArgs{
//								Subnet: pulumi.Sprintf("projects/%v/regions/us-central1/subnetworks/default", project.Number),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = managedkafka.NewAcl(ctx, "example", &managedkafka.AclArgs{
//				AclId:    pulumi.String("topic/mytopic"),
//				Cluster:  cluster.ClusterId,
//				Location: pulumi.String("us-central1"),
//				AclEntries: managedkafka.AclAclEntryArray{
//					&managedkafka.AclAclEntryArgs{
//						Principal:      pulumi.String("User:admin@my-project.iam.gserviceaccount.com"),
//						PermissionType: pulumi.String("ALLOW"),
//						Operation:      pulumi.String("ALL"),
//						Host:           pulumi.String("*"),
//					},
//					&managedkafka.AclAclEntryArgs{
//						Principal:      pulumi.String("User:producer-client@my-project.iam.gserviceaccount.com"),
//						PermissionType: pulumi.String("ALLOW"),
//						Operation:      pulumi.String("WRITE"),
//						Host:           pulumi.String("*"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Acl can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}`
//
// When using the `pulumi import` command, Acl can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:managedkafka/acl:Acl default projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}
// ```
type Acl struct {
	pulumi.CustomResourceState

	// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
	// Structure is documented below.
	AclEntries AclAclEntryArrayOutput `pulumi:"aclEntries"`
	// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
	// For acls on the cluster: `cluster`
	// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
	// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
	// For acls on all resources of a given type (i.e. the wildcard literal '*''): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
	AclId pulumi.StringOutput `pulumi:"aclId"`
	// The cluster name.
	Cluster pulumi.StringOutput `pulumi:"cluster"`
	// `etag` is used for concurrency control. An `etag` is returned in the
	// response to `GetAcl` and `CreateAcl`. Callers are required to put that etag
	// in the request to `UpdateAcl` to ensure that their change will be applied
	// to the same version of the acl that exists in the Kafka Cluster.
	// A terminal 'T' character in the etag indicates that the AclEntries were
	// truncated due to repeated field limits.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
	Location pulumi.StringOutput `pulumi:"location"`
	// The name of the acl. The `ACL_ID` segment is used when connecting directly to the cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/clusters/CLUSTER_ID/acls/ACL_ID`.
	Name pulumi.StringOutput `pulumi:"name"`
	// The acl pattern type derived from the name. One of: LITERAL, PREFIXED.
	PatternType pulumi.StringOutput `pulumi:"patternType"`
	Project     pulumi.StringOutput `pulumi:"project"`
	// The acl resource name derived from the name. For cluster resource_type, this is always "kafka-cluster". Can be the wildcard literal "*".
	ResourceName pulumi.StringOutput `pulumi:"resourceName"`
	// The acl resource type derived from the name. One of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.
	ResourceType pulumi.StringOutput `pulumi:"resourceType"`
}

// NewAcl registers a new resource with the given unique name, arguments, and options.
func NewAcl(ctx *pulumi.Context,
	name string, args *AclArgs, opts ...pulumi.ResourceOption) (*Acl, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AclEntries == nil {
		return nil, errors.New("invalid value for required argument 'AclEntries'")
	}
	if args.AclId == nil {
		return nil, errors.New("invalid value for required argument 'AclId'")
	}
	if args.Cluster == nil {
		return nil, errors.New("invalid value for required argument 'Cluster'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Acl
	err := ctx.RegisterResource("gcp:managedkafka/acl:Acl", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAcl gets an existing Acl resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAcl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AclState, opts ...pulumi.ResourceOption) (*Acl, error) {
	var resource Acl
	err := ctx.ReadResource("gcp:managedkafka/acl:Acl", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Acl resources.
type aclState struct {
	// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
	// Structure is documented below.
	AclEntries []AclAclEntry `pulumi:"aclEntries"`
	// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
	// For acls on the cluster: `cluster`
	// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
	// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
	// For acls on all resources of a given type (i.e. the wildcard literal '*''): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
	AclId *string `pulumi:"aclId"`
	// The cluster name.
	Cluster *string `pulumi:"cluster"`
	// `etag` is used for concurrency control. An `etag` is returned in the
	// response to `GetAcl` and `CreateAcl`. Callers are required to put that etag
	// in the request to `UpdateAcl` to ensure that their change will be applied
	// to the same version of the acl that exists in the Kafka Cluster.
	// A terminal 'T' character in the etag indicates that the AclEntries were
	// truncated due to repeated field limits.
	Etag *string `pulumi:"etag"`
	// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
	Location *string `pulumi:"location"`
	// The name of the acl. The `ACL_ID` segment is used when connecting directly to the cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/clusters/CLUSTER_ID/acls/ACL_ID`.
	Name *string `pulumi:"name"`
	// The acl pattern type derived from the name. One of: LITERAL, PREFIXED.
	PatternType *string `pulumi:"patternType"`
	Project     *string `pulumi:"project"`
	// The acl resource name derived from the name. For cluster resource_type, this is always "kafka-cluster". Can be the wildcard literal "*".
	ResourceName *string `pulumi:"resourceName"`
	// The acl resource type derived from the name. One of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.
	ResourceType *string `pulumi:"resourceType"`
}

type AclState struct {
	// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
	// Structure is documented below.
	AclEntries AclAclEntryArrayInput
	// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
	// For acls on the cluster: `cluster`
	// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
	// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
	// For acls on all resources of a given type (i.e. the wildcard literal '*''): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
	AclId pulumi.StringPtrInput
	// The cluster name.
	Cluster pulumi.StringPtrInput
	// `etag` is used for concurrency control. An `etag` is returned in the
	// response to `GetAcl` and `CreateAcl`. Callers are required to put that etag
	// in the request to `UpdateAcl` to ensure that their change will be applied
	// to the same version of the acl that exists in the Kafka Cluster.
	// A terminal 'T' character in the etag indicates that the AclEntries were
	// truncated due to repeated field limits.
	Etag pulumi.StringPtrInput
	// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
	Location pulumi.StringPtrInput
	// The name of the acl. The `ACL_ID` segment is used when connecting directly to the cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/clusters/CLUSTER_ID/acls/ACL_ID`.
	Name pulumi.StringPtrInput
	// The acl pattern type derived from the name. One of: LITERAL, PREFIXED.
	PatternType pulumi.StringPtrInput
	Project     pulumi.StringPtrInput
	// The acl resource name derived from the name. For cluster resource_type, this is always "kafka-cluster". Can be the wildcard literal "*".
	ResourceName pulumi.StringPtrInput
	// The acl resource type derived from the name. One of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.
	ResourceType pulumi.StringPtrInput
}

func (AclState) ElementType() reflect.Type {
	return reflect.TypeOf((*aclState)(nil)).Elem()
}

type aclArgs struct {
	// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
	// Structure is documented below.
	AclEntries []AclAclEntry `pulumi:"aclEntries"`
	// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
	// For acls on the cluster: `cluster`
	// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
	// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
	// For acls on all resources of a given type (i.e. the wildcard literal '*''): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
	AclId string `pulumi:"aclId"`
	// The cluster name.
	Cluster string `pulumi:"cluster"`
	// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
	Location string  `pulumi:"location"`
	Project  *string `pulumi:"project"`
}

// The set of arguments for constructing a Acl resource.
type AclArgs struct {
	// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
	// Structure is documented below.
	AclEntries AclAclEntryArrayInput
	// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
	// For acls on the cluster: `cluster`
	// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
	// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
	// For acls on all resources of a given type (i.e. the wildcard literal '*''): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
	AclId pulumi.StringInput
	// The cluster name.
	Cluster pulumi.StringInput
	// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
	Location pulumi.StringInput
	Project  pulumi.StringPtrInput
}

func (AclArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aclArgs)(nil)).Elem()
}

type AclInput interface {
	pulumi.Input

	ToAclOutput() AclOutput
	ToAclOutputWithContext(ctx context.Context) AclOutput
}

func (*Acl) ElementType() reflect.Type {
	return reflect.TypeOf((**Acl)(nil)).Elem()
}

func (i *Acl) ToAclOutput() AclOutput {
	return i.ToAclOutputWithContext(context.Background())
}

func (i *Acl) ToAclOutputWithContext(ctx context.Context) AclOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclOutput)
}

// AclArrayInput is an input type that accepts AclArray and AclArrayOutput values.
// You can construct a concrete instance of `AclArrayInput` via:
//
//	AclArray{ AclArgs{...} }
type AclArrayInput interface {
	pulumi.Input

	ToAclArrayOutput() AclArrayOutput
	ToAclArrayOutputWithContext(context.Context) AclArrayOutput
}

type AclArray []AclInput

func (AclArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Acl)(nil)).Elem()
}

func (i AclArray) ToAclArrayOutput() AclArrayOutput {
	return i.ToAclArrayOutputWithContext(context.Background())
}

func (i AclArray) ToAclArrayOutputWithContext(ctx context.Context) AclArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclArrayOutput)
}

// AclMapInput is an input type that accepts AclMap and AclMapOutput values.
// You can construct a concrete instance of `AclMapInput` via:
//
//	AclMap{ "key": AclArgs{...} }
type AclMapInput interface {
	pulumi.Input

	ToAclMapOutput() AclMapOutput
	ToAclMapOutputWithContext(context.Context) AclMapOutput
}

type AclMap map[string]AclInput

func (AclMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Acl)(nil)).Elem()
}

func (i AclMap) ToAclMapOutput() AclMapOutput {
	return i.ToAclMapOutputWithContext(context.Background())
}

func (i AclMap) ToAclMapOutputWithContext(ctx context.Context) AclMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclMapOutput)
}

type AclOutput struct{ *pulumi.OutputState }

func (AclOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Acl)(nil)).Elem()
}

func (o AclOutput) ToAclOutput() AclOutput {
	return o
}

func (o AclOutput) ToAclOutputWithContext(ctx context.Context) AclOutput {
	return o
}

// The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.
// Structure is documented below.
func (o AclOutput) AclEntries() AclAclEntryArrayOutput {
	return o.ApplyT(func(v *Acl) AclAclEntryArrayOutput { return v.AclEntries }).(AclAclEntryArrayOutput)
}

// The ID to use for the acl, which will become the final component of the acl's name. The structure of `aclId` defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. `aclId` is structured like one of the following:
// For acls on the cluster: `cluster`
// For acls on a single resource within the cluster: `topic/{resource_name}` `consumerGroup/{resource_name}` `transactionalId/{resource_name}`
// For acls on all resources that match a prefix: `topicPrefixed/{resource_name}` `consumerGroupPrefixed/{resource_name}` `transactionalIdPrefixed/{resource_name}`
// For acls on all resources of a given type (i.e. the wildcard literal '*”): `allTopics` (represents `topic/*`) `allConsumerGroups` (represents `consumerGroup/*`) `allTransactionalIds` (represents `transactionalId/*`).
func (o AclOutput) AclId() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.AclId }).(pulumi.StringOutput)
}

// The cluster name.
func (o AclOutput) Cluster() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.Cluster }).(pulumi.StringOutput)
}

// `etag` is used for concurrency control. An `etag` is returned in the
// response to `GetAcl` and `CreateAcl`. Callers are required to put that etag
// in the request to `UpdateAcl` to ensure that their change will be applied
// to the same version of the acl that exists in the Kafka Cluster.
// A terminal 'T' character in the etag indicates that the AclEntries were
// truncated due to repeated field limits.
func (o AclOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

// ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
func (o AclOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The name of the acl. The `ACL_ID` segment is used when connecting directly to the cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/clusters/CLUSTER_ID/acls/ACL_ID`.
func (o AclOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The acl pattern type derived from the name. One of: LITERAL, PREFIXED.
func (o AclOutput) PatternType() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.PatternType }).(pulumi.StringOutput)
}

func (o AclOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The acl resource name derived from the name. For cluster resource_type, this is always "kafka-cluster". Can be the wildcard literal "*".
func (o AclOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.ResourceName }).(pulumi.StringOutput)
}

// The acl resource type derived from the name. One of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.
func (o AclOutput) ResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v *Acl) pulumi.StringOutput { return v.ResourceType }).(pulumi.StringOutput)
}

type AclArrayOutput struct{ *pulumi.OutputState }

func (AclArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Acl)(nil)).Elem()
}

func (o AclArrayOutput) ToAclArrayOutput() AclArrayOutput {
	return o
}

func (o AclArrayOutput) ToAclArrayOutputWithContext(ctx context.Context) AclArrayOutput {
	return o
}

func (o AclArrayOutput) Index(i pulumi.IntInput) AclOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Acl {
		return vs[0].([]*Acl)[vs[1].(int)]
	}).(AclOutput)
}

type AclMapOutput struct{ *pulumi.OutputState }

func (AclMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Acl)(nil)).Elem()
}

func (o AclMapOutput) ToAclMapOutput() AclMapOutput {
	return o
}

func (o AclMapOutput) ToAclMapOutputWithContext(ctx context.Context) AclMapOutput {
	return o
}

func (o AclMapOutput) MapIndex(k pulumi.StringInput) AclOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Acl {
		return vs[0].(map[string]*Acl)[vs[1].(string)]
	}).(AclOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AclInput)(nil)).Elem(), &Acl{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclArrayInput)(nil)).Elem(), AclArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclMapInput)(nil)).Elem(), AclMap{})
	pulumi.RegisterOutputType(AclOutput{})
	pulumi.RegisterOutputType(AclArrayOutput{})
	pulumi.RegisterOutputType(AclMapOutput{})
}
