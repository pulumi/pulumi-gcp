// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package managedkafka

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type ClusterCapacityConfig struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	//
	// ***
	MemoryBytes string `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount string `pulumi:"vcpuCount"`
}

// ClusterCapacityConfigInput is an input type that accepts ClusterCapacityConfigArgs and ClusterCapacityConfigOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigInput` via:
//
//	ClusterCapacityConfigArgs{...}
type ClusterCapacityConfigInput interface {
	pulumi.Input

	ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput
	ToClusterCapacityConfigOutputWithContext(context.Context) ClusterCapacityConfigOutput
}

type ClusterCapacityConfigArgs struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	//
	// ***
	MemoryBytes pulumi.StringInput `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount pulumi.StringInput `pulumi:"vcpuCount"`
}

func (ClusterCapacityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return i.ToClusterCapacityConfigOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput)
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput).ToClusterCapacityConfigPtrOutputWithContext(ctx)
}

// ClusterCapacityConfigPtrInput is an input type that accepts ClusterCapacityConfigArgs, ClusterCapacityConfigPtr and ClusterCapacityConfigPtrOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigPtrInput` via:
//
//	        ClusterCapacityConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterCapacityConfigPtrInput interface {
	pulumi.Input

	ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput
	ToClusterCapacityConfigPtrOutputWithContext(context.Context) ClusterCapacityConfigPtrOutput
}

type clusterCapacityConfigPtrType ClusterCapacityConfigArgs

func ClusterCapacityConfigPtr(v *ClusterCapacityConfigArgs) ClusterCapacityConfigPtrInput {
	return (*clusterCapacityConfigPtrType)(v)
}

func (*clusterCapacityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigPtrOutput)
}

type ClusterCapacityConfigOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterCapacityConfig) *ClusterCapacityConfig {
		return &v
	}).(ClusterCapacityConfigPtrOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
//
// ***
func (o ClusterCapacityConfigOutput) MemoryBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.MemoryBytes }).(pulumi.StringOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigOutput) VcpuCount() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.VcpuCount }).(pulumi.StringOutput)
}

type ClusterCapacityConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) Elem() ClusterCapacityConfigOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) ClusterCapacityConfig {
		if v != nil {
			return *v
		}
		var ret ClusterCapacityConfig
		return ret
	}).(ClusterCapacityConfigOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
//
// ***
func (o ClusterCapacityConfigPtrOutput) MemoryBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MemoryBytes
	}).(pulumi.StringPtrOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigPtrOutput) VcpuCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.VcpuCount
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfig struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfig `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey *string `pulumi:"kmsKey"`
}

// ClusterGcpConfigInput is an input type that accepts ClusterGcpConfigArgs and ClusterGcpConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigInput` via:
//
//	ClusterGcpConfigArgs{...}
type ClusterGcpConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigOutput() ClusterGcpConfigOutput
	ToClusterGcpConfigOutputWithContext(context.Context) ClusterGcpConfigOutput
}

type ClusterGcpConfigArgs struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfigInput `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey pulumi.StringPtrInput `pulumi:"kmsKey"`
}

func (ClusterGcpConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return i.ToClusterGcpConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput)
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput).ToClusterGcpConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigPtrInput is an input type that accepts ClusterGcpConfigArgs, ClusterGcpConfigPtr and ClusterGcpConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigPtrInput` via:
//
//	        ClusterGcpConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput
	ToClusterGcpConfigPtrOutputWithContext(context.Context) ClusterGcpConfigPtrOutput
}

type clusterGcpConfigPtrType ClusterGcpConfigArgs

func ClusterGcpConfigPtr(v *ClusterGcpConfigArgs) ClusterGcpConfigPtrInput {
	return (*clusterGcpConfigPtrType)(v)
}

func (*clusterGcpConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigPtrOutput)
}

type ClusterGcpConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfig) *ClusterGcpConfig {
		return &v
	}).(ClusterGcpConfigPtrOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigOutput) AccessConfig() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v ClusterGcpConfig) ClusterGcpConfigAccessConfig { return v.AccessConfig }).(ClusterGcpConfigAccessConfigOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterGcpConfig) *string { return v.KmsKey }).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) Elem() ClusterGcpConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) ClusterGcpConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfig
		return ret
	}).(ClusterGcpConfigOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigPtrOutput) AccessConfig() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *ClusterGcpConfigAccessConfig {
		if v == nil {
			return nil
		}
		return &v.AccessConfig
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigPtrOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *string {
		if v == nil {
			return nil
		}
		return v.KmsKey
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigAccessConfig struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs []ClusterGcpConfigAccessConfigNetworkConfig `pulumi:"networkConfigs"`
}

// ClusterGcpConfigAccessConfigInput is an input type that accepts ClusterGcpConfigAccessConfigArgs and ClusterGcpConfigAccessConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigInput` via:
//
//	ClusterGcpConfigAccessConfigArgs{...}
type ClusterGcpConfigAccessConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput
	ToClusterGcpConfigAccessConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigOutput
}

type ClusterGcpConfigAccessConfigArgs struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs ClusterGcpConfigAccessConfigNetworkConfigArrayInput `pulumi:"networkConfigs"`
}

func (ClusterGcpConfigAccessConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return i.ToClusterGcpConfigAccessConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput)
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput).ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigAccessConfigPtrInput is an input type that accepts ClusterGcpConfigAccessConfigArgs, ClusterGcpConfigAccessConfigPtr and ClusterGcpConfigAccessConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigPtrInput` via:
//
//	        ClusterGcpConfigAccessConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigAccessConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput
	ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Context) ClusterGcpConfigAccessConfigPtrOutput
}

type clusterGcpConfigAccessConfigPtrType ClusterGcpConfigAccessConfigArgs

func ClusterGcpConfigAccessConfigPtr(v *ClusterGcpConfigAccessConfigArgs) ClusterGcpConfigAccessConfigPtrInput {
	return (*clusterGcpConfigAccessConfigPtrType)(v)
}

func (*clusterGcpConfigAccessConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigPtrOutput)
}

type ClusterGcpConfigAccessConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfigAccessConfig) *ClusterGcpConfigAccessConfig {
		return &v
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) Elem() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) ClusterGcpConfigAccessConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfigAccessConfig
		return ret
	}).(ClusterGcpConfigAccessConfigOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigPtrOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		if v == nil {
			return nil
		}
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfig struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. The subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet string `pulumi:"subnet"`
}

// ClusterGcpConfigAccessConfigNetworkConfigInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArgs and ClusterGcpConfigAccessConfigNetworkConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArgs{...}
type ClusterGcpConfigAccessConfigNetworkConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput
	ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArgs struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. The subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet pulumi.StringInput `pulumi:"subnet"`
}

func (ClusterGcpConfigAccessConfigNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

// ClusterGcpConfigAccessConfigNetworkConfigArrayInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArray and ClusterGcpConfigAccessConfigNetworkConfigArrayOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigArrayInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArray{ ClusterGcpConfigAccessConfigNetworkConfigArgs{...} }
type ClusterGcpConfigAccessConfigNetworkConfigArrayInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArray []ClusterGcpConfigAccessConfigNetworkConfigInput

func (ClusterGcpConfigAccessConfigNetworkConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. The subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) Subnet() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfigNetworkConfig) string { return v.Subnet }).(pulumi.StringOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) Index(i pulumi.IntInput) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterGcpConfigAccessConfigNetworkConfig {
		return vs[0].([]ClusterGcpConfigAccessConfigNetworkConfig)[vs[1].(int)]
	}).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

type ClusterRebalanceConfig struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode *string `pulumi:"mode"`
}

// ClusterRebalanceConfigInput is an input type that accepts ClusterRebalanceConfigArgs and ClusterRebalanceConfigOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigInput` via:
//
//	ClusterRebalanceConfigArgs{...}
type ClusterRebalanceConfigInput interface {
	pulumi.Input

	ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput
	ToClusterRebalanceConfigOutputWithContext(context.Context) ClusterRebalanceConfigOutput
}

type ClusterRebalanceConfigArgs struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
}

func (ClusterRebalanceConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return i.ToClusterRebalanceConfigOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput)
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput).ToClusterRebalanceConfigPtrOutputWithContext(ctx)
}

// ClusterRebalanceConfigPtrInput is an input type that accepts ClusterRebalanceConfigArgs, ClusterRebalanceConfigPtr and ClusterRebalanceConfigPtrOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigPtrInput` via:
//
//	        ClusterRebalanceConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterRebalanceConfigPtrInput interface {
	pulumi.Input

	ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput
	ToClusterRebalanceConfigPtrOutputWithContext(context.Context) ClusterRebalanceConfigPtrOutput
}

type clusterRebalanceConfigPtrType ClusterRebalanceConfigArgs

func ClusterRebalanceConfigPtr(v *ClusterRebalanceConfigArgs) ClusterRebalanceConfigPtrInput {
	return (*clusterRebalanceConfigPtrType)(v)
}

func (*clusterRebalanceConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigPtrOutput)
}

type ClusterRebalanceConfigOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterRebalanceConfig) *ClusterRebalanceConfig {
		return &v
	}).(ClusterRebalanceConfigPtrOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterRebalanceConfig) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

type ClusterRebalanceConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) Elem() ClusterRebalanceConfigOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) ClusterRebalanceConfig {
		if v != nil {
			return *v
		}
		var ret ClusterRebalanceConfig
		return ret
	}).(ClusterRebalanceConfigOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigPtrInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigPtrInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigPtrInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigArrayInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigPtrInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterOutputType(ClusterCapacityConfigOutput{})
	pulumi.RegisterOutputType(ClusterCapacityConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigPtrOutput{})
}
