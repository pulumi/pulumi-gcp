// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package managedkafka

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type AclAclEntry struct {
	// The host. Must be set to "*" for Managed Service for Apache Kafka.
	Host *string `pulumi:"host"`
	// The operation type. Allowed values are (case insensitive): ALL, READ,
	// WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION, DESCRIBE_CONFIGS,
	// ALTER_CONFIGS, and IDEMPOTENT_WRITE. See https://kafka.apache.org/documentation/#operations_resources_and_protocols
	// for valid combinations of resourceType and operation for different Kafka API requests.
	Operation string `pulumi:"operation"`
	// The permission type. Accepted values are (case insensitive): ALLOW, DENY.
	PermissionType *string `pulumi:"permissionType"`
	// The principal. Specified as Google Cloud account, with the Kafka StandardAuthorizer prefix User:". For example: "User:test-kafka-client@test-project.iam.gserviceaccount.com". Can be the wildcard "User:*" to refer to all users.
	Principal string `pulumi:"principal"`
}

// AclAclEntryInput is an input type that accepts AclAclEntryArgs and AclAclEntryOutput values.
// You can construct a concrete instance of `AclAclEntryInput` via:
//
//	AclAclEntryArgs{...}
type AclAclEntryInput interface {
	pulumi.Input

	ToAclAclEntryOutput() AclAclEntryOutput
	ToAclAclEntryOutputWithContext(context.Context) AclAclEntryOutput
}

type AclAclEntryArgs struct {
	// The host. Must be set to "*" for Managed Service for Apache Kafka.
	Host pulumi.StringPtrInput `pulumi:"host"`
	// The operation type. Allowed values are (case insensitive): ALL, READ,
	// WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION, DESCRIBE_CONFIGS,
	// ALTER_CONFIGS, and IDEMPOTENT_WRITE. See https://kafka.apache.org/documentation/#operations_resources_and_protocols
	// for valid combinations of resourceType and operation for different Kafka API requests.
	Operation pulumi.StringInput `pulumi:"operation"`
	// The permission type. Accepted values are (case insensitive): ALLOW, DENY.
	PermissionType pulumi.StringPtrInput `pulumi:"permissionType"`
	// The principal. Specified as Google Cloud account, with the Kafka StandardAuthorizer prefix User:". For example: "User:test-kafka-client@test-project.iam.gserviceaccount.com". Can be the wildcard "User:*" to refer to all users.
	Principal pulumi.StringInput `pulumi:"principal"`
}

func (AclAclEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AclAclEntry)(nil)).Elem()
}

func (i AclAclEntryArgs) ToAclAclEntryOutput() AclAclEntryOutput {
	return i.ToAclAclEntryOutputWithContext(context.Background())
}

func (i AclAclEntryArgs) ToAclAclEntryOutputWithContext(ctx context.Context) AclAclEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclAclEntryOutput)
}

// AclAclEntryArrayInput is an input type that accepts AclAclEntryArray and AclAclEntryArrayOutput values.
// You can construct a concrete instance of `AclAclEntryArrayInput` via:
//
//	AclAclEntryArray{ AclAclEntryArgs{...} }
type AclAclEntryArrayInput interface {
	pulumi.Input

	ToAclAclEntryArrayOutput() AclAclEntryArrayOutput
	ToAclAclEntryArrayOutputWithContext(context.Context) AclAclEntryArrayOutput
}

type AclAclEntryArray []AclAclEntryInput

func (AclAclEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AclAclEntry)(nil)).Elem()
}

func (i AclAclEntryArray) ToAclAclEntryArrayOutput() AclAclEntryArrayOutput {
	return i.ToAclAclEntryArrayOutputWithContext(context.Background())
}

func (i AclAclEntryArray) ToAclAclEntryArrayOutputWithContext(ctx context.Context) AclAclEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclAclEntryArrayOutput)
}

type AclAclEntryOutput struct{ *pulumi.OutputState }

func (AclAclEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AclAclEntry)(nil)).Elem()
}

func (o AclAclEntryOutput) ToAclAclEntryOutput() AclAclEntryOutput {
	return o
}

func (o AclAclEntryOutput) ToAclAclEntryOutputWithContext(ctx context.Context) AclAclEntryOutput {
	return o
}

// The host. Must be set to "*" for Managed Service for Apache Kafka.
func (o AclAclEntryOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AclAclEntry) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// The operation type. Allowed values are (case insensitive): ALL, READ,
// WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION, DESCRIBE_CONFIGS,
// ALTER_CONFIGS, and IDEMPOTENT_WRITE. See https://kafka.apache.org/documentation/#operations_resources_and_protocols
// for valid combinations of resourceType and operation for different Kafka API requests.
func (o AclAclEntryOutput) Operation() pulumi.StringOutput {
	return o.ApplyT(func(v AclAclEntry) string { return v.Operation }).(pulumi.StringOutput)
}

// The permission type. Accepted values are (case insensitive): ALLOW, DENY.
func (o AclAclEntryOutput) PermissionType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AclAclEntry) *string { return v.PermissionType }).(pulumi.StringPtrOutput)
}

// The principal. Specified as Google Cloud account, with the Kafka StandardAuthorizer prefix User:". For example: "User:test-kafka-client@test-project.iam.gserviceaccount.com". Can be the wildcard "User:*" to refer to all users.
func (o AclAclEntryOutput) Principal() pulumi.StringOutput {
	return o.ApplyT(func(v AclAclEntry) string { return v.Principal }).(pulumi.StringOutput)
}

type AclAclEntryArrayOutput struct{ *pulumi.OutputState }

func (AclAclEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AclAclEntry)(nil)).Elem()
}

func (o AclAclEntryArrayOutput) ToAclAclEntryArrayOutput() AclAclEntryArrayOutput {
	return o
}

func (o AclAclEntryArrayOutput) ToAclAclEntryArrayOutputWithContext(ctx context.Context) AclAclEntryArrayOutput {
	return o
}

func (o AclAclEntryArrayOutput) Index(i pulumi.IntInput) AclAclEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AclAclEntry {
		return vs[0].([]AclAclEntry)[vs[1].(int)]
	}).(AclAclEntryOutput)
}

type ClusterCapacityConfig struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	MemoryBytes string `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount string `pulumi:"vcpuCount"`
}

// ClusterCapacityConfigInput is an input type that accepts ClusterCapacityConfigArgs and ClusterCapacityConfigOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigInput` via:
//
//	ClusterCapacityConfigArgs{...}
type ClusterCapacityConfigInput interface {
	pulumi.Input

	ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput
	ToClusterCapacityConfigOutputWithContext(context.Context) ClusterCapacityConfigOutput
}

type ClusterCapacityConfigArgs struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	MemoryBytes pulumi.StringInput `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount pulumi.StringInput `pulumi:"vcpuCount"`
}

func (ClusterCapacityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return i.ToClusterCapacityConfigOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput)
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput).ToClusterCapacityConfigPtrOutputWithContext(ctx)
}

// ClusterCapacityConfigPtrInput is an input type that accepts ClusterCapacityConfigArgs, ClusterCapacityConfigPtr and ClusterCapacityConfigPtrOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigPtrInput` via:
//
//	        ClusterCapacityConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterCapacityConfigPtrInput interface {
	pulumi.Input

	ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput
	ToClusterCapacityConfigPtrOutputWithContext(context.Context) ClusterCapacityConfigPtrOutput
}

type clusterCapacityConfigPtrType ClusterCapacityConfigArgs

func ClusterCapacityConfigPtr(v *ClusterCapacityConfigArgs) ClusterCapacityConfigPtrInput {
	return (*clusterCapacityConfigPtrType)(v)
}

func (*clusterCapacityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigPtrOutput)
}

type ClusterCapacityConfigOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterCapacityConfig) *ClusterCapacityConfig {
		return &v
	}).(ClusterCapacityConfigPtrOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
func (o ClusterCapacityConfigOutput) MemoryBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.MemoryBytes }).(pulumi.StringOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigOutput) VcpuCount() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.VcpuCount }).(pulumi.StringOutput)
}

type ClusterCapacityConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) Elem() ClusterCapacityConfigOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) ClusterCapacityConfig {
		if v != nil {
			return *v
		}
		var ret ClusterCapacityConfig
		return ret
	}).(ClusterCapacityConfigOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
func (o ClusterCapacityConfigPtrOutput) MemoryBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MemoryBytes
	}).(pulumi.StringPtrOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigPtrOutput) VcpuCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.VcpuCount
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfig struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfig `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey *string `pulumi:"kmsKey"`
}

// ClusterGcpConfigInput is an input type that accepts ClusterGcpConfigArgs and ClusterGcpConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigInput` via:
//
//	ClusterGcpConfigArgs{...}
type ClusterGcpConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigOutput() ClusterGcpConfigOutput
	ToClusterGcpConfigOutputWithContext(context.Context) ClusterGcpConfigOutput
}

type ClusterGcpConfigArgs struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfigInput `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey pulumi.StringPtrInput `pulumi:"kmsKey"`
}

func (ClusterGcpConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return i.ToClusterGcpConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput)
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput).ToClusterGcpConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigPtrInput is an input type that accepts ClusterGcpConfigArgs, ClusterGcpConfigPtr and ClusterGcpConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigPtrInput` via:
//
//	        ClusterGcpConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput
	ToClusterGcpConfigPtrOutputWithContext(context.Context) ClusterGcpConfigPtrOutput
}

type clusterGcpConfigPtrType ClusterGcpConfigArgs

func ClusterGcpConfigPtr(v *ClusterGcpConfigArgs) ClusterGcpConfigPtrInput {
	return (*clusterGcpConfigPtrType)(v)
}

func (*clusterGcpConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigPtrOutput)
}

type ClusterGcpConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfig) *ClusterGcpConfig {
		return &v
	}).(ClusterGcpConfigPtrOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigOutput) AccessConfig() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v ClusterGcpConfig) ClusterGcpConfigAccessConfig { return v.AccessConfig }).(ClusterGcpConfigAccessConfigOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterGcpConfig) *string { return v.KmsKey }).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) Elem() ClusterGcpConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) ClusterGcpConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfig
		return ret
	}).(ClusterGcpConfigOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigPtrOutput) AccessConfig() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *ClusterGcpConfigAccessConfig {
		if v == nil {
			return nil
		}
		return &v.AccessConfig
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigPtrOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *string {
		if v == nil {
			return nil
		}
		return v.KmsKey
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigAccessConfig struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs []ClusterGcpConfigAccessConfigNetworkConfig `pulumi:"networkConfigs"`
}

// ClusterGcpConfigAccessConfigInput is an input type that accepts ClusterGcpConfigAccessConfigArgs and ClusterGcpConfigAccessConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigInput` via:
//
//	ClusterGcpConfigAccessConfigArgs{...}
type ClusterGcpConfigAccessConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput
	ToClusterGcpConfigAccessConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigOutput
}

type ClusterGcpConfigAccessConfigArgs struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs ClusterGcpConfigAccessConfigNetworkConfigArrayInput `pulumi:"networkConfigs"`
}

func (ClusterGcpConfigAccessConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return i.ToClusterGcpConfigAccessConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput)
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput).ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigAccessConfigPtrInput is an input type that accepts ClusterGcpConfigAccessConfigArgs, ClusterGcpConfigAccessConfigPtr and ClusterGcpConfigAccessConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigPtrInput` via:
//
//	        ClusterGcpConfigAccessConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigAccessConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput
	ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Context) ClusterGcpConfigAccessConfigPtrOutput
}

type clusterGcpConfigAccessConfigPtrType ClusterGcpConfigAccessConfigArgs

func ClusterGcpConfigAccessConfigPtr(v *ClusterGcpConfigAccessConfigArgs) ClusterGcpConfigAccessConfigPtrInput {
	return (*clusterGcpConfigAccessConfigPtrType)(v)
}

func (*clusterGcpConfigAccessConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigPtrOutput)
}

type ClusterGcpConfigAccessConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfigAccessConfig) *ClusterGcpConfigAccessConfig {
		return &v
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) Elem() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) ClusterGcpConfigAccessConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfigAccessConfig
		return ret
	}).(ClusterGcpConfigAccessConfigOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigPtrOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		if v == nil {
			return nil
		}
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfig struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet string `pulumi:"subnet"`
}

// ClusterGcpConfigAccessConfigNetworkConfigInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArgs and ClusterGcpConfigAccessConfigNetworkConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArgs{...}
type ClusterGcpConfigAccessConfigNetworkConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput
	ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArgs struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet pulumi.StringInput `pulumi:"subnet"`
}

func (ClusterGcpConfigAccessConfigNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

// ClusterGcpConfigAccessConfigNetworkConfigArrayInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArray and ClusterGcpConfigAccessConfigNetworkConfigArrayOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigArrayInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArray{ ClusterGcpConfigAccessConfigNetworkConfigArgs{...} }
type ClusterGcpConfigAccessConfigNetworkConfigArrayInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArray []ClusterGcpConfigAccessConfigNetworkConfigInput

func (ClusterGcpConfigAccessConfigNetworkConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) Subnet() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfigNetworkConfig) string { return v.Subnet }).(pulumi.StringOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) Index(i pulumi.IntInput) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterGcpConfigAccessConfigNetworkConfig {
		return vs[0].([]ClusterGcpConfigAccessConfigNetworkConfig)[vs[1].(int)]
	}).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

type ClusterRebalanceConfig struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode *string `pulumi:"mode"`
}

// ClusterRebalanceConfigInput is an input type that accepts ClusterRebalanceConfigArgs and ClusterRebalanceConfigOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigInput` via:
//
//	ClusterRebalanceConfigArgs{...}
type ClusterRebalanceConfigInput interface {
	pulumi.Input

	ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput
	ToClusterRebalanceConfigOutputWithContext(context.Context) ClusterRebalanceConfigOutput
}

type ClusterRebalanceConfigArgs struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
}

func (ClusterRebalanceConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return i.ToClusterRebalanceConfigOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput)
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput).ToClusterRebalanceConfigPtrOutputWithContext(ctx)
}

// ClusterRebalanceConfigPtrInput is an input type that accepts ClusterRebalanceConfigArgs, ClusterRebalanceConfigPtr and ClusterRebalanceConfigPtrOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigPtrInput` via:
//
//	        ClusterRebalanceConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterRebalanceConfigPtrInput interface {
	pulumi.Input

	ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput
	ToClusterRebalanceConfigPtrOutputWithContext(context.Context) ClusterRebalanceConfigPtrOutput
}

type clusterRebalanceConfigPtrType ClusterRebalanceConfigArgs

func ClusterRebalanceConfigPtr(v *ClusterRebalanceConfigArgs) ClusterRebalanceConfigPtrInput {
	return (*clusterRebalanceConfigPtrType)(v)
}

func (*clusterRebalanceConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigPtrOutput)
}

type ClusterRebalanceConfigOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterRebalanceConfig) *ClusterRebalanceConfig {
		return &v
	}).(ClusterRebalanceConfigPtrOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterRebalanceConfig) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

type ClusterRebalanceConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) Elem() ClusterRebalanceConfigOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) ClusterRebalanceConfig {
		if v != nil {
			return *v
		}
		var ret ClusterRebalanceConfig
		return ret
	}).(ClusterRebalanceConfigOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

type ClusterTlsConfig struct {
	// The rules for mapping mTLS certificate Distinguished Names (DNs) to shortened principal names for Kafka ACLs. This field corresponds exactly to the ssl.principal.mapping.rules broker config and matches the format and syntax defined in the Apache Kafka documentation. Setting or modifying this field will trigger a rolling restart of the Kafka brokers to apply the change. An empty string means that the default Kafka behavior is used. Example: `RULE:^CN=(.?),OU=ServiceUsers.$/$1@example.com/,DEFAULT`
	SslPrincipalMappingRules *string `pulumi:"sslPrincipalMappingRules"`
	// The configuration of the broker truststore. If specified, clients can use mTLS for authentication.
	// Structure is documented below.
	TrustConfig *ClusterTlsConfigTrustConfig `pulumi:"trustConfig"`
}

// ClusterTlsConfigInput is an input type that accepts ClusterTlsConfigArgs and ClusterTlsConfigOutput values.
// You can construct a concrete instance of `ClusterTlsConfigInput` via:
//
//	ClusterTlsConfigArgs{...}
type ClusterTlsConfigInput interface {
	pulumi.Input

	ToClusterTlsConfigOutput() ClusterTlsConfigOutput
	ToClusterTlsConfigOutputWithContext(context.Context) ClusterTlsConfigOutput
}

type ClusterTlsConfigArgs struct {
	// The rules for mapping mTLS certificate Distinguished Names (DNs) to shortened principal names for Kafka ACLs. This field corresponds exactly to the ssl.principal.mapping.rules broker config and matches the format and syntax defined in the Apache Kafka documentation. Setting or modifying this field will trigger a rolling restart of the Kafka brokers to apply the change. An empty string means that the default Kafka behavior is used. Example: `RULE:^CN=(.?),OU=ServiceUsers.$/$1@example.com/,DEFAULT`
	SslPrincipalMappingRules pulumi.StringPtrInput `pulumi:"sslPrincipalMappingRules"`
	// The configuration of the broker truststore. If specified, clients can use mTLS for authentication.
	// Structure is documented below.
	TrustConfig ClusterTlsConfigTrustConfigPtrInput `pulumi:"trustConfig"`
}

func (ClusterTlsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfig)(nil)).Elem()
}

func (i ClusterTlsConfigArgs) ToClusterTlsConfigOutput() ClusterTlsConfigOutput {
	return i.ToClusterTlsConfigOutputWithContext(context.Background())
}

func (i ClusterTlsConfigArgs) ToClusterTlsConfigOutputWithContext(ctx context.Context) ClusterTlsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigOutput)
}

func (i ClusterTlsConfigArgs) ToClusterTlsConfigPtrOutput() ClusterTlsConfigPtrOutput {
	return i.ToClusterTlsConfigPtrOutputWithContext(context.Background())
}

func (i ClusterTlsConfigArgs) ToClusterTlsConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigOutput).ToClusterTlsConfigPtrOutputWithContext(ctx)
}

// ClusterTlsConfigPtrInput is an input type that accepts ClusterTlsConfigArgs, ClusterTlsConfigPtr and ClusterTlsConfigPtrOutput values.
// You can construct a concrete instance of `ClusterTlsConfigPtrInput` via:
//
//	        ClusterTlsConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterTlsConfigPtrInput interface {
	pulumi.Input

	ToClusterTlsConfigPtrOutput() ClusterTlsConfigPtrOutput
	ToClusterTlsConfigPtrOutputWithContext(context.Context) ClusterTlsConfigPtrOutput
}

type clusterTlsConfigPtrType ClusterTlsConfigArgs

func ClusterTlsConfigPtr(v *ClusterTlsConfigArgs) ClusterTlsConfigPtrInput {
	return (*clusterTlsConfigPtrType)(v)
}

func (*clusterTlsConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTlsConfig)(nil)).Elem()
}

func (i *clusterTlsConfigPtrType) ToClusterTlsConfigPtrOutput() ClusterTlsConfigPtrOutput {
	return i.ToClusterTlsConfigPtrOutputWithContext(context.Background())
}

func (i *clusterTlsConfigPtrType) ToClusterTlsConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigPtrOutput)
}

type ClusterTlsConfigOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfig)(nil)).Elem()
}

func (o ClusterTlsConfigOutput) ToClusterTlsConfigOutput() ClusterTlsConfigOutput {
	return o
}

func (o ClusterTlsConfigOutput) ToClusterTlsConfigOutputWithContext(ctx context.Context) ClusterTlsConfigOutput {
	return o
}

func (o ClusterTlsConfigOutput) ToClusterTlsConfigPtrOutput() ClusterTlsConfigPtrOutput {
	return o.ToClusterTlsConfigPtrOutputWithContext(context.Background())
}

func (o ClusterTlsConfigOutput) ToClusterTlsConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterTlsConfig) *ClusterTlsConfig {
		return &v
	}).(ClusterTlsConfigPtrOutput)
}

// The rules for mapping mTLS certificate Distinguished Names (DNs) to shortened principal names for Kafka ACLs. This field corresponds exactly to the ssl.principal.mapping.rules broker config and matches the format and syntax defined in the Apache Kafka documentation. Setting or modifying this field will trigger a rolling restart of the Kafka brokers to apply the change. An empty string means that the default Kafka behavior is used. Example: `RULE:^CN=(.?),OU=ServiceUsers.$/$1@example.com/,DEFAULT`
func (o ClusterTlsConfigOutput) SslPrincipalMappingRules() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterTlsConfig) *string { return v.SslPrincipalMappingRules }).(pulumi.StringPtrOutput)
}

// The configuration of the broker truststore. If specified, clients can use mTLS for authentication.
// Structure is documented below.
func (o ClusterTlsConfigOutput) TrustConfig() ClusterTlsConfigTrustConfigPtrOutput {
	return o.ApplyT(func(v ClusterTlsConfig) *ClusterTlsConfigTrustConfig { return v.TrustConfig }).(ClusterTlsConfigTrustConfigPtrOutput)
}

type ClusterTlsConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTlsConfig)(nil)).Elem()
}

func (o ClusterTlsConfigPtrOutput) ToClusterTlsConfigPtrOutput() ClusterTlsConfigPtrOutput {
	return o
}

func (o ClusterTlsConfigPtrOutput) ToClusterTlsConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigPtrOutput {
	return o
}

func (o ClusterTlsConfigPtrOutput) Elem() ClusterTlsConfigOutput {
	return o.ApplyT(func(v *ClusterTlsConfig) ClusterTlsConfig {
		if v != nil {
			return *v
		}
		var ret ClusterTlsConfig
		return ret
	}).(ClusterTlsConfigOutput)
}

// The rules for mapping mTLS certificate Distinguished Names (DNs) to shortened principal names for Kafka ACLs. This field corresponds exactly to the ssl.principal.mapping.rules broker config and matches the format and syntax defined in the Apache Kafka documentation. Setting or modifying this field will trigger a rolling restart of the Kafka brokers to apply the change. An empty string means that the default Kafka behavior is used. Example: `RULE:^CN=(.?),OU=ServiceUsers.$/$1@example.com/,DEFAULT`
func (o ClusterTlsConfigPtrOutput) SslPrincipalMappingRules() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterTlsConfig) *string {
		if v == nil {
			return nil
		}
		return v.SslPrincipalMappingRules
	}).(pulumi.StringPtrOutput)
}

// The configuration of the broker truststore. If specified, clients can use mTLS for authentication.
// Structure is documented below.
func (o ClusterTlsConfigPtrOutput) TrustConfig() ClusterTlsConfigTrustConfigPtrOutput {
	return o.ApplyT(func(v *ClusterTlsConfig) *ClusterTlsConfigTrustConfig {
		if v == nil {
			return nil
		}
		return v.TrustConfig
	}).(ClusterTlsConfigTrustConfigPtrOutput)
}

type ClusterTlsConfigTrustConfig struct {
	// Configuration for the Google Certificate Authority Service. To support mTLS, you must specify at least one `casConfigs` block. A maximum of 10 CA pools can be specified. Additional CA pools may be specified with additional `casConfigs` blocks.
	// Structure is documented below.
	CasConfigs []ClusterTlsConfigTrustConfigCasConfig `pulumi:"casConfigs"`
}

// ClusterTlsConfigTrustConfigInput is an input type that accepts ClusterTlsConfigTrustConfigArgs and ClusterTlsConfigTrustConfigOutput values.
// You can construct a concrete instance of `ClusterTlsConfigTrustConfigInput` via:
//
//	ClusterTlsConfigTrustConfigArgs{...}
type ClusterTlsConfigTrustConfigInput interface {
	pulumi.Input

	ToClusterTlsConfigTrustConfigOutput() ClusterTlsConfigTrustConfigOutput
	ToClusterTlsConfigTrustConfigOutputWithContext(context.Context) ClusterTlsConfigTrustConfigOutput
}

type ClusterTlsConfigTrustConfigArgs struct {
	// Configuration for the Google Certificate Authority Service. To support mTLS, you must specify at least one `casConfigs` block. A maximum of 10 CA pools can be specified. Additional CA pools may be specified with additional `casConfigs` blocks.
	// Structure is documented below.
	CasConfigs ClusterTlsConfigTrustConfigCasConfigArrayInput `pulumi:"casConfigs"`
}

func (ClusterTlsConfigTrustConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfigTrustConfig)(nil)).Elem()
}

func (i ClusterTlsConfigTrustConfigArgs) ToClusterTlsConfigTrustConfigOutput() ClusterTlsConfigTrustConfigOutput {
	return i.ToClusterTlsConfigTrustConfigOutputWithContext(context.Background())
}

func (i ClusterTlsConfigTrustConfigArgs) ToClusterTlsConfigTrustConfigOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigTrustConfigOutput)
}

func (i ClusterTlsConfigTrustConfigArgs) ToClusterTlsConfigTrustConfigPtrOutput() ClusterTlsConfigTrustConfigPtrOutput {
	return i.ToClusterTlsConfigTrustConfigPtrOutputWithContext(context.Background())
}

func (i ClusterTlsConfigTrustConfigArgs) ToClusterTlsConfigTrustConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigTrustConfigOutput).ToClusterTlsConfigTrustConfigPtrOutputWithContext(ctx)
}

// ClusterTlsConfigTrustConfigPtrInput is an input type that accepts ClusterTlsConfigTrustConfigArgs, ClusterTlsConfigTrustConfigPtr and ClusterTlsConfigTrustConfigPtrOutput values.
// You can construct a concrete instance of `ClusterTlsConfigTrustConfigPtrInput` via:
//
//	        ClusterTlsConfigTrustConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterTlsConfigTrustConfigPtrInput interface {
	pulumi.Input

	ToClusterTlsConfigTrustConfigPtrOutput() ClusterTlsConfigTrustConfigPtrOutput
	ToClusterTlsConfigTrustConfigPtrOutputWithContext(context.Context) ClusterTlsConfigTrustConfigPtrOutput
}

type clusterTlsConfigTrustConfigPtrType ClusterTlsConfigTrustConfigArgs

func ClusterTlsConfigTrustConfigPtr(v *ClusterTlsConfigTrustConfigArgs) ClusterTlsConfigTrustConfigPtrInput {
	return (*clusterTlsConfigTrustConfigPtrType)(v)
}

func (*clusterTlsConfigTrustConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTlsConfigTrustConfig)(nil)).Elem()
}

func (i *clusterTlsConfigTrustConfigPtrType) ToClusterTlsConfigTrustConfigPtrOutput() ClusterTlsConfigTrustConfigPtrOutput {
	return i.ToClusterTlsConfigTrustConfigPtrOutputWithContext(context.Background())
}

func (i *clusterTlsConfigTrustConfigPtrType) ToClusterTlsConfigTrustConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigTrustConfigPtrOutput)
}

type ClusterTlsConfigTrustConfigOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigTrustConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfigTrustConfig)(nil)).Elem()
}

func (o ClusterTlsConfigTrustConfigOutput) ToClusterTlsConfigTrustConfigOutput() ClusterTlsConfigTrustConfigOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigOutput) ToClusterTlsConfigTrustConfigOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigOutput) ToClusterTlsConfigTrustConfigPtrOutput() ClusterTlsConfigTrustConfigPtrOutput {
	return o.ToClusterTlsConfigTrustConfigPtrOutputWithContext(context.Background())
}

func (o ClusterTlsConfigTrustConfigOutput) ToClusterTlsConfigTrustConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterTlsConfigTrustConfig) *ClusterTlsConfigTrustConfig {
		return &v
	}).(ClusterTlsConfigTrustConfigPtrOutput)
}

// Configuration for the Google Certificate Authority Service. To support mTLS, you must specify at least one `casConfigs` block. A maximum of 10 CA pools can be specified. Additional CA pools may be specified with additional `casConfigs` blocks.
// Structure is documented below.
func (o ClusterTlsConfigTrustConfigOutput) CasConfigs() ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return o.ApplyT(func(v ClusterTlsConfigTrustConfig) []ClusterTlsConfigTrustConfigCasConfig { return v.CasConfigs }).(ClusterTlsConfigTrustConfigCasConfigArrayOutput)
}

type ClusterTlsConfigTrustConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigTrustConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTlsConfigTrustConfig)(nil)).Elem()
}

func (o ClusterTlsConfigTrustConfigPtrOutput) ToClusterTlsConfigTrustConfigPtrOutput() ClusterTlsConfigTrustConfigPtrOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigPtrOutput) ToClusterTlsConfigTrustConfigPtrOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigPtrOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigPtrOutput) Elem() ClusterTlsConfigTrustConfigOutput {
	return o.ApplyT(func(v *ClusterTlsConfigTrustConfig) ClusterTlsConfigTrustConfig {
		if v != nil {
			return *v
		}
		var ret ClusterTlsConfigTrustConfig
		return ret
	}).(ClusterTlsConfigTrustConfigOutput)
}

// Configuration for the Google Certificate Authority Service. To support mTLS, you must specify at least one `casConfigs` block. A maximum of 10 CA pools can be specified. Additional CA pools may be specified with additional `casConfigs` blocks.
// Structure is documented below.
func (o ClusterTlsConfigTrustConfigPtrOutput) CasConfigs() ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return o.ApplyT(func(v *ClusterTlsConfigTrustConfig) []ClusterTlsConfigTrustConfigCasConfig {
		if v == nil {
			return nil
		}
		return v.CasConfigs
	}).(ClusterTlsConfigTrustConfigCasConfigArrayOutput)
}

type ClusterTlsConfigTrustConfigCasConfig struct {
	// The name of the CA pool to pull CA certificates from. The CA pool does not need to be in the same project or location as the Kafka cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/caPools/CA_POOL_ID.
	CaPool string `pulumi:"caPool"`
}

// ClusterTlsConfigTrustConfigCasConfigInput is an input type that accepts ClusterTlsConfigTrustConfigCasConfigArgs and ClusterTlsConfigTrustConfigCasConfigOutput values.
// You can construct a concrete instance of `ClusterTlsConfigTrustConfigCasConfigInput` via:
//
//	ClusterTlsConfigTrustConfigCasConfigArgs{...}
type ClusterTlsConfigTrustConfigCasConfigInput interface {
	pulumi.Input

	ToClusterTlsConfigTrustConfigCasConfigOutput() ClusterTlsConfigTrustConfigCasConfigOutput
	ToClusterTlsConfigTrustConfigCasConfigOutputWithContext(context.Context) ClusterTlsConfigTrustConfigCasConfigOutput
}

type ClusterTlsConfigTrustConfigCasConfigArgs struct {
	// The name of the CA pool to pull CA certificates from. The CA pool does not need to be in the same project or location as the Kafka cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/caPools/CA_POOL_ID.
	CaPool pulumi.StringInput `pulumi:"caPool"`
}

func (ClusterTlsConfigTrustConfigCasConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfigTrustConfigCasConfig)(nil)).Elem()
}

func (i ClusterTlsConfigTrustConfigCasConfigArgs) ToClusterTlsConfigTrustConfigCasConfigOutput() ClusterTlsConfigTrustConfigCasConfigOutput {
	return i.ToClusterTlsConfigTrustConfigCasConfigOutputWithContext(context.Background())
}

func (i ClusterTlsConfigTrustConfigCasConfigArgs) ToClusterTlsConfigTrustConfigCasConfigOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigCasConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigTrustConfigCasConfigOutput)
}

// ClusterTlsConfigTrustConfigCasConfigArrayInput is an input type that accepts ClusterTlsConfigTrustConfigCasConfigArray and ClusterTlsConfigTrustConfigCasConfigArrayOutput values.
// You can construct a concrete instance of `ClusterTlsConfigTrustConfigCasConfigArrayInput` via:
//
//	ClusterTlsConfigTrustConfigCasConfigArray{ ClusterTlsConfigTrustConfigCasConfigArgs{...} }
type ClusterTlsConfigTrustConfigCasConfigArrayInput interface {
	pulumi.Input

	ToClusterTlsConfigTrustConfigCasConfigArrayOutput() ClusterTlsConfigTrustConfigCasConfigArrayOutput
	ToClusterTlsConfigTrustConfigCasConfigArrayOutputWithContext(context.Context) ClusterTlsConfigTrustConfigCasConfigArrayOutput
}

type ClusterTlsConfigTrustConfigCasConfigArray []ClusterTlsConfigTrustConfigCasConfigInput

func (ClusterTlsConfigTrustConfigCasConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterTlsConfigTrustConfigCasConfig)(nil)).Elem()
}

func (i ClusterTlsConfigTrustConfigCasConfigArray) ToClusterTlsConfigTrustConfigCasConfigArrayOutput() ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return i.ToClusterTlsConfigTrustConfigCasConfigArrayOutputWithContext(context.Background())
}

func (i ClusterTlsConfigTrustConfigCasConfigArray) ToClusterTlsConfigTrustConfigCasConfigArrayOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTlsConfigTrustConfigCasConfigArrayOutput)
}

type ClusterTlsConfigTrustConfigCasConfigOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigTrustConfigCasConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTlsConfigTrustConfigCasConfig)(nil)).Elem()
}

func (o ClusterTlsConfigTrustConfigCasConfigOutput) ToClusterTlsConfigTrustConfigCasConfigOutput() ClusterTlsConfigTrustConfigCasConfigOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigCasConfigOutput) ToClusterTlsConfigTrustConfigCasConfigOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigCasConfigOutput {
	return o
}

// The name of the CA pool to pull CA certificates from. The CA pool does not need to be in the same project or location as the Kafka cluster. Must be in the format `projects/PROJECT_ID/locations/LOCATION/caPools/CA_POOL_ID.
func (o ClusterTlsConfigTrustConfigCasConfigOutput) CaPool() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterTlsConfigTrustConfigCasConfig) string { return v.CaPool }).(pulumi.StringOutput)
}

type ClusterTlsConfigTrustConfigCasConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterTlsConfigTrustConfigCasConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterTlsConfigTrustConfigCasConfig)(nil)).Elem()
}

func (o ClusterTlsConfigTrustConfigCasConfigArrayOutput) ToClusterTlsConfigTrustConfigCasConfigArrayOutput() ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigCasConfigArrayOutput) ToClusterTlsConfigTrustConfigCasConfigArrayOutputWithContext(ctx context.Context) ClusterTlsConfigTrustConfigCasConfigArrayOutput {
	return o
}

func (o ClusterTlsConfigTrustConfigCasConfigArrayOutput) Index(i pulumi.IntInput) ClusterTlsConfigTrustConfigCasConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterTlsConfigTrustConfigCasConfig {
		return vs[0].([]ClusterTlsConfigTrustConfigCasConfig)[vs[1].(int)]
	}).(ClusterTlsConfigTrustConfigCasConfigOutput)
}

type ConnectClusterCapacityConfig struct {
	// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
	MemoryBytes string `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount string `pulumi:"vcpuCount"`
}

// ConnectClusterCapacityConfigInput is an input type that accepts ConnectClusterCapacityConfigArgs and ConnectClusterCapacityConfigOutput values.
// You can construct a concrete instance of `ConnectClusterCapacityConfigInput` via:
//
//	ConnectClusterCapacityConfigArgs{...}
type ConnectClusterCapacityConfigInput interface {
	pulumi.Input

	ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput
	ToConnectClusterCapacityConfigOutputWithContext(context.Context) ConnectClusterCapacityConfigOutput
}

type ConnectClusterCapacityConfigArgs struct {
	// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
	MemoryBytes pulumi.StringInput `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount pulumi.StringInput `pulumi:"vcpuCount"`
}

func (ConnectClusterCapacityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterCapacityConfig)(nil)).Elem()
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput {
	return i.ToConnectClusterCapacityConfigOutputWithContext(context.Background())
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigOutput)
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return i.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigOutput).ToConnectClusterCapacityConfigPtrOutputWithContext(ctx)
}

// ConnectClusterCapacityConfigPtrInput is an input type that accepts ConnectClusterCapacityConfigArgs, ConnectClusterCapacityConfigPtr and ConnectClusterCapacityConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterCapacityConfigPtrInput` via:
//
//	        ConnectClusterCapacityConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterCapacityConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput
	ToConnectClusterCapacityConfigPtrOutputWithContext(context.Context) ConnectClusterCapacityConfigPtrOutput
}

type connectClusterCapacityConfigPtrType ConnectClusterCapacityConfigArgs

func ConnectClusterCapacityConfigPtr(v *ConnectClusterCapacityConfigArgs) ConnectClusterCapacityConfigPtrInput {
	return (*connectClusterCapacityConfigPtrType)(v)
}

func (*connectClusterCapacityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterCapacityConfig)(nil)).Elem()
}

func (i *connectClusterCapacityConfigPtrType) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return i.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterCapacityConfigPtrType) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigPtrOutput)
}

type ConnectClusterCapacityConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterCapacityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterCapacityConfig)(nil)).Elem()
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput {
	return o
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigOutput {
	return o
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return o.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterCapacityConfig) *ConnectClusterCapacityConfig {
		return &v
	}).(ConnectClusterCapacityConfigPtrOutput)
}

// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
func (o ConnectClusterCapacityConfigOutput) MemoryBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterCapacityConfig) string { return v.MemoryBytes }).(pulumi.StringOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ConnectClusterCapacityConfigOutput) VcpuCount() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterCapacityConfig) string { return v.VcpuCount }).(pulumi.StringOutput)
}

type ConnectClusterCapacityConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterCapacityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterCapacityConfig)(nil)).Elem()
}

func (o ConnectClusterCapacityConfigPtrOutput) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return o
}

func (o ConnectClusterCapacityConfigPtrOutput) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return o
}

func (o ConnectClusterCapacityConfigPtrOutput) Elem() ConnectClusterCapacityConfigOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) ConnectClusterCapacityConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterCapacityConfig
		return ret
	}).(ConnectClusterCapacityConfigOutput)
}

// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
func (o ConnectClusterCapacityConfigPtrOutput) MemoryBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MemoryBytes
	}).(pulumi.StringPtrOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ConnectClusterCapacityConfigPtrOutput) VcpuCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.VcpuCount
	}).(pulumi.StringPtrOutput)
}

type ConnectClusterGcpConfig struct {
	// The configuration of access to the Kafka Connect cluster.
	// Structure is documented below.
	AccessConfig ConnectClusterGcpConfigAccessConfig `pulumi:"accessConfig"`
}

// ConnectClusterGcpConfigInput is an input type that accepts ConnectClusterGcpConfigArgs and ConnectClusterGcpConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigInput` via:
//
//	ConnectClusterGcpConfigArgs{...}
type ConnectClusterGcpConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput
	ToConnectClusterGcpConfigOutputWithContext(context.Context) ConnectClusterGcpConfigOutput
}

type ConnectClusterGcpConfigArgs struct {
	// The configuration of access to the Kafka Connect cluster.
	// Structure is documented below.
	AccessConfig ConnectClusterGcpConfigAccessConfigInput `pulumi:"accessConfig"`
}

func (ConnectClusterGcpConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput {
	return i.ToConnectClusterGcpConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigOutput)
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return i.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigOutput).ToConnectClusterGcpConfigPtrOutputWithContext(ctx)
}

// ConnectClusterGcpConfigPtrInput is an input type that accepts ConnectClusterGcpConfigArgs, ConnectClusterGcpConfigPtr and ConnectClusterGcpConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigPtrInput` via:
//
//	        ConnectClusterGcpConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterGcpConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput
	ToConnectClusterGcpConfigPtrOutputWithContext(context.Context) ConnectClusterGcpConfigPtrOutput
}

type connectClusterGcpConfigPtrType ConnectClusterGcpConfigArgs

func ConnectClusterGcpConfigPtr(v *ConnectClusterGcpConfigArgs) ConnectClusterGcpConfigPtrInput {
	return (*connectClusterGcpConfigPtrType)(v)
}

func (*connectClusterGcpConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfig)(nil)).Elem()
}

func (i *connectClusterGcpConfigPtrType) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return i.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterGcpConfigPtrType) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigPtrOutput)
}

type ConnectClusterGcpConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return o.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterGcpConfig) *ConnectClusterGcpConfig {
		return &v
	}).(ConnectClusterGcpConfigPtrOutput)
}

// The configuration of access to the Kafka Connect cluster.
// Structure is documented below.
func (o ConnectClusterGcpConfigOutput) AccessConfig() ConnectClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfig) ConnectClusterGcpConfigAccessConfig { return v.AccessConfig }).(ConnectClusterGcpConfigAccessConfigOutput)
}

type ConnectClusterGcpConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigPtrOutput) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigPtrOutput) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigPtrOutput) Elem() ConnectClusterGcpConfigOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfig) ConnectClusterGcpConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterGcpConfig
		return ret
	}).(ConnectClusterGcpConfigOutput)
}

// The configuration of access to the Kafka Connect cluster.
// Structure is documented below.
func (o ConnectClusterGcpConfigPtrOutput) AccessConfig() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfig) *ConnectClusterGcpConfigAccessConfig {
		if v == nil {
			return nil
		}
		return &v.AccessConfig
	}).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

type ConnectClusterGcpConfigAccessConfig struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs []ConnectClusterGcpConfigAccessConfigNetworkConfig `pulumi:"networkConfigs"`
}

// ConnectClusterGcpConfigAccessConfigInput is an input type that accepts ConnectClusterGcpConfigAccessConfigArgs and ConnectClusterGcpConfigAccessConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigInput` via:
//
//	ConnectClusterGcpConfigAccessConfigArgs{...}
type ConnectClusterGcpConfigAccessConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput
	ToConnectClusterGcpConfigAccessConfigOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigOutput
}

type ConnectClusterGcpConfigAccessConfigArgs struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput `pulumi:"networkConfigs"`
}

func (ConnectClusterGcpConfigAccessConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput {
	return i.ToConnectClusterGcpConfigAccessConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigOutput)
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return i.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigOutput).ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx)
}

// ConnectClusterGcpConfigAccessConfigPtrInput is an input type that accepts ConnectClusterGcpConfigAccessConfigArgs, ConnectClusterGcpConfigAccessConfigPtr and ConnectClusterGcpConfigAccessConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigPtrInput` via:
//
//	        ConnectClusterGcpConfigAccessConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterGcpConfigAccessConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput
	ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput
}

type connectClusterGcpConfigAccessConfigPtrType ConnectClusterGcpConfigAccessConfigArgs

func ConnectClusterGcpConfigAccessConfigPtr(v *ConnectClusterGcpConfigAccessConfigArgs) ConnectClusterGcpConfigAccessConfigPtrInput {
	return (*connectClusterGcpConfigAccessConfigPtrType)(v)
}

func (*connectClusterGcpConfigAccessConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i *connectClusterGcpConfigAccessConfigPtrType) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return i.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterGcpConfigAccessConfigPtrType) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

type ConnectClusterGcpConfigAccessConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterGcpConfigAccessConfig) *ConnectClusterGcpConfigAccessConfig {
		return &v
	}).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ConnectClusterGcpConfigAccessConfigOutput) NetworkConfigs() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfig) []ConnectClusterGcpConfigAccessConfigNetworkConfig {
		return v.NetworkConfigs
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) Elem() ConnectClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfigAccessConfig) ConnectClusterGcpConfigAccessConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterGcpConfigAccessConfig
		return ret
	}).(ConnectClusterGcpConfigAccessConfigOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ConnectClusterGcpConfigAccessConfigPtrOutput) NetworkConfigs() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfigAccessConfig) []ConnectClusterGcpConfigAccessConfigNetworkConfig {
		if v == nil {
			return nil
		}
		return v.NetworkConfigs
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfig struct {
	// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
	AdditionalSubnets []string `pulumi:"additionalSubnets"`
	// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
	DnsDomainNames []string `pulumi:"dnsDomainNames"`
	// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
	PrimarySubnet string `pulumi:"primarySubnet"`
}

// ConnectClusterGcpConfigAccessConfigNetworkConfigInput is an input type that accepts ConnectClusterGcpConfigAccessConfigNetworkConfigArgs and ConnectClusterGcpConfigAccessConfigNetworkConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigNetworkConfigInput` via:
//
//	ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{...}
type ConnectClusterGcpConfigAccessConfigNetworkConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput
	ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArgs struct {
	// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
	AdditionalSubnets pulumi.StringArrayInput `pulumi:"additionalSubnets"`
	// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
	DnsDomainNames pulumi.StringArrayInput `pulumi:"dnsDomainNames"`
	// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
	PrimarySubnet pulumi.StringInput `pulumi:"primarySubnet"`
}

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return i.ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput)
}

// ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput is an input type that accepts ConnectClusterGcpConfigAccessConfigNetworkConfigArray and ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput` via:
//
//	ConnectClusterGcpConfigAccessConfigNetworkConfigArray{ ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{...} }
type ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput
	ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArray []ConnectClusterGcpConfigAccessConfigNetworkConfigInput

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return i.ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) AdditionalSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) []string { return v.AdditionalSubnets }).(pulumi.StringArrayOutput)
}

// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) DnsDomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) []string { return v.DnsDomainNames }).(pulumi.StringArrayOutput)
}

// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) PrimarySubnet() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) string { return v.PrimarySubnet }).(pulumi.StringOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) Index(i pulumi.IntInput) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConnectClusterGcpConfigAccessConfigNetworkConfig {
		return vs[0].([]ConnectClusterGcpConfigAccessConfigNetworkConfig)[vs[1].(int)]
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput)
}

type ConnectorTaskRestartPolicy struct {
	// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff *string `pulumi:"maximumBackoff"`
	// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff *string `pulumi:"minimumBackoff"`
}

// ConnectorTaskRestartPolicyInput is an input type that accepts ConnectorTaskRestartPolicyArgs and ConnectorTaskRestartPolicyOutput values.
// You can construct a concrete instance of `ConnectorTaskRestartPolicyInput` via:
//
//	ConnectorTaskRestartPolicyArgs{...}
type ConnectorTaskRestartPolicyInput interface {
	pulumi.Input

	ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput
	ToConnectorTaskRestartPolicyOutputWithContext(context.Context) ConnectorTaskRestartPolicyOutput
}

type ConnectorTaskRestartPolicyArgs struct {
	// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff pulumi.StringPtrInput `pulumi:"maximumBackoff"`
	// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff pulumi.StringPtrInput `pulumi:"minimumBackoff"`
}

func (ConnectorTaskRestartPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput {
	return i.ToConnectorTaskRestartPolicyOutputWithContext(context.Background())
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyOutput)
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return i.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyOutput).ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx)
}

// ConnectorTaskRestartPolicyPtrInput is an input type that accepts ConnectorTaskRestartPolicyArgs, ConnectorTaskRestartPolicyPtr and ConnectorTaskRestartPolicyPtrOutput values.
// You can construct a concrete instance of `ConnectorTaskRestartPolicyPtrInput` via:
//
//	        ConnectorTaskRestartPolicyArgs{...}
//
//	or:
//
//	        nil
type ConnectorTaskRestartPolicyPtrInput interface {
	pulumi.Input

	ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput
	ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Context) ConnectorTaskRestartPolicyPtrOutput
}

type connectorTaskRestartPolicyPtrType ConnectorTaskRestartPolicyArgs

func ConnectorTaskRestartPolicyPtr(v *ConnectorTaskRestartPolicyArgs) ConnectorTaskRestartPolicyPtrInput {
	return (*connectorTaskRestartPolicyPtrType)(v)
}

func (*connectorTaskRestartPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (i *connectorTaskRestartPolicyPtrType) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return i.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (i *connectorTaskRestartPolicyPtrType) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyPtrOutput)
}

type ConnectorTaskRestartPolicyOutput struct{ *pulumi.OutputState }

func (ConnectorTaskRestartPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput {
	return o
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyOutput {
	return o
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return o.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectorTaskRestartPolicy) *ConnectorTaskRestartPolicy {
		return &v
	}).(ConnectorTaskRestartPolicyPtrOutput)
}

// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyOutput) MaximumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConnectorTaskRestartPolicy) *string { return v.MaximumBackoff }).(pulumi.StringPtrOutput)
}

// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyOutput) MinimumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConnectorTaskRestartPolicy) *string { return v.MinimumBackoff }).(pulumi.StringPtrOutput)
}

type ConnectorTaskRestartPolicyPtrOutput struct{ *pulumi.OutputState }

func (ConnectorTaskRestartPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (o ConnectorTaskRestartPolicyPtrOutput) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return o
}

func (o ConnectorTaskRestartPolicyPtrOutput) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return o
}

func (o ConnectorTaskRestartPolicyPtrOutput) Elem() ConnectorTaskRestartPolicyOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) ConnectorTaskRestartPolicy {
		if v != nil {
			return *v
		}
		var ret ConnectorTaskRestartPolicy
		return ret
	}).(ConnectorTaskRestartPolicyOutput)
}

// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyPtrOutput) MaximumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) *string {
		if v == nil {
			return nil
		}
		return v.MaximumBackoff
	}).(pulumi.StringPtrOutput)
}

// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyPtrOutput) MinimumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) *string {
		if v == nil {
			return nil
		}
		return v.MinimumBackoff
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AclAclEntryInput)(nil)).Elem(), AclAclEntryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclAclEntryArrayInput)(nil)).Elem(), AclAclEntryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigPtrInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigPtrInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigPtrInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigArrayInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigPtrInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigInput)(nil)).Elem(), ClusterTlsConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigPtrInput)(nil)).Elem(), ClusterTlsConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigTrustConfigInput)(nil)).Elem(), ClusterTlsConfigTrustConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigTrustConfigPtrInput)(nil)).Elem(), ClusterTlsConfigTrustConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigTrustConfigCasConfigInput)(nil)).Elem(), ClusterTlsConfigTrustConfigCasConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTlsConfigTrustConfigCasConfigArrayInput)(nil)).Elem(), ClusterTlsConfigTrustConfigCasConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterCapacityConfigInput)(nil)).Elem(), ConnectClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterCapacityConfigPtrInput)(nil)).Elem(), ConnectClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigInput)(nil)).Elem(), ConnectClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigPtrInput)(nil)).Elem(), ConnectClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigPtrInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfigInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigNetworkConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorTaskRestartPolicyInput)(nil)).Elem(), ConnectorTaskRestartPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorTaskRestartPolicyPtrInput)(nil)).Elem(), ConnectorTaskRestartPolicyArgs{})
	pulumi.RegisterOutputType(AclAclEntryOutput{})
	pulumi.RegisterOutputType(AclAclEntryArrayOutput{})
	pulumi.RegisterOutputType(ClusterCapacityConfigOutput{})
	pulumi.RegisterOutputType(ClusterCapacityConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigTrustConfigOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigTrustConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigTrustConfigCasConfigOutput{})
	pulumi.RegisterOutputType(ClusterTlsConfigTrustConfigCasConfigArrayOutput{})
	pulumi.RegisterOutputType(ConnectClusterCapacityConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterCapacityConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput{})
	pulumi.RegisterOutputType(ConnectorTaskRestartPolicyOutput{})
	pulumi.RegisterOutputType(ConnectorTaskRestartPolicyPtrOutput{})
}
