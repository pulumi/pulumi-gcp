// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package managedkafka

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type ClusterCapacityConfig struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	//
	// ***
	MemoryBytes string `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount string `pulumi:"vcpuCount"`
}

// ClusterCapacityConfigInput is an input type that accepts ClusterCapacityConfigArgs and ClusterCapacityConfigOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigInput` via:
//
//	ClusterCapacityConfigArgs{...}
type ClusterCapacityConfigInput interface {
	pulumi.Input

	ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput
	ToClusterCapacityConfigOutputWithContext(context.Context) ClusterCapacityConfigOutput
}

type ClusterCapacityConfigArgs struct {
	// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
	//
	// ***
	MemoryBytes pulumi.StringInput `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount pulumi.StringInput `pulumi:"vcpuCount"`
}

func (ClusterCapacityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return i.ToClusterCapacityConfigOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput)
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i ClusterCapacityConfigArgs) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigOutput).ToClusterCapacityConfigPtrOutputWithContext(ctx)
}

// ClusterCapacityConfigPtrInput is an input type that accepts ClusterCapacityConfigArgs, ClusterCapacityConfigPtr and ClusterCapacityConfigPtrOutput values.
// You can construct a concrete instance of `ClusterCapacityConfigPtrInput` via:
//
//	        ClusterCapacityConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterCapacityConfigPtrInput interface {
	pulumi.Input

	ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput
	ToClusterCapacityConfigPtrOutputWithContext(context.Context) ClusterCapacityConfigPtrOutput
}

type clusterCapacityConfigPtrType ClusterCapacityConfigArgs

func ClusterCapacityConfigPtr(v *ClusterCapacityConfigArgs) ClusterCapacityConfigPtrInput {
	return (*clusterCapacityConfigPtrType)(v)
}

func (*clusterCapacityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return i.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i *clusterCapacityConfigPtrType) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCapacityConfigPtrOutput)
}

type ClusterCapacityConfigOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutput() ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigOutputWithContext(ctx context.Context) ClusterCapacityConfigOutput {
	return o
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o.ToClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (o ClusterCapacityConfigOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterCapacityConfig) *ClusterCapacityConfig {
		return &v
	}).(ClusterCapacityConfigPtrOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
//
// ***
func (o ClusterCapacityConfigOutput) MemoryBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.MemoryBytes }).(pulumi.StringOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigOutput) VcpuCount() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCapacityConfig) string { return v.VcpuCount }).(pulumi.StringOutput)
}

type ClusterCapacityConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterCapacityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCapacityConfig)(nil)).Elem()
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutput() ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) ToClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ClusterCapacityConfigPtrOutput {
	return o
}

func (o ClusterCapacityConfigPtrOutput) Elem() ClusterCapacityConfigOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) ClusterCapacityConfig {
		if v != nil {
			return *v
		}
		var ret ClusterCapacityConfig
		return ret
	}).(ClusterCapacityConfigOutput)
}

// The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
//
// ***
func (o ClusterCapacityConfigPtrOutput) MemoryBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MemoryBytes
	}).(pulumi.StringPtrOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ClusterCapacityConfigPtrOutput) VcpuCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.VcpuCount
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfig struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfig `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey *string `pulumi:"kmsKey"`
}

// ClusterGcpConfigInput is an input type that accepts ClusterGcpConfigArgs and ClusterGcpConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigInput` via:
//
//	ClusterGcpConfigArgs{...}
type ClusterGcpConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigOutput() ClusterGcpConfigOutput
	ToClusterGcpConfigOutputWithContext(context.Context) ClusterGcpConfigOutput
}

type ClusterGcpConfigArgs struct {
	// The configuration of access to the Kafka cluster.
	// Structure is documented below.
	AccessConfig ClusterGcpConfigAccessConfigInput `pulumi:"accessConfig"`
	// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
	KmsKey pulumi.StringPtrInput `pulumi:"kmsKey"`
}

func (ClusterGcpConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return i.ToClusterGcpConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput)
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigArgs) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigOutput).ToClusterGcpConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigPtrInput is an input type that accepts ClusterGcpConfigArgs, ClusterGcpConfigPtr and ClusterGcpConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigPtrInput` via:
//
//	        ClusterGcpConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput
	ToClusterGcpConfigPtrOutputWithContext(context.Context) ClusterGcpConfigPtrOutput
}

type clusterGcpConfigPtrType ClusterGcpConfigArgs

func ClusterGcpConfigPtr(v *ClusterGcpConfigArgs) ClusterGcpConfigPtrInput {
	return (*clusterGcpConfigPtrType)(v)
}

func (*clusterGcpConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return i.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigPtrType) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigPtrOutput)
}

type ClusterGcpConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutput() ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigOutputWithContext(ctx context.Context) ClusterGcpConfigOutput {
	return o
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o.ToClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfig) *ClusterGcpConfig {
		return &v
	}).(ClusterGcpConfigPtrOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigOutput) AccessConfig() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v ClusterGcpConfig) ClusterGcpConfigAccessConfig { return v.AccessConfig }).(ClusterGcpConfigAccessConfigOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterGcpConfig) *string { return v.KmsKey }).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfig)(nil)).Elem()
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutput() ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) ToClusterGcpConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigPtrOutput) Elem() ClusterGcpConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) ClusterGcpConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfig
		return ret
	}).(ClusterGcpConfigOutput)
}

// The configuration of access to the Kafka cluster.
// Structure is documented below.
func (o ClusterGcpConfigPtrOutput) AccessConfig() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *ClusterGcpConfigAccessConfig {
		if v == nil {
			return nil
		}
		return &v.AccessConfig
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
func (o ClusterGcpConfigPtrOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterGcpConfig) *string {
		if v == nil {
			return nil
		}
		return v.KmsKey
	}).(pulumi.StringPtrOutput)
}

type ClusterGcpConfigAccessConfig struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs []ClusterGcpConfigAccessConfigNetworkConfig `pulumi:"networkConfigs"`
}

// ClusterGcpConfigAccessConfigInput is an input type that accepts ClusterGcpConfigAccessConfigArgs and ClusterGcpConfigAccessConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigInput` via:
//
//	ClusterGcpConfigAccessConfigArgs{...}
type ClusterGcpConfigAccessConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput
	ToClusterGcpConfigAccessConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigOutput
}

type ClusterGcpConfigAccessConfigArgs struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs ClusterGcpConfigAccessConfigNetworkConfigArrayInput `pulumi:"networkConfigs"`
}

func (ClusterGcpConfigAccessConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return i.ToClusterGcpConfigAccessConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput)
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigArgs) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigOutput).ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx)
}

// ClusterGcpConfigAccessConfigPtrInput is an input type that accepts ClusterGcpConfigAccessConfigArgs, ClusterGcpConfigAccessConfigPtr and ClusterGcpConfigAccessConfigPtrOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigPtrInput` via:
//
//	        ClusterGcpConfigAccessConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterGcpConfigAccessConfigPtrInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput
	ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Context) ClusterGcpConfigAccessConfigPtrOutput
}

type clusterGcpConfigAccessConfigPtrType ClusterGcpConfigAccessConfigArgs

func ClusterGcpConfigAccessConfigPtr(v *ClusterGcpConfigAccessConfigArgs) ClusterGcpConfigAccessConfigPtrInput {
	return (*clusterGcpConfigAccessConfigPtrType)(v)
}

func (*clusterGcpConfigAccessConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return i.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i *clusterGcpConfigAccessConfigPtrType) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigPtrOutput)
}

type ClusterGcpConfigAccessConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutput() ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o.ToClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (o ClusterGcpConfigAccessConfigOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterGcpConfigAccessConfig) *ClusterGcpConfigAccessConfig {
		return &v
	}).(ClusterGcpConfigAccessConfigPtrOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutput() ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) ToClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigPtrOutput) Elem() ClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) ClusterGcpConfigAccessConfig {
		if v != nil {
			return *v
		}
		var ret ClusterGcpConfigAccessConfig
		return ret
	}).(ClusterGcpConfigAccessConfigOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ClusterGcpConfigAccessConfigPtrOutput) NetworkConfigs() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v *ClusterGcpConfigAccessConfig) []ClusterGcpConfigAccessConfigNetworkConfig {
		if v == nil {
			return nil
		}
		return v.NetworkConfigs
	}).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfig struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet string `pulumi:"subnet"`
}

// ClusterGcpConfigAccessConfigNetworkConfigInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArgs and ClusterGcpConfigAccessConfigNetworkConfigOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArgs{...}
type ClusterGcpConfigAccessConfigNetworkConfigInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput
	ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArgs struct {
	// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
	Subnet pulumi.StringInput `pulumi:"subnet"`
}

func (ClusterGcpConfigAccessConfigNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArgs) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

// ClusterGcpConfigAccessConfigNetworkConfigArrayInput is an input type that accepts ClusterGcpConfigAccessConfigNetworkConfigArray and ClusterGcpConfigAccessConfigNetworkConfigArrayOutput values.
// You can construct a concrete instance of `ClusterGcpConfigAccessConfigNetworkConfigArrayInput` via:
//
//	ClusterGcpConfigAccessConfigNetworkConfigArray{ ClusterGcpConfigAccessConfigNetworkConfigArgs{...} }
type ClusterGcpConfigAccessConfigNetworkConfigArrayInput interface {
	pulumi.Input

	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
	ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput
}

type ClusterGcpConfigAccessConfigNetworkConfigArray []ClusterGcpConfigAccessConfigNetworkConfigInput

func (ClusterGcpConfigAccessConfigNetworkConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return i.ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Background())
}

func (i ClusterGcpConfigAccessConfigNetworkConfigArray) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutput() ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) ToClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

// Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
func (o ClusterGcpConfigAccessConfigNetworkConfigOutput) Subnet() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterGcpConfigAccessConfigNetworkConfig) string { return v.Subnet }).(pulumi.StringOutput)
}

type ClusterGcpConfigAccessConfigNetworkConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ClusterGcpConfigAccessConfigNetworkConfigArrayOutput) Index(i pulumi.IntInput) ClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterGcpConfigAccessConfigNetworkConfig {
		return vs[0].([]ClusterGcpConfigAccessConfigNetworkConfig)[vs[1].(int)]
	}).(ClusterGcpConfigAccessConfigNetworkConfigOutput)
}

type ClusterRebalanceConfig struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode *string `pulumi:"mode"`
}

// ClusterRebalanceConfigInput is an input type that accepts ClusterRebalanceConfigArgs and ClusterRebalanceConfigOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigInput` via:
//
//	ClusterRebalanceConfigArgs{...}
type ClusterRebalanceConfigInput interface {
	pulumi.Input

	ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput
	ToClusterRebalanceConfigOutputWithContext(context.Context) ClusterRebalanceConfigOutput
}

type ClusterRebalanceConfigArgs struct {
	// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
	Mode pulumi.StringPtrInput `pulumi:"mode"`
}

func (ClusterRebalanceConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return i.ToClusterRebalanceConfigOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput)
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i ClusterRebalanceConfigArgs) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigOutput).ToClusterRebalanceConfigPtrOutputWithContext(ctx)
}

// ClusterRebalanceConfigPtrInput is an input type that accepts ClusterRebalanceConfigArgs, ClusterRebalanceConfigPtr and ClusterRebalanceConfigPtrOutput values.
// You can construct a concrete instance of `ClusterRebalanceConfigPtrInput` via:
//
//	        ClusterRebalanceConfigArgs{...}
//
//	or:
//
//	        nil
type ClusterRebalanceConfigPtrInput interface {
	pulumi.Input

	ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput
	ToClusterRebalanceConfigPtrOutputWithContext(context.Context) ClusterRebalanceConfigPtrOutput
}

type clusterRebalanceConfigPtrType ClusterRebalanceConfigArgs

func ClusterRebalanceConfigPtr(v *ClusterRebalanceConfigArgs) ClusterRebalanceConfigPtrInput {
	return (*clusterRebalanceConfigPtrType)(v)
}

func (*clusterRebalanceConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return i.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (i *clusterRebalanceConfigPtrType) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterRebalanceConfigPtrOutput)
}

type ClusterRebalanceConfigOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutput() ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigOutputWithContext(ctx context.Context) ClusterRebalanceConfigOutput {
	return o
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o.ToClusterRebalanceConfigPtrOutputWithContext(context.Background())
}

func (o ClusterRebalanceConfigOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterRebalanceConfig) *ClusterRebalanceConfig {
		return &v
	}).(ClusterRebalanceConfigPtrOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterRebalanceConfig) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

type ClusterRebalanceConfigPtrOutput struct{ *pulumi.OutputState }

func (ClusterRebalanceConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterRebalanceConfig)(nil)).Elem()
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutput() ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) ToClusterRebalanceConfigPtrOutputWithContext(ctx context.Context) ClusterRebalanceConfigPtrOutput {
	return o
}

func (o ClusterRebalanceConfigPtrOutput) Elem() ClusterRebalanceConfigOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) ClusterRebalanceConfig {
		if v != nil {
			return *v
		}
		var ret ClusterRebalanceConfig
		return ret
	}).(ClusterRebalanceConfigOutput)
}

// The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
func (o ClusterRebalanceConfigPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterRebalanceConfig) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

type ConnectClusterCapacityConfig struct {
	// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
	MemoryBytes string `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount string `pulumi:"vcpuCount"`
}

// ConnectClusterCapacityConfigInput is an input type that accepts ConnectClusterCapacityConfigArgs and ConnectClusterCapacityConfigOutput values.
// You can construct a concrete instance of `ConnectClusterCapacityConfigInput` via:
//
//	ConnectClusterCapacityConfigArgs{...}
type ConnectClusterCapacityConfigInput interface {
	pulumi.Input

	ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput
	ToConnectClusterCapacityConfigOutputWithContext(context.Context) ConnectClusterCapacityConfigOutput
}

type ConnectClusterCapacityConfigArgs struct {
	// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
	MemoryBytes pulumi.StringInput `pulumi:"memoryBytes"`
	// The number of vCPUs to provision for the cluster. The minimum is 3.
	VcpuCount pulumi.StringInput `pulumi:"vcpuCount"`
}

func (ConnectClusterCapacityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterCapacityConfig)(nil)).Elem()
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput {
	return i.ToConnectClusterCapacityConfigOutputWithContext(context.Background())
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigOutput)
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return i.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterCapacityConfigArgs) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigOutput).ToConnectClusterCapacityConfigPtrOutputWithContext(ctx)
}

// ConnectClusterCapacityConfigPtrInput is an input type that accepts ConnectClusterCapacityConfigArgs, ConnectClusterCapacityConfigPtr and ConnectClusterCapacityConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterCapacityConfigPtrInput` via:
//
//	        ConnectClusterCapacityConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterCapacityConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput
	ToConnectClusterCapacityConfigPtrOutputWithContext(context.Context) ConnectClusterCapacityConfigPtrOutput
}

type connectClusterCapacityConfigPtrType ConnectClusterCapacityConfigArgs

func ConnectClusterCapacityConfigPtr(v *ConnectClusterCapacityConfigArgs) ConnectClusterCapacityConfigPtrInput {
	return (*connectClusterCapacityConfigPtrType)(v)
}

func (*connectClusterCapacityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterCapacityConfig)(nil)).Elem()
}

func (i *connectClusterCapacityConfigPtrType) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return i.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterCapacityConfigPtrType) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterCapacityConfigPtrOutput)
}

type ConnectClusterCapacityConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterCapacityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterCapacityConfig)(nil)).Elem()
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigOutput() ConnectClusterCapacityConfigOutput {
	return o
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigOutput {
	return o
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return o.ToConnectClusterCapacityConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterCapacityConfigOutput) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterCapacityConfig) *ConnectClusterCapacityConfig {
		return &v
	}).(ConnectClusterCapacityConfigPtrOutput)
}

// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
func (o ConnectClusterCapacityConfigOutput) MemoryBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterCapacityConfig) string { return v.MemoryBytes }).(pulumi.StringOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ConnectClusterCapacityConfigOutput) VcpuCount() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterCapacityConfig) string { return v.VcpuCount }).(pulumi.StringOutput)
}

type ConnectClusterCapacityConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterCapacityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterCapacityConfig)(nil)).Elem()
}

func (o ConnectClusterCapacityConfigPtrOutput) ToConnectClusterCapacityConfigPtrOutput() ConnectClusterCapacityConfigPtrOutput {
	return o
}

func (o ConnectClusterCapacityConfigPtrOutput) ToConnectClusterCapacityConfigPtrOutputWithContext(ctx context.Context) ConnectClusterCapacityConfigPtrOutput {
	return o
}

func (o ConnectClusterCapacityConfigPtrOutput) Elem() ConnectClusterCapacityConfigOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) ConnectClusterCapacityConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterCapacityConfig
		return ret
	}).(ConnectClusterCapacityConfigOutput)
}

// The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
func (o ConnectClusterCapacityConfigPtrOutput) MemoryBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MemoryBytes
	}).(pulumi.StringPtrOutput)
}

// The number of vCPUs to provision for the cluster. The minimum is 3.
func (o ConnectClusterCapacityConfigPtrOutput) VcpuCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectClusterCapacityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.VcpuCount
	}).(pulumi.StringPtrOutput)
}

type ConnectClusterGcpConfig struct {
	// The configuration of access to the Kafka Connect cluster.
	// Structure is documented below.
	AccessConfig ConnectClusterGcpConfigAccessConfig `pulumi:"accessConfig"`
}

// ConnectClusterGcpConfigInput is an input type that accepts ConnectClusterGcpConfigArgs and ConnectClusterGcpConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigInput` via:
//
//	ConnectClusterGcpConfigArgs{...}
type ConnectClusterGcpConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput
	ToConnectClusterGcpConfigOutputWithContext(context.Context) ConnectClusterGcpConfigOutput
}

type ConnectClusterGcpConfigArgs struct {
	// The configuration of access to the Kafka Connect cluster.
	// Structure is documented below.
	AccessConfig ConnectClusterGcpConfigAccessConfigInput `pulumi:"accessConfig"`
}

func (ConnectClusterGcpConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput {
	return i.ToConnectClusterGcpConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigOutput)
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return i.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigArgs) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigOutput).ToConnectClusterGcpConfigPtrOutputWithContext(ctx)
}

// ConnectClusterGcpConfigPtrInput is an input type that accepts ConnectClusterGcpConfigArgs, ConnectClusterGcpConfigPtr and ConnectClusterGcpConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigPtrInput` via:
//
//	        ConnectClusterGcpConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterGcpConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput
	ToConnectClusterGcpConfigPtrOutputWithContext(context.Context) ConnectClusterGcpConfigPtrOutput
}

type connectClusterGcpConfigPtrType ConnectClusterGcpConfigArgs

func ConnectClusterGcpConfigPtr(v *ConnectClusterGcpConfigArgs) ConnectClusterGcpConfigPtrInput {
	return (*connectClusterGcpConfigPtrType)(v)
}

func (*connectClusterGcpConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfig)(nil)).Elem()
}

func (i *connectClusterGcpConfigPtrType) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return i.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterGcpConfigPtrType) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigPtrOutput)
}

type ConnectClusterGcpConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigOutput() ConnectClusterGcpConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return o.ToConnectClusterGcpConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterGcpConfigOutput) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterGcpConfig) *ConnectClusterGcpConfig {
		return &v
	}).(ConnectClusterGcpConfigPtrOutput)
}

// The configuration of access to the Kafka Connect cluster.
// Structure is documented below.
func (o ConnectClusterGcpConfigOutput) AccessConfig() ConnectClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfig) ConnectClusterGcpConfigAccessConfig { return v.AccessConfig }).(ConnectClusterGcpConfigAccessConfigOutput)
}

type ConnectClusterGcpConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigPtrOutput) ToConnectClusterGcpConfigPtrOutput() ConnectClusterGcpConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigPtrOutput) ToConnectClusterGcpConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigPtrOutput) Elem() ConnectClusterGcpConfigOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfig) ConnectClusterGcpConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterGcpConfig
		return ret
	}).(ConnectClusterGcpConfigOutput)
}

// The configuration of access to the Kafka Connect cluster.
// Structure is documented below.
func (o ConnectClusterGcpConfigPtrOutput) AccessConfig() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfig) *ConnectClusterGcpConfigAccessConfig {
		if v == nil {
			return nil
		}
		return &v.AccessConfig
	}).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

type ConnectClusterGcpConfigAccessConfig struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs []ConnectClusterGcpConfigAccessConfigNetworkConfig `pulumi:"networkConfigs"`
}

// ConnectClusterGcpConfigAccessConfigInput is an input type that accepts ConnectClusterGcpConfigAccessConfigArgs and ConnectClusterGcpConfigAccessConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigInput` via:
//
//	ConnectClusterGcpConfigAccessConfigArgs{...}
type ConnectClusterGcpConfigAccessConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput
	ToConnectClusterGcpConfigAccessConfigOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigOutput
}

type ConnectClusterGcpConfigAccessConfigArgs struct {
	// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
	// Structure is documented below.
	NetworkConfigs ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput `pulumi:"networkConfigs"`
}

func (ConnectClusterGcpConfigAccessConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput {
	return i.ToConnectClusterGcpConfigAccessConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigOutput)
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return i.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigArgs) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigOutput).ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx)
}

// ConnectClusterGcpConfigAccessConfigPtrInput is an input type that accepts ConnectClusterGcpConfigAccessConfigArgs, ConnectClusterGcpConfigAccessConfigPtr and ConnectClusterGcpConfigAccessConfigPtrOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigPtrInput` via:
//
//	        ConnectClusterGcpConfigAccessConfigArgs{...}
//
//	or:
//
//	        nil
type ConnectClusterGcpConfigAccessConfigPtrInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput
	ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput
}

type connectClusterGcpConfigAccessConfigPtrType ConnectClusterGcpConfigAccessConfigArgs

func ConnectClusterGcpConfigAccessConfigPtr(v *ConnectClusterGcpConfigAccessConfigArgs) ConnectClusterGcpConfigAccessConfigPtrInput {
	return (*connectClusterGcpConfigAccessConfigPtrType)(v)
}

func (*connectClusterGcpConfigAccessConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (i *connectClusterGcpConfigAccessConfigPtrType) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return i.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (i *connectClusterGcpConfigAccessConfigPtrType) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

type ConnectClusterGcpConfigAccessConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigOutput() ConnectClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(context.Background())
}

func (o ConnectClusterGcpConfigAccessConfigOutput) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectClusterGcpConfigAccessConfig) *ConnectClusterGcpConfigAccessConfig {
		return &v
	}).(ConnectClusterGcpConfigAccessConfigPtrOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ConnectClusterGcpConfigAccessConfigOutput) NetworkConfigs() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfig) []ConnectClusterGcpConfigAccessConfigNetworkConfig {
		return v.NetworkConfigs
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigPtrOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectClusterGcpConfigAccessConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) ToConnectClusterGcpConfigAccessConfigPtrOutput() ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) ToConnectClusterGcpConfigAccessConfigPtrOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigPtrOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigPtrOutput) Elem() ConnectClusterGcpConfigAccessConfigOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfigAccessConfig) ConnectClusterGcpConfigAccessConfig {
		if v != nil {
			return *v
		}
		var ret ConnectClusterGcpConfigAccessConfig
		return ret
	}).(ConnectClusterGcpConfigAccessConfigOutput)
}

// Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
// Structure is documented below.
func (o ConnectClusterGcpConfigAccessConfigPtrOutput) NetworkConfigs() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o.ApplyT(func(v *ConnectClusterGcpConfigAccessConfig) []ConnectClusterGcpConfigAccessConfigNetworkConfig {
		if v == nil {
			return nil
		}
		return v.NetworkConfigs
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfig struct {
	// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
	AdditionalSubnets []string `pulumi:"additionalSubnets"`
	// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
	//
	// ***
	DnsDomainNames []string `pulumi:"dnsDomainNames"`
	// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
	PrimarySubnet string `pulumi:"primarySubnet"`
}

// ConnectClusterGcpConfigAccessConfigNetworkConfigInput is an input type that accepts ConnectClusterGcpConfigAccessConfigNetworkConfigArgs and ConnectClusterGcpConfigAccessConfigNetworkConfigOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigNetworkConfigInput` via:
//
//	ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{...}
type ConnectClusterGcpConfigAccessConfigNetworkConfigInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput
	ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArgs struct {
	// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
	AdditionalSubnets pulumi.StringArrayInput `pulumi:"additionalSubnets"`
	// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
	//
	// ***
	DnsDomainNames pulumi.StringArrayInput `pulumi:"dnsDomainNames"`
	// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
	PrimarySubnet pulumi.StringInput `pulumi:"primarySubnet"`
}

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return i.ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArgs) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput)
}

// ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput is an input type that accepts ConnectClusterGcpConfigAccessConfigNetworkConfigArray and ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput values.
// You can construct a concrete instance of `ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput` via:
//
//	ConnectClusterGcpConfigAccessConfigNetworkConfigArray{ ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{...} }
type ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput interface {
	pulumi.Input

	ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput
	ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArray []ConnectClusterGcpConfigAccessConfigNetworkConfigInput

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return i.ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(context.Background())
}

func (i ConnectClusterGcpConfigAccessConfigNetworkConfigArray) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return o
}

// Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) AdditionalSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) []string { return v.AdditionalSubnets }).(pulumi.StringArrayOutput)
}

// Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
//
// ***
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) DnsDomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) []string { return v.DnsDomainNames }).(pulumi.StringArrayOutput)
}

// VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
func (o ConnectClusterGcpConfigAccessConfigNetworkConfigOutput) PrimarySubnet() pulumi.StringOutput {
	return o.ApplyT(func(v ConnectClusterGcpConfigAccessConfigNetworkConfig) string { return v.PrimarySubnet }).(pulumi.StringOutput)
}

type ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput struct{ *pulumi.OutputState }

func (ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConnectClusterGcpConfigAccessConfigNetworkConfig)(nil)).Elem()
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput() ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) ToConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutputWithContext(ctx context.Context) ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput {
	return o
}

func (o ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput) Index(i pulumi.IntInput) ConnectClusterGcpConfigAccessConfigNetworkConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConnectClusterGcpConfigAccessConfigNetworkConfig {
		return vs[0].([]ConnectClusterGcpConfigAccessConfigNetworkConfig)[vs[1].(int)]
	}).(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput)
}

type ConnectorTaskRestartPolicy struct {
	// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff *string `pulumi:"maximumBackoff"`
	// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff *string `pulumi:"minimumBackoff"`
}

// ConnectorTaskRestartPolicyInput is an input type that accepts ConnectorTaskRestartPolicyArgs and ConnectorTaskRestartPolicyOutput values.
// You can construct a concrete instance of `ConnectorTaskRestartPolicyInput` via:
//
//	ConnectorTaskRestartPolicyArgs{...}
type ConnectorTaskRestartPolicyInput interface {
	pulumi.Input

	ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput
	ToConnectorTaskRestartPolicyOutputWithContext(context.Context) ConnectorTaskRestartPolicyOutput
}

type ConnectorTaskRestartPolicyArgs struct {
	// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MaximumBackoff pulumi.StringPtrInput `pulumi:"maximumBackoff"`
	// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	MinimumBackoff pulumi.StringPtrInput `pulumi:"minimumBackoff"`
}

func (ConnectorTaskRestartPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput {
	return i.ToConnectorTaskRestartPolicyOutputWithContext(context.Background())
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyOutput)
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return i.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (i ConnectorTaskRestartPolicyArgs) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyOutput).ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx)
}

// ConnectorTaskRestartPolicyPtrInput is an input type that accepts ConnectorTaskRestartPolicyArgs, ConnectorTaskRestartPolicyPtr and ConnectorTaskRestartPolicyPtrOutput values.
// You can construct a concrete instance of `ConnectorTaskRestartPolicyPtrInput` via:
//
//	        ConnectorTaskRestartPolicyArgs{...}
//
//	or:
//
//	        nil
type ConnectorTaskRestartPolicyPtrInput interface {
	pulumi.Input

	ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput
	ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Context) ConnectorTaskRestartPolicyPtrOutput
}

type connectorTaskRestartPolicyPtrType ConnectorTaskRestartPolicyArgs

func ConnectorTaskRestartPolicyPtr(v *ConnectorTaskRestartPolicyArgs) ConnectorTaskRestartPolicyPtrInput {
	return (*connectorTaskRestartPolicyPtrType)(v)
}

func (*connectorTaskRestartPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (i *connectorTaskRestartPolicyPtrType) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return i.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (i *connectorTaskRestartPolicyPtrType) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorTaskRestartPolicyPtrOutput)
}

type ConnectorTaskRestartPolicyOutput struct{ *pulumi.OutputState }

func (ConnectorTaskRestartPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyOutput() ConnectorTaskRestartPolicyOutput {
	return o
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyOutput {
	return o
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return o.ToConnectorTaskRestartPolicyPtrOutputWithContext(context.Background())
}

func (o ConnectorTaskRestartPolicyOutput) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConnectorTaskRestartPolicy) *ConnectorTaskRestartPolicy {
		return &v
	}).(ConnectorTaskRestartPolicyPtrOutput)
}

// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyOutput) MaximumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConnectorTaskRestartPolicy) *string { return v.MaximumBackoff }).(pulumi.StringPtrOutput)
}

// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyOutput) MinimumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConnectorTaskRestartPolicy) *string { return v.MinimumBackoff }).(pulumi.StringPtrOutput)
}

type ConnectorTaskRestartPolicyPtrOutput struct{ *pulumi.OutputState }

func (ConnectorTaskRestartPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorTaskRestartPolicy)(nil)).Elem()
}

func (o ConnectorTaskRestartPolicyPtrOutput) ToConnectorTaskRestartPolicyPtrOutput() ConnectorTaskRestartPolicyPtrOutput {
	return o
}

func (o ConnectorTaskRestartPolicyPtrOutput) ToConnectorTaskRestartPolicyPtrOutputWithContext(ctx context.Context) ConnectorTaskRestartPolicyPtrOutput {
	return o
}

func (o ConnectorTaskRestartPolicyPtrOutput) Elem() ConnectorTaskRestartPolicyOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) ConnectorTaskRestartPolicy {
		if v != nil {
			return *v
		}
		var ret ConnectorTaskRestartPolicy
		return ret
	}).(ConnectorTaskRestartPolicyOutput)
}

// The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyPtrOutput) MaximumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) *string {
		if v == nil {
			return nil
		}
		return v.MaximumBackoff
	}).(pulumi.StringPtrOutput)
}

// The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
func (o ConnectorTaskRestartPolicyPtrOutput) MinimumBackoff() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectorTaskRestartPolicy) *string {
		if v == nil {
			return nil
		}
		return v.MinimumBackoff
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterCapacityConfigPtrInput)(nil)).Elem(), ClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigPtrInput)(nil)).Elem(), ClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigPtrInput)(nil)).Elem(), ClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterGcpConfigAccessConfigNetworkConfigArrayInput)(nil)).Elem(), ClusterGcpConfigAccessConfigNetworkConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterRebalanceConfigPtrInput)(nil)).Elem(), ClusterRebalanceConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterCapacityConfigInput)(nil)).Elem(), ConnectClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterCapacityConfigPtrInput)(nil)).Elem(), ConnectClusterCapacityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigInput)(nil)).Elem(), ConnectClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigPtrInput)(nil)).Elem(), ConnectClusterGcpConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigPtrInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfigInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectClusterGcpConfigAccessConfigNetworkConfigArrayInput)(nil)).Elem(), ConnectClusterGcpConfigAccessConfigNetworkConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorTaskRestartPolicyInput)(nil)).Elem(), ConnectorTaskRestartPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorTaskRestartPolicyPtrInput)(nil)).Elem(), ConnectorTaskRestartPolicyArgs{})
	pulumi.RegisterOutputType(ClusterCapacityConfigOutput{})
	pulumi.RegisterOutputType(ClusterCapacityConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigPtrOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigOutput{})
	pulumi.RegisterOutputType(ClusterGcpConfigAccessConfigNetworkConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigOutput{})
	pulumi.RegisterOutputType(ClusterRebalanceConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterCapacityConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterCapacityConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigPtrOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigNetworkConfigOutput{})
	pulumi.RegisterOutputType(ConnectClusterGcpConfigAccessConfigNetworkConfigArrayOutput{})
	pulumi.RegisterOutputType(ConnectorTaskRestartPolicyOutput{})
	pulumi.RegisterOutputType(ConnectorTaskRestartPolicyPtrOutput{})
}
