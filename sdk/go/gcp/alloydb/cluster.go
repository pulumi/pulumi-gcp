// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package alloydb

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A managed alloydb cluster.
//
// To get more information about Cluster, see:
//
// * [API documentation](https://cloud.google.com/alloydb/docs/reference/rest/v1/projects.locations.clusters/create)
// * How-to Guides
//   - [AlloyDB](https://cloud.google.com/alloydb/docs/)
//
// > **Note:** Users can promote a secondary cluster to a primary cluster with the help of `clusterType`.
// To promote, users have to set the `clusterType` property as `PRIMARY` and remove the `secondaryConfig` field from cluster configuration.
// See Example.
//
// Switchover is supported in terraform by refreshing the state of the terraform configurations.
// The switchover operation still needs to be called outside of terraform.
// After the switchover operation is completed successfully:
//  1. Refresh the state of the AlloyDB resources by running `pulumi up -refresh-only --auto-approve` .
//  2. Manually update the terraform configuration file(s) to match the actual state of the resources by modifying the `clusterType` and `secondaryConfig` fields.
//  3. Verify the sync of terraform state by running `pulumi preview` and ensure that the infrastructure matches the configuration and no changes are required.
//
// ## Example Usage
//
// ### Alloydb Cluster Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
//				Name: pulumi.String("alloydb-cluster"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewCluster(ctx, "default", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-cluster"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: defaultNetwork.ID(),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Alloydb Cluster Before Upgrade
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
//				Name: "alloydb-network",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultCluster, err := alloydb.NewCluster(ctx, "default", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-cluster"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: pulumi.String(_default.Id),
//				},
//				DatabaseVersion: pulumi.String("POSTGRES_14"),
//				InitialUser: &alloydb.ClusterInitialUserArgs{
//					Password: pulumi.String("alloydb-cluster"),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewInstance(ctx, "default", &alloydb.InstanceArgs{
//				Cluster:      defaultCluster.Name,
//				InstanceId:   pulumi.String("alloydb-instance"),
//				InstanceType: pulumi.String("PRIMARY"),
//				MachineConfig: &alloydb.InstanceMachineConfigArgs{
//					CpuCount: pulumi.Int(2),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Alloydb Cluster After Upgrade
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
//				Name: "alloydb-network",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			defaultCluster, err := alloydb.NewCluster(ctx, "default", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-cluster"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: pulumi.String(_default.Id),
//				},
//				DatabaseVersion: pulumi.String("POSTGRES_15"),
//				InitialUser: &alloydb.ClusterInitialUserArgs{
//					Password: pulumi.String("alloydb-cluster"),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewInstance(ctx, "default", &alloydb.InstanceArgs{
//				Cluster:      defaultCluster.Name,
//				InstanceId:   pulumi.String("alloydb-instance"),
//				InstanceType: pulumi.String("PRIMARY"),
//				MachineConfig: &alloydb.InstanceMachineConfigArgs{
//					CpuCount: pulumi.Int(2),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Alloydb Cluster Full
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
//				Name: pulumi.String("alloydb-cluster-full"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewCluster(ctx, "full", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-cluster-full"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: _default.ID(),
//				},
//				DatabaseVersion: pulumi.String("POSTGRES_15"),
//				InitialUser: &alloydb.ClusterInitialUserArgs{
//					User:     pulumi.String("alloydb-cluster-full"),
//					Password: pulumi.String("alloydb-cluster-full"),
//				},
//				ContinuousBackupConfig: &alloydb.ClusterContinuousBackupConfigArgs{
//					Enabled:            pulumi.Bool(true),
//					RecoveryWindowDays: pulumi.Int(14),
//				},
//				AutomatedBackupPolicy: &alloydb.ClusterAutomatedBackupPolicyArgs{
//					Location:     pulumi.String("us-central1"),
//					BackupWindow: pulumi.String("1800s"),
//					Enabled:      pulumi.Bool(true),
//					WeeklySchedule: &alloydb.ClusterAutomatedBackupPolicyWeeklyScheduleArgs{
//						DaysOfWeeks: pulumi.StringArray{
//							pulumi.String("MONDAY"),
//						},
//						StartTimes: alloydb.ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArray{
//							&alloydb.ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs{
//								Hours:   pulumi.Int(23),
//								Minutes: pulumi.Int(0),
//								Seconds: pulumi.Int(0),
//								Nanos:   pulumi.Int(0),
//							},
//						},
//					},
//					QuantityBasedRetention: &alloydb.ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs{
//						Count: pulumi.Int(1),
//					},
//					Labels: pulumi.StringMap{
//						"test": pulumi.String("alloydb-cluster-full"),
//					},
//				},
//				Labels: pulumi.StringMap{
//					"test": pulumi.String("alloydb-cluster-full"),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Alloydb Cluster Restore
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/servicenetworking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
//				Name: "alloydb-network",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			source, err := alloydb.NewCluster(ctx, "source", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-source-cluster"),
//				Location:  pulumi.String("us-central1"),
//				Network:   _default.Id,
//				InitialUser: &alloydb.ClusterInitialUserArgs{
//					Password: pulumi.String("alloydb-source-cluster"),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			privateIpAlloc, err := compute.NewGlobalAddress(ctx, "private_ip_alloc", &compute.GlobalAddressArgs{
//				Name:         pulumi.String("alloydb-source-cluster"),
//				AddressType:  pulumi.String("INTERNAL"),
//				Purpose:      pulumi.String("VPC_PEERING"),
//				PrefixLength: pulumi.Int(16),
//				Network:      pulumi.String(_default.Id),
//			})
//			if err != nil {
//				return err
//			}
//			vpcConnection, err := servicenetworking.NewConnection(ctx, "vpc_connection", &servicenetworking.ConnectionArgs{
//				Network: pulumi.String(_default.Id),
//				Service: pulumi.String("servicenetworking.googleapis.com"),
//				ReservedPeeringRanges: pulumi.StringArray{
//					privateIpAlloc.Name,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			sourceInstance, err := alloydb.NewInstance(ctx, "source", &alloydb.InstanceArgs{
//				Cluster:      source.Name,
//				InstanceId:   pulumi.String("alloydb-instance"),
//				InstanceType: pulumi.String("PRIMARY"),
//				MachineConfig: &alloydb.InstanceMachineConfigArgs{
//					CpuCount: pulumi.Int(2),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				vpcConnection,
//			}))
//			if err != nil {
//				return err
//			}
//			sourceBackup, err := alloydb.NewBackup(ctx, "source", &alloydb.BackupArgs{
//				BackupId:    pulumi.String("alloydb-backup"),
//				Location:    pulumi.String("us-central1"),
//				ClusterName: source.Name,
//			}, pulumi.DependsOn([]pulumi.Resource{
//				sourceInstance,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewCluster(ctx, "restored_from_backup", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-backup-restored"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: pulumi.String(_default.Id),
//				},
//				RestoreBackupSource: &alloydb.ClusterRestoreBackupSourceArgs{
//					BackupName: sourceBackup.Name,
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewCluster(ctx, "restored_via_pitr", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-pitr-restored"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: pulumi.String(_default.Id),
//				},
//				RestoreContinuousBackupSource: &alloydb.ClusterRestoreContinuousBackupSourceArgs{
//					Cluster:     source.Name,
//					PointInTime: pulumi.String("2023-08-03T19:19:00.094Z"),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Alloydb Secondary Cluster Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/alloydb"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/servicenetworking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
//				Name: pulumi.String("alloydb-secondary-cluster"),
//			})
//			if err != nil {
//				return err
//			}
//			primary, err := alloydb.NewCluster(ctx, "primary", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-primary-cluster"),
//				Location:  pulumi.String("us-central1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: _default.ID(),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			privateIpAlloc, err := compute.NewGlobalAddress(ctx, "private_ip_alloc", &compute.GlobalAddressArgs{
//				Name:         pulumi.String("alloydb-secondary-cluster"),
//				AddressType:  pulumi.String("INTERNAL"),
//				Purpose:      pulumi.String("VPC_PEERING"),
//				PrefixLength: pulumi.Int(16),
//				Network:      _default.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			vpcConnection, err := servicenetworking.NewConnection(ctx, "vpc_connection", &servicenetworking.ConnectionArgs{
//				Network: _default.ID(),
//				Service: pulumi.String("servicenetworking.googleapis.com"),
//				ReservedPeeringRanges: pulumi.StringArray{
//					privateIpAlloc.Name,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			primaryInstance, err := alloydb.NewInstance(ctx, "primary", &alloydb.InstanceArgs{
//				Cluster:      primary.Name,
//				InstanceId:   pulumi.String("alloydb-primary-instance"),
//				InstanceType: pulumi.String("PRIMARY"),
//				MachineConfig: &alloydb.InstanceMachineConfigArgs{
//					CpuCount: pulumi.Int(2),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				vpcConnection,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = alloydb.NewCluster(ctx, "secondary", &alloydb.ClusterArgs{
//				ClusterId: pulumi.String("alloydb-secondary-cluster"),
//				Location:  pulumi.String("us-east1"),
//				NetworkConfig: &alloydb.ClusterNetworkConfigArgs{
//					Network: _default.ID(),
//				},
//				ClusterType: pulumi.String("SECONDARY"),
//				ContinuousBackupConfig: &alloydb.ClusterContinuousBackupConfigArgs{
//					Enabled: pulumi.Bool(false),
//				},
//				SecondaryConfig: &alloydb.ClusterSecondaryConfigArgs{
//					PrimaryClusterName: primary.Name,
//				},
//				DeletionProtection: pulumi.Bool(false),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				primaryInstance,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Cluster can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}`
// * `{{project}}/{{location}}/{{cluster_id}}`
// * `{{location}}/{{cluster_id}}`
// * `{{cluster_id}}`
//
// When using the `pulumi import` command, Cluster can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:alloydb/cluster:Cluster default projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
// $ pulumi import gcp:alloydb/cluster:Cluster default {{project}}/{{location}}/{{cluster_id}}
// $ pulumi import gcp:alloydb/cluster:Cluster default {{location}}/{{cluster_id}}
// $ pulumi import gcp:alloydb/cluster:Cluster default {{cluster_id}}
// ```
type Cluster struct {
	pulumi.CustomResourceState

	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	//
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy ClusterAutomatedBackupPolicyOutput `pulumi:"automatedBackupPolicy"`
	// Cluster created from backup.
	// Structure is documented below.
	BackupSources ClusterBackupSourceArrayOutput `pulumi:"backupSources"`
	// Cluster created from a BackupDR backup.
	// Structure is documented below.
	BackupdrBackupSources ClusterBackupdrBackupSourceArrayOutput `pulumi:"backupdrBackupSources"`
	// The ID of the alloydb cluster.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is `PRIMARY`.
	// Possible values are: `PRIMARY`, `SECONDARY`.
	ClusterType pulumi.StringPtrOutput `pulumi:"clusterType"`
	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig ClusterContinuousBackupConfigOutput `pulumi:"continuousBackupConfig"`
	// ContinuousBackupInfo describes the continuous backup properties of a cluster.
	// Structure is documented below.
	ContinuousBackupInfos ClusterContinuousBackupInfoArrayOutput `pulumi:"continuousBackupInfos"`
	// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
	// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
	DatabaseVersion pulumi.StringOutput `pulumi:"databaseVersion"`
	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrOutput `pulumi:"deletionPolicy"`
	// Whether Terraform will be prevented from destroying the cluster.
	// When the field is set to true or unset in Terraform state, a `pulumi up`
	// or `terraform destroy` that would delete the cluster will fail.
	// When the field is set to false, deleting the cluster is allowed.
	DeletionProtection pulumi.BoolPtrOutput `pulumi:"deletionProtection"`
	// User-settable and human-readable display name for the Cluster.
	DisplayName pulumi.StringPtrOutput `pulumi:"displayName"`
	// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
	EffectiveAnnotations pulumi.StringMapOutput `pulumi:"effectiveAnnotations"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig ClusterEncryptionConfigPtrOutput `pulumi:"encryptionConfig"`
	// (Output)
	// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
	// Structure is documented below.
	EncryptionInfos ClusterEncryptionInfoArrayOutput `pulumi:"encryptionInfos"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag pulumi.StringPtrOutput `pulumi:"etag"`
	// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
	// Structure is documented below.
	InitialUser ClusterInitialUserPtrOutput `pulumi:"initialUser"`
	// User-defined labels for the alloydb cluster.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The location where the alloydb cluster should reside.
	Location pulumi.StringOutput `pulumi:"location"`
	// MaintenanceUpdatePolicy defines the policy for system updates.
	// Structure is documented below.
	MaintenanceUpdatePolicy ClusterMaintenanceUpdatePolicyPtrOutput `pulumi:"maintenanceUpdatePolicy"`
	// Cluster created via DMS migration.
	// Structure is documented below.
	MigrationSources ClusterMigrationSourceArrayOutput `pulumi:"migrationSources"`
	// The name of the cluster resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig ClusterNetworkConfigOutput `pulumi:"networkConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// Configuration for Private Service Connect (PSC) for the cluster.
	// Structure is documented below.
	PscConfig ClusterPscConfigPtrOutput `pulumi:"pscConfig"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
	// This can happen due to user-triggered updates or system actions like failover or maintenance.
	Reconciling pulumi.BoolOutput `pulumi:"reconciling"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupSource ClusterRestoreBackupSourcePtrOutput `pulumi:"restoreBackupSource"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupdrBackupSource ClusterRestoreBackupdrBackupSourcePtrOutput `pulumi:"restoreBackupdrBackupSource"`
	// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
	// Structure is documented below.
	RestoreBackupdrPitrSource ClusterRestoreBackupdrPitrSourcePtrOutput `pulumi:"restoreBackupdrPitrSource"`
	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource ClusterRestoreContinuousBackupSourcePtrOutput `pulumi:"restoreContinuousBackupSource"`
	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig ClusterSecondaryConfigPtrOutput `pulumi:"secondaryConfig"`
	// Set to true to skip awaiting on the major version upgrade of the cluster.
	// Possible values: true, false
	// Default value: "true"
	SkipAwaitMajorVersionUpgrade pulumi.BoolPtrOutput `pulumi:"skipAwaitMajorVersionUpgrade"`
	// Output only. The current serving state of the cluster.
	State pulumi.StringOutput `pulumi:"state"`
	// The subscrition type of cluster.
	// Possible values are: `TRIAL`, `STANDARD`.
	SubscriptionType pulumi.StringOutput `pulumi:"subscriptionType"`
	// Contains information and all metadata related to TRIAL clusters.
	// Structure is documented below.
	TrialMetadatas ClusterTrialMetadataArrayOutput `pulumi:"trialMetadatas"`
	// The system-generated UID of the resource.
	Uid pulumi.StringOutput `pulumi:"uid"`
}

// NewCluster registers a new resource with the given unique name, arguments, and options.
func NewCluster(ctx *pulumi.Context,
	name string, args *ClusterArgs, opts ...pulumi.ResourceOption) (*Cluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Cluster
	err := ctx.RegisterResource("gcp:alloydb/cluster:Cluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCluster gets an existing Cluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterState, opts ...pulumi.ResourceOption) (*Cluster, error) {
	var resource Cluster
	err := ctx.ReadResource("gcp:alloydb/cluster:Cluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cluster resources.
type clusterState struct {
	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	//
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy *ClusterAutomatedBackupPolicy `pulumi:"automatedBackupPolicy"`
	// Cluster created from backup.
	// Structure is documented below.
	BackupSources []ClusterBackupSource `pulumi:"backupSources"`
	// Cluster created from a BackupDR backup.
	// Structure is documented below.
	BackupdrBackupSources []ClusterBackupdrBackupSource `pulumi:"backupdrBackupSources"`
	// The ID of the alloydb cluster.
	ClusterId *string `pulumi:"clusterId"`
	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is `PRIMARY`.
	// Possible values are: `PRIMARY`, `SECONDARY`.
	ClusterType *string `pulumi:"clusterType"`
	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig *ClusterContinuousBackupConfig `pulumi:"continuousBackupConfig"`
	// ContinuousBackupInfo describes the continuous backup properties of a cluster.
	// Structure is documented below.
	ContinuousBackupInfos []ClusterContinuousBackupInfo `pulumi:"continuousBackupInfos"`
	// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
	// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
	DatabaseVersion *string `pulumi:"databaseVersion"`
	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy *string `pulumi:"deletionPolicy"`
	// Whether Terraform will be prevented from destroying the cluster.
	// When the field is set to true or unset in Terraform state, a `pulumi up`
	// or `terraform destroy` that would delete the cluster will fail.
	// When the field is set to false, deleting the cluster is allowed.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// User-settable and human-readable display name for the Cluster.
	DisplayName *string `pulumi:"displayName"`
	// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
	EffectiveAnnotations map[string]string `pulumi:"effectiveAnnotations"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig *ClusterEncryptionConfig `pulumi:"encryptionConfig"`
	// (Output)
	// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
	// Structure is documented below.
	EncryptionInfos []ClusterEncryptionInfo `pulumi:"encryptionInfos"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag *string `pulumi:"etag"`
	// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
	// Structure is documented below.
	InitialUser *ClusterInitialUser `pulumi:"initialUser"`
	// User-defined labels for the alloydb cluster.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location where the alloydb cluster should reside.
	Location *string `pulumi:"location"`
	// MaintenanceUpdatePolicy defines the policy for system updates.
	// Structure is documented below.
	MaintenanceUpdatePolicy *ClusterMaintenanceUpdatePolicy `pulumi:"maintenanceUpdatePolicy"`
	// Cluster created via DMS migration.
	// Structure is documented below.
	MigrationSources []ClusterMigrationSource `pulumi:"migrationSources"`
	// The name of the cluster resource.
	Name *string `pulumi:"name"`
	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig *ClusterNetworkConfig `pulumi:"networkConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Configuration for Private Service Connect (PSC) for the cluster.
	// Structure is documented below.
	PscConfig *ClusterPscConfig `pulumi:"pscConfig"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
	// This can happen due to user-triggered updates or system actions like failover or maintenance.
	Reconciling *bool `pulumi:"reconciling"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupSource *ClusterRestoreBackupSource `pulumi:"restoreBackupSource"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupdrBackupSource *ClusterRestoreBackupdrBackupSource `pulumi:"restoreBackupdrBackupSource"`
	// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
	// Structure is documented below.
	RestoreBackupdrPitrSource *ClusterRestoreBackupdrPitrSource `pulumi:"restoreBackupdrPitrSource"`
	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource *ClusterRestoreContinuousBackupSource `pulumi:"restoreContinuousBackupSource"`
	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig *ClusterSecondaryConfig `pulumi:"secondaryConfig"`
	// Set to true to skip awaiting on the major version upgrade of the cluster.
	// Possible values: true, false
	// Default value: "true"
	SkipAwaitMajorVersionUpgrade *bool `pulumi:"skipAwaitMajorVersionUpgrade"`
	// Output only. The current serving state of the cluster.
	State *string `pulumi:"state"`
	// The subscrition type of cluster.
	// Possible values are: `TRIAL`, `STANDARD`.
	SubscriptionType *string `pulumi:"subscriptionType"`
	// Contains information and all metadata related to TRIAL clusters.
	// Structure is documented below.
	TrialMetadatas []ClusterTrialMetadata `pulumi:"trialMetadatas"`
	// The system-generated UID of the resource.
	Uid *string `pulumi:"uid"`
}

type ClusterState struct {
	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	//
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy ClusterAutomatedBackupPolicyPtrInput
	// Cluster created from backup.
	// Structure is documented below.
	BackupSources ClusterBackupSourceArrayInput
	// Cluster created from a BackupDR backup.
	// Structure is documented below.
	BackupdrBackupSources ClusterBackupdrBackupSourceArrayInput
	// The ID of the alloydb cluster.
	ClusterId pulumi.StringPtrInput
	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is `PRIMARY`.
	// Possible values are: `PRIMARY`, `SECONDARY`.
	ClusterType pulumi.StringPtrInput
	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig ClusterContinuousBackupConfigPtrInput
	// ContinuousBackupInfo describes the continuous backup properties of a cluster.
	// Structure is documented below.
	ContinuousBackupInfos ClusterContinuousBackupInfoArrayInput
	// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
	// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
	DatabaseVersion pulumi.StringPtrInput
	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrInput
	// Whether Terraform will be prevented from destroying the cluster.
	// When the field is set to true or unset in Terraform state, a `pulumi up`
	// or `terraform destroy` that would delete the cluster will fail.
	// When the field is set to false, deleting the cluster is allowed.
	DeletionProtection pulumi.BoolPtrInput
	// User-settable and human-readable display name for the Cluster.
	DisplayName pulumi.StringPtrInput
	// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
	EffectiveAnnotations pulumi.StringMapInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig ClusterEncryptionConfigPtrInput
	// (Output)
	// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
	// Structure is documented below.
	EncryptionInfos ClusterEncryptionInfoArrayInput
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag pulumi.StringPtrInput
	// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
	// Structure is documented below.
	InitialUser ClusterInitialUserPtrInput
	// User-defined labels for the alloydb cluster.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location where the alloydb cluster should reside.
	Location pulumi.StringPtrInput
	// MaintenanceUpdatePolicy defines the policy for system updates.
	// Structure is documented below.
	MaintenanceUpdatePolicy ClusterMaintenanceUpdatePolicyPtrInput
	// Cluster created via DMS migration.
	// Structure is documented below.
	MigrationSources ClusterMigrationSourceArrayInput
	// The name of the cluster resource.
	Name pulumi.StringPtrInput
	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig ClusterNetworkConfigPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Configuration for Private Service Connect (PSC) for the cluster.
	// Structure is documented below.
	PscConfig ClusterPscConfigPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
	// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
	// This can happen due to user-triggered updates or system actions like failover or maintenance.
	Reconciling pulumi.BoolPtrInput
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupSource ClusterRestoreBackupSourcePtrInput
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupdrBackupSource ClusterRestoreBackupdrBackupSourcePtrInput
	// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
	// Structure is documented below.
	RestoreBackupdrPitrSource ClusterRestoreBackupdrPitrSourcePtrInput
	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource ClusterRestoreContinuousBackupSourcePtrInput
	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig ClusterSecondaryConfigPtrInput
	// Set to true to skip awaiting on the major version upgrade of the cluster.
	// Possible values: true, false
	// Default value: "true"
	SkipAwaitMajorVersionUpgrade pulumi.BoolPtrInput
	// Output only. The current serving state of the cluster.
	State pulumi.StringPtrInput
	// The subscrition type of cluster.
	// Possible values are: `TRIAL`, `STANDARD`.
	SubscriptionType pulumi.StringPtrInput
	// Contains information and all metadata related to TRIAL clusters.
	// Structure is documented below.
	TrialMetadatas ClusterTrialMetadataArrayInput
	// The system-generated UID of the resource.
	Uid pulumi.StringPtrInput
}

func (ClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterState)(nil)).Elem()
}

type clusterArgs struct {
	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	//
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy *ClusterAutomatedBackupPolicy `pulumi:"automatedBackupPolicy"`
	// The ID of the alloydb cluster.
	ClusterId string `pulumi:"clusterId"`
	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is `PRIMARY`.
	// Possible values are: `PRIMARY`, `SECONDARY`.
	ClusterType *string `pulumi:"clusterType"`
	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig *ClusterContinuousBackupConfig `pulumi:"continuousBackupConfig"`
	// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
	// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
	DatabaseVersion *string `pulumi:"databaseVersion"`
	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy *string `pulumi:"deletionPolicy"`
	// Whether Terraform will be prevented from destroying the cluster.
	// When the field is set to true or unset in Terraform state, a `pulumi up`
	// or `terraform destroy` that would delete the cluster will fail.
	// When the field is set to false, deleting the cluster is allowed.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// User-settable and human-readable display name for the Cluster.
	DisplayName *string `pulumi:"displayName"`
	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig *ClusterEncryptionConfig `pulumi:"encryptionConfig"`
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag *string `pulumi:"etag"`
	// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
	// Structure is documented below.
	InitialUser *ClusterInitialUser `pulumi:"initialUser"`
	// User-defined labels for the alloydb cluster.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location where the alloydb cluster should reside.
	Location string `pulumi:"location"`
	// MaintenanceUpdatePolicy defines the policy for system updates.
	// Structure is documented below.
	MaintenanceUpdatePolicy *ClusterMaintenanceUpdatePolicy `pulumi:"maintenanceUpdatePolicy"`
	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig *ClusterNetworkConfig `pulumi:"networkConfig"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Configuration for Private Service Connect (PSC) for the cluster.
	// Structure is documented below.
	PscConfig *ClusterPscConfig `pulumi:"pscConfig"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupSource *ClusterRestoreBackupSource `pulumi:"restoreBackupSource"`
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupdrBackupSource *ClusterRestoreBackupdrBackupSource `pulumi:"restoreBackupdrBackupSource"`
	// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
	// Structure is documented below.
	RestoreBackupdrPitrSource *ClusterRestoreBackupdrPitrSource `pulumi:"restoreBackupdrPitrSource"`
	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource *ClusterRestoreContinuousBackupSource `pulumi:"restoreContinuousBackupSource"`
	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig *ClusterSecondaryConfig `pulumi:"secondaryConfig"`
	// Set to true to skip awaiting on the major version upgrade of the cluster.
	// Possible values: true, false
	// Default value: "true"
	SkipAwaitMajorVersionUpgrade *bool `pulumi:"skipAwaitMajorVersionUpgrade"`
	// The subscrition type of cluster.
	// Possible values are: `TRIAL`, `STANDARD`.
	SubscriptionType *string `pulumi:"subscriptionType"`
}

// The set of arguments for constructing a Cluster resource.
type ClusterArgs struct {
	// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
	// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
	//
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
	// Structure is documented below.
	AutomatedBackupPolicy ClusterAutomatedBackupPolicyPtrInput
	// The ID of the alloydb cluster.
	ClusterId pulumi.StringInput
	// The type of cluster. If not set, defaults to PRIMARY.
	// Default value is `PRIMARY`.
	// Possible values are: `PRIMARY`, `SECONDARY`.
	ClusterType pulumi.StringPtrInput
	// The continuous backup config for this cluster.
	// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
	// Structure is documented below.
	ContinuousBackupConfig ClusterContinuousBackupConfigPtrInput
	// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
	// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
	DatabaseVersion pulumi.StringPtrInput
	// Policy to determine if the cluster should be deleted forcefully.
	// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
	// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrInput
	// Whether Terraform will be prevented from destroying the cluster.
	// When the field is set to true or unset in Terraform state, a `pulumi up`
	// or `terraform destroy` that would delete the cluster will fail.
	// When the field is set to false, deleting the cluster is allowed.
	DeletionProtection pulumi.BoolPtrInput
	// User-settable and human-readable display name for the Cluster.
	DisplayName pulumi.StringPtrInput
	// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
	// Structure is documented below.
	EncryptionConfig ClusterEncryptionConfigPtrInput
	// For Resource freshness validation (https://google.aip.dev/154)
	Etag pulumi.StringPtrInput
	// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
	// Structure is documented below.
	InitialUser ClusterInitialUserPtrInput
	// User-defined labels for the alloydb cluster.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location where the alloydb cluster should reside.
	Location pulumi.StringInput
	// MaintenanceUpdatePolicy defines the policy for system updates.
	// Structure is documented below.
	MaintenanceUpdatePolicy ClusterMaintenanceUpdatePolicyPtrInput
	// Metadata related to network configuration.
	// Structure is documented below.
	NetworkConfig ClusterNetworkConfigPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Configuration for Private Service Connect (PSC) for the cluster.
	// Structure is documented below.
	PscConfig ClusterPscConfigPtrInput
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupSource ClusterRestoreBackupSourcePtrInput
	// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreBackupdrBackupSource ClusterRestoreBackupdrBackupSourcePtrInput
	// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
	// Structure is documented below.
	RestoreBackupdrPitrSource ClusterRestoreBackupdrPitrSourcePtrInput
	// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
	// Structure is documented below.
	RestoreContinuousBackupSource ClusterRestoreContinuousBackupSourcePtrInput
	// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
	// Structure is documented below.
	SecondaryConfig ClusterSecondaryConfigPtrInput
	// Set to true to skip awaiting on the major version upgrade of the cluster.
	// Possible values: true, false
	// Default value: "true"
	SkipAwaitMajorVersionUpgrade pulumi.BoolPtrInput
	// The subscrition type of cluster.
	// Possible values are: `TRIAL`, `STANDARD`.
	SubscriptionType pulumi.StringPtrInput
}

func (ClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterArgs)(nil)).Elem()
}

type ClusterInput interface {
	pulumi.Input

	ToClusterOutput() ClusterOutput
	ToClusterOutputWithContext(ctx context.Context) ClusterOutput
}

func (*Cluster) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (i *Cluster) ToClusterOutput() ClusterOutput {
	return i.ToClusterOutputWithContext(context.Background())
}

func (i *Cluster) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterOutput)
}

// ClusterArrayInput is an input type that accepts ClusterArray and ClusterArrayOutput values.
// You can construct a concrete instance of `ClusterArrayInput` via:
//
//	ClusterArray{ ClusterArgs{...} }
type ClusterArrayInput interface {
	pulumi.Input

	ToClusterArrayOutput() ClusterArrayOutput
	ToClusterArrayOutputWithContext(context.Context) ClusterArrayOutput
}

type ClusterArray []ClusterInput

func (ClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (i ClusterArray) ToClusterArrayOutput() ClusterArrayOutput {
	return i.ToClusterArrayOutputWithContext(context.Background())
}

func (i ClusterArray) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterArrayOutput)
}

// ClusterMapInput is an input type that accepts ClusterMap and ClusterMapOutput values.
// You can construct a concrete instance of `ClusterMapInput` via:
//
//	ClusterMap{ "key": ClusterArgs{...} }
type ClusterMapInput interface {
	pulumi.Input

	ToClusterMapOutput() ClusterMapOutput
	ToClusterMapOutputWithContext(context.Context) ClusterMapOutput
}

type ClusterMap map[string]ClusterInput

func (ClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (i ClusterMap) ToClusterMapOutput() ClusterMapOutput {
	return i.ToClusterMapOutputWithContext(context.Background())
}

func (i ClusterMap) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMapOutput)
}

type ClusterOutput struct{ *pulumi.OutputState }

func (ClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Cluster)(nil)).Elem()
}

func (o ClusterOutput) ToClusterOutput() ClusterOutput {
	return o
}

func (o ClusterOutput) ToClusterOutputWithContext(ctx context.Context) ClusterOutput {
	return o
}

// Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
// An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
//
// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
func (o ClusterOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
// Structure is documented below.
func (o ClusterOutput) AutomatedBackupPolicy() ClusterAutomatedBackupPolicyOutput {
	return o.ApplyT(func(v *Cluster) ClusterAutomatedBackupPolicyOutput { return v.AutomatedBackupPolicy }).(ClusterAutomatedBackupPolicyOutput)
}

// Cluster created from backup.
// Structure is documented below.
func (o ClusterOutput) BackupSources() ClusterBackupSourceArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterBackupSourceArrayOutput { return v.BackupSources }).(ClusterBackupSourceArrayOutput)
}

// Cluster created from a BackupDR backup.
// Structure is documented below.
func (o ClusterOutput) BackupdrBackupSources() ClusterBackupdrBackupSourceArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterBackupdrBackupSourceArrayOutput { return v.BackupdrBackupSources }).(ClusterBackupdrBackupSourceArrayOutput)
}

// The ID of the alloydb cluster.
func (o ClusterOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// The type of cluster. If not set, defaults to PRIMARY.
// Default value is `PRIMARY`.
// Possible values are: `PRIMARY`, `SECONDARY`.
func (o ClusterOutput) ClusterType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.ClusterType }).(pulumi.StringPtrOutput)
}

// The continuous backup config for this cluster.
// If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
// Structure is documented below.
func (o ClusterOutput) ContinuousBackupConfig() ClusterContinuousBackupConfigOutput {
	return o.ApplyT(func(v *Cluster) ClusterContinuousBackupConfigOutput { return v.ContinuousBackupConfig }).(ClusterContinuousBackupConfigOutput)
}

// ContinuousBackupInfo describes the continuous backup properties of a cluster.
// Structure is documented below.
func (o ClusterOutput) ContinuousBackupInfos() ClusterContinuousBackupInfoArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterContinuousBackupInfoArrayOutput { return v.ContinuousBackupInfos }).(ClusterContinuousBackupInfoArrayOutput)
}

// The database engine major version. This is an optional field and it's populated at the Cluster creation time.
// Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
func (o ClusterOutput) DatabaseVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.DatabaseVersion }).(pulumi.StringOutput)
}

// Policy to determine if the cluster should be deleted forcefully.
// Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
// Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
// Possible values: DEFAULT, FORCE
func (o ClusterOutput) DeletionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.DeletionPolicy }).(pulumi.StringPtrOutput)
}

// Whether Terraform will be prevented from destroying the cluster.
// When the field is set to true or unset in Terraform state, a `pulumi up`
// or `terraform destroy` that would delete the cluster will fail.
// When the field is set to false, deleting the cluster is allowed.
func (o ClusterOutput) DeletionProtection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolPtrOutput { return v.DeletionProtection }).(pulumi.BoolPtrOutput)
}

// User-settable and human-readable display name for the Cluster.
func (o ClusterOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.
func (o ClusterOutput) EffectiveAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.EffectiveAnnotations }).(pulumi.StringMapOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o ClusterOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
// Structure is documented below.
func (o ClusterOutput) EncryptionConfig() ClusterEncryptionConfigPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterEncryptionConfigPtrOutput { return v.EncryptionConfig }).(ClusterEncryptionConfigPtrOutput)
}

// (Output)
// Output only. The encryption information for the WALs and backups required for ContinuousBackup.
// Structure is documented below.
func (o ClusterOutput) EncryptionInfos() ClusterEncryptionInfoArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterEncryptionInfoArrayOutput { return v.EncryptionInfos }).(ClusterEncryptionInfoArrayOutput)
}

// For Resource freshness validation (https://google.aip.dev/154)
func (o ClusterOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringPtrOutput { return v.Etag }).(pulumi.StringPtrOutput)
}

// Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
// Structure is documented below.
func (o ClusterOutput) InitialUser() ClusterInitialUserPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterInitialUserPtrOutput { return v.InitialUser }).(ClusterInitialUserPtrOutput)
}

// User-defined labels for the alloydb cluster.
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o ClusterOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The location where the alloydb cluster should reside.
func (o ClusterOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// MaintenanceUpdatePolicy defines the policy for system updates.
// Structure is documented below.
func (o ClusterOutput) MaintenanceUpdatePolicy() ClusterMaintenanceUpdatePolicyPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterMaintenanceUpdatePolicyPtrOutput { return v.MaintenanceUpdatePolicy }).(ClusterMaintenanceUpdatePolicyPtrOutput)
}

// Cluster created via DMS migration.
// Structure is documented below.
func (o ClusterOutput) MigrationSources() ClusterMigrationSourceArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterMigrationSourceArrayOutput { return v.MigrationSources }).(ClusterMigrationSourceArrayOutput)
}

// The name of the cluster resource.
func (o ClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Metadata related to network configuration.
// Structure is documented below.
func (o ClusterOutput) NetworkConfig() ClusterNetworkConfigOutput {
	return o.ApplyT(func(v *Cluster) ClusterNetworkConfigOutput { return v.NetworkConfig }).(ClusterNetworkConfigOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o ClusterOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Configuration for Private Service Connect (PSC) for the cluster.
// Structure is documented below.
func (o ClusterOutput) PscConfig() ClusterPscConfigPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterPscConfigPtrOutput { return v.PscConfig }).(ClusterPscConfigPtrOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o ClusterOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// Output only. Reconciling (https://google.aip.dev/128#reconciliation).
// Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
// This can happen due to user-triggered updates or system actions like failover or maintenance.
func (o ClusterOutput) Reconciling() pulumi.BoolOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolOutput { return v.Reconciling }).(pulumi.BoolOutput)
}

// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
// Structure is documented below.
func (o ClusterOutput) RestoreBackupSource() ClusterRestoreBackupSourcePtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterRestoreBackupSourcePtrOutput { return v.RestoreBackupSource }).(ClusterRestoreBackupSourcePtrOutput)
}

// The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source',  'restore_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
// Structure is documented below.
func (o ClusterOutput) RestoreBackupdrBackupSource() ClusterRestoreBackupdrBackupSourcePtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterRestoreBackupdrBackupSourcePtrOutput { return v.RestoreBackupdrBackupSource }).(ClusterRestoreBackupdrBackupSourcePtrOutput)
}

// The BackupDR source used for point in time recovery. Conflicts with 'restore_backupdr_backup_source', 'restore_continuous_backup_source' and 'restore_backupdr_backup_source', they can't be set togeter.
// Structure is documented below.
func (o ClusterOutput) RestoreBackupdrPitrSource() ClusterRestoreBackupdrPitrSourcePtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterRestoreBackupdrPitrSourcePtrOutput { return v.RestoreBackupdrPitrSource }).(ClusterRestoreBackupdrPitrSourcePtrOutput)
}

// The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', 'restore_backupdr_backup_source' and 'restore_backupdr_pitr_source', they can't be set together.
// Structure is documented below.
func (o ClusterOutput) RestoreContinuousBackupSource() ClusterRestoreContinuousBackupSourcePtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterRestoreContinuousBackupSourcePtrOutput { return v.RestoreContinuousBackupSource }).(ClusterRestoreContinuousBackupSourcePtrOutput)
}

// Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
// Structure is documented below.
func (o ClusterOutput) SecondaryConfig() ClusterSecondaryConfigPtrOutput {
	return o.ApplyT(func(v *Cluster) ClusterSecondaryConfigPtrOutput { return v.SecondaryConfig }).(ClusterSecondaryConfigPtrOutput)
}

// Set to true to skip awaiting on the major version upgrade of the cluster.
// Possible values: true, false
// Default value: "true"
func (o ClusterOutput) SkipAwaitMajorVersionUpgrade() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Cluster) pulumi.BoolPtrOutput { return v.SkipAwaitMajorVersionUpgrade }).(pulumi.BoolPtrOutput)
}

// Output only. The current serving state of the cluster.
func (o ClusterOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The subscrition type of cluster.
// Possible values are: `TRIAL`, `STANDARD`.
func (o ClusterOutput) SubscriptionType() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.SubscriptionType }).(pulumi.StringOutput)
}

// Contains information and all metadata related to TRIAL clusters.
// Structure is documented below.
func (o ClusterOutput) TrialMetadatas() ClusterTrialMetadataArrayOutput {
	return o.ApplyT(func(v *Cluster) ClusterTrialMetadataArrayOutput { return v.TrialMetadatas }).(ClusterTrialMetadataArrayOutput)
}

// The system-generated UID of the resource.
func (o ClusterOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v *Cluster) pulumi.StringOutput { return v.Uid }).(pulumi.StringOutput)
}

type ClusterArrayOutput struct{ *pulumi.OutputState }

func (ClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cluster)(nil)).Elem()
}

func (o ClusterArrayOutput) ToClusterArrayOutput() ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) ToClusterArrayOutputWithContext(ctx context.Context) ClusterArrayOutput {
	return o
}

func (o ClusterArrayOutput) Index(i pulumi.IntInput) ClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].([]*Cluster)[vs[1].(int)]
	}).(ClusterOutput)
}

type ClusterMapOutput struct{ *pulumi.OutputState }

func (ClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cluster)(nil)).Elem()
}

func (o ClusterMapOutput) ToClusterMapOutput() ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) ToClusterMapOutputWithContext(ctx context.Context) ClusterMapOutput {
	return o
}

func (o ClusterMapOutput) MapIndex(k pulumi.StringInput) ClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Cluster {
		return vs[0].(map[string]*Cluster)[vs[1].(string)]
	}).(ClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterInput)(nil)).Elem(), &Cluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterArrayInput)(nil)).Elem(), ClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterMapInput)(nil)).Elem(), ClusterMap{})
	pulumi.RegisterOutputType(ClusterOutput{})
	pulumi.RegisterOutputType(ClusterArrayOutput{})
	pulumi.RegisterOutputType(ClusterMapOutput{})
}
