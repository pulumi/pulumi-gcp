// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package discoveryengine

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// DataConnector manages the connection to external data sources for all data stores grouped
// under a Collection. It's a singleton resource of Collection. The initialization is only
// supported through DataConnectorService.SetUpDataConnector method, which will create a new
// Collection and initialize its DataConnector.
//
// To get more information about DataConnector, see:
//
// * [API documentation](https://cloud.google.com/generative-ai-app-builder/docs/reference/rpc/google.cloud.discoveryengine.v1alpha#dataconnectorservice)
// * How-to Guides
//   - [Introduction](https://cloud.google.com/agentspace/docs/introduction-to-connectors-and-data-stores)
//
// ## Example Usage
//
// ### Discoveryengine Dataconnector Jira Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/discoveryengine"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := discoveryengine.NewDataConnector(ctx, "jira-basic", &discoveryengine.DataConnectorArgs{
//				Location:              pulumi.String("global"),
//				CollectionId:          pulumi.String("collection-id"),
//				CollectionDisplayName: pulumi.String("tf-test-dataconnector-jira"),
//				DataSource:            pulumi.String("jira"),
//				Params: pulumi.StringMap{
//					"instance_id":   pulumi.String("33db20a3-dc45-4305-a505-d70b68599840"),
//					"instance_uri":  pulumi.String("https://vaissptbots1.atlassian.net/"),
//					"client_secret": pulumi.String("client-secret"),
//					"client_id":     pulumi.String("client-id"),
//					"refresh_token": pulumi.String("fill-in-the-blank"),
//				},
//				RefreshInterval: pulumi.String("86400s"),
//				Entities: discoveryengine.DataConnectorEntityArray{
//					&discoveryengine.DataConnectorEntityArgs{
//						EntityName: pulumi.String("project"),
//					},
//					&discoveryengine.DataConnectorEntityArgs{
//						EntityName: pulumi.String("issue"),
//					},
//					&discoveryengine.DataConnectorEntityArgs{
//						EntityName: pulumi.String("attachment"),
//					},
//					&discoveryengine.DataConnectorEntityArgs{
//						EntityName: pulumi.String("comment"),
//					},
//					&discoveryengine.DataConnectorEntityArgs{
//						EntityName: pulumi.String("worklog"),
//					},
//				},
//				StaticIpEnabled: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// DataConnector can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/collections/{{collection_id}}/dataConnector`
//
// * `{{project}}/{{location}}/{{collection_id}}`
//
// * `{{location}}/{{collection_id}}`
//
// When using the `pulumi import` command, DataConnector can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:discoveryengine/dataConnector:DataConnector default projects/{{project}}/locations/{{location}}/collections/{{collection_id}}/dataConnector
// ```
//
// ```sh
// $ pulumi import gcp:discoveryengine/dataConnector:DataConnector default {{project}}/{{location}}/{{collection_id}}
// ```
//
// ```sh
// $ pulumi import gcp:discoveryengine/dataConnector:DataConnector default {{location}}/{{collection_id}}
// ```
type DataConnector struct {
	pulumi.CustomResourceState

	// State of the action connector. This reflects whether the action connector
	// is initializing, active or has encountered errors. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	ActionState pulumi.StringOutput `pulumi:"actionState"`
	// User actions that must be completed before the connector can start syncing data.
	// The possible values can be: 'ALLOWLIST_STATIC_IP', 'ALLOWLIST_IN_SERVICE_ATTACHMENT'.
	BlockingReasons pulumi.StringArrayOutput `pulumi:"blockingReasons"`
	// The display name of the Collection.
	// Should be human readable, used to display collections in the Console
	// Dashboard. UTF-8 encoded string with limit of 1024 characters.
	CollectionDisplayName pulumi.StringOutput `pulumi:"collectionDisplayName"`
	// The ID to use for the Collection, which will become the final component
	// of the Collection's resource name. A new Collection is created as
	// part of the DataConnector setup. DataConnector is a singleton
	// resource under Collection, managing all DataStores of the Collection.
	// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
	// standard with a length limit of 63 characters. Otherwise, an
	// INVALID_ARGUMENT error is returned.
	CollectionId pulumi.StringOutput `pulumi:"collectionId"`
	// The type of connector. Each source can only map to one type.
	// For example, salesforce, confluence and jira have THIRD_PARTY connector
	// type. It is not mutable once set by system. The possible value can be:
	// 'CONNECTOR_TYPE_UNSPECIFIED', 'THIRD_PARTY', 'GCP_FHIR', 'BIG_QUERY',
	// 'GCS', 'GOOGLE_MAIL', 'GOOGLE_CALENDAR', 'GOOGLE_DRIVE',
	// 'NATIVE_CLOUD_IDENTITY', 'THIRD_PARTY_FEDERATED', 'THIRD_PARTY_EUA', 'GCNV'.
	ConnectorType pulumi.StringOutput `pulumi:"connectorType"`
	// Timestamp when the DataConnector was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// The name of the data source.
	// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
	DataSource pulumi.StringOutput `pulumi:"dataSource"`
	// List of entities from the connected data source to ingest.
	// Structure is documented below.
	Entities DataConnectorEntityArrayOutput `pulumi:"entities"`
	// The errors from initialization or from the latest connector run.
	// Structure is documented below.
	Errors DataConnectorErrorArrayOutput `pulumi:"errors"`
	// Params needed to access the source in the format of json string.
	JsonParams pulumi.StringPtrOutput `pulumi:"jsonParams"`
	// The KMS key to be used to protect the DataStores managed by this connector.
	// Must be set for requests that need to comply with CMEK Org Policy
	// protections.
	// If this field is set and processed successfully, the DataStores created by
	// this connector will be protected by the KMS key.
	KmsKeyName pulumi.StringPtrOutput `pulumi:"kmsKeyName"`
	// For periodic connectors only, the last time a data sync was completed.
	LastSyncTime pulumi.StringOutput `pulumi:"lastSyncTime"`
	// The most recent timestamp when this [DataConnector][] was paused,
	// affecting all functionalities such as data synchronization.
	// Pausing a connector has the following effects:
	// - All functionalities, including data synchronization, are halted.
	// - Any ongoing data synchronization job will be canceled.
	// - No future data synchronization runs will be scheduled nor can be
	//   triggered.
	LatestPauseTime pulumi.StringOutput `pulumi:"latestPauseTime"`
	// The geographic location where the data store should reside. The value can
	// only be one of "global", "us" and "eu".
	Location pulumi.StringOutput `pulumi:"location"`
	// The full resource name of the Data Connector.
	// Format: `projects/*/locations/*/collections/*/dataConnector`.
	Name pulumi.StringOutput `pulumi:"name"`
	// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
	Params pulumi.StringMapOutput `pulumi:"params"`
	// The tenant project ID associated with private connectivity connectors.
	// This project must be allowlisted by in order for the connector to function.
	PrivateConnectivityProjectId pulumi.StringOutput `pulumi:"privateConnectivityProjectId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The real-time sync state. The possible values can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	RealtimeState pulumi.StringOutput `pulumi:"realtimeState"`
	// The refresh interval for data sync. If duration is set to 0, the data will
	// be synced in real time. The streaming feature is not supported yet. The
	// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
	// set to the same value as the incremental refresh interval, incremental
	// sync will be disabled.
	RefreshInterval pulumi.StringOutput `pulumi:"refreshInterval"`
	// The state of connector. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	State pulumi.StringOutput `pulumi:"state"`
	// The static IP addresses used by this connector.
	StaticIpAddresses pulumi.StringArrayOutput `pulumi:"staticIpAddresses"`
	// Whether customer has enabled static IP addresses for this connector.
	StaticIpEnabled pulumi.BoolPtrOutput `pulumi:"staticIpEnabled"`
	// Timestamp when the DataConnector was updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewDataConnector registers a new resource with the given unique name, arguments, and options.
func NewDataConnector(ctx *pulumi.Context,
	name string, args *DataConnectorArgs, opts ...pulumi.ResourceOption) (*DataConnector, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CollectionDisplayName == nil {
		return nil, errors.New("invalid value for required argument 'CollectionDisplayName'")
	}
	if args.CollectionId == nil {
		return nil, errors.New("invalid value for required argument 'CollectionId'")
	}
	if args.DataSource == nil {
		return nil, errors.New("invalid value for required argument 'DataSource'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.RefreshInterval == nil {
		return nil, errors.New("invalid value for required argument 'RefreshInterval'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DataConnector
	err := ctx.RegisterResource("gcp:discoveryengine/dataConnector:DataConnector", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDataConnector gets an existing DataConnector resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDataConnector(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DataConnectorState, opts ...pulumi.ResourceOption) (*DataConnector, error) {
	var resource DataConnector
	err := ctx.ReadResource("gcp:discoveryengine/dataConnector:DataConnector", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DataConnector resources.
type dataConnectorState struct {
	// State of the action connector. This reflects whether the action connector
	// is initializing, active or has encountered errors. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	ActionState *string `pulumi:"actionState"`
	// User actions that must be completed before the connector can start syncing data.
	// The possible values can be: 'ALLOWLIST_STATIC_IP', 'ALLOWLIST_IN_SERVICE_ATTACHMENT'.
	BlockingReasons []string `pulumi:"blockingReasons"`
	// The display name of the Collection.
	// Should be human readable, used to display collections in the Console
	// Dashboard. UTF-8 encoded string with limit of 1024 characters.
	CollectionDisplayName *string `pulumi:"collectionDisplayName"`
	// The ID to use for the Collection, which will become the final component
	// of the Collection's resource name. A new Collection is created as
	// part of the DataConnector setup. DataConnector is a singleton
	// resource under Collection, managing all DataStores of the Collection.
	// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
	// standard with a length limit of 63 characters. Otherwise, an
	// INVALID_ARGUMENT error is returned.
	CollectionId *string `pulumi:"collectionId"`
	// The type of connector. Each source can only map to one type.
	// For example, salesforce, confluence and jira have THIRD_PARTY connector
	// type. It is not mutable once set by system. The possible value can be:
	// 'CONNECTOR_TYPE_UNSPECIFIED', 'THIRD_PARTY', 'GCP_FHIR', 'BIG_QUERY',
	// 'GCS', 'GOOGLE_MAIL', 'GOOGLE_CALENDAR', 'GOOGLE_DRIVE',
	// 'NATIVE_CLOUD_IDENTITY', 'THIRD_PARTY_FEDERATED', 'THIRD_PARTY_EUA', 'GCNV'.
	ConnectorType *string `pulumi:"connectorType"`
	// Timestamp when the DataConnector was created.
	CreateTime *string `pulumi:"createTime"`
	// The name of the data source.
	// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
	DataSource *string `pulumi:"dataSource"`
	// List of entities from the connected data source to ingest.
	// Structure is documented below.
	Entities []DataConnectorEntity `pulumi:"entities"`
	// The errors from initialization or from the latest connector run.
	// Structure is documented below.
	Errors []DataConnectorError `pulumi:"errors"`
	// Params needed to access the source in the format of json string.
	JsonParams *string `pulumi:"jsonParams"`
	// The KMS key to be used to protect the DataStores managed by this connector.
	// Must be set for requests that need to comply with CMEK Org Policy
	// protections.
	// If this field is set and processed successfully, the DataStores created by
	// this connector will be protected by the KMS key.
	KmsKeyName *string `pulumi:"kmsKeyName"`
	// For periodic connectors only, the last time a data sync was completed.
	LastSyncTime *string `pulumi:"lastSyncTime"`
	// The most recent timestamp when this [DataConnector][] was paused,
	// affecting all functionalities such as data synchronization.
	// Pausing a connector has the following effects:
	// - All functionalities, including data synchronization, are halted.
	// - Any ongoing data synchronization job will be canceled.
	// - No future data synchronization runs will be scheduled nor can be
	//   triggered.
	LatestPauseTime *string `pulumi:"latestPauseTime"`
	// The geographic location where the data store should reside. The value can
	// only be one of "global", "us" and "eu".
	Location *string `pulumi:"location"`
	// The full resource name of the Data Connector.
	// Format: `projects/*/locations/*/collections/*/dataConnector`.
	Name *string `pulumi:"name"`
	// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
	Params map[string]string `pulumi:"params"`
	// The tenant project ID associated with private connectivity connectors.
	// This project must be allowlisted by in order for the connector to function.
	PrivateConnectivityProjectId *string `pulumi:"privateConnectivityProjectId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The real-time sync state. The possible values can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	RealtimeState *string `pulumi:"realtimeState"`
	// The refresh interval for data sync. If duration is set to 0, the data will
	// be synced in real time. The streaming feature is not supported yet. The
	// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
	// set to the same value as the incremental refresh interval, incremental
	// sync will be disabled.
	RefreshInterval *string `pulumi:"refreshInterval"`
	// The state of connector. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	State *string `pulumi:"state"`
	// The static IP addresses used by this connector.
	StaticIpAddresses []string `pulumi:"staticIpAddresses"`
	// Whether customer has enabled static IP addresses for this connector.
	StaticIpEnabled *bool `pulumi:"staticIpEnabled"`
	// Timestamp when the DataConnector was updated.
	UpdateTime *string `pulumi:"updateTime"`
}

type DataConnectorState struct {
	// State of the action connector. This reflects whether the action connector
	// is initializing, active or has encountered errors. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	ActionState pulumi.StringPtrInput
	// User actions that must be completed before the connector can start syncing data.
	// The possible values can be: 'ALLOWLIST_STATIC_IP', 'ALLOWLIST_IN_SERVICE_ATTACHMENT'.
	BlockingReasons pulumi.StringArrayInput
	// The display name of the Collection.
	// Should be human readable, used to display collections in the Console
	// Dashboard. UTF-8 encoded string with limit of 1024 characters.
	CollectionDisplayName pulumi.StringPtrInput
	// The ID to use for the Collection, which will become the final component
	// of the Collection's resource name. A new Collection is created as
	// part of the DataConnector setup. DataConnector is a singleton
	// resource under Collection, managing all DataStores of the Collection.
	// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
	// standard with a length limit of 63 characters. Otherwise, an
	// INVALID_ARGUMENT error is returned.
	CollectionId pulumi.StringPtrInput
	// The type of connector. Each source can only map to one type.
	// For example, salesforce, confluence and jira have THIRD_PARTY connector
	// type. It is not mutable once set by system. The possible value can be:
	// 'CONNECTOR_TYPE_UNSPECIFIED', 'THIRD_PARTY', 'GCP_FHIR', 'BIG_QUERY',
	// 'GCS', 'GOOGLE_MAIL', 'GOOGLE_CALENDAR', 'GOOGLE_DRIVE',
	// 'NATIVE_CLOUD_IDENTITY', 'THIRD_PARTY_FEDERATED', 'THIRD_PARTY_EUA', 'GCNV'.
	ConnectorType pulumi.StringPtrInput
	// Timestamp when the DataConnector was created.
	CreateTime pulumi.StringPtrInput
	// The name of the data source.
	// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
	DataSource pulumi.StringPtrInput
	// List of entities from the connected data source to ingest.
	// Structure is documented below.
	Entities DataConnectorEntityArrayInput
	// The errors from initialization or from the latest connector run.
	// Structure is documented below.
	Errors DataConnectorErrorArrayInput
	// Params needed to access the source in the format of json string.
	JsonParams pulumi.StringPtrInput
	// The KMS key to be used to protect the DataStores managed by this connector.
	// Must be set for requests that need to comply with CMEK Org Policy
	// protections.
	// If this field is set and processed successfully, the DataStores created by
	// this connector will be protected by the KMS key.
	KmsKeyName pulumi.StringPtrInput
	// For periodic connectors only, the last time a data sync was completed.
	LastSyncTime pulumi.StringPtrInput
	// The most recent timestamp when this [DataConnector][] was paused,
	// affecting all functionalities such as data synchronization.
	// Pausing a connector has the following effects:
	// - All functionalities, including data synchronization, are halted.
	// - Any ongoing data synchronization job will be canceled.
	// - No future data synchronization runs will be scheduled nor can be
	//   triggered.
	LatestPauseTime pulumi.StringPtrInput
	// The geographic location where the data store should reside. The value can
	// only be one of "global", "us" and "eu".
	Location pulumi.StringPtrInput
	// The full resource name of the Data Connector.
	// Format: `projects/*/locations/*/collections/*/dataConnector`.
	Name pulumi.StringPtrInput
	// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
	Params pulumi.StringMapInput
	// The tenant project ID associated with private connectivity connectors.
	// This project must be allowlisted by in order for the connector to function.
	PrivateConnectivityProjectId pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The real-time sync state. The possible values can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	RealtimeState pulumi.StringPtrInput
	// The refresh interval for data sync. If duration is set to 0, the data will
	// be synced in real time. The streaming feature is not supported yet. The
	// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
	// set to the same value as the incremental refresh interval, incremental
	// sync will be disabled.
	RefreshInterval pulumi.StringPtrInput
	// The state of connector. The possible value can be:
	// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
	// 'INITIALIZATION_FAILED', 'UPDATING'.
	State pulumi.StringPtrInput
	// The static IP addresses used by this connector.
	StaticIpAddresses pulumi.StringArrayInput
	// Whether customer has enabled static IP addresses for this connector.
	StaticIpEnabled pulumi.BoolPtrInput
	// Timestamp when the DataConnector was updated.
	UpdateTime pulumi.StringPtrInput
}

func (DataConnectorState) ElementType() reflect.Type {
	return reflect.TypeOf((*dataConnectorState)(nil)).Elem()
}

type dataConnectorArgs struct {
	// The display name of the Collection.
	// Should be human readable, used to display collections in the Console
	// Dashboard. UTF-8 encoded string with limit of 1024 characters.
	CollectionDisplayName string `pulumi:"collectionDisplayName"`
	// The ID to use for the Collection, which will become the final component
	// of the Collection's resource name. A new Collection is created as
	// part of the DataConnector setup. DataConnector is a singleton
	// resource under Collection, managing all DataStores of the Collection.
	// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
	// standard with a length limit of 63 characters. Otherwise, an
	// INVALID_ARGUMENT error is returned.
	CollectionId string `pulumi:"collectionId"`
	// The name of the data source.
	// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
	DataSource string `pulumi:"dataSource"`
	// List of entities from the connected data source to ingest.
	// Structure is documented below.
	Entities []DataConnectorEntity `pulumi:"entities"`
	// Params needed to access the source in the format of json string.
	JsonParams *string `pulumi:"jsonParams"`
	// The KMS key to be used to protect the DataStores managed by this connector.
	// Must be set for requests that need to comply with CMEK Org Policy
	// protections.
	// If this field is set and processed successfully, the DataStores created by
	// this connector will be protected by the KMS key.
	KmsKeyName *string `pulumi:"kmsKeyName"`
	// The geographic location where the data store should reside. The value can
	// only be one of "global", "us" and "eu".
	Location string `pulumi:"location"`
	// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
	Params map[string]string `pulumi:"params"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The refresh interval for data sync. If duration is set to 0, the data will
	// be synced in real time. The streaming feature is not supported yet. The
	// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
	// set to the same value as the incremental refresh interval, incremental
	// sync will be disabled.
	RefreshInterval string `pulumi:"refreshInterval"`
	// Whether customer has enabled static IP addresses for this connector.
	StaticIpEnabled *bool `pulumi:"staticIpEnabled"`
}

// The set of arguments for constructing a DataConnector resource.
type DataConnectorArgs struct {
	// The display name of the Collection.
	// Should be human readable, used to display collections in the Console
	// Dashboard. UTF-8 encoded string with limit of 1024 characters.
	CollectionDisplayName pulumi.StringInput
	// The ID to use for the Collection, which will become the final component
	// of the Collection's resource name. A new Collection is created as
	// part of the DataConnector setup. DataConnector is a singleton
	// resource under Collection, managing all DataStores of the Collection.
	// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
	// standard with a length limit of 63 characters. Otherwise, an
	// INVALID_ARGUMENT error is returned.
	CollectionId pulumi.StringInput
	// The name of the data source.
	// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
	DataSource pulumi.StringInput
	// List of entities from the connected data source to ingest.
	// Structure is documented below.
	Entities DataConnectorEntityArrayInput
	// Params needed to access the source in the format of json string.
	JsonParams pulumi.StringPtrInput
	// The KMS key to be used to protect the DataStores managed by this connector.
	// Must be set for requests that need to comply with CMEK Org Policy
	// protections.
	// If this field is set and processed successfully, the DataStores created by
	// this connector will be protected by the KMS key.
	KmsKeyName pulumi.StringPtrInput
	// The geographic location where the data store should reside. The value can
	// only be one of "global", "us" and "eu".
	Location pulumi.StringInput
	// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
	Params pulumi.StringMapInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The refresh interval for data sync. If duration is set to 0, the data will
	// be synced in real time. The streaming feature is not supported yet. The
	// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
	// set to the same value as the incremental refresh interval, incremental
	// sync will be disabled.
	RefreshInterval pulumi.StringInput
	// Whether customer has enabled static IP addresses for this connector.
	StaticIpEnabled pulumi.BoolPtrInput
}

func (DataConnectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dataConnectorArgs)(nil)).Elem()
}

type DataConnectorInput interface {
	pulumi.Input

	ToDataConnectorOutput() DataConnectorOutput
	ToDataConnectorOutputWithContext(ctx context.Context) DataConnectorOutput
}

func (*DataConnector) ElementType() reflect.Type {
	return reflect.TypeOf((**DataConnector)(nil)).Elem()
}

func (i *DataConnector) ToDataConnectorOutput() DataConnectorOutput {
	return i.ToDataConnectorOutputWithContext(context.Background())
}

func (i *DataConnector) ToDataConnectorOutputWithContext(ctx context.Context) DataConnectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataConnectorOutput)
}

// DataConnectorArrayInput is an input type that accepts DataConnectorArray and DataConnectorArrayOutput values.
// You can construct a concrete instance of `DataConnectorArrayInput` via:
//
//	DataConnectorArray{ DataConnectorArgs{...} }
type DataConnectorArrayInput interface {
	pulumi.Input

	ToDataConnectorArrayOutput() DataConnectorArrayOutput
	ToDataConnectorArrayOutputWithContext(context.Context) DataConnectorArrayOutput
}

type DataConnectorArray []DataConnectorInput

func (DataConnectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DataConnector)(nil)).Elem()
}

func (i DataConnectorArray) ToDataConnectorArrayOutput() DataConnectorArrayOutput {
	return i.ToDataConnectorArrayOutputWithContext(context.Background())
}

func (i DataConnectorArray) ToDataConnectorArrayOutputWithContext(ctx context.Context) DataConnectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataConnectorArrayOutput)
}

// DataConnectorMapInput is an input type that accepts DataConnectorMap and DataConnectorMapOutput values.
// You can construct a concrete instance of `DataConnectorMapInput` via:
//
//	DataConnectorMap{ "key": DataConnectorArgs{...} }
type DataConnectorMapInput interface {
	pulumi.Input

	ToDataConnectorMapOutput() DataConnectorMapOutput
	ToDataConnectorMapOutputWithContext(context.Context) DataConnectorMapOutput
}

type DataConnectorMap map[string]DataConnectorInput

func (DataConnectorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DataConnector)(nil)).Elem()
}

func (i DataConnectorMap) ToDataConnectorMapOutput() DataConnectorMapOutput {
	return i.ToDataConnectorMapOutputWithContext(context.Background())
}

func (i DataConnectorMap) ToDataConnectorMapOutputWithContext(ctx context.Context) DataConnectorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataConnectorMapOutput)
}

type DataConnectorOutput struct{ *pulumi.OutputState }

func (DataConnectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DataConnector)(nil)).Elem()
}

func (o DataConnectorOutput) ToDataConnectorOutput() DataConnectorOutput {
	return o
}

func (o DataConnectorOutput) ToDataConnectorOutputWithContext(ctx context.Context) DataConnectorOutput {
	return o
}

// State of the action connector. This reflects whether the action connector
// is initializing, active or has encountered errors. The possible value can be:
// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
// 'INITIALIZATION_FAILED', 'UPDATING'.
func (o DataConnectorOutput) ActionState() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.ActionState }).(pulumi.StringOutput)
}

// User actions that must be completed before the connector can start syncing data.
// The possible values can be: 'ALLOWLIST_STATIC_IP', 'ALLOWLIST_IN_SERVICE_ATTACHMENT'.
func (o DataConnectorOutput) BlockingReasons() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringArrayOutput { return v.BlockingReasons }).(pulumi.StringArrayOutput)
}

// The display name of the Collection.
// Should be human readable, used to display collections in the Console
// Dashboard. UTF-8 encoded string with limit of 1024 characters.
func (o DataConnectorOutput) CollectionDisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.CollectionDisplayName }).(pulumi.StringOutput)
}

// The ID to use for the Collection, which will become the final component
// of the Collection's resource name. A new Collection is created as
// part of the DataConnector setup. DataConnector is a singleton
// resource under Collection, managing all DataStores of the Collection.
// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
// standard with a length limit of 63 characters. Otherwise, an
// INVALID_ARGUMENT error is returned.
func (o DataConnectorOutput) CollectionId() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.CollectionId }).(pulumi.StringOutput)
}

// The type of connector. Each source can only map to one type.
// For example, salesforce, confluence and jira have THIRD_PARTY connector
// type. It is not mutable once set by system. The possible value can be:
// 'CONNECTOR_TYPE_UNSPECIFIED', 'THIRD_PARTY', 'GCP_FHIR', 'BIG_QUERY',
// 'GCS', 'GOOGLE_MAIL', 'GOOGLE_CALENDAR', 'GOOGLE_DRIVE',
// 'NATIVE_CLOUD_IDENTITY', 'THIRD_PARTY_FEDERATED', 'THIRD_PARTY_EUA', 'GCNV'.
func (o DataConnectorOutput) ConnectorType() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.ConnectorType }).(pulumi.StringOutput)
}

// Timestamp when the DataConnector was created.
func (o DataConnectorOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// The name of the data source.
// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
func (o DataConnectorOutput) DataSource() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.DataSource }).(pulumi.StringOutput)
}

// List of entities from the connected data source to ingest.
// Structure is documented below.
func (o DataConnectorOutput) Entities() DataConnectorEntityArrayOutput {
	return o.ApplyT(func(v *DataConnector) DataConnectorEntityArrayOutput { return v.Entities }).(DataConnectorEntityArrayOutput)
}

// The errors from initialization or from the latest connector run.
// Structure is documented below.
func (o DataConnectorOutput) Errors() DataConnectorErrorArrayOutput {
	return o.ApplyT(func(v *DataConnector) DataConnectorErrorArrayOutput { return v.Errors }).(DataConnectorErrorArrayOutput)
}

// Params needed to access the source in the format of json string.
func (o DataConnectorOutput) JsonParams() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringPtrOutput { return v.JsonParams }).(pulumi.StringPtrOutput)
}

// The KMS key to be used to protect the DataStores managed by this connector.
// Must be set for requests that need to comply with CMEK Org Policy
// protections.
// If this field is set and processed successfully, the DataStores created by
// this connector will be protected by the KMS key.
func (o DataConnectorOutput) KmsKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringPtrOutput { return v.KmsKeyName }).(pulumi.StringPtrOutput)
}

// For periodic connectors only, the last time a data sync was completed.
func (o DataConnectorOutput) LastSyncTime() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.LastSyncTime }).(pulumi.StringOutput)
}

// The most recent timestamp when this [DataConnector][] was paused,
// affecting all functionalities such as data synchronization.
// Pausing a connector has the following effects:
//   - All functionalities, including data synchronization, are halted.
//   - Any ongoing data synchronization job will be canceled.
//   - No future data synchronization runs will be scheduled nor can be
//     triggered.
func (o DataConnectorOutput) LatestPauseTime() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.LatestPauseTime }).(pulumi.StringOutput)
}

// The geographic location where the data store should reside. The value can
// only be one of "global", "us" and "eu".
func (o DataConnectorOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The full resource name of the Data Connector.
// Format: `projects/*/locations/*/collections/*/dataConnector`.
func (o DataConnectorOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Params needed to access the source in the format of String-to-String (Key, Value) pairs.
func (o DataConnectorOutput) Params() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringMapOutput { return v.Params }).(pulumi.StringMapOutput)
}

// The tenant project ID associated with private connectivity connectors.
// This project must be allowlisted by in order for the connector to function.
func (o DataConnectorOutput) PrivateConnectivityProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.PrivateConnectivityProjectId }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o DataConnectorOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The real-time sync state. The possible values can be:
// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
// 'INITIALIZATION_FAILED', 'UPDATING'.
func (o DataConnectorOutput) RealtimeState() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.RealtimeState }).(pulumi.StringOutput)
}

// The refresh interval for data sync. If duration is set to 0, the data will
// be synced in real time. The streaming feature is not supported yet. The
// minimum is 30 minutes and maximum is 7 days. When the refresh interval is
// set to the same value as the incremental refresh interval, incremental
// sync will be disabled.
func (o DataConnectorOutput) RefreshInterval() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.RefreshInterval }).(pulumi.StringOutput)
}

// The state of connector. The possible value can be:
// 'STATE_UNSPECIFIED', 'CREATING', 'ACTIVE', 'FAILED', 'RUNNING', 'WARNING',
// 'INITIALIZATION_FAILED', 'UPDATING'.
func (o DataConnectorOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The static IP addresses used by this connector.
func (o DataConnectorOutput) StaticIpAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringArrayOutput { return v.StaticIpAddresses }).(pulumi.StringArrayOutput)
}

// Whether customer has enabled static IP addresses for this connector.
func (o DataConnectorOutput) StaticIpEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.BoolPtrOutput { return v.StaticIpEnabled }).(pulumi.BoolPtrOutput)
}

// Timestamp when the DataConnector was updated.
func (o DataConnectorOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *DataConnector) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

type DataConnectorArrayOutput struct{ *pulumi.OutputState }

func (DataConnectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DataConnector)(nil)).Elem()
}

func (o DataConnectorArrayOutput) ToDataConnectorArrayOutput() DataConnectorArrayOutput {
	return o
}

func (o DataConnectorArrayOutput) ToDataConnectorArrayOutputWithContext(ctx context.Context) DataConnectorArrayOutput {
	return o
}

func (o DataConnectorArrayOutput) Index(i pulumi.IntInput) DataConnectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DataConnector {
		return vs[0].([]*DataConnector)[vs[1].(int)]
	}).(DataConnectorOutput)
}

type DataConnectorMapOutput struct{ *pulumi.OutputState }

func (DataConnectorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DataConnector)(nil)).Elem()
}

func (o DataConnectorMapOutput) ToDataConnectorMapOutput() DataConnectorMapOutput {
	return o
}

func (o DataConnectorMapOutput) ToDataConnectorMapOutputWithContext(ctx context.Context) DataConnectorMapOutput {
	return o
}

func (o DataConnectorMapOutput) MapIndex(k pulumi.StringInput) DataConnectorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DataConnector {
		return vs[0].(map[string]*DataConnector)[vs[1].(string)]
	}).(DataConnectorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DataConnectorInput)(nil)).Elem(), &DataConnector{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataConnectorArrayInput)(nil)).Elem(), DataConnectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataConnectorMapInput)(nil)).Elem(), DataConnectorMap{})
	pulumi.RegisterOutputType(DataConnectorOutput{})
	pulumi.RegisterOutputType(DataConnectorArrayOutput{})
	pulumi.RegisterOutputType(DataConnectorMapOutput{})
}
