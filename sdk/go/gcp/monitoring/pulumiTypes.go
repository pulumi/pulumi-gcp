// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package monitoring

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type AlertPolicyCondition struct {
	// A condition that checks that a time series
	// continues to receive new data points.  Structure is documented below.
	ConditionAbsent *AlertPolicyConditionConditionAbsent `pulumi:"conditionAbsent"`
	// A condition that compares a time series against a
	// threshold.  Structure is documented below.
	ConditionThreshold *AlertPolicyConditionConditionThreshold `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the
	// condition in dashboards, notifications, and
	// incidents. To avoid confusion, don't use the same
	// display name for multiple conditions in the same
	// policy.
	DisplayName string `pulumi:"displayName"`
	// -
	// The unique resource name for this condition.
	// Its syntax is:
	// projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
	// [CONDITION_ID] is assigned by Stackdriver Monitoring when
	// the condition is created as part of a new or updated alerting
	// policy.
	Name *string `pulumi:"name"`
}

// AlertPolicyConditionInput is an input type that accepts AlertPolicyConditionArgs and AlertPolicyConditionOutput values.
// You can construct a concrete instance of `AlertPolicyConditionInput` via:
//
// 		 AlertPolicyConditionArgs{...}
//
type AlertPolicyConditionInput interface {
	pulumi.Input

	ToAlertPolicyConditionOutput() AlertPolicyConditionOutput
	ToAlertPolicyConditionOutputWithContext(context.Context) AlertPolicyConditionOutput
}

type AlertPolicyConditionArgs struct {
	// A condition that checks that a time series
	// continues to receive new data points.  Structure is documented below.
	ConditionAbsent AlertPolicyConditionConditionAbsentPtrInput `pulumi:"conditionAbsent"`
	// A condition that compares a time series against a
	// threshold.  Structure is documented below.
	ConditionThreshold AlertPolicyConditionConditionThresholdPtrInput `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the
	// condition in dashboards, notifications, and
	// incidents. To avoid confusion, don't use the same
	// display name for multiple conditions in the same
	// policy.
	DisplayName pulumi.StringInput `pulumi:"displayName"`
	// -
	// The unique resource name for this condition.
	// Its syntax is:
	// projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
	// [CONDITION_ID] is assigned by Stackdriver Monitoring when
	// the condition is created as part of a new or updated alerting
	// policy.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (AlertPolicyConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyCondition)(nil)).Elem()
}

func (i AlertPolicyConditionArgs) ToAlertPolicyConditionOutput() AlertPolicyConditionOutput {
	return i.ToAlertPolicyConditionOutputWithContext(context.Background())
}

func (i AlertPolicyConditionArgs) ToAlertPolicyConditionOutputWithContext(ctx context.Context) AlertPolicyConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionOutput)
}

// AlertPolicyConditionArrayInput is an input type that accepts AlertPolicyConditionArray and AlertPolicyConditionArrayOutput values.
// You can construct a concrete instance of `AlertPolicyConditionArrayInput` via:
//
// 		 AlertPolicyConditionArray{ AlertPolicyConditionArgs{...} }
//
type AlertPolicyConditionArrayInput interface {
	pulumi.Input

	ToAlertPolicyConditionArrayOutput() AlertPolicyConditionArrayOutput
	ToAlertPolicyConditionArrayOutputWithContext(context.Context) AlertPolicyConditionArrayOutput
}

type AlertPolicyConditionArray []AlertPolicyConditionInput

func (AlertPolicyConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyCondition)(nil)).Elem()
}

func (i AlertPolicyConditionArray) ToAlertPolicyConditionArrayOutput() AlertPolicyConditionArrayOutput {
	return i.ToAlertPolicyConditionArrayOutputWithContext(context.Background())
}

func (i AlertPolicyConditionArray) ToAlertPolicyConditionArrayOutputWithContext(ctx context.Context) AlertPolicyConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionArrayOutput)
}

type AlertPolicyConditionOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyCondition)(nil)).Elem()
}

func (o AlertPolicyConditionOutput) ToAlertPolicyConditionOutput() AlertPolicyConditionOutput {
	return o
}

func (o AlertPolicyConditionOutput) ToAlertPolicyConditionOutputWithContext(ctx context.Context) AlertPolicyConditionOutput {
	return o
}

// A condition that checks that a time series
// continues to receive new data points.  Structure is documented below.
func (o AlertPolicyConditionOutput) ConditionAbsent() AlertPolicyConditionConditionAbsentPtrOutput {
	return o.ApplyT(func(v AlertPolicyCondition) *AlertPolicyConditionConditionAbsent { return v.ConditionAbsent }).(AlertPolicyConditionConditionAbsentPtrOutput)
}

// A condition that compares a time series against a
// threshold.  Structure is documented below.
func (o AlertPolicyConditionOutput) ConditionThreshold() AlertPolicyConditionConditionThresholdPtrOutput {
	return o.ApplyT(func(v AlertPolicyCondition) *AlertPolicyConditionConditionThreshold { return v.ConditionThreshold }).(AlertPolicyConditionConditionThresholdPtrOutput)
}

// A short name or phrase used to identify the
// condition in dashboards, notifications, and
// incidents. To avoid confusion, don't use the same
// display name for multiple conditions in the same
// policy.
func (o AlertPolicyConditionOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v AlertPolicyCondition) string { return v.DisplayName }).(pulumi.StringOutput)
}

// -
// The unique resource name for this condition.
// Its syntax is:
// projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
// [CONDITION_ID] is assigned by Stackdriver Monitoring when
// the condition is created as part of a new or updated alerting
// policy.
func (o AlertPolicyConditionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyCondition) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type AlertPolicyConditionArrayOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyCondition)(nil)).Elem()
}

func (o AlertPolicyConditionArrayOutput) ToAlertPolicyConditionArrayOutput() AlertPolicyConditionArrayOutput {
	return o
}

func (o AlertPolicyConditionArrayOutput) ToAlertPolicyConditionArrayOutputWithContext(ctx context.Context) AlertPolicyConditionArrayOutput {
	return o
}

func (o AlertPolicyConditionArrayOutput) Index(i pulumi.IntInput) AlertPolicyConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlertPolicyCondition {
		return vs[0].([]AlertPolicyCondition)[vs[1].(int)]
	}).(AlertPolicyConditionOutput)
}

type AlertPolicyConditionConditionAbsent struct {
	// Specifies the alignment of data points in
	// individual time series as well as how to
	// combine the retrieved time series together
	// (such as when aggregating multiple streams
	// on each resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).
	// Multiple aggregations are applied in the
	// order specified.This field is similar to the
	// one in the MetricService.ListTimeSeries
	// request. It is advisable to use the
	// ListTimeSeries method when debugging this
	// field.  Structure is documented below.
	Aggregations []AlertPolicyConditionConditionAbsentAggregation `pulumi:"aggregations"`
	// The amount of time that a time series must
	// violate the threshold to be considered
	// failing. Currently, only values that are a
	// multiple of a minute--e.g., 0, 60, 120, or
	// 300 seconds--are supported. If an invalid
	// value is given, an error will be returned.
	// When choosing a duration, it is useful to
	// keep in mind the frequency of the underlying
	// time series data (which may also be affected
	// by any alignments specified in the
	// aggregations field); a good duration is long
	// enough so that a single outlier does not
	// generate spurious alerts, but short enough
	// that unhealthy states are detected and
	// alerted on quickly.
	Duration string `pulumi:"duration"`
	// A filter that identifies which time series
	// should be compared with the threshold.The
	// filter is similar to the one that is
	// specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	Filter *string `pulumi:"filter"`
	// The number/percent of time series for which
	// the comparison must hold in order for the
	// condition to trigger. If unspecified, then
	// the condition will trigger if the comparison
	// is true for any of the time series that have
	// been identified by filter and aggregations,
	// or by the ratio, if denominatorFilter and
	// denominatorAggregations are specified.  Structure is documented below.
	Trigger *AlertPolicyConditionConditionAbsentTrigger `pulumi:"trigger"`
}

// AlertPolicyConditionConditionAbsentInput is an input type that accepts AlertPolicyConditionConditionAbsentArgs and AlertPolicyConditionConditionAbsentOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentInput` via:
//
// 		 AlertPolicyConditionConditionAbsentArgs{...}
//
type AlertPolicyConditionConditionAbsentInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentOutput() AlertPolicyConditionConditionAbsentOutput
	ToAlertPolicyConditionConditionAbsentOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentOutput
}

type AlertPolicyConditionConditionAbsentArgs struct {
	// Specifies the alignment of data points in
	// individual time series as well as how to
	// combine the retrieved time series together
	// (such as when aggregating multiple streams
	// on each resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).
	// Multiple aggregations are applied in the
	// order specified.This field is similar to the
	// one in the MetricService.ListTimeSeries
	// request. It is advisable to use the
	// ListTimeSeries method when debugging this
	// field.  Structure is documented below.
	Aggregations AlertPolicyConditionConditionAbsentAggregationArrayInput `pulumi:"aggregations"`
	// The amount of time that a time series must
	// violate the threshold to be considered
	// failing. Currently, only values that are a
	// multiple of a minute--e.g., 0, 60, 120, or
	// 300 seconds--are supported. If an invalid
	// value is given, an error will be returned.
	// When choosing a duration, it is useful to
	// keep in mind the frequency of the underlying
	// time series data (which may also be affected
	// by any alignments specified in the
	// aggregations field); a good duration is long
	// enough so that a single outlier does not
	// generate spurious alerts, but short enough
	// that unhealthy states are detected and
	// alerted on quickly.
	Duration pulumi.StringInput `pulumi:"duration"`
	// A filter that identifies which time series
	// should be compared with the threshold.The
	// filter is similar to the one that is
	// specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The number/percent of time series for which
	// the comparison must hold in order for the
	// condition to trigger. If unspecified, then
	// the condition will trigger if the comparison
	// is true for any of the time series that have
	// been identified by filter and aggregations,
	// or by the ratio, if denominatorFilter and
	// denominatorAggregations are specified.  Structure is documented below.
	Trigger AlertPolicyConditionConditionAbsentTriggerPtrInput `pulumi:"trigger"`
}

func (AlertPolicyConditionConditionAbsentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsent)(nil)).Elem()
}

func (i AlertPolicyConditionConditionAbsentArgs) ToAlertPolicyConditionConditionAbsentOutput() AlertPolicyConditionConditionAbsentOutput {
	return i.ToAlertPolicyConditionConditionAbsentOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentArgs) ToAlertPolicyConditionConditionAbsentOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentOutput)
}

func (i AlertPolicyConditionConditionAbsentArgs) ToAlertPolicyConditionConditionAbsentPtrOutput() AlertPolicyConditionConditionAbsentPtrOutput {
	return i.ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentArgs) ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentOutput).ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(ctx)
}

// AlertPolicyConditionConditionAbsentPtrInput is an input type that accepts AlertPolicyConditionConditionAbsentArgs, AlertPolicyConditionConditionAbsentPtr and AlertPolicyConditionConditionAbsentPtrOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentPtrInput` via:
//
// 		 AlertPolicyConditionConditionAbsentArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyConditionConditionAbsentPtrInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentPtrOutput() AlertPolicyConditionConditionAbsentPtrOutput
	ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentPtrOutput
}

type alertPolicyConditionConditionAbsentPtrType AlertPolicyConditionConditionAbsentArgs

func AlertPolicyConditionConditionAbsentPtr(v *AlertPolicyConditionConditionAbsentArgs) AlertPolicyConditionConditionAbsentPtrInput {
	return (*alertPolicyConditionConditionAbsentPtrType)(v)
}

func (*alertPolicyConditionConditionAbsentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionAbsent)(nil)).Elem()
}

func (i *alertPolicyConditionConditionAbsentPtrType) ToAlertPolicyConditionConditionAbsentPtrOutput() AlertPolicyConditionConditionAbsentPtrOutput {
	return i.ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(context.Background())
}

func (i *alertPolicyConditionConditionAbsentPtrType) ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentPtrOutput)
}

type AlertPolicyConditionConditionAbsentOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsent)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentOutput) ToAlertPolicyConditionConditionAbsentOutput() AlertPolicyConditionConditionAbsentOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentOutput) ToAlertPolicyConditionConditionAbsentOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentOutput) ToAlertPolicyConditionConditionAbsentPtrOutput() AlertPolicyConditionConditionAbsentPtrOutput {
	return o.ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(context.Background())
}

func (o AlertPolicyConditionConditionAbsentOutput) ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsent) *AlertPolicyConditionConditionAbsent {
		return &v
	}).(AlertPolicyConditionConditionAbsentPtrOutput)
}

// Specifies the alignment of data points in
// individual time series as well as how to
// combine the retrieved time series together
// (such as when aggregating multiple streams
// on each resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).
// Multiple aggregations are applied in the
// order specified.This field is similar to the
// one in the MetricService.ListTimeSeries
// request. It is advisable to use the
// ListTimeSeries method when debugging this
// field.  Structure is documented below.
func (o AlertPolicyConditionConditionAbsentOutput) Aggregations() AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsent) []AlertPolicyConditionConditionAbsentAggregation {
		return v.Aggregations
	}).(AlertPolicyConditionConditionAbsentAggregationArrayOutput)
}

// The amount of time that a time series must
// violate the threshold to be considered
// failing. Currently, only values that are a
// multiple of a minute--e.g., 0, 60, 120, or
// 300 seconds--are supported. If an invalid
// value is given, an error will be returned.
// When choosing a duration, it is useful to
// keep in mind the frequency of the underlying
// time series data (which may also be affected
// by any alignments specified in the
// aggregations field); a good duration is long
// enough so that a single outlier does not
// generate spurious alerts, but short enough
// that unhealthy states are detected and
// alerted on quickly.
func (o AlertPolicyConditionConditionAbsentOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsent) string { return v.Duration }).(pulumi.StringOutput)
}

// A filter that identifies which time series
// should be compared with the threshold.The
// filter is similar to the one that is
// specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionAbsentOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsent) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which
// the comparison must hold in order for the
// condition to trigger. If unspecified, then
// the condition will trigger if the comparison
// is true for any of the time series that have
// been identified by filter and aggregations,
// or by the ratio, if denominatorFilter and
// denominatorAggregations are specified.  Structure is documented below.
func (o AlertPolicyConditionConditionAbsentOutput) Trigger() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsent) *AlertPolicyConditionConditionAbsentTrigger {
		return v.Trigger
	}).(AlertPolicyConditionConditionAbsentTriggerPtrOutput)
}

type AlertPolicyConditionConditionAbsentPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionAbsent)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentPtrOutput) ToAlertPolicyConditionConditionAbsentPtrOutput() AlertPolicyConditionConditionAbsentPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentPtrOutput) ToAlertPolicyConditionConditionAbsentPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentPtrOutput) Elem() AlertPolicyConditionConditionAbsentOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsent) AlertPolicyConditionConditionAbsent { return *v }).(AlertPolicyConditionConditionAbsentOutput)
}

// Specifies the alignment of data points in
// individual time series as well as how to
// combine the retrieved time series together
// (such as when aggregating multiple streams
// on each resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).
// Multiple aggregations are applied in the
// order specified.This field is similar to the
// one in the MetricService.ListTimeSeries
// request. It is advisable to use the
// ListTimeSeries method when debugging this
// field.  Structure is documented below.
func (o AlertPolicyConditionConditionAbsentPtrOutput) Aggregations() AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsent) []AlertPolicyConditionConditionAbsentAggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AlertPolicyConditionConditionAbsentAggregationArrayOutput)
}

// The amount of time that a time series must
// violate the threshold to be considered
// failing. Currently, only values that are a
// multiple of a minute--e.g., 0, 60, 120, or
// 300 seconds--are supported. If an invalid
// value is given, an error will be returned.
// When choosing a duration, it is useful to
// keep in mind the frequency of the underlying
// time series data (which may also be affected
// by any alignments specified in the
// aggregations field); a good duration is long
// enough so that a single outlier does not
// generate spurious alerts, but short enough
// that unhealthy states are detected and
// alerted on quickly.
func (o AlertPolicyConditionConditionAbsentPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsent) *string {
		if v == nil {
			return nil
		}
		return &v.Duration
	}).(pulumi.StringPtrOutput)
}

// A filter that identifies which time series
// should be compared with the threshold.The
// filter is similar to the one that is
// specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionAbsentPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsent) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which
// the comparison must hold in order for the
// condition to trigger. If unspecified, then
// the condition will trigger if the comparison
// is true for any of the time series that have
// been identified by filter and aggregations,
// or by the ratio, if denominatorFilter and
// denominatorAggregations are specified.  Structure is documented below.
func (o AlertPolicyConditionConditionAbsentPtrOutput) Trigger() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsent) *AlertPolicyConditionConditionAbsentTrigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(AlertPolicyConditionConditionAbsentTriggerPtrOutput)
}

type AlertPolicyConditionConditionAbsentAggregation struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer *string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner *string `pulumi:"perSeriesAligner"`
}

// AlertPolicyConditionConditionAbsentAggregationInput is an input type that accepts AlertPolicyConditionConditionAbsentAggregationArgs and AlertPolicyConditionConditionAbsentAggregationOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentAggregationInput` via:
//
// 		 AlertPolicyConditionConditionAbsentAggregationArgs{...}
//
type AlertPolicyConditionConditionAbsentAggregationInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentAggregationOutput() AlertPolicyConditionConditionAbsentAggregationOutput
	ToAlertPolicyConditionConditionAbsentAggregationOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentAggregationOutput
}

type AlertPolicyConditionConditionAbsentAggregationArgs struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer pulumi.StringPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner pulumi.StringPtrInput `pulumi:"perSeriesAligner"`
}

func (AlertPolicyConditionConditionAbsentAggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsentAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionAbsentAggregationArgs) ToAlertPolicyConditionConditionAbsentAggregationOutput() AlertPolicyConditionConditionAbsentAggregationOutput {
	return i.ToAlertPolicyConditionConditionAbsentAggregationOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentAggregationArgs) ToAlertPolicyConditionConditionAbsentAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentAggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentAggregationOutput)
}

// AlertPolicyConditionConditionAbsentAggregationArrayInput is an input type that accepts AlertPolicyConditionConditionAbsentAggregationArray and AlertPolicyConditionConditionAbsentAggregationArrayOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentAggregationArrayInput` via:
//
// 		 AlertPolicyConditionConditionAbsentAggregationArray{ AlertPolicyConditionConditionAbsentAggregationArgs{...} }
//
type AlertPolicyConditionConditionAbsentAggregationArrayInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentAggregationArrayOutput() AlertPolicyConditionConditionAbsentAggregationArrayOutput
	ToAlertPolicyConditionConditionAbsentAggregationArrayOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentAggregationArrayOutput
}

type AlertPolicyConditionConditionAbsentAggregationArray []AlertPolicyConditionConditionAbsentAggregationInput

func (AlertPolicyConditionConditionAbsentAggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionAbsentAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionAbsentAggregationArray) ToAlertPolicyConditionConditionAbsentAggregationArrayOutput() AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return i.ToAlertPolicyConditionConditionAbsentAggregationArrayOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentAggregationArray) ToAlertPolicyConditionConditionAbsentAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentAggregationArrayOutput)
}

type AlertPolicyConditionConditionAbsentAggregationOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentAggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsentAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentAggregationOutput) ToAlertPolicyConditionConditionAbsentAggregationOutput() AlertPolicyConditionConditionAbsentAggregationOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentAggregationOutput) ToAlertPolicyConditionConditionAbsentAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentAggregationOutput {
	return o
}

// The alignment period for per-time
// series alignment. If present,
// alignmentPeriod must be at least
// 60 seconds. After per-time series
// alignment, each time series will
// contain data points only on the
// period boundaries. If
// perSeriesAligner is not specified
// or equals ALIGN_NONE, then this
// field is ignored. If
// perSeriesAligner is specified and
// does not equal ALIGN_NONE, then
// this field must be defined;
// otherwise an error is returned.
func (o AlertPolicyConditionConditionAbsentAggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentAggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The approach to be used to combine
// time series. Not all reducer
// functions may be applied to all
// time series, depending on the
// metric type and the value type of
// the original time series.
// Reduction may change the metric
// type of value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionAbsentAggregationOutput) CrossSeriesReducer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentAggregation) *string { return v.CrossSeriesReducer }).(pulumi.StringPtrOutput)
}

// The set of fields to preserve when
// crossSeriesReducer is specified.
// The groupByFields determine how
// the time series are partitioned
// into subsets prior to applying the
// aggregation function. Each subset
// contains time series that have the
// same value for each of the
// grouping fields. Each individual
// time series is a member of exactly
// one subset. The crossSeriesReducer
// is applied to each subset of time
// series. It is not possible to
// reduce across different resource
// types, so this field implicitly
// contains resource.type. Fields not
// specified in groupByFields are
// aggregated away. If groupByFields
// is not specified and all the time
// series have the same resource
// type, then the time series are
// aggregated into a single output
// time series. If crossSeriesReducer
// is not defined, this field is
// ignored.
func (o AlertPolicyConditionConditionAbsentAggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentAggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// The approach to be used to align
// individual time series. Not all
// alignment functions may be applied
// to all time series, depending on
// the metric type and value type of
// the original time series.
// Alignment may change the metric
// type or the value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionAbsentAggregationOutput) PerSeriesAligner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentAggregation) *string { return v.PerSeriesAligner }).(pulumi.StringPtrOutput)
}

type AlertPolicyConditionConditionAbsentAggregationArrayOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentAggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionAbsentAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentAggregationArrayOutput) ToAlertPolicyConditionConditionAbsentAggregationArrayOutput() AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentAggregationArrayOutput) ToAlertPolicyConditionConditionAbsentAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentAggregationArrayOutput) Index(i pulumi.IntInput) AlertPolicyConditionConditionAbsentAggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlertPolicyConditionConditionAbsentAggregation {
		return vs[0].([]AlertPolicyConditionConditionAbsentAggregation)[vs[1].(int)]
	}).(AlertPolicyConditionConditionAbsentAggregationOutput)
}

type AlertPolicyConditionConditionAbsentTrigger struct {
	// The absolute number of time series
	// that must fail the predicate for the
	// condition to be triggered.
	Count *int `pulumi:"count"`
	// The percentage of time series that
	// must fail the predicate for the
	// condition to be triggered.
	Percent *float64 `pulumi:"percent"`
}

// AlertPolicyConditionConditionAbsentTriggerInput is an input type that accepts AlertPolicyConditionConditionAbsentTriggerArgs and AlertPolicyConditionConditionAbsentTriggerOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentTriggerInput` via:
//
// 		 AlertPolicyConditionConditionAbsentTriggerArgs{...}
//
type AlertPolicyConditionConditionAbsentTriggerInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentTriggerOutput() AlertPolicyConditionConditionAbsentTriggerOutput
	ToAlertPolicyConditionConditionAbsentTriggerOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentTriggerOutput
}

type AlertPolicyConditionConditionAbsentTriggerArgs struct {
	// The absolute number of time series
	// that must fail the predicate for the
	// condition to be triggered.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// The percentage of time series that
	// must fail the predicate for the
	// condition to be triggered.
	Percent pulumi.Float64PtrInput `pulumi:"percent"`
}

func (AlertPolicyConditionConditionAbsentTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsentTrigger)(nil)).Elem()
}

func (i AlertPolicyConditionConditionAbsentTriggerArgs) ToAlertPolicyConditionConditionAbsentTriggerOutput() AlertPolicyConditionConditionAbsentTriggerOutput {
	return i.ToAlertPolicyConditionConditionAbsentTriggerOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentTriggerArgs) ToAlertPolicyConditionConditionAbsentTriggerOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentTriggerOutput)
}

func (i AlertPolicyConditionConditionAbsentTriggerArgs) ToAlertPolicyConditionConditionAbsentTriggerPtrOutput() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return i.ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionAbsentTriggerArgs) ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentTriggerOutput).ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(ctx)
}

// AlertPolicyConditionConditionAbsentTriggerPtrInput is an input type that accepts AlertPolicyConditionConditionAbsentTriggerArgs, AlertPolicyConditionConditionAbsentTriggerPtr and AlertPolicyConditionConditionAbsentTriggerPtrOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionAbsentTriggerPtrInput` via:
//
// 		 AlertPolicyConditionConditionAbsentTriggerArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyConditionConditionAbsentTriggerPtrInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionAbsentTriggerPtrOutput() AlertPolicyConditionConditionAbsentTriggerPtrOutput
	ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(context.Context) AlertPolicyConditionConditionAbsentTriggerPtrOutput
}

type alertPolicyConditionConditionAbsentTriggerPtrType AlertPolicyConditionConditionAbsentTriggerArgs

func AlertPolicyConditionConditionAbsentTriggerPtr(v *AlertPolicyConditionConditionAbsentTriggerArgs) AlertPolicyConditionConditionAbsentTriggerPtrInput {
	return (*alertPolicyConditionConditionAbsentTriggerPtrType)(v)
}

func (*alertPolicyConditionConditionAbsentTriggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionAbsentTrigger)(nil)).Elem()
}

func (i *alertPolicyConditionConditionAbsentTriggerPtrType) ToAlertPolicyConditionConditionAbsentTriggerPtrOutput() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return i.ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(context.Background())
}

func (i *alertPolicyConditionConditionAbsentTriggerPtrType) ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionAbsentTriggerPtrOutput)
}

type AlertPolicyConditionConditionAbsentTriggerOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionAbsentTrigger)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentTriggerOutput) ToAlertPolicyConditionConditionAbsentTriggerOutput() AlertPolicyConditionConditionAbsentTriggerOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentTriggerOutput) ToAlertPolicyConditionConditionAbsentTriggerOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentTriggerOutput) ToAlertPolicyConditionConditionAbsentTriggerPtrOutput() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o.ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(context.Background())
}

func (o AlertPolicyConditionConditionAbsentTriggerOutput) ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentTrigger) *AlertPolicyConditionConditionAbsentTrigger {
		return &v
	}).(AlertPolicyConditionConditionAbsentTriggerPtrOutput)
}

// The absolute number of time series
// that must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionAbsentTriggerOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentTrigger) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// The percentage of time series that
// must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionAbsentTriggerOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionAbsentTrigger) *float64 { return v.Percent }).(pulumi.Float64PtrOutput)
}

type AlertPolicyConditionConditionAbsentTriggerPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionAbsentTriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionAbsentTrigger)(nil)).Elem()
}

func (o AlertPolicyConditionConditionAbsentTriggerPtrOutput) ToAlertPolicyConditionConditionAbsentTriggerPtrOutput() AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentTriggerPtrOutput) ToAlertPolicyConditionConditionAbsentTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionAbsentTriggerPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionAbsentTriggerPtrOutput) Elem() AlertPolicyConditionConditionAbsentTriggerOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsentTrigger) AlertPolicyConditionConditionAbsentTrigger {
		return *v
	}).(AlertPolicyConditionConditionAbsentTriggerOutput)
}

// The absolute number of time series
// that must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionAbsentTriggerPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsentTrigger) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// The percentage of time series that
// must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionAbsentTriggerPtrOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionAbsentTrigger) *float64 {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.Float64PtrOutput)
}

type AlertPolicyConditionConditionThreshold struct {
	// Specifies the alignment of data points in
	// individual time series as well as how to
	// combine the retrieved time series together
	// (such as when aggregating multiple streams
	// on each resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).
	// Multiple aggregations are applied in the
	// order specified.This field is similar to the
	// one in the MetricService.ListTimeSeries
	// request. It is advisable to use the
	// ListTimeSeries method when debugging this
	// field.  Structure is documented below.
	Aggregations []AlertPolicyConditionConditionThresholdAggregation `pulumi:"aggregations"`
	// The comparison to apply between the time
	// series (indicated by filter and aggregation)
	// and the threshold (indicated by
	// threshold_value). The comparison is applied
	// on each time series, with the time series on
	// the left-hand side and the threshold on the
	// right-hand side. Only COMPARISON_LT and
	// COMPARISON_GT are supported currently.
	Comparison string `pulumi:"comparison"`
	// Specifies the alignment of data points in
	// individual time series selected by
	// denominatorFilter as well as how to combine
	// the retrieved time series together (such as
	// when aggregating multiple streams on each
	// resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).When
	// computing ratios, the aggregations and
	// denominatorAggregations fields must use the
	// same alignment period and produce time
	// series that have the same periodicity and
	// labels.This field is similar to the one in
	// the MetricService.ListTimeSeries request. It
	// is advisable to use the ListTimeSeries
	// method when debugging this field.  Structure is documented below.
	DenominatorAggregations []AlertPolicyConditionConditionThresholdDenominatorAggregation `pulumi:"denominatorAggregations"`
	// A filter that identifies a time series that
	// should be used as the denominator of a ratio
	// that will be compared with the threshold. If
	// a denominatorFilter is specified, the time
	// series specified by the filter field will be
	// used as the numerator.The filter is similar
	// to the one that is specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	DenominatorFilter *string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must
	// violate the threshold to be considered
	// failing. Currently, only values that are a
	// multiple of a minute--e.g., 0, 60, 120, or
	// 300 seconds--are supported. If an invalid
	// value is given, an error will be returned.
	// When choosing a duration, it is useful to
	// keep in mind the frequency of the underlying
	// time series data (which may also be affected
	// by any alignments specified in the
	// aggregations field); a good duration is long
	// enough so that a single outlier does not
	// generate spurious alerts, but short enough
	// that unhealthy states are detected and
	// alerted on quickly.
	Duration string `pulumi:"duration"`
	// A filter that identifies which time series
	// should be compared with the threshold.The
	// filter is similar to the one that is
	// specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	Filter *string `pulumi:"filter"`
	// A value against which to compare the time
	// series.
	ThresholdValue *float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which
	// the comparison must hold in order for the
	// condition to trigger. If unspecified, then
	// the condition will trigger if the comparison
	// is true for any of the time series that have
	// been identified by filter and aggregations,
	// or by the ratio, if denominatorFilter and
	// denominatorAggregations are specified.  Structure is documented below.
	Trigger *AlertPolicyConditionConditionThresholdTrigger `pulumi:"trigger"`
}

// AlertPolicyConditionConditionThresholdInput is an input type that accepts AlertPolicyConditionConditionThresholdArgs and AlertPolicyConditionConditionThresholdOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdInput` via:
//
// 		 AlertPolicyConditionConditionThresholdArgs{...}
//
type AlertPolicyConditionConditionThresholdInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdOutput() AlertPolicyConditionConditionThresholdOutput
	ToAlertPolicyConditionConditionThresholdOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdOutput
}

type AlertPolicyConditionConditionThresholdArgs struct {
	// Specifies the alignment of data points in
	// individual time series as well as how to
	// combine the retrieved time series together
	// (such as when aggregating multiple streams
	// on each resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).
	// Multiple aggregations are applied in the
	// order specified.This field is similar to the
	// one in the MetricService.ListTimeSeries
	// request. It is advisable to use the
	// ListTimeSeries method when debugging this
	// field.  Structure is documented below.
	Aggregations AlertPolicyConditionConditionThresholdAggregationArrayInput `pulumi:"aggregations"`
	// The comparison to apply between the time
	// series (indicated by filter and aggregation)
	// and the threshold (indicated by
	// threshold_value). The comparison is applied
	// on each time series, with the time series on
	// the left-hand side and the threshold on the
	// right-hand side. Only COMPARISON_LT and
	// COMPARISON_GT are supported currently.
	Comparison pulumi.StringInput `pulumi:"comparison"`
	// Specifies the alignment of data points in
	// individual time series selected by
	// denominatorFilter as well as how to combine
	// the retrieved time series together (such as
	// when aggregating multiple streams on each
	// resource to a single stream for each
	// resource or when aggregating streams across
	// all members of a group of resources).When
	// computing ratios, the aggregations and
	// denominatorAggregations fields must use the
	// same alignment period and produce time
	// series that have the same periodicity and
	// labels.This field is similar to the one in
	// the MetricService.ListTimeSeries request. It
	// is advisable to use the ListTimeSeries
	// method when debugging this field.  Structure is documented below.
	DenominatorAggregations AlertPolicyConditionConditionThresholdDenominatorAggregationArrayInput `pulumi:"denominatorAggregations"`
	// A filter that identifies a time series that
	// should be used as the denominator of a ratio
	// that will be compared with the threshold. If
	// a denominatorFilter is specified, the time
	// series specified by the filter field will be
	// used as the numerator.The filter is similar
	// to the one that is specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	DenominatorFilter pulumi.StringPtrInput `pulumi:"denominatorFilter"`
	// The amount of time that a time series must
	// violate the threshold to be considered
	// failing. Currently, only values that are a
	// multiple of a minute--e.g., 0, 60, 120, or
	// 300 seconds--are supported. If an invalid
	// value is given, an error will be returned.
	// When choosing a duration, it is useful to
	// keep in mind the frequency of the underlying
	// time series data (which may also be affected
	// by any alignments specified in the
	// aggregations field); a good duration is long
	// enough so that a single outlier does not
	// generate spurious alerts, but short enough
	// that unhealthy states are detected and
	// alerted on quickly.
	Duration pulumi.StringInput `pulumi:"duration"`
	// A filter that identifies which time series
	// should be compared with the threshold.The
	// filter is similar to the one that is
	// specified in the
	// MetricService.ListTimeSeries request (that
	// call is useful to verify the time series
	// that will be retrieved / processed) and must
	// specify the metric type and optionally may
	// contain restrictions on resource type,
	// resource labels, and metric labels. This
	// field may not exceed 2048 Unicode characters
	// in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// A value against which to compare the time
	// series.
	ThresholdValue pulumi.Float64PtrInput `pulumi:"thresholdValue"`
	// The number/percent of time series for which
	// the comparison must hold in order for the
	// condition to trigger. If unspecified, then
	// the condition will trigger if the comparison
	// is true for any of the time series that have
	// been identified by filter and aggregations,
	// or by the ratio, if denominatorFilter and
	// denominatorAggregations are specified.  Structure is documented below.
	Trigger AlertPolicyConditionConditionThresholdTriggerPtrInput `pulumi:"trigger"`
}

func (AlertPolicyConditionConditionThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThreshold)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdArgs) ToAlertPolicyConditionConditionThresholdOutput() AlertPolicyConditionConditionThresholdOutput {
	return i.ToAlertPolicyConditionConditionThresholdOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdArgs) ToAlertPolicyConditionConditionThresholdOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdOutput)
}

func (i AlertPolicyConditionConditionThresholdArgs) ToAlertPolicyConditionConditionThresholdPtrOutput() AlertPolicyConditionConditionThresholdPtrOutput {
	return i.ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdArgs) ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdOutput).ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(ctx)
}

// AlertPolicyConditionConditionThresholdPtrInput is an input type that accepts AlertPolicyConditionConditionThresholdArgs, AlertPolicyConditionConditionThresholdPtr and AlertPolicyConditionConditionThresholdPtrOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdPtrInput` via:
//
// 		 AlertPolicyConditionConditionThresholdArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyConditionConditionThresholdPtrInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdPtrOutput() AlertPolicyConditionConditionThresholdPtrOutput
	ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdPtrOutput
}

type alertPolicyConditionConditionThresholdPtrType AlertPolicyConditionConditionThresholdArgs

func AlertPolicyConditionConditionThresholdPtr(v *AlertPolicyConditionConditionThresholdArgs) AlertPolicyConditionConditionThresholdPtrInput {
	return (*alertPolicyConditionConditionThresholdPtrType)(v)
}

func (*alertPolicyConditionConditionThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionThreshold)(nil)).Elem()
}

func (i *alertPolicyConditionConditionThresholdPtrType) ToAlertPolicyConditionConditionThresholdPtrOutput() AlertPolicyConditionConditionThresholdPtrOutput {
	return i.ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(context.Background())
}

func (i *alertPolicyConditionConditionThresholdPtrType) ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdPtrOutput)
}

type AlertPolicyConditionConditionThresholdOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThreshold)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdOutput) ToAlertPolicyConditionConditionThresholdOutput() AlertPolicyConditionConditionThresholdOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdOutput) ToAlertPolicyConditionConditionThresholdOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdOutput) ToAlertPolicyConditionConditionThresholdPtrOutput() AlertPolicyConditionConditionThresholdPtrOutput {
	return o.ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(context.Background())
}

func (o AlertPolicyConditionConditionThresholdOutput) ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) *AlertPolicyConditionConditionThreshold {
		return &v
	}).(AlertPolicyConditionConditionThresholdPtrOutput)
}

// Specifies the alignment of data points in
// individual time series as well as how to
// combine the retrieved time series together
// (such as when aggregating multiple streams
// on each resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).
// Multiple aggregations are applied in the
// order specified.This field is similar to the
// one in the MetricService.ListTimeSeries
// request. It is advisable to use the
// ListTimeSeries method when debugging this
// field.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdOutput) Aggregations() AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) []AlertPolicyConditionConditionThresholdAggregation {
		return v.Aggregations
	}).(AlertPolicyConditionConditionThresholdAggregationArrayOutput)
}

// The comparison to apply between the time
// series (indicated by filter and aggregation)
// and the threshold (indicated by
// threshold_value). The comparison is applied
// on each time series, with the time series on
// the left-hand side and the threshold on the
// right-hand side. Only COMPARISON_LT and
// COMPARISON_GT are supported currently.
func (o AlertPolicyConditionConditionThresholdOutput) Comparison() pulumi.StringOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) string { return v.Comparison }).(pulumi.StringOutput)
}

// Specifies the alignment of data points in
// individual time series selected by
// denominatorFilter as well as how to combine
// the retrieved time series together (such as
// when aggregating multiple streams on each
// resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).When
// computing ratios, the aggregations and
// denominatorAggregations fields must use the
// same alignment period and produce time
// series that have the same periodicity and
// labels.This field is similar to the one in
// the MetricService.ListTimeSeries request. It
// is advisable to use the ListTimeSeries
// method when debugging this field.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdOutput) DenominatorAggregations() AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) []AlertPolicyConditionConditionThresholdDenominatorAggregation {
		return v.DenominatorAggregations
	}).(AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput)
}

// A filter that identifies a time series that
// should be used as the denominator of a ratio
// that will be compared with the threshold. If
// a denominatorFilter is specified, the time
// series specified by the filter field will be
// used as the numerator.The filter is similar
// to the one that is specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionThresholdOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) *string { return v.DenominatorFilter }).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must
// violate the threshold to be considered
// failing. Currently, only values that are a
// multiple of a minute--e.g., 0, 60, 120, or
// 300 seconds--are supported. If an invalid
// value is given, an error will be returned.
// When choosing a duration, it is useful to
// keep in mind the frequency of the underlying
// time series data (which may also be affected
// by any alignments specified in the
// aggregations field); a good duration is long
// enough so that a single outlier does not
// generate spurious alerts, but short enough
// that unhealthy states are detected and
// alerted on quickly.
func (o AlertPolicyConditionConditionThresholdOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) string { return v.Duration }).(pulumi.StringOutput)
}

// A filter that identifies which time series
// should be compared with the threshold.The
// filter is similar to the one that is
// specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionThresholdOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// A value against which to compare the time
// series.
func (o AlertPolicyConditionConditionThresholdOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) *float64 { return v.ThresholdValue }).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which
// the comparison must hold in order for the
// condition to trigger. If unspecified, then
// the condition will trigger if the comparison
// is true for any of the time series that have
// been identified by filter and aggregations,
// or by the ratio, if denominatorFilter and
// denominatorAggregations are specified.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdOutput) Trigger() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThreshold) *AlertPolicyConditionConditionThresholdTrigger {
		return v.Trigger
	}).(AlertPolicyConditionConditionThresholdTriggerPtrOutput)
}

type AlertPolicyConditionConditionThresholdPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionThreshold)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdPtrOutput) ToAlertPolicyConditionConditionThresholdPtrOutput() AlertPolicyConditionConditionThresholdPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdPtrOutput) ToAlertPolicyConditionConditionThresholdPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdPtrOutput) Elem() AlertPolicyConditionConditionThresholdOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) AlertPolicyConditionConditionThreshold { return *v }).(AlertPolicyConditionConditionThresholdOutput)
}

// Specifies the alignment of data points in
// individual time series as well as how to
// combine the retrieved time series together
// (such as when aggregating multiple streams
// on each resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).
// Multiple aggregations are applied in the
// order specified.This field is similar to the
// one in the MetricService.ListTimeSeries
// request. It is advisable to use the
// ListTimeSeries method when debugging this
// field.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdPtrOutput) Aggregations() AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) []AlertPolicyConditionConditionThresholdAggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AlertPolicyConditionConditionThresholdAggregationArrayOutput)
}

// The comparison to apply between the time
// series (indicated by filter and aggregation)
// and the threshold (indicated by
// threshold_value). The comparison is applied
// on each time series, with the time series on
// the left-hand side and the threshold on the
// right-hand side. Only COMPARISON_LT and
// COMPARISON_GT are supported currently.
func (o AlertPolicyConditionConditionThresholdPtrOutput) Comparison() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *string {
		if v == nil {
			return nil
		}
		return &v.Comparison
	}).(pulumi.StringPtrOutput)
}

// Specifies the alignment of data points in
// individual time series selected by
// denominatorFilter as well as how to combine
// the retrieved time series together (such as
// when aggregating multiple streams on each
// resource to a single stream for each
// resource or when aggregating streams across
// all members of a group of resources).When
// computing ratios, the aggregations and
// denominatorAggregations fields must use the
// same alignment period and produce time
// series that have the same periodicity and
// labels.This field is similar to the one in
// the MetricService.ListTimeSeries request. It
// is advisable to use the ListTimeSeries
// method when debugging this field.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdPtrOutput) DenominatorAggregations() AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) []AlertPolicyConditionConditionThresholdDenominatorAggregation {
		if v == nil {
			return nil
		}
		return v.DenominatorAggregations
	}).(AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput)
}

// A filter that identifies a time series that
// should be used as the denominator of a ratio
// that will be compared with the threshold. If
// a denominatorFilter is specified, the time
// series specified by the filter field will be
// used as the numerator.The filter is similar
// to the one that is specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionThresholdPtrOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *string {
		if v == nil {
			return nil
		}
		return v.DenominatorFilter
	}).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must
// violate the threshold to be considered
// failing. Currently, only values that are a
// multiple of a minute--e.g., 0, 60, 120, or
// 300 seconds--are supported. If an invalid
// value is given, an error will be returned.
// When choosing a duration, it is useful to
// keep in mind the frequency of the underlying
// time series data (which may also be affected
// by any alignments specified in the
// aggregations field); a good duration is long
// enough so that a single outlier does not
// generate spurious alerts, but short enough
// that unhealthy states are detected and
// alerted on quickly.
func (o AlertPolicyConditionConditionThresholdPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *string {
		if v == nil {
			return nil
		}
		return &v.Duration
	}).(pulumi.StringPtrOutput)
}

// A filter that identifies which time series
// should be compared with the threshold.The
// filter is similar to the one that is
// specified in the
// MetricService.ListTimeSeries request (that
// call is useful to verify the time series
// that will be retrieved / processed) and must
// specify the metric type and optionally may
// contain restrictions on resource type,
// resource labels, and metric labels. This
// field may not exceed 2048 Unicode characters
// in length.
func (o AlertPolicyConditionConditionThresholdPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// A value against which to compare the time
// series.
func (o AlertPolicyConditionConditionThresholdPtrOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.ThresholdValue
	}).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which
// the comparison must hold in order for the
// condition to trigger. If unspecified, then
// the condition will trigger if the comparison
// is true for any of the time series that have
// been identified by filter and aggregations,
// or by the ratio, if denominatorFilter and
// denominatorAggregations are specified.  Structure is documented below.
func (o AlertPolicyConditionConditionThresholdPtrOutput) Trigger() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThreshold) *AlertPolicyConditionConditionThresholdTrigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(AlertPolicyConditionConditionThresholdTriggerPtrOutput)
}

type AlertPolicyConditionConditionThresholdAggregation struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer *string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner *string `pulumi:"perSeriesAligner"`
}

// AlertPolicyConditionConditionThresholdAggregationInput is an input type that accepts AlertPolicyConditionConditionThresholdAggregationArgs and AlertPolicyConditionConditionThresholdAggregationOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdAggregationInput` via:
//
// 		 AlertPolicyConditionConditionThresholdAggregationArgs{...}
//
type AlertPolicyConditionConditionThresholdAggregationInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdAggregationOutput() AlertPolicyConditionConditionThresholdAggregationOutput
	ToAlertPolicyConditionConditionThresholdAggregationOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdAggregationOutput
}

type AlertPolicyConditionConditionThresholdAggregationArgs struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer pulumi.StringPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner pulumi.StringPtrInput `pulumi:"perSeriesAligner"`
}

func (AlertPolicyConditionConditionThresholdAggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdAggregationArgs) ToAlertPolicyConditionConditionThresholdAggregationOutput() AlertPolicyConditionConditionThresholdAggregationOutput {
	return i.ToAlertPolicyConditionConditionThresholdAggregationOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdAggregationArgs) ToAlertPolicyConditionConditionThresholdAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdAggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdAggregationOutput)
}

// AlertPolicyConditionConditionThresholdAggregationArrayInput is an input type that accepts AlertPolicyConditionConditionThresholdAggregationArray and AlertPolicyConditionConditionThresholdAggregationArrayOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdAggregationArrayInput` via:
//
// 		 AlertPolicyConditionConditionThresholdAggregationArray{ AlertPolicyConditionConditionThresholdAggregationArgs{...} }
//
type AlertPolicyConditionConditionThresholdAggregationArrayInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdAggregationArrayOutput() AlertPolicyConditionConditionThresholdAggregationArrayOutput
	ToAlertPolicyConditionConditionThresholdAggregationArrayOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdAggregationArrayOutput
}

type AlertPolicyConditionConditionThresholdAggregationArray []AlertPolicyConditionConditionThresholdAggregationInput

func (AlertPolicyConditionConditionThresholdAggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionThresholdAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdAggregationArray) ToAlertPolicyConditionConditionThresholdAggregationArrayOutput() AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return i.ToAlertPolicyConditionConditionThresholdAggregationArrayOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdAggregationArray) ToAlertPolicyConditionConditionThresholdAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdAggregationArrayOutput)
}

type AlertPolicyConditionConditionThresholdAggregationOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdAggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdAggregationOutput) ToAlertPolicyConditionConditionThresholdAggregationOutput() AlertPolicyConditionConditionThresholdAggregationOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdAggregationOutput) ToAlertPolicyConditionConditionThresholdAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdAggregationOutput {
	return o
}

// The alignment period for per-time
// series alignment. If present,
// alignmentPeriod must be at least
// 60 seconds. After per-time series
// alignment, each time series will
// contain data points only on the
// period boundaries. If
// perSeriesAligner is not specified
// or equals ALIGN_NONE, then this
// field is ignored. If
// perSeriesAligner is specified and
// does not equal ALIGN_NONE, then
// this field must be defined;
// otherwise an error is returned.
func (o AlertPolicyConditionConditionThresholdAggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdAggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The approach to be used to combine
// time series. Not all reducer
// functions may be applied to all
// time series, depending on the
// metric type and the value type of
// the original time series.
// Reduction may change the metric
// type of value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionThresholdAggregationOutput) CrossSeriesReducer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdAggregation) *string { return v.CrossSeriesReducer }).(pulumi.StringPtrOutput)
}

// The set of fields to preserve when
// crossSeriesReducer is specified.
// The groupByFields determine how
// the time series are partitioned
// into subsets prior to applying the
// aggregation function. Each subset
// contains time series that have the
// same value for each of the
// grouping fields. Each individual
// time series is a member of exactly
// one subset. The crossSeriesReducer
// is applied to each subset of time
// series. It is not possible to
// reduce across different resource
// types, so this field implicitly
// contains resource.type. Fields not
// specified in groupByFields are
// aggregated away. If groupByFields
// is not specified and all the time
// series have the same resource
// type, then the time series are
// aggregated into a single output
// time series. If crossSeriesReducer
// is not defined, this field is
// ignored.
func (o AlertPolicyConditionConditionThresholdAggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdAggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// The approach to be used to align
// individual time series. Not all
// alignment functions may be applied
// to all time series, depending on
// the metric type and value type of
// the original time series.
// Alignment may change the metric
// type or the value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionThresholdAggregationOutput) PerSeriesAligner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdAggregation) *string { return v.PerSeriesAligner }).(pulumi.StringPtrOutput)
}

type AlertPolicyConditionConditionThresholdAggregationArrayOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdAggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionThresholdAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdAggregationArrayOutput) ToAlertPolicyConditionConditionThresholdAggregationArrayOutput() AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdAggregationArrayOutput) ToAlertPolicyConditionConditionThresholdAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdAggregationArrayOutput) Index(i pulumi.IntInput) AlertPolicyConditionConditionThresholdAggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlertPolicyConditionConditionThresholdAggregation {
		return vs[0].([]AlertPolicyConditionConditionThresholdAggregation)[vs[1].(int)]
	}).(AlertPolicyConditionConditionThresholdAggregationOutput)
}

type AlertPolicyConditionConditionThresholdDenominatorAggregation struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer *string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner *string `pulumi:"perSeriesAligner"`
}

// AlertPolicyConditionConditionThresholdDenominatorAggregationInput is an input type that accepts AlertPolicyConditionConditionThresholdDenominatorAggregationArgs and AlertPolicyConditionConditionThresholdDenominatorAggregationOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdDenominatorAggregationInput` via:
//
// 		 AlertPolicyConditionConditionThresholdDenominatorAggregationArgs{...}
//
type AlertPolicyConditionConditionThresholdDenominatorAggregationInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationOutput
	ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationOutput
}

type AlertPolicyConditionConditionThresholdDenominatorAggregationArgs struct {
	// The alignment period for per-time
	// series alignment. If present,
	// alignmentPeriod must be at least
	// 60 seconds. After per-time series
	// alignment, each time series will
	// contain data points only on the
	// period boundaries. If
	// perSeriesAligner is not specified
	// or equals ALIGN_NONE, then this
	// field is ignored. If
	// perSeriesAligner is specified and
	// does not equal ALIGN_NONE, then
	// this field must be defined;
	// otherwise an error is returned.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The approach to be used to combine
	// time series. Not all reducer
	// functions may be applied to all
	// time series, depending on the
	// metric type and the value type of
	// the original time series.
	// Reduction may change the metric
	// type of value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	CrossSeriesReducer pulumi.StringPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when
	// crossSeriesReducer is specified.
	// The groupByFields determine how
	// the time series are partitioned
	// into subsets prior to applying the
	// aggregation function. Each subset
	// contains time series that have the
	// same value for each of the
	// grouping fields. Each individual
	// time series is a member of exactly
	// one subset. The crossSeriesReducer
	// is applied to each subset of time
	// series. It is not possible to
	// reduce across different resource
	// types, so this field implicitly
	// contains resource.type. Fields not
	// specified in groupByFields are
	// aggregated away. If groupByFields
	// is not specified and all the time
	// series have the same resource
	// type, then the time series are
	// aggregated into a single output
	// time series. If crossSeriesReducer
	// is not defined, this field is
	// ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// The approach to be used to align
	// individual time series. Not all
	// alignment functions may be applied
	// to all time series, depending on
	// the metric type and value type of
	// the original time series.
	// Alignment may change the metric
	// type or the value type of the time
	// series.Time series data must be
	// aligned in order to perform cross-
	// time series reduction. If
	// crossSeriesReducer is specified,
	// then perSeriesAligner must be
	// specified and not equal ALIGN_NONE
	// and alignmentPeriod must be
	// specified; otherwise, an error is
	// returned.
	PerSeriesAligner pulumi.StringPtrInput `pulumi:"perSeriesAligner"`
}

func (AlertPolicyConditionConditionThresholdDenominatorAggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdDenominatorAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdDenominatorAggregationArgs) ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationOutput {
	return i.ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdDenominatorAggregationArgs) ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdDenominatorAggregationOutput)
}

// AlertPolicyConditionConditionThresholdDenominatorAggregationArrayInput is an input type that accepts AlertPolicyConditionConditionThresholdDenominatorAggregationArray and AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdDenominatorAggregationArrayInput` via:
//
// 		 AlertPolicyConditionConditionThresholdDenominatorAggregationArray{ AlertPolicyConditionConditionThresholdDenominatorAggregationArgs{...} }
//
type AlertPolicyConditionConditionThresholdDenominatorAggregationArrayInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput
	ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput
}

type AlertPolicyConditionConditionThresholdDenominatorAggregationArray []AlertPolicyConditionConditionThresholdDenominatorAggregationInput

func (AlertPolicyConditionConditionThresholdDenominatorAggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionThresholdDenominatorAggregation)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdDenominatorAggregationArray) ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return i.ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdDenominatorAggregationArray) ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput)
}

type AlertPolicyConditionConditionThresholdDenominatorAggregationOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdDenominatorAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) ToAlertPolicyConditionConditionThresholdDenominatorAggregationOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationOutput {
	return o
}

// The alignment period for per-time
// series alignment. If present,
// alignmentPeriod must be at least
// 60 seconds. After per-time series
// alignment, each time series will
// contain data points only on the
// period boundaries. If
// perSeriesAligner is not specified
// or equals ALIGN_NONE, then this
// field is ignored. If
// perSeriesAligner is specified and
// does not equal ALIGN_NONE, then
// this field must be defined;
// otherwise an error is returned.
func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdDenominatorAggregation) *string {
		return v.AlignmentPeriod
	}).(pulumi.StringPtrOutput)
}

// The approach to be used to combine
// time series. Not all reducer
// functions may be applied to all
// time series, depending on the
// metric type and the value type of
// the original time series.
// Reduction may change the metric
// type of value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) CrossSeriesReducer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdDenominatorAggregation) *string {
		return v.CrossSeriesReducer
	}).(pulumi.StringPtrOutput)
}

// The set of fields to preserve when
// crossSeriesReducer is specified.
// The groupByFields determine how
// the time series are partitioned
// into subsets prior to applying the
// aggregation function. Each subset
// contains time series that have the
// same value for each of the
// grouping fields. Each individual
// time series is a member of exactly
// one subset. The crossSeriesReducer
// is applied to each subset of time
// series. It is not possible to
// reduce across different resource
// types, so this field implicitly
// contains resource.type. Fields not
// specified in groupByFields are
// aggregated away. If groupByFields
// is not specified and all the time
// series have the same resource
// type, then the time series are
// aggregated into a single output
// time series. If crossSeriesReducer
// is not defined, this field is
// ignored.
func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdDenominatorAggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// The approach to be used to align
// individual time series. Not all
// alignment functions may be applied
// to all time series, depending on
// the metric type and value type of
// the original time series.
// Alignment may change the metric
// type or the value type of the time
// series.Time series data must be
// aligned in order to perform cross-
// time series reduction. If
// crossSeriesReducer is specified,
// then perSeriesAligner must be
// specified and not equal ALIGN_NONE
// and alignmentPeriod must be
// specified; otherwise, an error is
// returned.
func (o AlertPolicyConditionConditionThresholdDenominatorAggregationOutput) PerSeriesAligner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdDenominatorAggregation) *string {
		return v.PerSeriesAligner
	}).(pulumi.StringPtrOutput)
}

type AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlertPolicyConditionConditionThresholdDenominatorAggregation)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput) ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput() AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput) ToAlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput) Index(i pulumi.IntInput) AlertPolicyConditionConditionThresholdDenominatorAggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlertPolicyConditionConditionThresholdDenominatorAggregation {
		return vs[0].([]AlertPolicyConditionConditionThresholdDenominatorAggregation)[vs[1].(int)]
	}).(AlertPolicyConditionConditionThresholdDenominatorAggregationOutput)
}

type AlertPolicyConditionConditionThresholdTrigger struct {
	// The absolute number of time series
	// that must fail the predicate for the
	// condition to be triggered.
	Count *int `pulumi:"count"`
	// The percentage of time series that
	// must fail the predicate for the
	// condition to be triggered.
	Percent *float64 `pulumi:"percent"`
}

// AlertPolicyConditionConditionThresholdTriggerInput is an input type that accepts AlertPolicyConditionConditionThresholdTriggerArgs and AlertPolicyConditionConditionThresholdTriggerOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdTriggerInput` via:
//
// 		 AlertPolicyConditionConditionThresholdTriggerArgs{...}
//
type AlertPolicyConditionConditionThresholdTriggerInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdTriggerOutput() AlertPolicyConditionConditionThresholdTriggerOutput
	ToAlertPolicyConditionConditionThresholdTriggerOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdTriggerOutput
}

type AlertPolicyConditionConditionThresholdTriggerArgs struct {
	// The absolute number of time series
	// that must fail the predicate for the
	// condition to be triggered.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// The percentage of time series that
	// must fail the predicate for the
	// condition to be triggered.
	Percent pulumi.Float64PtrInput `pulumi:"percent"`
}

func (AlertPolicyConditionConditionThresholdTriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdTrigger)(nil)).Elem()
}

func (i AlertPolicyConditionConditionThresholdTriggerArgs) ToAlertPolicyConditionConditionThresholdTriggerOutput() AlertPolicyConditionConditionThresholdTriggerOutput {
	return i.ToAlertPolicyConditionConditionThresholdTriggerOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdTriggerArgs) ToAlertPolicyConditionConditionThresholdTriggerOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdTriggerOutput)
}

func (i AlertPolicyConditionConditionThresholdTriggerArgs) ToAlertPolicyConditionConditionThresholdTriggerPtrOutput() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return i.ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(context.Background())
}

func (i AlertPolicyConditionConditionThresholdTriggerArgs) ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdTriggerOutput).ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(ctx)
}

// AlertPolicyConditionConditionThresholdTriggerPtrInput is an input type that accepts AlertPolicyConditionConditionThresholdTriggerArgs, AlertPolicyConditionConditionThresholdTriggerPtr and AlertPolicyConditionConditionThresholdTriggerPtrOutput values.
// You can construct a concrete instance of `AlertPolicyConditionConditionThresholdTriggerPtrInput` via:
//
// 		 AlertPolicyConditionConditionThresholdTriggerArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyConditionConditionThresholdTriggerPtrInput interface {
	pulumi.Input

	ToAlertPolicyConditionConditionThresholdTriggerPtrOutput() AlertPolicyConditionConditionThresholdTriggerPtrOutput
	ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(context.Context) AlertPolicyConditionConditionThresholdTriggerPtrOutput
}

type alertPolicyConditionConditionThresholdTriggerPtrType AlertPolicyConditionConditionThresholdTriggerArgs

func AlertPolicyConditionConditionThresholdTriggerPtr(v *AlertPolicyConditionConditionThresholdTriggerArgs) AlertPolicyConditionConditionThresholdTriggerPtrInput {
	return (*alertPolicyConditionConditionThresholdTriggerPtrType)(v)
}

func (*alertPolicyConditionConditionThresholdTriggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionThresholdTrigger)(nil)).Elem()
}

func (i *alertPolicyConditionConditionThresholdTriggerPtrType) ToAlertPolicyConditionConditionThresholdTriggerPtrOutput() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return i.ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(context.Background())
}

func (i *alertPolicyConditionConditionThresholdTriggerPtrType) ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyConditionConditionThresholdTriggerPtrOutput)
}

type AlertPolicyConditionConditionThresholdTriggerOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdTriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyConditionConditionThresholdTrigger)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdTriggerOutput) ToAlertPolicyConditionConditionThresholdTriggerOutput() AlertPolicyConditionConditionThresholdTriggerOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdTriggerOutput) ToAlertPolicyConditionConditionThresholdTriggerOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdTriggerOutput) ToAlertPolicyConditionConditionThresholdTriggerPtrOutput() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o.ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(context.Background())
}

func (o AlertPolicyConditionConditionThresholdTriggerOutput) ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdTrigger) *AlertPolicyConditionConditionThresholdTrigger {
		return &v
	}).(AlertPolicyConditionConditionThresholdTriggerPtrOutput)
}

// The absolute number of time series
// that must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionThresholdTriggerOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdTrigger) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// The percentage of time series that
// must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionThresholdTriggerOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v AlertPolicyConditionConditionThresholdTrigger) *float64 { return v.Percent }).(pulumi.Float64PtrOutput)
}

type AlertPolicyConditionConditionThresholdTriggerPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyConditionConditionThresholdTriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyConditionConditionThresholdTrigger)(nil)).Elem()
}

func (o AlertPolicyConditionConditionThresholdTriggerPtrOutput) ToAlertPolicyConditionConditionThresholdTriggerPtrOutput() AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdTriggerPtrOutput) ToAlertPolicyConditionConditionThresholdTriggerPtrOutputWithContext(ctx context.Context) AlertPolicyConditionConditionThresholdTriggerPtrOutput {
	return o
}

func (o AlertPolicyConditionConditionThresholdTriggerPtrOutput) Elem() AlertPolicyConditionConditionThresholdTriggerOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThresholdTrigger) AlertPolicyConditionConditionThresholdTrigger {
		return *v
	}).(AlertPolicyConditionConditionThresholdTriggerOutput)
}

// The absolute number of time series
// that must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionThresholdTriggerPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThresholdTrigger) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// The percentage of time series that
// must fail the predicate for the
// condition to be triggered.
func (o AlertPolicyConditionConditionThresholdTriggerPtrOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *AlertPolicyConditionConditionThresholdTrigger) *float64 {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.Float64PtrOutput)
}

type AlertPolicyCreationRecord struct {
	MutateTime *string `pulumi:"mutateTime"`
	MutatedBy  *string `pulumi:"mutatedBy"`
}

// AlertPolicyCreationRecordInput is an input type that accepts AlertPolicyCreationRecordArgs and AlertPolicyCreationRecordOutput values.
// You can construct a concrete instance of `AlertPolicyCreationRecordInput` via:
//
// 		 AlertPolicyCreationRecordArgs{...}
//
type AlertPolicyCreationRecordInput interface {
	pulumi.Input

	ToAlertPolicyCreationRecordOutput() AlertPolicyCreationRecordOutput
	ToAlertPolicyCreationRecordOutputWithContext(context.Context) AlertPolicyCreationRecordOutput
}

type AlertPolicyCreationRecordArgs struct {
	MutateTime pulumi.StringPtrInput `pulumi:"mutateTime"`
	MutatedBy  pulumi.StringPtrInput `pulumi:"mutatedBy"`
}

func (AlertPolicyCreationRecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyCreationRecord)(nil)).Elem()
}

func (i AlertPolicyCreationRecordArgs) ToAlertPolicyCreationRecordOutput() AlertPolicyCreationRecordOutput {
	return i.ToAlertPolicyCreationRecordOutputWithContext(context.Background())
}

func (i AlertPolicyCreationRecordArgs) ToAlertPolicyCreationRecordOutputWithContext(ctx context.Context) AlertPolicyCreationRecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyCreationRecordOutput)
}

func (i AlertPolicyCreationRecordArgs) ToAlertPolicyCreationRecordPtrOutput() AlertPolicyCreationRecordPtrOutput {
	return i.ToAlertPolicyCreationRecordPtrOutputWithContext(context.Background())
}

func (i AlertPolicyCreationRecordArgs) ToAlertPolicyCreationRecordPtrOutputWithContext(ctx context.Context) AlertPolicyCreationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyCreationRecordOutput).ToAlertPolicyCreationRecordPtrOutputWithContext(ctx)
}

// AlertPolicyCreationRecordPtrInput is an input type that accepts AlertPolicyCreationRecordArgs, AlertPolicyCreationRecordPtr and AlertPolicyCreationRecordPtrOutput values.
// You can construct a concrete instance of `AlertPolicyCreationRecordPtrInput` via:
//
// 		 AlertPolicyCreationRecordArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyCreationRecordPtrInput interface {
	pulumi.Input

	ToAlertPolicyCreationRecordPtrOutput() AlertPolicyCreationRecordPtrOutput
	ToAlertPolicyCreationRecordPtrOutputWithContext(context.Context) AlertPolicyCreationRecordPtrOutput
}

type alertPolicyCreationRecordPtrType AlertPolicyCreationRecordArgs

func AlertPolicyCreationRecordPtr(v *AlertPolicyCreationRecordArgs) AlertPolicyCreationRecordPtrInput {
	return (*alertPolicyCreationRecordPtrType)(v)
}

func (*alertPolicyCreationRecordPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyCreationRecord)(nil)).Elem()
}

func (i *alertPolicyCreationRecordPtrType) ToAlertPolicyCreationRecordPtrOutput() AlertPolicyCreationRecordPtrOutput {
	return i.ToAlertPolicyCreationRecordPtrOutputWithContext(context.Background())
}

func (i *alertPolicyCreationRecordPtrType) ToAlertPolicyCreationRecordPtrOutputWithContext(ctx context.Context) AlertPolicyCreationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyCreationRecordPtrOutput)
}

type AlertPolicyCreationRecordOutput struct{ *pulumi.OutputState }

func (AlertPolicyCreationRecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyCreationRecord)(nil)).Elem()
}

func (o AlertPolicyCreationRecordOutput) ToAlertPolicyCreationRecordOutput() AlertPolicyCreationRecordOutput {
	return o
}

func (o AlertPolicyCreationRecordOutput) ToAlertPolicyCreationRecordOutputWithContext(ctx context.Context) AlertPolicyCreationRecordOutput {
	return o
}

func (o AlertPolicyCreationRecordOutput) ToAlertPolicyCreationRecordPtrOutput() AlertPolicyCreationRecordPtrOutput {
	return o.ToAlertPolicyCreationRecordPtrOutputWithContext(context.Background())
}

func (o AlertPolicyCreationRecordOutput) ToAlertPolicyCreationRecordPtrOutputWithContext(ctx context.Context) AlertPolicyCreationRecordPtrOutput {
	return o.ApplyT(func(v AlertPolicyCreationRecord) *AlertPolicyCreationRecord {
		return &v
	}).(AlertPolicyCreationRecordPtrOutput)
}
func (o AlertPolicyCreationRecordOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyCreationRecord) *string { return v.MutateTime }).(pulumi.StringPtrOutput)
}

func (o AlertPolicyCreationRecordOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyCreationRecord) *string { return v.MutatedBy }).(pulumi.StringPtrOutput)
}

type AlertPolicyCreationRecordPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyCreationRecordPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyCreationRecord)(nil)).Elem()
}

func (o AlertPolicyCreationRecordPtrOutput) ToAlertPolicyCreationRecordPtrOutput() AlertPolicyCreationRecordPtrOutput {
	return o
}

func (o AlertPolicyCreationRecordPtrOutput) ToAlertPolicyCreationRecordPtrOutputWithContext(ctx context.Context) AlertPolicyCreationRecordPtrOutput {
	return o
}

func (o AlertPolicyCreationRecordPtrOutput) Elem() AlertPolicyCreationRecordOutput {
	return o.ApplyT(func(v *AlertPolicyCreationRecord) AlertPolicyCreationRecord { return *v }).(AlertPolicyCreationRecordOutput)
}

func (o AlertPolicyCreationRecordPtrOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyCreationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutateTime
	}).(pulumi.StringPtrOutput)
}

func (o AlertPolicyCreationRecordPtrOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyCreationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutatedBy
	}).(pulumi.StringPtrOutput)
}

type AlertPolicyDocumentation struct {
	// The text of the documentation, interpreted according to mimeType.
	// The content may not exceed 8,192 Unicode characters and may not
	// exceed more than 10,240 bytes when encoded in UTF-8 format,
	// whichever is smaller.
	Content *string `pulumi:"content"`
	// The format of the content field. Presently, only the value
	// "text/markdown" is supported.
	MimeType *string `pulumi:"mimeType"`
}

// AlertPolicyDocumentationInput is an input type that accepts AlertPolicyDocumentationArgs and AlertPolicyDocumentationOutput values.
// You can construct a concrete instance of `AlertPolicyDocumentationInput` via:
//
// 		 AlertPolicyDocumentationArgs{...}
//
type AlertPolicyDocumentationInput interface {
	pulumi.Input

	ToAlertPolicyDocumentationOutput() AlertPolicyDocumentationOutput
	ToAlertPolicyDocumentationOutputWithContext(context.Context) AlertPolicyDocumentationOutput
}

type AlertPolicyDocumentationArgs struct {
	// The text of the documentation, interpreted according to mimeType.
	// The content may not exceed 8,192 Unicode characters and may not
	// exceed more than 10,240 bytes when encoded in UTF-8 format,
	// whichever is smaller.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The format of the content field. Presently, only the value
	// "text/markdown" is supported.
	MimeType pulumi.StringPtrInput `pulumi:"mimeType"`
}

func (AlertPolicyDocumentationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyDocumentation)(nil)).Elem()
}

func (i AlertPolicyDocumentationArgs) ToAlertPolicyDocumentationOutput() AlertPolicyDocumentationOutput {
	return i.ToAlertPolicyDocumentationOutputWithContext(context.Background())
}

func (i AlertPolicyDocumentationArgs) ToAlertPolicyDocumentationOutputWithContext(ctx context.Context) AlertPolicyDocumentationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyDocumentationOutput)
}

func (i AlertPolicyDocumentationArgs) ToAlertPolicyDocumentationPtrOutput() AlertPolicyDocumentationPtrOutput {
	return i.ToAlertPolicyDocumentationPtrOutputWithContext(context.Background())
}

func (i AlertPolicyDocumentationArgs) ToAlertPolicyDocumentationPtrOutputWithContext(ctx context.Context) AlertPolicyDocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyDocumentationOutput).ToAlertPolicyDocumentationPtrOutputWithContext(ctx)
}

// AlertPolicyDocumentationPtrInput is an input type that accepts AlertPolicyDocumentationArgs, AlertPolicyDocumentationPtr and AlertPolicyDocumentationPtrOutput values.
// You can construct a concrete instance of `AlertPolicyDocumentationPtrInput` via:
//
// 		 AlertPolicyDocumentationArgs{...}
//
//  or:
//
// 		 nil
//
type AlertPolicyDocumentationPtrInput interface {
	pulumi.Input

	ToAlertPolicyDocumentationPtrOutput() AlertPolicyDocumentationPtrOutput
	ToAlertPolicyDocumentationPtrOutputWithContext(context.Context) AlertPolicyDocumentationPtrOutput
}

type alertPolicyDocumentationPtrType AlertPolicyDocumentationArgs

func AlertPolicyDocumentationPtr(v *AlertPolicyDocumentationArgs) AlertPolicyDocumentationPtrInput {
	return (*alertPolicyDocumentationPtrType)(v)
}

func (*alertPolicyDocumentationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyDocumentation)(nil)).Elem()
}

func (i *alertPolicyDocumentationPtrType) ToAlertPolicyDocumentationPtrOutput() AlertPolicyDocumentationPtrOutput {
	return i.ToAlertPolicyDocumentationPtrOutputWithContext(context.Background())
}

func (i *alertPolicyDocumentationPtrType) ToAlertPolicyDocumentationPtrOutputWithContext(ctx context.Context) AlertPolicyDocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertPolicyDocumentationPtrOutput)
}

type AlertPolicyDocumentationOutput struct{ *pulumi.OutputState }

func (AlertPolicyDocumentationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertPolicyDocumentation)(nil)).Elem()
}

func (o AlertPolicyDocumentationOutput) ToAlertPolicyDocumentationOutput() AlertPolicyDocumentationOutput {
	return o
}

func (o AlertPolicyDocumentationOutput) ToAlertPolicyDocumentationOutputWithContext(ctx context.Context) AlertPolicyDocumentationOutput {
	return o
}

func (o AlertPolicyDocumentationOutput) ToAlertPolicyDocumentationPtrOutput() AlertPolicyDocumentationPtrOutput {
	return o.ToAlertPolicyDocumentationPtrOutputWithContext(context.Background())
}

func (o AlertPolicyDocumentationOutput) ToAlertPolicyDocumentationPtrOutputWithContext(ctx context.Context) AlertPolicyDocumentationPtrOutput {
	return o.ApplyT(func(v AlertPolicyDocumentation) *AlertPolicyDocumentation {
		return &v
	}).(AlertPolicyDocumentationPtrOutput)
}

// The text of the documentation, interpreted according to mimeType.
// The content may not exceed 8,192 Unicode characters and may not
// exceed more than 10,240 bytes when encoded in UTF-8 format,
// whichever is smaller.
func (o AlertPolicyDocumentationOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyDocumentation) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value
// "text/markdown" is supported.
func (o AlertPolicyDocumentationOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertPolicyDocumentation) *string { return v.MimeType }).(pulumi.StringPtrOutput)
}

type AlertPolicyDocumentationPtrOutput struct{ *pulumi.OutputState }

func (AlertPolicyDocumentationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertPolicyDocumentation)(nil)).Elem()
}

func (o AlertPolicyDocumentationPtrOutput) ToAlertPolicyDocumentationPtrOutput() AlertPolicyDocumentationPtrOutput {
	return o
}

func (o AlertPolicyDocumentationPtrOutput) ToAlertPolicyDocumentationPtrOutputWithContext(ctx context.Context) AlertPolicyDocumentationPtrOutput {
	return o
}

func (o AlertPolicyDocumentationPtrOutput) Elem() AlertPolicyDocumentationOutput {
	return o.ApplyT(func(v *AlertPolicyDocumentation) AlertPolicyDocumentation { return *v }).(AlertPolicyDocumentationOutput)
}

// The text of the documentation, interpreted according to mimeType.
// The content may not exceed 8,192 Unicode characters and may not
// exceed more than 10,240 bytes when encoded in UTF-8 format,
// whichever is smaller.
func (o AlertPolicyDocumentationPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyDocumentation) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value
// "text/markdown" is supported.
func (o AlertPolicyDocumentationPtrOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertPolicyDocumentation) *string {
		if v == nil {
			return nil
		}
		return v.MimeType
	}).(pulumi.StringPtrOutput)
}

type CustomServiceTelemetry struct {
	// The full name of the resource that defines this service.
	// Formatted as described in
	// https://cloud.google.com/apis/design/resource_names.
	ResourceName *string `pulumi:"resourceName"`
}

// CustomServiceTelemetryInput is an input type that accepts CustomServiceTelemetryArgs and CustomServiceTelemetryOutput values.
// You can construct a concrete instance of `CustomServiceTelemetryInput` via:
//
// 		 CustomServiceTelemetryArgs{...}
//
type CustomServiceTelemetryInput interface {
	pulumi.Input

	ToCustomServiceTelemetryOutput() CustomServiceTelemetryOutput
	ToCustomServiceTelemetryOutputWithContext(context.Context) CustomServiceTelemetryOutput
}

type CustomServiceTelemetryArgs struct {
	// The full name of the resource that defines this service.
	// Formatted as described in
	// https://cloud.google.com/apis/design/resource_names.
	ResourceName pulumi.StringPtrInput `pulumi:"resourceName"`
}

func (CustomServiceTelemetryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomServiceTelemetry)(nil)).Elem()
}

func (i CustomServiceTelemetryArgs) ToCustomServiceTelemetryOutput() CustomServiceTelemetryOutput {
	return i.ToCustomServiceTelemetryOutputWithContext(context.Background())
}

func (i CustomServiceTelemetryArgs) ToCustomServiceTelemetryOutputWithContext(ctx context.Context) CustomServiceTelemetryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomServiceTelemetryOutput)
}

func (i CustomServiceTelemetryArgs) ToCustomServiceTelemetryPtrOutput() CustomServiceTelemetryPtrOutput {
	return i.ToCustomServiceTelemetryPtrOutputWithContext(context.Background())
}

func (i CustomServiceTelemetryArgs) ToCustomServiceTelemetryPtrOutputWithContext(ctx context.Context) CustomServiceTelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomServiceTelemetryOutput).ToCustomServiceTelemetryPtrOutputWithContext(ctx)
}

// CustomServiceTelemetryPtrInput is an input type that accepts CustomServiceTelemetryArgs, CustomServiceTelemetryPtr and CustomServiceTelemetryPtrOutput values.
// You can construct a concrete instance of `CustomServiceTelemetryPtrInput` via:
//
// 		 CustomServiceTelemetryArgs{...}
//
//  or:
//
// 		 nil
//
type CustomServiceTelemetryPtrInput interface {
	pulumi.Input

	ToCustomServiceTelemetryPtrOutput() CustomServiceTelemetryPtrOutput
	ToCustomServiceTelemetryPtrOutputWithContext(context.Context) CustomServiceTelemetryPtrOutput
}

type customServiceTelemetryPtrType CustomServiceTelemetryArgs

func CustomServiceTelemetryPtr(v *CustomServiceTelemetryArgs) CustomServiceTelemetryPtrInput {
	return (*customServiceTelemetryPtrType)(v)
}

func (*customServiceTelemetryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomServiceTelemetry)(nil)).Elem()
}

func (i *customServiceTelemetryPtrType) ToCustomServiceTelemetryPtrOutput() CustomServiceTelemetryPtrOutput {
	return i.ToCustomServiceTelemetryPtrOutputWithContext(context.Background())
}

func (i *customServiceTelemetryPtrType) ToCustomServiceTelemetryPtrOutputWithContext(ctx context.Context) CustomServiceTelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomServiceTelemetryPtrOutput)
}

type CustomServiceTelemetryOutput struct{ *pulumi.OutputState }

func (CustomServiceTelemetryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomServiceTelemetry)(nil)).Elem()
}

func (o CustomServiceTelemetryOutput) ToCustomServiceTelemetryOutput() CustomServiceTelemetryOutput {
	return o
}

func (o CustomServiceTelemetryOutput) ToCustomServiceTelemetryOutputWithContext(ctx context.Context) CustomServiceTelemetryOutput {
	return o
}

func (o CustomServiceTelemetryOutput) ToCustomServiceTelemetryPtrOutput() CustomServiceTelemetryPtrOutput {
	return o.ToCustomServiceTelemetryPtrOutputWithContext(context.Background())
}

func (o CustomServiceTelemetryOutput) ToCustomServiceTelemetryPtrOutputWithContext(ctx context.Context) CustomServiceTelemetryPtrOutput {
	return o.ApplyT(func(v CustomServiceTelemetry) *CustomServiceTelemetry {
		return &v
	}).(CustomServiceTelemetryPtrOutput)
}

// The full name of the resource that defines this service.
// Formatted as described in
// https://cloud.google.com/apis/design/resource_names.
func (o CustomServiceTelemetryOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CustomServiceTelemetry) *string { return v.ResourceName }).(pulumi.StringPtrOutput)
}

type CustomServiceTelemetryPtrOutput struct{ *pulumi.OutputState }

func (CustomServiceTelemetryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomServiceTelemetry)(nil)).Elem()
}

func (o CustomServiceTelemetryPtrOutput) ToCustomServiceTelemetryPtrOutput() CustomServiceTelemetryPtrOutput {
	return o
}

func (o CustomServiceTelemetryPtrOutput) ToCustomServiceTelemetryPtrOutputWithContext(ctx context.Context) CustomServiceTelemetryPtrOutput {
	return o
}

func (o CustomServiceTelemetryPtrOutput) Elem() CustomServiceTelemetryOutput {
	return o.ApplyT(func(v *CustomServiceTelemetry) CustomServiceTelemetry { return *v }).(CustomServiceTelemetryOutput)
}

// The full name of the resource that defines this service.
// Formatted as described in
// https://cloud.google.com/apis/design/resource_names.
func (o CustomServiceTelemetryPtrOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomServiceTelemetry) *string {
		if v == nil {
			return nil
		}
		return v.ResourceName
	}).(pulumi.StringPtrOutput)
}

type NotificationChannelSensitiveLabels struct {
	// An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
	AuthToken *string `pulumi:"authToken"`
	// An password for a notification channel. Channel types that support this field include: webhookBasicauth  **Note**: This property is sensitive and will not be displayed in the plan.
	Password *string `pulumi:"password"`
	// An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
	ServiceKey *string `pulumi:"serviceKey"`
}

// NotificationChannelSensitiveLabelsInput is an input type that accepts NotificationChannelSensitiveLabelsArgs and NotificationChannelSensitiveLabelsOutput values.
// You can construct a concrete instance of `NotificationChannelSensitiveLabelsInput` via:
//
// 		 NotificationChannelSensitiveLabelsArgs{...}
//
type NotificationChannelSensitiveLabelsInput interface {
	pulumi.Input

	ToNotificationChannelSensitiveLabelsOutput() NotificationChannelSensitiveLabelsOutput
	ToNotificationChannelSensitiveLabelsOutputWithContext(context.Context) NotificationChannelSensitiveLabelsOutput
}

type NotificationChannelSensitiveLabelsArgs struct {
	// An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
	AuthToken pulumi.StringPtrInput `pulumi:"authToken"`
	// An password for a notification channel. Channel types that support this field include: webhookBasicauth  **Note**: This property is sensitive and will not be displayed in the plan.
	Password pulumi.StringPtrInput `pulumi:"password"`
	// An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
	ServiceKey pulumi.StringPtrInput `pulumi:"serviceKey"`
}

func (NotificationChannelSensitiveLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationChannelSensitiveLabels)(nil)).Elem()
}

func (i NotificationChannelSensitiveLabelsArgs) ToNotificationChannelSensitiveLabelsOutput() NotificationChannelSensitiveLabelsOutput {
	return i.ToNotificationChannelSensitiveLabelsOutputWithContext(context.Background())
}

func (i NotificationChannelSensitiveLabelsArgs) ToNotificationChannelSensitiveLabelsOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationChannelSensitiveLabelsOutput)
}

func (i NotificationChannelSensitiveLabelsArgs) ToNotificationChannelSensitiveLabelsPtrOutput() NotificationChannelSensitiveLabelsPtrOutput {
	return i.ToNotificationChannelSensitiveLabelsPtrOutputWithContext(context.Background())
}

func (i NotificationChannelSensitiveLabelsArgs) ToNotificationChannelSensitiveLabelsPtrOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationChannelSensitiveLabelsOutput).ToNotificationChannelSensitiveLabelsPtrOutputWithContext(ctx)
}

// NotificationChannelSensitiveLabelsPtrInput is an input type that accepts NotificationChannelSensitiveLabelsArgs, NotificationChannelSensitiveLabelsPtr and NotificationChannelSensitiveLabelsPtrOutput values.
// You can construct a concrete instance of `NotificationChannelSensitiveLabelsPtrInput` via:
//
// 		 NotificationChannelSensitiveLabelsArgs{...}
//
//  or:
//
// 		 nil
//
type NotificationChannelSensitiveLabelsPtrInput interface {
	pulumi.Input

	ToNotificationChannelSensitiveLabelsPtrOutput() NotificationChannelSensitiveLabelsPtrOutput
	ToNotificationChannelSensitiveLabelsPtrOutputWithContext(context.Context) NotificationChannelSensitiveLabelsPtrOutput
}

type notificationChannelSensitiveLabelsPtrType NotificationChannelSensitiveLabelsArgs

func NotificationChannelSensitiveLabelsPtr(v *NotificationChannelSensitiveLabelsArgs) NotificationChannelSensitiveLabelsPtrInput {
	return (*notificationChannelSensitiveLabelsPtrType)(v)
}

func (*notificationChannelSensitiveLabelsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationChannelSensitiveLabels)(nil)).Elem()
}

func (i *notificationChannelSensitiveLabelsPtrType) ToNotificationChannelSensitiveLabelsPtrOutput() NotificationChannelSensitiveLabelsPtrOutput {
	return i.ToNotificationChannelSensitiveLabelsPtrOutputWithContext(context.Background())
}

func (i *notificationChannelSensitiveLabelsPtrType) ToNotificationChannelSensitiveLabelsPtrOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationChannelSensitiveLabelsPtrOutput)
}

type NotificationChannelSensitiveLabelsOutput struct{ *pulumi.OutputState }

func (NotificationChannelSensitiveLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationChannelSensitiveLabels)(nil)).Elem()
}

func (o NotificationChannelSensitiveLabelsOutput) ToNotificationChannelSensitiveLabelsOutput() NotificationChannelSensitiveLabelsOutput {
	return o
}

func (o NotificationChannelSensitiveLabelsOutput) ToNotificationChannelSensitiveLabelsOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsOutput {
	return o
}

func (o NotificationChannelSensitiveLabelsOutput) ToNotificationChannelSensitiveLabelsPtrOutput() NotificationChannelSensitiveLabelsPtrOutput {
	return o.ToNotificationChannelSensitiveLabelsPtrOutputWithContext(context.Background())
}

func (o NotificationChannelSensitiveLabelsOutput) ToNotificationChannelSensitiveLabelsPtrOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsPtrOutput {
	return o.ApplyT(func(v NotificationChannelSensitiveLabels) *NotificationChannelSensitiveLabels {
		return &v
	}).(NotificationChannelSensitiveLabelsPtrOutput)
}

// An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsOutput) AuthToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationChannelSensitiveLabels) *string { return v.AuthToken }).(pulumi.StringPtrOutput)
}

// An password for a notification channel. Channel types that support this field include: webhookBasicauth  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationChannelSensitiveLabels) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsOutput) ServiceKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationChannelSensitiveLabels) *string { return v.ServiceKey }).(pulumi.StringPtrOutput)
}

type NotificationChannelSensitiveLabelsPtrOutput struct{ *pulumi.OutputState }

func (NotificationChannelSensitiveLabelsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationChannelSensitiveLabels)(nil)).Elem()
}

func (o NotificationChannelSensitiveLabelsPtrOutput) ToNotificationChannelSensitiveLabelsPtrOutput() NotificationChannelSensitiveLabelsPtrOutput {
	return o
}

func (o NotificationChannelSensitiveLabelsPtrOutput) ToNotificationChannelSensitiveLabelsPtrOutputWithContext(ctx context.Context) NotificationChannelSensitiveLabelsPtrOutput {
	return o
}

func (o NotificationChannelSensitiveLabelsPtrOutput) Elem() NotificationChannelSensitiveLabelsOutput {
	return o.ApplyT(func(v *NotificationChannelSensitiveLabels) NotificationChannelSensitiveLabels { return *v }).(NotificationChannelSensitiveLabelsOutput)
}

// An authorization token for a notification channel. Channel types that support this field include: slack  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsPtrOutput) AuthToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationChannelSensitiveLabels) *string {
		if v == nil {
			return nil
		}
		return v.AuthToken
	}).(pulumi.StringPtrOutput)
}

// An password for a notification channel. Channel types that support this field include: webhookBasicauth  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationChannelSensitiveLabels) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// An servicekey token for a notification channel. Channel types that support this field include: pagerduty  **Note**: This property is sensitive and will not be displayed in the plan.
func (o NotificationChannelSensitiveLabelsPtrOutput) ServiceKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationChannelSensitiveLabels) *string {
		if v == nil {
			return nil
		}
		return v.ServiceKey
	}).(pulumi.StringPtrOutput)
}

type SloBasicSli struct {
	// Parameters for a latency threshold SLI.  Structure is documented below.
	Latency SloBasicSliLatency `pulumi:"latency"`
	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	Locations []string `pulumi:"locations"`
	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	Methods []string `pulumi:"methods"`
	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	Versions []string `pulumi:"versions"`
}

// SloBasicSliInput is an input type that accepts SloBasicSliArgs and SloBasicSliOutput values.
// You can construct a concrete instance of `SloBasicSliInput` via:
//
// 		 SloBasicSliArgs{...}
//
type SloBasicSliInput interface {
	pulumi.Input

	ToSloBasicSliOutput() SloBasicSliOutput
	ToSloBasicSliOutputWithContext(context.Context) SloBasicSliOutput
}

type SloBasicSliArgs struct {
	// Parameters for a latency threshold SLI.  Structure is documented below.
	Latency SloBasicSliLatencyInput `pulumi:"latency"`
	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	Locations pulumi.StringArrayInput `pulumi:"locations"`
	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	Methods pulumi.StringArrayInput `pulumi:"methods"`
	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	Versions pulumi.StringArrayInput `pulumi:"versions"`
}

func (SloBasicSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloBasicSli)(nil)).Elem()
}

func (i SloBasicSliArgs) ToSloBasicSliOutput() SloBasicSliOutput {
	return i.ToSloBasicSliOutputWithContext(context.Background())
}

func (i SloBasicSliArgs) ToSloBasicSliOutputWithContext(ctx context.Context) SloBasicSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliOutput)
}

func (i SloBasicSliArgs) ToSloBasicSliPtrOutput() SloBasicSliPtrOutput {
	return i.ToSloBasicSliPtrOutputWithContext(context.Background())
}

func (i SloBasicSliArgs) ToSloBasicSliPtrOutputWithContext(ctx context.Context) SloBasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliOutput).ToSloBasicSliPtrOutputWithContext(ctx)
}

// SloBasicSliPtrInput is an input type that accepts SloBasicSliArgs, SloBasicSliPtr and SloBasicSliPtrOutput values.
// You can construct a concrete instance of `SloBasicSliPtrInput` via:
//
// 		 SloBasicSliArgs{...}
//
//  or:
//
// 		 nil
//
type SloBasicSliPtrInput interface {
	pulumi.Input

	ToSloBasicSliPtrOutput() SloBasicSliPtrOutput
	ToSloBasicSliPtrOutputWithContext(context.Context) SloBasicSliPtrOutput
}

type sloBasicSliPtrType SloBasicSliArgs

func SloBasicSliPtr(v *SloBasicSliArgs) SloBasicSliPtrInput {
	return (*sloBasicSliPtrType)(v)
}

func (*sloBasicSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloBasicSli)(nil)).Elem()
}

func (i *sloBasicSliPtrType) ToSloBasicSliPtrOutput() SloBasicSliPtrOutput {
	return i.ToSloBasicSliPtrOutputWithContext(context.Background())
}

func (i *sloBasicSliPtrType) ToSloBasicSliPtrOutputWithContext(ctx context.Context) SloBasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliPtrOutput)
}

type SloBasicSliOutput struct{ *pulumi.OutputState }

func (SloBasicSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloBasicSli)(nil)).Elem()
}

func (o SloBasicSliOutput) ToSloBasicSliOutput() SloBasicSliOutput {
	return o
}

func (o SloBasicSliOutput) ToSloBasicSliOutputWithContext(ctx context.Context) SloBasicSliOutput {
	return o
}

func (o SloBasicSliOutput) ToSloBasicSliPtrOutput() SloBasicSliPtrOutput {
	return o.ToSloBasicSliPtrOutputWithContext(context.Background())
}

func (o SloBasicSliOutput) ToSloBasicSliPtrOutputWithContext(ctx context.Context) SloBasicSliPtrOutput {
	return o.ApplyT(func(v SloBasicSli) *SloBasicSli {
		return &v
	}).(SloBasicSliPtrOutput)
}

// Parameters for a latency threshold SLI.  Structure is documented below.
func (o SloBasicSliOutput) Latency() SloBasicSliLatencyOutput {
	return o.ApplyT(func(v SloBasicSli) SloBasicSliLatency { return v.Latency }).(SloBasicSliLatencyOutput)
}

// An optional set of locations to which this SLI is relevant.
// Telemetry from other locations will not be used to calculate
// performance for this SLI. If omitted, this SLI applies to all
// locations in which the Service has activity. For service types
// that don't support breaking down by location, setting this
// field will result in an error.
func (o SloBasicSliOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SloBasicSli) []string { return v.Locations }).(pulumi.StringArrayOutput)
}

// An optional set of RPCs to which this SLI is relevant.
// Telemetry from other methods will not be used to calculate
// performance for this SLI. If omitted, this SLI applies to all
// the Service's methods. For service types that don't support
// breaking down by method, setting this field will result in an
// error.
func (o SloBasicSliOutput) Methods() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SloBasicSli) []string { return v.Methods }).(pulumi.StringArrayOutput)
}

// The set of API versions to which this SLI is relevant.
// Telemetry from other API versions will not be used to
// calculate performance for this SLI. If omitted,
// this SLI applies to all API versions. For service types
// that don't support breaking down by version, setting this
// field will result in an error.
func (o SloBasicSliOutput) Versions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SloBasicSli) []string { return v.Versions }).(pulumi.StringArrayOutput)
}

type SloBasicSliPtrOutput struct{ *pulumi.OutputState }

func (SloBasicSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloBasicSli)(nil)).Elem()
}

func (o SloBasicSliPtrOutput) ToSloBasicSliPtrOutput() SloBasicSliPtrOutput {
	return o
}

func (o SloBasicSliPtrOutput) ToSloBasicSliPtrOutputWithContext(ctx context.Context) SloBasicSliPtrOutput {
	return o
}

func (o SloBasicSliPtrOutput) Elem() SloBasicSliOutput {
	return o.ApplyT(func(v *SloBasicSli) SloBasicSli { return *v }).(SloBasicSliOutput)
}

// Parameters for a latency threshold SLI.  Structure is documented below.
func (o SloBasicSliPtrOutput) Latency() SloBasicSliLatencyPtrOutput {
	return o.ApplyT(func(v *SloBasicSli) *SloBasicSliLatency {
		if v == nil {
			return nil
		}
		return &v.Latency
	}).(SloBasicSliLatencyPtrOutput)
}

// An optional set of locations to which this SLI is relevant.
// Telemetry from other locations will not be used to calculate
// performance for this SLI. If omitted, this SLI applies to all
// locations in which the Service has activity. For service types
// that don't support breaking down by location, setting this
// field will result in an error.
func (o SloBasicSliPtrOutput) Locations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SloBasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(pulumi.StringArrayOutput)
}

// An optional set of RPCs to which this SLI is relevant.
// Telemetry from other methods will not be used to calculate
// performance for this SLI. If omitted, this SLI applies to all
// the Service's methods. For service types that don't support
// breaking down by method, setting this field will result in an
// error.
func (o SloBasicSliPtrOutput) Methods() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SloBasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Methods
	}).(pulumi.StringArrayOutput)
}

// The set of API versions to which this SLI is relevant.
// Telemetry from other API versions will not be used to
// calculate performance for this SLI. If omitted,
// this SLI applies to all API versions. For service types
// that don't support breaking down by version, setting this
// field will result in an error.
func (o SloBasicSliPtrOutput) Versions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SloBasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Versions
	}).(pulumi.StringArrayOutput)
}

type SloBasicSliLatency struct {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold string `pulumi:"threshold"`
}

// SloBasicSliLatencyInput is an input type that accepts SloBasicSliLatencyArgs and SloBasicSliLatencyOutput values.
// You can construct a concrete instance of `SloBasicSliLatencyInput` via:
//
// 		 SloBasicSliLatencyArgs{...}
//
type SloBasicSliLatencyInput interface {
	pulumi.Input

	ToSloBasicSliLatencyOutput() SloBasicSliLatencyOutput
	ToSloBasicSliLatencyOutputWithContext(context.Context) SloBasicSliLatencyOutput
}

type SloBasicSliLatencyArgs struct {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	Threshold pulumi.StringInput `pulumi:"threshold"`
}

func (SloBasicSliLatencyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloBasicSliLatency)(nil)).Elem()
}

func (i SloBasicSliLatencyArgs) ToSloBasicSliLatencyOutput() SloBasicSliLatencyOutput {
	return i.ToSloBasicSliLatencyOutputWithContext(context.Background())
}

func (i SloBasicSliLatencyArgs) ToSloBasicSliLatencyOutputWithContext(ctx context.Context) SloBasicSliLatencyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliLatencyOutput)
}

func (i SloBasicSliLatencyArgs) ToSloBasicSliLatencyPtrOutput() SloBasicSliLatencyPtrOutput {
	return i.ToSloBasicSliLatencyPtrOutputWithContext(context.Background())
}

func (i SloBasicSliLatencyArgs) ToSloBasicSliLatencyPtrOutputWithContext(ctx context.Context) SloBasicSliLatencyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliLatencyOutput).ToSloBasicSliLatencyPtrOutputWithContext(ctx)
}

// SloBasicSliLatencyPtrInput is an input type that accepts SloBasicSliLatencyArgs, SloBasicSliLatencyPtr and SloBasicSliLatencyPtrOutput values.
// You can construct a concrete instance of `SloBasicSliLatencyPtrInput` via:
//
// 		 SloBasicSliLatencyArgs{...}
//
//  or:
//
// 		 nil
//
type SloBasicSliLatencyPtrInput interface {
	pulumi.Input

	ToSloBasicSliLatencyPtrOutput() SloBasicSliLatencyPtrOutput
	ToSloBasicSliLatencyPtrOutputWithContext(context.Context) SloBasicSliLatencyPtrOutput
}

type sloBasicSliLatencyPtrType SloBasicSliLatencyArgs

func SloBasicSliLatencyPtr(v *SloBasicSliLatencyArgs) SloBasicSliLatencyPtrInput {
	return (*sloBasicSliLatencyPtrType)(v)
}

func (*sloBasicSliLatencyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloBasicSliLatency)(nil)).Elem()
}

func (i *sloBasicSliLatencyPtrType) ToSloBasicSliLatencyPtrOutput() SloBasicSliLatencyPtrOutput {
	return i.ToSloBasicSliLatencyPtrOutputWithContext(context.Background())
}

func (i *sloBasicSliLatencyPtrType) ToSloBasicSliLatencyPtrOutputWithContext(ctx context.Context) SloBasicSliLatencyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloBasicSliLatencyPtrOutput)
}

type SloBasicSliLatencyOutput struct{ *pulumi.OutputState }

func (SloBasicSliLatencyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloBasicSliLatency)(nil)).Elem()
}

func (o SloBasicSliLatencyOutput) ToSloBasicSliLatencyOutput() SloBasicSliLatencyOutput {
	return o
}

func (o SloBasicSliLatencyOutput) ToSloBasicSliLatencyOutputWithContext(ctx context.Context) SloBasicSliLatencyOutput {
	return o
}

func (o SloBasicSliLatencyOutput) ToSloBasicSliLatencyPtrOutput() SloBasicSliLatencyPtrOutput {
	return o.ToSloBasicSliLatencyPtrOutputWithContext(context.Background())
}

func (o SloBasicSliLatencyOutput) ToSloBasicSliLatencyPtrOutputWithContext(ctx context.Context) SloBasicSliLatencyPtrOutput {
	return o.ApplyT(func(v SloBasicSliLatency) *SloBasicSliLatency {
		return &v
	}).(SloBasicSliLatencyPtrOutput)
}

// A duration string, e.g. 10s.
// Good service is defined to be the count of requests made to
// this service that return in no more than threshold.
func (o SloBasicSliLatencyOutput) Threshold() pulumi.StringOutput {
	return o.ApplyT(func(v SloBasicSliLatency) string { return v.Threshold }).(pulumi.StringOutput)
}

type SloBasicSliLatencyPtrOutput struct{ *pulumi.OutputState }

func (SloBasicSliLatencyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloBasicSliLatency)(nil)).Elem()
}

func (o SloBasicSliLatencyPtrOutput) ToSloBasicSliLatencyPtrOutput() SloBasicSliLatencyPtrOutput {
	return o
}

func (o SloBasicSliLatencyPtrOutput) ToSloBasicSliLatencyPtrOutputWithContext(ctx context.Context) SloBasicSliLatencyPtrOutput {
	return o
}

func (o SloBasicSliLatencyPtrOutput) Elem() SloBasicSliLatencyOutput {
	return o.ApplyT(func(v *SloBasicSliLatency) SloBasicSliLatency { return *v }).(SloBasicSliLatencyOutput)
}

// A duration string, e.g. 10s.
// Good service is defined to be the count of requests made to
// this service that return in no more than threshold.
func (o SloBasicSliLatencyPtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloBasicSliLatency) *string {
		if v == nil {
			return nil
		}
		return &v.Threshold
	}).(pulumi.StringPtrOutput)
}

type SloRequestBasedSli struct {
	// Used when goodService is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The totalService is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
	DistributionCut *SloRequestBasedSliDistributionCut `pulumi:"distributionCut"`
	// A means to compute a ratio of `goodService` to `totalService`.
	// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship goodService + badService = totalService
	// will be assumed.
	// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
	GoodTotalRatio *SloRequestBasedSliGoodTotalRatio `pulumi:"goodTotalRatio"`
}

// SloRequestBasedSliInput is an input type that accepts SloRequestBasedSliArgs and SloRequestBasedSliOutput values.
// You can construct a concrete instance of `SloRequestBasedSliInput` via:
//
// 		 SloRequestBasedSliArgs{...}
//
type SloRequestBasedSliInput interface {
	pulumi.Input

	ToSloRequestBasedSliOutput() SloRequestBasedSliOutput
	ToSloRequestBasedSliOutputWithContext(context.Context) SloRequestBasedSliOutput
}

type SloRequestBasedSliArgs struct {
	// Used when goodService is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The totalService is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
	DistributionCut SloRequestBasedSliDistributionCutPtrInput `pulumi:"distributionCut"`
	// A means to compute a ratio of `goodService` to `totalService`.
	// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship goodService + badService = totalService
	// will be assumed.
	// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
	GoodTotalRatio SloRequestBasedSliGoodTotalRatioPtrInput `pulumi:"goodTotalRatio"`
}

func (SloRequestBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSli)(nil)).Elem()
}

func (i SloRequestBasedSliArgs) ToSloRequestBasedSliOutput() SloRequestBasedSliOutput {
	return i.ToSloRequestBasedSliOutputWithContext(context.Background())
}

func (i SloRequestBasedSliArgs) ToSloRequestBasedSliOutputWithContext(ctx context.Context) SloRequestBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliOutput)
}

func (i SloRequestBasedSliArgs) ToSloRequestBasedSliPtrOutput() SloRequestBasedSliPtrOutput {
	return i.ToSloRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i SloRequestBasedSliArgs) ToSloRequestBasedSliPtrOutputWithContext(ctx context.Context) SloRequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliOutput).ToSloRequestBasedSliPtrOutputWithContext(ctx)
}

// SloRequestBasedSliPtrInput is an input type that accepts SloRequestBasedSliArgs, SloRequestBasedSliPtr and SloRequestBasedSliPtrOutput values.
// You can construct a concrete instance of `SloRequestBasedSliPtrInput` via:
//
// 		 SloRequestBasedSliArgs{...}
//
//  or:
//
// 		 nil
//
type SloRequestBasedSliPtrInput interface {
	pulumi.Input

	ToSloRequestBasedSliPtrOutput() SloRequestBasedSliPtrOutput
	ToSloRequestBasedSliPtrOutputWithContext(context.Context) SloRequestBasedSliPtrOutput
}

type sloRequestBasedSliPtrType SloRequestBasedSliArgs

func SloRequestBasedSliPtr(v *SloRequestBasedSliArgs) SloRequestBasedSliPtrInput {
	return (*sloRequestBasedSliPtrType)(v)
}

func (*sloRequestBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSli)(nil)).Elem()
}

func (i *sloRequestBasedSliPtrType) ToSloRequestBasedSliPtrOutput() SloRequestBasedSliPtrOutput {
	return i.ToSloRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i *sloRequestBasedSliPtrType) ToSloRequestBasedSliPtrOutputWithContext(ctx context.Context) SloRequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliPtrOutput)
}

type SloRequestBasedSliOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSli)(nil)).Elem()
}

func (o SloRequestBasedSliOutput) ToSloRequestBasedSliOutput() SloRequestBasedSliOutput {
	return o
}

func (o SloRequestBasedSliOutput) ToSloRequestBasedSliOutputWithContext(ctx context.Context) SloRequestBasedSliOutput {
	return o
}

func (o SloRequestBasedSliOutput) ToSloRequestBasedSliPtrOutput() SloRequestBasedSliPtrOutput {
	return o.ToSloRequestBasedSliPtrOutputWithContext(context.Background())
}

func (o SloRequestBasedSliOutput) ToSloRequestBasedSliPtrOutputWithContext(ctx context.Context) SloRequestBasedSliPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSli) *SloRequestBasedSli {
		return &v
	}).(SloRequestBasedSliPtrOutput)
}

// Used when goodService is defined by a count of values aggregated in a
// Distribution that fall into a good range. The totalService is the
// total count of all values aggregated in the Distribution.
// Defines a distribution TimeSeries filter and thresholds used for
// measuring good service and total service.
// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
func (o SloRequestBasedSliOutput) DistributionCut() SloRequestBasedSliDistributionCutPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSli) *SloRequestBasedSliDistributionCut { return v.DistributionCut }).(SloRequestBasedSliDistributionCutPtrOutput)
}

// A means to compute a ratio of `goodService` to `totalService`.
// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
// Must specify exactly two of good, bad, and total service filters.
// The relationship goodService + badService = totalService
// will be assumed.
// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
func (o SloRequestBasedSliOutput) GoodTotalRatio() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSli) *SloRequestBasedSliGoodTotalRatio { return v.GoodTotalRatio }).(SloRequestBasedSliGoodTotalRatioPtrOutput)
}

type SloRequestBasedSliPtrOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSli)(nil)).Elem()
}

func (o SloRequestBasedSliPtrOutput) ToSloRequestBasedSliPtrOutput() SloRequestBasedSliPtrOutput {
	return o
}

func (o SloRequestBasedSliPtrOutput) ToSloRequestBasedSliPtrOutputWithContext(ctx context.Context) SloRequestBasedSliPtrOutput {
	return o
}

func (o SloRequestBasedSliPtrOutput) Elem() SloRequestBasedSliOutput {
	return o.ApplyT(func(v *SloRequestBasedSli) SloRequestBasedSli { return *v }).(SloRequestBasedSliOutput)
}

// Used when goodService is defined by a count of values aggregated in a
// Distribution that fall into a good range. The totalService is the
// total count of all values aggregated in the Distribution.
// Defines a distribution TimeSeries filter and thresholds used for
// measuring good service and total service.
// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
func (o SloRequestBasedSliPtrOutput) DistributionCut() SloRequestBasedSliDistributionCutPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSli) *SloRequestBasedSliDistributionCut {
		if v == nil {
			return nil
		}
		return v.DistributionCut
	}).(SloRequestBasedSliDistributionCutPtrOutput)
}

// A means to compute a ratio of `goodService` to `totalService`.
// Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
// Must specify exactly two of good, bad, and total service filters.
// The relationship goodService + badService = totalService
// will be assumed.
// Exactly one of `distributionCut` or `goodTotalRatio` can be set.  Structure is documented below.
func (o SloRequestBasedSliPtrOutput) GoodTotalRatio() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSli) *SloRequestBasedSliGoodTotalRatio {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatio
	}).(SloRequestBasedSliGoodTotalRatioPtrOutput)
}

type SloRequestBasedSliDistributionCut struct {
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter string `pulumi:"distributionFilter"`
	// Range of numerical values. The computed goodService
	// will be the count of values x in the Distribution such
	// that range.min <= x < range.max. inclusive of min and
	// exclusive of max. Open ranges can be defined by setting
	// just one of min or max.  Structure is documented below.
	Range SloRequestBasedSliDistributionCutRange `pulumi:"range"`
}

// SloRequestBasedSliDistributionCutInput is an input type that accepts SloRequestBasedSliDistributionCutArgs and SloRequestBasedSliDistributionCutOutput values.
// You can construct a concrete instance of `SloRequestBasedSliDistributionCutInput` via:
//
// 		 SloRequestBasedSliDistributionCutArgs{...}
//
type SloRequestBasedSliDistributionCutInput interface {
	pulumi.Input

	ToSloRequestBasedSliDistributionCutOutput() SloRequestBasedSliDistributionCutOutput
	ToSloRequestBasedSliDistributionCutOutputWithContext(context.Context) SloRequestBasedSliDistributionCutOutput
}

type SloRequestBasedSliDistributionCutArgs struct {
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter pulumi.StringInput `pulumi:"distributionFilter"`
	// Range of numerical values. The computed goodService
	// will be the count of values x in the Distribution such
	// that range.min <= x < range.max. inclusive of min and
	// exclusive of max. Open ranges can be defined by setting
	// just one of min or max.  Structure is documented below.
	Range SloRequestBasedSliDistributionCutRangeInput `pulumi:"range"`
}

func (SloRequestBasedSliDistributionCutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliDistributionCut)(nil)).Elem()
}

func (i SloRequestBasedSliDistributionCutArgs) ToSloRequestBasedSliDistributionCutOutput() SloRequestBasedSliDistributionCutOutput {
	return i.ToSloRequestBasedSliDistributionCutOutputWithContext(context.Background())
}

func (i SloRequestBasedSliDistributionCutArgs) ToSloRequestBasedSliDistributionCutOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutOutput)
}

func (i SloRequestBasedSliDistributionCutArgs) ToSloRequestBasedSliDistributionCutPtrOutput() SloRequestBasedSliDistributionCutPtrOutput {
	return i.ToSloRequestBasedSliDistributionCutPtrOutputWithContext(context.Background())
}

func (i SloRequestBasedSliDistributionCutArgs) ToSloRequestBasedSliDistributionCutPtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutOutput).ToSloRequestBasedSliDistributionCutPtrOutputWithContext(ctx)
}

// SloRequestBasedSliDistributionCutPtrInput is an input type that accepts SloRequestBasedSliDistributionCutArgs, SloRequestBasedSliDistributionCutPtr and SloRequestBasedSliDistributionCutPtrOutput values.
// You can construct a concrete instance of `SloRequestBasedSliDistributionCutPtrInput` via:
//
// 		 SloRequestBasedSliDistributionCutArgs{...}
//
//  or:
//
// 		 nil
//
type SloRequestBasedSliDistributionCutPtrInput interface {
	pulumi.Input

	ToSloRequestBasedSliDistributionCutPtrOutput() SloRequestBasedSliDistributionCutPtrOutput
	ToSloRequestBasedSliDistributionCutPtrOutputWithContext(context.Context) SloRequestBasedSliDistributionCutPtrOutput
}

type sloRequestBasedSliDistributionCutPtrType SloRequestBasedSliDistributionCutArgs

func SloRequestBasedSliDistributionCutPtr(v *SloRequestBasedSliDistributionCutArgs) SloRequestBasedSliDistributionCutPtrInput {
	return (*sloRequestBasedSliDistributionCutPtrType)(v)
}

func (*sloRequestBasedSliDistributionCutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliDistributionCut)(nil)).Elem()
}

func (i *sloRequestBasedSliDistributionCutPtrType) ToSloRequestBasedSliDistributionCutPtrOutput() SloRequestBasedSliDistributionCutPtrOutput {
	return i.ToSloRequestBasedSliDistributionCutPtrOutputWithContext(context.Background())
}

func (i *sloRequestBasedSliDistributionCutPtrType) ToSloRequestBasedSliDistributionCutPtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutPtrOutput)
}

type SloRequestBasedSliDistributionCutOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliDistributionCutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliDistributionCut)(nil)).Elem()
}

func (o SloRequestBasedSliDistributionCutOutput) ToSloRequestBasedSliDistributionCutOutput() SloRequestBasedSliDistributionCutOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutOutput) ToSloRequestBasedSliDistributionCutOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutOutput) ToSloRequestBasedSliDistributionCutPtrOutput() SloRequestBasedSliDistributionCutPtrOutput {
	return o.ToSloRequestBasedSliDistributionCutPtrOutputWithContext(context.Background())
}

func (o SloRequestBasedSliDistributionCutOutput) ToSloRequestBasedSliDistributionCutPtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCut) *SloRequestBasedSliDistributionCut {
		return &v
	}).(SloRequestBasedSliDistributionCutPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// aggregating values to quantify the good service provided.
// Must have ValueType = DISTRIBUTION and
// MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o SloRequestBasedSliDistributionCutOutput) DistributionFilter() pulumi.StringOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCut) string { return v.DistributionFilter }).(pulumi.StringOutput)
}

// Range of numerical values. The computed goodService
// will be the count of values x in the Distribution such
// that range.min <= x < range.max. inclusive of min and
// exclusive of max. Open ranges can be defined by setting
// just one of min or max.  Structure is documented below.
func (o SloRequestBasedSliDistributionCutOutput) Range() SloRequestBasedSliDistributionCutRangeOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCut) SloRequestBasedSliDistributionCutRange { return v.Range }).(SloRequestBasedSliDistributionCutRangeOutput)
}

type SloRequestBasedSliDistributionCutPtrOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliDistributionCutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliDistributionCut)(nil)).Elem()
}

func (o SloRequestBasedSliDistributionCutPtrOutput) ToSloRequestBasedSliDistributionCutPtrOutput() SloRequestBasedSliDistributionCutPtrOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutPtrOutput) ToSloRequestBasedSliDistributionCutPtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutPtrOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutPtrOutput) Elem() SloRequestBasedSliDistributionCutOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCut) SloRequestBasedSliDistributionCut { return *v }).(SloRequestBasedSliDistributionCutOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// aggregating values to quantify the good service provided.
// Must have ValueType = DISTRIBUTION and
// MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o SloRequestBasedSliDistributionCutPtrOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCut) *string {
		if v == nil {
			return nil
		}
		return &v.DistributionFilter
	}).(pulumi.StringPtrOutput)
}

// Range of numerical values. The computed goodService
// will be the count of values x in the Distribution such
// that range.min <= x < range.max. inclusive of min and
// exclusive of max. Open ranges can be defined by setting
// just one of min or max.  Structure is documented below.
func (o SloRequestBasedSliDistributionCutPtrOutput) Range() SloRequestBasedSliDistributionCutRangePtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCut) *SloRequestBasedSliDistributionCutRange {
		if v == nil {
			return nil
		}
		return &v.Range
	}).(SloRequestBasedSliDistributionCutRangePtrOutput)
}

type SloRequestBasedSliDistributionCutRange struct {
	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	Max *int `pulumi:"max"`
	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	Min *int `pulumi:"min"`
}

// SloRequestBasedSliDistributionCutRangeInput is an input type that accepts SloRequestBasedSliDistributionCutRangeArgs and SloRequestBasedSliDistributionCutRangeOutput values.
// You can construct a concrete instance of `SloRequestBasedSliDistributionCutRangeInput` via:
//
// 		 SloRequestBasedSliDistributionCutRangeArgs{...}
//
type SloRequestBasedSliDistributionCutRangeInput interface {
	pulumi.Input

	ToSloRequestBasedSliDistributionCutRangeOutput() SloRequestBasedSliDistributionCutRangeOutput
	ToSloRequestBasedSliDistributionCutRangeOutputWithContext(context.Context) SloRequestBasedSliDistributionCutRangeOutput
}

type SloRequestBasedSliDistributionCutRangeArgs struct {
	// max value for the range (inclusive). If not given,
	// will be set to "infinity", defining an open range
	// ">= range.min"
	Max pulumi.IntPtrInput `pulumi:"max"`
	// Min value for the range (inclusive). If not given,
	// will be set to "-infinity", defining an open range
	// "< range.max"
	Min pulumi.IntPtrInput `pulumi:"min"`
}

func (SloRequestBasedSliDistributionCutRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliDistributionCutRange)(nil)).Elem()
}

func (i SloRequestBasedSliDistributionCutRangeArgs) ToSloRequestBasedSliDistributionCutRangeOutput() SloRequestBasedSliDistributionCutRangeOutput {
	return i.ToSloRequestBasedSliDistributionCutRangeOutputWithContext(context.Background())
}

func (i SloRequestBasedSliDistributionCutRangeArgs) ToSloRequestBasedSliDistributionCutRangeOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutRangeOutput)
}

func (i SloRequestBasedSliDistributionCutRangeArgs) ToSloRequestBasedSliDistributionCutRangePtrOutput() SloRequestBasedSliDistributionCutRangePtrOutput {
	return i.ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(context.Background())
}

func (i SloRequestBasedSliDistributionCutRangeArgs) ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutRangeOutput).ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(ctx)
}

// SloRequestBasedSliDistributionCutRangePtrInput is an input type that accepts SloRequestBasedSliDistributionCutRangeArgs, SloRequestBasedSliDistributionCutRangePtr and SloRequestBasedSliDistributionCutRangePtrOutput values.
// You can construct a concrete instance of `SloRequestBasedSliDistributionCutRangePtrInput` via:
//
// 		 SloRequestBasedSliDistributionCutRangeArgs{...}
//
//  or:
//
// 		 nil
//
type SloRequestBasedSliDistributionCutRangePtrInput interface {
	pulumi.Input

	ToSloRequestBasedSliDistributionCutRangePtrOutput() SloRequestBasedSliDistributionCutRangePtrOutput
	ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(context.Context) SloRequestBasedSliDistributionCutRangePtrOutput
}

type sloRequestBasedSliDistributionCutRangePtrType SloRequestBasedSliDistributionCutRangeArgs

func SloRequestBasedSliDistributionCutRangePtr(v *SloRequestBasedSliDistributionCutRangeArgs) SloRequestBasedSliDistributionCutRangePtrInput {
	return (*sloRequestBasedSliDistributionCutRangePtrType)(v)
}

func (*sloRequestBasedSliDistributionCutRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliDistributionCutRange)(nil)).Elem()
}

func (i *sloRequestBasedSliDistributionCutRangePtrType) ToSloRequestBasedSliDistributionCutRangePtrOutput() SloRequestBasedSliDistributionCutRangePtrOutput {
	return i.ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(context.Background())
}

func (i *sloRequestBasedSliDistributionCutRangePtrType) ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliDistributionCutRangePtrOutput)
}

type SloRequestBasedSliDistributionCutRangeOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliDistributionCutRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliDistributionCutRange)(nil)).Elem()
}

func (o SloRequestBasedSliDistributionCutRangeOutput) ToSloRequestBasedSliDistributionCutRangeOutput() SloRequestBasedSliDistributionCutRangeOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutRangeOutput) ToSloRequestBasedSliDistributionCutRangeOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangeOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutRangeOutput) ToSloRequestBasedSliDistributionCutRangePtrOutput() SloRequestBasedSliDistributionCutRangePtrOutput {
	return o.ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(context.Background())
}

func (o SloRequestBasedSliDistributionCutRangeOutput) ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangePtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCutRange) *SloRequestBasedSliDistributionCutRange {
		return &v
	}).(SloRequestBasedSliDistributionCutRangePtrOutput)
}

// max value for the range (inclusive). If not given,
// will be set to "infinity", defining an open range
// ">= range.min"
func (o SloRequestBasedSliDistributionCutRangeOutput) Max() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCutRange) *int { return v.Max }).(pulumi.IntPtrOutput)
}

// Min value for the range (inclusive). If not given,
// will be set to "-infinity", defining an open range
// "< range.max"
func (o SloRequestBasedSliDistributionCutRangeOutput) Min() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliDistributionCutRange) *int { return v.Min }).(pulumi.IntPtrOutput)
}

type SloRequestBasedSliDistributionCutRangePtrOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliDistributionCutRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliDistributionCutRange)(nil)).Elem()
}

func (o SloRequestBasedSliDistributionCutRangePtrOutput) ToSloRequestBasedSliDistributionCutRangePtrOutput() SloRequestBasedSliDistributionCutRangePtrOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutRangePtrOutput) ToSloRequestBasedSliDistributionCutRangePtrOutputWithContext(ctx context.Context) SloRequestBasedSliDistributionCutRangePtrOutput {
	return o
}

func (o SloRequestBasedSliDistributionCutRangePtrOutput) Elem() SloRequestBasedSliDistributionCutRangeOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCutRange) SloRequestBasedSliDistributionCutRange { return *v }).(SloRequestBasedSliDistributionCutRangeOutput)
}

// max value for the range (inclusive). If not given,
// will be set to "infinity", defining an open range
// ">= range.min"
func (o SloRequestBasedSliDistributionCutRangePtrOutput) Max() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCutRange) *int {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.IntPtrOutput)
}

// Min value for the range (inclusive). If not given,
// will be set to "-infinity", defining an open range
// "< range.max"
func (o SloRequestBasedSliDistributionCutRangePtrOutput) Min() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliDistributionCutRange) *int {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.IntPtrOutput)
}

type SloRequestBasedSliGoodTotalRatio struct {
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	BadServiceFilter *string `pulumi:"badServiceFilter"`
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	GoodServiceFilter *string `pulumi:"goodServiceFilter"`
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	TotalServiceFilter *string `pulumi:"totalServiceFilter"`
}

// SloRequestBasedSliGoodTotalRatioInput is an input type that accepts SloRequestBasedSliGoodTotalRatioArgs and SloRequestBasedSliGoodTotalRatioOutput values.
// You can construct a concrete instance of `SloRequestBasedSliGoodTotalRatioInput` via:
//
// 		 SloRequestBasedSliGoodTotalRatioArgs{...}
//
type SloRequestBasedSliGoodTotalRatioInput interface {
	pulumi.Input

	ToSloRequestBasedSliGoodTotalRatioOutput() SloRequestBasedSliGoodTotalRatioOutput
	ToSloRequestBasedSliGoodTotalRatioOutputWithContext(context.Context) SloRequestBasedSliGoodTotalRatioOutput
}

type SloRequestBasedSliGoodTotalRatioArgs struct {
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	BadServiceFilter pulumi.StringPtrInput `pulumi:"badServiceFilter"`
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	GoodServiceFilter pulumi.StringPtrInput `pulumi:"goodServiceFilter"`
	// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
	// must be set (good + bad = total is assumed).
	TotalServiceFilter pulumi.StringPtrInput `pulumi:"totalServiceFilter"`
}

func (SloRequestBasedSliGoodTotalRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliGoodTotalRatio)(nil)).Elem()
}

func (i SloRequestBasedSliGoodTotalRatioArgs) ToSloRequestBasedSliGoodTotalRatioOutput() SloRequestBasedSliGoodTotalRatioOutput {
	return i.ToSloRequestBasedSliGoodTotalRatioOutputWithContext(context.Background())
}

func (i SloRequestBasedSliGoodTotalRatioArgs) ToSloRequestBasedSliGoodTotalRatioOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliGoodTotalRatioOutput)
}

func (i SloRequestBasedSliGoodTotalRatioArgs) ToSloRequestBasedSliGoodTotalRatioPtrOutput() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return i.ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(context.Background())
}

func (i SloRequestBasedSliGoodTotalRatioArgs) ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliGoodTotalRatioOutput).ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(ctx)
}

// SloRequestBasedSliGoodTotalRatioPtrInput is an input type that accepts SloRequestBasedSliGoodTotalRatioArgs, SloRequestBasedSliGoodTotalRatioPtr and SloRequestBasedSliGoodTotalRatioPtrOutput values.
// You can construct a concrete instance of `SloRequestBasedSliGoodTotalRatioPtrInput` via:
//
// 		 SloRequestBasedSliGoodTotalRatioArgs{...}
//
//  or:
//
// 		 nil
//
type SloRequestBasedSliGoodTotalRatioPtrInput interface {
	pulumi.Input

	ToSloRequestBasedSliGoodTotalRatioPtrOutput() SloRequestBasedSliGoodTotalRatioPtrOutput
	ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(context.Context) SloRequestBasedSliGoodTotalRatioPtrOutput
}

type sloRequestBasedSliGoodTotalRatioPtrType SloRequestBasedSliGoodTotalRatioArgs

func SloRequestBasedSliGoodTotalRatioPtr(v *SloRequestBasedSliGoodTotalRatioArgs) SloRequestBasedSliGoodTotalRatioPtrInput {
	return (*sloRequestBasedSliGoodTotalRatioPtrType)(v)
}

func (*sloRequestBasedSliGoodTotalRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliGoodTotalRatio)(nil)).Elem()
}

func (i *sloRequestBasedSliGoodTotalRatioPtrType) ToSloRequestBasedSliGoodTotalRatioPtrOutput() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return i.ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(context.Background())
}

func (i *sloRequestBasedSliGoodTotalRatioPtrType) ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloRequestBasedSliGoodTotalRatioPtrOutput)
}

type SloRequestBasedSliGoodTotalRatioOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliGoodTotalRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SloRequestBasedSliGoodTotalRatio)(nil)).Elem()
}

func (o SloRequestBasedSliGoodTotalRatioOutput) ToSloRequestBasedSliGoodTotalRatioOutput() SloRequestBasedSliGoodTotalRatioOutput {
	return o
}

func (o SloRequestBasedSliGoodTotalRatioOutput) ToSloRequestBasedSliGoodTotalRatioOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioOutput {
	return o
}

func (o SloRequestBasedSliGoodTotalRatioOutput) ToSloRequestBasedSliGoodTotalRatioPtrOutput() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o.ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(context.Background())
}

func (o SloRequestBasedSliGoodTotalRatioOutput) ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliGoodTotalRatio) *SloRequestBasedSliGoodTotalRatio {
		return &v
	}).(SloRequestBasedSliGoodTotalRatioPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying bad service provided, either demanded service that
// was not provided or demanded service that was of inadequate
// quality.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliGoodTotalRatio) *string { return v.BadServiceFilter }).(pulumi.StringPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying good service provided.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliGoodTotalRatio) *string { return v.GoodServiceFilter }).(pulumi.StringPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying total demanded service.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SloRequestBasedSliGoodTotalRatio) *string { return v.TotalServiceFilter }).(pulumi.StringPtrOutput)
}

type SloRequestBasedSliGoodTotalRatioPtrOutput struct{ *pulumi.OutputState }

func (SloRequestBasedSliGoodTotalRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloRequestBasedSliGoodTotalRatio)(nil)).Elem()
}

func (o SloRequestBasedSliGoodTotalRatioPtrOutput) ToSloRequestBasedSliGoodTotalRatioPtrOutput() SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o
}

func (o SloRequestBasedSliGoodTotalRatioPtrOutput) ToSloRequestBasedSliGoodTotalRatioPtrOutputWithContext(ctx context.Context) SloRequestBasedSliGoodTotalRatioPtrOutput {
	return o
}

func (o SloRequestBasedSliGoodTotalRatioPtrOutput) Elem() SloRequestBasedSliGoodTotalRatioOutput {
	return o.ApplyT(func(v *SloRequestBasedSliGoodTotalRatio) SloRequestBasedSliGoodTotalRatio { return *v }).(SloRequestBasedSliGoodTotalRatioOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying bad service provided, either demanded service that
// was not provided or demanded service that was of inadequate
// quality.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioPtrOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliGoodTotalRatio) *string {
		if v == nil {
			return nil
		}
		return v.BadServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying good service provided.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioPtrOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliGoodTotalRatio) *string {
		if v == nil {
			return nil
		}
		return v.GoodServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
// quantifying total demanded service.
// Must have ValueType = DOUBLE or ValueType = INT64 and
// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
// Exactly two of `goodServiceFilter`,`badServiceFilter`,`totalServiceFilter`
// must be set (good + bad = total is assumed).
func (o SloRequestBasedSliGoodTotalRatioPtrOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloRequestBasedSliGoodTotalRatio) *string {
		if v == nil {
			return nil
		}
		return v.TotalServiceFilter
	}).(pulumi.StringPtrOutput)
}

type UptimeCheckConfigContentMatcher struct {
	// String or regex content to match (max 1024 bytes)
	Content string `pulumi:"content"`
}

// UptimeCheckConfigContentMatcherInput is an input type that accepts UptimeCheckConfigContentMatcherArgs and UptimeCheckConfigContentMatcherOutput values.
// You can construct a concrete instance of `UptimeCheckConfigContentMatcherInput` via:
//
// 		 UptimeCheckConfigContentMatcherArgs{...}
//
type UptimeCheckConfigContentMatcherInput interface {
	pulumi.Input

	ToUptimeCheckConfigContentMatcherOutput() UptimeCheckConfigContentMatcherOutput
	ToUptimeCheckConfigContentMatcherOutputWithContext(context.Context) UptimeCheckConfigContentMatcherOutput
}

type UptimeCheckConfigContentMatcherArgs struct {
	// String or regex content to match (max 1024 bytes)
	Content pulumi.StringInput `pulumi:"content"`
}

func (UptimeCheckConfigContentMatcherArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigContentMatcher)(nil)).Elem()
}

func (i UptimeCheckConfigContentMatcherArgs) ToUptimeCheckConfigContentMatcherOutput() UptimeCheckConfigContentMatcherOutput {
	return i.ToUptimeCheckConfigContentMatcherOutputWithContext(context.Background())
}

func (i UptimeCheckConfigContentMatcherArgs) ToUptimeCheckConfigContentMatcherOutputWithContext(ctx context.Context) UptimeCheckConfigContentMatcherOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigContentMatcherOutput)
}

// UptimeCheckConfigContentMatcherArrayInput is an input type that accepts UptimeCheckConfigContentMatcherArray and UptimeCheckConfigContentMatcherArrayOutput values.
// You can construct a concrete instance of `UptimeCheckConfigContentMatcherArrayInput` via:
//
// 		 UptimeCheckConfigContentMatcherArray{ UptimeCheckConfigContentMatcherArgs{...} }
//
type UptimeCheckConfigContentMatcherArrayInput interface {
	pulumi.Input

	ToUptimeCheckConfigContentMatcherArrayOutput() UptimeCheckConfigContentMatcherArrayOutput
	ToUptimeCheckConfigContentMatcherArrayOutputWithContext(context.Context) UptimeCheckConfigContentMatcherArrayOutput
}

type UptimeCheckConfigContentMatcherArray []UptimeCheckConfigContentMatcherInput

func (UptimeCheckConfigContentMatcherArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UptimeCheckConfigContentMatcher)(nil)).Elem()
}

func (i UptimeCheckConfigContentMatcherArray) ToUptimeCheckConfigContentMatcherArrayOutput() UptimeCheckConfigContentMatcherArrayOutput {
	return i.ToUptimeCheckConfigContentMatcherArrayOutputWithContext(context.Background())
}

func (i UptimeCheckConfigContentMatcherArray) ToUptimeCheckConfigContentMatcherArrayOutputWithContext(ctx context.Context) UptimeCheckConfigContentMatcherArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigContentMatcherArrayOutput)
}

type UptimeCheckConfigContentMatcherOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigContentMatcherOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigContentMatcher)(nil)).Elem()
}

func (o UptimeCheckConfigContentMatcherOutput) ToUptimeCheckConfigContentMatcherOutput() UptimeCheckConfigContentMatcherOutput {
	return o
}

func (o UptimeCheckConfigContentMatcherOutput) ToUptimeCheckConfigContentMatcherOutputWithContext(ctx context.Context) UptimeCheckConfigContentMatcherOutput {
	return o
}

// String or regex content to match (max 1024 bytes)
func (o UptimeCheckConfigContentMatcherOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v UptimeCheckConfigContentMatcher) string { return v.Content }).(pulumi.StringOutput)
}

type UptimeCheckConfigContentMatcherArrayOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigContentMatcherArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UptimeCheckConfigContentMatcher)(nil)).Elem()
}

func (o UptimeCheckConfigContentMatcherArrayOutput) ToUptimeCheckConfigContentMatcherArrayOutput() UptimeCheckConfigContentMatcherArrayOutput {
	return o
}

func (o UptimeCheckConfigContentMatcherArrayOutput) ToUptimeCheckConfigContentMatcherArrayOutputWithContext(ctx context.Context) UptimeCheckConfigContentMatcherArrayOutput {
	return o
}

func (o UptimeCheckConfigContentMatcherArrayOutput) Index(i pulumi.IntInput) UptimeCheckConfigContentMatcherOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UptimeCheckConfigContentMatcher {
		return vs[0].([]UptimeCheckConfigContentMatcher)[vs[1].(int)]
	}).(UptimeCheckConfigContentMatcherOutput)
}

type UptimeCheckConfigHttpCheck struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
	AuthInfo *UptimeCheckConfigHttpCheckAuthInfo `pulumi:"authInfo"`
	// The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if maskHeaders is set to True then the headers will be obscured with ******.
	MaskHeaders *bool `pulumi:"maskHeaders"`
	// The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
	Path *string `pulumi:"path"`
	// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
	Port *int `pulumi:"port"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl *bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
	ValidateSsl *bool `pulumi:"validateSsl"`
}

// UptimeCheckConfigHttpCheckInput is an input type that accepts UptimeCheckConfigHttpCheckArgs and UptimeCheckConfigHttpCheckOutput values.
// You can construct a concrete instance of `UptimeCheckConfigHttpCheckInput` via:
//
// 		 UptimeCheckConfigHttpCheckArgs{...}
//
type UptimeCheckConfigHttpCheckInput interface {
	pulumi.Input

	ToUptimeCheckConfigHttpCheckOutput() UptimeCheckConfigHttpCheckOutput
	ToUptimeCheckConfigHttpCheckOutputWithContext(context.Context) UptimeCheckConfigHttpCheckOutput
}

type UptimeCheckConfigHttpCheckArgs struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
	AuthInfo UptimeCheckConfigHttpCheckAuthInfoPtrInput `pulumi:"authInfo"`
	// The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers pulumi.StringMapInput `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if maskHeaders is set to True then the headers will be obscured with ******.
	MaskHeaders pulumi.BoolPtrInput `pulumi:"maskHeaders"`
	// The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
	Path pulumi.StringPtrInput `pulumi:"path"`
	// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl pulumi.BoolPtrInput `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
	ValidateSsl pulumi.BoolPtrInput `pulumi:"validateSsl"`
}

func (UptimeCheckConfigHttpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigHttpCheck)(nil)).Elem()
}

func (i UptimeCheckConfigHttpCheckArgs) ToUptimeCheckConfigHttpCheckOutput() UptimeCheckConfigHttpCheckOutput {
	return i.ToUptimeCheckConfigHttpCheckOutputWithContext(context.Background())
}

func (i UptimeCheckConfigHttpCheckArgs) ToUptimeCheckConfigHttpCheckOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckOutput)
}

func (i UptimeCheckConfigHttpCheckArgs) ToUptimeCheckConfigHttpCheckPtrOutput() UptimeCheckConfigHttpCheckPtrOutput {
	return i.ToUptimeCheckConfigHttpCheckPtrOutputWithContext(context.Background())
}

func (i UptimeCheckConfigHttpCheckArgs) ToUptimeCheckConfigHttpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckOutput).ToUptimeCheckConfigHttpCheckPtrOutputWithContext(ctx)
}

// UptimeCheckConfigHttpCheckPtrInput is an input type that accepts UptimeCheckConfigHttpCheckArgs, UptimeCheckConfigHttpCheckPtr and UptimeCheckConfigHttpCheckPtrOutput values.
// You can construct a concrete instance of `UptimeCheckConfigHttpCheckPtrInput` via:
//
// 		 UptimeCheckConfigHttpCheckArgs{...}
//
//  or:
//
// 		 nil
//
type UptimeCheckConfigHttpCheckPtrInput interface {
	pulumi.Input

	ToUptimeCheckConfigHttpCheckPtrOutput() UptimeCheckConfigHttpCheckPtrOutput
	ToUptimeCheckConfigHttpCheckPtrOutputWithContext(context.Context) UptimeCheckConfigHttpCheckPtrOutput
}

type uptimeCheckConfigHttpCheckPtrType UptimeCheckConfigHttpCheckArgs

func UptimeCheckConfigHttpCheckPtr(v *UptimeCheckConfigHttpCheckArgs) UptimeCheckConfigHttpCheckPtrInput {
	return (*uptimeCheckConfigHttpCheckPtrType)(v)
}

func (*uptimeCheckConfigHttpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigHttpCheck)(nil)).Elem()
}

func (i *uptimeCheckConfigHttpCheckPtrType) ToUptimeCheckConfigHttpCheckPtrOutput() UptimeCheckConfigHttpCheckPtrOutput {
	return i.ToUptimeCheckConfigHttpCheckPtrOutputWithContext(context.Background())
}

func (i *uptimeCheckConfigHttpCheckPtrType) ToUptimeCheckConfigHttpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckPtrOutput)
}

type UptimeCheckConfigHttpCheckOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigHttpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigHttpCheck)(nil)).Elem()
}

func (o UptimeCheckConfigHttpCheckOutput) ToUptimeCheckConfigHttpCheckOutput() UptimeCheckConfigHttpCheckOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckOutput) ToUptimeCheckConfigHttpCheckOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckOutput) ToUptimeCheckConfigHttpCheckPtrOutput() UptimeCheckConfigHttpCheckPtrOutput {
	return o.ToUptimeCheckConfigHttpCheckPtrOutputWithContext(context.Background())
}

func (o UptimeCheckConfigHttpCheckOutput) ToUptimeCheckConfigHttpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *UptimeCheckConfigHttpCheck {
		return &v
	}).(UptimeCheckConfigHttpCheckPtrOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
func (o UptimeCheckConfigHttpCheckOutput) AuthInfo() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *UptimeCheckConfigHttpCheckAuthInfo { return v.AuthInfo }).(UptimeCheckConfigHttpCheckAuthInfoPtrOutput)
}

// The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o UptimeCheckConfigHttpCheckOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if maskHeaders is set to True then the headers will be obscured with ******.
func (o UptimeCheckConfigHttpCheckOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *bool { return v.MaskHeaders }).(pulumi.BoolPtrOutput)
}

// The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
func (o UptimeCheckConfigHttpCheckOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
func (o UptimeCheckConfigHttpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o UptimeCheckConfigHttpCheckOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *bool { return v.UseSsl }).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
func (o UptimeCheckConfigHttpCheckOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheck) *bool { return v.ValidateSsl }).(pulumi.BoolPtrOutput)
}

type UptimeCheckConfigHttpCheckPtrOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigHttpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigHttpCheck)(nil)).Elem()
}

func (o UptimeCheckConfigHttpCheckPtrOutput) ToUptimeCheckConfigHttpCheckPtrOutput() UptimeCheckConfigHttpCheckPtrOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckPtrOutput) ToUptimeCheckConfigHttpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckPtrOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckPtrOutput) Elem() UptimeCheckConfigHttpCheckOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) UptimeCheckConfigHttpCheck { return *v }).(UptimeCheckConfigHttpCheckOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.  Structure is documented below.
func (o UptimeCheckConfigHttpCheckPtrOutput) AuthInfo() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *UptimeCheckConfigHttpCheckAuthInfo {
		if v == nil {
			return nil
		}
		return v.AuthInfo
	}).(UptimeCheckConfigHttpCheckAuthInfoPtrOutput)
}

// The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o UptimeCheckConfigHttpCheckPtrOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) map[string]string {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if maskHeaders is set to True then the headers will be obscured with ******.
func (o UptimeCheckConfigHttpCheckPtrOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.MaskHeaders
	}).(pulumi.BoolPtrOutput)
}

// The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. Optional (defaults to "/").
func (o UptimeCheckConfigHttpCheckPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
func (o UptimeCheckConfigHttpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o UptimeCheckConfigHttpCheckPtrOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.UseSsl
	}).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
func (o UptimeCheckConfigHttpCheckPtrOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.ValidateSsl
	}).(pulumi.BoolPtrOutput)
}

type UptimeCheckConfigHttpCheckAuthInfo struct {
	// The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
	Password string `pulumi:"password"`
	// The username to authenticate.
	Username string `pulumi:"username"`
}

// UptimeCheckConfigHttpCheckAuthInfoInput is an input type that accepts UptimeCheckConfigHttpCheckAuthInfoArgs and UptimeCheckConfigHttpCheckAuthInfoOutput values.
// You can construct a concrete instance of `UptimeCheckConfigHttpCheckAuthInfoInput` via:
//
// 		 UptimeCheckConfigHttpCheckAuthInfoArgs{...}
//
type UptimeCheckConfigHttpCheckAuthInfoInput interface {
	pulumi.Input

	ToUptimeCheckConfigHttpCheckAuthInfoOutput() UptimeCheckConfigHttpCheckAuthInfoOutput
	ToUptimeCheckConfigHttpCheckAuthInfoOutputWithContext(context.Context) UptimeCheckConfigHttpCheckAuthInfoOutput
}

type UptimeCheckConfigHttpCheckAuthInfoArgs struct {
	// The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
	Password pulumi.StringInput `pulumi:"password"`
	// The username to authenticate.
	Username pulumi.StringInput `pulumi:"username"`
}

func (UptimeCheckConfigHttpCheckAuthInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigHttpCheckAuthInfo)(nil)).Elem()
}

func (i UptimeCheckConfigHttpCheckAuthInfoArgs) ToUptimeCheckConfigHttpCheckAuthInfoOutput() UptimeCheckConfigHttpCheckAuthInfoOutput {
	return i.ToUptimeCheckConfigHttpCheckAuthInfoOutputWithContext(context.Background())
}

func (i UptimeCheckConfigHttpCheckAuthInfoArgs) ToUptimeCheckConfigHttpCheckAuthInfoOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckAuthInfoOutput)
}

func (i UptimeCheckConfigHttpCheckAuthInfoArgs) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutput() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return i.ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(context.Background())
}

func (i UptimeCheckConfigHttpCheckAuthInfoArgs) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckAuthInfoOutput).ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(ctx)
}

// UptimeCheckConfigHttpCheckAuthInfoPtrInput is an input type that accepts UptimeCheckConfigHttpCheckAuthInfoArgs, UptimeCheckConfigHttpCheckAuthInfoPtr and UptimeCheckConfigHttpCheckAuthInfoPtrOutput values.
// You can construct a concrete instance of `UptimeCheckConfigHttpCheckAuthInfoPtrInput` via:
//
// 		 UptimeCheckConfigHttpCheckAuthInfoArgs{...}
//
//  or:
//
// 		 nil
//
type UptimeCheckConfigHttpCheckAuthInfoPtrInput interface {
	pulumi.Input

	ToUptimeCheckConfigHttpCheckAuthInfoPtrOutput() UptimeCheckConfigHttpCheckAuthInfoPtrOutput
	ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(context.Context) UptimeCheckConfigHttpCheckAuthInfoPtrOutput
}

type uptimeCheckConfigHttpCheckAuthInfoPtrType UptimeCheckConfigHttpCheckAuthInfoArgs

func UptimeCheckConfigHttpCheckAuthInfoPtr(v *UptimeCheckConfigHttpCheckAuthInfoArgs) UptimeCheckConfigHttpCheckAuthInfoPtrInput {
	return (*uptimeCheckConfigHttpCheckAuthInfoPtrType)(v)
}

func (*uptimeCheckConfigHttpCheckAuthInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigHttpCheckAuthInfo)(nil)).Elem()
}

func (i *uptimeCheckConfigHttpCheckAuthInfoPtrType) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutput() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return i.ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(context.Background())
}

func (i *uptimeCheckConfigHttpCheckAuthInfoPtrType) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigHttpCheckAuthInfoPtrOutput)
}

type UptimeCheckConfigHttpCheckAuthInfoOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigHttpCheckAuthInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigHttpCheckAuthInfo)(nil)).Elem()
}

func (o UptimeCheckConfigHttpCheckAuthInfoOutput) ToUptimeCheckConfigHttpCheckAuthInfoOutput() UptimeCheckConfigHttpCheckAuthInfoOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckAuthInfoOutput) ToUptimeCheckConfigHttpCheckAuthInfoOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckAuthInfoOutput) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutput() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o.ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(context.Background())
}

func (o UptimeCheckConfigHttpCheckAuthInfoOutput) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheckAuthInfo) *UptimeCheckConfigHttpCheckAuthInfo {
		return &v
	}).(UptimeCheckConfigHttpCheckAuthInfoPtrOutput)
}

// The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
func (o UptimeCheckConfigHttpCheckAuthInfoOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheckAuthInfo) string { return v.Password }).(pulumi.StringOutput)
}

// The username to authenticate.
func (o UptimeCheckConfigHttpCheckAuthInfoOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v UptimeCheckConfigHttpCheckAuthInfo) string { return v.Username }).(pulumi.StringOutput)
}

type UptimeCheckConfigHttpCheckAuthInfoPtrOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigHttpCheckAuthInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigHttpCheckAuthInfo)(nil)).Elem()
}

func (o UptimeCheckConfigHttpCheckAuthInfoPtrOutput) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutput() UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckAuthInfoPtrOutput) ToUptimeCheckConfigHttpCheckAuthInfoPtrOutputWithContext(ctx context.Context) UptimeCheckConfigHttpCheckAuthInfoPtrOutput {
	return o
}

func (o UptimeCheckConfigHttpCheckAuthInfoPtrOutput) Elem() UptimeCheckConfigHttpCheckAuthInfoOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheckAuthInfo) UptimeCheckConfigHttpCheckAuthInfo { return *v }).(UptimeCheckConfigHttpCheckAuthInfoOutput)
}

// The password to authenticate.  **Note**: This property is sensitive and will not be displayed in the plan.
func (o UptimeCheckConfigHttpCheckAuthInfoPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheckAuthInfo) *string {
		if v == nil {
			return nil
		}
		return &v.Password
	}).(pulumi.StringPtrOutput)
}

// The username to authenticate.
func (o UptimeCheckConfigHttpCheckAuthInfoPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigHttpCheckAuthInfo) *string {
		if v == nil {
			return nil
		}
		return &v.Username
	}).(pulumi.StringPtrOutput)
}

type UptimeCheckConfigMonitoredResource struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "projectId", "instanceId", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// UptimeCheckConfigMonitoredResourceInput is an input type that accepts UptimeCheckConfigMonitoredResourceArgs and UptimeCheckConfigMonitoredResourceOutput values.
// You can construct a concrete instance of `UptimeCheckConfigMonitoredResourceInput` via:
//
// 		 UptimeCheckConfigMonitoredResourceArgs{...}
//
type UptimeCheckConfigMonitoredResourceInput interface {
	pulumi.Input

	ToUptimeCheckConfigMonitoredResourceOutput() UptimeCheckConfigMonitoredResourceOutput
	ToUptimeCheckConfigMonitoredResourceOutputWithContext(context.Context) UptimeCheckConfigMonitoredResourceOutput
}

type UptimeCheckConfigMonitoredResourceArgs struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "projectId", "instanceId", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type pulumi.StringInput `pulumi:"type"`
}

func (UptimeCheckConfigMonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigMonitoredResource)(nil)).Elem()
}

func (i UptimeCheckConfigMonitoredResourceArgs) ToUptimeCheckConfigMonitoredResourceOutput() UptimeCheckConfigMonitoredResourceOutput {
	return i.ToUptimeCheckConfigMonitoredResourceOutputWithContext(context.Background())
}

func (i UptimeCheckConfigMonitoredResourceArgs) ToUptimeCheckConfigMonitoredResourceOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigMonitoredResourceOutput)
}

func (i UptimeCheckConfigMonitoredResourceArgs) ToUptimeCheckConfigMonitoredResourcePtrOutput() UptimeCheckConfigMonitoredResourcePtrOutput {
	return i.ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i UptimeCheckConfigMonitoredResourceArgs) ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigMonitoredResourceOutput).ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(ctx)
}

// UptimeCheckConfigMonitoredResourcePtrInput is an input type that accepts UptimeCheckConfigMonitoredResourceArgs, UptimeCheckConfigMonitoredResourcePtr and UptimeCheckConfigMonitoredResourcePtrOutput values.
// You can construct a concrete instance of `UptimeCheckConfigMonitoredResourcePtrInput` via:
//
// 		 UptimeCheckConfigMonitoredResourceArgs{...}
//
//  or:
//
// 		 nil
//
type UptimeCheckConfigMonitoredResourcePtrInput interface {
	pulumi.Input

	ToUptimeCheckConfigMonitoredResourcePtrOutput() UptimeCheckConfigMonitoredResourcePtrOutput
	ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(context.Context) UptimeCheckConfigMonitoredResourcePtrOutput
}

type uptimeCheckConfigMonitoredResourcePtrType UptimeCheckConfigMonitoredResourceArgs

func UptimeCheckConfigMonitoredResourcePtr(v *UptimeCheckConfigMonitoredResourceArgs) UptimeCheckConfigMonitoredResourcePtrInput {
	return (*uptimeCheckConfigMonitoredResourcePtrType)(v)
}

func (*uptimeCheckConfigMonitoredResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigMonitoredResource)(nil)).Elem()
}

func (i *uptimeCheckConfigMonitoredResourcePtrType) ToUptimeCheckConfigMonitoredResourcePtrOutput() UptimeCheckConfigMonitoredResourcePtrOutput {
	return i.ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i *uptimeCheckConfigMonitoredResourcePtrType) ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigMonitoredResourcePtrOutput)
}

type UptimeCheckConfigMonitoredResourceOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigMonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigMonitoredResource)(nil)).Elem()
}

func (o UptimeCheckConfigMonitoredResourceOutput) ToUptimeCheckConfigMonitoredResourceOutput() UptimeCheckConfigMonitoredResourceOutput {
	return o
}

func (o UptimeCheckConfigMonitoredResourceOutput) ToUptimeCheckConfigMonitoredResourceOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourceOutput {
	return o
}

func (o UptimeCheckConfigMonitoredResourceOutput) ToUptimeCheckConfigMonitoredResourcePtrOutput() UptimeCheckConfigMonitoredResourcePtrOutput {
	return o.ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(context.Background())
}

func (o UptimeCheckConfigMonitoredResourceOutput) ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourcePtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigMonitoredResource) *UptimeCheckConfigMonitoredResource {
		return &v
	}).(UptimeCheckConfigMonitoredResourcePtrOutput)
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "projectId", "instanceId", and "zone".
func (o UptimeCheckConfigMonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v UptimeCheckConfigMonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o UptimeCheckConfigMonitoredResourceOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UptimeCheckConfigMonitoredResource) string { return v.Type }).(pulumi.StringOutput)
}

type UptimeCheckConfigMonitoredResourcePtrOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigMonitoredResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigMonitoredResource)(nil)).Elem()
}

func (o UptimeCheckConfigMonitoredResourcePtrOutput) ToUptimeCheckConfigMonitoredResourcePtrOutput() UptimeCheckConfigMonitoredResourcePtrOutput {
	return o
}

func (o UptimeCheckConfigMonitoredResourcePtrOutput) ToUptimeCheckConfigMonitoredResourcePtrOutputWithContext(ctx context.Context) UptimeCheckConfigMonitoredResourcePtrOutput {
	return o
}

func (o UptimeCheckConfigMonitoredResourcePtrOutput) Elem() UptimeCheckConfigMonitoredResourceOutput {
	return o.ApplyT(func(v *UptimeCheckConfigMonitoredResource) UptimeCheckConfigMonitoredResource { return *v }).(UptimeCheckConfigMonitoredResourceOutput)
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "projectId", "instanceId", and "zone".
func (o UptimeCheckConfigMonitoredResourcePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *UptimeCheckConfigMonitoredResource) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o UptimeCheckConfigMonitoredResourcePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigMonitoredResource) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type UptimeCheckConfigResourceGroup struct {
	// The group of resources being monitored. Should be the `name` of a group
	GroupId *string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType *string `pulumi:"resourceType"`
}

// UptimeCheckConfigResourceGroupInput is an input type that accepts UptimeCheckConfigResourceGroupArgs and UptimeCheckConfigResourceGroupOutput values.
// You can construct a concrete instance of `UptimeCheckConfigResourceGroupInput` via:
//
// 		 UptimeCheckConfigResourceGroupArgs{...}
//
type UptimeCheckConfigResourceGroupInput interface {
	pulumi.Input

	ToUptimeCheckConfigResourceGroupOutput() UptimeCheckConfigResourceGroupOutput
	ToUptimeCheckConfigResourceGroupOutputWithContext(context.Context) UptimeCheckConfigResourceGroupOutput
}

type UptimeCheckConfigResourceGroupArgs struct {
	// The group of resources being monitored. Should be the `name` of a group
	GroupId pulumi.StringPtrInput `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType pulumi.StringPtrInput `pulumi:"resourceType"`
}

func (UptimeCheckConfigResourceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigResourceGroup)(nil)).Elem()
}

func (i UptimeCheckConfigResourceGroupArgs) ToUptimeCheckConfigResourceGroupOutput() UptimeCheckConfigResourceGroupOutput {
	return i.ToUptimeCheckConfigResourceGroupOutputWithContext(context.Background())
}

func (i UptimeCheckConfigResourceGroupArgs) ToUptimeCheckConfigResourceGroupOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigResourceGroupOutput)
}

func (i UptimeCheckConfigResourceGroupArgs) ToUptimeCheckConfigResourceGroupPtrOutput() UptimeCheckConfigResourceGroupPtrOutput {
	return i.ToUptimeCheckConfigResourceGroupPtrOutputWithContext(context.Background())
}

func (i UptimeCheckConfigResourceGroupArgs) ToUptimeCheckConfigResourceGroupPtrOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigResourceGroupOutput).ToUptimeCheckConfigResourceGroupPtrOutputWithContext(ctx)
}

// UptimeCheckConfigResourceGroupPtrInput is an input type that accepts UptimeCheckConfigResourceGroupArgs, UptimeCheckConfigResourceGroupPtr and UptimeCheckConfigResourceGroupPtrOutput values.
// You can construct a concrete instance of `UptimeCheckConfigResourceGroupPtrInput` via:
//
// 		 UptimeCheckConfigResourceGroupArgs{...}
//
//  or:
//
// 		 nil
//
type UptimeCheckConfigResourceGroupPtrInput interface {
	pulumi.Input

	ToUptimeCheckConfigResourceGroupPtrOutput() UptimeCheckConfigResourceGroupPtrOutput
	ToUptimeCheckConfigResourceGroupPtrOutputWithContext(context.Context) UptimeCheckConfigResourceGroupPtrOutput
}

type uptimeCheckConfigResourceGroupPtrType UptimeCheckConfigResourceGroupArgs

func UptimeCheckConfigResourceGroupPtr(v *UptimeCheckConfigResourceGroupArgs) UptimeCheckConfigResourceGroupPtrInput {
	return (*uptimeCheckConfigResourceGroupPtrType)(v)
}

func (*uptimeCheckConfigResourceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigResourceGroup)(nil)).Elem()
}

func (i *uptimeCheckConfigResourceGroupPtrType) ToUptimeCheckConfigResourceGroupPtrOutput() UptimeCheckConfigResourceGroupPtrOutput {
	return i.ToUptimeCheckConfigResourceGroupPtrOutputWithContext(context.Background())
}

func (i *uptimeCheckConfigResourceGroupPtrType) ToUptimeCheckConfigResourceGroupPtrOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigResourceGroupPtrOutput)
}

type UptimeCheckConfigResourceGroupOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigResourceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigResourceGroup)(nil)).Elem()
}

func (o UptimeCheckConfigResourceGroupOutput) ToUptimeCheckConfigResourceGroupOutput() UptimeCheckConfigResourceGroupOutput {
	return o
}

func (o UptimeCheckConfigResourceGroupOutput) ToUptimeCheckConfigResourceGroupOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupOutput {
	return o
}

func (o UptimeCheckConfigResourceGroupOutput) ToUptimeCheckConfigResourceGroupPtrOutput() UptimeCheckConfigResourceGroupPtrOutput {
	return o.ToUptimeCheckConfigResourceGroupPtrOutputWithContext(context.Background())
}

func (o UptimeCheckConfigResourceGroupOutput) ToUptimeCheckConfigResourceGroupPtrOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigResourceGroup) *UptimeCheckConfigResourceGroup {
		return &v
	}).(UptimeCheckConfigResourceGroupPtrOutput)
}

// The group of resources being monitored. Should be the `name` of a group
func (o UptimeCheckConfigResourceGroupOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigResourceGroup) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o UptimeCheckConfigResourceGroupOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigResourceGroup) *string { return v.ResourceType }).(pulumi.StringPtrOutput)
}

type UptimeCheckConfigResourceGroupPtrOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigResourceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigResourceGroup)(nil)).Elem()
}

func (o UptimeCheckConfigResourceGroupPtrOutput) ToUptimeCheckConfigResourceGroupPtrOutput() UptimeCheckConfigResourceGroupPtrOutput {
	return o
}

func (o UptimeCheckConfigResourceGroupPtrOutput) ToUptimeCheckConfigResourceGroupPtrOutputWithContext(ctx context.Context) UptimeCheckConfigResourceGroupPtrOutput {
	return o
}

func (o UptimeCheckConfigResourceGroupPtrOutput) Elem() UptimeCheckConfigResourceGroupOutput {
	return o.ApplyT(func(v *UptimeCheckConfigResourceGroup) UptimeCheckConfigResourceGroup { return *v }).(UptimeCheckConfigResourceGroupOutput)
}

// The group of resources being monitored. Should be the `name` of a group
func (o UptimeCheckConfigResourceGroupPtrOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.GroupId
	}).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o UptimeCheckConfigResourceGroupPtrOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.ResourceType
	}).(pulumi.StringPtrOutput)
}

type UptimeCheckConfigTcpCheck struct {
	// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
	Port int `pulumi:"port"`
}

// UptimeCheckConfigTcpCheckInput is an input type that accepts UptimeCheckConfigTcpCheckArgs and UptimeCheckConfigTcpCheckOutput values.
// You can construct a concrete instance of `UptimeCheckConfigTcpCheckInput` via:
//
// 		 UptimeCheckConfigTcpCheckArgs{...}
//
type UptimeCheckConfigTcpCheckInput interface {
	pulumi.Input

	ToUptimeCheckConfigTcpCheckOutput() UptimeCheckConfigTcpCheckOutput
	ToUptimeCheckConfigTcpCheckOutputWithContext(context.Context) UptimeCheckConfigTcpCheckOutput
}

type UptimeCheckConfigTcpCheckArgs struct {
	// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
	Port pulumi.IntInput `pulumi:"port"`
}

func (UptimeCheckConfigTcpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigTcpCheck)(nil)).Elem()
}

func (i UptimeCheckConfigTcpCheckArgs) ToUptimeCheckConfigTcpCheckOutput() UptimeCheckConfigTcpCheckOutput {
	return i.ToUptimeCheckConfigTcpCheckOutputWithContext(context.Background())
}

func (i UptimeCheckConfigTcpCheckArgs) ToUptimeCheckConfigTcpCheckOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigTcpCheckOutput)
}

func (i UptimeCheckConfigTcpCheckArgs) ToUptimeCheckConfigTcpCheckPtrOutput() UptimeCheckConfigTcpCheckPtrOutput {
	return i.ToUptimeCheckConfigTcpCheckPtrOutputWithContext(context.Background())
}

func (i UptimeCheckConfigTcpCheckArgs) ToUptimeCheckConfigTcpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigTcpCheckOutput).ToUptimeCheckConfigTcpCheckPtrOutputWithContext(ctx)
}

// UptimeCheckConfigTcpCheckPtrInput is an input type that accepts UptimeCheckConfigTcpCheckArgs, UptimeCheckConfigTcpCheckPtr and UptimeCheckConfigTcpCheckPtrOutput values.
// You can construct a concrete instance of `UptimeCheckConfigTcpCheckPtrInput` via:
//
// 		 UptimeCheckConfigTcpCheckArgs{...}
//
//  or:
//
// 		 nil
//
type UptimeCheckConfigTcpCheckPtrInput interface {
	pulumi.Input

	ToUptimeCheckConfigTcpCheckPtrOutput() UptimeCheckConfigTcpCheckPtrOutput
	ToUptimeCheckConfigTcpCheckPtrOutputWithContext(context.Context) UptimeCheckConfigTcpCheckPtrOutput
}

type uptimeCheckConfigTcpCheckPtrType UptimeCheckConfigTcpCheckArgs

func UptimeCheckConfigTcpCheckPtr(v *UptimeCheckConfigTcpCheckArgs) UptimeCheckConfigTcpCheckPtrInput {
	return (*uptimeCheckConfigTcpCheckPtrType)(v)
}

func (*uptimeCheckConfigTcpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigTcpCheck)(nil)).Elem()
}

func (i *uptimeCheckConfigTcpCheckPtrType) ToUptimeCheckConfigTcpCheckPtrOutput() UptimeCheckConfigTcpCheckPtrOutput {
	return i.ToUptimeCheckConfigTcpCheckPtrOutputWithContext(context.Background())
}

func (i *uptimeCheckConfigTcpCheckPtrType) ToUptimeCheckConfigTcpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UptimeCheckConfigTcpCheckPtrOutput)
}

type UptimeCheckConfigTcpCheckOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigTcpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UptimeCheckConfigTcpCheck)(nil)).Elem()
}

func (o UptimeCheckConfigTcpCheckOutput) ToUptimeCheckConfigTcpCheckOutput() UptimeCheckConfigTcpCheckOutput {
	return o
}

func (o UptimeCheckConfigTcpCheckOutput) ToUptimeCheckConfigTcpCheckOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckOutput {
	return o
}

func (o UptimeCheckConfigTcpCheckOutput) ToUptimeCheckConfigTcpCheckPtrOutput() UptimeCheckConfigTcpCheckPtrOutput {
	return o.ToUptimeCheckConfigTcpCheckPtrOutputWithContext(context.Background())
}

func (o UptimeCheckConfigTcpCheckOutput) ToUptimeCheckConfigTcpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckPtrOutput {
	return o.ApplyT(func(v UptimeCheckConfigTcpCheck) *UptimeCheckConfigTcpCheck {
		return &v
	}).(UptimeCheckConfigTcpCheckPtrOutput)
}

// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
func (o UptimeCheckConfigTcpCheckOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v UptimeCheckConfigTcpCheck) int { return v.Port }).(pulumi.IntOutput)
}

type UptimeCheckConfigTcpCheckPtrOutput struct{ *pulumi.OutputState }

func (UptimeCheckConfigTcpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UptimeCheckConfigTcpCheck)(nil)).Elem()
}

func (o UptimeCheckConfigTcpCheckPtrOutput) ToUptimeCheckConfigTcpCheckPtrOutput() UptimeCheckConfigTcpCheckPtrOutput {
	return o
}

func (o UptimeCheckConfigTcpCheckPtrOutput) ToUptimeCheckConfigTcpCheckPtrOutputWithContext(ctx context.Context) UptimeCheckConfigTcpCheckPtrOutput {
	return o
}

func (o UptimeCheckConfigTcpCheckPtrOutput) Elem() UptimeCheckConfigTcpCheckOutput {
	return o.ApplyT(func(v *UptimeCheckConfigTcpCheck) UptimeCheckConfigTcpCheck { return *v }).(UptimeCheckConfigTcpCheckOutput)
}

// The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
func (o UptimeCheckConfigTcpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UptimeCheckConfigTcpCheck) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

type GetAppEngineServiceTelemetry struct {
	ResourceName string `pulumi:"resourceName"`
}

// GetAppEngineServiceTelemetryInput is an input type that accepts GetAppEngineServiceTelemetryArgs and GetAppEngineServiceTelemetryOutput values.
// You can construct a concrete instance of `GetAppEngineServiceTelemetryInput` via:
//
// 		 GetAppEngineServiceTelemetryArgs{...}
//
type GetAppEngineServiceTelemetryInput interface {
	pulumi.Input

	ToGetAppEngineServiceTelemetryOutput() GetAppEngineServiceTelemetryOutput
	ToGetAppEngineServiceTelemetryOutputWithContext(context.Context) GetAppEngineServiceTelemetryOutput
}

type GetAppEngineServiceTelemetryArgs struct {
	ResourceName pulumi.StringInput `pulumi:"resourceName"`
}

func (GetAppEngineServiceTelemetryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetAppEngineServiceTelemetry)(nil)).Elem()
}

func (i GetAppEngineServiceTelemetryArgs) ToGetAppEngineServiceTelemetryOutput() GetAppEngineServiceTelemetryOutput {
	return i.ToGetAppEngineServiceTelemetryOutputWithContext(context.Background())
}

func (i GetAppEngineServiceTelemetryArgs) ToGetAppEngineServiceTelemetryOutputWithContext(ctx context.Context) GetAppEngineServiceTelemetryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetAppEngineServiceTelemetryOutput)
}

// GetAppEngineServiceTelemetryArrayInput is an input type that accepts GetAppEngineServiceTelemetryArray and GetAppEngineServiceTelemetryArrayOutput values.
// You can construct a concrete instance of `GetAppEngineServiceTelemetryArrayInput` via:
//
// 		 GetAppEngineServiceTelemetryArray{ GetAppEngineServiceTelemetryArgs{...} }
//
type GetAppEngineServiceTelemetryArrayInput interface {
	pulumi.Input

	ToGetAppEngineServiceTelemetryArrayOutput() GetAppEngineServiceTelemetryArrayOutput
	ToGetAppEngineServiceTelemetryArrayOutputWithContext(context.Context) GetAppEngineServiceTelemetryArrayOutput
}

type GetAppEngineServiceTelemetryArray []GetAppEngineServiceTelemetryInput

func (GetAppEngineServiceTelemetryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetAppEngineServiceTelemetry)(nil)).Elem()
}

func (i GetAppEngineServiceTelemetryArray) ToGetAppEngineServiceTelemetryArrayOutput() GetAppEngineServiceTelemetryArrayOutput {
	return i.ToGetAppEngineServiceTelemetryArrayOutputWithContext(context.Background())
}

func (i GetAppEngineServiceTelemetryArray) ToGetAppEngineServiceTelemetryArrayOutputWithContext(ctx context.Context) GetAppEngineServiceTelemetryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetAppEngineServiceTelemetryArrayOutput)
}

type GetAppEngineServiceTelemetryOutput struct{ *pulumi.OutputState }

func (GetAppEngineServiceTelemetryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetAppEngineServiceTelemetry)(nil)).Elem()
}

func (o GetAppEngineServiceTelemetryOutput) ToGetAppEngineServiceTelemetryOutput() GetAppEngineServiceTelemetryOutput {
	return o
}

func (o GetAppEngineServiceTelemetryOutput) ToGetAppEngineServiceTelemetryOutputWithContext(ctx context.Context) GetAppEngineServiceTelemetryOutput {
	return o
}

func (o GetAppEngineServiceTelemetryOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v GetAppEngineServiceTelemetry) string { return v.ResourceName }).(pulumi.StringOutput)
}

type GetAppEngineServiceTelemetryArrayOutput struct{ *pulumi.OutputState }

func (GetAppEngineServiceTelemetryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetAppEngineServiceTelemetry)(nil)).Elem()
}

func (o GetAppEngineServiceTelemetryArrayOutput) ToGetAppEngineServiceTelemetryArrayOutput() GetAppEngineServiceTelemetryArrayOutput {
	return o
}

func (o GetAppEngineServiceTelemetryArrayOutput) ToGetAppEngineServiceTelemetryArrayOutputWithContext(ctx context.Context) GetAppEngineServiceTelemetryArrayOutput {
	return o
}

func (o GetAppEngineServiceTelemetryArrayOutput) Index(i pulumi.IntInput) GetAppEngineServiceTelemetryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetAppEngineServiceTelemetry {
		return vs[0].([]GetAppEngineServiceTelemetry)[vs[1].(int)]
	}).(GetAppEngineServiceTelemetryOutput)
}

type GetNotificationChannelSensitiveLabel struct {
	AuthToken  string `pulumi:"authToken"`
	Password   string `pulumi:"password"`
	ServiceKey string `pulumi:"serviceKey"`
}

// GetNotificationChannelSensitiveLabelInput is an input type that accepts GetNotificationChannelSensitiveLabelArgs and GetNotificationChannelSensitiveLabelOutput values.
// You can construct a concrete instance of `GetNotificationChannelSensitiveLabelInput` via:
//
// 		 GetNotificationChannelSensitiveLabelArgs{...}
//
type GetNotificationChannelSensitiveLabelInput interface {
	pulumi.Input

	ToGetNotificationChannelSensitiveLabelOutput() GetNotificationChannelSensitiveLabelOutput
	ToGetNotificationChannelSensitiveLabelOutputWithContext(context.Context) GetNotificationChannelSensitiveLabelOutput
}

type GetNotificationChannelSensitiveLabelArgs struct {
	AuthToken  pulumi.StringInput `pulumi:"authToken"`
	Password   pulumi.StringInput `pulumi:"password"`
	ServiceKey pulumi.StringInput `pulumi:"serviceKey"`
}

func (GetNotificationChannelSensitiveLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNotificationChannelSensitiveLabel)(nil)).Elem()
}

func (i GetNotificationChannelSensitiveLabelArgs) ToGetNotificationChannelSensitiveLabelOutput() GetNotificationChannelSensitiveLabelOutput {
	return i.ToGetNotificationChannelSensitiveLabelOutputWithContext(context.Background())
}

func (i GetNotificationChannelSensitiveLabelArgs) ToGetNotificationChannelSensitiveLabelOutputWithContext(ctx context.Context) GetNotificationChannelSensitiveLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNotificationChannelSensitiveLabelOutput)
}

// GetNotificationChannelSensitiveLabelArrayInput is an input type that accepts GetNotificationChannelSensitiveLabelArray and GetNotificationChannelSensitiveLabelArrayOutput values.
// You can construct a concrete instance of `GetNotificationChannelSensitiveLabelArrayInput` via:
//
// 		 GetNotificationChannelSensitiveLabelArray{ GetNotificationChannelSensitiveLabelArgs{...} }
//
type GetNotificationChannelSensitiveLabelArrayInput interface {
	pulumi.Input

	ToGetNotificationChannelSensitiveLabelArrayOutput() GetNotificationChannelSensitiveLabelArrayOutput
	ToGetNotificationChannelSensitiveLabelArrayOutputWithContext(context.Context) GetNotificationChannelSensitiveLabelArrayOutput
}

type GetNotificationChannelSensitiveLabelArray []GetNotificationChannelSensitiveLabelInput

func (GetNotificationChannelSensitiveLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNotificationChannelSensitiveLabel)(nil)).Elem()
}

func (i GetNotificationChannelSensitiveLabelArray) ToGetNotificationChannelSensitiveLabelArrayOutput() GetNotificationChannelSensitiveLabelArrayOutput {
	return i.ToGetNotificationChannelSensitiveLabelArrayOutputWithContext(context.Background())
}

func (i GetNotificationChannelSensitiveLabelArray) ToGetNotificationChannelSensitiveLabelArrayOutputWithContext(ctx context.Context) GetNotificationChannelSensitiveLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNotificationChannelSensitiveLabelArrayOutput)
}

type GetNotificationChannelSensitiveLabelOutput struct{ *pulumi.OutputState }

func (GetNotificationChannelSensitiveLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNotificationChannelSensitiveLabel)(nil)).Elem()
}

func (o GetNotificationChannelSensitiveLabelOutput) ToGetNotificationChannelSensitiveLabelOutput() GetNotificationChannelSensitiveLabelOutput {
	return o
}

func (o GetNotificationChannelSensitiveLabelOutput) ToGetNotificationChannelSensitiveLabelOutputWithContext(ctx context.Context) GetNotificationChannelSensitiveLabelOutput {
	return o
}

func (o GetNotificationChannelSensitiveLabelOutput) AuthToken() pulumi.StringOutput {
	return o.ApplyT(func(v GetNotificationChannelSensitiveLabel) string { return v.AuthToken }).(pulumi.StringOutput)
}

func (o GetNotificationChannelSensitiveLabelOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v GetNotificationChannelSensitiveLabel) string { return v.Password }).(pulumi.StringOutput)
}

func (o GetNotificationChannelSensitiveLabelOutput) ServiceKey() pulumi.StringOutput {
	return o.ApplyT(func(v GetNotificationChannelSensitiveLabel) string { return v.ServiceKey }).(pulumi.StringOutput)
}

type GetNotificationChannelSensitiveLabelArrayOutput struct{ *pulumi.OutputState }

func (GetNotificationChannelSensitiveLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNotificationChannelSensitiveLabel)(nil)).Elem()
}

func (o GetNotificationChannelSensitiveLabelArrayOutput) ToGetNotificationChannelSensitiveLabelArrayOutput() GetNotificationChannelSensitiveLabelArrayOutput {
	return o
}

func (o GetNotificationChannelSensitiveLabelArrayOutput) ToGetNotificationChannelSensitiveLabelArrayOutputWithContext(ctx context.Context) GetNotificationChannelSensitiveLabelArrayOutput {
	return o
}

func (o GetNotificationChannelSensitiveLabelArrayOutput) Index(i pulumi.IntInput) GetNotificationChannelSensitiveLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetNotificationChannelSensitiveLabel {
		return vs[0].([]GetNotificationChannelSensitiveLabel)[vs[1].(int)]
	}).(GetNotificationChannelSensitiveLabelOutput)
}

type GetUptimeCheckIPsUptimeCheckIp struct {
	// The IP address from which the Uptime check originates. This is a fully specified IP address
	// (not an IP address range). Most IP addresses, as of this publication, are in IPv4 format; however, one should not
	// rely on the IP addresses being in IPv4 format indefinitely, and should support interpreting this field in either
	// IPv4 or IPv6 format.
	IpAddress string `pulumi:"ipAddress"`
	// A more specific location within the region that typically encodes a particular city/town/metro
	// (and its containing state/province or country) within the broader umbrella region category.
	Location string `pulumi:"location"`
	// A broad region category in which the IP address is located.
	Region string `pulumi:"region"`
}

// GetUptimeCheckIPsUptimeCheckIpInput is an input type that accepts GetUptimeCheckIPsUptimeCheckIpArgs and GetUptimeCheckIPsUptimeCheckIpOutput values.
// You can construct a concrete instance of `GetUptimeCheckIPsUptimeCheckIpInput` via:
//
// 		 GetUptimeCheckIPsUptimeCheckIpArgs{...}
//
type GetUptimeCheckIPsUptimeCheckIpInput interface {
	pulumi.Input

	ToGetUptimeCheckIPsUptimeCheckIpOutput() GetUptimeCheckIPsUptimeCheckIpOutput
	ToGetUptimeCheckIPsUptimeCheckIpOutputWithContext(context.Context) GetUptimeCheckIPsUptimeCheckIpOutput
}

type GetUptimeCheckIPsUptimeCheckIpArgs struct {
	// The IP address from which the Uptime check originates. This is a fully specified IP address
	// (not an IP address range). Most IP addresses, as of this publication, are in IPv4 format; however, one should not
	// rely on the IP addresses being in IPv4 format indefinitely, and should support interpreting this field in either
	// IPv4 or IPv6 format.
	IpAddress pulumi.StringInput `pulumi:"ipAddress"`
	// A more specific location within the region that typically encodes a particular city/town/metro
	// (and its containing state/province or country) within the broader umbrella region category.
	Location pulumi.StringInput `pulumi:"location"`
	// A broad region category in which the IP address is located.
	Region pulumi.StringInput `pulumi:"region"`
}

func (GetUptimeCheckIPsUptimeCheckIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUptimeCheckIPsUptimeCheckIp)(nil)).Elem()
}

func (i GetUptimeCheckIPsUptimeCheckIpArgs) ToGetUptimeCheckIPsUptimeCheckIpOutput() GetUptimeCheckIPsUptimeCheckIpOutput {
	return i.ToGetUptimeCheckIPsUptimeCheckIpOutputWithContext(context.Background())
}

func (i GetUptimeCheckIPsUptimeCheckIpArgs) ToGetUptimeCheckIPsUptimeCheckIpOutputWithContext(ctx context.Context) GetUptimeCheckIPsUptimeCheckIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUptimeCheckIPsUptimeCheckIpOutput)
}

// GetUptimeCheckIPsUptimeCheckIpArrayInput is an input type that accepts GetUptimeCheckIPsUptimeCheckIpArray and GetUptimeCheckIPsUptimeCheckIpArrayOutput values.
// You can construct a concrete instance of `GetUptimeCheckIPsUptimeCheckIpArrayInput` via:
//
// 		 GetUptimeCheckIPsUptimeCheckIpArray{ GetUptimeCheckIPsUptimeCheckIpArgs{...} }
//
type GetUptimeCheckIPsUptimeCheckIpArrayInput interface {
	pulumi.Input

	ToGetUptimeCheckIPsUptimeCheckIpArrayOutput() GetUptimeCheckIPsUptimeCheckIpArrayOutput
	ToGetUptimeCheckIPsUptimeCheckIpArrayOutputWithContext(context.Context) GetUptimeCheckIPsUptimeCheckIpArrayOutput
}

type GetUptimeCheckIPsUptimeCheckIpArray []GetUptimeCheckIPsUptimeCheckIpInput

func (GetUptimeCheckIPsUptimeCheckIpArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUptimeCheckIPsUptimeCheckIp)(nil)).Elem()
}

func (i GetUptimeCheckIPsUptimeCheckIpArray) ToGetUptimeCheckIPsUptimeCheckIpArrayOutput() GetUptimeCheckIPsUptimeCheckIpArrayOutput {
	return i.ToGetUptimeCheckIPsUptimeCheckIpArrayOutputWithContext(context.Background())
}

func (i GetUptimeCheckIPsUptimeCheckIpArray) ToGetUptimeCheckIPsUptimeCheckIpArrayOutputWithContext(ctx context.Context) GetUptimeCheckIPsUptimeCheckIpArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUptimeCheckIPsUptimeCheckIpArrayOutput)
}

type GetUptimeCheckIPsUptimeCheckIpOutput struct{ *pulumi.OutputState }

func (GetUptimeCheckIPsUptimeCheckIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUptimeCheckIPsUptimeCheckIp)(nil)).Elem()
}

func (o GetUptimeCheckIPsUptimeCheckIpOutput) ToGetUptimeCheckIPsUptimeCheckIpOutput() GetUptimeCheckIPsUptimeCheckIpOutput {
	return o
}

func (o GetUptimeCheckIPsUptimeCheckIpOutput) ToGetUptimeCheckIPsUptimeCheckIpOutputWithContext(ctx context.Context) GetUptimeCheckIPsUptimeCheckIpOutput {
	return o
}

// The IP address from which the Uptime check originates. This is a fully specified IP address
// (not an IP address range). Most IP addresses, as of this publication, are in IPv4 format; however, one should not
// rely on the IP addresses being in IPv4 format indefinitely, and should support interpreting this field in either
// IPv4 or IPv6 format.
func (o GetUptimeCheckIPsUptimeCheckIpOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v GetUptimeCheckIPsUptimeCheckIp) string { return v.IpAddress }).(pulumi.StringOutput)
}

// A more specific location within the region that typically encodes a particular city/town/metro
// (and its containing state/province or country) within the broader umbrella region category.
func (o GetUptimeCheckIPsUptimeCheckIpOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetUptimeCheckIPsUptimeCheckIp) string { return v.Location }).(pulumi.StringOutput)
}

// A broad region category in which the IP address is located.
func (o GetUptimeCheckIPsUptimeCheckIpOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v GetUptimeCheckIPsUptimeCheckIp) string { return v.Region }).(pulumi.StringOutput)
}

type GetUptimeCheckIPsUptimeCheckIpArrayOutput struct{ *pulumi.OutputState }

func (GetUptimeCheckIPsUptimeCheckIpArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUptimeCheckIPsUptimeCheckIp)(nil)).Elem()
}

func (o GetUptimeCheckIPsUptimeCheckIpArrayOutput) ToGetUptimeCheckIPsUptimeCheckIpArrayOutput() GetUptimeCheckIPsUptimeCheckIpArrayOutput {
	return o
}

func (o GetUptimeCheckIPsUptimeCheckIpArrayOutput) ToGetUptimeCheckIPsUptimeCheckIpArrayOutputWithContext(ctx context.Context) GetUptimeCheckIPsUptimeCheckIpArrayOutput {
	return o
}

func (o GetUptimeCheckIPsUptimeCheckIpArrayOutput) Index(i pulumi.IntInput) GetUptimeCheckIPsUptimeCheckIpOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetUptimeCheckIPsUptimeCheckIp {
		return vs[0].([]GetUptimeCheckIPsUptimeCheckIp)[vs[1].(int)]
	}).(GetUptimeCheckIPsUptimeCheckIpOutput)
}

func init() {
	pulumi.RegisterOutputType(AlertPolicyConditionOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionArrayOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentPtrOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentAggregationOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentAggregationArrayOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentTriggerOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionAbsentTriggerPtrOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdPtrOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdAggregationOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdAggregationArrayOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdDenominatorAggregationOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdDenominatorAggregationArrayOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdTriggerOutput{})
	pulumi.RegisterOutputType(AlertPolicyConditionConditionThresholdTriggerPtrOutput{})
	pulumi.RegisterOutputType(AlertPolicyCreationRecordOutput{})
	pulumi.RegisterOutputType(AlertPolicyCreationRecordPtrOutput{})
	pulumi.RegisterOutputType(AlertPolicyDocumentationOutput{})
	pulumi.RegisterOutputType(AlertPolicyDocumentationPtrOutput{})
	pulumi.RegisterOutputType(CustomServiceTelemetryOutput{})
	pulumi.RegisterOutputType(CustomServiceTelemetryPtrOutput{})
	pulumi.RegisterOutputType(NotificationChannelSensitiveLabelsOutput{})
	pulumi.RegisterOutputType(NotificationChannelSensitiveLabelsPtrOutput{})
	pulumi.RegisterOutputType(SloBasicSliOutput{})
	pulumi.RegisterOutputType(SloBasicSliPtrOutput{})
	pulumi.RegisterOutputType(SloBasicSliLatencyOutput{})
	pulumi.RegisterOutputType(SloBasicSliLatencyPtrOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliPtrOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliDistributionCutOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliDistributionCutPtrOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliDistributionCutRangeOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliDistributionCutRangePtrOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliGoodTotalRatioOutput{})
	pulumi.RegisterOutputType(SloRequestBasedSliGoodTotalRatioPtrOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigContentMatcherOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigContentMatcherArrayOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigHttpCheckOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigHttpCheckPtrOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigHttpCheckAuthInfoOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigHttpCheckAuthInfoPtrOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigMonitoredResourceOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigMonitoredResourcePtrOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigResourceGroupOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigResourceGroupPtrOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigTcpCheckOutput{})
	pulumi.RegisterOutputType(UptimeCheckConfigTcpCheckPtrOutput{})
	pulumi.RegisterOutputType(GetAppEngineServiceTelemetryOutput{})
	pulumi.RegisterOutputType(GetAppEngineServiceTelemetryArrayOutput{})
	pulumi.RegisterOutputType(GetNotificationChannelSensitiveLabelOutput{})
	pulumi.RegisterOutputType(GetNotificationChannelSensitiveLabelArrayOutput{})
	pulumi.RegisterOutputType(GetUptimeCheckIPsUptimeCheckIpOutput{})
	pulumi.RegisterOutputType(GetUptimeCheckIPsUptimeCheckIpArrayOutput{})
}
