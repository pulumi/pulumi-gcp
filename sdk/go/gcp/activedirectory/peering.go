// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package activedirectory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// ## Example Usage
// ### Active Directory Peering Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/activedirectory"
//	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/projects"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewNetwork(ctx, "source-network", nil, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			_, err = activedirectory.NewDomain(ctx, "ad-domain", &activedirectory.DomainArgs{
//				DomainName: pulumi.String("ad.test.hashicorptest.com"),
//				Locations: pulumi.StringArray{
//					pulumi.String("us-central1"),
//				},
//				ReservedIpRange: pulumi.String("192.168.255.0/24"),
//				AuthorizedNetworks: pulumi.StringArray{
//					source_network.ID(),
//				},
//			}, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			_, err = organizations.NewProject(ctx, "peered-project", &organizations.ProjectArgs{
//				ProjectId:      pulumi.String("my-peered-project"),
//				OrgId:          pulumi.String("123456789"),
//				BillingAccount: pulumi.String("000000-0000000-0000000-000000"),
//			}, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			compute, err := projects.NewService(ctx, "compute", &projects.ServiceArgs{
//				Project: peered_project.ProjectId,
//				Service: pulumi.String("compute.googleapis.com"),
//			}, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewNetwork(ctx, "peered-network", &compute.NetworkArgs{
//				Project: compute.Project,
//			}, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			_, err = activedirectory.NewPeering(ctx, "ad-domain-peering", &activedirectory.PeeringArgs{
//				DomainResource:    ad_domain.Name,
//				PeeringId:         pulumi.String("ad-domain-peering"),
//				AuthorizedNetwork: peered_network.ID(),
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			}, pulumi.Provider(google_beta))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource does not support import.
type Peering struct {
	pulumi.CustomResourceState

	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringOutput `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringOutput `pulumi:"domainResource"`
	// Resource labels that can contain user-provided metadata
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name pulumi.StringOutput `pulumi:"name"`
	// ***
	PeeringId pulumi.StringOutput `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The current state of this Peering.
	Status pulumi.StringPtrOutput `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrOutput `pulumi:"statusMessage"`
}

// NewPeering registers a new resource with the given unique name, arguments, and options.
func NewPeering(ctx *pulumi.Context,
	name string, args *PeeringArgs, opts ...pulumi.ResourceOption) (*Peering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AuthorizedNetwork == nil {
		return nil, errors.New("invalid value for required argument 'AuthorizedNetwork'")
	}
	if args.DomainResource == nil {
		return nil, errors.New("invalid value for required argument 'DomainResource'")
	}
	if args.PeeringId == nil {
		return nil, errors.New("invalid value for required argument 'PeeringId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Peering
	err := ctx.RegisterResource("gcp:activedirectory/peering:Peering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPeering gets an existing Peering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PeeringState, opts ...pulumi.ResourceOption) (*Peering, error) {
	var resource Peering
	err := ctx.ReadResource("gcp:activedirectory/peering:Peering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Peering resources.
type peeringState struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork *string `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource *string `pulumi:"domainResource"`
	// Resource labels that can contain user-provided metadata
	Labels map[string]string `pulumi:"labels"`
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name *string `pulumi:"name"`
	// ***
	PeeringId *string `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The current state of this Peering.
	Status *string `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage *string `pulumi:"statusMessage"`
}

type PeeringState struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringPtrInput
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringPtrInput
	// Resource labels that can contain user-provided metadata
	Labels pulumi.StringMapInput
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name pulumi.StringPtrInput
	// ***
	PeeringId pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The current state of this Peering.
	Status pulumi.StringPtrInput
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrInput
}

func (PeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringState)(nil)).Elem()
}

type peeringArgs struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork string `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource string `pulumi:"domainResource"`
	// Resource labels that can contain user-provided metadata
	Labels map[string]string `pulumi:"labels"`
	// ***
	PeeringId string `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The current state of this Peering.
	Status *string `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage *string `pulumi:"statusMessage"`
}

// The set of arguments for constructing a Peering resource.
type PeeringArgs struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringInput
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringInput
	// Resource labels that can contain user-provided metadata
	Labels pulumi.StringMapInput
	// ***
	PeeringId pulumi.StringInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The current state of this Peering.
	Status pulumi.StringPtrInput
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrInput
}

func (PeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringArgs)(nil)).Elem()
}

type PeeringInput interface {
	pulumi.Input

	ToPeeringOutput() PeeringOutput
	ToPeeringOutputWithContext(ctx context.Context) PeeringOutput
}

func (*Peering) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (i *Peering) ToPeeringOutput() PeeringOutput {
	return i.ToPeeringOutputWithContext(context.Background())
}

func (i *Peering) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringOutput)
}

func (i *Peering) ToOutput(ctx context.Context) pulumix.Output[*Peering] {
	return pulumix.Output[*Peering]{
		OutputState: i.ToPeeringOutputWithContext(ctx).OutputState,
	}
}

// PeeringArrayInput is an input type that accepts PeeringArray and PeeringArrayOutput values.
// You can construct a concrete instance of `PeeringArrayInput` via:
//
//	PeeringArray{ PeeringArgs{...} }
type PeeringArrayInput interface {
	pulumi.Input

	ToPeeringArrayOutput() PeeringArrayOutput
	ToPeeringArrayOutputWithContext(context.Context) PeeringArrayOutput
}

type PeeringArray []PeeringInput

func (PeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (i PeeringArray) ToPeeringArrayOutput() PeeringArrayOutput {
	return i.ToPeeringArrayOutputWithContext(context.Background())
}

func (i PeeringArray) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringArrayOutput)
}

func (i PeeringArray) ToOutput(ctx context.Context) pulumix.Output[[]*Peering] {
	return pulumix.Output[[]*Peering]{
		OutputState: i.ToPeeringArrayOutputWithContext(ctx).OutputState,
	}
}

// PeeringMapInput is an input type that accepts PeeringMap and PeeringMapOutput values.
// You can construct a concrete instance of `PeeringMapInput` via:
//
//	PeeringMap{ "key": PeeringArgs{...} }
type PeeringMapInput interface {
	pulumi.Input

	ToPeeringMapOutput() PeeringMapOutput
	ToPeeringMapOutputWithContext(context.Context) PeeringMapOutput
}

type PeeringMap map[string]PeeringInput

func (PeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (i PeeringMap) ToPeeringMapOutput() PeeringMapOutput {
	return i.ToPeeringMapOutputWithContext(context.Background())
}

func (i PeeringMap) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringMapOutput)
}

func (i PeeringMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Peering] {
	return pulumix.Output[map[string]*Peering]{
		OutputState: i.ToPeeringMapOutputWithContext(ctx).OutputState,
	}
}

type PeeringOutput struct{ *pulumi.OutputState }

func (PeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (o PeeringOutput) ToPeeringOutput() PeeringOutput {
	return o
}

func (o PeeringOutput) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return o
}

func (o PeeringOutput) ToOutput(ctx context.Context) pulumix.Output[*Peering] {
	return pulumix.Output[*Peering]{
		OutputState: o.OutputState,
	}
}

// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
func (o PeeringOutput) AuthorizedNetwork() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.AuthorizedNetwork }).(pulumi.StringOutput)
}

// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
func (o PeeringOutput) DomainResource() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.DomainResource }).(pulumi.StringOutput)
}

// Resource labels that can contain user-provided metadata
func (o PeeringOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
func (o PeeringOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// ***
func (o PeeringOutput) PeeringId() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeeringId }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o PeeringOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The current state of this Peering.
func (o PeeringOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

// Additional information about the current status of this peering, if available.
func (o PeeringOutput) StatusMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringPtrOutput { return v.StatusMessage }).(pulumi.StringPtrOutput)
}

type PeeringArrayOutput struct{ *pulumi.OutputState }

func (PeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (o PeeringArrayOutput) ToPeeringArrayOutput() PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Peering] {
	return pulumix.Output[[]*Peering]{
		OutputState: o.OutputState,
	}
}

func (o PeeringArrayOutput) Index(i pulumi.IntInput) PeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].([]*Peering)[vs[1].(int)]
	}).(PeeringOutput)
}

type PeeringMapOutput struct{ *pulumi.OutputState }

func (PeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (o PeeringMapOutput) ToPeeringMapOutput() PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Peering] {
	return pulumix.Output[map[string]*Peering]{
		OutputState: o.OutputState,
	}
}

func (o PeeringMapOutput) MapIndex(k pulumi.StringInput) PeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].(map[string]*Peering)[vs[1].(string)]
	}).(PeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringInput)(nil)).Elem(), &Peering{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringArrayInput)(nil)).Elem(), PeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringMapInput)(nil)).Elem(), PeeringMap{})
	pulumi.RegisterOutputType(PeeringOutput{})
	pulumi.RegisterOutputType(PeeringArrayOutput{})
	pulumi.RegisterOutputType(PeeringMapOutput{})
}
