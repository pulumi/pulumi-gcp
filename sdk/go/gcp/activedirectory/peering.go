// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package activedirectory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a Peering for Managed AD instance.
//
// > **Warning:** This resource is in beta, and should be used with the terraform-provider-google-beta provider.
// See Provider Versions for more details on beta resources.
//
// To get more information about Peering, see:
//
// * [API documentation](https://cloud.google.com/managed-microsoft-ad/reference/rest/v1beta1/projects.locations.global.peerings)
// * How-to Guides
//   - [Active Directory Domain Peering](https://cloud.google.com/managed-microsoft-ad/docs/domain-peering)
//
// ## Example Usage
//
// ### Active Directory Peering Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/activedirectory"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/projects"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			source_network, err := compute.NewNetwork(ctx, "source-network", &compute.NetworkArgs{
//				Name: pulumi.String("ad-network"),
//			})
//			if err != nil {
//				return err
//			}
//			ad_domain, err := activedirectory.NewDomain(ctx, "ad-domain", &activedirectory.DomainArgs{
//				DomainName: pulumi.String("ad.test.hashicorptest.com"),
//				Locations: pulumi.StringArray{
//					pulumi.String("us-central1"),
//				},
//				ReservedIpRange: pulumi.String("192.168.255.0/24"),
//				AuthorizedNetworks: pulumi.StringArray{
//					source_network.ID(),
//				},
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			peered_project, err := organizations.NewProject(ctx, "peered-project", &organizations.ProjectArgs{
//				Name:           pulumi.String("my-peered-project"),
//				ProjectId:      pulumi.String("my-peered-project"),
//				OrgId:          pulumi.String("123456789"),
//				BillingAccount: pulumi.String("000000-0000000-0000000-000000"),
//				DeletionPolicy: pulumi.String("DELETE"),
//			})
//			if err != nil {
//				return err
//			}
//			compute, err := projects.NewService(ctx, "compute", &projects.ServiceArgs{
//				Project: peered_project.ProjectId,
//				Service: pulumi.String("compute.googleapis.com"),
//			})
//			if err != nil {
//				return err
//			}
//			peered_network, err := compute.NewNetwork(ctx, "peered-network", &compute.NetworkArgs{
//				Project: compute.Project,
//				Name:    pulumi.String("ad-peered-network"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = activedirectory.NewPeering(ctx, "ad-domain-peering", &activedirectory.PeeringArgs{
//				DomainResource:     ad_domain.Name,
//				PeeringId:          pulumi.String("ad-domain-peering"),
//				AuthorizedNetwork:  peered_network.ID(),
//				DeletionProtection: false,
//				Labels: pulumi.StringMap{
//					"foo": pulumi.String("bar"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource does not support import.
type Peering struct {
	pulumi.CustomResourceState

	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringOutput `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringOutput `pulumi:"domainResource"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Resource labels that can contain user-provided metadata
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name pulumi.StringOutput `pulumi:"name"`
	// (Required)
	PeeringId pulumi.StringOutput `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// The current state of this Peering.
	Status pulumi.StringPtrOutput `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrOutput `pulumi:"statusMessage"`
}

// NewPeering registers a new resource with the given unique name, arguments, and options.
func NewPeering(ctx *pulumi.Context,
	name string, args *PeeringArgs, opts ...pulumi.ResourceOption) (*Peering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AuthorizedNetwork == nil {
		return nil, errors.New("invalid value for required argument 'AuthorizedNetwork'")
	}
	if args.DomainResource == nil {
		return nil, errors.New("invalid value for required argument 'DomainResource'")
	}
	if args.PeeringId == nil {
		return nil, errors.New("invalid value for required argument 'PeeringId'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Peering
	err := ctx.RegisterResource("gcp:activedirectory/peering:Peering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPeering gets an existing Peering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PeeringState, opts ...pulumi.ResourceOption) (*Peering, error) {
	var resource Peering
	err := ctx.ReadResource("gcp:activedirectory/peering:Peering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Peering resources.
type peeringState struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork *string `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource *string `pulumi:"domainResource"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Resource labels that can contain user-provided metadata
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name *string `pulumi:"name"`
	// (Required)
	PeeringId *string `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// The current state of this Peering.
	Status *string `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage *string `pulumi:"statusMessage"`
}

type PeeringState struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringPtrInput
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Resource labels that can contain user-provided metadata
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
	Name pulumi.StringPtrInput
	// (Required)
	PeeringId pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// The current state of this Peering.
	Status pulumi.StringPtrInput
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrInput
}

func (PeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringState)(nil)).Elem()
}

type peeringArgs struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork string `pulumi:"authorizedNetwork"`
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource string `pulumi:"domainResource"`
	// Resource labels that can contain user-provided metadata
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// (Required)
	PeeringId string `pulumi:"peeringId"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The current state of this Peering.
	Status *string `pulumi:"status"`
	// Additional information about the current status of this peering, if available.
	StatusMessage *string `pulumi:"statusMessage"`
}

// The set of arguments for constructing a Peering resource.
type PeeringArgs struct {
	// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
	AuthorizedNetwork pulumi.StringInput
	// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
	DomainResource pulumi.StringInput
	// Resource labels that can contain user-provided metadata
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// (Required)
	PeeringId pulumi.StringInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The current state of this Peering.
	Status pulumi.StringPtrInput
	// Additional information about the current status of this peering, if available.
	StatusMessage pulumi.StringPtrInput
}

func (PeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringArgs)(nil)).Elem()
}

type PeeringInput interface {
	pulumi.Input

	ToPeeringOutput() PeeringOutput
	ToPeeringOutputWithContext(ctx context.Context) PeeringOutput
}

func (*Peering) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (i *Peering) ToPeeringOutput() PeeringOutput {
	return i.ToPeeringOutputWithContext(context.Background())
}

func (i *Peering) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringOutput)
}

// PeeringArrayInput is an input type that accepts PeeringArray and PeeringArrayOutput values.
// You can construct a concrete instance of `PeeringArrayInput` via:
//
//	PeeringArray{ PeeringArgs{...} }
type PeeringArrayInput interface {
	pulumi.Input

	ToPeeringArrayOutput() PeeringArrayOutput
	ToPeeringArrayOutputWithContext(context.Context) PeeringArrayOutput
}

type PeeringArray []PeeringInput

func (PeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (i PeeringArray) ToPeeringArrayOutput() PeeringArrayOutput {
	return i.ToPeeringArrayOutputWithContext(context.Background())
}

func (i PeeringArray) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringArrayOutput)
}

// PeeringMapInput is an input type that accepts PeeringMap and PeeringMapOutput values.
// You can construct a concrete instance of `PeeringMapInput` via:
//
//	PeeringMap{ "key": PeeringArgs{...} }
type PeeringMapInput interface {
	pulumi.Input

	ToPeeringMapOutput() PeeringMapOutput
	ToPeeringMapOutputWithContext(context.Context) PeeringMapOutput
}

type PeeringMap map[string]PeeringInput

func (PeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (i PeeringMap) ToPeeringMapOutput() PeeringMapOutput {
	return i.ToPeeringMapOutputWithContext(context.Background())
}

func (i PeeringMap) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringMapOutput)
}

type PeeringOutput struct{ *pulumi.OutputState }

func (PeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (o PeeringOutput) ToPeeringOutput() PeeringOutput {
	return o
}

func (o PeeringOutput) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return o
}

// The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
func (o PeeringOutput) AuthorizedNetwork() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.AuthorizedNetwork }).(pulumi.StringOutput)
}

// Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
func (o PeeringOutput) DomainResource() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.DomainResource }).(pulumi.StringOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o PeeringOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Resource labels that can contain user-provided metadata
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o PeeringOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
func (o PeeringOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// (Required)
func (o PeeringOutput) PeeringId() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeeringId }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o PeeringOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o PeeringOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// The current state of this Peering.
func (o PeeringOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

// Additional information about the current status of this peering, if available.
func (o PeeringOutput) StatusMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringPtrOutput { return v.StatusMessage }).(pulumi.StringPtrOutput)
}

type PeeringArrayOutput struct{ *pulumi.OutputState }

func (PeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (o PeeringArrayOutput) ToPeeringArrayOutput() PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) Index(i pulumi.IntInput) PeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].([]*Peering)[vs[1].(int)]
	}).(PeeringOutput)
}

type PeeringMapOutput struct{ *pulumi.OutputState }

func (PeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (o PeeringMapOutput) ToPeeringMapOutput() PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) MapIndex(k pulumi.StringInput) PeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].(map[string]*Peering)[vs[1].(string)]
	}).(PeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringInput)(nil)).Elem(), &Peering{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringArrayInput)(nil)).Elem(), PeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringMapInput)(nil)).Elem(), PeeringMap{})
	pulumi.RegisterOutputType(PeeringOutput{})
	pulumi.RegisterOutputType(PeeringArrayOutput{})
	pulumi.RegisterOutputType(PeeringMapOutput{})
}
