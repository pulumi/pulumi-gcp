// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package orgpolicy

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Defines an organization policy which is used to specify constraints for configurations of Google Cloud resources.
//
// To get more information about Policy, see:
//
// * [API documentation](https://cloud.google.com/resource-manager/docs/reference/orgpolicy/rest/v2/organizations.policies)
// * How-to Guides
//   - [Official Documentation](https://cloud.google.com/resource-manager/docs/organization-policy/creating-managing-custom-constraints)
//   - [Supported Services](https://cloud.google.com/resource-manager/docs/organization-policy/custom-constraint-supported-services)
//
// ## Example Usage
//
// ### Org Policy Policy Enforce
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/orgpolicy"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basic, err := organizations.NewProject(ctx, "basic", &organizations.ProjectArgs{
//				ProjectId:      pulumi.String("id"),
//				Name:           pulumi.String("id"),
//				OrgId:          pulumi.String("123456789"),
//				DeletionPolicy: pulumi.String("DELETE"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = orgpolicy.NewPolicy(ctx, "primary", &orgpolicy.PolicyArgs{
//				Name: basic.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("projects/%v/policies/iam.disableServiceAccountKeyUpload", name), nil
//				}).(pulumi.StringOutput),
//				Parent: basic.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("projects/%v", name), nil
//				}).(pulumi.StringOutput),
//				Spec: &orgpolicy.PolicySpecArgs{
//					Rules: orgpolicy.PolicySpecRuleArray{
//						&orgpolicy.PolicySpecRuleArgs{
//							Enforce: pulumi.String("FALSE"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Org Policy Policy Folder
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/orgpolicy"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basic, err := organizations.NewFolder(ctx, "basic", &organizations.FolderArgs{
//				Parent:             pulumi.String("organizations/123456789"),
//				DisplayName:        pulumi.String("folder"),
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = orgpolicy.NewPolicy(ctx, "primary", &orgpolicy.PolicyArgs{
//				Name: basic.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("%v/policies/gcp.resourceLocations", name), nil
//				}).(pulumi.StringOutput),
//				Parent: basic.Name,
//				Spec: &orgpolicy.PolicySpecArgs{
//					InheritFromParent: pulumi.Bool(true),
//					Rules: orgpolicy.PolicySpecRuleArray{
//						&orgpolicy.PolicySpecRuleArgs{
//							DenyAll: pulumi.String("TRUE"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Org Policy Policy Organization
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/orgpolicy"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := orgpolicy.NewPolicy(ctx, "primary", &orgpolicy.PolicyArgs{
//				Name:   pulumi.String("organizations/123456789/policies/gcp.detailedAuditLoggingMode"),
//				Parent: pulumi.String("organizations/123456789"),
//				Spec: &orgpolicy.PolicySpecArgs{
//					Reset: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Org Policy Policy Project
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/orgpolicy"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basic, err := organizations.NewProject(ctx, "basic", &organizations.ProjectArgs{
//				ProjectId:      pulumi.String("id"),
//				Name:           pulumi.String("id"),
//				OrgId:          pulumi.String("123456789"),
//				DeletionPolicy: pulumi.String("DELETE"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = orgpolicy.NewPolicy(ctx, "primary", &orgpolicy.PolicyArgs{
//				Name: basic.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("projects/%v/policies/gcp.resourceLocations", name), nil
//				}).(pulumi.StringOutput),
//				Parent: basic.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("projects/%v", name), nil
//				}).(pulumi.StringOutput),
//				Spec: &orgpolicy.PolicySpecArgs{
//					Rules: orgpolicy.PolicySpecRuleArray{
//						&orgpolicy.PolicySpecRuleArgs{
//							Condition: &orgpolicy.PolicySpecRuleConditionArgs{
//								Description: pulumi.String("A sample condition for the policy"),
//								Expression:  pulumi.String("resource.matchTagId('tagKeys/123', 'tagValues/345')"),
//								Location:    pulumi.String("sample-location.log"),
//								Title:       pulumi.String("sample-condition"),
//							},
//							Values: &orgpolicy.PolicySpecRuleValuesArgs{
//								AllowedValues: pulumi.StringArray{
//									pulumi.String("projects/allowed-project"),
//								},
//								DeniedValues: pulumi.StringArray{
//									pulumi.String("projects/denied-project"),
//								},
//							},
//						},
//						&orgpolicy.PolicySpecRuleArgs{
//							AllowAll: pulumi.String("TRUE"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Org Policy Policy Dry Run Spec
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/orgpolicy"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			constraint, err := orgpolicy.NewCustomConstraint(ctx, "constraint", &orgpolicy.CustomConstraintArgs{
//				Name:        pulumi.String("custom.disableGkeAutoUpgrade_13293"),
//				Parent:      pulumi.String("organizations/123456789"),
//				DisplayName: pulumi.String("Disable GKE auto upgrade"),
//				Description: pulumi.String("Only allow GKE NodePool resource to be created or updated if AutoUpgrade is not enabled where this custom constraint is enforced."),
//				ActionType:  pulumi.String("ALLOW"),
//				Condition:   pulumi.String("resource.management.autoUpgrade == false"),
//				MethodTypes: pulumi.StringArray{
//					pulumi.String("CREATE"),
//				},
//				ResourceTypes: pulumi.StringArray{
//					pulumi.String("container.googleapis.com/NodePool"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = orgpolicy.NewPolicy(ctx, "primary", &orgpolicy.PolicyArgs{
//				Name: constraint.Name.ApplyT(func(name string) (string, error) {
//					return fmt.Sprintf("organizations/123456789/policies/%v", name), nil
//				}).(pulumi.StringOutput),
//				Parent: pulumi.String("organizations/123456789"),
//				Spec: &orgpolicy.PolicySpecArgs{
//					Rules: orgpolicy.PolicySpecRuleArray{
//						&orgpolicy.PolicySpecRuleArgs{
//							Enforce: pulumi.String("FALSE"),
//						},
//					},
//				},
//				DryRunSpec: &orgpolicy.PolicyDryRunSpecArgs{
//					InheritFromParent: pulumi.Bool(false),
//					Reset:             pulumi.Bool(false),
//					Rules: orgpolicy.PolicyDryRunSpecRuleArray{
//						&orgpolicy.PolicyDryRunSpecRuleArgs{
//							Enforce: pulumi.String("FALSE"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Policy can be imported using any of these accepted formats:
//
// * `{{parent}}/policies/{{name}}`
//
// When using the `pulumi import` command, Policy can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:orgpolicy/policy:Policy default {{parent}}/policies/{{name}}
// ```
type Policy struct {
	pulumi.CustomResourceState

	// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
	// Structure is documented below.
	DryRunSpec PolicyDryRunSpecPtrOutput `pulumi:"dryRunSpec"`
	// Optional. An opaque tag indicating the current state of the policy, used for concurrency control. This 'etag' is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
	Name pulumi.StringOutput `pulumi:"name"`
	// The parent of the resource.
	//
	// ***
	Parent pulumi.StringOutput `pulumi:"parent"`
	// Basic information about the Organization Policy.
	// Structure is documented below.
	Spec PolicySpecPtrOutput `pulumi:"spec"`
}

// NewPolicy registers a new resource with the given unique name, arguments, and options.
func NewPolicy(ctx *pulumi.Context,
	name string, args *PolicyArgs, opts ...pulumi.ResourceOption) (*Policy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Parent == nil {
		return nil, errors.New("invalid value for required argument 'Parent'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Policy
	err := ctx.RegisterResource("gcp:orgpolicy/policy:Policy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicy gets an existing Policy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyState, opts ...pulumi.ResourceOption) (*Policy, error) {
	var resource Policy
	err := ctx.ReadResource("gcp:orgpolicy/policy:Policy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Policy resources.
type policyState struct {
	// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
	// Structure is documented below.
	DryRunSpec *PolicyDryRunSpec `pulumi:"dryRunSpec"`
	// Optional. An opaque tag indicating the current state of the policy, used for concurrency control. This 'etag' is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
	Etag *string `pulumi:"etag"`
	// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
	Name *string `pulumi:"name"`
	// The parent of the resource.
	//
	// ***
	Parent *string `pulumi:"parent"`
	// Basic information about the Organization Policy.
	// Structure is documented below.
	Spec *PolicySpec `pulumi:"spec"`
}

type PolicyState struct {
	// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
	// Structure is documented below.
	DryRunSpec PolicyDryRunSpecPtrInput
	// Optional. An opaque tag indicating the current state of the policy, used for concurrency control. This 'etag' is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
	Etag pulumi.StringPtrInput
	// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
	Name pulumi.StringPtrInput
	// The parent of the resource.
	//
	// ***
	Parent pulumi.StringPtrInput
	// Basic information about the Organization Policy.
	// Structure is documented below.
	Spec PolicySpecPtrInput
}

func (PolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyState)(nil)).Elem()
}

type policyArgs struct {
	// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
	// Structure is documented below.
	DryRunSpec *PolicyDryRunSpec `pulumi:"dryRunSpec"`
	// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
	Name *string `pulumi:"name"`
	// The parent of the resource.
	//
	// ***
	Parent string `pulumi:"parent"`
	// Basic information about the Organization Policy.
	// Structure is documented below.
	Spec *PolicySpec `pulumi:"spec"`
}

// The set of arguments for constructing a Policy resource.
type PolicyArgs struct {
	// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
	// Structure is documented below.
	DryRunSpec PolicyDryRunSpecPtrInput
	// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
	Name pulumi.StringPtrInput
	// The parent of the resource.
	//
	// ***
	Parent pulumi.StringInput
	// Basic information about the Organization Policy.
	// Structure is documented below.
	Spec PolicySpecPtrInput
}

func (PolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyArgs)(nil)).Elem()
}

type PolicyInput interface {
	pulumi.Input

	ToPolicyOutput() PolicyOutput
	ToPolicyOutputWithContext(ctx context.Context) PolicyOutput
}

func (*Policy) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (i *Policy) ToPolicyOutput() PolicyOutput {
	return i.ToPolicyOutputWithContext(context.Background())
}

func (i *Policy) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyOutput)
}

// PolicyArrayInput is an input type that accepts PolicyArray and PolicyArrayOutput values.
// You can construct a concrete instance of `PolicyArrayInput` via:
//
//	PolicyArray{ PolicyArgs{...} }
type PolicyArrayInput interface {
	pulumi.Input

	ToPolicyArrayOutput() PolicyArrayOutput
	ToPolicyArrayOutputWithContext(context.Context) PolicyArrayOutput
}

type PolicyArray []PolicyInput

func (PolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (i PolicyArray) ToPolicyArrayOutput() PolicyArrayOutput {
	return i.ToPolicyArrayOutputWithContext(context.Background())
}

func (i PolicyArray) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyArrayOutput)
}

// PolicyMapInput is an input type that accepts PolicyMap and PolicyMapOutput values.
// You can construct a concrete instance of `PolicyMapInput` via:
//
//	PolicyMap{ "key": PolicyArgs{...} }
type PolicyMapInput interface {
	pulumi.Input

	ToPolicyMapOutput() PolicyMapOutput
	ToPolicyMapOutputWithContext(context.Context) PolicyMapOutput
}

type PolicyMap map[string]PolicyInput

func (PolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (i PolicyMap) ToPolicyMapOutput() PolicyMapOutput {
	return i.ToPolicyMapOutputWithContext(context.Background())
}

func (i PolicyMap) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapOutput)
}

type PolicyOutput struct{ *pulumi.OutputState }

func (PolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (o PolicyOutput) ToPolicyOutput() PolicyOutput {
	return o
}

func (o PolicyOutput) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return o
}

// Dry-run policy. Audit-only policy, can be used to monitor how the policy would have impacted the existing and future resources if it's enforced.
// Structure is documented below.
func (o PolicyOutput) DryRunSpec() PolicyDryRunSpecPtrOutput {
	return o.ApplyT(func(v *Policy) PolicyDryRunSpecPtrOutput { return v.DryRunSpec }).(PolicyDryRunSpecPtrOutput)
}

// Optional. An opaque tag indicating the current state of the policy, used for concurrency control. This 'etag' is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
func (o PolicyOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

// Immutable. The resource name of the Policy. Must be one of the following forms, where constraintName is the name of the constraint which this Policy configures: * `projects/{project_number}/policies/{constraint_name}` * `folders/{folder_id}/policies/{constraint_name}` * `organizations/{organization_id}/policies/{constraint_name}` For example, "projects/123/policies/compute.disableSerialPortAccess". Note: `projects/{project_id}/policies/{constraint_name}` is also an acceptable name for API requests, but responses will return the name using the equivalent project number.
func (o PolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The parent of the resource.
//
// ***
func (o PolicyOutput) Parent() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Parent }).(pulumi.StringOutput)
}

// Basic information about the Organization Policy.
// Structure is documented below.
func (o PolicyOutput) Spec() PolicySpecPtrOutput {
	return o.ApplyT(func(v *Policy) PolicySpecPtrOutput { return v.Spec }).(PolicySpecPtrOutput)
}

type PolicyArrayOutput struct{ *pulumi.OutputState }

func (PolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (o PolicyArrayOutput) ToPolicyArrayOutput() PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) Index(i pulumi.IntInput) PolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].([]*Policy)[vs[1].(int)]
	}).(PolicyOutput)
}

type PolicyMapOutput struct{ *pulumi.OutputState }

func (PolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (o PolicyMapOutput) ToPolicyMapOutput() PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) MapIndex(k pulumi.StringInput) PolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].(map[string]*Policy)[vs[1].(string)]
	}).(PolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInput)(nil)).Elem(), &Policy{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyArrayInput)(nil)).Elem(), PolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapInput)(nil)).Elem(), PolicyMap{})
	pulumi.RegisterOutputType(PolicyOutput{})
	pulumi.RegisterOutputType(PolicyArrayOutput{})
	pulumi.RegisterOutputType(PolicyMapOutput{})
}
