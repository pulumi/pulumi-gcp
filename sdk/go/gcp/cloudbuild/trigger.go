// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudbuild

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Configuration for an automated build in response to source repository changes.
//
// To get more information about Trigger, see:
//
// * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers)
// * How-to Guides
//   - [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)
//
// > **Note:** You can retrieve the email of the Cloud Build Service Account used in jobs by using the `projects.ServiceIdentity` resource.
//
// ## Example Usage
//
// ### Cloudbuild Trigger Filename
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "filename-trigger", &cloudbuild.TriggerArgs{
//				Location: pulumi.String("us-central1"),
//				TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
//					BranchName: pulumi.String("main"),
//					RepoName:   pulumi.String("my-repo"),
//				},
//				Substitutions: pulumi.StringMap{
//					"_FOO": pulumi.String("bar"),
//					"_BAZ": pulumi.String("qux"),
//				},
//				Filename: pulumi.String("cloudbuild.yaml"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Build
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "build-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("my-trigger"),
//				Location: pulumi.String("global"),
//				TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
//					BranchName: pulumi.String("main"),
//					RepoName:   pulumi.String("my-repo"),
//				},
//				Build: &cloudbuild.TriggerBuildArgs{
//					Steps: cloudbuild.TriggerBuildStepArray{
//						&cloudbuild.TriggerBuildStepArgs{
//							Name: pulumi.String("gcr.io/cloud-builders/gsutil"),
//							Args: pulumi.StringArray{
//								pulumi.String("cp"),
//								pulumi.String("gs://mybucket/remotefile.zip"),
//								pulumi.String("localfile.zip"),
//							},
//							Timeout: pulumi.String("120s"),
//							SecretEnvs: pulumi.StringArray{
//								pulumi.String("MY_SECRET"),
//							},
//						},
//						&cloudbuild.TriggerBuildStepArgs{
//							Name:   pulumi.String("ubuntu"),
//							Script: pulumi.String("echo hello"),
//						},
//					},
//					Source: &cloudbuild.TriggerBuildSourceArgs{
//						StorageSource: &cloudbuild.TriggerBuildSourceStorageSourceArgs{
//							Bucket: pulumi.String("mybucket"),
//							Object: pulumi.String("source_code.tar.gz"),
//						},
//					},
//					Tags: pulumi.StringArray{
//						pulumi.String("build"),
//						pulumi.String("newFeature"),
//					},
//					Substitutions: pulumi.StringMap{
//						"_FOO": pulumi.String("bar"),
//						"_BAZ": pulumi.String("qux"),
//					},
//					QueueTtl:   pulumi.String("20s"),
//					LogsBucket: pulumi.String("gs://mybucket/logs"),
//					Secrets: cloudbuild.TriggerBuildSecretArray{
//						&cloudbuild.TriggerBuildSecretArgs{
//							KmsKeyName: pulumi.String("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name"),
//							SecretEnv: pulumi.StringMap{
//								"PASSWORD": pulumi.String("ZW5jcnlwdGVkLXBhc3N3b3JkCg=="),
//							},
//						},
//					},
//					AvailableSecrets: &cloudbuild.TriggerBuildAvailableSecretsArgs{
//						SecretManagers: cloudbuild.TriggerBuildAvailableSecretsSecretManagerArray{
//							&cloudbuild.TriggerBuildAvailableSecretsSecretManagerArgs{
//								Env:         pulumi.String("MY_SECRET"),
//								VersionName: pulumi.String("projects/myProject/secrets/mySecret/versions/latest"),
//							},
//						},
//					},
//					Artifacts: &cloudbuild.TriggerBuildArtifactsArgs{
//						Images: pulumi.StringArray{
//							pulumi.String("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA"),
//						},
//						Objects: &cloudbuild.TriggerBuildArtifactsObjectsArgs{
//							Location: pulumi.String("gs://bucket/path/to/somewhere/"),
//							Paths: pulumi.StringArray{
//								pulumi.String("path"),
//							},
//						},
//						NpmPackages: cloudbuild.TriggerBuildArtifactsNpmPackageArray{
//							&cloudbuild.TriggerBuildArtifactsNpmPackageArgs{
//								PackagePath: pulumi.String("package.json"),
//								Repository:  pulumi.String("https://us-west1-npm.pkg.dev/myProject/quickstart-nodejs-repo"),
//							},
//						},
//						PythonPackages: cloudbuild.TriggerBuildArtifactsPythonPackageArray{
//							&cloudbuild.TriggerBuildArtifactsPythonPackageArgs{
//								Paths: pulumi.StringArray{
//									pulumi.String("dist/*"),
//								},
//								Repository: pulumi.String("https://us-west1-python.pkg.dev/myProject/quickstart-python-repo"),
//							},
//						},
//						MavenArtifacts: cloudbuild.TriggerBuildArtifactsMavenArtifactArray{
//							&cloudbuild.TriggerBuildArtifactsMavenArtifactArgs{
//								Repository: pulumi.String("https://us-west1-maven.pkg.dev/myProject/quickstart-java-repo"),
//								Path:       pulumi.String("/workspace/my-app/target/my-app-1.0.SNAPSHOT.jar"),
//								ArtifactId: pulumi.String("my-app"),
//								GroupId:    pulumi.String("com.mycompany.app"),
//								Version:    pulumi.String("1.0"),
//							},
//						},
//					},
//					Options: &cloudbuild.TriggerBuildOptionsArgs{
//						SourceProvenanceHashes: pulumi.StringArray{
//							pulumi.String("MD5"),
//						},
//						RequestedVerifyOption: pulumi.String("VERIFIED"),
//						MachineType:           pulumi.String("N1_HIGHCPU_8"),
//						DiskSizeGb:            pulumi.Int(100),
//						SubstitutionOption:    pulumi.String("ALLOW_LOOSE"),
//						DynamicSubstitutions:  pulumi.Bool(true),
//						LogStreamingOption:    pulumi.String("STREAM_OFF"),
//						WorkerPool:            pulumi.String("pool"),
//						Logging:               pulumi.String("LEGACY"),
//						Envs: pulumi.StringArray{
//							pulumi.String("ekey = evalue"),
//						},
//						SecretEnvs: pulumi.StringArray{
//							pulumi.String("secretenv = svalue"),
//						},
//						Volumes: cloudbuild.TriggerBuildOptionsVolumeArray{
//							&cloudbuild.TriggerBuildOptionsVolumeArgs{
//								Name: pulumi.String("v1"),
//								Path: pulumi.String("v1"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Service Account
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/projects"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/serviceaccount"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			cloudbuildServiceAccount, err := serviceaccount.NewAccount(ctx, "cloudbuild_service_account", &serviceaccount.AccountArgs{
//				AccountId: pulumi.String("cloud-sa"),
//			})
//			if err != nil {
//				return err
//			}
//			actAs, err := projects.NewIAMMember(ctx, "act_as", &projects.IAMMemberArgs{
//				Project: pulumi.String(project.ProjectId),
//				Role:    pulumi.String("roles/iam.serviceAccountUser"),
//				Member: cloudbuildServiceAccount.Email.ApplyT(func(email string) (string, error) {
//					return fmt.Sprintf("serviceAccount:%v", email), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			logsWriter, err := projects.NewIAMMember(ctx, "logs_writer", &projects.IAMMemberArgs{
//				Project: pulumi.String(project.ProjectId),
//				Role:    pulumi.String("roles/logging.logWriter"),
//				Member: cloudbuildServiceAccount.Email.ApplyT(func(email string) (string, error) {
//					return fmt.Sprintf("serviceAccount:%v", email), nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cloudbuild.NewTrigger(ctx, "service-account-trigger", &cloudbuild.TriggerArgs{
//				TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
//					BranchName: pulumi.String("main"),
//					RepoName:   pulumi.String("my-repo"),
//				},
//				ServiceAccount: cloudbuildServiceAccount.ID(),
//				Filename:       pulumi.String("cloudbuild.yaml"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				actAs,
//				logsWriter,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Include Build Logs
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "include-build-logs-trigger", &cloudbuild.TriggerArgs{
//				Location: pulumi.String("us-central1"),
//				Name:     pulumi.String("include-build-logs-trigger"),
//				Filename: pulumi.String("cloudbuild.yaml"),
//				Github: &cloudbuild.TriggerGithubArgs{
//					Owner: pulumi.String("hashicorp"),
//					Name:  pulumi.String("terraform-provider-google-beta"),
//					Push: &cloudbuild.TriggerGithubPushArgs{
//						Branch: pulumi.String("^main$"),
//					},
//				},
//				IncludeBuildLogs: pulumi.String("INCLUDE_BUILD_LOGS_WITH_STATUS"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Pubsub Config
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/pubsub"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			mytopic, err := pubsub.NewTopic(ctx, "mytopic", &pubsub.TopicArgs{
//				Name: pulumi.String("my-topic"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cloudbuild.NewTrigger(ctx, "pubsub-config-trigger", &cloudbuild.TriggerArgs{
//				Location:    pulumi.String("us-central1"),
//				Name:        pulumi.String("pubsub-trigger"),
//				Description: pulumi.String("acceptance test example pubsub build trigger"),
//				PubsubConfig: &cloudbuild.TriggerPubsubConfigArgs{
//					Topic: mytopic.ID(),
//				},
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Ref:      pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:     pulumi.String("cloudbuild.yaml"),
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Revision: pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//				Substitutions: pulumi.StringMap{
//					"_ACTION": pulumi.String("$(body.message.data.action)"),
//				},
//				Filter: pulumi.String("_ACTION.matches('INSERT')"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Webhook Config
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			webhookTriggerSecretKey, err := secretmanager.NewSecret(ctx, "webhook_trigger_secret_key", &secretmanager.SecretArgs{
//				SecretId: pulumi.String("webhook-trigger-secret-key"),
//				Replication: &secretmanager.SecretReplicationArgs{
//					UserManaged: &secretmanager.SecretReplicationUserManagedArgs{
//						Replicas: secretmanager.SecretReplicationUserManagedReplicaArray{
//							&secretmanager.SecretReplicationUserManagedReplicaArgs{
//								Location: pulumi.String("us-central1"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			webhookTriggerSecretKeyData, err := secretmanager.NewSecretVersion(ctx, "webhook_trigger_secret_key_data", &secretmanager.SecretVersionArgs{
//				Secret:     webhookTriggerSecretKey.ID(),
//				SecretData: pulumi.String("secretkeygoeshere"),
//			})
//			if err != nil {
//				return err
//			}
//			project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			secretAccessor, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
//				Bindings: []organizations.GetIAMPolicyBinding{
//					{
//						Role: "roles/secretmanager.secretAccessor",
//						Members: []string{
//							fmt.Sprintf("serviceAccount:service-%v@gcp-sa-cloudbuild.iam.gserviceaccount.com", project.Number),
//						},
//					},
//				},
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = secretmanager.NewSecretIamPolicy(ctx, "policy", &secretmanager.SecretIamPolicyArgs{
//				Project:    webhookTriggerSecretKey.Project,
//				SecretId:   webhookTriggerSecretKey.SecretId,
//				PolicyData: pulumi.String(secretAccessor.PolicyData),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cloudbuild.NewTrigger(ctx, "webhook-config-trigger", &cloudbuild.TriggerArgs{
//				Name:        pulumi.String("webhook-trigger"),
//				Description: pulumi.String("acceptance test example webhook build trigger"),
//				WebhookConfig: &cloudbuild.TriggerWebhookConfigArgs{
//					Secret: webhookTriggerSecretKeyData.ID(),
//				},
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Ref:      pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:     pulumi.String("cloudbuild.yaml"),
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Revision: pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Manual
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "manual-trigger", &cloudbuild.TriggerArgs{
//				Name: pulumi.String("manual-trigger"),
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Ref:      pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:     pulumi.String("cloudbuild.yaml"),
//					Uri:      pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Revision: pulumi.String("refs/heads/main"),
//					RepoType: pulumi.String("GITHUB"),
//				},
//				ApprovalConfig: &cloudbuild.TriggerApprovalConfigArgs{
//					ApprovalRequired: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Manual Github Enterprise
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "manual-ghe-trigger", &cloudbuild.TriggerArgs{
//				Name: pulumi.String(""),
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Uri:                    pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Ref:                    pulumi.String("refs/heads/main"),
//					RepoType:               pulumi.String("GITHUB"),
//					GithubEnterpriseConfig: pulumi.String("projects/myProject/locations/global/githubEnterpriseConfigs/configID"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:                   pulumi.String("cloudbuild.yaml"),
//					Uri:                    pulumi.String("https://hashicorp/terraform-provider-google-beta"),
//					Revision:               pulumi.String("refs/heads/main"),
//					RepoType:               pulumi.String("GITHUB"),
//					GithubEnterpriseConfig: pulumi.String("projects/myProject/locations/global/githubEnterpriseConfigs/configID"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Manual Bitbucket Server
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "manual-bitbucket-trigger", &cloudbuild.TriggerArgs{
//				Name: pulumi.String("terraform-manual-bbs-trigger"),
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Uri:                   pulumi.String("https://bbs.com/scm/stag/test-repo.git"),
//					Ref:                   pulumi.String("refs/heads/main"),
//					RepoType:              pulumi.String("BITBUCKET_SERVER"),
//					BitbucketServerConfig: pulumi.String("projects/myProject/locations/global/bitbucketServerConfigs/configID"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:                  pulumi.String("cloudbuild.yaml"),
//					Uri:                   pulumi.String("https://bbs.com/scm/stag/test-repo.git"),
//					Revision:              pulumi.String("refs/heads/main"),
//					RepoType:              pulumi.String("BITBUCKET_SERVER"),
//					BitbucketServerConfig: pulumi.String("projects/myProject/locations/global/bitbucketServerConfigs/configID"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Repo
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuildv2"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			my_connection, err := cloudbuildv2.NewConnection(ctx, "my-connection", &cloudbuildv2.ConnectionArgs{
//				Location: pulumi.String("us-central1"),
//				Name:     pulumi.String("my-connection"),
//				GithubConfig: &cloudbuildv2.ConnectionGithubConfigArgs{
//					AppInstallationId: pulumi.Int(123123),
//					AuthorizerCredential: &cloudbuildv2.ConnectionGithubConfigAuthorizerCredentialArgs{
//						OauthTokenSecretVersion: pulumi.String("projects/my-project/secrets/github-pat-secret/versions/latest"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			my_repository, err := cloudbuildv2.NewRepository(ctx, "my-repository", &cloudbuildv2.RepositoryArgs{
//				Name:             pulumi.String("my-repo"),
//				ParentConnection: my_connection.ID(),
//				RemoteUri:        pulumi.String("https://github.com/myuser/my-repo.git"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cloudbuild.NewTrigger(ctx, "repo-trigger", &cloudbuild.TriggerArgs{
//				Location: pulumi.String("us-central1"),
//				RepositoryEventConfig: &cloudbuild.TriggerRepositoryEventConfigArgs{
//					Repository: my_repository.ID(),
//					Push: &cloudbuild.TriggerRepositoryEventConfigPushArgs{
//						Branch: pulumi.String("feature-.*"),
//					},
//				},
//				Filename: pulumi.String("cloudbuild.yaml"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Bitbucket Server Push
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "bbs-push-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("bbs-push-trigger"),
//				Location: pulumi.String("us-central1"),
//				BitbucketServerTriggerConfig: &cloudbuild.TriggerBitbucketServerTriggerConfigArgs{
//					RepoSlug:                      pulumi.String("bbs-push-trigger"),
//					ProjectKey:                    pulumi.String("STAG"),
//					BitbucketServerConfigResource: pulumi.String("projects/123456789/locations/us-central1/bitbucketServerConfigs/myBitbucketConfig"),
//					Push: &cloudbuild.TriggerBitbucketServerTriggerConfigPushArgs{
//						Tag:         pulumi.String("^0.1.*"),
//						InvertRegex: pulumi.Bool(true),
//					},
//				},
//				Filename: pulumi.String("cloudbuild.yaml"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Bitbucket Server Pull Request
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "bbs-pull-request-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("ghe-trigger"),
//				Location: pulumi.String("us-central1"),
//				BitbucketServerTriggerConfig: &cloudbuild.TriggerBitbucketServerTriggerConfigArgs{
//					RepoSlug:                      pulumi.String("terraform-provider-google"),
//					ProjectKey:                    pulumi.String("STAG"),
//					BitbucketServerConfigResource: pulumi.String("projects/123456789/locations/us-central1/bitbucketServerConfigs/myBitbucketConfig"),
//					PullRequest: &cloudbuild.TriggerBitbucketServerTriggerConfigPullRequestArgs{
//						Branch:         pulumi.String("^master$"),
//						InvertRegex:    pulumi.Bool(false),
//						CommentControl: pulumi.String("COMMENTS_ENABLED"),
//					},
//				},
//				Filename: pulumi.String("cloudbuild.yaml"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Github Enterprise
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "ghe-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("ghe-trigger"),
//				Location: pulumi.String("us-central1"),
//				Github: &cloudbuild.TriggerGithubArgs{
//					Owner: pulumi.String("hashicorp"),
//					Name:  pulumi.String("terraform-provider-google"),
//					Push: &cloudbuild.TriggerGithubPushArgs{
//						Branch: pulumi.String("^main$"),
//					},
//					EnterpriseConfigResourceName: pulumi.String("projects/123456789/locations/us-central1/githubEnterpriseConfigs/configID"),
//				},
//				Filename: pulumi.String("cloudbuild.yaml"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Allow Failure
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "allow-failure-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("my-trigger"),
//				Location: pulumi.String("global"),
//				TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
//					BranchName: pulumi.String("main"),
//					RepoName:   pulumi.String("my-repo"),
//				},
//				Build: &cloudbuild.TriggerBuildArgs{
//					Steps: cloudbuild.TriggerBuildStepArray{
//						&cloudbuild.TriggerBuildStepArgs{
//							Name: pulumi.String("ubuntu"),
//							Args: pulumi.StringArray{
//								pulumi.String("-c"),
//								pulumi.String("exit 1"),
//							},
//							AllowFailure: pulumi.Bool(true),
//						},
//					},
//					Source: &cloudbuild.TriggerBuildSourceArgs{
//						StorageSource: &cloudbuild.TriggerBuildSourceStorageSourceArgs{
//							Bucket: pulumi.String("mybucket"),
//							Object: pulumi.String("source_code.tar.gz"),
//						},
//					},
//					Tags: pulumi.StringArray{
//						pulumi.String("build"),
//						pulumi.String("newFeature"),
//					},
//					Substitutions: pulumi.StringMap{
//						"_FOO": pulumi.String("bar"),
//						"_BAZ": pulumi.String("qux"),
//					},
//					QueueTtl:   pulumi.String("20s"),
//					LogsBucket: pulumi.String("gs://mybucket/logs"),
//					Secrets: cloudbuild.TriggerBuildSecretArray{
//						&cloudbuild.TriggerBuildSecretArgs{
//							KmsKeyName: pulumi.String("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name"),
//							SecretEnv: pulumi.StringMap{
//								"PASSWORD": pulumi.String("ZW5jcnlwdGVkLXBhc3N3b3JkCg=="),
//							},
//						},
//					},
//					AvailableSecrets: &cloudbuild.TriggerBuildAvailableSecretsArgs{
//						SecretManagers: cloudbuild.TriggerBuildAvailableSecretsSecretManagerArray{
//							&cloudbuild.TriggerBuildAvailableSecretsSecretManagerArgs{
//								Env:         pulumi.String("MY_SECRET"),
//								VersionName: pulumi.String("projects/myProject/secrets/mySecret/versions/latest"),
//							},
//						},
//					},
//					Artifacts: &cloudbuild.TriggerBuildArtifactsArgs{
//						Images: pulumi.StringArray{
//							pulumi.String("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA"),
//						},
//						Objects: &cloudbuild.TriggerBuildArtifactsObjectsArgs{
//							Location: pulumi.String("gs://bucket/path/to/somewhere/"),
//							Paths: pulumi.StringArray{
//								pulumi.String("path"),
//							},
//						},
//					},
//					Options: &cloudbuild.TriggerBuildOptionsArgs{
//						SourceProvenanceHashes: pulumi.StringArray{
//							pulumi.String("MD5"),
//						},
//						RequestedVerifyOption: pulumi.String("VERIFIED"),
//						MachineType:           pulumi.String("N1_HIGHCPU_8"),
//						DiskSizeGb:            pulumi.Int(100),
//						SubstitutionOption:    pulumi.String("ALLOW_LOOSE"),
//						DynamicSubstitutions:  pulumi.Bool(true),
//						LogStreamingOption:    pulumi.String("STREAM_OFF"),
//						WorkerPool:            pulumi.String("pool"),
//						Logging:               pulumi.String("LEGACY"),
//						Envs: pulumi.StringArray{
//							pulumi.String("ekey = evalue"),
//						},
//						SecretEnvs: pulumi.StringArray{
//							pulumi.String("secretenv = svalue"),
//						},
//						Volumes: cloudbuild.TriggerBuildOptionsVolumeArray{
//							&cloudbuild.TriggerBuildOptionsVolumeArgs{
//								Name: pulumi.String("v1"),
//								Path: pulumi.String("v1"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Allow Exit Codes
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudbuild.NewTrigger(ctx, "allow-exit-codes-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("my-trigger"),
//				Location: pulumi.String("global"),
//				TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
//					BranchName: pulumi.String("main"),
//					RepoName:   pulumi.String("my-repo"),
//				},
//				Build: &cloudbuild.TriggerBuildArgs{
//					Steps: cloudbuild.TriggerBuildStepArray{
//						&cloudbuild.TriggerBuildStepArgs{
//							Name: pulumi.String("ubuntu"),
//							Args: pulumi.StringArray{
//								pulumi.String("-c"),
//								pulumi.String("exit 1"),
//							},
//							AllowExitCodes: pulumi.IntArray{
//								pulumi.Int(1),
//								pulumi.Int(3),
//							},
//						},
//					},
//					Source: &cloudbuild.TriggerBuildSourceArgs{
//						StorageSource: &cloudbuild.TriggerBuildSourceStorageSourceArgs{
//							Bucket: pulumi.String("mybucket"),
//							Object: pulumi.String("source_code.tar.gz"),
//						},
//					},
//					Tags: pulumi.StringArray{
//						pulumi.String("build"),
//						pulumi.String("newFeature"),
//					},
//					Substitutions: pulumi.StringMap{
//						"_FOO": pulumi.String("bar"),
//						"_BAZ": pulumi.String("qux"),
//					},
//					QueueTtl:   pulumi.String("20s"),
//					LogsBucket: pulumi.String("gs://mybucket/logs"),
//					Secrets: cloudbuild.TriggerBuildSecretArray{
//						&cloudbuild.TriggerBuildSecretArgs{
//							KmsKeyName: pulumi.String("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name"),
//							SecretEnv: pulumi.StringMap{
//								"PASSWORD": pulumi.String("ZW5jcnlwdGVkLXBhc3N3b3JkCg=="),
//							},
//						},
//					},
//					AvailableSecrets: &cloudbuild.TriggerBuildAvailableSecretsArgs{
//						SecretManagers: cloudbuild.TriggerBuildAvailableSecretsSecretManagerArray{
//							&cloudbuild.TriggerBuildAvailableSecretsSecretManagerArgs{
//								Env:         pulumi.String("MY_SECRET"),
//								VersionName: pulumi.String("projects/myProject/secrets/mySecret/versions/latest"),
//							},
//						},
//					},
//					Artifacts: &cloudbuild.TriggerBuildArtifactsArgs{
//						Images: pulumi.StringArray{
//							pulumi.String("gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA"),
//						},
//						Objects: &cloudbuild.TriggerBuildArtifactsObjectsArgs{
//							Location: pulumi.String("gs://bucket/path/to/somewhere/"),
//							Paths: pulumi.StringArray{
//								pulumi.String("path"),
//							},
//						},
//					},
//					Options: &cloudbuild.TriggerBuildOptionsArgs{
//						SourceProvenanceHashes: pulumi.StringArray{
//							pulumi.String("MD5"),
//						},
//						RequestedVerifyOption: pulumi.String("VERIFIED"),
//						MachineType:           pulumi.String("N1_HIGHCPU_8"),
//						DiskSizeGb:            pulumi.Int(100),
//						SubstitutionOption:    pulumi.String("ALLOW_LOOSE"),
//						DynamicSubstitutions:  pulumi.Bool(true),
//						LogStreamingOption:    pulumi.String("STREAM_OFF"),
//						WorkerPool:            pulumi.String("pool"),
//						Logging:               pulumi.String("LEGACY"),
//						Envs: pulumi.StringArray{
//							pulumi.String("ekey = evalue"),
//						},
//						SecretEnvs: pulumi.StringArray{
//							pulumi.String("secretenv = svalue"),
//						},
//						Volumes: cloudbuild.TriggerBuildOptionsVolumeArray{
//							&cloudbuild.TriggerBuildOptionsVolumeArgs{
//								Name: pulumi.String("v1"),
//								Path: pulumi.String("v1"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Cloudbuild Trigger Pubsub With Repo
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuild"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudbuildv2"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/pubsub"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			my_connection, err := cloudbuildv2.NewConnection(ctx, "my-connection", &cloudbuildv2.ConnectionArgs{
//				Location: pulumi.String("us-central1"),
//				Name:     pulumi.String("my-connection"),
//				GithubConfig: &cloudbuildv2.ConnectionGithubConfigArgs{
//					AppInstallationId: pulumi.Int(123123),
//					AuthorizerCredential: &cloudbuildv2.ConnectionGithubConfigAuthorizerCredentialArgs{
//						OauthTokenSecretVersion: pulumi.String("projects/my-project/secrets/github-pat-secret/versions/latest"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			my_repository, err := cloudbuildv2.NewRepository(ctx, "my-repository", &cloudbuildv2.RepositoryArgs{
//				Name:             pulumi.String("my-repo"),
//				ParentConnection: my_connection.ID(),
//				RemoteUri:        pulumi.String("https://github.com/myuser/my-repo.git"),
//			})
//			if err != nil {
//				return err
//			}
//			mytopic, err := pubsub.NewTopic(ctx, "mytopic", &pubsub.TopicArgs{
//				Name: pulumi.String("my-topic"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = cloudbuild.NewTrigger(ctx, "pubsub-with-repo-trigger", &cloudbuild.TriggerArgs{
//				Name:     pulumi.String("pubsub-with-repo-trigger"),
//				Location: pulumi.String("us-central1"),
//				PubsubConfig: &cloudbuild.TriggerPubsubConfigArgs{
//					Topic: mytopic.ID(),
//				},
//				SourceToBuild: &cloudbuild.TriggerSourceToBuildArgs{
//					Repository: my_repository.ID(),
//					Ref:        pulumi.String("refs/heads/main"),
//					RepoType:   pulumi.String("GITHUB"),
//				},
//				GitFileSource: &cloudbuild.TriggerGitFileSourceArgs{
//					Path:       pulumi.String("cloudbuild.yaml"),
//					Repository: my_repository.ID(),
//					Revision:   pulumi.String("refs/heads/main"),
//					RepoType:   pulumi.String("GITHUB"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Trigger can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}`
//
// * `projects/{{project}}/triggers/{{trigger_id}}`
//
// * `{{project}}/{{trigger_id}}`
//
// * `{{trigger_id}}`
//
// When using the `pulumi import` command, Trigger can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/locations/{{location}}/triggers/{{trigger_id}}
// ```
//
// ```sh
// $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/triggers/{{trigger_id}}
// ```
//
// ```sh
// $ pulumi import gcp:cloudbuild/trigger:Trigger default {{project}}/{{trigger_id}}
// ```
//
// ```sh
// $ pulumi import gcp:cloudbuild/trigger:Trigger default {{trigger_id}}
// ```
type Trigger struct {
	pulumi.CustomResourceState

	// Configuration for manual approval to start a build invocation of this BuildTrigger.
	// Builds created by this trigger will require approval before they execute.
	// Any user with a Cloud Build Approver role for the project can approve a build.
	// Structure is documented below.
	ApprovalConfig TriggerApprovalConfigOutput `pulumi:"approvalConfig"`
	// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
	// Structure is documented below.
	BitbucketServerTriggerConfig TriggerBitbucketServerTriggerConfigPtrOutput `pulumi:"bitbucketServerTriggerConfig"`
	// Contents of the build template. Either a filename or build template must be provided.
	// Structure is documented below.
	Build TriggerBuildPtrOutput `pulumi:"build"`
	// Time when the trigger was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// Human-readable description of the trigger.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled pulumi.BoolPtrOutput `pulumi:"disabled"`
	// Path, from the source root, to a file whose contents is used for the template.
	// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
	// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
	Filename pulumi.StringPtrOutput `pulumi:"filename"`
	// A Common Expression Language string. Used only with Pub/Sub and Webhook.
	Filter pulumi.StringPtrOutput `pulumi:"filter"`
	// The file source describing the local or remote Build template.
	// Structure is documented below.
	GitFileSource TriggerGitFileSourcePtrOutput `pulumi:"gitFileSource"`
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
	// Structure is documented below.
	Github TriggerGithubPtrOutput `pulumi:"github"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If ignoredFiles and changed files are both empty, then they are not
	// used to determine whether or not to trigger a build.
	// If ignoredFiles is not empty, then we ignore any files that match any
	// of the ignoredFile globs. If the change has no files that are outside
	// of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles pulumi.StringArrayOutput `pulumi:"ignoredFiles"`
	// Build logs will be sent back to GitHub as part of the checkrun
	// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
	// INCLUDE_BUILD_LOGS_WITH_STATUS
	// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
	IncludeBuildLogs pulumi.StringPtrOutput `pulumi:"includeBuildLogs"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is empty, then as far as this filter is concerned, we
	// should trigger the build.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is not empty, then we make sure that at least one of
	// those files matches a includedFiles glob. If not, then we do not trigger
	// a build.
	IncludedFiles pulumi.StringArrayOutput `pulumi:"includedFiles"`
	// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
	// If not specified, "global" is used.
	Location pulumi.StringPtrOutput `pulumi:"location"`
	// Name of the trigger. Must be unique within the project.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// PubsubConfig describes the configuration of a trigger that creates
	// a build whenever a Pub/Sub message is published.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	PubsubConfig TriggerPubsubConfigPtrOutput `pulumi:"pubsubConfig"`
	// The configuration of a trigger that creates a build whenever an event from Repo API is received.
	// Structure is documented below.
	RepositoryEventConfig TriggerRepositoryEventConfigPtrOutput `pulumi:"repositoryEventConfig"`
	// The service account used for all user-controlled operations including
	// triggers.patch, triggers.run, builds.create, and builds.cancel.
	// If no service account is set, then the standard Cloud Build service account
	// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
	// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
	ServiceAccount pulumi.StringPtrOutput `pulumi:"serviceAccount"`
	// The repo and ref of the repository from which to build.
	// This field is used only for those triggers that do not respond to SCM events.
	// Triggers that respond to such events build source at whatever commit caused the event.
	// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	SourceToBuild TriggerSourceToBuildPtrOutput `pulumi:"sourceToBuild"`
	// Substitutions data for Build resource.
	Substitutions pulumi.StringMapOutput `pulumi:"substitutions"`
	// Tags for annotation of a BuildTrigger
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The unique identifier for the trigger.
	TriggerId pulumi.StringOutput `pulumi:"triggerId"`
	// Template describing the types of source changes to trigger a build.
	// Branch and tag names in trigger templates are interpreted as regular
	// expressions. Any branch or tag change that matches that regular
	// expression will trigger a build.
	// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	TriggerTemplate TriggerTriggerTemplatePtrOutput `pulumi:"triggerTemplate"`
	// WebhookConfig describes the configuration of a trigger that creates
	// a build whenever a webhook is sent to a trigger's webhook URL.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	WebhookConfig TriggerWebhookConfigPtrOutput `pulumi:"webhookConfig"`
}

// NewTrigger registers a new resource with the given unique name, arguments, and options.
func NewTrigger(ctx *pulumi.Context,
	name string, args *TriggerArgs, opts ...pulumi.ResourceOption) (*Trigger, error) {
	if args == nil {
		args = &TriggerArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Trigger
	err := ctx.RegisterResource("gcp:cloudbuild/trigger:Trigger", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTrigger gets an existing Trigger resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTrigger(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TriggerState, opts ...pulumi.ResourceOption) (*Trigger, error) {
	var resource Trigger
	err := ctx.ReadResource("gcp:cloudbuild/trigger:Trigger", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Trigger resources.
type triggerState struct {
	// Configuration for manual approval to start a build invocation of this BuildTrigger.
	// Builds created by this trigger will require approval before they execute.
	// Any user with a Cloud Build Approver role for the project can approve a build.
	// Structure is documented below.
	ApprovalConfig *TriggerApprovalConfig `pulumi:"approvalConfig"`
	// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
	// Structure is documented below.
	BitbucketServerTriggerConfig *TriggerBitbucketServerTriggerConfig `pulumi:"bitbucketServerTriggerConfig"`
	// Contents of the build template. Either a filename or build template must be provided.
	// Structure is documented below.
	Build *TriggerBuild `pulumi:"build"`
	// Time when the trigger was created.
	CreateTime *string `pulumi:"createTime"`
	// Human-readable description of the trigger.
	Description *string `pulumi:"description"`
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled *bool `pulumi:"disabled"`
	// Path, from the source root, to a file whose contents is used for the template.
	// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
	// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
	Filename *string `pulumi:"filename"`
	// A Common Expression Language string. Used only with Pub/Sub and Webhook.
	Filter *string `pulumi:"filter"`
	// The file source describing the local or remote Build template.
	// Structure is documented below.
	GitFileSource *TriggerGitFileSource `pulumi:"gitFileSource"`
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
	// Structure is documented below.
	Github *TriggerGithub `pulumi:"github"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If ignoredFiles and changed files are both empty, then they are not
	// used to determine whether or not to trigger a build.
	// If ignoredFiles is not empty, then we ignore any files that match any
	// of the ignoredFile globs. If the change has no files that are outside
	// of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles []string `pulumi:"ignoredFiles"`
	// Build logs will be sent back to GitHub as part of the checkrun
	// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
	// INCLUDE_BUILD_LOGS_WITH_STATUS
	// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
	IncludeBuildLogs *string `pulumi:"includeBuildLogs"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is empty, then as far as this filter is concerned, we
	// should trigger the build.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is not empty, then we make sure that at least one of
	// those files matches a includedFiles glob. If not, then we do not trigger
	// a build.
	IncludedFiles []string `pulumi:"includedFiles"`
	// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
	// If not specified, "global" is used.
	Location *string `pulumi:"location"`
	// Name of the trigger. Must be unique within the project.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// PubsubConfig describes the configuration of a trigger that creates
	// a build whenever a Pub/Sub message is published.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	PubsubConfig *TriggerPubsubConfig `pulumi:"pubsubConfig"`
	// The configuration of a trigger that creates a build whenever an event from Repo API is received.
	// Structure is documented below.
	RepositoryEventConfig *TriggerRepositoryEventConfig `pulumi:"repositoryEventConfig"`
	// The service account used for all user-controlled operations including
	// triggers.patch, triggers.run, builds.create, and builds.cancel.
	// If no service account is set, then the standard Cloud Build service account
	// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
	// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
	ServiceAccount *string `pulumi:"serviceAccount"`
	// The repo and ref of the repository from which to build.
	// This field is used only for those triggers that do not respond to SCM events.
	// Triggers that respond to such events build source at whatever commit caused the event.
	// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	SourceToBuild *TriggerSourceToBuild `pulumi:"sourceToBuild"`
	// Substitutions data for Build resource.
	Substitutions map[string]string `pulumi:"substitutions"`
	// Tags for annotation of a BuildTrigger
	Tags []string `pulumi:"tags"`
	// The unique identifier for the trigger.
	TriggerId *string `pulumi:"triggerId"`
	// Template describing the types of source changes to trigger a build.
	// Branch and tag names in trigger templates are interpreted as regular
	// expressions. Any branch or tag change that matches that regular
	// expression will trigger a build.
	// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	TriggerTemplate *TriggerTriggerTemplate `pulumi:"triggerTemplate"`
	// WebhookConfig describes the configuration of a trigger that creates
	// a build whenever a webhook is sent to a trigger's webhook URL.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	WebhookConfig *TriggerWebhookConfig `pulumi:"webhookConfig"`
}

type TriggerState struct {
	// Configuration for manual approval to start a build invocation of this BuildTrigger.
	// Builds created by this trigger will require approval before they execute.
	// Any user with a Cloud Build Approver role for the project can approve a build.
	// Structure is documented below.
	ApprovalConfig TriggerApprovalConfigPtrInput
	// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
	// Structure is documented below.
	BitbucketServerTriggerConfig TriggerBitbucketServerTriggerConfigPtrInput
	// Contents of the build template. Either a filename or build template must be provided.
	// Structure is documented below.
	Build TriggerBuildPtrInput
	// Time when the trigger was created.
	CreateTime pulumi.StringPtrInput
	// Human-readable description of the trigger.
	Description pulumi.StringPtrInput
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled pulumi.BoolPtrInput
	// Path, from the source root, to a file whose contents is used for the template.
	// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
	// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
	Filename pulumi.StringPtrInput
	// A Common Expression Language string. Used only with Pub/Sub and Webhook.
	Filter pulumi.StringPtrInput
	// The file source describing the local or remote Build template.
	// Structure is documented below.
	GitFileSource TriggerGitFileSourcePtrInput
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
	// Structure is documented below.
	Github TriggerGithubPtrInput
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If ignoredFiles and changed files are both empty, then they are not
	// used to determine whether or not to trigger a build.
	// If ignoredFiles is not empty, then we ignore any files that match any
	// of the ignoredFile globs. If the change has no files that are outside
	// of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles pulumi.StringArrayInput
	// Build logs will be sent back to GitHub as part of the checkrun
	// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
	// INCLUDE_BUILD_LOGS_WITH_STATUS
	// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
	IncludeBuildLogs pulumi.StringPtrInput
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is empty, then as far as this filter is concerned, we
	// should trigger the build.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is not empty, then we make sure that at least one of
	// those files matches a includedFiles glob. If not, then we do not trigger
	// a build.
	IncludedFiles pulumi.StringArrayInput
	// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
	// If not specified, "global" is used.
	Location pulumi.StringPtrInput
	// Name of the trigger. Must be unique within the project.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// PubsubConfig describes the configuration of a trigger that creates
	// a build whenever a Pub/Sub message is published.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	PubsubConfig TriggerPubsubConfigPtrInput
	// The configuration of a trigger that creates a build whenever an event from Repo API is received.
	// Structure is documented below.
	RepositoryEventConfig TriggerRepositoryEventConfigPtrInput
	// The service account used for all user-controlled operations including
	// triggers.patch, triggers.run, builds.create, and builds.cancel.
	// If no service account is set, then the standard Cloud Build service account
	// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
	// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
	ServiceAccount pulumi.StringPtrInput
	// The repo and ref of the repository from which to build.
	// This field is used only for those triggers that do not respond to SCM events.
	// Triggers that respond to such events build source at whatever commit caused the event.
	// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	SourceToBuild TriggerSourceToBuildPtrInput
	// Substitutions data for Build resource.
	Substitutions pulumi.StringMapInput
	// Tags for annotation of a BuildTrigger
	Tags pulumi.StringArrayInput
	// The unique identifier for the trigger.
	TriggerId pulumi.StringPtrInput
	// Template describing the types of source changes to trigger a build.
	// Branch and tag names in trigger templates are interpreted as regular
	// expressions. Any branch or tag change that matches that regular
	// expression will trigger a build.
	// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	TriggerTemplate TriggerTriggerTemplatePtrInput
	// WebhookConfig describes the configuration of a trigger that creates
	// a build whenever a webhook is sent to a trigger's webhook URL.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	WebhookConfig TriggerWebhookConfigPtrInput
}

func (TriggerState) ElementType() reflect.Type {
	return reflect.TypeOf((*triggerState)(nil)).Elem()
}

type triggerArgs struct {
	// Configuration for manual approval to start a build invocation of this BuildTrigger.
	// Builds created by this trigger will require approval before they execute.
	// Any user with a Cloud Build Approver role for the project can approve a build.
	// Structure is documented below.
	ApprovalConfig *TriggerApprovalConfig `pulumi:"approvalConfig"`
	// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
	// Structure is documented below.
	BitbucketServerTriggerConfig *TriggerBitbucketServerTriggerConfig `pulumi:"bitbucketServerTriggerConfig"`
	// Contents of the build template. Either a filename or build template must be provided.
	// Structure is documented below.
	Build *TriggerBuild `pulumi:"build"`
	// Human-readable description of the trigger.
	Description *string `pulumi:"description"`
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled *bool `pulumi:"disabled"`
	// Path, from the source root, to a file whose contents is used for the template.
	// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
	// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
	Filename *string `pulumi:"filename"`
	// A Common Expression Language string. Used only with Pub/Sub and Webhook.
	Filter *string `pulumi:"filter"`
	// The file source describing the local or remote Build template.
	// Structure is documented below.
	GitFileSource *TriggerGitFileSource `pulumi:"gitFileSource"`
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
	// Structure is documented below.
	Github *TriggerGithub `pulumi:"github"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If ignoredFiles and changed files are both empty, then they are not
	// used to determine whether or not to trigger a build.
	// If ignoredFiles is not empty, then we ignore any files that match any
	// of the ignoredFile globs. If the change has no files that are outside
	// of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles []string `pulumi:"ignoredFiles"`
	// Build logs will be sent back to GitHub as part of the checkrun
	// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
	// INCLUDE_BUILD_LOGS_WITH_STATUS
	// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
	IncludeBuildLogs *string `pulumi:"includeBuildLogs"`
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is empty, then as far as this filter is concerned, we
	// should trigger the build.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is not empty, then we make sure that at least one of
	// those files matches a includedFiles glob. If not, then we do not trigger
	// a build.
	IncludedFiles []string `pulumi:"includedFiles"`
	// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
	// If not specified, "global" is used.
	Location *string `pulumi:"location"`
	// Name of the trigger. Must be unique within the project.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// PubsubConfig describes the configuration of a trigger that creates
	// a build whenever a Pub/Sub message is published.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	PubsubConfig *TriggerPubsubConfig `pulumi:"pubsubConfig"`
	// The configuration of a trigger that creates a build whenever an event from Repo API is received.
	// Structure is documented below.
	RepositoryEventConfig *TriggerRepositoryEventConfig `pulumi:"repositoryEventConfig"`
	// The service account used for all user-controlled operations including
	// triggers.patch, triggers.run, builds.create, and builds.cancel.
	// If no service account is set, then the standard Cloud Build service account
	// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
	// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
	ServiceAccount *string `pulumi:"serviceAccount"`
	// The repo and ref of the repository from which to build.
	// This field is used only for those triggers that do not respond to SCM events.
	// Triggers that respond to such events build source at whatever commit caused the event.
	// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	SourceToBuild *TriggerSourceToBuild `pulumi:"sourceToBuild"`
	// Substitutions data for Build resource.
	Substitutions map[string]string `pulumi:"substitutions"`
	// Tags for annotation of a BuildTrigger
	Tags []string `pulumi:"tags"`
	// Template describing the types of source changes to trigger a build.
	// Branch and tag names in trigger templates are interpreted as regular
	// expressions. Any branch or tag change that matches that regular
	// expression will trigger a build.
	// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	TriggerTemplate *TriggerTriggerTemplate `pulumi:"triggerTemplate"`
	// WebhookConfig describes the configuration of a trigger that creates
	// a build whenever a webhook is sent to a trigger's webhook URL.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	WebhookConfig *TriggerWebhookConfig `pulumi:"webhookConfig"`
}

// The set of arguments for constructing a Trigger resource.
type TriggerArgs struct {
	// Configuration for manual approval to start a build invocation of this BuildTrigger.
	// Builds created by this trigger will require approval before they execute.
	// Any user with a Cloud Build Approver role for the project can approve a build.
	// Structure is documented below.
	ApprovalConfig TriggerApprovalConfigPtrInput
	// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
	// Structure is documented below.
	BitbucketServerTriggerConfig TriggerBitbucketServerTriggerConfigPtrInput
	// Contents of the build template. Either a filename or build template must be provided.
	// Structure is documented below.
	Build TriggerBuildPtrInput
	// Human-readable description of the trigger.
	Description pulumi.StringPtrInput
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled pulumi.BoolPtrInput
	// Path, from the source root, to a file whose contents is used for the template.
	// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
	// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
	Filename pulumi.StringPtrInput
	// A Common Expression Language string. Used only with Pub/Sub and Webhook.
	Filter pulumi.StringPtrInput
	// The file source describing the local or remote Build template.
	// Structure is documented below.
	GitFileSource TriggerGitFileSourcePtrInput
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
	// Structure is documented below.
	Github TriggerGithubPtrInput
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If ignoredFiles and changed files are both empty, then they are not
	// used to determine whether or not to trigger a build.
	// If ignoredFiles is not empty, then we ignore any files that match any
	// of the ignoredFile globs. If the change has no files that are outside
	// of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles pulumi.StringArrayInput
	// Build logs will be sent back to GitHub as part of the checkrun
	// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
	// INCLUDE_BUILD_LOGS_WITH_STATUS
	// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
	IncludeBuildLogs pulumi.StringPtrInput
	// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
	// extended with support for `**`.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is empty, then as far as this filter is concerned, we
	// should trigger the build.
	// If any of the files altered in the commit pass the ignoredFiles filter
	// and includedFiles is not empty, then we make sure that at least one of
	// those files matches a includedFiles glob. If not, then we do not trigger
	// a build.
	IncludedFiles pulumi.StringArrayInput
	// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
	// If not specified, "global" is used.
	Location pulumi.StringPtrInput
	// Name of the trigger. Must be unique within the project.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// PubsubConfig describes the configuration of a trigger that creates
	// a build whenever a Pub/Sub message is published.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	PubsubConfig TriggerPubsubConfigPtrInput
	// The configuration of a trigger that creates a build whenever an event from Repo API is received.
	// Structure is documented below.
	RepositoryEventConfig TriggerRepositoryEventConfigPtrInput
	// The service account used for all user-controlled operations including
	// triggers.patch, triggers.run, builds.create, and builds.cancel.
	// If no service account is set, then the standard Cloud Build service account
	// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
	// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
	ServiceAccount pulumi.StringPtrInput
	// The repo and ref of the repository from which to build.
	// This field is used only for those triggers that do not respond to SCM events.
	// Triggers that respond to such events build source at whatever commit caused the event.
	// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	SourceToBuild TriggerSourceToBuildPtrInput
	// Substitutions data for Build resource.
	Substitutions pulumi.StringMapInput
	// Tags for annotation of a BuildTrigger
	Tags pulumi.StringArrayInput
	// Template describing the types of source changes to trigger a build.
	// Branch and tag names in trigger templates are interpreted as regular
	// expressions. Any branch or tag change that matches that regular
	// expression will trigger a build.
	// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	TriggerTemplate TriggerTriggerTemplatePtrInput
	// WebhookConfig describes the configuration of a trigger that creates
	// a build whenever a webhook is sent to a trigger's webhook URL.
	// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
	// Structure is documented below.
	WebhookConfig TriggerWebhookConfigPtrInput
}

func (TriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*triggerArgs)(nil)).Elem()
}

type TriggerInput interface {
	pulumi.Input

	ToTriggerOutput() TriggerOutput
	ToTriggerOutputWithContext(ctx context.Context) TriggerOutput
}

func (*Trigger) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (i *Trigger) ToTriggerOutput() TriggerOutput {
	return i.ToTriggerOutputWithContext(context.Background())
}

func (i *Trigger) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput)
}

// TriggerArrayInput is an input type that accepts TriggerArray and TriggerArrayOutput values.
// You can construct a concrete instance of `TriggerArrayInput` via:
//
//	TriggerArray{ TriggerArgs{...} }
type TriggerArrayInput interface {
	pulumi.Input

	ToTriggerArrayOutput() TriggerArrayOutput
	ToTriggerArrayOutputWithContext(context.Context) TriggerArrayOutput
}

type TriggerArray []TriggerInput

func (TriggerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Trigger)(nil)).Elem()
}

func (i TriggerArray) ToTriggerArrayOutput() TriggerArrayOutput {
	return i.ToTriggerArrayOutputWithContext(context.Background())
}

func (i TriggerArray) ToTriggerArrayOutputWithContext(ctx context.Context) TriggerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerArrayOutput)
}

// TriggerMapInput is an input type that accepts TriggerMap and TriggerMapOutput values.
// You can construct a concrete instance of `TriggerMapInput` via:
//
//	TriggerMap{ "key": TriggerArgs{...} }
type TriggerMapInput interface {
	pulumi.Input

	ToTriggerMapOutput() TriggerMapOutput
	ToTriggerMapOutputWithContext(context.Context) TriggerMapOutput
}

type TriggerMap map[string]TriggerInput

func (TriggerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Trigger)(nil)).Elem()
}

func (i TriggerMap) ToTriggerMapOutput() TriggerMapOutput {
	return i.ToTriggerMapOutputWithContext(context.Background())
}

func (i TriggerMap) ToTriggerMapOutputWithContext(ctx context.Context) TriggerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerMapOutput)
}

type TriggerOutput struct{ *pulumi.OutputState }

func (TriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (o TriggerOutput) ToTriggerOutput() TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return o
}

// Configuration for manual approval to start a build invocation of this BuildTrigger.
// Builds created by this trigger will require approval before they execute.
// Any user with a Cloud Build Approver role for the project can approve a build.
// Structure is documented below.
func (o TriggerOutput) ApprovalConfig() TriggerApprovalConfigOutput {
	return o.ApplyT(func(v *Trigger) TriggerApprovalConfigOutput { return v.ApprovalConfig }).(TriggerApprovalConfigOutput)
}

// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
// Structure is documented below.
func (o TriggerOutput) BitbucketServerTriggerConfig() TriggerBitbucketServerTriggerConfigPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerBitbucketServerTriggerConfigPtrOutput { return v.BitbucketServerTriggerConfig }).(TriggerBitbucketServerTriggerConfigPtrOutput)
}

// Contents of the build template. Either a filename or build template must be provided.
// Structure is documented below.
func (o TriggerOutput) Build() TriggerBuildPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerBuildPtrOutput { return v.Build }).(TriggerBuildPtrOutput)
}

// Time when the trigger was created.
func (o TriggerOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// Human-readable description of the trigger.
func (o TriggerOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
func (o TriggerOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.BoolPtrOutput { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// Path, from the source root, to a file whose contents is used for the template.
// Either a filename or build template must be provided. Set this only when using triggerTemplate or github.
// When using Pub/Sub, Webhook or Manual set the file name using gitFileSource instead.
func (o TriggerOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.Filename }).(pulumi.StringPtrOutput)
}

// A Common Expression Language string. Used only with Pub/Sub and Webhook.
func (o TriggerOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.Filter }).(pulumi.StringPtrOutput)
}

// The file source describing the local or remote Build template.
// Structure is documented below.
func (o TriggerOutput) GitFileSource() TriggerGitFileSourcePtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerGitFileSourcePtrOutput { return v.GitFileSource }).(TriggerGitFileSourcePtrOutput)
}

// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
// One of `triggerTemplate`, `github`, `pubsubConfig` or `webhookConfig` must be provided.
// Structure is documented below.
func (o TriggerOutput) Github() TriggerGithubPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerGithubPtrOutput { return v.Github }).(TriggerGithubPtrOutput)
}

// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
// extended with support for `**`.
// If ignoredFiles and changed files are both empty, then they are not
// used to determine whether or not to trigger a build.
// If ignoredFiles is not empty, then we ignore any files that match any
// of the ignoredFile globs. If the change has no files that are outside
// of the ignoredFiles globs, then we do not trigger a build.
func (o TriggerOutput) IgnoredFiles() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringArrayOutput { return v.IgnoredFiles }).(pulumi.StringArrayOutput)
}

// Build logs will be sent back to GitHub as part of the checkrun
// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
// INCLUDE_BUILD_LOGS_WITH_STATUS
// Possible values are: `INCLUDE_BUILD_LOGS_UNSPECIFIED`, `INCLUDE_BUILD_LOGS_WITH_STATUS`.
func (o TriggerOutput) IncludeBuildLogs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.IncludeBuildLogs }).(pulumi.StringPtrOutput)
}

// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
// extended with support for `**`.
// If any of the files altered in the commit pass the ignoredFiles filter
// and includedFiles is empty, then as far as this filter is concerned, we
// should trigger the build.
// If any of the files altered in the commit pass the ignoredFiles filter
// and includedFiles is not empty, then we make sure that at least one of
// those files matches a includedFiles glob. If not, then we do not trigger
// a build.
func (o TriggerOutput) IncludedFiles() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringArrayOutput { return v.IncludedFiles }).(pulumi.StringArrayOutput)
}

// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
// If not specified, "global" is used.
func (o TriggerOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.Location }).(pulumi.StringPtrOutput)
}

// Name of the trigger. Must be unique within the project.
func (o TriggerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o TriggerOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// PubsubConfig describes the configuration of a trigger that creates
// a build whenever a Pub/Sub message is published.
// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
// Structure is documented below.
func (o TriggerOutput) PubsubConfig() TriggerPubsubConfigPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerPubsubConfigPtrOutput { return v.PubsubConfig }).(TriggerPubsubConfigPtrOutput)
}

// The configuration of a trigger that creates a build whenever an event from Repo API is received.
// Structure is documented below.
func (o TriggerOutput) RepositoryEventConfig() TriggerRepositoryEventConfigPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerRepositoryEventConfigPtrOutput { return v.RepositoryEventConfig }).(TriggerRepositoryEventConfigPtrOutput)
}

// The service account used for all user-controlled operations including
// triggers.patch, triggers.run, builds.create, and builds.cancel.
// If no service account is set, then the standard Cloud Build service account
// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
func (o TriggerOutput) ServiceAccount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringPtrOutput { return v.ServiceAccount }).(pulumi.StringPtrOutput)
}

// The repo and ref of the repository from which to build.
// This field is used only for those triggers that do not respond to SCM events.
// Triggers that respond to such events build source at whatever commit caused the event.
// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
// Structure is documented below.
func (o TriggerOutput) SourceToBuild() TriggerSourceToBuildPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerSourceToBuildPtrOutput { return v.SourceToBuild }).(TriggerSourceToBuildPtrOutput)
}

// Substitutions data for Build resource.
func (o TriggerOutput) Substitutions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringMapOutput { return v.Substitutions }).(pulumi.StringMapOutput)
}

// Tags for annotation of a BuildTrigger
func (o TriggerOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The unique identifier for the trigger.
func (o TriggerOutput) TriggerId() pulumi.StringOutput {
	return o.ApplyT(func(v *Trigger) pulumi.StringOutput { return v.TriggerId }).(pulumi.StringOutput)
}

// Template describing the types of source changes to trigger a build.
// Branch and tag names in trigger templates are interpreted as regular
// expressions. Any branch or tag change that matches that regular
// expression will trigger a build.
// One of `triggerTemplate`, `github`, `pubsubConfig`, `webhookConfig` or `sourceToBuild` must be provided.
// Structure is documented below.
func (o TriggerOutput) TriggerTemplate() TriggerTriggerTemplatePtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerTriggerTemplatePtrOutput { return v.TriggerTemplate }).(TriggerTriggerTemplatePtrOutput)
}

// WebhookConfig describes the configuration of a trigger that creates
// a build whenever a webhook is sent to a trigger's webhook URL.
// One of `triggerTemplate`, `github`, `pubsubConfig` `webhookConfig` or `sourceToBuild` must be provided.
// Structure is documented below.
func (o TriggerOutput) WebhookConfig() TriggerWebhookConfigPtrOutput {
	return o.ApplyT(func(v *Trigger) TriggerWebhookConfigPtrOutput { return v.WebhookConfig }).(TriggerWebhookConfigPtrOutput)
}

type TriggerArrayOutput struct{ *pulumi.OutputState }

func (TriggerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Trigger)(nil)).Elem()
}

func (o TriggerArrayOutput) ToTriggerArrayOutput() TriggerArrayOutput {
	return o
}

func (o TriggerArrayOutput) ToTriggerArrayOutputWithContext(ctx context.Context) TriggerArrayOutput {
	return o
}

func (o TriggerArrayOutput) Index(i pulumi.IntInput) TriggerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Trigger {
		return vs[0].([]*Trigger)[vs[1].(int)]
	}).(TriggerOutput)
}

type TriggerMapOutput struct{ *pulumi.OutputState }

func (TriggerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Trigger)(nil)).Elem()
}

func (o TriggerMapOutput) ToTriggerMapOutput() TriggerMapOutput {
	return o
}

func (o TriggerMapOutput) ToTriggerMapOutputWithContext(ctx context.Context) TriggerMapOutput {
	return o
}

func (o TriggerMapOutput) MapIndex(k pulumi.StringInput) TriggerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Trigger {
		return vs[0].(map[string]*Trigger)[vs[1].(string)]
	}).(TriggerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TriggerInput)(nil)).Elem(), &Trigger{})
	pulumi.RegisterInputType(reflect.TypeOf((*TriggerArrayInput)(nil)).Elem(), TriggerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TriggerMapInput)(nil)).Elem(), TriggerMap{})
	pulumi.RegisterOutputType(TriggerOutput{})
	pulumi.RegisterOutputType(TriggerArrayOutput{})
	pulumi.RegisterOutputType(TriggerMapOutput{})
}
