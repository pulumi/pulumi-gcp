// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package resourcemanager

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// An app-enabled folder is a folder within the Google Cloud resource hierarchy that has been configured for application management. This folder lets you define and manage App Hub applications. These applications are functional groupings of services and workloads that span multiple projects within that folder and its descendant projects.
//
// To get more information about Capability, see:
//
// * [API documentation](https://cloud.google.com/resource-manager/reference/rest)
// * How-to Guides
//   - [Official Documentation](https://cloud.google.com/resource-manager/docs/manage-applications)
//
// ## Example Usage
//
// ### Resource Manager Capability
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/resourcemanager"
//	"github.com/pulumi/pulumi-time/sdk/go/time"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			folder, err := organizations.NewFolder(ctx, "folder", &organizations.FolderArgs{
//				DisplayName:        pulumi.String("my-folder"),
//				Parent:             pulumi.String("organizations/123456789"),
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			wait60s, err := time.NewSleep(ctx, "wait_60s", &time.SleepArgs{
//				CreateDuration: "60s",
//			}, pulumi.DependsOn([]pulumi.Resource{
//				folder,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = resourcemanager.NewCapability(ctx, "capability", &resourcemanager.CapabilityArgs{
//				Value:          pulumi.Bool(true),
//				Parent:         folder.Name,
//				CapabilityName: pulumi.String("app-management"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				wait60s,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Capability can be imported using any of these accepted formats:
//
// * `{{parent}}/capabilities/{{capability_name}}`
//
// * `{{parent}}/{{capability_name}}`
//
// When using the `pulumi import` command, Capability can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:resourcemanager/capability:Capability default {{parent}}/capabilities/{{capability_name}}
// ```
//
// ```sh
// $ pulumi import gcp:resourcemanager/capability:Capability default {{parent}}/{{capability_name}}
// ```
type Capability struct {
	pulumi.CustomResourceState

	// Capability name that should be updated on the folder.
	CapabilityName pulumi.StringOutput `pulumi:"capabilityName"`
	// Folder on which Capability needs to be updated in the format folders/folder_id.
	Parent pulumi.StringOutput `pulumi:"parent"`
	// Capability Value.
	Value pulumi.BoolOutput `pulumi:"value"`
}

// NewCapability registers a new resource with the given unique name, arguments, and options.
func NewCapability(ctx *pulumi.Context,
	name string, args *CapabilityArgs, opts ...pulumi.ResourceOption) (*Capability, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CapabilityName == nil {
		return nil, errors.New("invalid value for required argument 'CapabilityName'")
	}
	if args.Parent == nil {
		return nil, errors.New("invalid value for required argument 'Parent'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Capability
	err := ctx.RegisterResource("gcp:resourcemanager/capability:Capability", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCapability gets an existing Capability resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCapability(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CapabilityState, opts ...pulumi.ResourceOption) (*Capability, error) {
	var resource Capability
	err := ctx.ReadResource("gcp:resourcemanager/capability:Capability", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Capability resources.
type capabilityState struct {
	// Capability name that should be updated on the folder.
	CapabilityName *string `pulumi:"capabilityName"`
	// Folder on which Capability needs to be updated in the format folders/folder_id.
	Parent *string `pulumi:"parent"`
	// Capability Value.
	Value *bool `pulumi:"value"`
}

type CapabilityState struct {
	// Capability name that should be updated on the folder.
	CapabilityName pulumi.StringPtrInput
	// Folder on which Capability needs to be updated in the format folders/folder_id.
	Parent pulumi.StringPtrInput
	// Capability Value.
	Value pulumi.BoolPtrInput
}

func (CapabilityState) ElementType() reflect.Type {
	return reflect.TypeOf((*capabilityState)(nil)).Elem()
}

type capabilityArgs struct {
	// Capability name that should be updated on the folder.
	CapabilityName string `pulumi:"capabilityName"`
	// Folder on which Capability needs to be updated in the format folders/folder_id.
	Parent string `pulumi:"parent"`
	// Capability Value.
	Value bool `pulumi:"value"`
}

// The set of arguments for constructing a Capability resource.
type CapabilityArgs struct {
	// Capability name that should be updated on the folder.
	CapabilityName pulumi.StringInput
	// Folder on which Capability needs to be updated in the format folders/folder_id.
	Parent pulumi.StringInput
	// Capability Value.
	Value pulumi.BoolInput
}

func (CapabilityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*capabilityArgs)(nil)).Elem()
}

type CapabilityInput interface {
	pulumi.Input

	ToCapabilityOutput() CapabilityOutput
	ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput
}

func (*Capability) ElementType() reflect.Type {
	return reflect.TypeOf((**Capability)(nil)).Elem()
}

func (i *Capability) ToCapabilityOutput() CapabilityOutput {
	return i.ToCapabilityOutputWithContext(context.Background())
}

func (i *Capability) ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilityOutput)
}

// CapabilityArrayInput is an input type that accepts CapabilityArray and CapabilityArrayOutput values.
// You can construct a concrete instance of `CapabilityArrayInput` via:
//
//	CapabilityArray{ CapabilityArgs{...} }
type CapabilityArrayInput interface {
	pulumi.Input

	ToCapabilityArrayOutput() CapabilityArrayOutput
	ToCapabilityArrayOutputWithContext(context.Context) CapabilityArrayOutput
}

type CapabilityArray []CapabilityInput

func (CapabilityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Capability)(nil)).Elem()
}

func (i CapabilityArray) ToCapabilityArrayOutput() CapabilityArrayOutput {
	return i.ToCapabilityArrayOutputWithContext(context.Background())
}

func (i CapabilityArray) ToCapabilityArrayOutputWithContext(ctx context.Context) CapabilityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilityArrayOutput)
}

// CapabilityMapInput is an input type that accepts CapabilityMap and CapabilityMapOutput values.
// You can construct a concrete instance of `CapabilityMapInput` via:
//
//	CapabilityMap{ "key": CapabilityArgs{...} }
type CapabilityMapInput interface {
	pulumi.Input

	ToCapabilityMapOutput() CapabilityMapOutput
	ToCapabilityMapOutputWithContext(context.Context) CapabilityMapOutput
}

type CapabilityMap map[string]CapabilityInput

func (CapabilityMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Capability)(nil)).Elem()
}

func (i CapabilityMap) ToCapabilityMapOutput() CapabilityMapOutput {
	return i.ToCapabilityMapOutputWithContext(context.Background())
}

func (i CapabilityMap) ToCapabilityMapOutputWithContext(ctx context.Context) CapabilityMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilityMapOutput)
}

type CapabilityOutput struct{ *pulumi.OutputState }

func (CapabilityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Capability)(nil)).Elem()
}

func (o CapabilityOutput) ToCapabilityOutput() CapabilityOutput {
	return o
}

func (o CapabilityOutput) ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput {
	return o
}

// Capability name that should be updated on the folder.
func (o CapabilityOutput) CapabilityName() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.CapabilityName }).(pulumi.StringOutput)
}

// Folder on which Capability needs to be updated in the format folders/folder_id.
func (o CapabilityOutput) Parent() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.Parent }).(pulumi.StringOutput)
}

// Capability Value.
func (o CapabilityOutput) Value() pulumi.BoolOutput {
	return o.ApplyT(func(v *Capability) pulumi.BoolOutput { return v.Value }).(pulumi.BoolOutput)
}

type CapabilityArrayOutput struct{ *pulumi.OutputState }

func (CapabilityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Capability)(nil)).Elem()
}

func (o CapabilityArrayOutput) ToCapabilityArrayOutput() CapabilityArrayOutput {
	return o
}

func (o CapabilityArrayOutput) ToCapabilityArrayOutputWithContext(ctx context.Context) CapabilityArrayOutput {
	return o
}

func (o CapabilityArrayOutput) Index(i pulumi.IntInput) CapabilityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Capability {
		return vs[0].([]*Capability)[vs[1].(int)]
	}).(CapabilityOutput)
}

type CapabilityMapOutput struct{ *pulumi.OutputState }

func (CapabilityMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Capability)(nil)).Elem()
}

func (o CapabilityMapOutput) ToCapabilityMapOutput() CapabilityMapOutput {
	return o
}

func (o CapabilityMapOutput) ToCapabilityMapOutputWithContext(ctx context.Context) CapabilityMapOutput {
	return o
}

func (o CapabilityMapOutput) MapIndex(k pulumi.StringInput) CapabilityOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Capability {
		return vs[0].(map[string]*Capability)[vs[1].(string)]
	}).(CapabilityOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CapabilityInput)(nil)).Elem(), &Capability{})
	pulumi.RegisterInputType(reflect.TypeOf((*CapabilityArrayInput)(nil)).Elem(), CapabilityArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CapabilityMapInput)(nil)).Elem(), CapabilityMap{})
	pulumi.RegisterOutputType(CapabilityOutput{})
	pulumi.RegisterOutputType(CapabilityArrayOutput{})
	pulumi.RegisterOutputType(CapabilityMapOutput{})
}
