// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datafusion

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type InstanceAccelerator struct {
	// The type of an accelator for a CDF instance.
	// Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
	AcceleratorType string `pulumi:"acceleratorType"`
	// The type of an accelator for a CDF instance.
	// Possible values are: `ENABLED`, `DISABLED`.
	State string `pulumi:"state"`
}

// InstanceAcceleratorInput is an input type that accepts InstanceAcceleratorArgs and InstanceAcceleratorOutput values.
// You can construct a concrete instance of `InstanceAcceleratorInput` via:
//
//	InstanceAcceleratorArgs{...}
type InstanceAcceleratorInput interface {
	pulumi.Input

	ToInstanceAcceleratorOutput() InstanceAcceleratorOutput
	ToInstanceAcceleratorOutputWithContext(context.Context) InstanceAcceleratorOutput
}

type InstanceAcceleratorArgs struct {
	// The type of an accelator for a CDF instance.
	// Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
	AcceleratorType pulumi.StringInput `pulumi:"acceleratorType"`
	// The type of an accelator for a CDF instance.
	// Possible values are: `ENABLED`, `DISABLED`.
	State pulumi.StringInput `pulumi:"state"`
}

func (InstanceAcceleratorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceAccelerator)(nil)).Elem()
}

func (i InstanceAcceleratorArgs) ToInstanceAcceleratorOutput() InstanceAcceleratorOutput {
	return i.ToInstanceAcceleratorOutputWithContext(context.Background())
}

func (i InstanceAcceleratorArgs) ToInstanceAcceleratorOutputWithContext(ctx context.Context) InstanceAcceleratorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceAcceleratorOutput)
}

// InstanceAcceleratorArrayInput is an input type that accepts InstanceAcceleratorArray and InstanceAcceleratorArrayOutput values.
// You can construct a concrete instance of `InstanceAcceleratorArrayInput` via:
//
//	InstanceAcceleratorArray{ InstanceAcceleratorArgs{...} }
type InstanceAcceleratorArrayInput interface {
	pulumi.Input

	ToInstanceAcceleratorArrayOutput() InstanceAcceleratorArrayOutput
	ToInstanceAcceleratorArrayOutputWithContext(context.Context) InstanceAcceleratorArrayOutput
}

type InstanceAcceleratorArray []InstanceAcceleratorInput

func (InstanceAcceleratorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceAccelerator)(nil)).Elem()
}

func (i InstanceAcceleratorArray) ToInstanceAcceleratorArrayOutput() InstanceAcceleratorArrayOutput {
	return i.ToInstanceAcceleratorArrayOutputWithContext(context.Background())
}

func (i InstanceAcceleratorArray) ToInstanceAcceleratorArrayOutputWithContext(ctx context.Context) InstanceAcceleratorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceAcceleratorArrayOutput)
}

type InstanceAcceleratorOutput struct{ *pulumi.OutputState }

func (InstanceAcceleratorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceAccelerator)(nil)).Elem()
}

func (o InstanceAcceleratorOutput) ToInstanceAcceleratorOutput() InstanceAcceleratorOutput {
	return o
}

func (o InstanceAcceleratorOutput) ToInstanceAcceleratorOutputWithContext(ctx context.Context) InstanceAcceleratorOutput {
	return o
}

// The type of an accelator for a CDF instance.
// Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
func (o InstanceAcceleratorOutput) AcceleratorType() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceAccelerator) string { return v.AcceleratorType }).(pulumi.StringOutput)
}

// The type of an accelator for a CDF instance.
// Possible values are: `ENABLED`, `DISABLED`.
func (o InstanceAcceleratorOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceAccelerator) string { return v.State }).(pulumi.StringOutput)
}

type InstanceAcceleratorArrayOutput struct{ *pulumi.OutputState }

func (InstanceAcceleratorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceAccelerator)(nil)).Elem()
}

func (o InstanceAcceleratorArrayOutput) ToInstanceAcceleratorArrayOutput() InstanceAcceleratorArrayOutput {
	return o
}

func (o InstanceAcceleratorArrayOutput) ToInstanceAcceleratorArrayOutputWithContext(ctx context.Context) InstanceAcceleratorArrayOutput {
	return o
}

func (o InstanceAcceleratorArrayOutput) Index(i pulumi.IntInput) InstanceAcceleratorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceAccelerator {
		return vs[0].([]InstanceAccelerator)[vs[1].(int)]
	}).(InstanceAcceleratorOutput)
}

type InstanceCryptoKeyConfig struct {
	// The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
	KeyReference string `pulumi:"keyReference"`
}

// InstanceCryptoKeyConfigInput is an input type that accepts InstanceCryptoKeyConfigArgs and InstanceCryptoKeyConfigOutput values.
// You can construct a concrete instance of `InstanceCryptoKeyConfigInput` via:
//
//	InstanceCryptoKeyConfigArgs{...}
type InstanceCryptoKeyConfigInput interface {
	pulumi.Input

	ToInstanceCryptoKeyConfigOutput() InstanceCryptoKeyConfigOutput
	ToInstanceCryptoKeyConfigOutputWithContext(context.Context) InstanceCryptoKeyConfigOutput
}

type InstanceCryptoKeyConfigArgs struct {
	// The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
	KeyReference pulumi.StringInput `pulumi:"keyReference"`
}

func (InstanceCryptoKeyConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceCryptoKeyConfig)(nil)).Elem()
}

func (i InstanceCryptoKeyConfigArgs) ToInstanceCryptoKeyConfigOutput() InstanceCryptoKeyConfigOutput {
	return i.ToInstanceCryptoKeyConfigOutputWithContext(context.Background())
}

func (i InstanceCryptoKeyConfigArgs) ToInstanceCryptoKeyConfigOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceCryptoKeyConfigOutput)
}

func (i InstanceCryptoKeyConfigArgs) ToInstanceCryptoKeyConfigPtrOutput() InstanceCryptoKeyConfigPtrOutput {
	return i.ToInstanceCryptoKeyConfigPtrOutputWithContext(context.Background())
}

func (i InstanceCryptoKeyConfigArgs) ToInstanceCryptoKeyConfigPtrOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceCryptoKeyConfigOutput).ToInstanceCryptoKeyConfigPtrOutputWithContext(ctx)
}

// InstanceCryptoKeyConfigPtrInput is an input type that accepts InstanceCryptoKeyConfigArgs, InstanceCryptoKeyConfigPtr and InstanceCryptoKeyConfigPtrOutput values.
// You can construct a concrete instance of `InstanceCryptoKeyConfigPtrInput` via:
//
//	        InstanceCryptoKeyConfigArgs{...}
//
//	or:
//
//	        nil
type InstanceCryptoKeyConfigPtrInput interface {
	pulumi.Input

	ToInstanceCryptoKeyConfigPtrOutput() InstanceCryptoKeyConfigPtrOutput
	ToInstanceCryptoKeyConfigPtrOutputWithContext(context.Context) InstanceCryptoKeyConfigPtrOutput
}

type instanceCryptoKeyConfigPtrType InstanceCryptoKeyConfigArgs

func InstanceCryptoKeyConfigPtr(v *InstanceCryptoKeyConfigArgs) InstanceCryptoKeyConfigPtrInput {
	return (*instanceCryptoKeyConfigPtrType)(v)
}

func (*instanceCryptoKeyConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceCryptoKeyConfig)(nil)).Elem()
}

func (i *instanceCryptoKeyConfigPtrType) ToInstanceCryptoKeyConfigPtrOutput() InstanceCryptoKeyConfigPtrOutput {
	return i.ToInstanceCryptoKeyConfigPtrOutputWithContext(context.Background())
}

func (i *instanceCryptoKeyConfigPtrType) ToInstanceCryptoKeyConfigPtrOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceCryptoKeyConfigPtrOutput)
}

type InstanceCryptoKeyConfigOutput struct{ *pulumi.OutputState }

func (InstanceCryptoKeyConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceCryptoKeyConfig)(nil)).Elem()
}

func (o InstanceCryptoKeyConfigOutput) ToInstanceCryptoKeyConfigOutput() InstanceCryptoKeyConfigOutput {
	return o
}

func (o InstanceCryptoKeyConfigOutput) ToInstanceCryptoKeyConfigOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigOutput {
	return o
}

func (o InstanceCryptoKeyConfigOutput) ToInstanceCryptoKeyConfigPtrOutput() InstanceCryptoKeyConfigPtrOutput {
	return o.ToInstanceCryptoKeyConfigPtrOutputWithContext(context.Background())
}

func (o InstanceCryptoKeyConfigOutput) ToInstanceCryptoKeyConfigPtrOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InstanceCryptoKeyConfig) *InstanceCryptoKeyConfig {
		return &v
	}).(InstanceCryptoKeyConfigPtrOutput)
}

// The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
func (o InstanceCryptoKeyConfigOutput) KeyReference() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceCryptoKeyConfig) string { return v.KeyReference }).(pulumi.StringOutput)
}

type InstanceCryptoKeyConfigPtrOutput struct{ *pulumi.OutputState }

func (InstanceCryptoKeyConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceCryptoKeyConfig)(nil)).Elem()
}

func (o InstanceCryptoKeyConfigPtrOutput) ToInstanceCryptoKeyConfigPtrOutput() InstanceCryptoKeyConfigPtrOutput {
	return o
}

func (o InstanceCryptoKeyConfigPtrOutput) ToInstanceCryptoKeyConfigPtrOutputWithContext(ctx context.Context) InstanceCryptoKeyConfigPtrOutput {
	return o
}

func (o InstanceCryptoKeyConfigPtrOutput) Elem() InstanceCryptoKeyConfigOutput {
	return o.ApplyT(func(v *InstanceCryptoKeyConfig) InstanceCryptoKeyConfig {
		if v != nil {
			return *v
		}
		var ret InstanceCryptoKeyConfig
		return ret
	}).(InstanceCryptoKeyConfigOutput)
}

// The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
func (o InstanceCryptoKeyConfigPtrOutput) KeyReference() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceCryptoKeyConfig) *string {
		if v == nil {
			return nil
		}
		return &v.KeyReference
	}).(pulumi.StringPtrOutput)
}

type InstanceEventPublishConfig struct {
	// Option to enable Event Publishing.
	Enabled bool `pulumi:"enabled"`
	// The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
	Topic string `pulumi:"topic"`
}

// InstanceEventPublishConfigInput is an input type that accepts InstanceEventPublishConfigArgs and InstanceEventPublishConfigOutput values.
// You can construct a concrete instance of `InstanceEventPublishConfigInput` via:
//
//	InstanceEventPublishConfigArgs{...}
type InstanceEventPublishConfigInput interface {
	pulumi.Input

	ToInstanceEventPublishConfigOutput() InstanceEventPublishConfigOutput
	ToInstanceEventPublishConfigOutputWithContext(context.Context) InstanceEventPublishConfigOutput
}

type InstanceEventPublishConfigArgs struct {
	// Option to enable Event Publishing.
	Enabled pulumi.BoolInput `pulumi:"enabled"`
	// The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
	Topic pulumi.StringInput `pulumi:"topic"`
}

func (InstanceEventPublishConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceEventPublishConfig)(nil)).Elem()
}

func (i InstanceEventPublishConfigArgs) ToInstanceEventPublishConfigOutput() InstanceEventPublishConfigOutput {
	return i.ToInstanceEventPublishConfigOutputWithContext(context.Background())
}

func (i InstanceEventPublishConfigArgs) ToInstanceEventPublishConfigOutputWithContext(ctx context.Context) InstanceEventPublishConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceEventPublishConfigOutput)
}

func (i InstanceEventPublishConfigArgs) ToInstanceEventPublishConfigPtrOutput() InstanceEventPublishConfigPtrOutput {
	return i.ToInstanceEventPublishConfigPtrOutputWithContext(context.Background())
}

func (i InstanceEventPublishConfigArgs) ToInstanceEventPublishConfigPtrOutputWithContext(ctx context.Context) InstanceEventPublishConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceEventPublishConfigOutput).ToInstanceEventPublishConfigPtrOutputWithContext(ctx)
}

// InstanceEventPublishConfigPtrInput is an input type that accepts InstanceEventPublishConfigArgs, InstanceEventPublishConfigPtr and InstanceEventPublishConfigPtrOutput values.
// You can construct a concrete instance of `InstanceEventPublishConfigPtrInput` via:
//
//	        InstanceEventPublishConfigArgs{...}
//
//	or:
//
//	        nil
type InstanceEventPublishConfigPtrInput interface {
	pulumi.Input

	ToInstanceEventPublishConfigPtrOutput() InstanceEventPublishConfigPtrOutput
	ToInstanceEventPublishConfigPtrOutputWithContext(context.Context) InstanceEventPublishConfigPtrOutput
}

type instanceEventPublishConfigPtrType InstanceEventPublishConfigArgs

func InstanceEventPublishConfigPtr(v *InstanceEventPublishConfigArgs) InstanceEventPublishConfigPtrInput {
	return (*instanceEventPublishConfigPtrType)(v)
}

func (*instanceEventPublishConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceEventPublishConfig)(nil)).Elem()
}

func (i *instanceEventPublishConfigPtrType) ToInstanceEventPublishConfigPtrOutput() InstanceEventPublishConfigPtrOutput {
	return i.ToInstanceEventPublishConfigPtrOutputWithContext(context.Background())
}

func (i *instanceEventPublishConfigPtrType) ToInstanceEventPublishConfigPtrOutputWithContext(ctx context.Context) InstanceEventPublishConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceEventPublishConfigPtrOutput)
}

type InstanceEventPublishConfigOutput struct{ *pulumi.OutputState }

func (InstanceEventPublishConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceEventPublishConfig)(nil)).Elem()
}

func (o InstanceEventPublishConfigOutput) ToInstanceEventPublishConfigOutput() InstanceEventPublishConfigOutput {
	return o
}

func (o InstanceEventPublishConfigOutput) ToInstanceEventPublishConfigOutputWithContext(ctx context.Context) InstanceEventPublishConfigOutput {
	return o
}

func (o InstanceEventPublishConfigOutput) ToInstanceEventPublishConfigPtrOutput() InstanceEventPublishConfigPtrOutput {
	return o.ToInstanceEventPublishConfigPtrOutputWithContext(context.Background())
}

func (o InstanceEventPublishConfigOutput) ToInstanceEventPublishConfigPtrOutputWithContext(ctx context.Context) InstanceEventPublishConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InstanceEventPublishConfig) *InstanceEventPublishConfig {
		return &v
	}).(InstanceEventPublishConfigPtrOutput)
}

// Option to enable Event Publishing.
func (o InstanceEventPublishConfigOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v InstanceEventPublishConfig) bool { return v.Enabled }).(pulumi.BoolOutput)
}

// The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
func (o InstanceEventPublishConfigOutput) Topic() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceEventPublishConfig) string { return v.Topic }).(pulumi.StringOutput)
}

type InstanceEventPublishConfigPtrOutput struct{ *pulumi.OutputState }

func (InstanceEventPublishConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceEventPublishConfig)(nil)).Elem()
}

func (o InstanceEventPublishConfigPtrOutput) ToInstanceEventPublishConfigPtrOutput() InstanceEventPublishConfigPtrOutput {
	return o
}

func (o InstanceEventPublishConfigPtrOutput) ToInstanceEventPublishConfigPtrOutputWithContext(ctx context.Context) InstanceEventPublishConfigPtrOutput {
	return o
}

func (o InstanceEventPublishConfigPtrOutput) Elem() InstanceEventPublishConfigOutput {
	return o.ApplyT(func(v *InstanceEventPublishConfig) InstanceEventPublishConfig {
		if v != nil {
			return *v
		}
		var ret InstanceEventPublishConfig
		return ret
	}).(InstanceEventPublishConfigOutput)
}

// Option to enable Event Publishing.
func (o InstanceEventPublishConfigPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceEventPublishConfig) *bool {
		if v == nil {
			return nil
		}
		return &v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
func (o InstanceEventPublishConfigPtrOutput) Topic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceEventPublishConfig) *string {
		if v == nil {
			return nil
		}
		return &v.Topic
	}).(pulumi.StringPtrOutput)
}

type InstanceNetworkConfig struct {
	// Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
	// the corresponding tenant project from a predefined list of available connection modes.
	// If this field is unspecified for a private instance, VPC peering is used.
	// Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
	ConnectionType *string `pulumi:"connectionType"`
	// The IP range in CIDR notation to use for the managed Data Fusion instance
	// nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
	IpAllocation *string `pulumi:"ipAllocation"`
	// Name of the network in the project with which the tenant project
	// will be peered for executing pipelines. In case of shared VPC where the network resides in another host
	// project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
	Network *string `pulumi:"network"`
	// Optional. Configuration for Private Service Connect.
	// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
	// Structure is documented below.
	PrivateServiceConnectConfig *InstanceNetworkConfigPrivateServiceConnectConfig `pulumi:"privateServiceConnectConfig"`
}

// InstanceNetworkConfigInput is an input type that accepts InstanceNetworkConfigArgs and InstanceNetworkConfigOutput values.
// You can construct a concrete instance of `InstanceNetworkConfigInput` via:
//
//	InstanceNetworkConfigArgs{...}
type InstanceNetworkConfigInput interface {
	pulumi.Input

	ToInstanceNetworkConfigOutput() InstanceNetworkConfigOutput
	ToInstanceNetworkConfigOutputWithContext(context.Context) InstanceNetworkConfigOutput
}

type InstanceNetworkConfigArgs struct {
	// Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
	// the corresponding tenant project from a predefined list of available connection modes.
	// If this field is unspecified for a private instance, VPC peering is used.
	// Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
	ConnectionType pulumi.StringPtrInput `pulumi:"connectionType"`
	// The IP range in CIDR notation to use for the managed Data Fusion instance
	// nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
	IpAllocation pulumi.StringPtrInput `pulumi:"ipAllocation"`
	// Name of the network in the project with which the tenant project
	// will be peered for executing pipelines. In case of shared VPC where the network resides in another host
	// project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
	Network pulumi.StringPtrInput `pulumi:"network"`
	// Optional. Configuration for Private Service Connect.
	// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
	// Structure is documented below.
	PrivateServiceConnectConfig InstanceNetworkConfigPrivateServiceConnectConfigPtrInput `pulumi:"privateServiceConnectConfig"`
}

func (InstanceNetworkConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetworkConfig)(nil)).Elem()
}

func (i InstanceNetworkConfigArgs) ToInstanceNetworkConfigOutput() InstanceNetworkConfigOutput {
	return i.ToInstanceNetworkConfigOutputWithContext(context.Background())
}

func (i InstanceNetworkConfigArgs) ToInstanceNetworkConfigOutputWithContext(ctx context.Context) InstanceNetworkConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigOutput)
}

func (i InstanceNetworkConfigArgs) ToInstanceNetworkConfigPtrOutput() InstanceNetworkConfigPtrOutput {
	return i.ToInstanceNetworkConfigPtrOutputWithContext(context.Background())
}

func (i InstanceNetworkConfigArgs) ToInstanceNetworkConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigOutput).ToInstanceNetworkConfigPtrOutputWithContext(ctx)
}

// InstanceNetworkConfigPtrInput is an input type that accepts InstanceNetworkConfigArgs, InstanceNetworkConfigPtr and InstanceNetworkConfigPtrOutput values.
// You can construct a concrete instance of `InstanceNetworkConfigPtrInput` via:
//
//	        InstanceNetworkConfigArgs{...}
//
//	or:
//
//	        nil
type InstanceNetworkConfigPtrInput interface {
	pulumi.Input

	ToInstanceNetworkConfigPtrOutput() InstanceNetworkConfigPtrOutput
	ToInstanceNetworkConfigPtrOutputWithContext(context.Context) InstanceNetworkConfigPtrOutput
}

type instanceNetworkConfigPtrType InstanceNetworkConfigArgs

func InstanceNetworkConfigPtr(v *InstanceNetworkConfigArgs) InstanceNetworkConfigPtrInput {
	return (*instanceNetworkConfigPtrType)(v)
}

func (*instanceNetworkConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceNetworkConfig)(nil)).Elem()
}

func (i *instanceNetworkConfigPtrType) ToInstanceNetworkConfigPtrOutput() InstanceNetworkConfigPtrOutput {
	return i.ToInstanceNetworkConfigPtrOutputWithContext(context.Background())
}

func (i *instanceNetworkConfigPtrType) ToInstanceNetworkConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigPtrOutput)
}

type InstanceNetworkConfigOutput struct{ *pulumi.OutputState }

func (InstanceNetworkConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetworkConfig)(nil)).Elem()
}

func (o InstanceNetworkConfigOutput) ToInstanceNetworkConfigOutput() InstanceNetworkConfigOutput {
	return o
}

func (o InstanceNetworkConfigOutput) ToInstanceNetworkConfigOutputWithContext(ctx context.Context) InstanceNetworkConfigOutput {
	return o
}

func (o InstanceNetworkConfigOutput) ToInstanceNetworkConfigPtrOutput() InstanceNetworkConfigPtrOutput {
	return o.ToInstanceNetworkConfigPtrOutputWithContext(context.Background())
}

func (o InstanceNetworkConfigOutput) ToInstanceNetworkConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InstanceNetworkConfig) *InstanceNetworkConfig {
		return &v
	}).(InstanceNetworkConfigPtrOutput)
}

// Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
// the corresponding tenant project from a predefined list of available connection modes.
// If this field is unspecified for a private instance, VPC peering is used.
// Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
func (o InstanceNetworkConfigOutput) ConnectionType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfig) *string { return v.ConnectionType }).(pulumi.StringPtrOutput)
}

// The IP range in CIDR notation to use for the managed Data Fusion instance
// nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
func (o InstanceNetworkConfigOutput) IpAllocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfig) *string { return v.IpAllocation }).(pulumi.StringPtrOutput)
}

// Name of the network in the project with which the tenant project
// will be peered for executing pipelines. In case of shared VPC where the network resides in another host
// project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
func (o InstanceNetworkConfigOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfig) *string { return v.Network }).(pulumi.StringPtrOutput)
}

// Optional. Configuration for Private Service Connect.
// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
// Structure is documented below.
func (o InstanceNetworkConfigOutput) PrivateServiceConnectConfig() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfig) *InstanceNetworkConfigPrivateServiceConnectConfig {
		return v.PrivateServiceConnectConfig
	}).(InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput)
}

type InstanceNetworkConfigPtrOutput struct{ *pulumi.OutputState }

func (InstanceNetworkConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceNetworkConfig)(nil)).Elem()
}

func (o InstanceNetworkConfigPtrOutput) ToInstanceNetworkConfigPtrOutput() InstanceNetworkConfigPtrOutput {
	return o
}

func (o InstanceNetworkConfigPtrOutput) ToInstanceNetworkConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPtrOutput {
	return o
}

func (o InstanceNetworkConfigPtrOutput) Elem() InstanceNetworkConfigOutput {
	return o.ApplyT(func(v *InstanceNetworkConfig) InstanceNetworkConfig {
		if v != nil {
			return *v
		}
		var ret InstanceNetworkConfig
		return ret
	}).(InstanceNetworkConfigOutput)
}

// Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
// the corresponding tenant project from a predefined list of available connection modes.
// If this field is unspecified for a private instance, VPC peering is used.
// Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
func (o InstanceNetworkConfigPtrOutput) ConnectionType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfig) *string {
		if v == nil {
			return nil
		}
		return v.ConnectionType
	}).(pulumi.StringPtrOutput)
}

// The IP range in CIDR notation to use for the managed Data Fusion instance
// nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
func (o InstanceNetworkConfigPtrOutput) IpAllocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfig) *string {
		if v == nil {
			return nil
		}
		return v.IpAllocation
	}).(pulumi.StringPtrOutput)
}

// Name of the network in the project with which the tenant project
// will be peered for executing pipelines. In case of shared VPC where the network resides in another host
// project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
func (o InstanceNetworkConfigPtrOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfig) *string {
		if v == nil {
			return nil
		}
		return v.Network
	}).(pulumi.StringPtrOutput)
}

// Optional. Configuration for Private Service Connect.
// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
// Structure is documented below.
func (o InstanceNetworkConfigPtrOutput) PrivateServiceConnectConfig() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfig) *InstanceNetworkConfigPrivateServiceConnectConfig {
		if v == nil {
			return nil
		}
		return v.PrivateServiceConnectConfig
	}).(InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput)
}

type InstanceNetworkConfigPrivateServiceConnectConfig struct {
	// (Output)
	// Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
	// The size of this block is /25. The format of this field is governed by RFC 4632.
	EffectiveUnreachableCidrBlock *string `pulumi:"effectiveUnreachableCidrBlock"`
	// Optional. The reference to the network attachment used to establish private connectivity.
	// It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
	// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
	NetworkAttachment *string `pulumi:"networkAttachment"`
	// Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
	// The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
	// This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
	// If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
	UnreachableCidrBlock *string `pulumi:"unreachableCidrBlock"`
}

// InstanceNetworkConfigPrivateServiceConnectConfigInput is an input type that accepts InstanceNetworkConfigPrivateServiceConnectConfigArgs and InstanceNetworkConfigPrivateServiceConnectConfigOutput values.
// You can construct a concrete instance of `InstanceNetworkConfigPrivateServiceConnectConfigInput` via:
//
//	InstanceNetworkConfigPrivateServiceConnectConfigArgs{...}
type InstanceNetworkConfigPrivateServiceConnectConfigInput interface {
	pulumi.Input

	ToInstanceNetworkConfigPrivateServiceConnectConfigOutput() InstanceNetworkConfigPrivateServiceConnectConfigOutput
	ToInstanceNetworkConfigPrivateServiceConnectConfigOutputWithContext(context.Context) InstanceNetworkConfigPrivateServiceConnectConfigOutput
}

type InstanceNetworkConfigPrivateServiceConnectConfigArgs struct {
	// (Output)
	// Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
	// The size of this block is /25. The format of this field is governed by RFC 4632.
	EffectiveUnreachableCidrBlock pulumi.StringPtrInput `pulumi:"effectiveUnreachableCidrBlock"`
	// Optional. The reference to the network attachment used to establish private connectivity.
	// It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
	// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
	NetworkAttachment pulumi.StringPtrInput `pulumi:"networkAttachment"`
	// Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
	// The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
	// This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
	// If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
	UnreachableCidrBlock pulumi.StringPtrInput `pulumi:"unreachableCidrBlock"`
}

func (InstanceNetworkConfigPrivateServiceConnectConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetworkConfigPrivateServiceConnectConfig)(nil)).Elem()
}

func (i InstanceNetworkConfigPrivateServiceConnectConfigArgs) ToInstanceNetworkConfigPrivateServiceConnectConfigOutput() InstanceNetworkConfigPrivateServiceConnectConfigOutput {
	return i.ToInstanceNetworkConfigPrivateServiceConnectConfigOutputWithContext(context.Background())
}

func (i InstanceNetworkConfigPrivateServiceConnectConfigArgs) ToInstanceNetworkConfigPrivateServiceConnectConfigOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigPrivateServiceConnectConfigOutput)
}

func (i InstanceNetworkConfigPrivateServiceConnectConfigArgs) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutput() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return i.ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(context.Background())
}

func (i InstanceNetworkConfigPrivateServiceConnectConfigArgs) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigPrivateServiceConnectConfigOutput).ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(ctx)
}

// InstanceNetworkConfigPrivateServiceConnectConfigPtrInput is an input type that accepts InstanceNetworkConfigPrivateServiceConnectConfigArgs, InstanceNetworkConfigPrivateServiceConnectConfigPtr and InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput values.
// You can construct a concrete instance of `InstanceNetworkConfigPrivateServiceConnectConfigPtrInput` via:
//
//	        InstanceNetworkConfigPrivateServiceConnectConfigArgs{...}
//
//	or:
//
//	        nil
type InstanceNetworkConfigPrivateServiceConnectConfigPtrInput interface {
	pulumi.Input

	ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutput() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput
	ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(context.Context) InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput
}

type instanceNetworkConfigPrivateServiceConnectConfigPtrType InstanceNetworkConfigPrivateServiceConnectConfigArgs

func InstanceNetworkConfigPrivateServiceConnectConfigPtr(v *InstanceNetworkConfigPrivateServiceConnectConfigArgs) InstanceNetworkConfigPrivateServiceConnectConfigPtrInput {
	return (*instanceNetworkConfigPrivateServiceConnectConfigPtrType)(v)
}

func (*instanceNetworkConfigPrivateServiceConnectConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceNetworkConfigPrivateServiceConnectConfig)(nil)).Elem()
}

func (i *instanceNetworkConfigPrivateServiceConnectConfigPtrType) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutput() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return i.ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(context.Background())
}

func (i *instanceNetworkConfigPrivateServiceConnectConfigPtrType) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput)
}

type InstanceNetworkConfigPrivateServiceConnectConfigOutput struct{ *pulumi.OutputState }

func (InstanceNetworkConfigPrivateServiceConnectConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetworkConfigPrivateServiceConnectConfig)(nil)).Elem()
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigOutput() InstanceNetworkConfigPrivateServiceConnectConfigOutput {
	return o
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigOutput {
	return o
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutput() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o.ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(context.Background())
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InstanceNetworkConfigPrivateServiceConnectConfig) *InstanceNetworkConfigPrivateServiceConnectConfig {
		return &v
	}).(InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput)
}

// (Output)
// Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
// The size of this block is /25. The format of this field is governed by RFC 4632.
func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) EffectiveUnreachableCidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfigPrivateServiceConnectConfig) *string {
		return v.EffectiveUnreachableCidrBlock
	}).(pulumi.StringPtrOutput)
}

// Optional. The reference to the network attachment used to establish private connectivity.
// It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) NetworkAttachment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfigPrivateServiceConnectConfig) *string { return v.NetworkAttachment }).(pulumi.StringPtrOutput)
}

// Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
// The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
// This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
// If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
func (o InstanceNetworkConfigPrivateServiceConnectConfigOutput) UnreachableCidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetworkConfigPrivateServiceConnectConfig) *string { return v.UnreachableCidrBlock }).(pulumi.StringPtrOutput)
}

type InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput struct{ *pulumi.OutputState }

func (InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceNetworkConfigPrivateServiceConnectConfig)(nil)).Elem()
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutput() InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) ToInstanceNetworkConfigPrivateServiceConnectConfigPtrOutputWithContext(ctx context.Context) InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput {
	return o
}

func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) Elem() InstanceNetworkConfigPrivateServiceConnectConfigOutput {
	return o.ApplyT(func(v *InstanceNetworkConfigPrivateServiceConnectConfig) InstanceNetworkConfigPrivateServiceConnectConfig {
		if v != nil {
			return *v
		}
		var ret InstanceNetworkConfigPrivateServiceConnectConfig
		return ret
	}).(InstanceNetworkConfigPrivateServiceConnectConfigOutput)
}

// (Output)
// Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
// The size of this block is /25. The format of this field is governed by RFC 4632.
func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) EffectiveUnreachableCidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfigPrivateServiceConnectConfig) *string {
		if v == nil {
			return nil
		}
		return v.EffectiveUnreachableCidrBlock
	}).(pulumi.StringPtrOutput)
}

// Optional. The reference to the network attachment used to establish private connectivity.
// It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
// This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) NetworkAttachment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfigPrivateServiceConnectConfig) *string {
		if v == nil {
			return nil
		}
		return v.NetworkAttachment
	}).(pulumi.StringPtrOutput)
}

// Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
// The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
// This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
// If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
func (o InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput) UnreachableCidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceNetworkConfigPrivateServiceConnectConfig) *string {
		if v == nil {
			return nil
		}
		return v.UnreachableCidrBlock
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceAcceleratorInput)(nil)).Elem(), InstanceAcceleratorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceAcceleratorArrayInput)(nil)).Elem(), InstanceAcceleratorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceCryptoKeyConfigInput)(nil)).Elem(), InstanceCryptoKeyConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceCryptoKeyConfigPtrInput)(nil)).Elem(), InstanceCryptoKeyConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceEventPublishConfigInput)(nil)).Elem(), InstanceEventPublishConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceEventPublishConfigPtrInput)(nil)).Elem(), InstanceEventPublishConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceNetworkConfigInput)(nil)).Elem(), InstanceNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceNetworkConfigPtrInput)(nil)).Elem(), InstanceNetworkConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceNetworkConfigPrivateServiceConnectConfigInput)(nil)).Elem(), InstanceNetworkConfigPrivateServiceConnectConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceNetworkConfigPrivateServiceConnectConfigPtrInput)(nil)).Elem(), InstanceNetworkConfigPrivateServiceConnectConfigArgs{})
	pulumi.RegisterOutputType(InstanceAcceleratorOutput{})
	pulumi.RegisterOutputType(InstanceAcceleratorArrayOutput{})
	pulumi.RegisterOutputType(InstanceCryptoKeyConfigOutput{})
	pulumi.RegisterOutputType(InstanceCryptoKeyConfigPtrOutput{})
	pulumi.RegisterOutputType(InstanceEventPublishConfigOutput{})
	pulumi.RegisterOutputType(InstanceEventPublishConfigPtrOutput{})
	pulumi.RegisterOutputType(InstanceNetworkConfigOutput{})
	pulumi.RegisterOutputType(InstanceNetworkConfigPtrOutput{})
	pulumi.RegisterOutputType(InstanceNetworkConfigPrivateServiceConnectConfigOutput{})
	pulumi.RegisterOutputType(InstanceNetworkConfigPrivateServiceConnectConfigPtrOutput{})
}
