// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datafusion

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Represents a Data Fusion instance.
//
// To get more information about Instance, see:
//
// * [API documentation](https://cloud.google.com/data-fusion/docs/reference/rest/v1beta1/projects.locations.instances)
// * How-to Guides
//   - [Official Documentation](https://cloud.google.com/data-fusion/docs/)
//
// ## Example Usage
// ### Data Fusion Instance Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datafusion.NewInstance(ctx, "basicInstance", &datafusion.InstanceArgs{
//				Region: pulumi.String("us-central1"),
//				Type:   pulumi.String("BASIC"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Data Fusion Instance Full
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/appengine"
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := appengine.GetDefaultServiceAccount(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			network, err := compute.NewNetwork(ctx, "network", nil)
//			if err != nil {
//				return err
//			}
//			privateIpAlloc, err := compute.NewGlobalAddress(ctx, "privateIpAlloc", &compute.GlobalAddressArgs{
//				AddressType:  pulumi.String("INTERNAL"),
//				Purpose:      pulumi.String("VPC_PEERING"),
//				PrefixLength: pulumi.Int(22),
//				Network:      network.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datafusion.NewInstance(ctx, "extendedInstance", &datafusion.InstanceArgs{
//				Description:                 pulumi.String("My Data Fusion instance"),
//				DisplayName:                 pulumi.String("My Data Fusion instance"),
//				Region:                      pulumi.String("us-central1"),
//				Type:                        pulumi.String("BASIC"),
//				EnableStackdriverLogging:    pulumi.Bool(true),
//				EnableStackdriverMonitoring: pulumi.Bool(true),
//				PrivateInstance:             pulumi.Bool(true),
//				DataprocServiceAccount:      *pulumi.String(_default.Email),
//				Labels: pulumi.StringMap{
//					"example_key": pulumi.String("example_value"),
//				},
//				NetworkConfig: &datafusion.InstanceNetworkConfigArgs{
//					Network: pulumi.String("default"),
//					IpAllocation: pulumi.All(privateIpAlloc.Address, privateIpAlloc.PrefixLength).ApplyT(func(_args []interface{}) (string, error) {
//						address := _args[0].(string)
//						prefixLength := _args[1].(int)
//						return fmt.Sprintf("%v/%v", address, prefixLength), nil
//					}).(pulumi.StringOutput),
//				},
//				Accelerators: datafusion.InstanceAcceleratorArray{
//					&datafusion.InstanceAcceleratorArgs{
//						AcceleratorType: pulumi.String("CDC"),
//						State:           pulumi.String("ENABLED"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Data Fusion Instance Cmek
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/kms"
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			keyRing, err := kms.NewKeyRing(ctx, "keyRing", &kms.KeyRingArgs{
//				Location: pulumi.String("us-central1"),
//			})
//			if err != nil {
//				return err
//			}
//			cryptoKey, err := kms.NewCryptoKey(ctx, "cryptoKey", &kms.CryptoKeyArgs{
//				KeyRing: keyRing.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			project, err := organizations.LookupProject(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			cryptoKeyBinding, err := kms.NewCryptoKeyIAMBinding(ctx, "cryptoKeyBinding", &kms.CryptoKeyIAMBindingArgs{
//				CryptoKeyId: cryptoKey.ID(),
//				Role:        pulumi.String("roles/cloudkms.cryptoKeyEncrypterDecrypter"),
//				Members: pulumi.StringArray{
//					pulumi.String(fmt.Sprintf("serviceAccount:service-%v@gcp-sa-datafusion.iam.gserviceaccount.com", project.Number)),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datafusion.NewInstance(ctx, "cmek", &datafusion.InstanceArgs{
//				Region: pulumi.String("us-central1"),
//				Type:   pulumi.String("BASIC"),
//				CryptoKeyConfig: &datafusion.InstanceCryptoKeyConfigArgs{
//					KeyReference: cryptoKey.ID(),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				cryptoKeyBinding,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Data Fusion Instance Enterprise
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datafusion.NewInstance(ctx, "enterpriseInstance", &datafusion.InstanceArgs{
//				EnableRbac: pulumi.Bool(true),
//				Region:     pulumi.String("us-central1"),
//				Type:       pulumi.String("ENTERPRISE"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Data Fusion Instance Event
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/pubsub"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			eventTopic, err := pubsub.NewTopic(ctx, "eventTopic", nil)
//			if err != nil {
//				return err
//			}
//			_, err = datafusion.NewInstance(ctx, "eventInstance", &datafusion.InstanceArgs{
//				Region: pulumi.String("us-central1"),
//				Type:   pulumi.String("BASIC"),
//				EventPublishConfig: &datafusion.InstanceEventPublishConfigArgs{
//					Enabled: pulumi.Bool(true),
//					Topic:   eventTopic.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Data Fusion Instance Zone
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/datafusion"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datafusion.NewInstance(ctx, "zone", &datafusion.InstanceArgs{
//				Region: pulumi.String("us-central1"),
//				Type:   pulumi.String("DEVELOPER"),
//				Zone:   pulumi.String("us-central1-a"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # Instance can be imported using any of these accepted formats
//
// ```sh
//
//	$ pulumi import gcp:datafusion/instance:Instance default projects/{{project}}/locations/{{region}}/instances/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:datafusion/instance:Instance default {{project}}/{{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:datafusion/instance:Instance default {{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:datafusion/instance:Instance default {{name}}
//
// ```
type Instance struct {
	pulumi.CustomResourceState

	// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
	// created with the Options field. Users will need to either manually update their state file to include these diffed
	// options, or include the field in a [lifecycle ignore changes
	// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
	Accelerators InstanceAcceleratorArrayOutput `pulumi:"accelerators"`
	// Endpoint on which the REST APIs is accessible.
	ApiEndpoint pulumi.StringOutput `pulumi:"apiEndpoint"`
	// The time the instance was created in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
	// Structure is documented below.
	CryptoKeyConfig InstanceCryptoKeyConfigPtrOutput `pulumi:"cryptoKeyConfig"`
	// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
	DataprocServiceAccount pulumi.StringPtrOutput `pulumi:"dataprocServiceAccount"`
	// An optional description of the instance.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Display name for an instance.
	DisplayName pulumi.StringPtrOutput `pulumi:"displayName"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
	// clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Option to enable granular role-based access control.
	EnableRbac pulumi.BoolPtrOutput `pulumi:"enableRbac"`
	// Option to enable Stackdriver Logging.
	EnableStackdriverLogging pulumi.BoolPtrOutput `pulumi:"enableStackdriverLogging"`
	// Option to enable Stackdriver Monitoring.
	EnableStackdriverMonitoring pulumi.BoolPtrOutput `pulumi:"enableStackdriverMonitoring"`
	// Option to enable and pass metadata for event publishing.
	// Structure is documented below.
	EventPublishConfig InstanceEventPublishConfigPtrOutput `pulumi:"eventPublishConfig"`
	// Cloud Storage bucket generated by Data Fusion in the customer project.
	GcsBucket pulumi.StringOutput `pulumi:"gcsBucket"`
	// The resource labels for instance to use to annotate any related underlying resources,
	// such as Compute Engine VMs.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The ID of the instance or a fully qualified identifier for the instance.
	Name pulumi.StringOutput `pulumi:"name"`
	// Network configuration options. These are required when a private Data Fusion instance is to be created.
	// Structure is documented below.
	NetworkConfig InstanceNetworkConfigPtrOutput `pulumi:"networkConfig"`
	// Map of additional options used to configure the behavior of Data Fusion instance.
	Options pulumi.StringMapOutput `pulumi:"options"`
	// P4 service account for the customer project.
	P4ServiceAccount pulumi.StringOutput `pulumi:"p4ServiceAccount"`
	// Specifies whether the Data Fusion instance should be private. If set to
	// true, all Data Fusion nodes will have private IP addresses and will not be
	// able to access the public internet.
	PrivateInstance pulumi.BoolPtrOutput `pulumi:"privateInstance"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// The region of the Data Fusion instance.
	Region pulumi.StringOutput `pulumi:"region"`
	// Service account which will be used to access resources in the customer project.
	//
	// Deprecated: `service_account` is deprecated and will be removed in a future major release. Instead, use `tenant_project_id` to extract the tenant project ID.
	ServiceAccount pulumi.StringOutput `pulumi:"serviceAccount"`
	// Endpoint on which the Data Fusion UI and REST APIs are accessible.
	ServiceEndpoint pulumi.StringOutput `pulumi:"serviceEndpoint"`
	// The type of an accelator for a CDF instance.
	// Possible values are: `ENABLED`, `DISABLED`.
	State pulumi.StringOutput `pulumi:"state"`
	// Additional information about the current state of this Data Fusion instance if available.
	StateMessage pulumi.StringOutput `pulumi:"stateMessage"`
	// The name of the tenant project.
	TenantProjectId pulumi.StringOutput `pulumi:"tenantProjectId"`
	// Represents the type of Data Fusion instance. Each type is configured with
	// the default settings for processing and memory.
	// - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
	//   using point and click UI. However, there are certain limitations, such as fewer number
	//   of concurrent pipelines, no support for streaming pipelines, etc.
	// - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
	//   available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
	// - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
	//   with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
	//   pipelines at low cost.
	//   Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
	//
	// ***
	Type pulumi.StringOutput `pulumi:"type"`
	// The time the instance was last updated in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
	// Current version of the Data Fusion.
	Version pulumi.StringOutput `pulumi:"version"`
	// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Instance
	err := ctx.RegisterResource("gcp:datafusion/instance:Instance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	var resource Instance
	err := ctx.ReadResource("gcp:datafusion/instance:Instance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type instanceState struct {
	// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
	// created with the Options field. Users will need to either manually update their state file to include these diffed
	// options, or include the field in a [lifecycle ignore changes
	// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
	Accelerators []InstanceAccelerator `pulumi:"accelerators"`
	// Endpoint on which the REST APIs is accessible.
	ApiEndpoint *string `pulumi:"apiEndpoint"`
	// The time the instance was created in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	CreateTime *string `pulumi:"createTime"`
	// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
	// Structure is documented below.
	CryptoKeyConfig *InstanceCryptoKeyConfig `pulumi:"cryptoKeyConfig"`
	// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
	DataprocServiceAccount *string `pulumi:"dataprocServiceAccount"`
	// An optional description of the instance.
	Description *string `pulumi:"description"`
	// Display name for an instance.
	DisplayName *string `pulumi:"displayName"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
	// clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Option to enable granular role-based access control.
	EnableRbac *bool `pulumi:"enableRbac"`
	// Option to enable Stackdriver Logging.
	EnableStackdriverLogging *bool `pulumi:"enableStackdriverLogging"`
	// Option to enable Stackdriver Monitoring.
	EnableStackdriverMonitoring *bool `pulumi:"enableStackdriverMonitoring"`
	// Option to enable and pass metadata for event publishing.
	// Structure is documented below.
	EventPublishConfig *InstanceEventPublishConfig `pulumi:"eventPublishConfig"`
	// Cloud Storage bucket generated by Data Fusion in the customer project.
	GcsBucket *string `pulumi:"gcsBucket"`
	// The resource labels for instance to use to annotate any related underlying resources,
	// such as Compute Engine VMs.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The ID of the instance or a fully qualified identifier for the instance.
	Name *string `pulumi:"name"`
	// Network configuration options. These are required when a private Data Fusion instance is to be created.
	// Structure is documented below.
	NetworkConfig *InstanceNetworkConfig `pulumi:"networkConfig"`
	// Map of additional options used to configure the behavior of Data Fusion instance.
	Options map[string]string `pulumi:"options"`
	// P4 service account for the customer project.
	P4ServiceAccount *string `pulumi:"p4ServiceAccount"`
	// Specifies whether the Data Fusion instance should be private. If set to
	// true, all Data Fusion nodes will have private IP addresses and will not be
	// able to access the public internet.
	PrivateInstance *bool `pulumi:"privateInstance"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// The region of the Data Fusion instance.
	Region *string `pulumi:"region"`
	// Service account which will be used to access resources in the customer project.
	//
	// Deprecated: `service_account` is deprecated and will be removed in a future major release. Instead, use `tenant_project_id` to extract the tenant project ID.
	ServiceAccount *string `pulumi:"serviceAccount"`
	// Endpoint on which the Data Fusion UI and REST APIs are accessible.
	ServiceEndpoint *string `pulumi:"serviceEndpoint"`
	// The type of an accelator for a CDF instance.
	// Possible values are: `ENABLED`, `DISABLED`.
	State *string `pulumi:"state"`
	// Additional information about the current state of this Data Fusion instance if available.
	StateMessage *string `pulumi:"stateMessage"`
	// The name of the tenant project.
	TenantProjectId *string `pulumi:"tenantProjectId"`
	// Represents the type of Data Fusion instance. Each type is configured with
	// the default settings for processing and memory.
	// - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
	//   using point and click UI. However, there are certain limitations, such as fewer number
	//   of concurrent pipelines, no support for streaming pipelines, etc.
	// - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
	//   available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
	// - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
	//   with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
	//   pipelines at low cost.
	//   Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
	//
	// ***
	Type *string `pulumi:"type"`
	// The time the instance was last updated in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	UpdateTime *string `pulumi:"updateTime"`
	// Current version of the Data Fusion.
	Version *string `pulumi:"version"`
	// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
	Zone *string `pulumi:"zone"`
}

type InstanceState struct {
	// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
	// created with the Options field. Users will need to either manually update their state file to include these diffed
	// options, or include the field in a [lifecycle ignore changes
	// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
	Accelerators InstanceAcceleratorArrayInput
	// Endpoint on which the REST APIs is accessible.
	ApiEndpoint pulumi.StringPtrInput
	// The time the instance was created in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	CreateTime pulumi.StringPtrInput
	// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
	// Structure is documented below.
	CryptoKeyConfig InstanceCryptoKeyConfigPtrInput
	// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
	DataprocServiceAccount pulumi.StringPtrInput
	// An optional description of the instance.
	Description pulumi.StringPtrInput
	// Display name for an instance.
	DisplayName pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
	// clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Option to enable granular role-based access control.
	EnableRbac pulumi.BoolPtrInput
	// Option to enable Stackdriver Logging.
	EnableStackdriverLogging pulumi.BoolPtrInput
	// Option to enable Stackdriver Monitoring.
	EnableStackdriverMonitoring pulumi.BoolPtrInput
	// Option to enable and pass metadata for event publishing.
	// Structure is documented below.
	EventPublishConfig InstanceEventPublishConfigPtrInput
	// Cloud Storage bucket generated by Data Fusion in the customer project.
	GcsBucket pulumi.StringPtrInput
	// The resource labels for instance to use to annotate any related underlying resources,
	// such as Compute Engine VMs.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The ID of the instance or a fully qualified identifier for the instance.
	Name pulumi.StringPtrInput
	// Network configuration options. These are required when a private Data Fusion instance is to be created.
	// Structure is documented below.
	NetworkConfig InstanceNetworkConfigPtrInput
	// Map of additional options used to configure the behavior of Data Fusion instance.
	Options pulumi.StringMapInput
	// P4 service account for the customer project.
	P4ServiceAccount pulumi.StringPtrInput
	// Specifies whether the Data Fusion instance should be private. If set to
	// true, all Data Fusion nodes will have private IP addresses and will not be
	// able to access the public internet.
	PrivateInstance pulumi.BoolPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// The region of the Data Fusion instance.
	Region pulumi.StringPtrInput
	// Service account which will be used to access resources in the customer project.
	//
	// Deprecated: `service_account` is deprecated and will be removed in a future major release. Instead, use `tenant_project_id` to extract the tenant project ID.
	ServiceAccount pulumi.StringPtrInput
	// Endpoint on which the Data Fusion UI and REST APIs are accessible.
	ServiceEndpoint pulumi.StringPtrInput
	// The type of an accelator for a CDF instance.
	// Possible values are: `ENABLED`, `DISABLED`.
	State pulumi.StringPtrInput
	// Additional information about the current state of this Data Fusion instance if available.
	StateMessage pulumi.StringPtrInput
	// The name of the tenant project.
	TenantProjectId pulumi.StringPtrInput
	// Represents the type of Data Fusion instance. Each type is configured with
	// the default settings for processing and memory.
	// - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
	//   using point and click UI. However, there are certain limitations, such as fewer number
	//   of concurrent pipelines, no support for streaming pipelines, etc.
	// - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
	//   available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
	// - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
	//   with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
	//   pipelines at low cost.
	//   Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
	//
	// ***
	Type pulumi.StringPtrInput
	// The time the instance was last updated in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
	UpdateTime pulumi.StringPtrInput
	// Current version of the Data Fusion.
	Version pulumi.StringPtrInput
	// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
	Zone pulumi.StringPtrInput
}

func (InstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceState)(nil)).Elem()
}

type instanceArgs struct {
	// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
	// created with the Options field. Users will need to either manually update their state file to include these diffed
	// options, or include the field in a [lifecycle ignore changes
	// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
	Accelerators []InstanceAccelerator `pulumi:"accelerators"`
	// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
	// Structure is documented below.
	CryptoKeyConfig *InstanceCryptoKeyConfig `pulumi:"cryptoKeyConfig"`
	// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
	DataprocServiceAccount *string `pulumi:"dataprocServiceAccount"`
	// An optional description of the instance.
	Description *string `pulumi:"description"`
	// Display name for an instance.
	DisplayName *string `pulumi:"displayName"`
	// Option to enable granular role-based access control.
	EnableRbac *bool `pulumi:"enableRbac"`
	// Option to enable Stackdriver Logging.
	EnableStackdriverLogging *bool `pulumi:"enableStackdriverLogging"`
	// Option to enable Stackdriver Monitoring.
	EnableStackdriverMonitoring *bool `pulumi:"enableStackdriverMonitoring"`
	// Option to enable and pass metadata for event publishing.
	// Structure is documented below.
	EventPublishConfig *InstanceEventPublishConfig `pulumi:"eventPublishConfig"`
	// The resource labels for instance to use to annotate any related underlying resources,
	// such as Compute Engine VMs.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The ID of the instance or a fully qualified identifier for the instance.
	Name *string `pulumi:"name"`
	// Network configuration options. These are required when a private Data Fusion instance is to be created.
	// Structure is documented below.
	NetworkConfig *InstanceNetworkConfig `pulumi:"networkConfig"`
	// Map of additional options used to configure the behavior of Data Fusion instance.
	Options map[string]string `pulumi:"options"`
	// Specifies whether the Data Fusion instance should be private. If set to
	// true, all Data Fusion nodes will have private IP addresses and will not be
	// able to access the public internet.
	PrivateInstance *bool `pulumi:"privateInstance"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The region of the Data Fusion instance.
	Region *string `pulumi:"region"`
	// Represents the type of Data Fusion instance. Each type is configured with
	// the default settings for processing and memory.
	// - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
	//   using point and click UI. However, there are certain limitations, such as fewer number
	//   of concurrent pipelines, no support for streaming pipelines, etc.
	// - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
	//   available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
	// - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
	//   with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
	//   pipelines at low cost.
	//   Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
	//
	// ***
	Type string `pulumi:"type"`
	// Current version of the Data Fusion.
	Version *string `pulumi:"version"`
	// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
	// created with the Options field. Users will need to either manually update their state file to include these diffed
	// options, or include the field in a [lifecycle ignore changes
	// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
	Accelerators InstanceAcceleratorArrayInput
	// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
	// Structure is documented below.
	CryptoKeyConfig InstanceCryptoKeyConfigPtrInput
	// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
	DataprocServiceAccount pulumi.StringPtrInput
	// An optional description of the instance.
	Description pulumi.StringPtrInput
	// Display name for an instance.
	DisplayName pulumi.StringPtrInput
	// Option to enable granular role-based access control.
	EnableRbac pulumi.BoolPtrInput
	// Option to enable Stackdriver Logging.
	EnableStackdriverLogging pulumi.BoolPtrInput
	// Option to enable Stackdriver Monitoring.
	EnableStackdriverMonitoring pulumi.BoolPtrInput
	// Option to enable and pass metadata for event publishing.
	// Structure is documented below.
	EventPublishConfig InstanceEventPublishConfigPtrInput
	// The resource labels for instance to use to annotate any related underlying resources,
	// such as Compute Engine VMs.
	//
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The ID of the instance or a fully qualified identifier for the instance.
	Name pulumi.StringPtrInput
	// Network configuration options. These are required when a private Data Fusion instance is to be created.
	// Structure is documented below.
	NetworkConfig InstanceNetworkConfigPtrInput
	// Map of additional options used to configure the behavior of Data Fusion instance.
	Options pulumi.StringMapInput
	// Specifies whether the Data Fusion instance should be private. If set to
	// true, all Data Fusion nodes will have private IP addresses and will not be
	// able to access the public internet.
	PrivateInstance pulumi.BoolPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The region of the Data Fusion instance.
	Region pulumi.StringPtrInput
	// Represents the type of Data Fusion instance. Each type is configured with
	// the default settings for processing and memory.
	// - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
	//   using point and click UI. However, there are certain limitations, such as fewer number
	//   of concurrent pipelines, no support for streaming pipelines, etc.
	// - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
	//   available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
	// - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
	//   with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
	//   pipelines at low cost.
	//   Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
	//
	// ***
	Type pulumi.StringInput
	// Current version of the Data Fusion.
	Version pulumi.StringPtrInput
	// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
	Zone pulumi.StringPtrInput
}

func (InstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceArgs)(nil)).Elem()
}

type InstanceInput interface {
	pulumi.Input

	ToInstanceOutput() InstanceOutput
	ToInstanceOutputWithContext(ctx context.Context) InstanceOutput
}

func (*Instance) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (i *Instance) ToInstanceOutput() InstanceOutput {
	return i.ToInstanceOutputWithContext(context.Background())
}

func (i *Instance) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceOutput)
}

func (i *Instance) ToOutput(ctx context.Context) pulumix.Output[*Instance] {
	return pulumix.Output[*Instance]{
		OutputState: i.ToInstanceOutputWithContext(ctx).OutputState,
	}
}

// InstanceArrayInput is an input type that accepts InstanceArray and InstanceArrayOutput values.
// You can construct a concrete instance of `InstanceArrayInput` via:
//
//	InstanceArray{ InstanceArgs{...} }
type InstanceArrayInput interface {
	pulumi.Input

	ToInstanceArrayOutput() InstanceArrayOutput
	ToInstanceArrayOutputWithContext(context.Context) InstanceArrayOutput
}

type InstanceArray []InstanceInput

func (InstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (i InstanceArray) ToInstanceArrayOutput() InstanceArrayOutput {
	return i.ToInstanceArrayOutputWithContext(context.Background())
}

func (i InstanceArray) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceArrayOutput)
}

func (i InstanceArray) ToOutput(ctx context.Context) pulumix.Output[[]*Instance] {
	return pulumix.Output[[]*Instance]{
		OutputState: i.ToInstanceArrayOutputWithContext(ctx).OutputState,
	}
}

// InstanceMapInput is an input type that accepts InstanceMap and InstanceMapOutput values.
// You can construct a concrete instance of `InstanceMapInput` via:
//
//	InstanceMap{ "key": InstanceArgs{...} }
type InstanceMapInput interface {
	pulumi.Input

	ToInstanceMapOutput() InstanceMapOutput
	ToInstanceMapOutputWithContext(context.Context) InstanceMapOutput
}

type InstanceMap map[string]InstanceInput

func (InstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (i InstanceMap) ToInstanceMapOutput() InstanceMapOutput {
	return i.ToInstanceMapOutputWithContext(context.Background())
}

func (i InstanceMap) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceMapOutput)
}

func (i InstanceMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Instance] {
	return pulumix.Output[map[string]*Instance]{
		OutputState: i.ToInstanceMapOutputWithContext(ctx).OutputState,
	}
}

type InstanceOutput struct{ *pulumi.OutputState }

func (InstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (o InstanceOutput) ToInstanceOutput() InstanceOutput {
	return o
}

func (o InstanceOutput) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return o
}

func (o InstanceOutput) ToOutput(ctx context.Context) pulumix.Output[*Instance] {
	return pulumix.Output[*Instance]{
		OutputState: o.OutputState,
	}
}

// List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be
// created with the Options field. Users will need to either manually update their state file to include these diffed
// options, or include the field in a [lifecycle ignore changes
// block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle#ignore_changes).
func (o InstanceOutput) Accelerators() InstanceAcceleratorArrayOutput {
	return o.ApplyT(func(v *Instance) InstanceAcceleratorArrayOutput { return v.Accelerators }).(InstanceAcceleratorArrayOutput)
}

// Endpoint on which the REST APIs is accessible.
func (o InstanceOutput) ApiEndpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.ApiEndpoint }).(pulumi.StringOutput)
}

// The time the instance was created in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
func (o InstanceOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature.
// Structure is documented below.
func (o InstanceOutput) CryptoKeyConfig() InstanceCryptoKeyConfigPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceCryptoKeyConfigPtrOutput { return v.CryptoKeyConfig }).(InstanceCryptoKeyConfigPtrOutput)
}

// User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
func (o InstanceOutput) DataprocServiceAccount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.DataprocServiceAccount }).(pulumi.StringPtrOutput)
}

// An optional description of the instance.
func (o InstanceOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Display name for an instance.
func (o InstanceOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
// clients and services.
func (o InstanceOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Option to enable granular role-based access control.
func (o InstanceOutput) EnableRbac() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.EnableRbac }).(pulumi.BoolPtrOutput)
}

// Option to enable Stackdriver Logging.
func (o InstanceOutput) EnableStackdriverLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.EnableStackdriverLogging }).(pulumi.BoolPtrOutput)
}

// Option to enable Stackdriver Monitoring.
func (o InstanceOutput) EnableStackdriverMonitoring() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.EnableStackdriverMonitoring }).(pulumi.BoolPtrOutput)
}

// Option to enable and pass metadata for event publishing.
// Structure is documented below.
func (o InstanceOutput) EventPublishConfig() InstanceEventPublishConfigPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceEventPublishConfigPtrOutput { return v.EventPublishConfig }).(InstanceEventPublishConfigPtrOutput)
}

// Cloud Storage bucket generated by Data Fusion in the customer project.
func (o InstanceOutput) GcsBucket() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.GcsBucket }).(pulumi.StringOutput)
}

// The resource labels for instance to use to annotate any related underlying resources,
// such as Compute Engine VMs.
//
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o InstanceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The ID of the instance or a fully qualified identifier for the instance.
func (o InstanceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Network configuration options. These are required when a private Data Fusion instance is to be created.
// Structure is documented below.
func (o InstanceOutput) NetworkConfig() InstanceNetworkConfigPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceNetworkConfigPtrOutput { return v.NetworkConfig }).(InstanceNetworkConfigPtrOutput)
}

// Map of additional options used to configure the behavior of Data Fusion instance.
func (o InstanceOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Options }).(pulumi.StringMapOutput)
}

// P4 service account for the customer project.
func (o InstanceOutput) P4ServiceAccount() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.P4ServiceAccount }).(pulumi.StringOutput)
}

// Specifies whether the Data Fusion instance should be private. If set to
// true, all Data Fusion nodes will have private IP addresses and will not be
// able to access the public internet.
func (o InstanceOutput) PrivateInstance() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.PrivateInstance }).(pulumi.BoolPtrOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o InstanceOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o InstanceOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// The region of the Data Fusion instance.
func (o InstanceOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Service account which will be used to access resources in the customer project.
//
// Deprecated: `service_account` is deprecated and will be removed in a future major release. Instead, use `tenant_project_id` to extract the tenant project ID.
func (o InstanceOutput) ServiceAccount() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.ServiceAccount }).(pulumi.StringOutput)
}

// Endpoint on which the Data Fusion UI and REST APIs are accessible.
func (o InstanceOutput) ServiceEndpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.ServiceEndpoint }).(pulumi.StringOutput)
}

// The type of an accelator for a CDF instance.
// Possible values are: `ENABLED`, `DISABLED`.
func (o InstanceOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Additional information about the current state of this Data Fusion instance if available.
func (o InstanceOutput) StateMessage() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.StateMessage }).(pulumi.StringOutput)
}

// The name of the tenant project.
func (o InstanceOutput) TenantProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.TenantProjectId }).(pulumi.StringOutput)
}

// Represents the type of Data Fusion instance. Each type is configured with
// the default settings for processing and memory.
//   - BASIC: Basic Data Fusion instance. In Basic type, the user will be able to create data pipelines
//     using point and click UI. However, there are certain limitations, such as fewer number
//     of concurrent pipelines, no support for streaming pipelines, etc.
//   - ENTERPRISE: Enterprise Data Fusion instance. In Enterprise type, the user will have more features
//     available, such as support for streaming pipelines, higher number of concurrent pipelines, etc.
//   - DEVELOPER: Developer Data Fusion instance. In Developer type, the user will have all features available but
//     with restrictive capabilities. This is to help enterprises design and develop their data ingestion and integration
//     pipelines at low cost.
//     Possible values are: `BASIC`, `ENTERPRISE`, `DEVELOPER`.
//
// ***
func (o InstanceOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The time the instance was last updated in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
func (o InstanceOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

// Current version of the Data Fusion.
func (o InstanceOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

// Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
func (o InstanceOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type InstanceArrayOutput struct{ *pulumi.OutputState }

func (InstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (o InstanceArrayOutput) ToInstanceArrayOutput() InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Instance] {
	return pulumix.Output[[]*Instance]{
		OutputState: o.OutputState,
	}
}

func (o InstanceArrayOutput) Index(i pulumi.IntInput) InstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].([]*Instance)[vs[1].(int)]
	}).(InstanceOutput)
}

type InstanceMapOutput struct{ *pulumi.OutputState }

func (InstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (o InstanceMapOutput) ToInstanceMapOutput() InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Instance] {
	return pulumix.Output[map[string]*Instance]{
		OutputState: o.OutputState,
	}
}

func (o InstanceMapOutput) MapIndex(k pulumi.StringInput) InstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].(map[string]*Instance)[vs[1].(string)]
	}).(InstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceInput)(nil)).Elem(), &Instance{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceArrayInput)(nil)).Elem(), InstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceMapInput)(nil)).Elem(), InstanceMap{})
	pulumi.RegisterOutputType(InstanceOutput{})
	pulumi.RegisterOutputType(InstanceArrayOutput{})
	pulumi.RegisterOutputType(InstanceMapOutput{})
}
