// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Target Pool within GCE. This is a collection of instances used as
// target of a network load balancer (Forwarding Rule). For more information see
// [the official
// documentation](https://cloud.google.com/compute/docs/load-balancing/network/target-pools)
// and [API](https://cloud.google.com/compute/docs/reference/latest/targetPools).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
//				Name:             pulumi.String("default"),
//				RequestPath:      pulumi.String("/"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewTargetPool(ctx, "default", &compute.TargetPoolArgs{
//				Name: pulumi.String("instance-pool"),
//				Instances: pulumi.StringArray{
//					pulumi.String("us-central1-a/myinstance1"),
//					pulumi.String("us-central1-b/myinstance2"),
//				},
//				HealthChecks: defaultHttpHealthCheck.Name,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Target pools can be imported using any of the following formats:
//
// * `projects/{{project}}/regions/{{region}}/targetPools/{{name}}`
//
// * `{{project}}/{{region}}/{{name}}`
//
// * `{{region}}/{{name}}`
//
// * `{{name}}`
//
// When using the `pulumi import` command, target pools can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:compute/targetPool:TargetPool default projects/{{project}}/regions/{{region}}/targetPools/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/targetPool:TargetPool default {{project}}/{{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/targetPool:TargetPool default {{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/targetPool:TargetPool default {{name}}
// ```
type TargetPool struct {
	pulumi.CustomResourceState

	// URL to the backup target pool. Must also set
	// failover_ratio.
	BackupPool pulumi.StringPtrOutput `pulumi:"backupPool"`
	// Textual description field.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Ratio (0 to 1) of failed nodes before using the
	// backup pool (which must also be set).
	FailoverRatio pulumi.Float64PtrOutput `pulumi:"failoverRatio"`
	// List of zero or one health check name or self_link. Only
	// legacy `compute.HttpHealthCheck` is supported.
	HealthChecks pulumi.StringPtrOutput `pulumi:"healthChecks"`
	// List of instances in the pool. They can be given as
	// URLs, or in the form of "zone/name". Note that the instances need not exist
	// at the time of target pool creation, so there is no need to use the
	// interpolation to create a dependency on the instances from the
	// target pool.
	Instances pulumi.StringArrayOutput `pulumi:"instances"`
	// A unique name for the resource, required by GCE. Changing
	// this forces a new resource to be created.
	//
	// ***
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// Where the target pool resides. Defaults to project
	// region.
	Region pulumi.StringOutput `pulumi:"region"`
	// The resource URL for the security policy associated with this target pool.
	SecurityPolicy pulumi.StringPtrOutput `pulumi:"securityPolicy"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// How to distribute load. Options are "NONE" (no
	// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
	// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
	SessionAffinity pulumi.StringPtrOutput `pulumi:"sessionAffinity"`
}

// NewTargetPool registers a new resource with the given unique name, arguments, and options.
func NewTargetPool(ctx *pulumi.Context,
	name string, args *TargetPoolArgs, opts ...pulumi.ResourceOption) (*TargetPool, error) {
	if args == nil {
		args = &TargetPoolArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TargetPool
	err := ctx.RegisterResource("gcp:compute/targetPool:TargetPool", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTargetPool gets an existing TargetPool resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTargetPool(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TargetPoolState, opts ...pulumi.ResourceOption) (*TargetPool, error) {
	var resource TargetPool
	err := ctx.ReadResource("gcp:compute/targetPool:TargetPool", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TargetPool resources.
type targetPoolState struct {
	// URL to the backup target pool. Must also set
	// failover_ratio.
	BackupPool *string `pulumi:"backupPool"`
	// Textual description field.
	Description *string `pulumi:"description"`
	// Ratio (0 to 1) of failed nodes before using the
	// backup pool (which must also be set).
	FailoverRatio *float64 `pulumi:"failoverRatio"`
	// List of zero or one health check name or self_link. Only
	// legacy `compute.HttpHealthCheck` is supported.
	HealthChecks *string `pulumi:"healthChecks"`
	// List of instances in the pool. They can be given as
	// URLs, or in the form of "zone/name". Note that the instances need not exist
	// at the time of target pool creation, so there is no need to use the
	// interpolation to create a dependency on the instances from the
	// target pool.
	Instances []string `pulumi:"instances"`
	// A unique name for the resource, required by GCE. Changing
	// this forces a new resource to be created.
	//
	// ***
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Where the target pool resides. Defaults to project
	// region.
	Region *string `pulumi:"region"`
	// The resource URL for the security policy associated with this target pool.
	SecurityPolicy *string `pulumi:"securityPolicy"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// How to distribute load. Options are "NONE" (no
	// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
	// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
	SessionAffinity *string `pulumi:"sessionAffinity"`
}

type TargetPoolState struct {
	// URL to the backup target pool. Must also set
	// failover_ratio.
	BackupPool pulumi.StringPtrInput
	// Textual description field.
	Description pulumi.StringPtrInput
	// Ratio (0 to 1) of failed nodes before using the
	// backup pool (which must also be set).
	FailoverRatio pulumi.Float64PtrInput
	// List of zero or one health check name or self_link. Only
	// legacy `compute.HttpHealthCheck` is supported.
	HealthChecks pulumi.StringPtrInput
	// List of instances in the pool. They can be given as
	// URLs, or in the form of "zone/name". Note that the instances need not exist
	// at the time of target pool creation, so there is no need to use the
	// interpolation to create a dependency on the instances from the
	// target pool.
	Instances pulumi.StringArrayInput
	// A unique name for the resource, required by GCE. Changing
	// this forces a new resource to be created.
	//
	// ***
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Where the target pool resides. Defaults to project
	// region.
	Region pulumi.StringPtrInput
	// The resource URL for the security policy associated with this target pool.
	SecurityPolicy pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// How to distribute load. Options are "NONE" (no
	// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
	// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
	SessionAffinity pulumi.StringPtrInput
}

func (TargetPoolState) ElementType() reflect.Type {
	return reflect.TypeOf((*targetPoolState)(nil)).Elem()
}

type targetPoolArgs struct {
	// URL to the backup target pool. Must also set
	// failover_ratio.
	BackupPool *string `pulumi:"backupPool"`
	// Textual description field.
	Description *string `pulumi:"description"`
	// Ratio (0 to 1) of failed nodes before using the
	// backup pool (which must also be set).
	FailoverRatio *float64 `pulumi:"failoverRatio"`
	// List of zero or one health check name or self_link. Only
	// legacy `compute.HttpHealthCheck` is supported.
	HealthChecks *string `pulumi:"healthChecks"`
	// List of instances in the pool. They can be given as
	// URLs, or in the form of "zone/name". Note that the instances need not exist
	// at the time of target pool creation, so there is no need to use the
	// interpolation to create a dependency on the instances from the
	// target pool.
	Instances []string `pulumi:"instances"`
	// A unique name for the resource, required by GCE. Changing
	// this forces a new resource to be created.
	//
	// ***
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Where the target pool resides. Defaults to project
	// region.
	Region *string `pulumi:"region"`
	// The resource URL for the security policy associated with this target pool.
	SecurityPolicy *string `pulumi:"securityPolicy"`
	// How to distribute load. Options are "NONE" (no
	// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
	// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
	SessionAffinity *string `pulumi:"sessionAffinity"`
}

// The set of arguments for constructing a TargetPool resource.
type TargetPoolArgs struct {
	// URL to the backup target pool. Must also set
	// failover_ratio.
	BackupPool pulumi.StringPtrInput
	// Textual description field.
	Description pulumi.StringPtrInput
	// Ratio (0 to 1) of failed nodes before using the
	// backup pool (which must also be set).
	FailoverRatio pulumi.Float64PtrInput
	// List of zero or one health check name or self_link. Only
	// legacy `compute.HttpHealthCheck` is supported.
	HealthChecks pulumi.StringPtrInput
	// List of instances in the pool. They can be given as
	// URLs, or in the form of "zone/name". Note that the instances need not exist
	// at the time of target pool creation, so there is no need to use the
	// interpolation to create a dependency on the instances from the
	// target pool.
	Instances pulumi.StringArrayInput
	// A unique name for the resource, required by GCE. Changing
	// this forces a new resource to be created.
	//
	// ***
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Where the target pool resides. Defaults to project
	// region.
	Region pulumi.StringPtrInput
	// The resource URL for the security policy associated with this target pool.
	SecurityPolicy pulumi.StringPtrInput
	// How to distribute load. Options are "NONE" (no
	// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
	// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
	SessionAffinity pulumi.StringPtrInput
}

func (TargetPoolArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*targetPoolArgs)(nil)).Elem()
}

type TargetPoolInput interface {
	pulumi.Input

	ToTargetPoolOutput() TargetPoolOutput
	ToTargetPoolOutputWithContext(ctx context.Context) TargetPoolOutput
}

func (*TargetPool) ElementType() reflect.Type {
	return reflect.TypeOf((**TargetPool)(nil)).Elem()
}

func (i *TargetPool) ToTargetPoolOutput() TargetPoolOutput {
	return i.ToTargetPoolOutputWithContext(context.Background())
}

func (i *TargetPool) ToTargetPoolOutputWithContext(ctx context.Context) TargetPoolOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetPoolOutput)
}

// TargetPoolArrayInput is an input type that accepts TargetPoolArray and TargetPoolArrayOutput values.
// You can construct a concrete instance of `TargetPoolArrayInput` via:
//
//	TargetPoolArray{ TargetPoolArgs{...} }
type TargetPoolArrayInput interface {
	pulumi.Input

	ToTargetPoolArrayOutput() TargetPoolArrayOutput
	ToTargetPoolArrayOutputWithContext(context.Context) TargetPoolArrayOutput
}

type TargetPoolArray []TargetPoolInput

func (TargetPoolArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TargetPool)(nil)).Elem()
}

func (i TargetPoolArray) ToTargetPoolArrayOutput() TargetPoolArrayOutput {
	return i.ToTargetPoolArrayOutputWithContext(context.Background())
}

func (i TargetPoolArray) ToTargetPoolArrayOutputWithContext(ctx context.Context) TargetPoolArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetPoolArrayOutput)
}

// TargetPoolMapInput is an input type that accepts TargetPoolMap and TargetPoolMapOutput values.
// You can construct a concrete instance of `TargetPoolMapInput` via:
//
//	TargetPoolMap{ "key": TargetPoolArgs{...} }
type TargetPoolMapInput interface {
	pulumi.Input

	ToTargetPoolMapOutput() TargetPoolMapOutput
	ToTargetPoolMapOutputWithContext(context.Context) TargetPoolMapOutput
}

type TargetPoolMap map[string]TargetPoolInput

func (TargetPoolMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TargetPool)(nil)).Elem()
}

func (i TargetPoolMap) ToTargetPoolMapOutput() TargetPoolMapOutput {
	return i.ToTargetPoolMapOutputWithContext(context.Background())
}

func (i TargetPoolMap) ToTargetPoolMapOutputWithContext(ctx context.Context) TargetPoolMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetPoolMapOutput)
}

type TargetPoolOutput struct{ *pulumi.OutputState }

func (TargetPoolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TargetPool)(nil)).Elem()
}

func (o TargetPoolOutput) ToTargetPoolOutput() TargetPoolOutput {
	return o
}

func (o TargetPoolOutput) ToTargetPoolOutputWithContext(ctx context.Context) TargetPoolOutput {
	return o
}

// URL to the backup target pool. Must also set
// failover_ratio.
func (o TargetPoolOutput) BackupPool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringPtrOutput { return v.BackupPool }).(pulumi.StringPtrOutput)
}

// Textual description field.
func (o TargetPoolOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Ratio (0 to 1) of failed nodes before using the
// backup pool (which must also be set).
func (o TargetPoolOutput) FailoverRatio() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.Float64PtrOutput { return v.FailoverRatio }).(pulumi.Float64PtrOutput)
}

// List of zero or one health check name or self_link. Only
// legacy `compute.HttpHealthCheck` is supported.
func (o TargetPoolOutput) HealthChecks() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringPtrOutput { return v.HealthChecks }).(pulumi.StringPtrOutput)
}

// List of instances in the pool. They can be given as
// URLs, or in the form of "zone/name". Note that the instances need not exist
// at the time of target pool creation, so there is no need to use the
// interpolation to create a dependency on the instances from the
// target pool.
func (o TargetPoolOutput) Instances() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringArrayOutput { return v.Instances }).(pulumi.StringArrayOutput)
}

// A unique name for the resource, required by GCE. Changing
// this forces a new resource to be created.
//
// ***
func (o TargetPoolOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs. If it
// is not provided, the provider project is used.
func (o TargetPoolOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Where the target pool resides. Defaults to project
// region.
func (o TargetPoolOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The resource URL for the security policy associated with this target pool.
func (o TargetPoolOutput) SecurityPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringPtrOutput { return v.SecurityPolicy }).(pulumi.StringPtrOutput)
}

// The URI of the created resource.
func (o TargetPoolOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// How to distribute load. Options are "NONE" (no
// affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and
// "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
func (o TargetPoolOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TargetPool) pulumi.StringPtrOutput { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

type TargetPoolArrayOutput struct{ *pulumi.OutputState }

func (TargetPoolArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TargetPool)(nil)).Elem()
}

func (o TargetPoolArrayOutput) ToTargetPoolArrayOutput() TargetPoolArrayOutput {
	return o
}

func (o TargetPoolArrayOutput) ToTargetPoolArrayOutputWithContext(ctx context.Context) TargetPoolArrayOutput {
	return o
}

func (o TargetPoolArrayOutput) Index(i pulumi.IntInput) TargetPoolOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TargetPool {
		return vs[0].([]*TargetPool)[vs[1].(int)]
	}).(TargetPoolOutput)
}

type TargetPoolMapOutput struct{ *pulumi.OutputState }

func (TargetPoolMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TargetPool)(nil)).Elem()
}

func (o TargetPoolMapOutput) ToTargetPoolMapOutput() TargetPoolMapOutput {
	return o
}

func (o TargetPoolMapOutput) ToTargetPoolMapOutputWithContext(ctx context.Context) TargetPoolMapOutput {
	return o
}

func (o TargetPoolMapOutput) MapIndex(k pulumi.StringInput) TargetPoolOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TargetPool {
		return vs[0].(map[string]*TargetPool)[vs[1].(string)]
	}).(TargetPoolOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TargetPoolInput)(nil)).Elem(), &TargetPool{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetPoolArrayInput)(nil)).Elem(), TargetPoolArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetPoolMapInput)(nil)).Elem(), TargetPoolMap{})
	pulumi.RegisterOutputType(TargetPoolOutput{})
	pulumi.RegisterOutputType(TargetPoolArrayOutput{})
	pulumi.RegisterOutputType(TargetPoolMapOutput{})
}
