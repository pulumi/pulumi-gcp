// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a ServiceAttachment resource.
//
// To get more information about ServiceAttachment, see:
//
// * [API documentation](https://cloud.google.com/compute/docs/reference/beta/serviceAttachments)
// * How-to Guides
//     * [Configuring Private Service Connect to access services](https://cloud.google.com/vpc/docs/configure-private-service-connect-services)
//
// ## Example Usage
// ### Service Attachment Basic
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producerServiceHealthCheck", &compute.HealthCheckArgs{
// 			CheckIntervalSec: pulumi.Int(1),
// 			TimeoutSec:       pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(80),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producerServiceBackend", &compute.RegionBackendServiceArgs{
// 			Region: pulumi.String("us-west2"),
// 			HealthChecks: pulumi.String{
// 				producerServiceHealthCheck.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbNetwork, err := compute.NewNetwork(ctx, "pscIlbNetwork", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "pscIlbProducerSubnetwork", &compute.SubnetworkArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Network:     pscIlbNetwork.ID(),
// 			IpCidrRange: pulumi.String("10.0.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbTargetService, err := compute.NewForwardingRule(ctx, "pscIlbTargetService", &compute.ForwardingRuleArgs{
// 			Region:              pulumi.String("us-west2"),
// 			LoadBalancingScheme: pulumi.String("INTERNAL"),
// 			BackendService:      producerServiceBackend.ID(),
// 			AllPorts:            pulumi.Bool(true),
// 			Network:             pscIlbNetwork.Name,
// 			Subnetwork:          pscIlbProducerSubnetwork.Name,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbNat, err := compute.NewSubnetwork(ctx, "pscIlbNat", &compute.SubnetworkArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Network:     pscIlbNetwork.ID(),
// 			Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
// 			IpCidrRange: pulumi.String("10.1.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbServiceAttachment, err := compute.NewServiceAttachment(ctx, "pscIlbServiceAttachment", &compute.ServiceAttachmentArgs{
// 			Region:               pulumi.String("us-west2"),
// 			Description:          pulumi.String("A service attachment configured with Terraform"),
// 			EnableProxyProtocol:  pulumi.Bool(true),
// 			ConnectionPreference: pulumi.String("ACCEPT_AUTOMATIC"),
// 			NatSubnets: pulumi.StringArray{
// 				pscIlbNat.ID(),
// 			},
// 			TargetService: pscIlbTargetService.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbConsumerAddress, err := compute.NewAddress(ctx, "pscIlbConsumerAddress", &compute.AddressArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Subnetwork:  pulumi.String("default"),
// 			AddressType: pulumi.String("INTERNAL"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewForwardingRule(ctx, "pscIlbConsumer", &compute.ForwardingRuleArgs{
// 			Region:              pulumi.String("us-west2"),
// 			Target:              pscIlbServiceAttachment.ID(),
// 			LoadBalancingScheme: pulumi.String(""),
// 			Network:             pulumi.String("default"),
// 			IpAddress:           pscIlbConsumerAddress.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Service Attachment Explicit Projects
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producerServiceHealthCheck", &compute.HealthCheckArgs{
// 			CheckIntervalSec: pulumi.Int(1),
// 			TimeoutSec:       pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(80),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producerServiceBackend", &compute.RegionBackendServiceArgs{
// 			Region: pulumi.String("us-west2"),
// 			HealthChecks: pulumi.String{
// 				producerServiceHealthCheck.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbNetwork, err := compute.NewNetwork(ctx, "pscIlbNetwork", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "pscIlbProducerSubnetwork", &compute.SubnetworkArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Network:     pscIlbNetwork.ID(),
// 			IpCidrRange: pulumi.String("10.0.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbTargetService, err := compute.NewForwardingRule(ctx, "pscIlbTargetService", &compute.ForwardingRuleArgs{
// 			Region:              pulumi.String("us-west2"),
// 			LoadBalancingScheme: pulumi.String("INTERNAL"),
// 			BackendService:      producerServiceBackend.ID(),
// 			AllPorts:            pulumi.Bool(true),
// 			Network:             pscIlbNetwork.Name,
// 			Subnetwork:          pscIlbProducerSubnetwork.Name,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbNat, err := compute.NewSubnetwork(ctx, "pscIlbNat", &compute.SubnetworkArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Network:     pscIlbNetwork.ID(),
// 			Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
// 			IpCidrRange: pulumi.String("10.1.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbServiceAttachment, err := compute.NewServiceAttachment(ctx, "pscIlbServiceAttachment", &compute.ServiceAttachmentArgs{
// 			Region:               pulumi.String("us-west2"),
// 			Description:          pulumi.String("A service attachment configured with Terraform"),
// 			EnableProxyProtocol:  pulumi.Bool(true),
// 			ConnectionPreference: pulumi.String("ACCEPT_MANUAL"),
// 			NatSubnets: pulumi.StringArray{
// 				pscIlbNat.ID(),
// 			},
// 			TargetService: pscIlbTargetService.ID(),
// 			ConsumerRejectLists: pulumi.StringArray{
// 				pulumi.String("673497134629"),
// 				pulumi.String("482878270665"),
// 			},
// 			ConsumerAcceptLists: compute.ServiceAttachmentConsumerAcceptListArray{
// 				&compute.ServiceAttachmentConsumerAcceptListArgs{
// 					ProjectIdOrNum:  pulumi.String("658859330310"),
// 					ConnectionLimit: pulumi.Int(4),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		pscIlbConsumerAddress, err := compute.NewAddress(ctx, "pscIlbConsumerAddress", &compute.AddressArgs{
// 			Region:      pulumi.String("us-west2"),
// 			Subnetwork:  pulumi.String("default"),
// 			AddressType: pulumi.String("INTERNAL"),
// 			Address:     pulumi.String("10.168.1.17"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewForwardingRule(ctx, "pscIlbConsumer", &compute.ForwardingRuleArgs{
// 			Region:              pulumi.String("us-west2"),
// 			Target:              pscIlbServiceAttachment.ID(),
// 			LoadBalancingScheme: pulumi.String(""),
// 			Network:             pulumi.String("default"),
// 			IpAddress:           pscIlbConsumerAddress.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ServiceAttachment can be imported using any of these accepted formats
//
// ```sh
//  $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default projects/{{project}}/regions/{{region}}/serviceAttachments/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{project}}/{{region}}/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{region}}/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{name}}
// ```
type ServiceAttachment struct {
	pulumi.CustomResourceState

	// An array of the consumer forwarding rules connected to this service attachment.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayOutput `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringOutput `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayOutput `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayOutput `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolOutput `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during updates of this resource.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringOutput `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayOutput `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// URL of the region where the resource resides.
	Region pulumi.StringOutput `pulumi:"region"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringOutput `pulumi:"targetService"`
}

// NewServiceAttachment registers a new resource with the given unique name, arguments, and options.
func NewServiceAttachment(ctx *pulumi.Context,
	name string, args *ServiceAttachmentArgs, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionPreference == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionPreference'")
	}
	if args.EnableProxyProtocol == nil {
		return nil, errors.New("invalid value for required argument 'EnableProxyProtocol'")
	}
	if args.NatSubnets == nil {
		return nil, errors.New("invalid value for required argument 'NatSubnets'")
	}
	if args.TargetService == nil {
		return nil, errors.New("invalid value for required argument 'TargetService'")
	}
	var resource ServiceAttachment
	err := ctx.RegisterResource("gcp:compute/serviceAttachment:ServiceAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceAttachment gets an existing ServiceAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceAttachmentState, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	var resource ServiceAttachment
	err := ctx.ReadResource("gcp:compute/serviceAttachment:ServiceAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceAttachment resources.
type serviceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service attachment.
	ConnectedEndpoints []ServiceAttachmentConnectedEndpoint `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference *string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol *bool `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during updates of this resource.
	Fingerprint *string `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService *string `pulumi:"targetService"`
}

type ServiceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service attachment.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayInput
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringPtrInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolPtrInput
	// Fingerprint of this resource. This field is used internally during updates of this resource.
	Fingerprint pulumi.StringPtrInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringPtrInput
}

func (ServiceAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentState)(nil)).Elem()
}

type serviceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol bool `pulumi:"enableProxyProtocol"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService string `pulumi:"targetService"`
}

// The set of arguments for constructing a ServiceAttachment resource.
type ServiceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringInput
}

func (ServiceAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentArgs)(nil)).Elem()
}

type ServiceAttachmentInput interface {
	pulumi.Input

	ToServiceAttachmentOutput() ServiceAttachmentOutput
	ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput
}

func (*ServiceAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAttachment)(nil))
}

func (i *ServiceAttachment) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return i.ToServiceAttachmentOutputWithContext(context.Background())
}

func (i *ServiceAttachment) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentOutput)
}

func (i *ServiceAttachment) ToServiceAttachmentPtrOutput() ServiceAttachmentPtrOutput {
	return i.ToServiceAttachmentPtrOutputWithContext(context.Background())
}

func (i *ServiceAttachment) ToServiceAttachmentPtrOutputWithContext(ctx context.Context) ServiceAttachmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentPtrOutput)
}

type ServiceAttachmentPtrInput interface {
	pulumi.Input

	ToServiceAttachmentPtrOutput() ServiceAttachmentPtrOutput
	ToServiceAttachmentPtrOutputWithContext(ctx context.Context) ServiceAttachmentPtrOutput
}

type serviceAttachmentPtrType ServiceAttachmentArgs

func (*serviceAttachmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil))
}

func (i *serviceAttachmentPtrType) ToServiceAttachmentPtrOutput() ServiceAttachmentPtrOutput {
	return i.ToServiceAttachmentPtrOutputWithContext(context.Background())
}

func (i *serviceAttachmentPtrType) ToServiceAttachmentPtrOutputWithContext(ctx context.Context) ServiceAttachmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentPtrOutput)
}

// ServiceAttachmentArrayInput is an input type that accepts ServiceAttachmentArray and ServiceAttachmentArrayOutput values.
// You can construct a concrete instance of `ServiceAttachmentArrayInput` via:
//
//          ServiceAttachmentArray{ ServiceAttachmentArgs{...} }
type ServiceAttachmentArrayInput interface {
	pulumi.Input

	ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput
	ToServiceAttachmentArrayOutputWithContext(context.Context) ServiceAttachmentArrayOutput
}

type ServiceAttachmentArray []ServiceAttachmentInput

func (ServiceAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return i.ToServiceAttachmentArrayOutputWithContext(context.Background())
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentArrayOutput)
}

// ServiceAttachmentMapInput is an input type that accepts ServiceAttachmentMap and ServiceAttachmentMapOutput values.
// You can construct a concrete instance of `ServiceAttachmentMapInput` via:
//
//          ServiceAttachmentMap{ "key": ServiceAttachmentArgs{...} }
type ServiceAttachmentMapInput interface {
	pulumi.Input

	ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput
	ToServiceAttachmentMapOutputWithContext(context.Context) ServiceAttachmentMapOutput
}

type ServiceAttachmentMap map[string]ServiceAttachmentInput

func (ServiceAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return i.ToServiceAttachmentMapOutputWithContext(context.Background())
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentMapOutput)
}

type ServiceAttachmentOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAttachment)(nil))
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return o
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return o
}

func (o ServiceAttachmentOutput) ToServiceAttachmentPtrOutput() ServiceAttachmentPtrOutput {
	return o.ToServiceAttachmentPtrOutputWithContext(context.Background())
}

func (o ServiceAttachmentOutput) ToServiceAttachmentPtrOutputWithContext(ctx context.Context) ServiceAttachmentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceAttachment) *ServiceAttachment {
		return &v
	}).(ServiceAttachmentPtrOutput)
}

type ServiceAttachmentPtrOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil))
}

func (o ServiceAttachmentPtrOutput) ToServiceAttachmentPtrOutput() ServiceAttachmentPtrOutput {
	return o
}

func (o ServiceAttachmentPtrOutput) ToServiceAttachmentPtrOutputWithContext(ctx context.Context) ServiceAttachmentPtrOutput {
	return o
}

func (o ServiceAttachmentPtrOutput) Elem() ServiceAttachmentOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachment {
		if v != nil {
			return *v
		}
		var ret ServiceAttachment
		return ret
	}).(ServiceAttachmentOutput)
}

type ServiceAttachmentArrayOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceAttachment)(nil))
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) Index(i pulumi.IntInput) ServiceAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceAttachment {
		return vs[0].([]ServiceAttachment)[vs[1].(int)]
	}).(ServiceAttachmentOutput)
}

type ServiceAttachmentMapOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ServiceAttachment)(nil))
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) MapIndex(k pulumi.StringInput) ServiceAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ServiceAttachment {
		return vs[0].(map[string]ServiceAttachment)[vs[1].(string)]
	}).(ServiceAttachmentOutput)
}

func init() {
	pulumi.RegisterOutputType(ServiceAttachmentOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentPtrOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentArrayOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentMapOutput{})
}
