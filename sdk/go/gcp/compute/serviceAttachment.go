// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a ServiceAttachment resource.
//
// To get more information about ServiceAttachment, see:
//
// * [API documentation](https://cloud.google.com/compute/docs/reference/beta/serviceAttachments)
// * How-to Guides
//   - [Configuring Private Service Connect to access services](https://cloud.google.com/vpc/docs/configure-private-service-connect-services)
//
// ## Example Usage
//
// ### Service Attachment Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producer_service_health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("producer-service-health-check"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producer_service_backend", &compute.RegionBackendServiceArgs{
//				Name:         pulumi.String("producer-service"),
//				Region:       pulumi.String("us-west2"),
//				HealthChecks: producerServiceHealthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNetwork, err := compute.NewNetwork(ctx, "psc_ilb_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_producer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-producer-subnetwork"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbTargetService, err := compute.NewForwardingRule(ctx, "psc_ilb_target_service", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("producer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				LoadBalancingScheme: pulumi.String("INTERNAL"),
//				BackendService:      producerServiceBackend.ID(),
//				AllPorts:            pulumi.Bool(true),
//				Network:             pscIlbNetwork.Name,
//				Subnetwork:          pscIlbProducerSubnetwork.Name,
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNat, err := compute.NewSubnetwork(ctx, "psc_ilb_nat", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-nat"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbServiceAttachment, err := compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:        pulumi.String("my-psc-ilb"),
//				Region:      pulumi.String("us-west2"),
//				Description: pulumi.String("A service attachment configured with Terraform"),
//				DomainNames: pulumi.StringArray{
//					pulumi.String("gcp.tfacc.hashicorptest.com."),
//				},
//				EnableProxyProtocol:  pulumi.Bool(true),
//				ConnectionPreference: pulumi.String("ACCEPT_AUTOMATIC"),
//				NatSubnets: pulumi.StringArray{
//					pscIlbNat.ID(),
//				},
//				TargetService: pscIlbTargetService.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbConsumerAddress, err := compute.NewAddress(ctx, "psc_ilb_consumer_address", &compute.AddressArgs{
//				Name:        pulumi.String("psc-ilb-consumer-address"),
//				Region:      pulumi.String("us-west2"),
//				Subnetwork:  pulumi.String("default"),
//				AddressType: pulumi.String("INTERNAL"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewForwardingRule(ctx, "psc_ilb_consumer", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("psc-ilb-consumer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				Target:              pscIlbServiceAttachment.ID(),
//				LoadBalancingScheme: pulumi.String(""),
//				Network:             pulumi.String("default"),
//				IpAddress:           pscIlbConsumerAddress.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Service Attachment Explicit Projects
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producer_service_health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("producer-service-health-check"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producer_service_backend", &compute.RegionBackendServiceArgs{
//				Name:         pulumi.String("producer-service"),
//				Region:       pulumi.String("us-west2"),
//				HealthChecks: producerServiceHealthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNetwork, err := compute.NewNetwork(ctx, "psc_ilb_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_producer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-producer-subnetwork"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbTargetService, err := compute.NewForwardingRule(ctx, "psc_ilb_target_service", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("producer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				LoadBalancingScheme: pulumi.String("INTERNAL"),
//				BackendService:      producerServiceBackend.ID(),
//				AllPorts:            pulumi.Bool(true),
//				Network:             pscIlbNetwork.Name,
//				Subnetwork:          pscIlbProducerSubnetwork.Name,
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNat, err := compute.NewSubnetwork(ctx, "psc_ilb_nat", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-nat"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbServiceAttachment, err := compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:        pulumi.String("my-psc-ilb"),
//				Region:      pulumi.String("us-west2"),
//				Description: pulumi.String("A service attachment configured with Terraform"),
//				DomainNames: pulumi.StringArray{
//					pulumi.String("gcp.tfacc.hashicorptest.com."),
//				},
//				EnableProxyProtocol:  pulumi.Bool(true),
//				ConnectionPreference: pulumi.String("ACCEPT_MANUAL"),
//				NatSubnets: pulumi.StringArray{
//					pscIlbNat.ID(),
//				},
//				TargetService: pscIlbTargetService.ID(),
//				ConsumerRejectLists: pulumi.StringArray{
//					pulumi.String("673497134629"),
//					pulumi.String("482878270665"),
//				},
//				ConsumerAcceptLists: compute.ServiceAttachmentConsumerAcceptListArray{
//					&compute.ServiceAttachmentConsumerAcceptListArgs{
//						ProjectIdOrNum:  pulumi.String("658859330310"),
//						ConnectionLimit: pulumi.Int(4),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbConsumerAddress, err := compute.NewAddress(ctx, "psc_ilb_consumer_address", &compute.AddressArgs{
//				Name:        pulumi.String("psc-ilb-consumer-address"),
//				Region:      pulumi.String("us-west2"),
//				Subnetwork:  pulumi.String("default"),
//				AddressType: pulumi.String("INTERNAL"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewForwardingRule(ctx, "psc_ilb_consumer", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("psc-ilb-consumer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				Target:              pscIlbServiceAttachment.ID(),
//				LoadBalancingScheme: pulumi.String(""),
//				Network:             pulumi.String("default"),
//				IpAddress:           pscIlbConsumerAddress.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Service Attachment Explicit Networks
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pscIlbConsumerNetwork, err := compute.NewNetwork(ctx, "psc_ilb_consumer_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-consumer-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producer_service_health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("producer-service-health-check"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producer_service_backend", &compute.RegionBackendServiceArgs{
//				Name:         pulumi.String("producer-service"),
//				Region:       pulumi.String("us-west2"),
//				HealthChecks: producerServiceHealthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNetwork, err := compute.NewNetwork(ctx, "psc_ilb_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_producer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-producer-subnetwork"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbTargetService, err := compute.NewForwardingRule(ctx, "psc_ilb_target_service", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("producer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				LoadBalancingScheme: pulumi.String("INTERNAL"),
//				BackendService:      producerServiceBackend.ID(),
//				AllPorts:            pulumi.Bool(true),
//				Network:             pscIlbNetwork.Name,
//				Subnetwork:          pscIlbProducerSubnetwork.Name,
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNat, err := compute.NewSubnetwork(ctx, "psc_ilb_nat", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-nat"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbServiceAttachment, err := compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:                 pulumi.String("my-psc-ilb"),
//				Region:               pulumi.String("us-west2"),
//				Description:          pulumi.String("A service attachment configured with Terraform"),
//				EnableProxyProtocol:  pulumi.Bool(false),
//				ConnectionPreference: pulumi.String("ACCEPT_MANUAL"),
//				NatSubnets: pulumi.StringArray{
//					pscIlbNat.ID(),
//				},
//				TargetService: pscIlbTargetService.ID(),
//				ConsumerAcceptLists: compute.ServiceAttachmentConsumerAcceptListArray{
//					&compute.ServiceAttachmentConsumerAcceptListArgs{
//						NetworkUrl:      pscIlbConsumerNetwork.SelfLink,
//						ConnectionLimit: pulumi.Int(1),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbConsumerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_consumer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-consumer-network"),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbConsumerNetwork.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbConsumerAddress, err := compute.NewAddress(ctx, "psc_ilb_consumer_address", &compute.AddressArgs{
//				Name:        pulumi.String("psc-ilb-consumer-address"),
//				Region:      pulumi.String("us-west2"),
//				Subnetwork:  pscIlbConsumerSubnetwork.ID(),
//				AddressType: pulumi.String("INTERNAL"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewForwardingRule(ctx, "psc_ilb_consumer", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("psc-ilb-consumer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				Target:              pscIlbServiceAttachment.ID(),
//				LoadBalancingScheme: pulumi.String(""),
//				Network:             pscIlbConsumerNetwork.ID(),
//				Subnetwork:          pscIlbConsumerSubnetwork.ID(),
//				IpAddress:           pscIlbConsumerAddress.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Service Attachment Reconcile Connections
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producer_service_health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("producer-service-health-check"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producer_service_backend", &compute.RegionBackendServiceArgs{
//				Name:         pulumi.String("producer-service"),
//				Region:       pulumi.String("us-west2"),
//				HealthChecks: producerServiceHealthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNetwork, err := compute.NewNetwork(ctx, "psc_ilb_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_producer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-producer-subnetwork"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbTargetService, err := compute.NewForwardingRule(ctx, "psc_ilb_target_service", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("producer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				LoadBalancingScheme: pulumi.String("INTERNAL"),
//				BackendService:      producerServiceBackend.ID(),
//				AllPorts:            pulumi.Bool(true),
//				Network:             pscIlbNetwork.Name,
//				Subnetwork:          pscIlbProducerSubnetwork.Name,
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNat, err := compute.NewSubnetwork(ctx, "psc_ilb_nat", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-nat"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:        pulumi.String("my-psc-ilb"),
//				Region:      pulumi.String("us-west2"),
//				Description: pulumi.String("A service attachment configured with Terraform"),
//				DomainNames: pulumi.StringArray{
//					pulumi.String("gcp.tfacc.hashicorptest.com."),
//				},
//				EnableProxyProtocol:  pulumi.Bool(true),
//				ConnectionPreference: pulumi.String("ACCEPT_MANUAL"),
//				NatSubnets: pulumi.StringArray{
//					pscIlbNat.ID(),
//				},
//				TargetService: pscIlbTargetService.ID(),
//				ConsumerRejectLists: pulumi.StringArray{
//					pulumi.String("673497134629"),
//					pulumi.String("482878270665"),
//				},
//				ConsumerAcceptLists: compute.ServiceAttachmentConsumerAcceptListArray{
//					&compute.ServiceAttachmentConsumerAcceptListArgs{
//						ProjectIdOrNum:  pulumi.String("658859330310"),
//						ConnectionLimit: pulumi.Int(4),
//					},
//				},
//				ReconcileConnections: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Service Attachment Tunneling Config
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			producerServiceHealthCheck, err := compute.NewHealthCheck(ctx, "producer_service_health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("producer-service-health-check"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			producerServiceBackend, err := compute.NewRegionBackendService(ctx, "producer_service_backend", &compute.RegionBackendServiceArgs{
//				Name:         pulumi.String("producer-service"),
//				Region:       pulumi.String("us-west2"),
//				HealthChecks: producerServiceHealthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNetwork, err := compute.NewNetwork(ctx, "psc_ilb_network", &compute.NetworkArgs{
//				Name:                  pulumi.String("psc-ilb-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbProducerSubnetwork, err := compute.NewSubnetwork(ctx, "psc_ilb_producer_subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-producer-subnetwork"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbTargetService, err := compute.NewForwardingRule(ctx, "psc_ilb_target_service", &compute.ForwardingRuleArgs{
//				Name:                pulumi.String("producer-forwarding-rule"),
//				Region:              pulumi.String("us-west2"),
//				LoadBalancingScheme: pulumi.String("INTERNAL"),
//				BackendService:      producerServiceBackend.ID(),
//				AllPorts:            pulumi.Bool(true),
//				Network:             pscIlbNetwork.Name,
//				Subnetwork:          pscIlbProducerSubnetwork.Name,
//			})
//			if err != nil {
//				return err
//			}
//			pscIlbNat, err := compute.NewSubnetwork(ctx, "psc_ilb_nat", &compute.SubnetworkArgs{
//				Name:        pulumi.String("psc-ilb-nat"),
//				Region:      pulumi.String("us-west2"),
//				Network:     pscIlbNetwork.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:                 pulumi.String("my-psc-ilb"),
//				Region:               pulumi.String("us-west2"),
//				Description:          pulumi.String("A service attachment configured with tunneling"),
//				EnableProxyProtocol:  pulumi.Bool(false),
//				ConnectionPreference: pulumi.String("ACCEPT_AUTOMATIC"),
//				NatSubnets: pulumi.StringArray{
//					pscIlbNat.ID(),
//				},
//				TargetService: pscIlbTargetService.ID(),
//				TunnelingConfig: &compute.ServiceAttachmentTunnelingConfigArgs{
//					RoutingMode:          pulumi.String("REGIONAL"),
//					EncapsulationProfile: pulumi.String("IPV4"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Service Attachment Cross Region Ilb
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			healthCheck, err := compute.NewHealthCheck(ctx, "health_check", &compute.HealthCheckArgs{
//				Name:             pulumi.String("sa"),
//				CheckIntervalSec: pulumi.Int(1),
//				TimeoutSec:       pulumi.Int(1),
//				TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
//					Port: pulumi.Int(80),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			backendService, err := compute.NewBackendService(ctx, "backend_service", &compute.BackendServiceArgs{
//				Name:                pulumi.String("sa"),
//				LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
//				HealthChecks:        healthCheck.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			urlMap, err := compute.NewURLMap(ctx, "url_map", &compute.URLMapArgs{
//				Name:           pulumi.String("sa"),
//				Description:    pulumi.String("Url map."),
//				DefaultService: backendService.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			httpProxy, err := compute.NewTargetHttpProxy(ctx, "http_proxy", &compute.TargetHttpProxyArgs{
//				Name:        pulumi.String("sa"),
//				Description: pulumi.String("a description"),
//				UrlMap:      urlMap.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("sa"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			subnetworkProxy, err := compute.NewSubnetwork(ctx, "subnetwork_proxy", &compute.SubnetworkArgs{
//				Name:        pulumi.String("sa-proxy"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.ID(),
//				Purpose:     pulumi.String("GLOBAL_MANAGED_PROXY"),
//				Role:        pulumi.String("ACTIVE"),
//				IpCidrRange: pulumi.String("10.2.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("sa"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.ID(),
//				IpCidrRange: pulumi.String("10.0.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			forwardingRule, err := compute.NewGlobalForwardingRule(ctx, "forwarding_rule", &compute.GlobalForwardingRuleArgs{
//				Name:                pulumi.String("sa"),
//				Target:              httpProxy.ID(),
//				Network:             network.ID(),
//				Subnetwork:          subnetwork.ID(),
//				PortRange:           pulumi.String("80"),
//				LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				subnetworkProxy,
//			}))
//			if err != nil {
//				return err
//			}
//			subnetworkPsc, err := compute.NewSubnetwork(ctx, "subnetwork_psc", &compute.SubnetworkArgs{
//				Name:        pulumi.String("sa-psc"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.ID(),
//				Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
//				IpCidrRange: pulumi.String("10.1.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewServiceAttachment(ctx, "psc_ilb_service_attachment", &compute.ServiceAttachmentArgs{
//				Name:                 pulumi.String("sa"),
//				Region:               pulumi.String("us-central1"),
//				Description:          pulumi.String("A service attachment configured with Terraform"),
//				ConnectionPreference: pulumi.String("ACCEPT_AUTOMATIC"),
//				EnableProxyProtocol:  pulumi.Bool(false),
//				NatSubnets: pulumi.StringArray{
//					subnetworkPsc.ID(),
//				},
//				TargetService: forwardingRule.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ServiceAttachment can be imported using any of these accepted formats:
//
// * `projects/{{project}}/regions/{{region}}/serviceAttachments/{{name}}`
//
// * `{{project}}/{{region}}/{{name}}`
//
// * `{{region}}/{{name}}`
//
// * `{{name}}`
//
// When using the `pulumi import` command, ServiceAttachment can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default projects/{{project}}/regions/{{region}}/serviceAttachments/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{project}}/{{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{region}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{name}}
// ```
type ServiceAttachment struct {
	pulumi.CustomResourceState

	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayOutput `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringOutput `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayOutput `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayOutput `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayOutput `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolOutput `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringOutput `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayOutput `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
	PropagatedConnectionLimit pulumi.IntOutput `pulumi:"propagatedConnectionLimit"`
	// An 128-bit global unique ID of the PSC service attachment.
	// Structure is documented below.
	PscServiceAttachmentIds ServiceAttachmentPscServiceAttachmentIdArrayOutput `pulumi:"pscServiceAttachmentIds"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections pulumi.BoolOutput `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region pulumi.StringOutput `pulumi:"region"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagatedConnectionLimit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero pulumi.BoolPtrOutput `pulumi:"sendPropagatedConnectionLimitIfZero"`
	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService pulumi.StringOutput `pulumi:"targetService"`
	// Tunneling configuration for this service attachment.
	// Structure is documented below.
	TunnelingConfig ServiceAttachmentTunnelingConfigPtrOutput `pulumi:"tunnelingConfig"`
}

// NewServiceAttachment registers a new resource with the given unique name, arguments, and options.
func NewServiceAttachment(ctx *pulumi.Context,
	name string, args *ServiceAttachmentArgs, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionPreference == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionPreference'")
	}
	if args.EnableProxyProtocol == nil {
		return nil, errors.New("invalid value for required argument 'EnableProxyProtocol'")
	}
	if args.NatSubnets == nil {
		return nil, errors.New("invalid value for required argument 'NatSubnets'")
	}
	if args.TargetService == nil {
		return nil, errors.New("invalid value for required argument 'TargetService'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServiceAttachment
	err := ctx.RegisterResource("gcp:compute/serviceAttachment:ServiceAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceAttachment gets an existing ServiceAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceAttachmentState, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	var resource ServiceAttachment
	err := ctx.ReadResource("gcp:compute/serviceAttachment:ServiceAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceAttachment resources.
type serviceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints []ServiceAttachmentConnectedEndpoint `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference *string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []string `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol *bool `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint *string `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
	PropagatedConnectionLimit *int `pulumi:"propagatedConnectionLimit"`
	// An 128-bit global unique ID of the PSC service attachment.
	// Structure is documented below.
	PscServiceAttachmentIds []ServiceAttachmentPscServiceAttachmentId `pulumi:"pscServiceAttachmentIds"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections *bool `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagatedConnectionLimit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero *bool `pulumi:"sendPropagatedConnectionLimitIfZero"`
	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService *string `pulumi:"targetService"`
	// Tunneling configuration for this service attachment.
	// Structure is documented below.
	TunnelingConfig *ServiceAttachmentTunnelingConfig `pulumi:"tunnelingConfig"`
}

type ServiceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayInput
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringPtrInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolPtrInput
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringPtrInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
	PropagatedConnectionLimit pulumi.IntPtrInput
	// An 128-bit global unique ID of the PSC service attachment.
	// Structure is documented below.
	PscServiceAttachmentIds ServiceAttachmentPscServiceAttachmentIdArrayInput
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections pulumi.BoolPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagatedConnectionLimit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero pulumi.BoolPtrInput
	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService pulumi.StringPtrInput
	// Tunneling configuration for this service attachment.
	// Structure is documented below.
	TunnelingConfig ServiceAttachmentTunnelingConfigPtrInput
}

func (ServiceAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentState)(nil)).Elem()
}

type serviceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []string `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol bool `pulumi:"enableProxyProtocol"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
	PropagatedConnectionLimit *int `pulumi:"propagatedConnectionLimit"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections *bool `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagatedConnectionLimit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero *bool `pulumi:"sendPropagatedConnectionLimitIfZero"`
	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService string `pulumi:"targetService"`
	// Tunneling configuration for this service attachment.
	// Structure is documented below.
	TunnelingConfig *ServiceAttachmentTunnelingConfig `pulumi:"tunnelingConfig"`
}

// The set of arguments for constructing a ServiceAttachment resource.
type ServiceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	EnableProxyProtocol pulumi.BoolInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
	// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
	// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
	// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
	// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
	PropagatedConnectionLimit pulumi.IntPtrInput
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	ReconcileConnections pulumi.BoolPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// Controls the behavior of propagated_connection_limit.
	// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
	// When true, the provider will set propagatedConnectionLimit to zero.
	// Defaults to false.
	SendPropagatedConnectionLimitIfZero pulumi.BoolPtrInput
	// The URL of a service serving the endpoint identified by this service attachment.
	TargetService pulumi.StringInput
	// Tunneling configuration for this service attachment.
	// Structure is documented below.
	TunnelingConfig ServiceAttachmentTunnelingConfigPtrInput
}

func (ServiceAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentArgs)(nil)).Elem()
}

type ServiceAttachmentInput interface {
	pulumi.Input

	ToServiceAttachmentOutput() ServiceAttachmentOutput
	ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput
}

func (*ServiceAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil)).Elem()
}

func (i *ServiceAttachment) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return i.ToServiceAttachmentOutputWithContext(context.Background())
}

func (i *ServiceAttachment) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentOutput)
}

// ServiceAttachmentArrayInput is an input type that accepts ServiceAttachmentArray and ServiceAttachmentArrayOutput values.
// You can construct a concrete instance of `ServiceAttachmentArrayInput` via:
//
//	ServiceAttachmentArray{ ServiceAttachmentArgs{...} }
type ServiceAttachmentArrayInput interface {
	pulumi.Input

	ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput
	ToServiceAttachmentArrayOutputWithContext(context.Context) ServiceAttachmentArrayOutput
}

type ServiceAttachmentArray []ServiceAttachmentInput

func (ServiceAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return i.ToServiceAttachmentArrayOutputWithContext(context.Background())
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentArrayOutput)
}

// ServiceAttachmentMapInput is an input type that accepts ServiceAttachmentMap and ServiceAttachmentMapOutput values.
// You can construct a concrete instance of `ServiceAttachmentMapInput` via:
//
//	ServiceAttachmentMap{ "key": ServiceAttachmentArgs{...} }
type ServiceAttachmentMapInput interface {
	pulumi.Input

	ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput
	ToServiceAttachmentMapOutputWithContext(context.Context) ServiceAttachmentMapOutput
}

type ServiceAttachmentMap map[string]ServiceAttachmentInput

func (ServiceAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return i.ToServiceAttachmentMapOutputWithContext(context.Background())
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentMapOutput)
}

type ServiceAttachmentOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return o
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return o
}

// An array of the consumer forwarding rules connected to this service
// attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) ConnectedEndpoints() ServiceAttachmentConnectedEndpointArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentConnectedEndpointArrayOutput { return v.ConnectedEndpoints }).(ServiceAttachmentConnectedEndpointArrayOutput)
}

// The connection preference to use for this service attachment. Valid
// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
func (o ServiceAttachmentOutput) ConnectionPreference() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.ConnectionPreference }).(pulumi.StringOutput)
}

// An array of projects that are allowed to connect to this service
// attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) ConsumerAcceptLists() ServiceAttachmentConsumerAcceptListArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentConsumerAcceptListArrayOutput {
		return v.ConsumerAcceptLists
	}).(ServiceAttachmentConsumerAcceptListArrayOutput)
}

// An array of projects that are not allowed to connect to this service
// attachment.
func (o ServiceAttachmentOutput) ConsumerRejectLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.ConsumerRejectLists }).(pulumi.StringArrayOutput)
}

// An optional description of this resource.
func (o ServiceAttachmentOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// If specified, the domain name will be used during the integration between
// the PSC connected endpoints and the Cloud DNS. For example, this is a
// valid domain name: "p.mycompany.com.". Current max number of domain names
// supported is 1.
func (o ServiceAttachmentOutput) DomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.DomainNames }).(pulumi.StringArrayOutput)
}

// If true, enable the proxy protocol which is for supplying client TCP/IP
// address data in TCP connections that traverse proxies on their way to
// destination servers.
func (o ServiceAttachmentOutput) EnableProxyProtocol() pulumi.BoolOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.BoolOutput { return v.EnableProxyProtocol }).(pulumi.BoolOutput)
}

// Fingerprint of this resource. This field is used internally during
// updates of this resource.
func (o ServiceAttachmentOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Fingerprint }).(pulumi.StringOutput)
}

// Name of the resource. The name must be 1-63 characters long, and
// comply with RFC1035. Specifically, the name must be 1-63 characters
// long and match the regular expression `a-z?`
// which means the first character must be a lowercase letter, and all
// following characters must be a dash, lowercase letter, or digit,
// except the last character, which cannot be a dash.
func (o ServiceAttachmentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// An array of subnets that is provided for NAT in this service attachment.
func (o ServiceAttachmentOutput) NatSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.NatSubnets }).(pulumi.StringArrayOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o ServiceAttachmentOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The number of consumer spokes that connected Private Service Connect endpoints can be propagated to through Network Connectivity Center.
// This limit lets the service producer limit how many propagated Private Service Connect connections can be established to this service attachment from a single consumer.
// If the connection preference of the service attachment is ACCEPT_MANUAL, the limit applies to each project or network that is listed in the consumer accept list.
// If the connection preference of the service attachment is ACCEPT_AUTOMATIC, the limit applies to each project that contains a connected endpoint.
// If unspecified, the default propagated connection limit is 250. To explicitly send a zero value, set `sendPropagatedConnectionLimitIfZero = true`.
func (o ServiceAttachmentOutput) PropagatedConnectionLimit() pulumi.IntOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.IntOutput { return v.PropagatedConnectionLimit }).(pulumi.IntOutput)
}

// An 128-bit global unique ID of the PSC service attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) PscServiceAttachmentIds() ServiceAttachmentPscServiceAttachmentIdArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentPscServiceAttachmentIdArrayOutput {
		return v.PscServiceAttachmentIds
	}).(ServiceAttachmentPscServiceAttachmentIdArrayOutput)
}

// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
func (o ServiceAttachmentOutput) ReconcileConnections() pulumi.BoolOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.BoolOutput { return v.ReconcileConnections }).(pulumi.BoolOutput)
}

// URL of the region where the resource resides.
func (o ServiceAttachmentOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The URI of the created resource.
func (o ServiceAttachmentOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// Controls the behavior of propagated_connection_limit.
// When false, setting propagatedConnectionLimit to zero causes the provider to use to the API's default value.
// When true, the provider will set propagatedConnectionLimit to zero.
// Defaults to false.
func (o ServiceAttachmentOutput) SendPropagatedConnectionLimitIfZero() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.BoolPtrOutput { return v.SendPropagatedConnectionLimitIfZero }).(pulumi.BoolPtrOutput)
}

// The URL of a service serving the endpoint identified by this service attachment.
func (o ServiceAttachmentOutput) TargetService() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.TargetService }).(pulumi.StringOutput)
}

// Tunneling configuration for this service attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) TunnelingConfig() ServiceAttachmentTunnelingConfigPtrOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentTunnelingConfigPtrOutput { return v.TunnelingConfig }).(ServiceAttachmentTunnelingConfigPtrOutput)
}

type ServiceAttachmentArrayOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) Index(i pulumi.IntInput) ServiceAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServiceAttachment {
		return vs[0].([]*ServiceAttachment)[vs[1].(int)]
	}).(ServiceAttachmentOutput)
}

type ServiceAttachmentMapOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) MapIndex(k pulumi.StringInput) ServiceAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServiceAttachment {
		return vs[0].(map[string]*ServiceAttachment)[vs[1].(string)]
	}).(ServiceAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentInput)(nil)).Elem(), &ServiceAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentArrayInput)(nil)).Elem(), ServiceAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentMapInput)(nil)).Elem(), ServiceAttachmentMap{})
	pulumi.RegisterOutputType(ServiceAttachmentOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentArrayOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentMapOutput{})
}
