// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a ServiceAttachment resource.
//
// To get more information about ServiceAttachment, see:
//
// * [API documentation](https://cloud.google.com/compute/docs/reference/beta/serviceAttachments)
// * How-to Guides
//   - [Configuring Private Service Connect to access services](https://cloud.google.com/vpc/docs/configure-private-service-connect-services)
//
// ## Example Usage
//
// ## Import
//
// # ServiceAttachment can be imported using any of these accepted formats
//
// ```sh
//
//	$ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default projects/{{project}}/regions/{{region}}/serviceAttachments/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{project}}/{{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/serviceAttachment:ServiceAttachment default {{name}}
//
// ```
type ServiceAttachment struct {
	pulumi.CustomResourceState

	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayOutput `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringOutput `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayOutput `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayOutput `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayOutput `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	//
	// ***
	EnableProxyProtocol pulumi.BoolOutput `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringOutput `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayOutput `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// For newly created service attachment, this boolean defaults to true.
	ReconcileConnections pulumi.BoolPtrOutput `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region pulumi.StringOutput `pulumi:"region"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringOutput `pulumi:"targetService"`
}

// NewServiceAttachment registers a new resource with the given unique name, arguments, and options.
func NewServiceAttachment(ctx *pulumi.Context,
	name string, args *ServiceAttachmentArgs, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectionPreference == nil {
		return nil, errors.New("invalid value for required argument 'ConnectionPreference'")
	}
	if args.EnableProxyProtocol == nil {
		return nil, errors.New("invalid value for required argument 'EnableProxyProtocol'")
	}
	if args.NatSubnets == nil {
		return nil, errors.New("invalid value for required argument 'NatSubnets'")
	}
	if args.TargetService == nil {
		return nil, errors.New("invalid value for required argument 'TargetService'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServiceAttachment
	err := ctx.RegisterResource("gcp:compute/serviceAttachment:ServiceAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServiceAttachment gets an existing ServiceAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServiceAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceAttachmentState, opts ...pulumi.ResourceOption) (*ServiceAttachment, error) {
	var resource ServiceAttachment
	err := ctx.ReadResource("gcp:compute/serviceAttachment:ServiceAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServiceAttachment resources.
type serviceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints []ServiceAttachmentConnectedEndpoint `pulumi:"connectedEndpoints"`
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference *string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []string `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	//
	// ***
	EnableProxyProtocol *bool `pulumi:"enableProxyProtocol"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint *string `pulumi:"fingerprint"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// For newly created service attachment, this boolean defaults to true.
	ReconcileConnections *bool `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService *string `pulumi:"targetService"`
}

type ServiceAttachmentState struct {
	// An array of the consumer forwarding rules connected to this service
	// attachment.
	// Structure is documented below.
	ConnectedEndpoints ServiceAttachmentConnectedEndpointArrayInput
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringPtrInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	//
	// ***
	EnableProxyProtocol pulumi.BoolPtrInput
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringPtrInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// For newly created service attachment, this boolean defaults to true.
	ReconcileConnections pulumi.BoolPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringPtrInput
}

func (ServiceAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentState)(nil)).Elem()
}

type serviceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference string `pulumi:"connectionPreference"`
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists []ServiceAttachmentConsumerAcceptList `pulumi:"consumerAcceptLists"`
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists []string `pulumi:"consumerRejectLists"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames []string `pulumi:"domainNames"`
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	//
	// ***
	EnableProxyProtocol bool `pulumi:"enableProxyProtocol"`
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets []string `pulumi:"natSubnets"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// For newly created service attachment, this boolean defaults to true.
	ReconcileConnections *bool `pulumi:"reconcileConnections"`
	// URL of the region where the resource resides.
	Region *string `pulumi:"region"`
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService string `pulumi:"targetService"`
}

// The set of arguments for constructing a ServiceAttachment resource.
type ServiceAttachmentArgs struct {
	// The connection preference to use for this service attachment. Valid
	// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
	ConnectionPreference pulumi.StringInput
	// An array of projects that are allowed to connect to this service
	// attachment.
	// Structure is documented below.
	ConsumerAcceptLists ServiceAttachmentConsumerAcceptListArrayInput
	// An array of projects that are not allowed to connect to this service
	// attachment.
	ConsumerRejectLists pulumi.StringArrayInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// If specified, the domain name will be used during the integration between
	// the PSC connected endpoints and the Cloud DNS. For example, this is a
	// valid domain name: "p.mycompany.com.". Current max number of domain names
	// supported is 1.
	DomainNames pulumi.StringArrayInput
	// If true, enable the proxy protocol which is for supplying client TCP/IP
	// address data in TCP connections that traverse proxies on their way to
	// destination servers.
	//
	// ***
	EnableProxyProtocol pulumi.BoolInput
	// Name of the resource. The name must be 1-63 characters long, and
	// comply with RFC1035. Specifically, the name must be 1-63 characters
	// long and match the regular expression `a-z?`
	// which means the first character must be a lowercase letter, and all
	// following characters must be a dash, lowercase letter, or digit,
	// except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// An array of subnets that is provided for NAT in this service attachment.
	NatSubnets pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
	// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
	// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
	// For newly created service attachment, this boolean defaults to true.
	ReconcileConnections pulumi.BoolPtrInput
	// URL of the region where the resource resides.
	Region pulumi.StringPtrInput
	// The URL of a forwarding rule that represents the service identified by
	// this service attachment.
	TargetService pulumi.StringInput
}

func (ServiceAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceAttachmentArgs)(nil)).Elem()
}

type ServiceAttachmentInput interface {
	pulumi.Input

	ToServiceAttachmentOutput() ServiceAttachmentOutput
	ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput
}

func (*ServiceAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil)).Elem()
}

func (i *ServiceAttachment) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return i.ToServiceAttachmentOutputWithContext(context.Background())
}

func (i *ServiceAttachment) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentOutput)
}

// ServiceAttachmentArrayInput is an input type that accepts ServiceAttachmentArray and ServiceAttachmentArrayOutput values.
// You can construct a concrete instance of `ServiceAttachmentArrayInput` via:
//
//	ServiceAttachmentArray{ ServiceAttachmentArgs{...} }
type ServiceAttachmentArrayInput interface {
	pulumi.Input

	ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput
	ToServiceAttachmentArrayOutputWithContext(context.Context) ServiceAttachmentArrayOutput
}

type ServiceAttachmentArray []ServiceAttachmentInput

func (ServiceAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return i.ToServiceAttachmentArrayOutputWithContext(context.Background())
}

func (i ServiceAttachmentArray) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentArrayOutput)
}

// ServiceAttachmentMapInput is an input type that accepts ServiceAttachmentMap and ServiceAttachmentMapOutput values.
// You can construct a concrete instance of `ServiceAttachmentMapInput` via:
//
//	ServiceAttachmentMap{ "key": ServiceAttachmentArgs{...} }
type ServiceAttachmentMapInput interface {
	pulumi.Input

	ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput
	ToServiceAttachmentMapOutputWithContext(context.Context) ServiceAttachmentMapOutput
}

type ServiceAttachmentMap map[string]ServiceAttachmentInput

func (ServiceAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceAttachment)(nil)).Elem()
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return i.ToServiceAttachmentMapOutputWithContext(context.Background())
}

func (i ServiceAttachmentMap) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAttachmentMapOutput)
}

type ServiceAttachmentOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutput() ServiceAttachmentOutput {
	return o
}

func (o ServiceAttachmentOutput) ToServiceAttachmentOutputWithContext(ctx context.Context) ServiceAttachmentOutput {
	return o
}

// An array of the consumer forwarding rules connected to this service
// attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) ConnectedEndpoints() ServiceAttachmentConnectedEndpointArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentConnectedEndpointArrayOutput { return v.ConnectedEndpoints }).(ServiceAttachmentConnectedEndpointArrayOutput)
}

// The connection preference to use for this service attachment. Valid
// values include "ACCEPT_AUTOMATIC", "ACCEPT_MANUAL".
func (o ServiceAttachmentOutput) ConnectionPreference() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.ConnectionPreference }).(pulumi.StringOutput)
}

// An array of projects that are allowed to connect to this service
// attachment.
// Structure is documented below.
func (o ServiceAttachmentOutput) ConsumerAcceptLists() ServiceAttachmentConsumerAcceptListArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) ServiceAttachmentConsumerAcceptListArrayOutput {
		return v.ConsumerAcceptLists
	}).(ServiceAttachmentConsumerAcceptListArrayOutput)
}

// An array of projects that are not allowed to connect to this service
// attachment.
func (o ServiceAttachmentOutput) ConsumerRejectLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.ConsumerRejectLists }).(pulumi.StringArrayOutput)
}

// An optional description of this resource.
func (o ServiceAttachmentOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// If specified, the domain name will be used during the integration between
// the PSC connected endpoints and the Cloud DNS. For example, this is a
// valid domain name: "p.mycompany.com.". Current max number of domain names
// supported is 1.
func (o ServiceAttachmentOutput) DomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.DomainNames }).(pulumi.StringArrayOutput)
}

// If true, enable the proxy protocol which is for supplying client TCP/IP
// address data in TCP connections that traverse proxies on their way to
// destination servers.
//
// ***
func (o ServiceAttachmentOutput) EnableProxyProtocol() pulumi.BoolOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.BoolOutput { return v.EnableProxyProtocol }).(pulumi.BoolOutput)
}

// Fingerprint of this resource. This field is used internally during
// updates of this resource.
func (o ServiceAttachmentOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Fingerprint }).(pulumi.StringOutput)
}

// Name of the resource. The name must be 1-63 characters long, and
// comply with RFC1035. Specifically, the name must be 1-63 characters
// long and match the regular expression `a-z?`
// which means the first character must be a lowercase letter, and all
// following characters must be a dash, lowercase letter, or digit,
// except the last character, which cannot be a dash.
func (o ServiceAttachmentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// An array of subnets that is provided for NAT in this service attachment.
func (o ServiceAttachmentOutput) NatSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringArrayOutput { return v.NatSubnets }).(pulumi.StringArrayOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o ServiceAttachmentOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints.
// If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified .
// If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list.
// For newly created service attachment, this boolean defaults to true.
func (o ServiceAttachmentOutput) ReconcileConnections() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.BoolPtrOutput { return v.ReconcileConnections }).(pulumi.BoolPtrOutput)
}

// URL of the region where the resource resides.
func (o ServiceAttachmentOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The URI of the created resource.
func (o ServiceAttachmentOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// The URL of a forwarding rule that represents the service identified by
// this service attachment.
func (o ServiceAttachmentOutput) TargetService() pulumi.StringOutput {
	return o.ApplyT(func(v *ServiceAttachment) pulumi.StringOutput { return v.TargetService }).(pulumi.StringOutput)
}

type ServiceAttachmentArrayOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutput() ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) ToServiceAttachmentArrayOutputWithContext(ctx context.Context) ServiceAttachmentArrayOutput {
	return o
}

func (o ServiceAttachmentArrayOutput) Index(i pulumi.IntInput) ServiceAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServiceAttachment {
		return vs[0].([]*ServiceAttachment)[vs[1].(int)]
	}).(ServiceAttachmentOutput)
}

type ServiceAttachmentMapOutput struct{ *pulumi.OutputState }

func (ServiceAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServiceAttachment)(nil)).Elem()
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutput() ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) ToServiceAttachmentMapOutputWithContext(ctx context.Context) ServiceAttachmentMapOutput {
	return o
}

func (o ServiceAttachmentMapOutput) MapIndex(k pulumi.StringInput) ServiceAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServiceAttachment {
		return vs[0].(map[string]*ServiceAttachment)[vs[1].(string)]
	}).(ServiceAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentInput)(nil)).Elem(), &ServiceAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentArrayInput)(nil)).Elem(), ServiceAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAttachmentMapInput)(nil)).Elem(), ServiceAttachmentMap{})
	pulumi.RegisterOutputType(ServiceAttachmentOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentArrayOutput{})
	pulumi.RegisterOutputType(ServiceAttachmentMapOutput{})
}
