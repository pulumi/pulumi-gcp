// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The Compute NetworkFirewallPolicy with rules resource
//
// ## Example Usage
//
// ### Compute Region Network Firewall Policy With Rules Full
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/tags"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			addressGroup1, err := networksecurity.NewAddressGroup(ctx, "address_group_1", &networksecurity.AddressGroupArgs{
//				Name:        pulumi.String("address-group"),
//				Parent:      pulumi.String(project.Id),
//				Description: pulumi.String("Regional address group"),
//				Location:    pulumi.String("us-west2"),
//				Items: pulumi.StringArray{
//					pulumi.String("208.80.154.224/32"),
//				},
//				Type:     pulumi.String("IPV4"),
//				Capacity: pulumi.Int(100),
//			})
//			if err != nil {
//				return err
//			}
//			secureTagKey1, err := tags.NewTagKey(ctx, "secure_tag_key_1", &tags.TagKeyArgs{
//				Description: pulumi.String("Tag key"),
//				Parent:      pulumi.String(project.Id),
//				Purpose:     pulumi.String("GCE_FIREWALL"),
//				ShortName:   pulumi.String("tag-key"),
//				PurposeData: pulumi.StringMap{
//					"network": pulumi.Sprintf("%v/default", project.Name),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			secureTagValue1, err := tags.NewTagValue(ctx, "secure_tag_value_1", &tags.TagValueArgs{
//				Description: pulumi.String("Tag value"),
//				Parent:      secureTagKey1.ID(),
//				ShortName:   pulumi.String("tag-value"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewRegionNetworkFirewallPolicyWithRules(ctx, "primary", &compute.RegionNetworkFirewallPolicyWithRulesArgs{
//				Name:        pulumi.String("fw-policy"),
//				Region:      pulumi.String("us-west2"),
//				Description: pulumi.String("Terraform test"),
//				Rules: compute.RegionNetworkFirewallPolicyWithRulesRuleArray{
//					&compute.RegionNetworkFirewallPolicyWithRulesRuleArgs{
//						Description:   pulumi.String("tcp rule"),
//						Priority:      pulumi.Int(1000),
//						EnableLogging: pulumi.Bool(true),
//						Action:        pulumi.String("allow"),
//						Direction:     pulumi.String("EGRESS"),
//						Match: &compute.RegionNetworkFirewallPolicyWithRulesRuleMatchArgs{
//							DestIpRanges: pulumi.StringArray{
//								pulumi.String("11.100.0.1/32"),
//							},
//							DestFqdns: pulumi.StringArray{
//								pulumi.String("www.yyy.com"),
//								pulumi.String("www.zzz.com"),
//							},
//							DestRegionCodes: pulumi.StringArray{
//								pulumi.String("HK"),
//								pulumi.String("IN"),
//							},
//							DestThreatIntelligences: pulumi.StringArray{
//								pulumi.String("iplist-search-engines-crawlers"),
//								pulumi.String("iplist-tor-exit-nodes"),
//							},
//							DestAddressGroups: pulumi.StringArray{
//								addressGroup1.ID(),
//							},
//							Layer4Configs: compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArray{
//								&compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArgs{
//									IpProtocol: pulumi.String("tcp"),
//									Ports: pulumi.StringArray{
//										pulumi.String("8080"),
//										pulumi.String("7070"),
//									},
//								},
//							},
//						},
//						TargetSecureTags: compute.RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTagArray{
//							&compute.RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTagArgs{
//								Name: secureTagValue1.ID(),
//							},
//						},
//					},
//					&compute.RegionNetworkFirewallPolicyWithRulesRuleArgs{
//						Description:   pulumi.String("udp rule"),
//						RuleName:      pulumi.String("test-rule"),
//						Priority:      pulumi.Int(2000),
//						EnableLogging: pulumi.Bool(false),
//						Action:        pulumi.String("deny"),
//						Direction:     pulumi.String("INGRESS"),
//						Disabled:      pulumi.Bool(true),
//						Match: &compute.RegionNetworkFirewallPolicyWithRulesRuleMatchArgs{
//							SrcIpRanges: pulumi.StringArray{
//								pulumi.String("0.0.0.0/0"),
//							},
//							SrcFqdns: pulumi.StringArray{
//								pulumi.String("www.abc.com"),
//								pulumi.String("www.def.com"),
//							},
//							SrcRegionCodes: pulumi.StringArray{
//								pulumi.String("US"),
//								pulumi.String("CA"),
//							},
//							SrcThreatIntelligences: pulumi.StringArray{
//								pulumi.String("iplist-known-malicious-ips"),
//								pulumi.String("iplist-public-clouds"),
//							},
//							SrcAddressGroups: pulumi.StringArray{
//								addressGroup1.ID(),
//							},
//							SrcSecureTags: compute.RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTagArray{
//								&compute.RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTagArgs{
//									Name: secureTagValue1.ID(),
//								},
//							},
//							Layer4Configs: compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArray{
//								&compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArgs{
//									IpProtocol: pulumi.String("udp"),
//								},
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Compute Region Network Firewall Policy With Rules Roce
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewRegionNetworkFirewallPolicyWithRules(ctx, "policy", &compute.RegionNetworkFirewallPolicyWithRulesArgs{
//				Name:        pulumi.String("rnf-policy"),
//				Description: pulumi.String("Terraform test"),
//				PolicyType:  pulumi.String("RDMA_ROCE_POLICY"),
//				Rules: compute.RegionNetworkFirewallPolicyWithRulesRuleArray{
//					&compute.RegionNetworkFirewallPolicyWithRulesRuleArgs{
//						Description:   pulumi.String("deny all rule"),
//						Priority:      pulumi.Int(1000),
//						EnableLogging: pulumi.Bool(true),
//						Action:        pulumi.String("deny"),
//						Direction:     pulumi.String("INGRESS"),
//						Match: &compute.RegionNetworkFirewallPolicyWithRulesRuleMatchArgs{
//							SrcIpRanges: pulumi.StringArray{
//								pulumi.String("0.0.0.0/0"),
//							},
//							Layer4Configs: compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArray{
//								&compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4ConfigArgs{
//									IpProtocol: pulumi.String("all"),
//								},
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// RegionNetworkFirewallPolicyWithRules can be imported using any of these accepted formats:
//
// * `projects/{{project}}/regions/{{region}}/firewallPolicies/{{name}}`
// * `{{project}}/{{region}}/{{name}}`
// * `{{region}}/{{name}}`
// * `{{name}}`
//
// When using the `pulumi import` command, RegionNetworkFirewallPolicyWithRules can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules default projects/{{project}}/regions/{{region}}/firewallPolicies/{{name}}
// $ pulumi import gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules default {{project}}/{{region}}/{{name}}
// $ pulumi import gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules default {{region}}/{{name}}
// $ pulumi import gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules default {{name}}
// ```
type RegionNetworkFirewallPolicyWithRules struct {
	pulumi.CustomResourceState

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringOutput `pulumi:"creationTimestamp"`
	// An optional description of this resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Fingerprint of the resource. This field is used internally during updates of this resource.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// User-provided name of the Network firewall policy.
	// The name should be unique in the project in which the firewall policy is created.
	// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
	// the name must be 1-63 characters long and match the regular expression a-z?
	// which means the first character must be a lowercase letter, and all following characters must be a dash,
	// lowercase letter, or digit, except the last character, which cannot be a dash.
	Name pulumi.StringOutput `pulumi:"name"`
	// The unique identifier for the resource. This identifier is defined by the server.
	NetworkFirewallPolicyId pulumi.StringOutput `pulumi:"networkFirewallPolicyId"`
	// Policy type is used to determine which resources (networks) the policy can be associated with.
	// A policy can be associated with a network only if the network has the matching policyType in its network profile.
	// Different policy types may support some of the Firewall Rules features.
	// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
	PolicyType pulumi.StringOutput `pulumi:"policyType"`
	// A list of firewall policy pre-defined rules.
	// Structure is documented below.
	PredefinedRules RegionNetworkFirewallPolicyWithRulesPredefinedRuleArrayOutput `pulumi:"predefinedRules"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The region of this resource.
	Region pulumi.StringOutput `pulumi:"region"`
	// Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.
	RuleTupleCount pulumi.IntOutput `pulumi:"ruleTupleCount"`
	// A list of firewall policy rules.
	// Structure is documented below.
	Rules RegionNetworkFirewallPolicyWithRulesRuleArrayOutput `pulumi:"rules"`
	// Server-defined URL for the resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// Server-defined URL for this resource with the resource id.
	SelfLinkWithId pulumi.StringOutput `pulumi:"selfLinkWithId"`
}

// NewRegionNetworkFirewallPolicyWithRules registers a new resource with the given unique name, arguments, and options.
func NewRegionNetworkFirewallPolicyWithRules(ctx *pulumi.Context,
	name string, args *RegionNetworkFirewallPolicyWithRulesArgs, opts ...pulumi.ResourceOption) (*RegionNetworkFirewallPolicyWithRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RegionNetworkFirewallPolicyWithRules
	err := ctx.RegisterResource("gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRegionNetworkFirewallPolicyWithRules gets an existing RegionNetworkFirewallPolicyWithRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRegionNetworkFirewallPolicyWithRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RegionNetworkFirewallPolicyWithRulesState, opts ...pulumi.ResourceOption) (*RegionNetworkFirewallPolicyWithRules, error) {
	var resource RegionNetworkFirewallPolicyWithRules
	err := ctx.ReadResource("gcp:compute/regionNetworkFirewallPolicyWithRules:RegionNetworkFirewallPolicyWithRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RegionNetworkFirewallPolicyWithRules resources.
type regionNetworkFirewallPolicyWithRulesState struct {
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `pulumi:"creationTimestamp"`
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// Fingerprint of the resource. This field is used internally during updates of this resource.
	Fingerprint *string `pulumi:"fingerprint"`
	// User-provided name of the Network firewall policy.
	// The name should be unique in the project in which the firewall policy is created.
	// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
	// the name must be 1-63 characters long and match the regular expression a-z?
	// which means the first character must be a lowercase letter, and all following characters must be a dash,
	// lowercase letter, or digit, except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// The unique identifier for the resource. This identifier is defined by the server.
	NetworkFirewallPolicyId *string `pulumi:"networkFirewallPolicyId"`
	// Policy type is used to determine which resources (networks) the policy can be associated with.
	// A policy can be associated with a network only if the network has the matching policyType in its network profile.
	// Different policy types may support some of the Firewall Rules features.
	// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
	PolicyType *string `pulumi:"policyType"`
	// A list of firewall policy pre-defined rules.
	// Structure is documented below.
	PredefinedRules []RegionNetworkFirewallPolicyWithRulesPredefinedRule `pulumi:"predefinedRules"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The region of this resource.
	Region *string `pulumi:"region"`
	// Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.
	RuleTupleCount *int `pulumi:"ruleTupleCount"`
	// A list of firewall policy rules.
	// Structure is documented below.
	Rules []RegionNetworkFirewallPolicyWithRulesRule `pulumi:"rules"`
	// Server-defined URL for the resource.
	SelfLink *string `pulumi:"selfLink"`
	// Server-defined URL for this resource with the resource id.
	SelfLinkWithId *string `pulumi:"selfLinkWithId"`
}

type RegionNetworkFirewallPolicyWithRulesState struct {
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringPtrInput
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// Fingerprint of the resource. This field is used internally during updates of this resource.
	Fingerprint pulumi.StringPtrInput
	// User-provided name of the Network firewall policy.
	// The name should be unique in the project in which the firewall policy is created.
	// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
	// the name must be 1-63 characters long and match the regular expression a-z?
	// which means the first character must be a lowercase letter, and all following characters must be a dash,
	// lowercase letter, or digit, except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// The unique identifier for the resource. This identifier is defined by the server.
	NetworkFirewallPolicyId pulumi.StringPtrInput
	// Policy type is used to determine which resources (networks) the policy can be associated with.
	// A policy can be associated with a network only if the network has the matching policyType in its network profile.
	// Different policy types may support some of the Firewall Rules features.
	// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
	PolicyType pulumi.StringPtrInput
	// A list of firewall policy pre-defined rules.
	// Structure is documented below.
	PredefinedRules RegionNetworkFirewallPolicyWithRulesPredefinedRuleArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The region of this resource.
	Region pulumi.StringPtrInput
	// Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.
	RuleTupleCount pulumi.IntPtrInput
	// A list of firewall policy rules.
	// Structure is documented below.
	Rules RegionNetworkFirewallPolicyWithRulesRuleArrayInput
	// Server-defined URL for the resource.
	SelfLink pulumi.StringPtrInput
	// Server-defined URL for this resource with the resource id.
	SelfLinkWithId pulumi.StringPtrInput
}

func (RegionNetworkFirewallPolicyWithRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*regionNetworkFirewallPolicyWithRulesState)(nil)).Elem()
}

type regionNetworkFirewallPolicyWithRulesArgs struct {
	// An optional description of this resource.
	Description *string `pulumi:"description"`
	// User-provided name of the Network firewall policy.
	// The name should be unique in the project in which the firewall policy is created.
	// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
	// the name must be 1-63 characters long and match the regular expression a-z?
	// which means the first character must be a lowercase letter, and all following characters must be a dash,
	// lowercase letter, or digit, except the last character, which cannot be a dash.
	Name *string `pulumi:"name"`
	// Policy type is used to determine which resources (networks) the policy can be associated with.
	// A policy can be associated with a network only if the network has the matching policyType in its network profile.
	// Different policy types may support some of the Firewall Rules features.
	// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
	PolicyType *string `pulumi:"policyType"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The region of this resource.
	Region *string `pulumi:"region"`
	// A list of firewall policy rules.
	// Structure is documented below.
	Rules []RegionNetworkFirewallPolicyWithRulesRule `pulumi:"rules"`
}

// The set of arguments for constructing a RegionNetworkFirewallPolicyWithRules resource.
type RegionNetworkFirewallPolicyWithRulesArgs struct {
	// An optional description of this resource.
	Description pulumi.StringPtrInput
	// User-provided name of the Network firewall policy.
	// The name should be unique in the project in which the firewall policy is created.
	// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
	// the name must be 1-63 characters long and match the regular expression a-z?
	// which means the first character must be a lowercase letter, and all following characters must be a dash,
	// lowercase letter, or digit, except the last character, which cannot be a dash.
	Name pulumi.StringPtrInput
	// Policy type is used to determine which resources (networks) the policy can be associated with.
	// A policy can be associated with a network only if the network has the matching policyType in its network profile.
	// Different policy types may support some of the Firewall Rules features.
	// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
	PolicyType pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The region of this resource.
	Region pulumi.StringPtrInput
	// A list of firewall policy rules.
	// Structure is documented below.
	Rules RegionNetworkFirewallPolicyWithRulesRuleArrayInput
}

func (RegionNetworkFirewallPolicyWithRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*regionNetworkFirewallPolicyWithRulesArgs)(nil)).Elem()
}

type RegionNetworkFirewallPolicyWithRulesInput interface {
	pulumi.Input

	ToRegionNetworkFirewallPolicyWithRulesOutput() RegionNetworkFirewallPolicyWithRulesOutput
	ToRegionNetworkFirewallPolicyWithRulesOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesOutput
}

func (*RegionNetworkFirewallPolicyWithRules) ElementType() reflect.Type {
	return reflect.TypeOf((**RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (i *RegionNetworkFirewallPolicyWithRules) ToRegionNetworkFirewallPolicyWithRulesOutput() RegionNetworkFirewallPolicyWithRulesOutput {
	return i.ToRegionNetworkFirewallPolicyWithRulesOutputWithContext(context.Background())
}

func (i *RegionNetworkFirewallPolicyWithRules) ToRegionNetworkFirewallPolicyWithRulesOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionNetworkFirewallPolicyWithRulesOutput)
}

// RegionNetworkFirewallPolicyWithRulesArrayInput is an input type that accepts RegionNetworkFirewallPolicyWithRulesArray and RegionNetworkFirewallPolicyWithRulesArrayOutput values.
// You can construct a concrete instance of `RegionNetworkFirewallPolicyWithRulesArrayInput` via:
//
//	RegionNetworkFirewallPolicyWithRulesArray{ RegionNetworkFirewallPolicyWithRulesArgs{...} }
type RegionNetworkFirewallPolicyWithRulesArrayInput interface {
	pulumi.Input

	ToRegionNetworkFirewallPolicyWithRulesArrayOutput() RegionNetworkFirewallPolicyWithRulesArrayOutput
	ToRegionNetworkFirewallPolicyWithRulesArrayOutputWithContext(context.Context) RegionNetworkFirewallPolicyWithRulesArrayOutput
}

type RegionNetworkFirewallPolicyWithRulesArray []RegionNetworkFirewallPolicyWithRulesInput

func (RegionNetworkFirewallPolicyWithRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (i RegionNetworkFirewallPolicyWithRulesArray) ToRegionNetworkFirewallPolicyWithRulesArrayOutput() RegionNetworkFirewallPolicyWithRulesArrayOutput {
	return i.ToRegionNetworkFirewallPolicyWithRulesArrayOutputWithContext(context.Background())
}

func (i RegionNetworkFirewallPolicyWithRulesArray) ToRegionNetworkFirewallPolicyWithRulesArrayOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionNetworkFirewallPolicyWithRulesArrayOutput)
}

// RegionNetworkFirewallPolicyWithRulesMapInput is an input type that accepts RegionNetworkFirewallPolicyWithRulesMap and RegionNetworkFirewallPolicyWithRulesMapOutput values.
// You can construct a concrete instance of `RegionNetworkFirewallPolicyWithRulesMapInput` via:
//
//	RegionNetworkFirewallPolicyWithRulesMap{ "key": RegionNetworkFirewallPolicyWithRulesArgs{...} }
type RegionNetworkFirewallPolicyWithRulesMapInput interface {
	pulumi.Input

	ToRegionNetworkFirewallPolicyWithRulesMapOutput() RegionNetworkFirewallPolicyWithRulesMapOutput
	ToRegionNetworkFirewallPolicyWithRulesMapOutputWithContext(context.Context) RegionNetworkFirewallPolicyWithRulesMapOutput
}

type RegionNetworkFirewallPolicyWithRulesMap map[string]RegionNetworkFirewallPolicyWithRulesInput

func (RegionNetworkFirewallPolicyWithRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (i RegionNetworkFirewallPolicyWithRulesMap) ToRegionNetworkFirewallPolicyWithRulesMapOutput() RegionNetworkFirewallPolicyWithRulesMapOutput {
	return i.ToRegionNetworkFirewallPolicyWithRulesMapOutputWithContext(context.Background())
}

func (i RegionNetworkFirewallPolicyWithRulesMap) ToRegionNetworkFirewallPolicyWithRulesMapOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionNetworkFirewallPolicyWithRulesMapOutput)
}

type RegionNetworkFirewallPolicyWithRulesOutput struct{ *pulumi.OutputState }

func (RegionNetworkFirewallPolicyWithRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (o RegionNetworkFirewallPolicyWithRulesOutput) ToRegionNetworkFirewallPolicyWithRulesOutput() RegionNetworkFirewallPolicyWithRulesOutput {
	return o
}

func (o RegionNetworkFirewallPolicyWithRulesOutput) ToRegionNetworkFirewallPolicyWithRulesOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesOutput {
	return o
}

// Creation timestamp in RFC3339 text format.
func (o RegionNetworkFirewallPolicyWithRulesOutput) CreationTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.CreationTimestamp }).(pulumi.StringOutput)
}

// An optional description of this resource.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Fingerprint of the resource. This field is used internally during updates of this resource.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.Fingerprint }).(pulumi.StringOutput)
}

// User-provided name of the Network firewall policy.
// The name should be unique in the project in which the firewall policy is created.
// The name must be 1-63 characters long, and comply with RFC1035. Specifically,
// the name must be 1-63 characters long and match the regular expression a-z?
// which means the first character must be a lowercase letter, and all following characters must be a dash,
// lowercase letter, or digit, except the last character, which cannot be a dash.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The unique identifier for the resource. This identifier is defined by the server.
func (o RegionNetworkFirewallPolicyWithRulesOutput) NetworkFirewallPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.NetworkFirewallPolicyId }).(pulumi.StringOutput)
}

// Policy type is used to determine which resources (networks) the policy can be associated with.
// A policy can be associated with a network only if the network has the matching policyType in its network profile.
// Different policy types may support some of the Firewall Rules features.
// Possible values are: `VPC_POLICY`, `RDMA_ROCE_POLICY`, `RDMA_FALCON_POLICY`, `ULL_POLICY`.
func (o RegionNetworkFirewallPolicyWithRulesOutput) PolicyType() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.PolicyType }).(pulumi.StringOutput)
}

// A list of firewall policy pre-defined rules.
// Structure is documented below.
func (o RegionNetworkFirewallPolicyWithRulesOutput) PredefinedRules() RegionNetworkFirewallPolicyWithRulesPredefinedRuleArrayOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) RegionNetworkFirewallPolicyWithRulesPredefinedRuleArrayOutput {
		return v.PredefinedRules
	}).(RegionNetworkFirewallPolicyWithRulesPredefinedRuleArrayOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The region of this resource.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.
func (o RegionNetworkFirewallPolicyWithRulesOutput) RuleTupleCount() pulumi.IntOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.IntOutput { return v.RuleTupleCount }).(pulumi.IntOutput)
}

// A list of firewall policy rules.
// Structure is documented below.
func (o RegionNetworkFirewallPolicyWithRulesOutput) Rules() RegionNetworkFirewallPolicyWithRulesRuleArrayOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) RegionNetworkFirewallPolicyWithRulesRuleArrayOutput {
		return v.Rules
	}).(RegionNetworkFirewallPolicyWithRulesRuleArrayOutput)
}

// Server-defined URL for the resource.
func (o RegionNetworkFirewallPolicyWithRulesOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// Server-defined URL for this resource with the resource id.
func (o RegionNetworkFirewallPolicyWithRulesOutput) SelfLinkWithId() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionNetworkFirewallPolicyWithRules) pulumi.StringOutput { return v.SelfLinkWithId }).(pulumi.StringOutput)
}

type RegionNetworkFirewallPolicyWithRulesArrayOutput struct{ *pulumi.OutputState }

func (RegionNetworkFirewallPolicyWithRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (o RegionNetworkFirewallPolicyWithRulesArrayOutput) ToRegionNetworkFirewallPolicyWithRulesArrayOutput() RegionNetworkFirewallPolicyWithRulesArrayOutput {
	return o
}

func (o RegionNetworkFirewallPolicyWithRulesArrayOutput) ToRegionNetworkFirewallPolicyWithRulesArrayOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesArrayOutput {
	return o
}

func (o RegionNetworkFirewallPolicyWithRulesArrayOutput) Index(i pulumi.IntInput) RegionNetworkFirewallPolicyWithRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RegionNetworkFirewallPolicyWithRules {
		return vs[0].([]*RegionNetworkFirewallPolicyWithRules)[vs[1].(int)]
	}).(RegionNetworkFirewallPolicyWithRulesOutput)
}

type RegionNetworkFirewallPolicyWithRulesMapOutput struct{ *pulumi.OutputState }

func (RegionNetworkFirewallPolicyWithRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegionNetworkFirewallPolicyWithRules)(nil)).Elem()
}

func (o RegionNetworkFirewallPolicyWithRulesMapOutput) ToRegionNetworkFirewallPolicyWithRulesMapOutput() RegionNetworkFirewallPolicyWithRulesMapOutput {
	return o
}

func (o RegionNetworkFirewallPolicyWithRulesMapOutput) ToRegionNetworkFirewallPolicyWithRulesMapOutputWithContext(ctx context.Context) RegionNetworkFirewallPolicyWithRulesMapOutput {
	return o
}

func (o RegionNetworkFirewallPolicyWithRulesMapOutput) MapIndex(k pulumi.StringInput) RegionNetworkFirewallPolicyWithRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RegionNetworkFirewallPolicyWithRules {
		return vs[0].(map[string]*RegionNetworkFirewallPolicyWithRules)[vs[1].(string)]
	}).(RegionNetworkFirewallPolicyWithRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RegionNetworkFirewallPolicyWithRulesInput)(nil)).Elem(), &RegionNetworkFirewallPolicyWithRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegionNetworkFirewallPolicyWithRulesArrayInput)(nil)).Elem(), RegionNetworkFirewallPolicyWithRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegionNetworkFirewallPolicyWithRulesMapInput)(nil)).Elem(), RegionNetworkFirewallPolicyWithRulesMap{})
	pulumi.RegisterOutputType(RegionNetworkFirewallPolicyWithRulesOutput{})
	pulumi.RegisterOutputType(RegionNetworkFirewallPolicyWithRulesArrayOutput{})
	pulumi.RegisterOutputType(RegionNetworkFirewallPolicyWithRulesMapOutput{})
}
