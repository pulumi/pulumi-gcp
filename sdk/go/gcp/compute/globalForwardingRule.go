// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a GlobalForwardingRule resource. Global forwarding rules are
// used to forward traffic to the correct load balancer for HTTP load
// balancing. Global forwarding rules can only be used for HTTP load
// balancing.
//
// For more information, see
// <https://cloud.google.com/compute/docs/load-balancing/http/>
//
// ## Example Usage
// ### External Ssl Proxy Lb Mig Backend
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi-tls/sdk/v4/go/tls"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultNetwork, err := compute.NewNetwork(ctx, "defaultNetwork", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "defaultSubnetwork", &compute.SubnetworkArgs{
// 			IpCidrRange: pulumi.String("10.0.1.0/24"),
// 			Region:      pulumi.String("us-central1"),
// 			Network:     defaultNetwork.ID(),
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		defaultGlobalAddress, err := compute.NewGlobalAddress(ctx, "defaultGlobalAddress", nil)
// 		if err != nil {
// 			return err
// 		}
// 		defaultPrivateKey, err := tls.NewPrivateKey(ctx, "defaultPrivateKey", &tls.PrivateKeyArgs{
// 			Algorithm: pulumi.String("RSA"),
// 			RsaBits:   pulumi.Int(2048),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultSelfSignedCert, err := tls.NewSelfSignedCert(ctx, "defaultSelfSignedCert", &tls.SelfSignedCertArgs{
// 			KeyAlgorithm:        defaultPrivateKey.Algorithm,
// 			PrivateKeyPem:       defaultPrivateKey.PrivateKeyPem,
// 			ValidityPeriodHours: pulumi.Int(12),
// 			EarlyRenewalHours:   pulumi.Int(3),
// 			AllowedUses: pulumi.StringArray{
// 				pulumi.String("key_encipherment"),
// 				pulumi.String("digital_signature"),
// 				pulumi.String("server_auth"),
// 			},
// 			DnsNames: pulumi.StringArray{
// 				pulumi.String("example.com"),
// 			},
// 			Subjects: SelfSignedCertSubjectArray{
// 				&SelfSignedCertSubjectArgs{
// 					CommonName:   pulumi.String("example.com"),
// 					Organization: pulumi.String("ACME Examples, Inc"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultSSLCertificate, err := compute.NewSSLCertificate(ctx, "defaultSSLCertificate", &compute.SSLCertificateArgs{
// 			PrivateKey:  defaultPrivateKey.PrivateKeyPem,
// 			Certificate: defaultSelfSignedCert.CertPem,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultHealthCheck, err := compute.NewHealthCheck(ctx, "defaultHealthCheck", &compute.HealthCheckArgs{
// 			TimeoutSec:       pulumi.Int(1),
// 			CheckIntervalSec: pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(443),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceTemplate, err := compute.NewInstanceTemplate(ctx, "defaultInstanceTemplate", &compute.InstanceTemplateArgs{
// 			MachineType: pulumi.String("e2-small"),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 			NetworkInterfaces: compute.InstanceTemplateNetworkInterfaceArray{
// 				&compute.InstanceTemplateNetworkInterfaceArgs{
// 					Network:    defaultNetwork.ID(),
// 					Subnetwork: defaultSubnetwork.ID(),
// 					AccessConfigs: compute.InstanceTemplateNetworkInterfaceAccessConfigArray{
// 						nil,
// 					},
// 				},
// 			},
// 			Disks: compute.InstanceTemplateDiskArray{
// 				&compute.InstanceTemplateDiskArgs{
// 					SourceImage: pulumi.String("debian-cloud/debian-10"),
// 					AutoDelete:  pulumi.Bool(true),
// 					Boot:        pulumi.Bool(true),
// 				},
// 			},
// 			Metadata: pulumi.AnyMap{
// 				"startup-script": pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "#! /bin/bash\n", "set -euo pipefail\n", "export DEBIAN_FRONTEND=noninteractive\n", "sudo apt-get update\n", "sudo apt-get install  -y apache2 jq\n", "sudo a2ensite default-ssl\n", "sudo a2enmod ssl\n", "sudo service apache2 restart\n", "NAME=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/hostname\")\n", "IP=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip\")\n", "METADATA=", "$", "(curl -f -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True\" | jq 'del(.[\"startup-script\"])')\n", "cat <<EOF > /var/www/html/index.html\n", "<h1>SSL Load Balancer</h1>\n", "<pre>\n", "Name: ", "$", "NAME\n", "IP: ", "$", "IP\n", "Metadata: ", "$", "METADATA\n", "</pre>\n", "EOF\n")),
// 			},
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceGroupManager, err := compute.NewInstanceGroupManager(ctx, "defaultInstanceGroupManager", &compute.InstanceGroupManagerArgs{
// 			Zone: pulumi.String("us-central1-c"),
// 			NamedPorts: compute.InstanceGroupManagerNamedPortArray{
// 				&compute.InstanceGroupManagerNamedPortArgs{
// 					Name: pulumi.String("tcp"),
// 					Port: pulumi.Int(443),
// 				},
// 			},
// 			Versions: compute.InstanceGroupManagerVersionArray{
// 				&compute.InstanceGroupManagerVersionArgs{
// 					InstanceTemplate: defaultInstanceTemplate.ID(),
// 					Name:             pulumi.String("primary"),
// 				},
// 			},
// 			BaseInstanceName: pulumi.String("vm"),
// 			TargetSize:       pulumi.Int(2),
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			Protocol:            pulumi.String("SSL"),
// 			PortName:            pulumi.String("tcp"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			TimeoutSec:          pulumi.Int(10),
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:          defaultInstanceGroupManager.InstanceGroup,
// 					BalancingMode:  pulumi.String("UTILIZATION"),
// 					MaxUtilization: pulumi.Float64(1),
// 					CapacityScaler: pulumi.Float64(1),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetSSLProxy, err := compute.NewTargetSSLProxy(ctx, "defaultTargetSSLProxy", &compute.TargetSSLProxyArgs{
// 			BackendService: defaultBackendService.ID(),
// 			SslCertificates: pulumi.StringArray{
// 				defaultSSLCertificate.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			IpProtocol:          pulumi.String("TCP"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			PortRange:           pulumi.String("443"),
// 			Target:              defaultTargetSSLProxy.ID(),
// 			IpAddress:           defaultGlobalAddress.ID(),
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewFirewall(ctx, "defaultFirewall", &compute.FirewallArgs{
// 			Direction: pulumi.String("INGRESS"),
// 			Network:   defaultNetwork.ID(),
// 			SourceRanges: pulumi.StringArray{
// 				pulumi.String("130.211.0.0/22"),
// 				pulumi.String("35.191.0.0/16"),
// 			},
// 			Allows: compute.FirewallAllowArray{
// 				&compute.FirewallAllowArgs{
// 					Protocol: pulumi.String("tcp"),
// 				},
// 			},
// 			TargetTags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 		}, pulumi.Provider(google))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### External Tcp Proxy Lb Mig Backend
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultNetwork, err := compute.NewNetwork(ctx, "defaultNetwork", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "defaultSubnetwork", &compute.SubnetworkArgs{
// 			IpCidrRange: pulumi.String("10.0.1.0/24"),
// 			Region:      pulumi.String("us-central1"),
// 			Network:     defaultNetwork.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultGlobalAddress, err := compute.NewGlobalAddress(ctx, "defaultGlobalAddress", nil, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultHealthCheck, err := compute.NewHealthCheck(ctx, "defaultHealthCheck", &compute.HealthCheckArgs{
// 			TimeoutSec:       pulumi.Int(1),
// 			CheckIntervalSec: pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(80),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceTemplate, err := compute.NewInstanceTemplate(ctx, "defaultInstanceTemplate", &compute.InstanceTemplateArgs{
// 			MachineType: pulumi.String("e2-small"),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 			NetworkInterfaces: compute.InstanceTemplateNetworkInterfaceArray{
// 				&compute.InstanceTemplateNetworkInterfaceArgs{
// 					Network:    defaultNetwork.ID(),
// 					Subnetwork: defaultSubnetwork.ID(),
// 					AccessConfigs: compute.InstanceTemplateNetworkInterfaceAccessConfigArray{
// 						nil,
// 					},
// 				},
// 			},
// 			Disks: compute.InstanceTemplateDiskArray{
// 				&compute.InstanceTemplateDiskArgs{
// 					SourceImage: pulumi.String("debian-cloud/debian-10"),
// 					AutoDelete:  pulumi.Bool(true),
// 					Boot:        pulumi.Bool(true),
// 				},
// 			},
// 			Metadata: pulumi.AnyMap{
// 				"startup-script": pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "#! /bin/bash\n", "set -euo pipefail\n", "export DEBIAN_FRONTEND=noninteractive\n", "apt-get update\n", "apt-get install -y nginx-light jq\n", "NAME=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/hostname\")\n", "IP=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip\")\n", "METADATA=", "$", "(curl -f -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True\" | jq 'del(.[\"startup-script\"])')\n", "cat <<EOF > /var/www/html/index.html\n", "<pre>\n", "Name: ", "$", "NAME\n", "IP: ", "$", "IP\n", "Metadata: ", "$", "METADATA\n", "</pre>\n", "EOF\n")),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceGroupManager, err := compute.NewInstanceGroupManager(ctx, "defaultInstanceGroupManager", &compute.InstanceGroupManagerArgs{
// 			Zone: pulumi.String("us-central1-c"),
// 			NamedPorts: compute.InstanceGroupManagerNamedPortArray{
// 				&compute.InstanceGroupManagerNamedPortArgs{
// 					Name: pulumi.String("tcp"),
// 					Port: pulumi.Int(110),
// 				},
// 			},
// 			Versions: compute.InstanceGroupManagerVersionArray{
// 				&compute.InstanceGroupManagerVersionArgs{
// 					InstanceTemplate: defaultInstanceTemplate.ID(),
// 					Name:             pulumi.String("primary"),
// 				},
// 			},
// 			BaseInstanceName: pulumi.String("vm"),
// 			TargetSize:       pulumi.Int(2),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			Protocol:            pulumi.String("TCP"),
// 			PortName:            pulumi.String("tcp"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			TimeoutSec:          pulumi.Int(10),
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:          defaultInstanceGroupManager.InstanceGroup,
// 					BalancingMode:  pulumi.String("UTILIZATION"),
// 					MaxUtilization: pulumi.Float64(1),
// 					CapacityScaler: pulumi.Float64(1),
// 				},
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetTCPProxy, err := compute.NewTargetTCPProxy(ctx, "defaultTargetTCPProxy", &compute.TargetTCPProxyArgs{
// 			BackendService: defaultBackendService.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			IpProtocol:          pulumi.String("TCP"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			PortRange:           pulumi.String("110"),
// 			Target:              defaultTargetTCPProxy.ID(),
// 			IpAddress:           defaultGlobalAddress.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewFirewall(ctx, "defaultFirewall", &compute.FirewallArgs{
// 			Direction: pulumi.String("INGRESS"),
// 			Network:   defaultNetwork.ID(),
// 			SourceRanges: pulumi.StringArray{
// 				pulumi.String("130.211.0.0/22"),
// 				pulumi.String("35.191.0.0/16"),
// 			},
// 			Allows: compute.FirewallAllowArray{
// 				&compute.FirewallAllowArgs{
// 					Protocol: pulumi.String("tcp"),
// 				},
// 			},
// 			TargetTags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### External Http Lb Mig Backend Custom Header
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultNetwork, err := compute.NewNetwork(ctx, "defaultNetwork", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "defaultSubnetwork", &compute.SubnetworkArgs{
// 			IpCidrRange: pulumi.String("10.0.1.0/24"),
// 			Region:      pulumi.String("us-central1"),
// 			Network:     defaultNetwork.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultGlobalAddress, err := compute.NewGlobalAddress(ctx, "defaultGlobalAddress", nil, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultHealthCheck, err := compute.NewHealthCheck(ctx, "defaultHealthCheck", &compute.HealthCheckArgs{
// 			HttpHealthCheck: &compute.HealthCheckHttpHealthCheckArgs{
// 				PortSpecification: pulumi.String("USE_SERVING_PORT"),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceTemplate, err := compute.NewInstanceTemplate(ctx, "defaultInstanceTemplate", &compute.InstanceTemplateArgs{
// 			MachineType: pulumi.String("e2-small"),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 			NetworkInterfaces: compute.InstanceTemplateNetworkInterfaceArray{
// 				&compute.InstanceTemplateNetworkInterfaceArgs{
// 					Network:    defaultNetwork.ID(),
// 					Subnetwork: defaultSubnetwork.ID(),
// 					AccessConfigs: compute.InstanceTemplateNetworkInterfaceAccessConfigArray{
// 						nil,
// 					},
// 				},
// 			},
// 			Disks: compute.InstanceTemplateDiskArray{
// 				&compute.InstanceTemplateDiskArgs{
// 					SourceImage: pulumi.String("debian-cloud/debian-10"),
// 					AutoDelete:  pulumi.Bool(true),
// 					Boot:        pulumi.Bool(true),
// 				},
// 			},
// 			Metadata: pulumi.AnyMap{
// 				"startup-script": pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "#! /bin/bash\n", "set -euo pipefail\n", "\n", "export DEBIAN_FRONTEND=noninteractive\n", "apt-get update\n", "apt-get install -y nginx-light jq\n", "\n", "NAME=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/hostname\")\n", "IP=", "$", "(curl -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip\")\n", "METADATA=", "$", "(curl -f -H \"Metadata-Flavor: Google\" \"http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=True\" | jq 'del(.[\"startup-script\"])')\n", "\n", "cat <<EOF > /var/www/html/index.html\n", "<pre>\n", "Name: ", "$", "NAME\n", "IP: ", "$", "IP\n", "Metadata: ", "$", "METADATA\n", "</pre>\n", "EOF\n")),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultInstanceGroupManager, err := compute.NewInstanceGroupManager(ctx, "defaultInstanceGroupManager", &compute.InstanceGroupManagerArgs{
// 			Zone: pulumi.String("us-central1-c"),
// 			NamedPorts: compute.InstanceGroupManagerNamedPortArray{
// 				&compute.InstanceGroupManagerNamedPortArgs{
// 					Name: pulumi.String("http"),
// 					Port: pulumi.Int(8080),
// 				},
// 			},
// 			Versions: compute.InstanceGroupManagerVersionArray{
// 				&compute.InstanceGroupManagerVersionArgs{
// 					InstanceTemplate: defaultInstanceTemplate.ID(),
// 					Name:             pulumi.String("primary"),
// 				},
// 			},
// 			BaseInstanceName: pulumi.String("vm"),
// 			TargetSize:       pulumi.Int(2),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			Protocol:            pulumi.String("HTTP"),
// 			PortName:            pulumi.String("my-port"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			TimeoutSec:          pulumi.Int(10),
// 			EnableCdn:           pulumi.Bool(true),
// 			CustomRequestHeaders: pulumi.StringArray{
// 				pulumi.String("X-Client-Geo-Location: {client_region_subdivision}, {client_city}"),
// 			},
// 			CustomResponseHeaders: pulumi.StringArray{
// 				pulumi.String("X-Cache-Hit: {cdn_cache_status}"),
// 			},
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:          defaultInstanceGroupManager.InstanceGroup,
// 					BalancingMode:  pulumi.String("UTILIZATION"),
// 					CapacityScaler: pulumi.Float64(1),
// 				},
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultURLMap, err := compute.NewURLMap(ctx, "defaultURLMap", &compute.URLMapArgs{
// 			DefaultService: defaultBackendService.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetHttpProxy, err := compute.NewTargetHttpProxy(ctx, "defaultTargetHttpProxy", &compute.TargetHttpProxyArgs{
// 			UrlMap: defaultURLMap.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			IpProtocol:          pulumi.String("TCP"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL"),
// 			PortRange:           pulumi.String("80"),
// 			Target:              defaultTargetHttpProxy.ID(),
// 			IpAddress:           defaultGlobalAddress.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewFirewall(ctx, "defaultFirewall", &compute.FirewallArgs{
// 			Direction: pulumi.String("INGRESS"),
// 			Network:   defaultNetwork.ID(),
// 			SourceRanges: pulumi.StringArray{
// 				pulumi.String("130.211.0.0/22"),
// 				pulumi.String("35.191.0.0/16"),
// 			},
// 			Allows: compute.FirewallAllowArray{
// 				&compute.FirewallAllowArgs{
// 					Protocol: pulumi.String("tcp"),
// 				},
// 			},
// 			TargetTags: pulumi.StringArray{
// 				pulumi.String("allow-health-check"),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Global Forwarding Rule Http
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "defaultHttpHealthCheck", &compute.HttpHealthCheckArgs{
// 			RequestPath:      pulumi.String("/"),
// 			CheckIntervalSec: pulumi.Int(1),
// 			TimeoutSec:       pulumi.Int(1),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			PortName:   pulumi.String("http"),
// 			Protocol:   pulumi.String("HTTP"),
// 			TimeoutSec: pulumi.Int(10),
// 			HealthChecks: pulumi.String{
// 				defaultHttpHealthCheck.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultURLMap, err := compute.NewURLMap(ctx, "defaultURLMap", &compute.URLMapArgs{
// 			Description:    pulumi.String("a description"),
// 			DefaultService: defaultBackendService.ID(),
// 			HostRules: compute.URLMapHostRuleArray{
// 				&compute.URLMapHostRuleArgs{
// 					Hosts: pulumi.StringArray{
// 						pulumi.String("mysite.com"),
// 					},
// 					PathMatcher: pulumi.String("allpaths"),
// 				},
// 			},
// 			PathMatchers: compute.URLMapPathMatcherArray{
// 				&compute.URLMapPathMatcherArgs{
// 					Name:           pulumi.String("allpaths"),
// 					DefaultService: defaultBackendService.ID(),
// 					PathRules: compute.URLMapPathMatcherPathRuleArray{
// 						&compute.URLMapPathMatcherPathRuleArgs{
// 							Paths: pulumi.StringArray{
// 								pulumi.String("/*"),
// 							},
// 							Service: defaultBackendService.ID(),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetHttpProxy, err := compute.NewTargetHttpProxy(ctx, "defaultTargetHttpProxy", &compute.TargetHttpProxyArgs{
// 			Description: pulumi.String("a description"),
// 			UrlMap:      defaultURLMap.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			Target:    defaultTargetHttpProxy.ID(),
// 			PortRange: pulumi.String("80"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Global Forwarding Rule Internal
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		debianImage, err := compute.LookupImage(ctx, &compute.LookupImageArgs{
// 			Family:  pulumi.StringRef("debian-9"),
// 			Project: pulumi.StringRef("debian-cloud"),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		instanceTemplate, err := compute.NewInstanceTemplate(ctx, "instanceTemplate", &compute.InstanceTemplateArgs{
// 			MachineType: pulumi.String("e2-medium"),
// 			NetworkInterfaces: compute.InstanceTemplateNetworkInterfaceArray{
// 				&compute.InstanceTemplateNetworkInterfaceArgs{
// 					Network: pulumi.String("default"),
// 				},
// 			},
// 			Disks: compute.InstanceTemplateDiskArray{
// 				&compute.InstanceTemplateDiskArgs{
// 					SourceImage: pulumi.String(debianImage.SelfLink),
// 					AutoDelete:  pulumi.Bool(true),
// 					Boot:        pulumi.Bool(true),
// 				},
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		igm, err := compute.NewInstanceGroupManager(ctx, "igm", &compute.InstanceGroupManagerArgs{
// 			Versions: compute.InstanceGroupManagerVersionArray{
// 				&compute.InstanceGroupManagerVersionArgs{
// 					InstanceTemplate: instanceTemplate.ID(),
// 					Name:             pulumi.String("primary"),
// 				},
// 			},
// 			BaseInstanceName: pulumi.String("internal-glb"),
// 			Zone:             pulumi.String("us-central1-f"),
// 			TargetSize:       pulumi.Int(1),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultHealthCheck, err := compute.NewHealthCheck(ctx, "defaultHealthCheck", &compute.HealthCheckArgs{
// 			CheckIntervalSec: pulumi.Int(1),
// 			TimeoutSec:       pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(80),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			PortName:            pulumi.String("http"),
// 			Protocol:            pulumi.String("HTTP"),
// 			TimeoutSec:          pulumi.Int(10),
// 			LoadBalancingScheme: pulumi.String("INTERNAL_SELF_MANAGED"),
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:              igm.InstanceGroup,
// 					BalancingMode:      pulumi.String("RATE"),
// 					CapacityScaler:     pulumi.Float64(0.4),
// 					MaxRatePerInstance: pulumi.Float64(50),
// 				},
// 			},
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultURLMap, err := compute.NewURLMap(ctx, "defaultURLMap", &compute.URLMapArgs{
// 			Description:    pulumi.String("a description"),
// 			DefaultService: defaultBackendService.ID(),
// 			HostRules: compute.URLMapHostRuleArray{
// 				&compute.URLMapHostRuleArgs{
// 					Hosts: pulumi.StringArray{
// 						pulumi.String("mysite.com"),
// 					},
// 					PathMatcher: pulumi.String("allpaths"),
// 				},
// 			},
// 			PathMatchers: compute.URLMapPathMatcherArray{
// 				&compute.URLMapPathMatcherArgs{
// 					Name:           pulumi.String("allpaths"),
// 					DefaultService: defaultBackendService.ID(),
// 					PathRules: compute.URLMapPathMatcherPathRuleArray{
// 						&compute.URLMapPathMatcherPathRuleArgs{
// 							Paths: pulumi.StringArray{
// 								pulumi.String("/*"),
// 							},
// 							Service: defaultBackendService.ID(),
// 						},
// 					},
// 				},
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetHttpProxy, err := compute.NewTargetHttpProxy(ctx, "defaultTargetHttpProxy", &compute.TargetHttpProxyArgs{
// 			Description: pulumi.String("a description"),
// 			UrlMap:      defaultURLMap.ID(),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			Target:              defaultTargetHttpProxy.ID(),
// 			PortRange:           pulumi.String("80"),
// 			LoadBalancingScheme: pulumi.String("INTERNAL_SELF_MANAGED"),
// 			IpAddress:           pulumi.String("0.0.0.0"),
// 			MetadataFilters: compute.GlobalForwardingRuleMetadataFilterArray{
// 				&compute.GlobalForwardingRuleMetadataFilterArgs{
// 					FilterMatchCriteria: pulumi.String("MATCH_ANY"),
// 					FilterLabels: compute.GlobalForwardingRuleMetadataFilterFilterLabelArray{
// 						&compute.GlobalForwardingRuleMetadataFilterFilterLabelArgs{
// 							Name:  pulumi.String("PLANET"),
// 							Value: pulumi.String("MARS"),
// 						},
// 					},
// 				},
// 			},
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Global Forwarding Rule External Managed
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			PortName:            pulumi.String("http"),
// 			Protocol:            pulumi.String("HTTP"),
// 			TimeoutSec:          pulumi.Int(10),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL_MANAGED"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultURLMap, err := compute.NewURLMap(ctx, "defaultURLMap", &compute.URLMapArgs{
// 			Description:    pulumi.String("a description"),
// 			DefaultService: defaultBackendService.ID(),
// 			HostRules: compute.URLMapHostRuleArray{
// 				&compute.URLMapHostRuleArgs{
// 					Hosts: pulumi.StringArray{
// 						pulumi.String("mysite.com"),
// 					},
// 					PathMatcher: pulumi.String("allpaths"),
// 				},
// 			},
// 			PathMatchers: compute.URLMapPathMatcherArray{
// 				&compute.URLMapPathMatcherArgs{
// 					Name:           pulumi.String("allpaths"),
// 					DefaultService: defaultBackendService.ID(),
// 					PathRules: compute.URLMapPathMatcherPathRuleArray{
// 						&compute.URLMapPathMatcherPathRuleArgs{
// 							Paths: pulumi.StringArray{
// 								pulumi.String("/*"),
// 							},
// 							Service: defaultBackendService.ID(),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetHttpProxy, err := compute.NewTargetHttpProxy(ctx, "defaultTargetHttpProxy", &compute.TargetHttpProxyArgs{
// 			Description: pulumi.String("a description"),
// 			UrlMap:      defaultURLMap.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			Target:              defaultTargetHttpProxy.ID(),
// 			PortRange:           pulumi.String("80"),
// 			LoadBalancingScheme: pulumi.String("EXTERNAL_MANAGED"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Global Forwarding Rule Hybrid
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		defaultNetwork, err := compute.NewNetwork(ctx, "defaultNetwork", nil)
// 		if err != nil {
// 			return err
// 		}
// 		defaultNetworkEndpointGroup, err := compute.NewNetworkEndpointGroup(ctx, "defaultNetworkEndpointGroup", &compute.NetworkEndpointGroupArgs{
// 			Network:             defaultNetwork.ID(),
// 			DefaultPort:         pulumi.Int(90),
// 			Zone:                pulumi.String("us-central1-a"),
// 			NetworkEndpointType: pulumi.String("GCE_VM_IP_PORT"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		hybridNetworkEndpointGroup, err := compute.NewNetworkEndpointGroup(ctx, "hybridNetworkEndpointGroup", &compute.NetworkEndpointGroupArgs{
// 			Network:             defaultNetwork.ID(),
// 			DefaultPort:         pulumi.Int(90),
// 			Zone:                pulumi.String("us-central1-a"),
// 			NetworkEndpointType: pulumi.String("NON_GCP_PRIVATE_IP_PORT"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewNetworkEndpoint(ctx, "hybrid-endpoint", &compute.NetworkEndpointArgs{
// 			NetworkEndpointGroup: hybridNetworkEndpointGroup.Name,
// 			Port:                 hybridNetworkEndpointGroup.DefaultPort,
// 			IpAddress:            pulumi.String("127.0.0.1"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultHealthCheck, err := compute.NewHealthCheck(ctx, "defaultHealthCheck", &compute.HealthCheckArgs{
// 			TimeoutSec:       pulumi.Int(1),
// 			CheckIntervalSec: pulumi.Int(1),
// 			TcpHealthCheck: &compute.HealthCheckTcpHealthCheckArgs{
// 				Port: pulumi.Int(80),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultBackendService, err := compute.NewBackendService(ctx, "defaultBackendService", &compute.BackendServiceArgs{
// 			PortName:   pulumi.String("http"),
// 			Protocol:   pulumi.String("HTTP"),
// 			TimeoutSec: pulumi.Int(10),
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:              defaultNetworkEndpointGroup.ID(),
// 					BalancingMode:      pulumi.String("RATE"),
// 					MaxRatePerEndpoint: pulumi.Float64(10),
// 				},
// 			},
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		hybridBackendService, err := compute.NewBackendService(ctx, "hybridBackendService", &compute.BackendServiceArgs{
// 			PortName:   pulumi.String("http"),
// 			Protocol:   pulumi.String("HTTP"),
// 			TimeoutSec: pulumi.Int(10),
// 			Backends: compute.BackendServiceBackendArray{
// 				&compute.BackendServiceBackendArgs{
// 					Group:              hybridNetworkEndpointGroup.ID(),
// 					BalancingMode:      pulumi.String("RATE"),
// 					MaxRatePerEndpoint: pulumi.Float64(10),
// 				},
// 			},
// 			HealthChecks: pulumi.String{
// 				defaultHealthCheck.ID(),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultURLMap, err := compute.NewURLMap(ctx, "defaultURLMap", &compute.URLMapArgs{
// 			Description:    pulumi.String("a description"),
// 			DefaultService: defaultBackendService.ID(),
// 			HostRules: compute.URLMapHostRuleArray{
// 				&compute.URLMapHostRuleArgs{
// 					Hosts: pulumi.StringArray{
// 						pulumi.String("mysite.com"),
// 					},
// 					PathMatcher: pulumi.String("allpaths"),
// 				},
// 			},
// 			PathMatchers: compute.URLMapPathMatcherArray{
// 				&compute.URLMapPathMatcherArgs{
// 					Name:           pulumi.String("allpaths"),
// 					DefaultService: defaultBackendService.ID(),
// 					PathRules: compute.URLMapPathMatcherPathRuleArray{
// 						&compute.URLMapPathMatcherPathRuleArgs{
// 							Paths: pulumi.StringArray{
// 								pulumi.String("/*"),
// 							},
// 							Service: defaultBackendService.ID(),
// 						},
// 						&compute.URLMapPathMatcherPathRuleArgs{
// 							Paths: pulumi.StringArray{
// 								pulumi.String("/hybrid"),
// 							},
// 							Service: hybridBackendService.ID(),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		defaultTargetHttpProxy, err := compute.NewTargetHttpProxy(ctx, "defaultTargetHttpProxy", &compute.TargetHttpProxyArgs{
// 			Description: pulumi.String("a description"),
// 			UrlMap:      defaultURLMap.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			Target:    defaultTargetHttpProxy.ID(),
// 			PortRange: pulumi.String("80"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Private Service Connect Google Apis
// ### Private Service Connect Google Apis
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
// 			Project:               pulumi.String("my-project-name"),
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewSubnetwork(ctx, "vpcSubnetwork", &compute.SubnetworkArgs{
// 			Project:               network.Project,
// 			IpCidrRange:           pulumi.String("10.2.0.0/16"),
// 			Region:                pulumi.String("us-central1"),
// 			Network:               network.ID(),
// 			PrivateIpGoogleAccess: pulumi.Bool(true),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		defaultGlobalAddress, err := compute.NewGlobalAddress(ctx, "defaultGlobalAddress", &compute.GlobalAddressArgs{
// 			Project:     network.Project,
// 			AddressType: pulumi.String("INTERNAL"),
// 			Purpose:     pulumi.String("PRIVATE_SERVICE_CONNECT"),
// 			Network:     network.ID(),
// 			Address:     pulumi.String("100.100.100.106"),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewGlobalForwardingRule(ctx, "defaultGlobalForwardingRule", &compute.GlobalForwardingRuleArgs{
// 			Project:             network.Project,
// 			Target:              pulumi.String("all-apis"),
// 			Network:             network.ID(),
// 			IpAddress:           defaultGlobalAddress.ID(),
// 			LoadBalancingScheme: pulumi.String(""),
// 		}, pulumi.Provider(google_beta))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// GlobalForwardingRule can be imported using any of these accepted formats
//
// ```sh
//  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default projects/{{project}}/global/forwardingRules/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default {{project}}/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:compute/globalForwardingRule:GlobalForwardingRule default {{name}}
// ```
type GlobalForwardingRule struct {
	pulumi.CustomResourceState

	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IpAddress pulumi.StringOutput `pulumi:"ipAddress"`
	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
	IpProtocol pulumi.StringOutput `pulumi:"ipProtocol"`
	// The IP Version that will be used by this global forwarding rule.
	// Possible values are `IPV4` and `IPV6`.
	IpVersion pulumi.StringPtrOutput `pulumi:"ipVersion"`
	// Used internally during label updates.
	LabelFingerprint pulumi.StringOutput `pulumi:"labelFingerprint"`
	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy)
	// Note: This field must be set "" if the global address is
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is `EXTERNAL`.
	// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
	LoadBalancingScheme pulumi.StringPtrOutput `pulumi:"loadBalancingScheme"`
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters GlobalForwardingRuleMetadataFilterArrayOutput `pulumi:"metadataFilters"`
	// Name of the metadata label. The length must be between
	// 1 and 1024 characters, inclusive.
	Name pulumi.StringOutput `pulumi:"name"`
	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	Network pulumi.StringOutput `pulumi:"network"`
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// * TargetHttpProxy: 80, 8080
	// * TargetHttpsProxy: 443
	// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetVpnGateway: 500, 4500
	PortRange pulumi.StringPtrOutput `pulumi:"portRange"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The PSC connection id of the PSC Forwarding Rule.
	PscConnectionId pulumi.StringOutput `pulumi:"pscConnectionId"`
	// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
	// CLOSED
	PscConnectionStatus pulumi.StringOutput `pulumi:"pscConnectionStatus"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	Target pulumi.StringOutput `pulumi:"target"`
}

// NewGlobalForwardingRule registers a new resource with the given unique name, arguments, and options.
func NewGlobalForwardingRule(ctx *pulumi.Context,
	name string, args *GlobalForwardingRuleArgs, opts ...pulumi.ResourceOption) (*GlobalForwardingRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Target == nil {
		return nil, errors.New("invalid value for required argument 'Target'")
	}
	var resource GlobalForwardingRule
	err := ctx.RegisterResource("gcp:compute/globalForwardingRule:GlobalForwardingRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGlobalForwardingRule gets an existing GlobalForwardingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGlobalForwardingRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GlobalForwardingRuleState, opts ...pulumi.ResourceOption) (*GlobalForwardingRule, error) {
	var resource GlobalForwardingRule
	err := ctx.ReadResource("gcp:compute/globalForwardingRule:GlobalForwardingRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GlobalForwardingRule resources.
type globalForwardingRuleState struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description *string `pulumi:"description"`
	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IpAddress *string `pulumi:"ipAddress"`
	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
	IpProtocol *string `pulumi:"ipProtocol"`
	// The IP Version that will be used by this global forwarding rule.
	// Possible values are `IPV4` and `IPV6`.
	IpVersion *string `pulumi:"ipVersion"`
	// Used internally during label updates.
	LabelFingerprint *string `pulumi:"labelFingerprint"`
	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	Labels map[string]string `pulumi:"labels"`
	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy)
	// Note: This field must be set "" if the global address is
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is `EXTERNAL`.
	// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
	LoadBalancingScheme *string `pulumi:"loadBalancingScheme"`
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters []GlobalForwardingRuleMetadataFilter `pulumi:"metadataFilters"`
	// Name of the metadata label. The length must be between
	// 1 and 1024 characters, inclusive.
	Name *string `pulumi:"name"`
	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	Network *string `pulumi:"network"`
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// * TargetHttpProxy: 80, 8080
	// * TargetHttpsProxy: 443
	// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetVpnGateway: 500, 4500
	PortRange *string `pulumi:"portRange"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The PSC connection id of the PSC Forwarding Rule.
	PscConnectionId *string `pulumi:"pscConnectionId"`
	// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
	// CLOSED
	PscConnectionStatus *string `pulumi:"pscConnectionStatus"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	Target *string `pulumi:"target"`
}

type GlobalForwardingRuleState struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrInput
	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IpAddress pulumi.StringPtrInput
	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
	IpProtocol pulumi.StringPtrInput
	// The IP Version that will be used by this global forwarding rule.
	// Possible values are `IPV4` and `IPV6`.
	IpVersion pulumi.StringPtrInput
	// Used internally during label updates.
	LabelFingerprint pulumi.StringPtrInput
	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	Labels pulumi.StringMapInput
	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy)
	// Note: This field must be set "" if the global address is
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is `EXTERNAL`.
	// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
	LoadBalancingScheme pulumi.StringPtrInput
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters GlobalForwardingRuleMetadataFilterArrayInput
	// Name of the metadata label. The length must be between
	// 1 and 1024 characters, inclusive.
	Name pulumi.StringPtrInput
	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	Network pulumi.StringPtrInput
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// * TargetHttpProxy: 80, 8080
	// * TargetHttpsProxy: 443
	// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetVpnGateway: 500, 4500
	PortRange pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The PSC connection id of the PSC Forwarding Rule.
	PscConnectionId pulumi.StringPtrInput
	// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
	// CLOSED
	PscConnectionStatus pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	Target pulumi.StringPtrInput
}

func (GlobalForwardingRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*globalForwardingRuleState)(nil)).Elem()
}

type globalForwardingRuleArgs struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description *string `pulumi:"description"`
	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IpAddress *string `pulumi:"ipAddress"`
	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
	IpProtocol *string `pulumi:"ipProtocol"`
	// The IP Version that will be used by this global forwarding rule.
	// Possible values are `IPV4` and `IPV6`.
	IpVersion *string `pulumi:"ipVersion"`
	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	Labels map[string]string `pulumi:"labels"`
	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy)
	// Note: This field must be set "" if the global address is
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is `EXTERNAL`.
	// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
	LoadBalancingScheme *string `pulumi:"loadBalancingScheme"`
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters []GlobalForwardingRuleMetadataFilter `pulumi:"metadataFilters"`
	// Name of the metadata label. The length must be between
	// 1 and 1024 characters, inclusive.
	Name *string `pulumi:"name"`
	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	Network *string `pulumi:"network"`
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// * TargetHttpProxy: 80, 8080
	// * TargetHttpsProxy: 443
	// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetVpnGateway: 500, 4500
	PortRange *string `pulumi:"portRange"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	Target string `pulumi:"target"`
}

// The set of arguments for constructing a GlobalForwardingRule resource.
type GlobalForwardingRuleArgs struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrInput
	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IpAddress pulumi.StringPtrInput
	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
	IpProtocol pulumi.StringPtrInput
	// The IP Version that will be used by this global forwarding rule.
	// Possible values are `IPV4` and `IPV6`.
	IpVersion pulumi.StringPtrInput
	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	Labels pulumi.StringMapInput
	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy)
	// Note: This field must be set "" if the global address is
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is `EXTERNAL`.
	// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
	LoadBalancingScheme pulumi.StringPtrInput
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	MetadataFilters GlobalForwardingRuleMetadataFilterArrayInput
	// Name of the metadata label. The length must be between
	// 1 and 1024 characters, inclusive.
	Name pulumi.StringPtrInput
	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	Network pulumi.StringPtrInput
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// * TargetHttpProxy: 80, 8080
	// * TargetHttpsProxy: 443
	// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	//   1883, 5222
	// * TargetVpnGateway: 500, 4500
	PortRange pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	Target pulumi.StringInput
}

func (GlobalForwardingRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*globalForwardingRuleArgs)(nil)).Elem()
}

type GlobalForwardingRuleInput interface {
	pulumi.Input

	ToGlobalForwardingRuleOutput() GlobalForwardingRuleOutput
	ToGlobalForwardingRuleOutputWithContext(ctx context.Context) GlobalForwardingRuleOutput
}

func (*GlobalForwardingRule) ElementType() reflect.Type {
	return reflect.TypeOf((**GlobalForwardingRule)(nil)).Elem()
}

func (i *GlobalForwardingRule) ToGlobalForwardingRuleOutput() GlobalForwardingRuleOutput {
	return i.ToGlobalForwardingRuleOutputWithContext(context.Background())
}

func (i *GlobalForwardingRule) ToGlobalForwardingRuleOutputWithContext(ctx context.Context) GlobalForwardingRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlobalForwardingRuleOutput)
}

// GlobalForwardingRuleArrayInput is an input type that accepts GlobalForwardingRuleArray and GlobalForwardingRuleArrayOutput values.
// You can construct a concrete instance of `GlobalForwardingRuleArrayInput` via:
//
//          GlobalForwardingRuleArray{ GlobalForwardingRuleArgs{...} }
type GlobalForwardingRuleArrayInput interface {
	pulumi.Input

	ToGlobalForwardingRuleArrayOutput() GlobalForwardingRuleArrayOutput
	ToGlobalForwardingRuleArrayOutputWithContext(context.Context) GlobalForwardingRuleArrayOutput
}

type GlobalForwardingRuleArray []GlobalForwardingRuleInput

func (GlobalForwardingRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GlobalForwardingRule)(nil)).Elem()
}

func (i GlobalForwardingRuleArray) ToGlobalForwardingRuleArrayOutput() GlobalForwardingRuleArrayOutput {
	return i.ToGlobalForwardingRuleArrayOutputWithContext(context.Background())
}

func (i GlobalForwardingRuleArray) ToGlobalForwardingRuleArrayOutputWithContext(ctx context.Context) GlobalForwardingRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlobalForwardingRuleArrayOutput)
}

// GlobalForwardingRuleMapInput is an input type that accepts GlobalForwardingRuleMap and GlobalForwardingRuleMapOutput values.
// You can construct a concrete instance of `GlobalForwardingRuleMapInput` via:
//
//          GlobalForwardingRuleMap{ "key": GlobalForwardingRuleArgs{...} }
type GlobalForwardingRuleMapInput interface {
	pulumi.Input

	ToGlobalForwardingRuleMapOutput() GlobalForwardingRuleMapOutput
	ToGlobalForwardingRuleMapOutputWithContext(context.Context) GlobalForwardingRuleMapOutput
}

type GlobalForwardingRuleMap map[string]GlobalForwardingRuleInput

func (GlobalForwardingRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GlobalForwardingRule)(nil)).Elem()
}

func (i GlobalForwardingRuleMap) ToGlobalForwardingRuleMapOutput() GlobalForwardingRuleMapOutput {
	return i.ToGlobalForwardingRuleMapOutputWithContext(context.Background())
}

func (i GlobalForwardingRuleMap) ToGlobalForwardingRuleMapOutputWithContext(ctx context.Context) GlobalForwardingRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlobalForwardingRuleMapOutput)
}

type GlobalForwardingRuleOutput struct{ *pulumi.OutputState }

func (GlobalForwardingRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GlobalForwardingRule)(nil)).Elem()
}

func (o GlobalForwardingRuleOutput) ToGlobalForwardingRuleOutput() GlobalForwardingRuleOutput {
	return o
}

func (o GlobalForwardingRuleOutput) ToGlobalForwardingRuleOutputWithContext(ctx context.Context) GlobalForwardingRuleOutput {
	return o
}

// An optional description of this resource. Provide this property when
// you create the resource.
func (o GlobalForwardingRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The IP address that this forwarding rule serves. When a client sends
// traffic to this IP address, the forwarding rule directs the traffic to
// the target that you specify in the forwarding rule. The
// loadBalancingScheme and the forwarding rule's target determine the
// type of IP address that you can use. For detailed information, refer
// to [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
// An address can be specified either by a literal IP address or a
// reference to an existing Address resource. If you don't specify a
// reserved IP address, an ephemeral IP address is assigned.
// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
// that has validateForProxyless field set to true.
// For Private Service Connect forwarding rules that forward traffic to
// Google APIs, IP address must be provided.
func (o GlobalForwardingRuleOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.IpAddress }).(pulumi.StringOutput)
}

// The IP protocol to which this rule applies. When the load balancing scheme is
// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
// and addressType of INTERNAL
// Possible values are `TCP`, `UDP`, `ESP`, `AH`, `SCTP`, and `ICMP`.
func (o GlobalForwardingRuleOutput) IpProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.IpProtocol }).(pulumi.StringOutput)
}

// The IP Version that will be used by this global forwarding rule.
// Possible values are `IPV4` and `IPV6`.
func (o GlobalForwardingRuleOutput) IpVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringPtrOutput { return v.IpVersion }).(pulumi.StringPtrOutput)
}

// Used internally during label updates.
func (o GlobalForwardingRuleOutput) LabelFingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.LabelFingerprint }).(pulumi.StringOutput)
}

// Labels to apply to this forwarding rule.  A list of key->value pairs.
func (o GlobalForwardingRuleOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// This signifies what the GlobalForwardingRule will be used for.
// The value of INTERNAL_SELF_MANAGED means that this will be used for
// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
// will be used for External Global Load Balancing (HTTP(S) LB,
// External TCP/UDP LB, SSL Proxy)
// Note: This field must be set "" if the global address is
// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
// that this will be used for Global external HTTP(S) load balancers.
// Note: This field must be set "" if the global address is
// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
// Default value is `EXTERNAL`.
// Possible values are `EXTERNAL`, `EXTERNAL_MANAGED`, and `INTERNAL_SELF_MANAGED`.
func (o GlobalForwardingRuleOutput) LoadBalancingScheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringPtrOutput { return v.LoadBalancingScheme }).(pulumi.StringPtrOutput)
}

// Opaque filter criteria used by Loadbalancer to restrict routing
// configuration to a limited set xDS compliant clients. In their xDS
// requests to Loadbalancer, xDS clients present node metadata. If a
// match takes place, the relevant routing configuration is made available
// to those proxies.
// For each metadataFilter in this list, if its filterMatchCriteria is set
// to MATCH_ANY, at least one of the filterLabels must match the
// corresponding label provided in the metadata. If its filterMatchCriteria
// is set to MATCH_ALL, then all of its filterLabels must match with
// corresponding labels in the provided metadata.
// metadataFilters specified here can be overridden by those specified in
// the UrlMap that this ForwardingRule references.
// metadataFilters only applies to Loadbalancers that have their
// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
// Structure is documented below.
func (o GlobalForwardingRuleOutput) MetadataFilters() GlobalForwardingRuleMetadataFilterArrayOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) GlobalForwardingRuleMetadataFilterArrayOutput { return v.MetadataFilters }).(GlobalForwardingRuleMetadataFilterArrayOutput)
}

// Name of the metadata label. The length must be between
// 1 and 1024 characters, inclusive.
func (o GlobalForwardingRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// This field is not used for external load balancing.
// For INTERNAL_SELF_MANAGED load balancing, this field
// identifies the network that the load balanced IP should belong to
// for this global forwarding rule. If this field is not specified,
// the default network will be used.
func (o GlobalForwardingRuleOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.Network }).(pulumi.StringOutput)
}

// This field is used along with the target field for TargetHttpProxy,
// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
// TargetPool, TargetInstance.
// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
// addressed to ports in the specified range will be forwarded to target.
// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
// disjoint port ranges.
// Some types of forwarding target have constraints on the acceptable
// ports:
// * TargetHttpProxy: 80, 8080
// * TargetHttpsProxy: 443
// * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
//   1883, 5222
// * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
//   1883, 5222
// * TargetVpnGateway: 500, 4500
func (o GlobalForwardingRuleOutput) PortRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringPtrOutput { return v.PortRange }).(pulumi.StringPtrOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o GlobalForwardingRuleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The PSC connection id of the PSC Forwarding Rule.
func (o GlobalForwardingRuleOutput) PscConnectionId() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.PscConnectionId }).(pulumi.StringOutput)
}

// The PSC connection status of the PSC Forwarding Rule. Possible values: STATUS_UNSPECIFIED, PENDING, ACCEPTED, REJECTED,
// CLOSED
func (o GlobalForwardingRuleOutput) PscConnectionStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.PscConnectionStatus }).(pulumi.StringOutput)
}

// The URI of the created resource.
func (o GlobalForwardingRuleOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// The URL of the target resource to receive the matched traffic.
// The forwarded traffic must be of a type appropriate to the target object.
// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
// are valid.
// For global address with a purpose of PRIVATE_SERVICE_CONNECT and
// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
func (o GlobalForwardingRuleOutput) Target() pulumi.StringOutput {
	return o.ApplyT(func(v *GlobalForwardingRule) pulumi.StringOutput { return v.Target }).(pulumi.StringOutput)
}

type GlobalForwardingRuleArrayOutput struct{ *pulumi.OutputState }

func (GlobalForwardingRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GlobalForwardingRule)(nil)).Elem()
}

func (o GlobalForwardingRuleArrayOutput) ToGlobalForwardingRuleArrayOutput() GlobalForwardingRuleArrayOutput {
	return o
}

func (o GlobalForwardingRuleArrayOutput) ToGlobalForwardingRuleArrayOutputWithContext(ctx context.Context) GlobalForwardingRuleArrayOutput {
	return o
}

func (o GlobalForwardingRuleArrayOutput) Index(i pulumi.IntInput) GlobalForwardingRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GlobalForwardingRule {
		return vs[0].([]*GlobalForwardingRule)[vs[1].(int)]
	}).(GlobalForwardingRuleOutput)
}

type GlobalForwardingRuleMapOutput struct{ *pulumi.OutputState }

func (GlobalForwardingRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GlobalForwardingRule)(nil)).Elem()
}

func (o GlobalForwardingRuleMapOutput) ToGlobalForwardingRuleMapOutput() GlobalForwardingRuleMapOutput {
	return o
}

func (o GlobalForwardingRuleMapOutput) ToGlobalForwardingRuleMapOutputWithContext(ctx context.Context) GlobalForwardingRuleMapOutput {
	return o
}

func (o GlobalForwardingRuleMapOutput) MapIndex(k pulumi.StringInput) GlobalForwardingRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GlobalForwardingRule {
		return vs[0].(map[string]*GlobalForwardingRule)[vs[1].(string)]
	}).(GlobalForwardingRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GlobalForwardingRuleInput)(nil)).Elem(), &GlobalForwardingRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*GlobalForwardingRuleArrayInput)(nil)).Elem(), GlobalForwardingRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GlobalForwardingRuleMapInput)(nil)).Elem(), GlobalForwardingRuleMap{})
	pulumi.RegisterOutputType(GlobalForwardingRuleOutput{})
	pulumi.RegisterOutputType(GlobalForwardingRuleArrayOutput{})
	pulumi.RegisterOutputType(GlobalForwardingRuleMapOutput{})
}
