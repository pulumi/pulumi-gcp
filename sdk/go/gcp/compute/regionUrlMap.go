// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v7/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// UrlMaps are used to route requests to a backend service based on rules
// that you define for the host and path of an incoming URL.
//
// ## Example Usage
//
// ## Import
//
// # RegionUrlMap can be imported using any of these accepted formats
//
// ```sh
//
//	$ pulumi import gcp:compute/regionUrlMap:RegionUrlMap default projects/{{project}}/regions/{{region}}/urlMaps/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/regionUrlMap:RegionUrlMap default {{project}}/{{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/regionUrlMap:RegionUrlMap default {{region}}/{{name}}
//
// ```
//
// ```sh
//
//	$ pulumi import gcp:compute/regionUrlMap:RegionUrlMap default {{name}}
//
// ```
type RegionUrlMap struct {
	pulumi.CustomResourceState

	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringOutput `pulumi:"creationTimestamp"`
	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
	// Structure is documented below.
	DefaultRouteAction RegionUrlMapDefaultRouteActionPtrOutput `pulumi:"defaultRouteAction"`
	// The full or partial URL of the defaultService resource to which traffic is directed if
	// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
	// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.  Only one of defaultService,
	// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
	DefaultService pulumi.StringPtrOutput `pulumi:"defaultService"`
	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultUrlRedirect RegionUrlMapDefaultUrlRedirectPtrOutput `pulumi:"defaultUrlRedirect"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringOutput `pulumi:"fingerprint"`
	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRules RegionUrlMapHostRuleArrayOutput `pulumi:"hostRules"`
	// The unique identifier for the resource.
	MapId pulumi.IntOutput `pulumi:"mapId"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression `a-z?` which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// ***
	Name pulumi.StringOutput `pulumi:"name"`
	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatchers RegionUrlMapPathMatcherArrayOutput `pulumi:"pathMatchers"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	Region pulumi.StringOutput `pulumi:"region"`
	// The URI of the created resource.
	SelfLink pulumi.StringOutput `pulumi:"selfLink"`
	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	Tests RegionUrlMapTestArrayOutput `pulumi:"tests"`
}

// NewRegionUrlMap registers a new resource with the given unique name, arguments, and options.
func NewRegionUrlMap(ctx *pulumi.Context,
	name string, args *RegionUrlMapArgs, opts ...pulumi.ResourceOption) (*RegionUrlMap, error) {
	if args == nil {
		args = &RegionUrlMapArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RegionUrlMap
	err := ctx.RegisterResource("gcp:compute/regionUrlMap:RegionUrlMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRegionUrlMap gets an existing RegionUrlMap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRegionUrlMap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RegionUrlMapState, opts ...pulumi.ResourceOption) (*RegionUrlMap, error) {
	var resource RegionUrlMap
	err := ctx.ReadResource("gcp:compute/regionUrlMap:RegionUrlMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RegionUrlMap resources.
type regionUrlMapState struct {
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `pulumi:"creationTimestamp"`
	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
	// Structure is documented below.
	DefaultRouteAction *RegionUrlMapDefaultRouteAction `pulumi:"defaultRouteAction"`
	// The full or partial URL of the defaultService resource to which traffic is directed if
	// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
	// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.  Only one of defaultService,
	// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
	DefaultService *string `pulumi:"defaultService"`
	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultUrlRedirect *RegionUrlMapDefaultUrlRedirect `pulumi:"defaultUrlRedirect"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description *string `pulumi:"description"`
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint *string `pulumi:"fingerprint"`
	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRules []RegionUrlMapHostRule `pulumi:"hostRules"`
	// The unique identifier for the resource.
	MapId *int `pulumi:"mapId"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression `a-z?` which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// ***
	Name *string `pulumi:"name"`
	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatchers []RegionUrlMapPathMatcher `pulumi:"pathMatchers"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	Region *string `pulumi:"region"`
	// The URI of the created resource.
	SelfLink *string `pulumi:"selfLink"`
	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	Tests []RegionUrlMapTest `pulumi:"tests"`
}

type RegionUrlMapState struct {
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringPtrInput
	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
	// Structure is documented below.
	DefaultRouteAction RegionUrlMapDefaultRouteActionPtrInput
	// The full or partial URL of the defaultService resource to which traffic is directed if
	// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
	// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.  Only one of defaultService,
	// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
	DefaultService pulumi.StringPtrInput
	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultUrlRedirect RegionUrlMapDefaultUrlRedirectPtrInput
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrInput
	// Fingerprint of this resource. This field is used internally during
	// updates of this resource.
	Fingerprint pulumi.StringPtrInput
	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRules RegionUrlMapHostRuleArrayInput
	// The unique identifier for the resource.
	MapId pulumi.IntPtrInput
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression `a-z?` which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// ***
	Name pulumi.StringPtrInput
	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatchers RegionUrlMapPathMatcherArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	Region pulumi.StringPtrInput
	// The URI of the created resource.
	SelfLink pulumi.StringPtrInput
	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	Tests RegionUrlMapTestArrayInput
}

func (RegionUrlMapState) ElementType() reflect.Type {
	return reflect.TypeOf((*regionUrlMapState)(nil)).Elem()
}

type regionUrlMapArgs struct {
	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
	// Structure is documented below.
	DefaultRouteAction *RegionUrlMapDefaultRouteAction `pulumi:"defaultRouteAction"`
	// The full or partial URL of the defaultService resource to which traffic is directed if
	// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
	// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.  Only one of defaultService,
	// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
	DefaultService *string `pulumi:"defaultService"`
	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultUrlRedirect *RegionUrlMapDefaultUrlRedirect `pulumi:"defaultUrlRedirect"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description *string `pulumi:"description"`
	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRules []RegionUrlMapHostRule `pulumi:"hostRules"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression `a-z?` which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// ***
	Name *string `pulumi:"name"`
	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatchers []RegionUrlMapPathMatcher `pulumi:"pathMatchers"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	Region *string `pulumi:"region"`
	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	Tests []RegionUrlMapTest `pulumi:"tests"`
}

// The set of arguments for constructing a RegionUrlMap resource.
type RegionUrlMapArgs struct {
	// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be set.
	// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
	// Structure is documented below.
	DefaultRouteAction RegionUrlMapDefaultRouteActionPtrInput
	// The full or partial URL of the defaultService resource to which traffic is directed if
	// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
	// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.  Only one of defaultService,
	// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
	DefaultService pulumi.StringPtrInput
	// When none of the specified hostRules match, the request is redirected to a URL specified
	// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Structure is documented below.
	DefaultUrlRedirect RegionUrlMapDefaultUrlRedirectPtrInput
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description pulumi.StringPtrInput
	// The list of HostRules to use against the URL.
	// Structure is documented below.
	HostRules RegionUrlMapHostRuleArrayInput
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression `a-z?` which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// ***
	Name pulumi.StringPtrInput
	// The list of named PathMatchers to use against the URL.
	// Structure is documented below.
	PathMatchers RegionUrlMapPathMatcherArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The Region in which the url map should reside.
	// If it is not provided, the provider region is used.
	Region pulumi.StringPtrInput
	// The list of expected URL mappings. Requests to update this UrlMap will
	// succeed only if all of the test cases pass.
	// Structure is documented below.
	Tests RegionUrlMapTestArrayInput
}

func (RegionUrlMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*regionUrlMapArgs)(nil)).Elem()
}

type RegionUrlMapInput interface {
	pulumi.Input

	ToRegionUrlMapOutput() RegionUrlMapOutput
	ToRegionUrlMapOutputWithContext(ctx context.Context) RegionUrlMapOutput
}

func (*RegionUrlMap) ElementType() reflect.Type {
	return reflect.TypeOf((**RegionUrlMap)(nil)).Elem()
}

func (i *RegionUrlMap) ToRegionUrlMapOutput() RegionUrlMapOutput {
	return i.ToRegionUrlMapOutputWithContext(context.Background())
}

func (i *RegionUrlMap) ToRegionUrlMapOutputWithContext(ctx context.Context) RegionUrlMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionUrlMapOutput)
}

func (i *RegionUrlMap) ToOutput(ctx context.Context) pulumix.Output[*RegionUrlMap] {
	return pulumix.Output[*RegionUrlMap]{
		OutputState: i.ToRegionUrlMapOutputWithContext(ctx).OutputState,
	}
}

// RegionUrlMapArrayInput is an input type that accepts RegionUrlMapArray and RegionUrlMapArrayOutput values.
// You can construct a concrete instance of `RegionUrlMapArrayInput` via:
//
//	RegionUrlMapArray{ RegionUrlMapArgs{...} }
type RegionUrlMapArrayInput interface {
	pulumi.Input

	ToRegionUrlMapArrayOutput() RegionUrlMapArrayOutput
	ToRegionUrlMapArrayOutputWithContext(context.Context) RegionUrlMapArrayOutput
}

type RegionUrlMapArray []RegionUrlMapInput

func (RegionUrlMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegionUrlMap)(nil)).Elem()
}

func (i RegionUrlMapArray) ToRegionUrlMapArrayOutput() RegionUrlMapArrayOutput {
	return i.ToRegionUrlMapArrayOutputWithContext(context.Background())
}

func (i RegionUrlMapArray) ToRegionUrlMapArrayOutputWithContext(ctx context.Context) RegionUrlMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionUrlMapArrayOutput)
}

func (i RegionUrlMapArray) ToOutput(ctx context.Context) pulumix.Output[[]*RegionUrlMap] {
	return pulumix.Output[[]*RegionUrlMap]{
		OutputState: i.ToRegionUrlMapArrayOutputWithContext(ctx).OutputState,
	}
}

// RegionUrlMapMapInput is an input type that accepts RegionUrlMapMap and RegionUrlMapMapOutput values.
// You can construct a concrete instance of `RegionUrlMapMapInput` via:
//
//	RegionUrlMapMap{ "key": RegionUrlMapArgs{...} }
type RegionUrlMapMapInput interface {
	pulumi.Input

	ToRegionUrlMapMapOutput() RegionUrlMapMapOutput
	ToRegionUrlMapMapOutputWithContext(context.Context) RegionUrlMapMapOutput
}

type RegionUrlMapMap map[string]RegionUrlMapInput

func (RegionUrlMapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegionUrlMap)(nil)).Elem()
}

func (i RegionUrlMapMap) ToRegionUrlMapMapOutput() RegionUrlMapMapOutput {
	return i.ToRegionUrlMapMapOutputWithContext(context.Background())
}

func (i RegionUrlMapMap) ToRegionUrlMapMapOutputWithContext(ctx context.Context) RegionUrlMapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegionUrlMapMapOutput)
}

func (i RegionUrlMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*RegionUrlMap] {
	return pulumix.Output[map[string]*RegionUrlMap]{
		OutputState: i.ToRegionUrlMapMapOutputWithContext(ctx).OutputState,
	}
}

type RegionUrlMapOutput struct{ *pulumi.OutputState }

func (RegionUrlMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegionUrlMap)(nil)).Elem()
}

func (o RegionUrlMapOutput) ToRegionUrlMapOutput() RegionUrlMapOutput {
	return o
}

func (o RegionUrlMapOutput) ToRegionUrlMapOutputWithContext(ctx context.Context) RegionUrlMapOutput {
	return o
}

func (o RegionUrlMapOutput) ToOutput(ctx context.Context) pulumix.Output[*RegionUrlMap] {
	return pulumix.Output[*RegionUrlMap]{
		OutputState: o.OutputState,
	}
}

// Creation timestamp in RFC3339 text format.
func (o RegionUrlMapOutput) CreationTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.CreationTimestamp }).(pulumi.StringOutput)
}

// defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
// Only one of defaultRouteAction or defaultUrlRedirect must be set.
// URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
// defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
// Structure is documented below.
func (o RegionUrlMapOutput) DefaultRouteAction() RegionUrlMapDefaultRouteActionPtrOutput {
	return o.ApplyT(func(v *RegionUrlMap) RegionUrlMapDefaultRouteActionPtrOutput { return v.DefaultRouteAction }).(RegionUrlMapDefaultRouteActionPtrOutput)
}

// The full or partial URL of the defaultService resource to which traffic is directed if
// none of the hostRules match. If defaultRouteAction is additionally specified, advanced
// routing actions like URL Rewrites, etc. take effect prior to sending the request to the
// backend. However, if defaultService is specified, defaultRouteAction cannot contain any
// weightedBackendServices. Conversely, if routeAction specifies any
// weightedBackendServices, service must not be specified.  Only one of defaultService,
// defaultUrlRedirect or defaultRouteAction.weightedBackendService must be set.
func (o RegionUrlMapOutput) DefaultService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringPtrOutput { return v.DefaultService }).(pulumi.StringPtrOutput)
}

// When none of the specified hostRules match, the request is redirected to a URL specified
// by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
// defaultRouteAction must not be set.
// Structure is documented below.
func (o RegionUrlMapOutput) DefaultUrlRedirect() RegionUrlMapDefaultUrlRedirectPtrOutput {
	return o.ApplyT(func(v *RegionUrlMap) RegionUrlMapDefaultUrlRedirectPtrOutput { return v.DefaultUrlRedirect }).(RegionUrlMapDefaultUrlRedirectPtrOutput)
}

// An optional description of this resource. Provide this property when
// you create the resource.
func (o RegionUrlMapOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Fingerprint of this resource. This field is used internally during
// updates of this resource.
func (o RegionUrlMapOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.Fingerprint }).(pulumi.StringOutput)
}

// The list of HostRules to use against the URL.
// Structure is documented below.
func (o RegionUrlMapOutput) HostRules() RegionUrlMapHostRuleArrayOutput {
	return o.ApplyT(func(v *RegionUrlMap) RegionUrlMapHostRuleArrayOutput { return v.HostRules }).(RegionUrlMapHostRuleArrayOutput)
}

// The unique identifier for the resource.
func (o RegionUrlMapOutput) MapId() pulumi.IntOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.IntOutput { return v.MapId }).(pulumi.IntOutput)
}

// Name of the resource. Provided by the client when the resource is
// created. The name must be 1-63 characters long, and comply with
// RFC1035. Specifically, the name must be 1-63 characters long and match
// the regular expression `a-z?` which means the
// first character must be a lowercase letter, and all following
// characters must be a dash, lowercase letter, or digit, except the last
// character, which cannot be a dash.
//
// ***
func (o RegionUrlMapOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The list of named PathMatchers to use against the URL.
// Structure is documented below.
func (o RegionUrlMapOutput) PathMatchers() RegionUrlMapPathMatcherArrayOutput {
	return o.ApplyT(func(v *RegionUrlMap) RegionUrlMapPathMatcherArrayOutput { return v.PathMatchers }).(RegionUrlMapPathMatcherArrayOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o RegionUrlMapOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The Region in which the url map should reside.
// If it is not provided, the provider region is used.
func (o RegionUrlMapOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The URI of the created resource.
func (o RegionUrlMapOutput) SelfLink() pulumi.StringOutput {
	return o.ApplyT(func(v *RegionUrlMap) pulumi.StringOutput { return v.SelfLink }).(pulumi.StringOutput)
}

// The list of expected URL mappings. Requests to update this UrlMap will
// succeed only if all of the test cases pass.
// Structure is documented below.
func (o RegionUrlMapOutput) Tests() RegionUrlMapTestArrayOutput {
	return o.ApplyT(func(v *RegionUrlMap) RegionUrlMapTestArrayOutput { return v.Tests }).(RegionUrlMapTestArrayOutput)
}

type RegionUrlMapArrayOutput struct{ *pulumi.OutputState }

func (RegionUrlMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegionUrlMap)(nil)).Elem()
}

func (o RegionUrlMapArrayOutput) ToRegionUrlMapArrayOutput() RegionUrlMapArrayOutput {
	return o
}

func (o RegionUrlMapArrayOutput) ToRegionUrlMapArrayOutputWithContext(ctx context.Context) RegionUrlMapArrayOutput {
	return o
}

func (o RegionUrlMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*RegionUrlMap] {
	return pulumix.Output[[]*RegionUrlMap]{
		OutputState: o.OutputState,
	}
}

func (o RegionUrlMapArrayOutput) Index(i pulumi.IntInput) RegionUrlMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RegionUrlMap {
		return vs[0].([]*RegionUrlMap)[vs[1].(int)]
	}).(RegionUrlMapOutput)
}

type RegionUrlMapMapOutput struct{ *pulumi.OutputState }

func (RegionUrlMapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegionUrlMap)(nil)).Elem()
}

func (o RegionUrlMapMapOutput) ToRegionUrlMapMapOutput() RegionUrlMapMapOutput {
	return o
}

func (o RegionUrlMapMapOutput) ToRegionUrlMapMapOutputWithContext(ctx context.Context) RegionUrlMapMapOutput {
	return o
}

func (o RegionUrlMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*RegionUrlMap] {
	return pulumix.Output[map[string]*RegionUrlMap]{
		OutputState: o.OutputState,
	}
}

func (o RegionUrlMapMapOutput) MapIndex(k pulumi.StringInput) RegionUrlMapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RegionUrlMap {
		return vs[0].(map[string]*RegionUrlMap)[vs[1].(string)]
	}).(RegionUrlMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RegionUrlMapInput)(nil)).Elem(), &RegionUrlMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegionUrlMapArrayInput)(nil)).Elem(), RegionUrlMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegionUrlMapMapInput)(nil)).Elem(), RegionUrlMapMap{})
	pulumi.RegisterOutputType(RegionUrlMapOutput{})
	pulumi.RegisterOutputType(RegionUrlMapArrayOutput{})
	pulumi.RegisterOutputType(RegionUrlMapMapOutput{})
}
