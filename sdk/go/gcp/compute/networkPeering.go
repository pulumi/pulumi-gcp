// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a network peering within GCE. For more information see
// [the official documentation](https://cloud.google.com/compute/docs/vpc/vpc-peering)
// and
// [API](https://cloud.google.com/compute/docs/reference/latest/networks).
//
// > Both networks must create a peering with each other for the peering
// to be functional.
//
// > Subnets IP ranges across peered VPC networks cannot overlap.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_default, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
//				Name:                  pulumi.String("foobar"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			other, err := compute.NewNetwork(ctx, "other", &compute.NetworkArgs{
//				Name:                  pulumi.String("other"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewNetworkPeering(ctx, "peering1", &compute.NetworkPeeringArgs{
//				Name:        pulumi.String("peering1"),
//				Network:     _default.SelfLink,
//				PeerNetwork: other.SelfLink,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewNetworkPeering(ctx, "peering2", &compute.NetworkPeeringArgs{
//				Name:        pulumi.String("peering2"),
//				Network:     other.SelfLink,
//				PeerNetwork: _default.SelfLink,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # VPC network peerings can be imported using the name and project of the primary network the peering exists in and the name of the network peering
//
// * `{{project_id}}/{{network_id}}/{{peering_id}}`
//
// When using the `pulumi import` command, VPC network peerings can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:compute/networkPeering:NetworkPeering default {{project_id}}/{{network_id}}/{{peering_id}}
// ```
type NetworkPeering struct {
	pulumi.CustomResourceState

	// Whether to export the custom routes to the peer network. Defaults to `false`.
	ExportCustomRoutes pulumi.BoolPtrOutput `pulumi:"exportCustomRoutes"`
	// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
	ExportSubnetRoutesWithPublicIp pulumi.BoolPtrOutput `pulumi:"exportSubnetRoutesWithPublicIp"`
	// Whether to import the custom routes from the peer network. Defaults to `false`.
	ImportCustomRoutes pulumi.BoolPtrOutput `pulumi:"importCustomRoutes"`
	// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
	ImportSubnetRoutesWithPublicIp pulumi.BoolPtrOutput `pulumi:"importSubnetRoutesWithPublicIp"`
	// Name of the peering.
	Name pulumi.StringOutput `pulumi:"name"`
	// The primary network of the peering.
	Network pulumi.StringOutput `pulumi:"network"`
	// The peer network in the peering. The peer network
	// may belong to a different project.
	PeerNetwork pulumi.StringOutput `pulumi:"peerNetwork"`
	// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
	StackType pulumi.StringPtrOutput `pulumi:"stackType"`
	// State for the peering, either `ACTIVE` or `INACTIVE`. The peering is
	// `ACTIVE` when there's a matching configuration in the peer network.
	State pulumi.StringOutput `pulumi:"state"`
	// Details about the current state of the peering.
	StateDetails pulumi.StringOutput `pulumi:"stateDetails"`
	// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
	UpdateStrategy pulumi.StringPtrOutput `pulumi:"updateStrategy"`
}

// NewNetworkPeering registers a new resource with the given unique name, arguments, and options.
func NewNetworkPeering(ctx *pulumi.Context,
	name string, args *NetworkPeeringArgs, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Network == nil {
		return nil, errors.New("invalid value for required argument 'Network'")
	}
	if args.PeerNetwork == nil {
		return nil, errors.New("invalid value for required argument 'PeerNetwork'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkPeering
	err := ctx.RegisterResource("gcp:compute/networkPeering:NetworkPeering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkPeering gets an existing NetworkPeering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkPeeringState, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	var resource NetworkPeering
	err := ctx.ReadResource("gcp:compute/networkPeering:NetworkPeering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkPeering resources.
type networkPeeringState struct {
	// Whether to export the custom routes to the peer network. Defaults to `false`.
	ExportCustomRoutes *bool `pulumi:"exportCustomRoutes"`
	// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
	ExportSubnetRoutesWithPublicIp *bool `pulumi:"exportSubnetRoutesWithPublicIp"`
	// Whether to import the custom routes from the peer network. Defaults to `false`.
	ImportCustomRoutes *bool `pulumi:"importCustomRoutes"`
	// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
	ImportSubnetRoutesWithPublicIp *bool `pulumi:"importSubnetRoutesWithPublicIp"`
	// Name of the peering.
	Name *string `pulumi:"name"`
	// The primary network of the peering.
	Network *string `pulumi:"network"`
	// The peer network in the peering. The peer network
	// may belong to a different project.
	PeerNetwork *string `pulumi:"peerNetwork"`
	// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
	StackType *string `pulumi:"stackType"`
	// State for the peering, either `ACTIVE` or `INACTIVE`. The peering is
	// `ACTIVE` when there's a matching configuration in the peer network.
	State *string `pulumi:"state"`
	// Details about the current state of the peering.
	StateDetails *string `pulumi:"stateDetails"`
	// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
	UpdateStrategy *string `pulumi:"updateStrategy"`
}

type NetworkPeeringState struct {
	// Whether to export the custom routes to the peer network. Defaults to `false`.
	ExportCustomRoutes pulumi.BoolPtrInput
	// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
	ExportSubnetRoutesWithPublicIp pulumi.BoolPtrInput
	// Whether to import the custom routes from the peer network. Defaults to `false`.
	ImportCustomRoutes pulumi.BoolPtrInput
	// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
	ImportSubnetRoutesWithPublicIp pulumi.BoolPtrInput
	// Name of the peering.
	Name pulumi.StringPtrInput
	// The primary network of the peering.
	Network pulumi.StringPtrInput
	// The peer network in the peering. The peer network
	// may belong to a different project.
	PeerNetwork pulumi.StringPtrInput
	// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
	StackType pulumi.StringPtrInput
	// State for the peering, either `ACTIVE` or `INACTIVE`. The peering is
	// `ACTIVE` when there's a matching configuration in the peer network.
	State pulumi.StringPtrInput
	// Details about the current state of the peering.
	StateDetails pulumi.StringPtrInput
	// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
	UpdateStrategy pulumi.StringPtrInput
}

func (NetworkPeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringState)(nil)).Elem()
}

type networkPeeringArgs struct {
	// Whether to export the custom routes to the peer network. Defaults to `false`.
	ExportCustomRoutes *bool `pulumi:"exportCustomRoutes"`
	// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
	ExportSubnetRoutesWithPublicIp *bool `pulumi:"exportSubnetRoutesWithPublicIp"`
	// Whether to import the custom routes from the peer network. Defaults to `false`.
	ImportCustomRoutes *bool `pulumi:"importCustomRoutes"`
	// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
	ImportSubnetRoutesWithPublicIp *bool `pulumi:"importSubnetRoutesWithPublicIp"`
	// Name of the peering.
	Name *string `pulumi:"name"`
	// The primary network of the peering.
	Network string `pulumi:"network"`
	// The peer network in the peering. The peer network
	// may belong to a different project.
	PeerNetwork string `pulumi:"peerNetwork"`
	// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
	StackType *string `pulumi:"stackType"`
	// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
	UpdateStrategy *string `pulumi:"updateStrategy"`
}

// The set of arguments for constructing a NetworkPeering resource.
type NetworkPeeringArgs struct {
	// Whether to export the custom routes to the peer network. Defaults to `false`.
	ExportCustomRoutes pulumi.BoolPtrInput
	// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
	ExportSubnetRoutesWithPublicIp pulumi.BoolPtrInput
	// Whether to import the custom routes from the peer network. Defaults to `false`.
	ImportCustomRoutes pulumi.BoolPtrInput
	// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
	ImportSubnetRoutesWithPublicIp pulumi.BoolPtrInput
	// Name of the peering.
	Name pulumi.StringPtrInput
	// The primary network of the peering.
	Network pulumi.StringInput
	// The peer network in the peering. The peer network
	// may belong to a different project.
	PeerNetwork pulumi.StringInput
	// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
	StackType pulumi.StringPtrInput
	// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
	UpdateStrategy pulumi.StringPtrInput
}

func (NetworkPeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringArgs)(nil)).Elem()
}

type NetworkPeeringInput interface {
	pulumi.Input

	ToNetworkPeeringOutput() NetworkPeeringOutput
	ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput
}

func (*NetworkPeering) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (i *NetworkPeering) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return i.ToNetworkPeeringOutputWithContext(context.Background())
}

func (i *NetworkPeering) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringOutput)
}

// NetworkPeeringArrayInput is an input type that accepts NetworkPeeringArray and NetworkPeeringArrayOutput values.
// You can construct a concrete instance of `NetworkPeeringArrayInput` via:
//
//	NetworkPeeringArray{ NetworkPeeringArgs{...} }
type NetworkPeeringArrayInput interface {
	pulumi.Input

	ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput
	ToNetworkPeeringArrayOutputWithContext(context.Context) NetworkPeeringArrayOutput
}

type NetworkPeeringArray []NetworkPeeringInput

func (NetworkPeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return i.ToNetworkPeeringArrayOutputWithContext(context.Background())
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringArrayOutput)
}

// NetworkPeeringMapInput is an input type that accepts NetworkPeeringMap and NetworkPeeringMapOutput values.
// You can construct a concrete instance of `NetworkPeeringMapInput` via:
//
//	NetworkPeeringMap{ "key": NetworkPeeringArgs{...} }
type NetworkPeeringMapInput interface {
	pulumi.Input

	ToNetworkPeeringMapOutput() NetworkPeeringMapOutput
	ToNetworkPeeringMapOutputWithContext(context.Context) NetworkPeeringMapOutput
}

type NetworkPeeringMap map[string]NetworkPeeringInput

func (NetworkPeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return i.ToNetworkPeeringMapOutputWithContext(context.Background())
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringMapOutput)
}

type NetworkPeeringOutput struct{ *pulumi.OutputState }

func (NetworkPeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return o
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return o
}

// Whether to export the custom routes to the peer network. Defaults to `false`.
func (o NetworkPeeringOutput) ExportCustomRoutes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.BoolPtrOutput { return v.ExportCustomRoutes }).(pulumi.BoolPtrOutput)
}

// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
func (o NetworkPeeringOutput) ExportSubnetRoutesWithPublicIp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.BoolPtrOutput { return v.ExportSubnetRoutesWithPublicIp }).(pulumi.BoolPtrOutput)
}

// Whether to import the custom routes from the peer network. Defaults to `false`.
func (o NetworkPeeringOutput) ImportCustomRoutes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.BoolPtrOutput { return v.ImportCustomRoutes }).(pulumi.BoolPtrOutput)
}

// Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
func (o NetworkPeeringOutput) ImportSubnetRoutesWithPublicIp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.BoolPtrOutput { return v.ImportSubnetRoutesWithPublicIp }).(pulumi.BoolPtrOutput)
}

// Name of the peering.
func (o NetworkPeeringOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The primary network of the peering.
func (o NetworkPeeringOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.Network }).(pulumi.StringOutput)
}

// The peer network in the peering. The peer network
// may belong to a different project.
func (o NetworkPeeringOutput) PeerNetwork() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.PeerNetwork }).(pulumi.StringOutput)
}

// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
func (o NetworkPeeringOutput) StackType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringPtrOutput { return v.StackType }).(pulumi.StringPtrOutput)
}

// State for the peering, either `ACTIVE` or `INACTIVE`. The peering is
// `ACTIVE` when there's a matching configuration in the peer network.
func (o NetworkPeeringOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Details about the current state of the peering.
func (o NetworkPeeringOutput) StateDetails() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.StateDetails }).(pulumi.StringOutput)
}

// The update strategy determines the semantics for updates and deletes to the peering connection configuration. The default value is INDEPENDENT. Possible values: ["INDEPENDENT", "CONSENSUS"]
func (o NetworkPeeringOutput) UpdateStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringPtrOutput { return v.UpdateStrategy }).(pulumi.StringPtrOutput)
}

type NetworkPeeringArrayOutput struct{ *pulumi.OutputState }

func (NetworkPeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) Index(i pulumi.IntInput) NetworkPeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].([]*NetworkPeering)[vs[1].(int)]
	}).(NetworkPeeringOutput)
}

type NetworkPeeringMapOutput struct{ *pulumi.OutputState }

func (NetworkPeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) MapIndex(k pulumi.StringInput) NetworkPeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].(map[string]*NetworkPeering)[vs[1].(string)]
	}).(NetworkPeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringInput)(nil)).Elem(), &NetworkPeering{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringArrayInput)(nil)).Elem(), NetworkPeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringMapInput)(nil)).Elem(), NetworkPeeringMap{})
	pulumi.RegisterOutputType(NetworkPeeringOutput{})
	pulumi.RegisterOutputType(NetworkPeeringArrayOutput{})
	pulumi.RegisterOutputType(NetworkPeeringMapOutput{})
}
