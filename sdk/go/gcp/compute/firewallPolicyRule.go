// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
//
// To get more information about FirewallPolicyRule, see:
//
// * [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/firewallPolicies/addRule)
//
// ## Example Usage
//
// ### Firewall Policy Rule
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/tags"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basicGlobalNetworksecurityAddressGroup, err := networksecurity.NewAddressGroup(ctx, "basic_global_networksecurity_address_group", &networksecurity.AddressGroupArgs{
//				Name:        pulumi.String("address-group"),
//				Parent:      pulumi.String("organizations/123456789"),
//				Description: pulumi.String("Sample global networksecurity_address_group"),
//				Location:    pulumi.String("global"),
//				Items: pulumi.StringArray{
//					pulumi.String("208.80.154.224/32"),
//				},
//				Type:     pulumi.String("IPV4"),
//				Capacity: pulumi.Int(100),
//			})
//			if err != nil {
//				return err
//			}
//			folder, err := organizations.NewFolder(ctx, "folder", &organizations.FolderArgs{
//				DisplayName:        pulumi.String("folder"),
//				Parent:             pulumi.String("organizations/123456789"),
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_default, err := compute.NewFirewallPolicy(ctx, "default", &compute.FirewallPolicyArgs{
//				Parent:      folder.ID(),
//				ShortName:   pulumi.String("fw-policy"),
//				Description: pulumi.String("Resource created for Terraform acceptance testing"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewFirewallPolicyRule(ctx, "primary", &compute.FirewallPolicyRuleArgs{
//				FirewallPolicy: _default.Name,
//				Description:    pulumi.String("Resource created for Terraform acceptance testing"),
//				Priority:       pulumi.Int(9000),
//				EnableLogging:  pulumi.Bool(true),
//				Action:         pulumi.String("allow"),
//				Direction:      pulumi.String("EGRESS"),
//				Disabled:       pulumi.Bool(false),
//				TargetServiceAccounts: pulumi.StringArray{
//					pulumi.String("my@service-account.com"),
//				},
//				Match: &compute.FirewallPolicyRuleMatchArgs{
//					DestIpRanges: pulumi.StringArray{
//						pulumi.String("11.100.0.1/32"),
//					},
//					DestFqdns: pulumi.StringArray{},
//					DestRegionCodes: pulumi.StringArray{
//						pulumi.String("US"),
//					},
//					DestThreatIntelligences: pulumi.StringArray{
//						pulumi.String("iplist-known-malicious-ips"),
//					},
//					SrcAddressGroups: pulumi.StringArray{},
//					DestAddressGroups: pulumi.StringArray{
//						basicGlobalNetworksecurityAddressGroup.ID(),
//					},
//					Layer4Configs: compute.FirewallPolicyRuleMatchLayer4ConfigArray{
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("tcp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("8080"),
//							},
//						},
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("udp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("22"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			basicKey, err := tags.NewTagKey(ctx, "basic_key", &tags.TagKeyArgs{
//				Description: pulumi.String("For keyname resources."),
//				Parent:      pulumi.String("organizations/123456789"),
//				Purpose:     pulumi.String("GCE_FIREWALL"),
//				ShortName:   pulumi.String("tag-key"),
//				PurposeData: pulumi.StringMap{
//					"organization": pulumi.String("auto"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = tags.NewTagValue(ctx, "basic_value", &tags.TagValueArgs{
//				Description: pulumi.String("For valuename resources."),
//				Parent:      basicKey.ID(),
//				ShortName:   pulumi.String("tag-value"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Firewall Policy Rule Network Scope
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			folder, err := organizations.NewFolder(ctx, "folder", &organizations.FolderArgs{
//				DisplayName:        pulumi.String("folder"),
//				Parent:             pulumi.String("organizations/123456789"),
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_default, err := compute.NewFirewallPolicy(ctx, "default", &compute.FirewallPolicyArgs{
//				Parent:      folder.ID(),
//				ShortName:   pulumi.String("fw-policy"),
//				Description: pulumi.String("Firewall policy"),
//			})
//			if err != nil {
//				return err
//			}
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewFirewallPolicyRule(ctx, "primary", &compute.FirewallPolicyRuleArgs{
//				FirewallPolicy: _default.Name,
//				Description:    pulumi.String("Firewall policy rule with network scope"),
//				Priority:       pulumi.Int(9000),
//				Action:         pulumi.String("allow"),
//				Direction:      pulumi.String("INGRESS"),
//				Disabled:       pulumi.Bool(false),
//				Match: &compute.FirewallPolicyRuleMatchArgs{
//					SrcIpRanges: pulumi.StringArray{
//						pulumi.String("11.100.0.1/32"),
//					},
//					SrcNetworkScope: pulumi.String("VPC_NETWORKS"),
//					SrcNetworks: pulumi.StringArray{
//						network.ID(),
//					},
//					Layer4Configs: compute.FirewallPolicyRuleMatchLayer4ConfigArray{
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("tcp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("8080"),
//							},
//						},
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("udp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("22"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Firewall Policy Rule Secure Tags
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/tags"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			folder, err := organizations.NewFolder(ctx, "folder", &organizations.FolderArgs{
//				DisplayName:        pulumi.String("folder"),
//				Parent:             pulumi.String("organizations/123456789"),
//				DeletionProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_default, err := compute.NewFirewallPolicy(ctx, "default", &compute.FirewallPolicyArgs{
//				Parent:      folder.ID(),
//				ShortName:   pulumi.String("fw-policy"),
//				Description: pulumi.String("Resource created for Terraform acceptance testing"),
//			})
//			if err != nil {
//				return err
//			}
//			basicKey, err := tags.NewTagKey(ctx, "basic_key", &tags.TagKeyArgs{
//				Description: pulumi.String("For keyname resources."),
//				Parent:      pulumi.String("organizations/123456789"),
//				Purpose:     pulumi.String("GCE_FIREWALL"),
//				ShortName:   pulumi.String("tag-key"),
//				PurposeData: pulumi.StringMap{
//					"organization": pulumi.String("auto"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			basicValue, err := tags.NewTagValue(ctx, "basic_value", &tags.TagValueArgs{
//				Description: pulumi.String("For valuename resources."),
//				Parent:      basicKey.ID(),
//				ShortName:   pulumi.String("tag-value"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewFirewallPolicyRule(ctx, "primary", &compute.FirewallPolicyRuleArgs{
//				FirewallPolicy: _default.Name,
//				Description:    pulumi.String("Resource created for Terraform acceptance testing"),
//				Priority:       pulumi.Int(9000),
//				EnableLogging:  pulumi.Bool(true),
//				Action:         pulumi.String("allow"),
//				Direction:      pulumi.String("INGRESS"),
//				Disabled:       pulumi.Bool(false),
//				TargetSecureTags: compute.FirewallPolicyRuleTargetSecureTagArray{
//					&compute.FirewallPolicyRuleTargetSecureTagArgs{
//						Name: basicValue.ID(),
//					},
//				},
//				Match: &compute.FirewallPolicyRuleMatchArgs{
//					SrcIpRanges: pulumi.StringArray{
//						pulumi.String("11.100.0.1/32"),
//					},
//					SrcSecureTags: compute.FirewallPolicyRuleMatchSrcSecureTagArray{
//						&compute.FirewallPolicyRuleMatchSrcSecureTagArgs{
//							Name: basicValue.ID(),
//						},
//					},
//					Layer4Configs: compute.FirewallPolicyRuleMatchLayer4ConfigArray{
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("tcp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("8080"),
//							},
//						},
//						&compute.FirewallPolicyRuleMatchLayer4ConfigArgs{
//							IpProtocol: pulumi.String("udp"),
//							Ports: pulumi.StringArray{
//								pulumi.String("22"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// FirewallPolicyRule can be imported using any of these accepted formats:
//
// * `locations/global/firewallPolicies/{{firewall_policy}}/rules/{{priority}}`
//
// * `{{firewall_policy}}/{{priority}}`
//
// When using the `pulumi import` command, FirewallPolicyRule can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:compute/firewallPolicyRule:FirewallPolicyRule default locations/global/firewallPolicies/{{firewall_policy}}/rules/{{priority}}
// ```
//
// ```sh
// $ pulumi import gcp:compute/firewallPolicyRule:FirewallPolicyRule default {{firewall_policy}}/{{priority}}
// ```
type FirewallPolicyRule struct {
	pulumi.CustomResourceState

	// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
	Action pulumi.StringOutput `pulumi:"action"`
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringOutput `pulumi:"creationTimestamp"`
	// An optional description for this resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The direction in which this rule applies.
	// Possible values are: `INGRESS`, `EGRESS`.
	Direction pulumi.StringOutput `pulumi:"direction"`
	// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
	// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
	Disabled pulumi.BoolPtrOutput `pulumi:"disabled"`
	// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
	// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
	// "gotoNext" rules.
	EnableLogging pulumi.BoolPtrOutput `pulumi:"enableLogging"`
	// The firewall policy of the resource.
	FirewallPolicy pulumi.StringOutput `pulumi:"firewallPolicy"`
	// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
	Kind pulumi.StringOutput `pulumi:"kind"`
	// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
	// Structure is documented below.
	Match FirewallPolicyRuleMatchOutput `pulumi:"match"`
	// An integer indicating the priority of a rule in the list.
	// The priority must be a positive value between 0 and 2147483647.
	// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
	Priority pulumi.IntOutput `pulumi:"priority"`
	// Calculation of the complexity of a single firewall policy rule.
	RuleTupleCount pulumi.IntOutput `pulumi:"ruleTupleCount"`
	// A fully-qualified URL of a SecurityProfile resource instance. Example:
	// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
	// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
	SecurityProfileGroup pulumi.StringPtrOutput `pulumi:"securityProfileGroup"`
	// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
	// this rule. If this field is left blank, all VMs within the organization will receive the rule.
	TargetResources pulumi.StringArrayOutput `pulumi:"targetResources"`
	// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
	// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
	// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
	// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
	// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
	TargetSecureTags FirewallPolicyRuleTargetSecureTagArrayOutput `pulumi:"targetSecureTags"`
	// A list of service accounts indicating the sets of instances that are applied with this rule.
	TargetServiceAccounts pulumi.StringArrayOutput `pulumi:"targetServiceAccounts"`
	// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
	// 'apply_security_profile_group' and cannot be set for other actions.
	TlsInspect pulumi.BoolPtrOutput `pulumi:"tlsInspect"`
}

// NewFirewallPolicyRule registers a new resource with the given unique name, arguments, and options.
func NewFirewallPolicyRule(ctx *pulumi.Context,
	name string, args *FirewallPolicyRuleArgs, opts ...pulumi.ResourceOption) (*FirewallPolicyRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Direction == nil {
		return nil, errors.New("invalid value for required argument 'Direction'")
	}
	if args.FirewallPolicy == nil {
		return nil, errors.New("invalid value for required argument 'FirewallPolicy'")
	}
	if args.Match == nil {
		return nil, errors.New("invalid value for required argument 'Match'")
	}
	if args.Priority == nil {
		return nil, errors.New("invalid value for required argument 'Priority'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FirewallPolicyRule
	err := ctx.RegisterResource("gcp:compute/firewallPolicyRule:FirewallPolicyRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewallPolicyRule gets an existing FirewallPolicyRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewallPolicyRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallPolicyRuleState, opts ...pulumi.ResourceOption) (*FirewallPolicyRule, error) {
	var resource FirewallPolicyRule
	err := ctx.ReadResource("gcp:compute/firewallPolicyRule:FirewallPolicyRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirewallPolicyRule resources.
type firewallPolicyRuleState struct {
	// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
	Action *string `pulumi:"action"`
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp *string `pulumi:"creationTimestamp"`
	// An optional description for this resource.
	Description *string `pulumi:"description"`
	// The direction in which this rule applies.
	// Possible values are: `INGRESS`, `EGRESS`.
	Direction *string `pulumi:"direction"`
	// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
	// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
	Disabled *bool `pulumi:"disabled"`
	// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
	// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
	// "gotoNext" rules.
	EnableLogging *bool `pulumi:"enableLogging"`
	// The firewall policy of the resource.
	FirewallPolicy *string `pulumi:"firewallPolicy"`
	// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
	Kind *string `pulumi:"kind"`
	// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
	// Structure is documented below.
	Match *FirewallPolicyRuleMatch `pulumi:"match"`
	// An integer indicating the priority of a rule in the list.
	// The priority must be a positive value between 0 and 2147483647.
	// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
	Priority *int `pulumi:"priority"`
	// Calculation of the complexity of a single firewall policy rule.
	RuleTupleCount *int `pulumi:"ruleTupleCount"`
	// A fully-qualified URL of a SecurityProfile resource instance. Example:
	// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
	// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
	SecurityProfileGroup *string `pulumi:"securityProfileGroup"`
	// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
	// this rule. If this field is left blank, all VMs within the organization will receive the rule.
	TargetResources []string `pulumi:"targetResources"`
	// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
	// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
	// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
	// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
	// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
	TargetSecureTags []FirewallPolicyRuleTargetSecureTag `pulumi:"targetSecureTags"`
	// A list of service accounts indicating the sets of instances that are applied with this rule.
	TargetServiceAccounts []string `pulumi:"targetServiceAccounts"`
	// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
	// 'apply_security_profile_group' and cannot be set for other actions.
	TlsInspect *bool `pulumi:"tlsInspect"`
}

type FirewallPolicyRuleState struct {
	// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
	Action pulumi.StringPtrInput
	// Creation timestamp in RFC3339 text format.
	CreationTimestamp pulumi.StringPtrInput
	// An optional description for this resource.
	Description pulumi.StringPtrInput
	// The direction in which this rule applies.
	// Possible values are: `INGRESS`, `EGRESS`.
	Direction pulumi.StringPtrInput
	// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
	// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
	Disabled pulumi.BoolPtrInput
	// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
	// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
	// "gotoNext" rules.
	EnableLogging pulumi.BoolPtrInput
	// The firewall policy of the resource.
	FirewallPolicy pulumi.StringPtrInput
	// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
	Kind pulumi.StringPtrInput
	// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
	// Structure is documented below.
	Match FirewallPolicyRuleMatchPtrInput
	// An integer indicating the priority of a rule in the list.
	// The priority must be a positive value between 0 and 2147483647.
	// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
	Priority pulumi.IntPtrInput
	// Calculation of the complexity of a single firewall policy rule.
	RuleTupleCount pulumi.IntPtrInput
	// A fully-qualified URL of a SecurityProfile resource instance. Example:
	// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
	// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
	SecurityProfileGroup pulumi.StringPtrInput
	// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
	// this rule. If this field is left blank, all VMs within the organization will receive the rule.
	TargetResources pulumi.StringArrayInput
	// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
	// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
	// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
	// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
	// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
	TargetSecureTags FirewallPolicyRuleTargetSecureTagArrayInput
	// A list of service accounts indicating the sets of instances that are applied with this rule.
	TargetServiceAccounts pulumi.StringArrayInput
	// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
	// 'apply_security_profile_group' and cannot be set for other actions.
	TlsInspect pulumi.BoolPtrInput
}

func (FirewallPolicyRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallPolicyRuleState)(nil)).Elem()
}

type firewallPolicyRuleArgs struct {
	// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
	Action string `pulumi:"action"`
	// An optional description for this resource.
	Description *string `pulumi:"description"`
	// The direction in which this rule applies.
	// Possible values are: `INGRESS`, `EGRESS`.
	Direction string `pulumi:"direction"`
	// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
	// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
	Disabled *bool `pulumi:"disabled"`
	// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
	// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
	// "gotoNext" rules.
	EnableLogging *bool `pulumi:"enableLogging"`
	// The firewall policy of the resource.
	FirewallPolicy string `pulumi:"firewallPolicy"`
	// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
	// Structure is documented below.
	Match FirewallPolicyRuleMatch `pulumi:"match"`
	// An integer indicating the priority of a rule in the list.
	// The priority must be a positive value between 0 and 2147483647.
	// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
	Priority int `pulumi:"priority"`
	// A fully-qualified URL of a SecurityProfile resource instance. Example:
	// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
	// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
	SecurityProfileGroup *string `pulumi:"securityProfileGroup"`
	// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
	// this rule. If this field is left blank, all VMs within the organization will receive the rule.
	TargetResources []string `pulumi:"targetResources"`
	// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
	// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
	// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
	// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
	// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
	TargetSecureTags []FirewallPolicyRuleTargetSecureTag `pulumi:"targetSecureTags"`
	// A list of service accounts indicating the sets of instances that are applied with this rule.
	TargetServiceAccounts []string `pulumi:"targetServiceAccounts"`
	// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
	// 'apply_security_profile_group' and cannot be set for other actions.
	TlsInspect *bool `pulumi:"tlsInspect"`
}

// The set of arguments for constructing a FirewallPolicyRule resource.
type FirewallPolicyRuleArgs struct {
	// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
	Action pulumi.StringInput
	// An optional description for this resource.
	Description pulumi.StringPtrInput
	// The direction in which this rule applies.
	// Possible values are: `INGRESS`, `EGRESS`.
	Direction pulumi.StringInput
	// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
	// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
	Disabled pulumi.BoolPtrInput
	// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
	// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
	// "gotoNext" rules.
	EnableLogging pulumi.BoolPtrInput
	// The firewall policy of the resource.
	FirewallPolicy pulumi.StringInput
	// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
	// Structure is documented below.
	Match FirewallPolicyRuleMatchInput
	// An integer indicating the priority of a rule in the list.
	// The priority must be a positive value between 0 and 2147483647.
	// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
	Priority pulumi.IntInput
	// A fully-qualified URL of a SecurityProfile resource instance. Example:
	// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
	// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
	SecurityProfileGroup pulumi.StringPtrInput
	// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
	// this rule. If this field is left blank, all VMs within the organization will receive the rule.
	TargetResources pulumi.StringArrayInput
	// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
	// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
	// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
	// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
	// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
	TargetSecureTags FirewallPolicyRuleTargetSecureTagArrayInput
	// A list of service accounts indicating the sets of instances that are applied with this rule.
	TargetServiceAccounts pulumi.StringArrayInput
	// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
	// 'apply_security_profile_group' and cannot be set for other actions.
	TlsInspect pulumi.BoolPtrInput
}

func (FirewallPolicyRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallPolicyRuleArgs)(nil)).Elem()
}

type FirewallPolicyRuleInput interface {
	pulumi.Input

	ToFirewallPolicyRuleOutput() FirewallPolicyRuleOutput
	ToFirewallPolicyRuleOutputWithContext(ctx context.Context) FirewallPolicyRuleOutput
}

func (*FirewallPolicyRule) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyRule)(nil)).Elem()
}

func (i *FirewallPolicyRule) ToFirewallPolicyRuleOutput() FirewallPolicyRuleOutput {
	return i.ToFirewallPolicyRuleOutputWithContext(context.Background())
}

func (i *FirewallPolicyRule) ToFirewallPolicyRuleOutputWithContext(ctx context.Context) FirewallPolicyRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyRuleOutput)
}

// FirewallPolicyRuleArrayInput is an input type that accepts FirewallPolicyRuleArray and FirewallPolicyRuleArrayOutput values.
// You can construct a concrete instance of `FirewallPolicyRuleArrayInput` via:
//
//	FirewallPolicyRuleArray{ FirewallPolicyRuleArgs{...} }
type FirewallPolicyRuleArrayInput interface {
	pulumi.Input

	ToFirewallPolicyRuleArrayOutput() FirewallPolicyRuleArrayOutput
	ToFirewallPolicyRuleArrayOutputWithContext(context.Context) FirewallPolicyRuleArrayOutput
}

type FirewallPolicyRuleArray []FirewallPolicyRuleInput

func (FirewallPolicyRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallPolicyRule)(nil)).Elem()
}

func (i FirewallPolicyRuleArray) ToFirewallPolicyRuleArrayOutput() FirewallPolicyRuleArrayOutput {
	return i.ToFirewallPolicyRuleArrayOutputWithContext(context.Background())
}

func (i FirewallPolicyRuleArray) ToFirewallPolicyRuleArrayOutputWithContext(ctx context.Context) FirewallPolicyRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyRuleArrayOutput)
}

// FirewallPolicyRuleMapInput is an input type that accepts FirewallPolicyRuleMap and FirewallPolicyRuleMapOutput values.
// You can construct a concrete instance of `FirewallPolicyRuleMapInput` via:
//
//	FirewallPolicyRuleMap{ "key": FirewallPolicyRuleArgs{...} }
type FirewallPolicyRuleMapInput interface {
	pulumi.Input

	ToFirewallPolicyRuleMapOutput() FirewallPolicyRuleMapOutput
	ToFirewallPolicyRuleMapOutputWithContext(context.Context) FirewallPolicyRuleMapOutput
}

type FirewallPolicyRuleMap map[string]FirewallPolicyRuleInput

func (FirewallPolicyRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallPolicyRule)(nil)).Elem()
}

func (i FirewallPolicyRuleMap) ToFirewallPolicyRuleMapOutput() FirewallPolicyRuleMapOutput {
	return i.ToFirewallPolicyRuleMapOutputWithContext(context.Background())
}

func (i FirewallPolicyRuleMap) ToFirewallPolicyRuleMapOutputWithContext(ctx context.Context) FirewallPolicyRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyRuleMapOutput)
}

type FirewallPolicyRuleOutput struct{ *pulumi.OutputState }

func (FirewallPolicyRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyRule)(nil)).Elem()
}

func (o FirewallPolicyRuleOutput) ToFirewallPolicyRuleOutput() FirewallPolicyRuleOutput {
	return o
}

func (o FirewallPolicyRuleOutput) ToFirewallPolicyRuleOutputWithContext(ctx context.Context) FirewallPolicyRuleOutput {
	return o
}

// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny", "gotoNext" and "applySecurityProfileGroup".
func (o FirewallPolicyRuleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// Creation timestamp in RFC3339 text format.
func (o FirewallPolicyRuleOutput) CreationTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringOutput { return v.CreationTimestamp }).(pulumi.StringOutput)
}

// An optional description for this resource.
func (o FirewallPolicyRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The direction in which this rule applies.
// Possible values are: `INGRESS`, `EGRESS`.
func (o FirewallPolicyRuleOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringOutput { return v.Direction }).(pulumi.StringOutput)
}

// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and
// traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
func (o FirewallPolicyRuleOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.BoolPtrOutput { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured
// export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on
// "gotoNext" rules.
func (o FirewallPolicyRuleOutput) EnableLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.BoolPtrOutput { return v.EnableLogging }).(pulumi.BoolPtrOutput)
}

// The firewall policy of the resource.
func (o FirewallPolicyRuleOutput) FirewallPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringOutput { return v.FirewallPolicy }).(pulumi.StringOutput)
}

// Type of the resource. Always `compute#firewallPolicyRule` for firewall policy rules
func (o FirewallPolicyRuleOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringOutput { return v.Kind }).(pulumi.StringOutput)
}

// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
// Structure is documented below.
func (o FirewallPolicyRuleOutput) Match() FirewallPolicyRuleMatchOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) FirewallPolicyRuleMatchOutput { return v.Match }).(FirewallPolicyRuleMatchOutput)
}

// An integer indicating the priority of a rule in the list.
// The priority must be a positive value between 0 and 2147483647.
// Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
func (o FirewallPolicyRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.IntOutput { return v.Priority }).(pulumi.IntOutput)
}

// Calculation of the complexity of a single firewall policy rule.
func (o FirewallPolicyRuleOutput) RuleTupleCount() pulumi.IntOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.IntOutput { return v.RuleTupleCount }).(pulumi.IntOutput)
}

// A fully-qualified URL of a SecurityProfile resource instance. Example:
// https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
// Must be specified if action = 'apply_security_profile_group' and cannot be specified for other actions.
func (o FirewallPolicyRuleOutput) SecurityProfileGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringPtrOutput { return v.SecurityProfileGroup }).(pulumi.StringPtrOutput)
}

// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get
// this rule. If this field is left blank, all VMs within the organization will receive the rule.
func (o FirewallPolicyRuleOutput) TargetResources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringArrayOutput { return v.TargetResources }).(pulumi.StringArrayOutput)
}

// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then
// the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the
// targetSecureTag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same
// time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule
// applies to all instances on the specified network. Maximum number of target secure tags allowed is 256.
func (o FirewallPolicyRuleOutput) TargetSecureTags() FirewallPolicyRuleTargetSecureTagArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) FirewallPolicyRuleTargetSecureTagArrayOutput { return v.TargetSecureTags }).(FirewallPolicyRuleTargetSecureTagArrayOutput)
}

// A list of service accounts indicating the sets of instances that are applied with this rule.
func (o FirewallPolicyRuleOutput) TargetServiceAccounts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.StringArrayOutput { return v.TargetServiceAccounts }).(pulumi.StringArrayOutput)
}

// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action =
// 'apply_security_profile_group' and cannot be set for other actions.
func (o FirewallPolicyRuleOutput) TlsInspect() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyRule) pulumi.BoolPtrOutput { return v.TlsInspect }).(pulumi.BoolPtrOutput)
}

type FirewallPolicyRuleArrayOutput struct{ *pulumi.OutputState }

func (FirewallPolicyRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallPolicyRule)(nil)).Elem()
}

func (o FirewallPolicyRuleArrayOutput) ToFirewallPolicyRuleArrayOutput() FirewallPolicyRuleArrayOutput {
	return o
}

func (o FirewallPolicyRuleArrayOutput) ToFirewallPolicyRuleArrayOutputWithContext(ctx context.Context) FirewallPolicyRuleArrayOutput {
	return o
}

func (o FirewallPolicyRuleArrayOutput) Index(i pulumi.IntInput) FirewallPolicyRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FirewallPolicyRule {
		return vs[0].([]*FirewallPolicyRule)[vs[1].(int)]
	}).(FirewallPolicyRuleOutput)
}

type FirewallPolicyRuleMapOutput struct{ *pulumi.OutputState }

func (FirewallPolicyRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallPolicyRule)(nil)).Elem()
}

func (o FirewallPolicyRuleMapOutput) ToFirewallPolicyRuleMapOutput() FirewallPolicyRuleMapOutput {
	return o
}

func (o FirewallPolicyRuleMapOutput) ToFirewallPolicyRuleMapOutputWithContext(ctx context.Context) FirewallPolicyRuleMapOutput {
	return o
}

func (o FirewallPolicyRuleMapOutput) MapIndex(k pulumi.StringInput) FirewallPolicyRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FirewallPolicyRule {
		return vs[0].(map[string]*FirewallPolicyRule)[vs[1].(string)]
	}).(FirewallPolicyRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyRuleInput)(nil)).Elem(), &FirewallPolicyRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyRuleArrayInput)(nil)).Elem(), FirewallPolicyRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyRuleMapInput)(nil)).Elem(), FirewallPolicyRuleMap{})
	pulumi.RegisterOutputType(FirewallPolicyRuleOutput{})
	pulumi.RegisterOutputType(FirewallPolicyRuleArrayOutput{})
	pulumi.RegisterOutputType(FirewallPolicyRuleMapOutput{})
}
