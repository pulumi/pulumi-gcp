// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dataproc

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Spark application is a single Spark workload run on a GDC cluster.
//
// To get more information about SparkApplication, see:
//
// * [API documentation](https://cloud.google.com/dataproc-gdc/docs/reference/rest/v1/projects.locations.serviceInstances.sparkApplications)
// * How-to Guides
//   - [Dataproc Intro](https://cloud.google.com/dataproc/)
//
// ## Example Usage
//
// ### Dataprocgdc Sparkapplication Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-spark-app-basic"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				SparkApplicationConfig: &dataproc.GdcSparkApplicationSparkApplicationConfigArgs{
//					MainClass: pulumi.String("org.apache.spark.examples.SparkPi"),
//					JarFileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//					Args: pulumi.StringArray{
//						pulumi.String("10000"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dataprocgdc Sparkapplication
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			appEnv, err := dataproc.NewGdcApplicationEnvironment(ctx, "app_env", &dataproc.GdcApplicationEnvironmentArgs{
//				ApplicationEnvironmentId: pulumi.String("tf-e2e-spark-app-env"),
//				Serviceinstance:          pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:                  pulumi.String("my-project"),
//				Location:                 pulumi.String("us-west2"),
//				Namespace:                pulumi.String("default"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-spark-app"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				Labels: pulumi.StringMap{
//					"test-label": pulumi.String("label-value"),
//				},
//				Annotations: pulumi.StringMap{
//					"an_annotation": pulumi.String("annotation_value"),
//				},
//				Properties: pulumi.StringMap{
//					"spark.executor.instances": pulumi.String("2"),
//				},
//				ApplicationEnvironment: appEnv.Name,
//				Version:                pulumi.String("1.2"),
//				SparkApplicationConfig: &dataproc.GdcSparkApplicationSparkApplicationConfigArgs{
//					MainJarFileUri: pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					JarFileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//					ArchiveUris: pulumi.StringArray{
//						pulumi.String("file://usr/lib/spark/examples/spark-examples.jar"),
//					},
//					FileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dataprocgdc Sparkapplication Pyspark
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-pyspark-app"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				DisplayName:        pulumi.String("A Pyspark application for a Terraform create test"),
//				DependencyImages: pulumi.StringArray{
//					pulumi.String("gcr.io/some/image"),
//				},
//				PysparkApplicationConfig: &dataproc.GdcSparkApplicationPysparkApplicationConfigArgs{
//					MainPythonFileUri: pulumi.String("gs://goog-dataproc-initialization-actions-us-west2/conda/test_conda.py"),
//					JarFileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//					PythonFileUris: pulumi.StringArray{
//						pulumi.String("gs://goog-dataproc-initialization-actions-us-west2/conda/get-sys-exec.py"),
//					},
//					FileUris: pulumi.StringArray{
//						pulumi.String("file://usr/lib/spark/examples/spark-examples.jar"),
//					},
//					ArchiveUris: pulumi.StringArray{
//						pulumi.String("file://usr/lib/spark/examples/spark-examples.jar"),
//					},
//					Args: pulumi.StringArray{
//						pulumi.String("10"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dataprocgdc Sparkapplication Sparkr
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-sparkr-app"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				DisplayName:        pulumi.String("A SparkR application for a Terraform create test"),
//				SparkRApplicationConfig: &dataproc.GdcSparkApplicationSparkRApplicationConfigArgs{
//					MainRFileUri: pulumi.String("gs://some-bucket/something.R"),
//					FileUris: pulumi.StringArray{
//						pulumi.String("file://usr/lib/spark/examples/spark-examples.jar"),
//					},
//					ArchiveUris: pulumi.StringArray{
//						pulumi.String("file://usr/lib/spark/examples/spark-examples.jar"),
//					},
//					Args: pulumi.StringArray{
//						pulumi.String("10"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dataprocgdc Sparkapplication Sparksql
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-sparksql-app"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				DisplayName:        pulumi.String("A SparkSql application for a Terraform create test"),
//				SparkSqlApplicationConfig: &dataproc.GdcSparkApplicationSparkSqlApplicationConfigArgs{
//					JarFileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//					QueryList: &dataproc.GdcSparkApplicationSparkSqlApplicationConfigQueryListArgs{
//						Queries: pulumi.StringArray{
//							pulumi.String("show tables;"),
//						},
//					},
//					ScriptVariables: pulumi.StringMap{
//						"MY_VAR": pulumi.String("1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Dataprocgdc Sparkapplication Sparksql Query File
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/dataproc"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dataproc.NewGdcSparkApplication(ctx, "spark-application", &dataproc.GdcSparkApplicationArgs{
//				SparkApplicationId: pulumi.String("tf-e2e-sparksql-app"),
//				Serviceinstance:    pulumi.String("do-not-delete-dataproc-gdc-instance"),
//				Project:            pulumi.String("my-project"),
//				Location:           pulumi.String("us-west2"),
//				Namespace:          pulumi.String("default"),
//				DisplayName:        pulumi.String("A SparkSql application for a Terraform create test"),
//				SparkSqlApplicationConfig: &dataproc.GdcSparkApplicationSparkSqlApplicationConfigArgs{
//					JarFileUris: pulumi.StringArray{
//						pulumi.String("file:///usr/lib/spark/examples/jars/spark-examples.jar"),
//					},
//					QueryFileUri: pulumi.String("gs://some-bucket/something.sql"),
//					ScriptVariables: pulumi.StringMap{
//						"MY_VAR": pulumi.String("1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// SparkApplication can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/serviceInstances/{{serviceinstance}}/sparkApplications/{{spark_application_id}}`
//
// * `{{project}}/{{location}}/{{serviceinstance}}/{{spark_application_id}}`
//
// * `{{location}}/{{serviceinstance}}/{{spark_application_id}}`
//
// When using the `pulumi import` command, SparkApplication can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:dataproc/gdcSparkApplication:GdcSparkApplication default projects/{{project}}/locations/{{location}}/serviceInstances/{{serviceinstance}}/sparkApplications/{{spark_application_id}}
// ```
//
// ```sh
// $ pulumi import gcp:dataproc/gdcSparkApplication:GdcSparkApplication default {{project}}/{{location}}/{{serviceinstance}}/{{spark_application_id}}
// ```
//
// ```sh
// $ pulumi import gcp:dataproc/gdcSparkApplication:GdcSparkApplication default {{location}}/{{serviceinstance}}/{{spark_application_id}}
// ```
type GdcSparkApplication struct {
	pulumi.CustomResourceState

	// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// An ApplicationEnvironment from which to inherit configuration properties.
	ApplicationEnvironment pulumi.StringPtrOutput `pulumi:"applicationEnvironment"`
	// The timestamp when the resource was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
	DependencyImages pulumi.StringArrayOutput `pulumi:"dependencyImages"`
	// User-provided human-readable name to be used in user interfaces.
	DisplayName          pulumi.StringPtrOutput `pulumi:"displayName"`
	EffectiveAnnotations pulumi.StringMapOutput `pulumi:"effectiveAnnotations"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// The labels to associate with this application. Labels may be used for filtering and billing tracking.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The location of the spark application.
	Location pulumi.StringOutput `pulumi:"location"`
	// URL for a monitoring UI for this application (for eventual Spark PHS/UI support) Out of scope for private GA
	MonitoringEndpoint pulumi.StringOutput `pulumi:"monitoringEndpoint"`
	// Identifier. The name of the application. Format: projects/{project}/locations/{location}/serviceInstances/{service_instance}/sparkApplications/{application}
	Name pulumi.StringOutput `pulumi:"name"`
	// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
	Namespace pulumi.StringPtrOutput `pulumi:"namespace"`
	// An HCFS URI pointing to the location of stdout and stdout of the application Mainly useful for Pantheon and gcloud Not in scope for private GA
	OutputUri pulumi.StringOutput `pulumi:"outputUri"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// application-specific properties.
	Properties pulumi.StringMapOutput `pulumi:"properties"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// Represents the PySparkApplicationConfig.
	// Structure is documented below.
	PysparkApplicationConfig GdcSparkApplicationPysparkApplicationConfigPtrOutput `pulumi:"pysparkApplicationConfig"`
	// Whether the application is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
	Reconciling pulumi.BoolOutput `pulumi:"reconciling"`
	// The id of the service instance to which this spark application belongs.
	Serviceinstance pulumi.StringOutput `pulumi:"serviceinstance"`
	// Represents the SparkApplicationConfig.
	// Structure is documented below.
	SparkApplicationConfig GdcSparkApplicationSparkApplicationConfigPtrOutput `pulumi:"sparkApplicationConfig"`
	// The id of the application
	SparkApplicationId pulumi.StringOutput `pulumi:"sparkApplicationId"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkRApplicationConfig GdcSparkApplicationSparkRApplicationConfigPtrOutput `pulumi:"sparkRApplicationConfig"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkSqlApplicationConfig GdcSparkApplicationSparkSqlApplicationConfigPtrOutput `pulumi:"sparkSqlApplicationConfig"`
	// The current state.
	// Possible values:
	// * `STATE_UNSPECIFIED`
	// * `PENDING`
	// * `RUNNING`
	// * `CANCELLING`
	// * `CANCELLED`
	// * `SUCCEEDED`
	// * `FAILED`
	State pulumi.StringOutput `pulumi:"state"`
	// A message explaining the current state.
	StateMessage pulumi.StringOutput `pulumi:"stateMessage"`
	// System generated unique identifier for this application, formatted as UUID4.
	Uid pulumi.StringOutput `pulumi:"uid"`
	// The timestamp when the resource was most recently updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
	// The Dataproc version of this application.
	Version pulumi.StringPtrOutput `pulumi:"version"`
}

// NewGdcSparkApplication registers a new resource with the given unique name, arguments, and options.
func NewGdcSparkApplication(ctx *pulumi.Context,
	name string, args *GdcSparkApplicationArgs, opts ...pulumi.ResourceOption) (*GdcSparkApplication, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.Serviceinstance == nil {
		return nil, errors.New("invalid value for required argument 'Serviceinstance'")
	}
	if args.SparkApplicationId == nil {
		return nil, errors.New("invalid value for required argument 'SparkApplicationId'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GdcSparkApplication
	err := ctx.RegisterResource("gcp:dataproc/gdcSparkApplication:GdcSparkApplication", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGdcSparkApplication gets an existing GdcSparkApplication resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGdcSparkApplication(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GdcSparkApplicationState, opts ...pulumi.ResourceOption) (*GdcSparkApplication, error) {
	var resource GdcSparkApplication
	err := ctx.ReadResource("gcp:dataproc/gdcSparkApplication:GdcSparkApplication", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GdcSparkApplication resources.
type gdcSparkApplicationState struct {
	// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// An ApplicationEnvironment from which to inherit configuration properties.
	ApplicationEnvironment *string `pulumi:"applicationEnvironment"`
	// The timestamp when the resource was created.
	CreateTime *string `pulumi:"createTime"`
	// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
	DependencyImages []string `pulumi:"dependencyImages"`
	// User-provided human-readable name to be used in user interfaces.
	DisplayName          *string           `pulumi:"displayName"`
	EffectiveAnnotations map[string]string `pulumi:"effectiveAnnotations"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// The labels to associate with this application. Labels may be used for filtering and billing tracking.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location of the spark application.
	Location *string `pulumi:"location"`
	// URL for a monitoring UI for this application (for eventual Spark PHS/UI support) Out of scope for private GA
	MonitoringEndpoint *string `pulumi:"monitoringEndpoint"`
	// Identifier. The name of the application. Format: projects/{project}/locations/{location}/serviceInstances/{service_instance}/sparkApplications/{application}
	Name *string `pulumi:"name"`
	// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
	Namespace *string `pulumi:"namespace"`
	// An HCFS URI pointing to the location of stdout and stdout of the application Mainly useful for Pantheon and gcloud Not in scope for private GA
	OutputUri *string `pulumi:"outputUri"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// application-specific properties.
	Properties map[string]string `pulumi:"properties"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// Represents the PySparkApplicationConfig.
	// Structure is documented below.
	PysparkApplicationConfig *GdcSparkApplicationPysparkApplicationConfig `pulumi:"pysparkApplicationConfig"`
	// Whether the application is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
	Reconciling *bool `pulumi:"reconciling"`
	// The id of the service instance to which this spark application belongs.
	Serviceinstance *string `pulumi:"serviceinstance"`
	// Represents the SparkApplicationConfig.
	// Structure is documented below.
	SparkApplicationConfig *GdcSparkApplicationSparkApplicationConfig `pulumi:"sparkApplicationConfig"`
	// The id of the application
	SparkApplicationId *string `pulumi:"sparkApplicationId"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkRApplicationConfig *GdcSparkApplicationSparkRApplicationConfig `pulumi:"sparkRApplicationConfig"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkSqlApplicationConfig *GdcSparkApplicationSparkSqlApplicationConfig `pulumi:"sparkSqlApplicationConfig"`
	// The current state.
	// Possible values:
	// * `STATE_UNSPECIFIED`
	// * `PENDING`
	// * `RUNNING`
	// * `CANCELLING`
	// * `CANCELLED`
	// * `SUCCEEDED`
	// * `FAILED`
	State *string `pulumi:"state"`
	// A message explaining the current state.
	StateMessage *string `pulumi:"stateMessage"`
	// System generated unique identifier for this application, formatted as UUID4.
	Uid *string `pulumi:"uid"`
	// The timestamp when the resource was most recently updated.
	UpdateTime *string `pulumi:"updateTime"`
	// The Dataproc version of this application.
	Version *string `pulumi:"version"`
}

type GdcSparkApplicationState struct {
	// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// An ApplicationEnvironment from which to inherit configuration properties.
	ApplicationEnvironment pulumi.StringPtrInput
	// The timestamp when the resource was created.
	CreateTime pulumi.StringPtrInput
	// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
	DependencyImages pulumi.StringArrayInput
	// User-provided human-readable name to be used in user interfaces.
	DisplayName          pulumi.StringPtrInput
	EffectiveAnnotations pulumi.StringMapInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// The labels to associate with this application. Labels may be used for filtering and billing tracking.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location of the spark application.
	Location pulumi.StringPtrInput
	// URL for a monitoring UI for this application (for eventual Spark PHS/UI support) Out of scope for private GA
	MonitoringEndpoint pulumi.StringPtrInput
	// Identifier. The name of the application. Format: projects/{project}/locations/{location}/serviceInstances/{service_instance}/sparkApplications/{application}
	Name pulumi.StringPtrInput
	// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
	Namespace pulumi.StringPtrInput
	// An HCFS URI pointing to the location of stdout and stdout of the application Mainly useful for Pantheon and gcloud Not in scope for private GA
	OutputUri pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// application-specific properties.
	Properties pulumi.StringMapInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// Represents the PySparkApplicationConfig.
	// Structure is documented below.
	PysparkApplicationConfig GdcSparkApplicationPysparkApplicationConfigPtrInput
	// Whether the application is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
	Reconciling pulumi.BoolPtrInput
	// The id of the service instance to which this spark application belongs.
	Serviceinstance pulumi.StringPtrInput
	// Represents the SparkApplicationConfig.
	// Structure is documented below.
	SparkApplicationConfig GdcSparkApplicationSparkApplicationConfigPtrInput
	// The id of the application
	SparkApplicationId pulumi.StringPtrInput
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkRApplicationConfig GdcSparkApplicationSparkRApplicationConfigPtrInput
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkSqlApplicationConfig GdcSparkApplicationSparkSqlApplicationConfigPtrInput
	// The current state.
	// Possible values:
	// * `STATE_UNSPECIFIED`
	// * `PENDING`
	// * `RUNNING`
	// * `CANCELLING`
	// * `CANCELLED`
	// * `SUCCEEDED`
	// * `FAILED`
	State pulumi.StringPtrInput
	// A message explaining the current state.
	StateMessage pulumi.StringPtrInput
	// System generated unique identifier for this application, formatted as UUID4.
	Uid pulumi.StringPtrInput
	// The timestamp when the resource was most recently updated.
	UpdateTime pulumi.StringPtrInput
	// The Dataproc version of this application.
	Version pulumi.StringPtrInput
}

func (GdcSparkApplicationState) ElementType() reflect.Type {
	return reflect.TypeOf((*gdcSparkApplicationState)(nil)).Elem()
}

type gdcSparkApplicationArgs struct {
	// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// An ApplicationEnvironment from which to inherit configuration properties.
	ApplicationEnvironment *string `pulumi:"applicationEnvironment"`
	// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
	DependencyImages []string `pulumi:"dependencyImages"`
	// User-provided human-readable name to be used in user interfaces.
	DisplayName *string `pulumi:"displayName"`
	// The labels to associate with this application. Labels may be used for filtering and billing tracking.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The location of the spark application.
	Location string `pulumi:"location"`
	// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
	Namespace *string `pulumi:"namespace"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// application-specific properties.
	Properties map[string]string `pulumi:"properties"`
	// Represents the PySparkApplicationConfig.
	// Structure is documented below.
	PysparkApplicationConfig *GdcSparkApplicationPysparkApplicationConfig `pulumi:"pysparkApplicationConfig"`
	// The id of the service instance to which this spark application belongs.
	Serviceinstance string `pulumi:"serviceinstance"`
	// Represents the SparkApplicationConfig.
	// Structure is documented below.
	SparkApplicationConfig *GdcSparkApplicationSparkApplicationConfig `pulumi:"sparkApplicationConfig"`
	// The id of the application
	SparkApplicationId string `pulumi:"sparkApplicationId"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkRApplicationConfig *GdcSparkApplicationSparkRApplicationConfig `pulumi:"sparkRApplicationConfig"`
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkSqlApplicationConfig *GdcSparkApplicationSparkSqlApplicationConfig `pulumi:"sparkSqlApplicationConfig"`
	// The Dataproc version of this application.
	Version *string `pulumi:"version"`
}

// The set of arguments for constructing a GdcSparkApplication resource.
type GdcSparkApplicationArgs struct {
	// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
	// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
	// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// An ApplicationEnvironment from which to inherit configuration properties.
	ApplicationEnvironment pulumi.StringPtrInput
	// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
	DependencyImages pulumi.StringArrayInput
	// User-provided human-readable name to be used in user interfaces.
	DisplayName pulumi.StringPtrInput
	// The labels to associate with this application. Labels may be used for filtering and billing tracking.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The location of the spark application.
	Location pulumi.StringInput
	// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
	Namespace pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// application-specific properties.
	Properties pulumi.StringMapInput
	// Represents the PySparkApplicationConfig.
	// Structure is documented below.
	PysparkApplicationConfig GdcSparkApplicationPysparkApplicationConfigPtrInput
	// The id of the service instance to which this spark application belongs.
	Serviceinstance pulumi.StringInput
	// Represents the SparkApplicationConfig.
	// Structure is documented below.
	SparkApplicationConfig GdcSparkApplicationSparkApplicationConfigPtrInput
	// The id of the application
	SparkApplicationId pulumi.StringInput
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkRApplicationConfig GdcSparkApplicationSparkRApplicationConfigPtrInput
	// Represents the SparkRApplicationConfig.
	// Structure is documented below.
	SparkSqlApplicationConfig GdcSparkApplicationSparkSqlApplicationConfigPtrInput
	// The Dataproc version of this application.
	Version pulumi.StringPtrInput
}

func (GdcSparkApplicationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*gdcSparkApplicationArgs)(nil)).Elem()
}

type GdcSparkApplicationInput interface {
	pulumi.Input

	ToGdcSparkApplicationOutput() GdcSparkApplicationOutput
	ToGdcSparkApplicationOutputWithContext(ctx context.Context) GdcSparkApplicationOutput
}

func (*GdcSparkApplication) ElementType() reflect.Type {
	return reflect.TypeOf((**GdcSparkApplication)(nil)).Elem()
}

func (i *GdcSparkApplication) ToGdcSparkApplicationOutput() GdcSparkApplicationOutput {
	return i.ToGdcSparkApplicationOutputWithContext(context.Background())
}

func (i *GdcSparkApplication) ToGdcSparkApplicationOutputWithContext(ctx context.Context) GdcSparkApplicationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GdcSparkApplicationOutput)
}

// GdcSparkApplicationArrayInput is an input type that accepts GdcSparkApplicationArray and GdcSparkApplicationArrayOutput values.
// You can construct a concrete instance of `GdcSparkApplicationArrayInput` via:
//
//	GdcSparkApplicationArray{ GdcSparkApplicationArgs{...} }
type GdcSparkApplicationArrayInput interface {
	pulumi.Input

	ToGdcSparkApplicationArrayOutput() GdcSparkApplicationArrayOutput
	ToGdcSparkApplicationArrayOutputWithContext(context.Context) GdcSparkApplicationArrayOutput
}

type GdcSparkApplicationArray []GdcSparkApplicationInput

func (GdcSparkApplicationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GdcSparkApplication)(nil)).Elem()
}

func (i GdcSparkApplicationArray) ToGdcSparkApplicationArrayOutput() GdcSparkApplicationArrayOutput {
	return i.ToGdcSparkApplicationArrayOutputWithContext(context.Background())
}

func (i GdcSparkApplicationArray) ToGdcSparkApplicationArrayOutputWithContext(ctx context.Context) GdcSparkApplicationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GdcSparkApplicationArrayOutput)
}

// GdcSparkApplicationMapInput is an input type that accepts GdcSparkApplicationMap and GdcSparkApplicationMapOutput values.
// You can construct a concrete instance of `GdcSparkApplicationMapInput` via:
//
//	GdcSparkApplicationMap{ "key": GdcSparkApplicationArgs{...} }
type GdcSparkApplicationMapInput interface {
	pulumi.Input

	ToGdcSparkApplicationMapOutput() GdcSparkApplicationMapOutput
	ToGdcSparkApplicationMapOutputWithContext(context.Context) GdcSparkApplicationMapOutput
}

type GdcSparkApplicationMap map[string]GdcSparkApplicationInput

func (GdcSparkApplicationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GdcSparkApplication)(nil)).Elem()
}

func (i GdcSparkApplicationMap) ToGdcSparkApplicationMapOutput() GdcSparkApplicationMapOutput {
	return i.ToGdcSparkApplicationMapOutputWithContext(context.Background())
}

func (i GdcSparkApplicationMap) ToGdcSparkApplicationMapOutputWithContext(ctx context.Context) GdcSparkApplicationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GdcSparkApplicationMapOutput)
}

type GdcSparkApplicationOutput struct{ *pulumi.OutputState }

func (GdcSparkApplicationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GdcSparkApplication)(nil)).Elem()
}

func (o GdcSparkApplicationOutput) ToGdcSparkApplicationOutput() GdcSparkApplicationOutput {
	return o
}

func (o GdcSparkApplicationOutput) ToGdcSparkApplicationOutputWithContext(ctx context.Context) GdcSparkApplicationOutput {
	return o
}

// The annotations to associate with this application. Annotations may be used to store client information, but are not used by the server.
// **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
// Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
func (o GdcSparkApplicationOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// An ApplicationEnvironment from which to inherit configuration properties.
func (o GdcSparkApplicationOutput) ApplicationEnvironment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringPtrOutput { return v.ApplicationEnvironment }).(pulumi.StringPtrOutput)
}

// The timestamp when the resource was created.
func (o GdcSparkApplicationOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// List of container image uris for additional file dependencies. Dependent files are sequentially copied from each image. If a file with the same name exists in 2 images then the file from later image is used.
func (o GdcSparkApplicationOutput) DependencyImages() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringArrayOutput { return v.DependencyImages }).(pulumi.StringArrayOutput)
}

// User-provided human-readable name to be used in user interfaces.
func (o GdcSparkApplicationOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringPtrOutput { return v.DisplayName }).(pulumi.StringPtrOutput)
}

func (o GdcSparkApplicationOutput) EffectiveAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.EffectiveAnnotations }).(pulumi.StringMapOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o GdcSparkApplicationOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// The labels to associate with this application. Labels may be used for filtering and billing tracking.
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o GdcSparkApplicationOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The location of the spark application.
func (o GdcSparkApplicationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// URL for a monitoring UI for this application (for eventual Spark PHS/UI support) Out of scope for private GA
func (o GdcSparkApplicationOutput) MonitoringEndpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.MonitoringEndpoint }).(pulumi.StringOutput)
}

// Identifier. The name of the application. Format: projects/{project}/locations/{location}/serviceInstances/{service_instance}/sparkApplications/{application}
func (o GdcSparkApplicationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The Kubernetes namespace in which to create the application. This namespace must already exist on the cluster.
func (o GdcSparkApplicationOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringPtrOutput { return v.Namespace }).(pulumi.StringPtrOutput)
}

// An HCFS URI pointing to the location of stdout and stdout of the application Mainly useful for Pantheon and gcloud Not in scope for private GA
func (o GdcSparkApplicationOutput) OutputUri() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.OutputUri }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o GdcSparkApplicationOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// application-specific properties.
func (o GdcSparkApplicationOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.Properties }).(pulumi.StringMapOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o GdcSparkApplicationOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// Represents the PySparkApplicationConfig.
// Structure is documented below.
func (o GdcSparkApplicationOutput) PysparkApplicationConfig() GdcSparkApplicationPysparkApplicationConfigPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) GdcSparkApplicationPysparkApplicationConfigPtrOutput {
		return v.PysparkApplicationConfig
	}).(GdcSparkApplicationPysparkApplicationConfigPtrOutput)
}

// Whether the application is currently reconciling. True if the current state of the resource does not match the intended state, and the system is working to reconcile them, whether or not the change was user initiated.
func (o GdcSparkApplicationOutput) Reconciling() pulumi.BoolOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.BoolOutput { return v.Reconciling }).(pulumi.BoolOutput)
}

// The id of the service instance to which this spark application belongs.
func (o GdcSparkApplicationOutput) Serviceinstance() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.Serviceinstance }).(pulumi.StringOutput)
}

// Represents the SparkApplicationConfig.
// Structure is documented below.
func (o GdcSparkApplicationOutput) SparkApplicationConfig() GdcSparkApplicationSparkApplicationConfigPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) GdcSparkApplicationSparkApplicationConfigPtrOutput {
		return v.SparkApplicationConfig
	}).(GdcSparkApplicationSparkApplicationConfigPtrOutput)
}

// The id of the application
func (o GdcSparkApplicationOutput) SparkApplicationId() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.SparkApplicationId }).(pulumi.StringOutput)
}

// Represents the SparkRApplicationConfig.
// Structure is documented below.
func (o GdcSparkApplicationOutput) SparkRApplicationConfig() GdcSparkApplicationSparkRApplicationConfigPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) GdcSparkApplicationSparkRApplicationConfigPtrOutput {
		return v.SparkRApplicationConfig
	}).(GdcSparkApplicationSparkRApplicationConfigPtrOutput)
}

// Represents the SparkRApplicationConfig.
// Structure is documented below.
func (o GdcSparkApplicationOutput) SparkSqlApplicationConfig() GdcSparkApplicationSparkSqlApplicationConfigPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) GdcSparkApplicationSparkSqlApplicationConfigPtrOutput {
		return v.SparkSqlApplicationConfig
	}).(GdcSparkApplicationSparkSqlApplicationConfigPtrOutput)
}

// The current state.
// Possible values:
// * `STATE_UNSPECIFIED`
// * `PENDING`
// * `RUNNING`
// * `CANCELLING`
// * `CANCELLED`
// * `SUCCEEDED`
// * `FAILED`
func (o GdcSparkApplicationOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// A message explaining the current state.
func (o GdcSparkApplicationOutput) StateMessage() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.StateMessage }).(pulumi.StringOutput)
}

// System generated unique identifier for this application, formatted as UUID4.
func (o GdcSparkApplicationOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.Uid }).(pulumi.StringOutput)
}

// The timestamp when the resource was most recently updated.
func (o GdcSparkApplicationOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

// The Dataproc version of this application.
func (o GdcSparkApplicationOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GdcSparkApplication) pulumi.StringPtrOutput { return v.Version }).(pulumi.StringPtrOutput)
}

type GdcSparkApplicationArrayOutput struct{ *pulumi.OutputState }

func (GdcSparkApplicationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GdcSparkApplication)(nil)).Elem()
}

func (o GdcSparkApplicationArrayOutput) ToGdcSparkApplicationArrayOutput() GdcSparkApplicationArrayOutput {
	return o
}

func (o GdcSparkApplicationArrayOutput) ToGdcSparkApplicationArrayOutputWithContext(ctx context.Context) GdcSparkApplicationArrayOutput {
	return o
}

func (o GdcSparkApplicationArrayOutput) Index(i pulumi.IntInput) GdcSparkApplicationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GdcSparkApplication {
		return vs[0].([]*GdcSparkApplication)[vs[1].(int)]
	}).(GdcSparkApplicationOutput)
}

type GdcSparkApplicationMapOutput struct{ *pulumi.OutputState }

func (GdcSparkApplicationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GdcSparkApplication)(nil)).Elem()
}

func (o GdcSparkApplicationMapOutput) ToGdcSparkApplicationMapOutput() GdcSparkApplicationMapOutput {
	return o
}

func (o GdcSparkApplicationMapOutput) ToGdcSparkApplicationMapOutputWithContext(ctx context.Context) GdcSparkApplicationMapOutput {
	return o
}

func (o GdcSparkApplicationMapOutput) MapIndex(k pulumi.StringInput) GdcSparkApplicationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GdcSparkApplication {
		return vs[0].(map[string]*GdcSparkApplication)[vs[1].(string)]
	}).(GdcSparkApplicationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GdcSparkApplicationInput)(nil)).Elem(), &GdcSparkApplication{})
	pulumi.RegisterInputType(reflect.TypeOf((*GdcSparkApplicationArrayInput)(nil)).Elem(), GdcSparkApplicationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GdcSparkApplicationMapInput)(nil)).Elem(), GdcSparkApplicationMap{})
	pulumi.RegisterOutputType(GdcSparkApplicationOutput{})
	pulumi.RegisterOutputType(GdcSparkApplicationArrayOutput{})
	pulumi.RegisterOutputType(GdcSparkApplicationMapOutput{})
}
