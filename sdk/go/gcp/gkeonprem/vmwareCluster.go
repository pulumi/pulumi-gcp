// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gkeonprem

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Google VMware User Cluster.
//
// ## Example Usage
//
// ### Gkeonprem Vmware Cluster Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/gkeonprem"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gkeonprem.NewVMwareCluster(ctx, "cluster-basic", &gkeonprem.VMwareClusterArgs{
//				Name:                   pulumi.String("cluster-basic"),
//				Location:               pulumi.String("us-west1"),
//				AdminClusterMembership: pulumi.String("projects/870316890899/locations/global/memberships/gkeonprem-terraform-test"),
//				Description:            pulumi.String("test cluster"),
//				OnPremVersion:          pulumi.String("1.13.1-gke.35"),
//				Annotations:            pulumi.StringMap{},
//				NetworkConfig: &gkeonprem.VMwareClusterNetworkConfigArgs{
//					ServiceAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("10.96.0.0/12"),
//					},
//					PodAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("192.168.0.0/16"),
//					},
//					DhcpIpConfig: &gkeonprem.VMwareClusterNetworkConfigDhcpIpConfigArgs{
//						Enabled: pulumi.Bool(true),
//					},
//				},
//				ControlPlaneNode: &gkeonprem.VMwareClusterControlPlaneNodeArgs{
//					Cpus:     pulumi.Int(4),
//					Memory:   pulumi.Int(8192),
//					Replicas: pulumi.Int(1),
//				},
//				LoadBalancer: &gkeonprem.VMwareClusterLoadBalancerArgs{
//					VipConfig: &gkeonprem.VMwareClusterLoadBalancerVipConfigArgs{
//						ControlPlaneVip: pulumi.String("10.251.133.5"),
//						IngressVip:      pulumi.String("10.251.135.19"),
//					},
//					MetalLbConfig: &gkeonprem.VMwareClusterLoadBalancerMetalLbConfigArgs{
//						AddressPools: gkeonprem.VMwareClusterLoadBalancerMetalLbConfigAddressPoolArray{
//							&gkeonprem.VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs{
//								Pool:         pulumi.String("ingress-ip"),
//								ManualAssign: pulumi.Bool(true),
//								Addresses: pulumi.StringArray{
//									pulumi.String("10.251.135.19"),
//								},
//								AvoidBuggyIps: pulumi.Bool(true),
//							},
//							&gkeonprem.VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs{
//								Pool:         pulumi.String("lb-test-ip"),
//								ManualAssign: pulumi.Bool(true),
//								Addresses: pulumi.StringArray{
//									pulumi.String("10.251.135.19"),
//								},
//								AvoidBuggyIps: pulumi.Bool(true),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Gkeonprem Vmware Cluster F5lb
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/gkeonprem"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gkeonprem.NewVMwareCluster(ctx, "cluster-f5lb", &gkeonprem.VMwareClusterArgs{
//				Name:                   pulumi.String("cluster-f5lb"),
//				Location:               pulumi.String("us-west1"),
//				AdminClusterMembership: pulumi.String("projects/870316890899/locations/global/memberships/gkeonprem-terraform-test"),
//				Description:            pulumi.String("test cluster"),
//				OnPremVersion:          pulumi.String("1.13.1-gke.35"),
//				Annotations:            pulumi.StringMap{},
//				NetworkConfig: &gkeonprem.VMwareClusterNetworkConfigArgs{
//					ServiceAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("10.96.0.0/12"),
//					},
//					PodAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("192.168.0.0/16"),
//					},
//					DhcpIpConfig: &gkeonprem.VMwareClusterNetworkConfigDhcpIpConfigArgs{
//						Enabled: pulumi.Bool(true),
//					},
//					ControlPlaneV2Config: &gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigArgs{
//						ControlPlaneIpBlock: &gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs{
//							Ips: gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArray{
//								&gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs{
//									Hostname: pulumi.String("test-hostname"),
//									Ip:       pulumi.String("10.0.0.1"),
//								},
//							},
//							Netmask: pulumi.String("10.0.0.1/32"),
//							Gateway: pulumi.String("test-gateway"),
//						},
//					},
//					VcenterNetwork: pulumi.String("test-vcenter-network"),
//				},
//				ControlPlaneNode: &gkeonprem.VMwareClusterControlPlaneNodeArgs{
//					Cpus:     pulumi.Int(4),
//					Memory:   pulumi.Int(8192),
//					Replicas: pulumi.Int(1),
//					AutoResizeConfig: &gkeonprem.VMwareClusterControlPlaneNodeAutoResizeConfigArgs{
//						Enabled: pulumi.Bool(true),
//					},
//				},
//				LoadBalancer: &gkeonprem.VMwareClusterLoadBalancerArgs{
//					VipConfig: &gkeonprem.VMwareClusterLoadBalancerVipConfigArgs{
//						ControlPlaneVip: pulumi.String("10.251.133.5"),
//						IngressVip:      pulumi.String("10.251.135.19"),
//					},
//					F5Config: &gkeonprem.VMwareClusterLoadBalancerF5ConfigArgs{
//						Address:   pulumi.String("10.0.0.1"),
//						Partition: pulumi.String("test-partition"),
//						SnatPool:  pulumi.String("test-snap-pool"),
//					},
//				},
//				DataplaneV2: &gkeonprem.VMwareClusterDataplaneV2Args{
//					DataplaneV2Enabled:        pulumi.Bool(true),
//					WindowsDataplaneV2Enabled: pulumi.Bool(true),
//					AdvancedNetworking:        pulumi.Bool(true),
//				},
//				VmTrackingEnabled:     pulumi.Bool(true),
//				EnableControlPlaneV2:  pulumi.Bool(true),
//				DisableBundledIngress: pulumi.Bool(true),
//				Authorization: &gkeonprem.VMwareClusterAuthorizationArgs{
//					AdminUsers: gkeonprem.VMwareClusterAuthorizationAdminUserArray{
//						&gkeonprem.VMwareClusterAuthorizationAdminUserArgs{
//							Username: pulumi.String("testuser@gmail.com"),
//						},
//					},
//				},
//				AntiAffinityGroups: &gkeonprem.VMwareClusterAntiAffinityGroupsArgs{
//					AagConfigDisabled: pulumi.Bool(true),
//				},
//				AutoRepairConfig: &gkeonprem.VMwareClusterAutoRepairConfigArgs{
//					Enabled: pulumi.Bool(true),
//				},
//				Storage: &gkeonprem.VMwareClusterStorageArgs{
//					VsphereCsiDisabled: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Gkeonprem Vmware Cluster Manuallb
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/gkeonprem"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gkeonprem.NewVMwareCluster(ctx, "cluster-manuallb", &gkeonprem.VMwareClusterArgs{
//				Name:                   pulumi.String("cluster-manuallb"),
//				Location:               pulumi.String("us-west1"),
//				AdminClusterMembership: pulumi.String("projects/870316890899/locations/global/memberships/gkeonprem-terraform-test"),
//				Description:            pulumi.String("test cluster"),
//				OnPremVersion:          pulumi.String("1.13.1-gke.35"),
//				Annotations:            pulumi.StringMap{},
//				NetworkConfig: &gkeonprem.VMwareClusterNetworkConfigArgs{
//					ServiceAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("10.96.0.0/12"),
//					},
//					PodAddressCidrBlocks: pulumi.StringArray{
//						pulumi.String("192.168.0.0/16"),
//					},
//					HostConfig: &gkeonprem.VMwareClusterNetworkConfigHostConfigArgs{
//						DnsServers: pulumi.StringArray{
//							pulumi.String("10.254.41.1"),
//						},
//						NtpServers: pulumi.StringArray{
//							pulumi.String("216.239.35.8"),
//						},
//						DnsSearchDomains: pulumi.StringArray{
//							pulumi.String("test-domain"),
//						},
//					},
//					StaticIpConfig: &gkeonprem.VMwareClusterNetworkConfigStaticIpConfigArgs{
//						IpBlocks: gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockArray{
//							&gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs{
//								Netmask: pulumi.String("255.255.252.0"),
//								Gateway: pulumi.String("10.251.31.254"),
//								Ips: gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArray{
//									&gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs{
//										Ip:       pulumi.String("10.251.30.153"),
//										Hostname: pulumi.String("test-hostname1"),
//									},
//									&gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs{
//										Ip:       pulumi.String("10.251.31.206"),
//										Hostname: pulumi.String("test-hostname2"),
//									},
//									&gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs{
//										Ip:       pulumi.String("10.251.31.193"),
//										Hostname: pulumi.String("test-hostname3"),
//									},
//									&gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs{
//										Ip:       pulumi.String("10.251.30.230"),
//										Hostname: pulumi.String("test-hostname4"),
//									},
//								},
//							},
//						},
//					},
//				},
//				ControlPlaneNode: &gkeonprem.VMwareClusterControlPlaneNodeArgs{
//					Cpus:     pulumi.Int(4),
//					Memory:   pulumi.Int(8192),
//					Replicas: pulumi.Int(1),
//					AutoResizeConfig: &gkeonprem.VMwareClusterControlPlaneNodeAutoResizeConfigArgs{
//						Enabled: pulumi.Bool(true),
//					},
//				},
//				LoadBalancer: &gkeonprem.VMwareClusterLoadBalancerArgs{
//					VipConfig: &gkeonprem.VMwareClusterLoadBalancerVipConfigArgs{
//						ControlPlaneVip: pulumi.String("10.251.133.5"),
//						IngressVip:      pulumi.String("10.251.135.19"),
//					},
//					ManualLbConfig: &gkeonprem.VMwareClusterLoadBalancerManualLbConfigArgs{
//						IngressHttpNodePort:        pulumi.Int(30005),
//						IngressHttpsNodePort:       pulumi.Int(30006),
//						ControlPlaneNodePort:       pulumi.Int(30007),
//						KonnectivityServerNodePort: pulumi.Int(30008),
//					},
//				},
//				Vcenter: &gkeonprem.VMwareClusterVcenterArgs{
//					ResourcePool:      pulumi.String("test-resource-pool"),
//					Datastore:         pulumi.String("test-datastore"),
//					Datacenter:        pulumi.String("test-datacenter"),
//					Cluster:           pulumi.String("test-cluster"),
//					Folder:            pulumi.String("test-folder"),
//					CaCertData:        pulumi.String("test-ca-cert-data"),
//					StoragePolicyName: pulumi.String("test-storage-policy-name"),
//				},
//				DataplaneV2: &gkeonprem.VMwareClusterDataplaneV2Args{
//					DataplaneV2Enabled:        pulumi.Bool(true),
//					WindowsDataplaneV2Enabled: pulumi.Bool(true),
//					AdvancedNetworking:        pulumi.Bool(true),
//				},
//				VmTrackingEnabled:     pulumi.Bool(true),
//				EnableControlPlaneV2:  pulumi.Bool(true),
//				EnableAdvancedCluster: pulumi.Bool(true),
//				UpgradePolicy: &gkeonprem.VMwareClusterUpgradePolicyArgs{
//					ControlPlaneOnly: pulumi.Bool(true),
//				},
//				Authorization: &gkeonprem.VMwareClusterAuthorizationArgs{
//					AdminUsers: gkeonprem.VMwareClusterAuthorizationAdminUserArray{
//						&gkeonprem.VMwareClusterAuthorizationAdminUserArgs{
//							Username: pulumi.String("testuser@gmail.com"),
//						},
//					},
//				},
//				AntiAffinityGroups: &gkeonprem.VMwareClusterAntiAffinityGroupsArgs{
//					AagConfigDisabled: pulumi.Bool(true),
//				},
//				AutoRepairConfig: &gkeonprem.VMwareClusterAutoRepairConfigArgs{
//					Enabled: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// VmwareCluster can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}`
//
// * `{{project}}/{{location}}/{{name}}`
//
// * `{{location}}/{{name}}`
//
// When using the `pulumi import` command, VmwareCluster can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:gkeonprem/vMwareCluster:VMwareCluster default projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:gkeonprem/vMwareCluster:VMwareCluster default {{project}}/{{location}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:gkeonprem/vMwareCluster:VMwareCluster default {{location}}/{{name}}
// ```
type VMwareCluster struct {
	pulumi.CustomResourceState

	// The admin cluster this VMware User Cluster belongs to.
	// This is the full resource name of the admin cluster's hub membership.
	// In the future, references to other resource types might be allowed if
	// admin clusters are modeled as their own resources.
	AdminClusterMembership pulumi.StringOutput `pulumi:"adminClusterMembership"`
	// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
	// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
	// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
	// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
	// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
	// 'effective_annotations' for all of the annotations present on the resource.
	Annotations pulumi.StringMapOutput `pulumi:"annotations"`
	// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
	AntiAffinityGroups VMwareClusterAntiAffinityGroupsOutput `pulumi:"antiAffinityGroups"`
	// RBAC policy that will be applied and managed by GKE On-Prem.
	Authorization VMwareClusterAuthorizationPtrOutput `pulumi:"authorization"`
	// Configuration for auto repairing.
	AutoRepairConfig VMwareClusterAutoRepairConfigOutput `pulumi:"autoRepairConfig"`
	// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
	// Structure is documented below.
	ControlPlaneNode VMwareClusterControlPlaneNodeOutput `pulumi:"controlPlaneNode"`
	// The time at which VMware User Cluster was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
	DataplaneV2 VMwareClusterDataplaneV2Output `pulumi:"dataplaneV2"`
	// The time at which VMware User Cluster was deleted.
	DeleteTime pulumi.StringOutput `pulumi:"deleteTime"`
	// (Output)
	// The description of the validation check.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Disable bundled ingress.
	DisableBundledIngress pulumi.BoolPtrOutput   `pulumi:"disableBundledIngress"`
	EffectiveAnnotations  pulumi.StringMapOutput `pulumi:"effectiveAnnotations"`
	// Enable advanced cluster. Default to false.
	EnableAdvancedCluster pulumi.BoolPtrOutput `pulumi:"enableAdvancedCluster"`
	// Enable control plane V2. Default to false.
	EnableControlPlaneV2 pulumi.BoolPtrOutput `pulumi:"enableControlPlaneV2"`
	// The DNS name of VMware User Cluster's API server.
	Endpoint pulumi.StringOutput `pulumi:"endpoint"`
	// This checksum is computed by the server based on the value of other
	// fields, and may be sent on update and delete requests to ensure the
	// client has an up-to-date value before proceeding.
	// Allows clients to perform consistent read-modify-writes
	// through optimistic concurrency control.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// Fleet configuration for the cluster.
	// Structure is documented below.
	Fleets VMwareClusterFleetArrayOutput `pulumi:"fleets"`
	// Load Balancer configuration.
	LoadBalancer VMwareClusterLoadBalancerPtrOutput `pulumi:"loadBalancer"`
	// The object name of the VMware OnPremUserCluster custom resource on the
	// associated admin cluster. This field is used to support conflicting
	// names when enrolling existing clusters to the API. When used as a part of
	// cluster enrollment, this field will differ from the ID in the resource
	// name. For new clusters, this field will match the user provided cluster ID
	// and be visible in the last component of the resource name. It is not
	// modifiable.
	// All users should use this name to access their cluster using gkectl or
	// kubectl and should expect to see the local name when viewing admin
	// cluster controller logs.
	LocalName pulumi.StringOutput `pulumi:"localName"`
	// The location of the resource.
	Location pulumi.StringOutput `pulumi:"location"`
	// The VMware cluster name.
	Name pulumi.StringOutput `pulumi:"name"`
	// The VMware User Cluster network configuration.
	NetworkConfig VMwareClusterNetworkConfigPtrOutput `pulumi:"networkConfig"`
	// The Anthos clusters on the VMware version for your user cluster.
	OnPremVersion pulumi.StringOutput `pulumi:"onPremVersion"`
	Project       pulumi.StringOutput `pulumi:"project"`
	// If set, there are currently changes in flight to the VMware User Cluster.
	Reconciling pulumi.BoolOutput `pulumi:"reconciling"`
	// (Output)
	// The lifecycle state of the condition.
	State pulumi.StringOutput `pulumi:"state"`
	// (Output)
	// Specifies the detailed validation check status
	// Structure is documented below.
	Statuses VMwareClusterStatusArrayOutput `pulumi:"statuses"`
	// Storage configuration.
	Storage VMwareClusterStorageOutput `pulumi:"storage"`
	// The unique identifier of the VMware User Cluster.
	Uid pulumi.StringOutput `pulumi:"uid"`
	// The time at which VMware User Cluster was last updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
	// Specifies upgrade policy for the cluster.
	UpgradePolicy VMwareClusterUpgradePolicyPtrOutput `pulumi:"upgradePolicy"`
	// ValidationCheck represents the result of the preflight check job.
	// Structure is documented below.
	ValidationChecks VMwareClusterValidationCheckArrayOutput `pulumi:"validationChecks"`
	// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
	Vcenter VMwareClusterVcenterOutput `pulumi:"vcenter"`
	// Enable VM tracking.
	VmTrackingEnabled pulumi.BoolOutput `pulumi:"vmTrackingEnabled"`
}

// NewVMwareCluster registers a new resource with the given unique name, arguments, and options.
func NewVMwareCluster(ctx *pulumi.Context,
	name string, args *VMwareClusterArgs, opts ...pulumi.ResourceOption) (*VMwareCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AdminClusterMembership == nil {
		return nil, errors.New("invalid value for required argument 'AdminClusterMembership'")
	}
	if args.ControlPlaneNode == nil {
		return nil, errors.New("invalid value for required argument 'ControlPlaneNode'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.OnPremVersion == nil {
		return nil, errors.New("invalid value for required argument 'OnPremVersion'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VMwareCluster
	err := ctx.RegisterResource("gcp:gkeonprem/vMwareCluster:VMwareCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVMwareCluster gets an existing VMwareCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVMwareCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VMwareClusterState, opts ...pulumi.ResourceOption) (*VMwareCluster, error) {
	var resource VMwareCluster
	err := ctx.ReadResource("gcp:gkeonprem/vMwareCluster:VMwareCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VMwareCluster resources.
type vmwareClusterState struct {
	// The admin cluster this VMware User Cluster belongs to.
	// This is the full resource name of the admin cluster's hub membership.
	// In the future, references to other resource types might be allowed if
	// admin clusters are modeled as their own resources.
	AdminClusterMembership *string `pulumi:"adminClusterMembership"`
	// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
	// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
	// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
	// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
	// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
	// 'effective_annotations' for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
	AntiAffinityGroups *VMwareClusterAntiAffinityGroups `pulumi:"antiAffinityGroups"`
	// RBAC policy that will be applied and managed by GKE On-Prem.
	Authorization *VMwareClusterAuthorization `pulumi:"authorization"`
	// Configuration for auto repairing.
	AutoRepairConfig *VMwareClusterAutoRepairConfig `pulumi:"autoRepairConfig"`
	// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
	// Structure is documented below.
	ControlPlaneNode *VMwareClusterControlPlaneNode `pulumi:"controlPlaneNode"`
	// The time at which VMware User Cluster was created.
	CreateTime *string `pulumi:"createTime"`
	// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
	DataplaneV2 *VMwareClusterDataplaneV2 `pulumi:"dataplaneV2"`
	// The time at which VMware User Cluster was deleted.
	DeleteTime *string `pulumi:"deleteTime"`
	// (Output)
	// The description of the validation check.
	Description *string `pulumi:"description"`
	// Disable bundled ingress.
	DisableBundledIngress *bool             `pulumi:"disableBundledIngress"`
	EffectiveAnnotations  map[string]string `pulumi:"effectiveAnnotations"`
	// Enable advanced cluster. Default to false.
	EnableAdvancedCluster *bool `pulumi:"enableAdvancedCluster"`
	// Enable control plane V2. Default to false.
	EnableControlPlaneV2 *bool `pulumi:"enableControlPlaneV2"`
	// The DNS name of VMware User Cluster's API server.
	Endpoint *string `pulumi:"endpoint"`
	// This checksum is computed by the server based on the value of other
	// fields, and may be sent on update and delete requests to ensure the
	// client has an up-to-date value before proceeding.
	// Allows clients to perform consistent read-modify-writes
	// through optimistic concurrency control.
	Etag *string `pulumi:"etag"`
	// Fleet configuration for the cluster.
	// Structure is documented below.
	Fleets []VMwareClusterFleet `pulumi:"fleets"`
	// Load Balancer configuration.
	LoadBalancer *VMwareClusterLoadBalancer `pulumi:"loadBalancer"`
	// The object name of the VMware OnPremUserCluster custom resource on the
	// associated admin cluster. This field is used to support conflicting
	// names when enrolling existing clusters to the API. When used as a part of
	// cluster enrollment, this field will differ from the ID in the resource
	// name. For new clusters, this field will match the user provided cluster ID
	// and be visible in the last component of the resource name. It is not
	// modifiable.
	// All users should use this name to access their cluster using gkectl or
	// kubectl and should expect to see the local name when viewing admin
	// cluster controller logs.
	LocalName *string `pulumi:"localName"`
	// The location of the resource.
	Location *string `pulumi:"location"`
	// The VMware cluster name.
	Name *string `pulumi:"name"`
	// The VMware User Cluster network configuration.
	NetworkConfig *VMwareClusterNetworkConfig `pulumi:"networkConfig"`
	// The Anthos clusters on the VMware version for your user cluster.
	OnPremVersion *string `pulumi:"onPremVersion"`
	Project       *string `pulumi:"project"`
	// If set, there are currently changes in flight to the VMware User Cluster.
	Reconciling *bool `pulumi:"reconciling"`
	// (Output)
	// The lifecycle state of the condition.
	State *string `pulumi:"state"`
	// (Output)
	// Specifies the detailed validation check status
	// Structure is documented below.
	Statuses []VMwareClusterStatus `pulumi:"statuses"`
	// Storage configuration.
	Storage *VMwareClusterStorage `pulumi:"storage"`
	// The unique identifier of the VMware User Cluster.
	Uid *string `pulumi:"uid"`
	// The time at which VMware User Cluster was last updated.
	UpdateTime *string `pulumi:"updateTime"`
	// Specifies upgrade policy for the cluster.
	UpgradePolicy *VMwareClusterUpgradePolicy `pulumi:"upgradePolicy"`
	// ValidationCheck represents the result of the preflight check job.
	// Structure is documented below.
	ValidationChecks []VMwareClusterValidationCheck `pulumi:"validationChecks"`
	// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
	Vcenter *VMwareClusterVcenter `pulumi:"vcenter"`
	// Enable VM tracking.
	VmTrackingEnabled *bool `pulumi:"vmTrackingEnabled"`
}

type VMwareClusterState struct {
	// The admin cluster this VMware User Cluster belongs to.
	// This is the full resource name of the admin cluster's hub membership.
	// In the future, references to other resource types might be allowed if
	// admin clusters are modeled as their own resources.
	AdminClusterMembership pulumi.StringPtrInput
	// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
	// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
	// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
	// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
	// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
	// 'effective_annotations' for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
	AntiAffinityGroups VMwareClusterAntiAffinityGroupsPtrInput
	// RBAC policy that will be applied and managed by GKE On-Prem.
	Authorization VMwareClusterAuthorizationPtrInput
	// Configuration for auto repairing.
	AutoRepairConfig VMwareClusterAutoRepairConfigPtrInput
	// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
	// Structure is documented below.
	ControlPlaneNode VMwareClusterControlPlaneNodePtrInput
	// The time at which VMware User Cluster was created.
	CreateTime pulumi.StringPtrInput
	// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
	DataplaneV2 VMwareClusterDataplaneV2PtrInput
	// The time at which VMware User Cluster was deleted.
	DeleteTime pulumi.StringPtrInput
	// (Output)
	// The description of the validation check.
	Description pulumi.StringPtrInput
	// Disable bundled ingress.
	DisableBundledIngress pulumi.BoolPtrInput
	EffectiveAnnotations  pulumi.StringMapInput
	// Enable advanced cluster. Default to false.
	EnableAdvancedCluster pulumi.BoolPtrInput
	// Enable control plane V2. Default to false.
	EnableControlPlaneV2 pulumi.BoolPtrInput
	// The DNS name of VMware User Cluster's API server.
	Endpoint pulumi.StringPtrInput
	// This checksum is computed by the server based on the value of other
	// fields, and may be sent on update and delete requests to ensure the
	// client has an up-to-date value before proceeding.
	// Allows clients to perform consistent read-modify-writes
	// through optimistic concurrency control.
	Etag pulumi.StringPtrInput
	// Fleet configuration for the cluster.
	// Structure is documented below.
	Fleets VMwareClusterFleetArrayInput
	// Load Balancer configuration.
	LoadBalancer VMwareClusterLoadBalancerPtrInput
	// The object name of the VMware OnPremUserCluster custom resource on the
	// associated admin cluster. This field is used to support conflicting
	// names when enrolling existing clusters to the API. When used as a part of
	// cluster enrollment, this field will differ from the ID in the resource
	// name. For new clusters, this field will match the user provided cluster ID
	// and be visible in the last component of the resource name. It is not
	// modifiable.
	// All users should use this name to access their cluster using gkectl or
	// kubectl and should expect to see the local name when viewing admin
	// cluster controller logs.
	LocalName pulumi.StringPtrInput
	// The location of the resource.
	Location pulumi.StringPtrInput
	// The VMware cluster name.
	Name pulumi.StringPtrInput
	// The VMware User Cluster network configuration.
	NetworkConfig VMwareClusterNetworkConfigPtrInput
	// The Anthos clusters on the VMware version for your user cluster.
	OnPremVersion pulumi.StringPtrInput
	Project       pulumi.StringPtrInput
	// If set, there are currently changes in flight to the VMware User Cluster.
	Reconciling pulumi.BoolPtrInput
	// (Output)
	// The lifecycle state of the condition.
	State pulumi.StringPtrInput
	// (Output)
	// Specifies the detailed validation check status
	// Structure is documented below.
	Statuses VMwareClusterStatusArrayInput
	// Storage configuration.
	Storage VMwareClusterStoragePtrInput
	// The unique identifier of the VMware User Cluster.
	Uid pulumi.StringPtrInput
	// The time at which VMware User Cluster was last updated.
	UpdateTime pulumi.StringPtrInput
	// Specifies upgrade policy for the cluster.
	UpgradePolicy VMwareClusterUpgradePolicyPtrInput
	// ValidationCheck represents the result of the preflight check job.
	// Structure is documented below.
	ValidationChecks VMwareClusterValidationCheckArrayInput
	// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
	Vcenter VMwareClusterVcenterPtrInput
	// Enable VM tracking.
	VmTrackingEnabled pulumi.BoolPtrInput
}

func (VMwareClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareClusterState)(nil)).Elem()
}

type vmwareClusterArgs struct {
	// The admin cluster this VMware User Cluster belongs to.
	// This is the full resource name of the admin cluster's hub membership.
	// In the future, references to other resource types might be allowed if
	// admin clusters are modeled as their own resources.
	AdminClusterMembership string `pulumi:"adminClusterMembership"`
	// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
	// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
	// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
	// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
	// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
	// 'effective_annotations' for all of the annotations present on the resource.
	Annotations map[string]string `pulumi:"annotations"`
	// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
	AntiAffinityGroups *VMwareClusterAntiAffinityGroups `pulumi:"antiAffinityGroups"`
	// RBAC policy that will be applied and managed by GKE On-Prem.
	Authorization *VMwareClusterAuthorization `pulumi:"authorization"`
	// Configuration for auto repairing.
	AutoRepairConfig *VMwareClusterAutoRepairConfig `pulumi:"autoRepairConfig"`
	// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
	// Structure is documented below.
	ControlPlaneNode VMwareClusterControlPlaneNode `pulumi:"controlPlaneNode"`
	// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
	DataplaneV2 *VMwareClusterDataplaneV2 `pulumi:"dataplaneV2"`
	// (Output)
	// The description of the validation check.
	Description *string `pulumi:"description"`
	// Disable bundled ingress.
	DisableBundledIngress *bool `pulumi:"disableBundledIngress"`
	// Enable advanced cluster. Default to false.
	EnableAdvancedCluster *bool `pulumi:"enableAdvancedCluster"`
	// Enable control plane V2. Default to false.
	EnableControlPlaneV2 *bool `pulumi:"enableControlPlaneV2"`
	// Load Balancer configuration.
	LoadBalancer *VMwareClusterLoadBalancer `pulumi:"loadBalancer"`
	// The location of the resource.
	Location string `pulumi:"location"`
	// The VMware cluster name.
	Name *string `pulumi:"name"`
	// The VMware User Cluster network configuration.
	NetworkConfig *VMwareClusterNetworkConfig `pulumi:"networkConfig"`
	// The Anthos clusters on the VMware version for your user cluster.
	OnPremVersion string  `pulumi:"onPremVersion"`
	Project       *string `pulumi:"project"`
	// Storage configuration.
	Storage *VMwareClusterStorage `pulumi:"storage"`
	// Specifies upgrade policy for the cluster.
	UpgradePolicy *VMwareClusterUpgradePolicy `pulumi:"upgradePolicy"`
	// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
	Vcenter *VMwareClusterVcenter `pulumi:"vcenter"`
	// Enable VM tracking.
	VmTrackingEnabled *bool `pulumi:"vmTrackingEnabled"`
}

// The set of arguments for constructing a VMwareCluster resource.
type VMwareClusterArgs struct {
	// The admin cluster this VMware User Cluster belongs to.
	// This is the full resource name of the admin cluster's hub membership.
	// In the future, references to other resource types might be allowed if
	// admin clusters are modeled as their own resources.
	AdminClusterMembership pulumi.StringInput
	// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
	// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
	// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
	// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
	// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
	// 'effective_annotations' for all of the annotations present on the resource.
	Annotations pulumi.StringMapInput
	// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
	AntiAffinityGroups VMwareClusterAntiAffinityGroupsPtrInput
	// RBAC policy that will be applied and managed by GKE On-Prem.
	Authorization VMwareClusterAuthorizationPtrInput
	// Configuration for auto repairing.
	AutoRepairConfig VMwareClusterAutoRepairConfigPtrInput
	// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
	// Structure is documented below.
	ControlPlaneNode VMwareClusterControlPlaneNodeInput
	// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
	DataplaneV2 VMwareClusterDataplaneV2PtrInput
	// (Output)
	// The description of the validation check.
	Description pulumi.StringPtrInput
	// Disable bundled ingress.
	DisableBundledIngress pulumi.BoolPtrInput
	// Enable advanced cluster. Default to false.
	EnableAdvancedCluster pulumi.BoolPtrInput
	// Enable control plane V2. Default to false.
	EnableControlPlaneV2 pulumi.BoolPtrInput
	// Load Balancer configuration.
	LoadBalancer VMwareClusterLoadBalancerPtrInput
	// The location of the resource.
	Location pulumi.StringInput
	// The VMware cluster name.
	Name pulumi.StringPtrInput
	// The VMware User Cluster network configuration.
	NetworkConfig VMwareClusterNetworkConfigPtrInput
	// The Anthos clusters on the VMware version for your user cluster.
	OnPremVersion pulumi.StringInput
	Project       pulumi.StringPtrInput
	// Storage configuration.
	Storage VMwareClusterStoragePtrInput
	// Specifies upgrade policy for the cluster.
	UpgradePolicy VMwareClusterUpgradePolicyPtrInput
	// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
	Vcenter VMwareClusterVcenterPtrInput
	// Enable VM tracking.
	VmTrackingEnabled pulumi.BoolPtrInput
}

func (VMwareClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vmwareClusterArgs)(nil)).Elem()
}

type VMwareClusterInput interface {
	pulumi.Input

	ToVMwareClusterOutput() VMwareClusterOutput
	ToVMwareClusterOutputWithContext(ctx context.Context) VMwareClusterOutput
}

func (*VMwareCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**VMwareCluster)(nil)).Elem()
}

func (i *VMwareCluster) ToVMwareClusterOutput() VMwareClusterOutput {
	return i.ToVMwareClusterOutputWithContext(context.Background())
}

func (i *VMwareCluster) ToVMwareClusterOutputWithContext(ctx context.Context) VMwareClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMwareClusterOutput)
}

// VMwareClusterArrayInput is an input type that accepts VMwareClusterArray and VMwareClusterArrayOutput values.
// You can construct a concrete instance of `VMwareClusterArrayInput` via:
//
//	VMwareClusterArray{ VMwareClusterArgs{...} }
type VMwareClusterArrayInput interface {
	pulumi.Input

	ToVMwareClusterArrayOutput() VMwareClusterArrayOutput
	ToVMwareClusterArrayOutputWithContext(context.Context) VMwareClusterArrayOutput
}

type VMwareClusterArray []VMwareClusterInput

func (VMwareClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VMwareCluster)(nil)).Elem()
}

func (i VMwareClusterArray) ToVMwareClusterArrayOutput() VMwareClusterArrayOutput {
	return i.ToVMwareClusterArrayOutputWithContext(context.Background())
}

func (i VMwareClusterArray) ToVMwareClusterArrayOutputWithContext(ctx context.Context) VMwareClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMwareClusterArrayOutput)
}

// VMwareClusterMapInput is an input type that accepts VMwareClusterMap and VMwareClusterMapOutput values.
// You can construct a concrete instance of `VMwareClusterMapInput` via:
//
//	VMwareClusterMap{ "key": VMwareClusterArgs{...} }
type VMwareClusterMapInput interface {
	pulumi.Input

	ToVMwareClusterMapOutput() VMwareClusterMapOutput
	ToVMwareClusterMapOutputWithContext(context.Context) VMwareClusterMapOutput
}

type VMwareClusterMap map[string]VMwareClusterInput

func (VMwareClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VMwareCluster)(nil)).Elem()
}

func (i VMwareClusterMap) ToVMwareClusterMapOutput() VMwareClusterMapOutput {
	return i.ToVMwareClusterMapOutputWithContext(context.Background())
}

func (i VMwareClusterMap) ToVMwareClusterMapOutputWithContext(ctx context.Context) VMwareClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMwareClusterMapOutput)
}

type VMwareClusterOutput struct{ *pulumi.OutputState }

func (VMwareClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VMwareCluster)(nil)).Elem()
}

func (o VMwareClusterOutput) ToVMwareClusterOutput() VMwareClusterOutput {
	return o
}

func (o VMwareClusterOutput) ToVMwareClusterOutputWithContext(ctx context.Context) VMwareClusterOutput {
	return o
}

// The admin cluster this VMware User Cluster belongs to.
// This is the full resource name of the admin cluster's hub membership.
// In the future, references to other resource types might be allowed if
// admin clusters are modeled as their own resources.
func (o VMwareClusterOutput) AdminClusterMembership() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.AdminClusterMembership }).(pulumi.StringOutput)
}

// Annotations on the VMware User Cluster. This field has the same restrictions as Kubernetes annotations. The total size
// of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required),
// separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with
// alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between. **Note**: This field is
// non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field
// 'effective_annotations' for all of the annotations present on the resource.
func (o VMwareClusterOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringMapOutput { return v.Annotations }).(pulumi.StringMapOutput)
}

// AAGConfig specifies whether to spread VMware User Cluster nodes across at least three physical hosts in the datacenter.
func (o VMwareClusterOutput) AntiAffinityGroups() VMwareClusterAntiAffinityGroupsOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterAntiAffinityGroupsOutput { return v.AntiAffinityGroups }).(VMwareClusterAntiAffinityGroupsOutput)
}

// RBAC policy that will be applied and managed by GKE On-Prem.
func (o VMwareClusterOutput) Authorization() VMwareClusterAuthorizationPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterAuthorizationPtrOutput { return v.Authorization }).(VMwareClusterAuthorizationPtrOutput)
}

// Configuration for auto repairing.
func (o VMwareClusterOutput) AutoRepairConfig() VMwareClusterAutoRepairConfigOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterAutoRepairConfigOutput { return v.AutoRepairConfig }).(VMwareClusterAutoRepairConfigOutput)
}

// VMware User Cluster control plane nodes must have either 1 or 3 replicas.
// Structure is documented below.
func (o VMwareClusterOutput) ControlPlaneNode() VMwareClusterControlPlaneNodeOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterControlPlaneNodeOutput { return v.ControlPlaneNode }).(VMwareClusterControlPlaneNodeOutput)
}

// The time at which VMware User Cluster was created.
func (o VMwareClusterOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// VmwareDataplaneV2Config specifies configuration for Dataplane V2.
func (o VMwareClusterOutput) DataplaneV2() VMwareClusterDataplaneV2Output {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterDataplaneV2Output { return v.DataplaneV2 }).(VMwareClusterDataplaneV2Output)
}

// The time at which VMware User Cluster was deleted.
func (o VMwareClusterOutput) DeleteTime() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.DeleteTime }).(pulumi.StringOutput)
}

// (Output)
// The description of the validation check.
func (o VMwareClusterOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Disable bundled ingress.
func (o VMwareClusterOutput) DisableBundledIngress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.BoolPtrOutput { return v.DisableBundledIngress }).(pulumi.BoolPtrOutput)
}

func (o VMwareClusterOutput) EffectiveAnnotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringMapOutput { return v.EffectiveAnnotations }).(pulumi.StringMapOutput)
}

// Enable advanced cluster. Default to false.
func (o VMwareClusterOutput) EnableAdvancedCluster() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.BoolPtrOutput { return v.EnableAdvancedCluster }).(pulumi.BoolPtrOutput)
}

// Enable control plane V2. Default to false.
func (o VMwareClusterOutput) EnableControlPlaneV2() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.BoolPtrOutput { return v.EnableControlPlaneV2 }).(pulumi.BoolPtrOutput)
}

// The DNS name of VMware User Cluster's API server.
func (o VMwareClusterOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Endpoint }).(pulumi.StringOutput)
}

// This checksum is computed by the server based on the value of other
// fields, and may be sent on update and delete requests to ensure the
// client has an up-to-date value before proceeding.
// Allows clients to perform consistent read-modify-writes
// through optimistic concurrency control.
func (o VMwareClusterOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

// Fleet configuration for the cluster.
// Structure is documented below.
func (o VMwareClusterOutput) Fleets() VMwareClusterFleetArrayOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterFleetArrayOutput { return v.Fleets }).(VMwareClusterFleetArrayOutput)
}

// Load Balancer configuration.
func (o VMwareClusterOutput) LoadBalancer() VMwareClusterLoadBalancerPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterLoadBalancerPtrOutput { return v.LoadBalancer }).(VMwareClusterLoadBalancerPtrOutput)
}

// The object name of the VMware OnPremUserCluster custom resource on the
// associated admin cluster. This field is used to support conflicting
// names when enrolling existing clusters to the API. When used as a part of
// cluster enrollment, this field will differ from the ID in the resource
// name. For new clusters, this field will match the user provided cluster ID
// and be visible in the last component of the resource name. It is not
// modifiable.
// All users should use this name to access their cluster using gkectl or
// kubectl and should expect to see the local name when viewing admin
// cluster controller logs.
func (o VMwareClusterOutput) LocalName() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.LocalName }).(pulumi.StringOutput)
}

// The location of the resource.
func (o VMwareClusterOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The VMware cluster name.
func (o VMwareClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The VMware User Cluster network configuration.
func (o VMwareClusterOutput) NetworkConfig() VMwareClusterNetworkConfigPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterNetworkConfigPtrOutput { return v.NetworkConfig }).(VMwareClusterNetworkConfigPtrOutput)
}

// The Anthos clusters on the VMware version for your user cluster.
func (o VMwareClusterOutput) OnPremVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.OnPremVersion }).(pulumi.StringOutput)
}

func (o VMwareClusterOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// If set, there are currently changes in flight to the VMware User Cluster.
func (o VMwareClusterOutput) Reconciling() pulumi.BoolOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.BoolOutput { return v.Reconciling }).(pulumi.BoolOutput)
}

// (Output)
// The lifecycle state of the condition.
func (o VMwareClusterOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// (Output)
// Specifies the detailed validation check status
// Structure is documented below.
func (o VMwareClusterOutput) Statuses() VMwareClusterStatusArrayOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterStatusArrayOutput { return v.Statuses }).(VMwareClusterStatusArrayOutput)
}

// Storage configuration.
func (o VMwareClusterOutput) Storage() VMwareClusterStorageOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterStorageOutput { return v.Storage }).(VMwareClusterStorageOutput)
}

// The unique identifier of the VMware User Cluster.
func (o VMwareClusterOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.Uid }).(pulumi.StringOutput)
}

// The time at which VMware User Cluster was last updated.
func (o VMwareClusterOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

// Specifies upgrade policy for the cluster.
func (o VMwareClusterOutput) UpgradePolicy() VMwareClusterUpgradePolicyPtrOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterUpgradePolicyPtrOutput { return v.UpgradePolicy }).(VMwareClusterUpgradePolicyPtrOutput)
}

// ValidationCheck represents the result of the preflight check job.
// Structure is documented below.
func (o VMwareClusterOutput) ValidationChecks() VMwareClusterValidationCheckArrayOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterValidationCheckArrayOutput { return v.ValidationChecks }).(VMwareClusterValidationCheckArrayOutput)
}

// VmwareVCenterConfig specifies vCenter config for the user cluster. Inherited from the admin cluster.
func (o VMwareClusterOutput) Vcenter() VMwareClusterVcenterOutput {
	return o.ApplyT(func(v *VMwareCluster) VMwareClusterVcenterOutput { return v.Vcenter }).(VMwareClusterVcenterOutput)
}

// Enable VM tracking.
func (o VMwareClusterOutput) VmTrackingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *VMwareCluster) pulumi.BoolOutput { return v.VmTrackingEnabled }).(pulumi.BoolOutput)
}

type VMwareClusterArrayOutput struct{ *pulumi.OutputState }

func (VMwareClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VMwareCluster)(nil)).Elem()
}

func (o VMwareClusterArrayOutput) ToVMwareClusterArrayOutput() VMwareClusterArrayOutput {
	return o
}

func (o VMwareClusterArrayOutput) ToVMwareClusterArrayOutputWithContext(ctx context.Context) VMwareClusterArrayOutput {
	return o
}

func (o VMwareClusterArrayOutput) Index(i pulumi.IntInput) VMwareClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VMwareCluster {
		return vs[0].([]*VMwareCluster)[vs[1].(int)]
	}).(VMwareClusterOutput)
}

type VMwareClusterMapOutput struct{ *pulumi.OutputState }

func (VMwareClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VMwareCluster)(nil)).Elem()
}

func (o VMwareClusterMapOutput) ToVMwareClusterMapOutput() VMwareClusterMapOutput {
	return o
}

func (o VMwareClusterMapOutput) ToVMwareClusterMapOutputWithContext(ctx context.Context) VMwareClusterMapOutput {
	return o
}

func (o VMwareClusterMapOutput) MapIndex(k pulumi.StringInput) VMwareClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VMwareCluster {
		return vs[0].(map[string]*VMwareCluster)[vs[1].(string)]
	}).(VMwareClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VMwareClusterInput)(nil)).Elem(), &VMwareCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMwareClusterArrayInput)(nil)).Elem(), VMwareClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMwareClusterMapInput)(nil)).Elem(), VMwareClusterMap{})
	pulumi.RegisterOutputType(VMwareClusterOutput{})
	pulumi.RegisterOutputType(VMwareClusterArrayOutput{})
	pulumi.RegisterOutputType(VMwareClusterMapOutput{})
}
