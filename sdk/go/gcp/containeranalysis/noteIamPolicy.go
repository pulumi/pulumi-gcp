// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package containeranalysis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type NoteIamPolicy struct {
	pulumi.CustomResourceState

	Etag       pulumi.StringOutput `pulumi:"etag"`
	Note       pulumi.StringOutput `pulumi:"note"`
	PolicyData pulumi.StringOutput `pulumi:"policyData"`
	Project    pulumi.StringOutput `pulumi:"project"`
}

// NewNoteIamPolicy registers a new resource with the given unique name, arguments, and options.
func NewNoteIamPolicy(ctx *pulumi.Context,
	name string, args *NoteIamPolicyArgs, opts ...pulumi.ResourceOption) (*NoteIamPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Note == nil {
		return nil, errors.New("invalid value for required argument 'Note'")
	}
	if args.PolicyData == nil {
		return nil, errors.New("invalid value for required argument 'PolicyData'")
	}
	var resource NoteIamPolicy
	err := ctx.RegisterResource("gcp:containeranalysis/noteIamPolicy:NoteIamPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNoteIamPolicy gets an existing NoteIamPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNoteIamPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NoteIamPolicyState, opts ...pulumi.ResourceOption) (*NoteIamPolicy, error) {
	var resource NoteIamPolicy
	err := ctx.ReadResource("gcp:containeranalysis/noteIamPolicy:NoteIamPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NoteIamPolicy resources.
type noteIamPolicyState struct {
	Etag       *string `pulumi:"etag"`
	Note       *string `pulumi:"note"`
	PolicyData *string `pulumi:"policyData"`
	Project    *string `pulumi:"project"`
}

type NoteIamPolicyState struct {
	Etag       pulumi.StringPtrInput
	Note       pulumi.StringPtrInput
	PolicyData pulumi.StringPtrInput
	Project    pulumi.StringPtrInput
}

func (NoteIamPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamPolicyState)(nil)).Elem()
}

type noteIamPolicyArgs struct {
	Note       string  `pulumi:"note"`
	PolicyData string  `pulumi:"policyData"`
	Project    *string `pulumi:"project"`
}

// The set of arguments for constructing a NoteIamPolicy resource.
type NoteIamPolicyArgs struct {
	Note       pulumi.StringInput
	PolicyData pulumi.StringInput
	Project    pulumi.StringPtrInput
}

func (NoteIamPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamPolicyArgs)(nil)).Elem()
}

type NoteIamPolicyInput interface {
	pulumi.Input

	ToNoteIamPolicyOutput() NoteIamPolicyOutput
	ToNoteIamPolicyOutputWithContext(ctx context.Context) NoteIamPolicyOutput
}

func (*NoteIamPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamPolicy)(nil)).Elem()
}

func (i *NoteIamPolicy) ToNoteIamPolicyOutput() NoteIamPolicyOutput {
	return i.ToNoteIamPolicyOutputWithContext(context.Background())
}

func (i *NoteIamPolicy) ToNoteIamPolicyOutputWithContext(ctx context.Context) NoteIamPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamPolicyOutput)
}

// NoteIamPolicyArrayInput is an input type that accepts NoteIamPolicyArray and NoteIamPolicyArrayOutput values.
// You can construct a concrete instance of `NoteIamPolicyArrayInput` via:
//
//	NoteIamPolicyArray{ NoteIamPolicyArgs{...} }
type NoteIamPolicyArrayInput interface {
	pulumi.Input

	ToNoteIamPolicyArrayOutput() NoteIamPolicyArrayOutput
	ToNoteIamPolicyArrayOutputWithContext(context.Context) NoteIamPolicyArrayOutput
}

type NoteIamPolicyArray []NoteIamPolicyInput

func (NoteIamPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamPolicy)(nil)).Elem()
}

func (i NoteIamPolicyArray) ToNoteIamPolicyArrayOutput() NoteIamPolicyArrayOutput {
	return i.ToNoteIamPolicyArrayOutputWithContext(context.Background())
}

func (i NoteIamPolicyArray) ToNoteIamPolicyArrayOutputWithContext(ctx context.Context) NoteIamPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamPolicyArrayOutput)
}

// NoteIamPolicyMapInput is an input type that accepts NoteIamPolicyMap and NoteIamPolicyMapOutput values.
// You can construct a concrete instance of `NoteIamPolicyMapInput` via:
//
//	NoteIamPolicyMap{ "key": NoteIamPolicyArgs{...} }
type NoteIamPolicyMapInput interface {
	pulumi.Input

	ToNoteIamPolicyMapOutput() NoteIamPolicyMapOutput
	ToNoteIamPolicyMapOutputWithContext(context.Context) NoteIamPolicyMapOutput
}

type NoteIamPolicyMap map[string]NoteIamPolicyInput

func (NoteIamPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamPolicy)(nil)).Elem()
}

func (i NoteIamPolicyMap) ToNoteIamPolicyMapOutput() NoteIamPolicyMapOutput {
	return i.ToNoteIamPolicyMapOutputWithContext(context.Background())
}

func (i NoteIamPolicyMap) ToNoteIamPolicyMapOutputWithContext(ctx context.Context) NoteIamPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamPolicyMapOutput)
}

type NoteIamPolicyOutput struct{ *pulumi.OutputState }

func (NoteIamPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamPolicy)(nil)).Elem()
}

func (o NoteIamPolicyOutput) ToNoteIamPolicyOutput() NoteIamPolicyOutput {
	return o
}

func (o NoteIamPolicyOutput) ToNoteIamPolicyOutputWithContext(ctx context.Context) NoteIamPolicyOutput {
	return o
}

func (o NoteIamPolicyOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamPolicy) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

func (o NoteIamPolicyOutput) Note() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamPolicy) pulumi.StringOutput { return v.Note }).(pulumi.StringOutput)
}

func (o NoteIamPolicyOutput) PolicyData() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamPolicy) pulumi.StringOutput { return v.PolicyData }).(pulumi.StringOutput)
}

func (o NoteIamPolicyOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamPolicy) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

type NoteIamPolicyArrayOutput struct{ *pulumi.OutputState }

func (NoteIamPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamPolicy)(nil)).Elem()
}

func (o NoteIamPolicyArrayOutput) ToNoteIamPolicyArrayOutput() NoteIamPolicyArrayOutput {
	return o
}

func (o NoteIamPolicyArrayOutput) ToNoteIamPolicyArrayOutputWithContext(ctx context.Context) NoteIamPolicyArrayOutput {
	return o
}

func (o NoteIamPolicyArrayOutput) Index(i pulumi.IntInput) NoteIamPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NoteIamPolicy {
		return vs[0].([]*NoteIamPolicy)[vs[1].(int)]
	}).(NoteIamPolicyOutput)
}

type NoteIamPolicyMapOutput struct{ *pulumi.OutputState }

func (NoteIamPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamPolicy)(nil)).Elem()
}

func (o NoteIamPolicyMapOutput) ToNoteIamPolicyMapOutput() NoteIamPolicyMapOutput {
	return o
}

func (o NoteIamPolicyMapOutput) ToNoteIamPolicyMapOutputWithContext(ctx context.Context) NoteIamPolicyMapOutput {
	return o
}

func (o NoteIamPolicyMapOutput) MapIndex(k pulumi.StringInput) NoteIamPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NoteIamPolicy {
		return vs[0].(map[string]*NoteIamPolicy)[vs[1].(string)]
	}).(NoteIamPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamPolicyInput)(nil)).Elem(), &NoteIamPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamPolicyArrayInput)(nil)).Elem(), NoteIamPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamPolicyMapInput)(nil)).Elem(), NoteIamPolicyMap{})
	pulumi.RegisterOutputType(NoteIamPolicyOutput{})
	pulumi.RegisterOutputType(NoteIamPolicyArrayOutput{})
	pulumi.RegisterOutputType(NoteIamPolicyMapOutput{})
}
