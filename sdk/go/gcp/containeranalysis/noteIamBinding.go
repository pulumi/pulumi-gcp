// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package containeranalysis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type NoteIamBinding struct {
	pulumi.CustomResourceState

	Condition NoteIamBindingConditionPtrOutput `pulumi:"condition"`
	Etag      pulumi.StringOutput              `pulumi:"etag"`
	Members   pulumi.StringArrayOutput         `pulumi:"members"`
	Note      pulumi.StringOutput              `pulumi:"note"`
	Project   pulumi.StringOutput              `pulumi:"project"`
	Role      pulumi.StringOutput              `pulumi:"role"`
}

// NewNoteIamBinding registers a new resource with the given unique name, arguments, and options.
func NewNoteIamBinding(ctx *pulumi.Context,
	name string, args *NoteIamBindingArgs, opts ...pulumi.ResourceOption) (*NoteIamBinding, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Members == nil {
		return nil, errors.New("invalid value for required argument 'Members'")
	}
	if args.Note == nil {
		return nil, errors.New("invalid value for required argument 'Note'")
	}
	if args.Role == nil {
		return nil, errors.New("invalid value for required argument 'Role'")
	}
	var resource NoteIamBinding
	err := ctx.RegisterResource("gcp:containeranalysis/noteIamBinding:NoteIamBinding", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNoteIamBinding gets an existing NoteIamBinding resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNoteIamBinding(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NoteIamBindingState, opts ...pulumi.ResourceOption) (*NoteIamBinding, error) {
	var resource NoteIamBinding
	err := ctx.ReadResource("gcp:containeranalysis/noteIamBinding:NoteIamBinding", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NoteIamBinding resources.
type noteIamBindingState struct {
	Condition *NoteIamBindingCondition `pulumi:"condition"`
	Etag      *string                  `pulumi:"etag"`
	Members   []string                 `pulumi:"members"`
	Note      *string                  `pulumi:"note"`
	Project   *string                  `pulumi:"project"`
	Role      *string                  `pulumi:"role"`
}

type NoteIamBindingState struct {
	Condition NoteIamBindingConditionPtrInput
	Etag      pulumi.StringPtrInput
	Members   pulumi.StringArrayInput
	Note      pulumi.StringPtrInput
	Project   pulumi.StringPtrInput
	Role      pulumi.StringPtrInput
}

func (NoteIamBindingState) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamBindingState)(nil)).Elem()
}

type noteIamBindingArgs struct {
	Condition *NoteIamBindingCondition `pulumi:"condition"`
	Members   []string                 `pulumi:"members"`
	Note      string                   `pulumi:"note"`
	Project   *string                  `pulumi:"project"`
	Role      string                   `pulumi:"role"`
}

// The set of arguments for constructing a NoteIamBinding resource.
type NoteIamBindingArgs struct {
	Condition NoteIamBindingConditionPtrInput
	Members   pulumi.StringArrayInput
	Note      pulumi.StringInput
	Project   pulumi.StringPtrInput
	Role      pulumi.StringInput
}

func (NoteIamBindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamBindingArgs)(nil)).Elem()
}

type NoteIamBindingInput interface {
	pulumi.Input

	ToNoteIamBindingOutput() NoteIamBindingOutput
	ToNoteIamBindingOutputWithContext(ctx context.Context) NoteIamBindingOutput
}

func (*NoteIamBinding) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamBinding)(nil)).Elem()
}

func (i *NoteIamBinding) ToNoteIamBindingOutput() NoteIamBindingOutput {
	return i.ToNoteIamBindingOutputWithContext(context.Background())
}

func (i *NoteIamBinding) ToNoteIamBindingOutputWithContext(ctx context.Context) NoteIamBindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamBindingOutput)
}

// NoteIamBindingArrayInput is an input type that accepts NoteIamBindingArray and NoteIamBindingArrayOutput values.
// You can construct a concrete instance of `NoteIamBindingArrayInput` via:
//
//	NoteIamBindingArray{ NoteIamBindingArgs{...} }
type NoteIamBindingArrayInput interface {
	pulumi.Input

	ToNoteIamBindingArrayOutput() NoteIamBindingArrayOutput
	ToNoteIamBindingArrayOutputWithContext(context.Context) NoteIamBindingArrayOutput
}

type NoteIamBindingArray []NoteIamBindingInput

func (NoteIamBindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamBinding)(nil)).Elem()
}

func (i NoteIamBindingArray) ToNoteIamBindingArrayOutput() NoteIamBindingArrayOutput {
	return i.ToNoteIamBindingArrayOutputWithContext(context.Background())
}

func (i NoteIamBindingArray) ToNoteIamBindingArrayOutputWithContext(ctx context.Context) NoteIamBindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamBindingArrayOutput)
}

// NoteIamBindingMapInput is an input type that accepts NoteIamBindingMap and NoteIamBindingMapOutput values.
// You can construct a concrete instance of `NoteIamBindingMapInput` via:
//
//	NoteIamBindingMap{ "key": NoteIamBindingArgs{...} }
type NoteIamBindingMapInput interface {
	pulumi.Input

	ToNoteIamBindingMapOutput() NoteIamBindingMapOutput
	ToNoteIamBindingMapOutputWithContext(context.Context) NoteIamBindingMapOutput
}

type NoteIamBindingMap map[string]NoteIamBindingInput

func (NoteIamBindingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamBinding)(nil)).Elem()
}

func (i NoteIamBindingMap) ToNoteIamBindingMapOutput() NoteIamBindingMapOutput {
	return i.ToNoteIamBindingMapOutputWithContext(context.Background())
}

func (i NoteIamBindingMap) ToNoteIamBindingMapOutputWithContext(ctx context.Context) NoteIamBindingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamBindingMapOutput)
}

type NoteIamBindingOutput struct{ *pulumi.OutputState }

func (NoteIamBindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamBinding)(nil)).Elem()
}

func (o NoteIamBindingOutput) ToNoteIamBindingOutput() NoteIamBindingOutput {
	return o
}

func (o NoteIamBindingOutput) ToNoteIamBindingOutputWithContext(ctx context.Context) NoteIamBindingOutput {
	return o
}

func (o NoteIamBindingOutput) Condition() NoteIamBindingConditionPtrOutput {
	return o.ApplyT(func(v *NoteIamBinding) NoteIamBindingConditionPtrOutput { return v.Condition }).(NoteIamBindingConditionPtrOutput)
}

func (o NoteIamBindingOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamBinding) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

func (o NoteIamBindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NoteIamBinding) pulumi.StringArrayOutput { return v.Members }).(pulumi.StringArrayOutput)
}

func (o NoteIamBindingOutput) Note() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamBinding) pulumi.StringOutput { return v.Note }).(pulumi.StringOutput)
}

func (o NoteIamBindingOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamBinding) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

func (o NoteIamBindingOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamBinding) pulumi.StringOutput { return v.Role }).(pulumi.StringOutput)
}

type NoteIamBindingArrayOutput struct{ *pulumi.OutputState }

func (NoteIamBindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamBinding)(nil)).Elem()
}

func (o NoteIamBindingArrayOutput) ToNoteIamBindingArrayOutput() NoteIamBindingArrayOutput {
	return o
}

func (o NoteIamBindingArrayOutput) ToNoteIamBindingArrayOutputWithContext(ctx context.Context) NoteIamBindingArrayOutput {
	return o
}

func (o NoteIamBindingArrayOutput) Index(i pulumi.IntInput) NoteIamBindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NoteIamBinding {
		return vs[0].([]*NoteIamBinding)[vs[1].(int)]
	}).(NoteIamBindingOutput)
}

type NoteIamBindingMapOutput struct{ *pulumi.OutputState }

func (NoteIamBindingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamBinding)(nil)).Elem()
}

func (o NoteIamBindingMapOutput) ToNoteIamBindingMapOutput() NoteIamBindingMapOutput {
	return o
}

func (o NoteIamBindingMapOutput) ToNoteIamBindingMapOutputWithContext(ctx context.Context) NoteIamBindingMapOutput {
	return o
}

func (o NoteIamBindingMapOutput) MapIndex(k pulumi.StringInput) NoteIamBindingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NoteIamBinding {
		return vs[0].(map[string]*NoteIamBinding)[vs[1].(string)]
	}).(NoteIamBindingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamBindingInput)(nil)).Elem(), &NoteIamBinding{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamBindingArrayInput)(nil)).Elem(), NoteIamBindingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamBindingMapInput)(nil)).Elem(), NoteIamBindingMap{})
	pulumi.RegisterOutputType(NoteIamBindingOutput{})
	pulumi.RegisterOutputType(NoteIamBindingArrayOutput{})
	pulumi.RegisterOutputType(NoteIamBindingMapOutput{})
}
