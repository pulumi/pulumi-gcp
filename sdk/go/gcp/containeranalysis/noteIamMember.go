// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package containeranalysis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type NoteIamMember struct {
	pulumi.CustomResourceState

	Condition NoteIamMemberConditionPtrOutput `pulumi:"condition"`
	Etag      pulumi.StringOutput             `pulumi:"etag"`
	Member    pulumi.StringOutput             `pulumi:"member"`
	Note      pulumi.StringOutput             `pulumi:"note"`
	Project   pulumi.StringOutput             `pulumi:"project"`
	Role      pulumi.StringOutput             `pulumi:"role"`
}

// NewNoteIamMember registers a new resource with the given unique name, arguments, and options.
func NewNoteIamMember(ctx *pulumi.Context,
	name string, args *NoteIamMemberArgs, opts ...pulumi.ResourceOption) (*NoteIamMember, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Member == nil {
		return nil, errors.New("invalid value for required argument 'Member'")
	}
	if args.Note == nil {
		return nil, errors.New("invalid value for required argument 'Note'")
	}
	if args.Role == nil {
		return nil, errors.New("invalid value for required argument 'Role'")
	}
	var resource NoteIamMember
	err := ctx.RegisterResource("gcp:containeranalysis/noteIamMember:NoteIamMember", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNoteIamMember gets an existing NoteIamMember resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNoteIamMember(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NoteIamMemberState, opts ...pulumi.ResourceOption) (*NoteIamMember, error) {
	var resource NoteIamMember
	err := ctx.ReadResource("gcp:containeranalysis/noteIamMember:NoteIamMember", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NoteIamMember resources.
type noteIamMemberState struct {
	Condition *NoteIamMemberCondition `pulumi:"condition"`
	Etag      *string                 `pulumi:"etag"`
	Member    *string                 `pulumi:"member"`
	Note      *string                 `pulumi:"note"`
	Project   *string                 `pulumi:"project"`
	Role      *string                 `pulumi:"role"`
}

type NoteIamMemberState struct {
	Condition NoteIamMemberConditionPtrInput
	Etag      pulumi.StringPtrInput
	Member    pulumi.StringPtrInput
	Note      pulumi.StringPtrInput
	Project   pulumi.StringPtrInput
	Role      pulumi.StringPtrInput
}

func (NoteIamMemberState) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamMemberState)(nil)).Elem()
}

type noteIamMemberArgs struct {
	Condition *NoteIamMemberCondition `pulumi:"condition"`
	Member    string                  `pulumi:"member"`
	Note      string                  `pulumi:"note"`
	Project   *string                 `pulumi:"project"`
	Role      string                  `pulumi:"role"`
}

// The set of arguments for constructing a NoteIamMember resource.
type NoteIamMemberArgs struct {
	Condition NoteIamMemberConditionPtrInput
	Member    pulumi.StringInput
	Note      pulumi.StringInput
	Project   pulumi.StringPtrInput
	Role      pulumi.StringInput
}

func (NoteIamMemberArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*noteIamMemberArgs)(nil)).Elem()
}

type NoteIamMemberInput interface {
	pulumi.Input

	ToNoteIamMemberOutput() NoteIamMemberOutput
	ToNoteIamMemberOutputWithContext(ctx context.Context) NoteIamMemberOutput
}

func (*NoteIamMember) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamMember)(nil)).Elem()
}

func (i *NoteIamMember) ToNoteIamMemberOutput() NoteIamMemberOutput {
	return i.ToNoteIamMemberOutputWithContext(context.Background())
}

func (i *NoteIamMember) ToNoteIamMemberOutputWithContext(ctx context.Context) NoteIamMemberOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamMemberOutput)
}

// NoteIamMemberArrayInput is an input type that accepts NoteIamMemberArray and NoteIamMemberArrayOutput values.
// You can construct a concrete instance of `NoteIamMemberArrayInput` via:
//
//	NoteIamMemberArray{ NoteIamMemberArgs{...} }
type NoteIamMemberArrayInput interface {
	pulumi.Input

	ToNoteIamMemberArrayOutput() NoteIamMemberArrayOutput
	ToNoteIamMemberArrayOutputWithContext(context.Context) NoteIamMemberArrayOutput
}

type NoteIamMemberArray []NoteIamMemberInput

func (NoteIamMemberArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamMember)(nil)).Elem()
}

func (i NoteIamMemberArray) ToNoteIamMemberArrayOutput() NoteIamMemberArrayOutput {
	return i.ToNoteIamMemberArrayOutputWithContext(context.Background())
}

func (i NoteIamMemberArray) ToNoteIamMemberArrayOutputWithContext(ctx context.Context) NoteIamMemberArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamMemberArrayOutput)
}

// NoteIamMemberMapInput is an input type that accepts NoteIamMemberMap and NoteIamMemberMapOutput values.
// You can construct a concrete instance of `NoteIamMemberMapInput` via:
//
//	NoteIamMemberMap{ "key": NoteIamMemberArgs{...} }
type NoteIamMemberMapInput interface {
	pulumi.Input

	ToNoteIamMemberMapOutput() NoteIamMemberMapOutput
	ToNoteIamMemberMapOutputWithContext(context.Context) NoteIamMemberMapOutput
}

type NoteIamMemberMap map[string]NoteIamMemberInput

func (NoteIamMemberMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamMember)(nil)).Elem()
}

func (i NoteIamMemberMap) ToNoteIamMemberMapOutput() NoteIamMemberMapOutput {
	return i.ToNoteIamMemberMapOutputWithContext(context.Background())
}

func (i NoteIamMemberMap) ToNoteIamMemberMapOutputWithContext(ctx context.Context) NoteIamMemberMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NoteIamMemberMapOutput)
}

type NoteIamMemberOutput struct{ *pulumi.OutputState }

func (NoteIamMemberOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NoteIamMember)(nil)).Elem()
}

func (o NoteIamMemberOutput) ToNoteIamMemberOutput() NoteIamMemberOutput {
	return o
}

func (o NoteIamMemberOutput) ToNoteIamMemberOutputWithContext(ctx context.Context) NoteIamMemberOutput {
	return o
}

func (o NoteIamMemberOutput) Condition() NoteIamMemberConditionPtrOutput {
	return o.ApplyT(func(v *NoteIamMember) NoteIamMemberConditionPtrOutput { return v.Condition }).(NoteIamMemberConditionPtrOutput)
}

func (o NoteIamMemberOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamMember) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

func (o NoteIamMemberOutput) Member() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamMember) pulumi.StringOutput { return v.Member }).(pulumi.StringOutput)
}

func (o NoteIamMemberOutput) Note() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamMember) pulumi.StringOutput { return v.Note }).(pulumi.StringOutput)
}

func (o NoteIamMemberOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamMember) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

func (o NoteIamMemberOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v *NoteIamMember) pulumi.StringOutput { return v.Role }).(pulumi.StringOutput)
}

type NoteIamMemberArrayOutput struct{ *pulumi.OutputState }

func (NoteIamMemberArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NoteIamMember)(nil)).Elem()
}

func (o NoteIamMemberArrayOutput) ToNoteIamMemberArrayOutput() NoteIamMemberArrayOutput {
	return o
}

func (o NoteIamMemberArrayOutput) ToNoteIamMemberArrayOutputWithContext(ctx context.Context) NoteIamMemberArrayOutput {
	return o
}

func (o NoteIamMemberArrayOutput) Index(i pulumi.IntInput) NoteIamMemberOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NoteIamMember {
		return vs[0].([]*NoteIamMember)[vs[1].(int)]
	}).(NoteIamMemberOutput)
}

type NoteIamMemberMapOutput struct{ *pulumi.OutputState }

func (NoteIamMemberMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NoteIamMember)(nil)).Elem()
}

func (o NoteIamMemberMapOutput) ToNoteIamMemberMapOutput() NoteIamMemberMapOutput {
	return o
}

func (o NoteIamMemberMapOutput) ToNoteIamMemberMapOutputWithContext(ctx context.Context) NoteIamMemberMapOutput {
	return o
}

func (o NoteIamMemberMapOutput) MapIndex(k pulumi.StringInput) NoteIamMemberOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NoteIamMember {
		return vs[0].(map[string]*NoteIamMember)[vs[1].(string)]
	}).(NoteIamMemberOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamMemberInput)(nil)).Elem(), &NoteIamMember{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamMemberArrayInput)(nil)).Elem(), NoteIamMemberArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NoteIamMemberMapInput)(nil)).Elem(), NoteIamMemberMap{})
	pulumi.RegisterOutputType(NoteIamMemberOutput{})
	pulumi.RegisterOutputType(NoteIamMemberArrayOutput{})
	pulumi.RegisterOutputType(NoteIamMemberMapOutput{})
}
