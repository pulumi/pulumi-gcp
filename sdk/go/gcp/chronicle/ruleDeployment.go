// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package chronicle

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The RuleDeployment resource represents the deployment state of a Rule.
//
// To get more information about RuleDeployment, see:
//
// * [API documentation](https://cloud.google.com/chronicle/docs/reference/rest/v1/RuleDeployment)
// * How-to Guides
//   - [Google SecOps Guides](https://cloud.google.com/chronicle/docs/secops/secops-overview)
//
// ## Example Usage
//
// ### Chronicle Ruledeployment Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/chronicle"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// _, err := chronicle.NewRule(ctx, "my-rule", &chronicle.RuleArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Text: pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
// })
// if err != nil {
// return err
// }
// invokeSplit, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// invokeSplit1, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// _, err = chronicle.NewRuleDeployment(ctx, "example", &chronicle.RuleDeploymentArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Rule: pulumi.String(len(invokeSplit.Result).ApplyT(func(length int) (pulumi.Any, error) {
// %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference)).(pulumi.AnyOutput)),
// Enabled: pulumi.Bool(true),
// Alerting: pulumi.Bool(true),
// Archived: pulumi.Bool(false),
// RunFrequency: pulumi.String("DAILY"),
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
// ### Chronicle Ruledeployment Disabled
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/chronicle"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// _, err := chronicle.NewRule(ctx, "my-rule", &chronicle.RuleArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Text: pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
// })
// if err != nil {
// return err
// }
// invokeSplit, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// invokeSplit1, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// _, err = chronicle.NewRuleDeployment(ctx, "example", &chronicle.RuleDeploymentArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Rule: pulumi.String(len(invokeSplit.Result).ApplyT(func(length int) (pulumi.Any, error) {
// %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference)).(pulumi.AnyOutput)),
// Enabled: pulumi.Bool(false),
// RunFrequency: pulumi.String("LIVE"),
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
// ### Chronicle Ruledeployment Run Frequency Missing
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/chronicle"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// _, err := chronicle.NewRule(ctx, "my-rule", &chronicle.RuleArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Text: pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
// })
// if err != nil {
// return err
// }
// invokeSplit, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// invokeSplit1, err := std.Split(ctx, &std.SplitArgs{
// Separator: "/",
// Text: googleChronicleRule.MyRule.Name,
// }, nil)
// if err != nil {
// return err
// }
// _, err = chronicle.NewRuleDeployment(ctx, "example", &chronicle.RuleDeploymentArgs{
// Location: pulumi.String("us"),
// Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
// Rule: pulumi.String(len(invokeSplit.Result).ApplyT(func(length int) (pulumi.Any, error) {
// %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference)).(pulumi.AnyOutput)),
// Enabled: pulumi.Bool(true),
// Alerting: pulumi.Bool(true),
// Archived: pulumi.Bool(false),
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
//
// ## Import
//
// RuleDeployment can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/deployment`
//
// * `{{project}}/{{location}}/{{instance}}/{{rule}}`
//
// * `{{location}}/{{instance}}/{{rule}}`
//
// When using the `pulumi import` command, RuleDeployment can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:chronicle/ruleDeployment:RuleDeployment default projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/deployment
// ```
//
// ```sh
// $ pulumi import gcp:chronicle/ruleDeployment:RuleDeployment default {{project}}/{{location}}/{{instance}}/{{rule}}
// ```
//
// ```sh
// $ pulumi import gcp:chronicle/ruleDeployment:RuleDeployment default {{location}}/{{instance}}/{{rule}}
// ```
type RuleDeployment struct {
	pulumi.CustomResourceState

	// Whether detections resulting from this deployment should be considered
	// alerts.
	Alerting pulumi.BoolPtrOutput `pulumi:"alerting"`
	// Output only. The timestamp when the rule deployment archive state was last set to true. If the rule deployment's current archive state is not set to true, the field will be empty.
	ArchiveTime pulumi.StringOutput `pulumi:"archiveTime"`
	// The archive state of the rule deployment.
	// Cannot be set to true unless enabled is set to false i.e.
	// archiving requires a two-step process: first, disable the rule by
	// setting 'enabled' to false, then set 'archive' to true.
	// If set to true, alerting will automatically be set to false.
	// If currently set to true, enabled, alerting, and runFrequency cannot be
	// updated.
	Archived pulumi.BoolPtrOutput `pulumi:"archived"`
	// Output only. The names of the associated/chained consumer rules. Rules are considered
	// consumers of this rule if their rule text explicitly filters on this rule's ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ConsumerRules pulumi.StringArrayOutput `pulumi:"consumerRules"`
	// Whether the rule is currently deployed continuously against incoming data.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// The execution state of the rule deployment.
	// Possible values:
	// DEFAULT
	// LIMITED
	// PAUSED
	ExecutionState pulumi.StringOutput `pulumi:"executionState"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	Instance pulumi.StringOutput `pulumi:"instance"`
	// Output only. The timestamp when the rule deployment alert state was lastly changed. This is filled regardless of the current alert state.E.g. if the current alert status is false, this timestamp will be the timestamp when the alert status was changed to false.
	LastAlertStatusChangeTime pulumi.StringOutput `pulumi:"lastAlertStatusChangeTime"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringOutput `pulumi:"location"`
	// The resource name of the rule deployment.
	// Note that RuleDeployment is a child of the overall Rule, not any individual
	// revision, so the resource ID segment for the Rule resource must not
	// reference a specific revision.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}/deployment
	Name pulumi.StringOutput `pulumi:"name"`
	// Output only. The names of the associated/chained producer rules. Rules are considered
	// producers for this rule if this rule explicitly filters on their ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ProducerRules pulumi.StringArrayOutput `pulumi:"producerRules"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The Rule ID of the rule.
	Rule pulumi.StringOutput `pulumi:"rule"`
	// The run frequency of the rule deployment.
	// Possible values:
	// LIVE
	// HOURLY
	// DAILY
	RunFrequency pulumi.StringPtrOutput `pulumi:"runFrequency"`
}

// NewRuleDeployment registers a new resource with the given unique name, arguments, and options.
func NewRuleDeployment(ctx *pulumi.Context,
	name string, args *RuleDeploymentArgs, opts ...pulumi.ResourceOption) (*RuleDeployment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Instance == nil {
		return nil, errors.New("invalid value for required argument 'Instance'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.Rule == nil {
		return nil, errors.New("invalid value for required argument 'Rule'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RuleDeployment
	err := ctx.RegisterResource("gcp:chronicle/ruleDeployment:RuleDeployment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRuleDeployment gets an existing RuleDeployment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRuleDeployment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleDeploymentState, opts ...pulumi.ResourceOption) (*RuleDeployment, error) {
	var resource RuleDeployment
	err := ctx.ReadResource("gcp:chronicle/ruleDeployment:RuleDeployment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RuleDeployment resources.
type ruleDeploymentState struct {
	// Whether detections resulting from this deployment should be considered
	// alerts.
	Alerting *bool `pulumi:"alerting"`
	// Output only. The timestamp when the rule deployment archive state was last set to true. If the rule deployment's current archive state is not set to true, the field will be empty.
	ArchiveTime *string `pulumi:"archiveTime"`
	// The archive state of the rule deployment.
	// Cannot be set to true unless enabled is set to false i.e.
	// archiving requires a two-step process: first, disable the rule by
	// setting 'enabled' to false, then set 'archive' to true.
	// If set to true, alerting will automatically be set to false.
	// If currently set to true, enabled, alerting, and runFrequency cannot be
	// updated.
	Archived *bool `pulumi:"archived"`
	// Output only. The names of the associated/chained consumer rules. Rules are considered
	// consumers of this rule if their rule text explicitly filters on this rule's ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ConsumerRules []string `pulumi:"consumerRules"`
	// Whether the rule is currently deployed continuously against incoming data.
	Enabled *bool `pulumi:"enabled"`
	// The execution state of the rule deployment.
	// Possible values:
	// DEFAULT
	// LIMITED
	// PAUSED
	ExecutionState *string `pulumi:"executionState"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	Instance *string `pulumi:"instance"`
	// Output only. The timestamp when the rule deployment alert state was lastly changed. This is filled regardless of the current alert state.E.g. if the current alert status is false, this timestamp will be the timestamp when the alert status was changed to false.
	LastAlertStatusChangeTime *string `pulumi:"lastAlertStatusChangeTime"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location *string `pulumi:"location"`
	// The resource name of the rule deployment.
	// Note that RuleDeployment is a child of the overall Rule, not any individual
	// revision, so the resource ID segment for the Rule resource must not
	// reference a specific revision.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}/deployment
	Name *string `pulumi:"name"`
	// Output only. The names of the associated/chained producer rules. Rules are considered
	// producers for this rule if this rule explicitly filters on their ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ProducerRules []string `pulumi:"producerRules"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The Rule ID of the rule.
	Rule *string `pulumi:"rule"`
	// The run frequency of the rule deployment.
	// Possible values:
	// LIVE
	// HOURLY
	// DAILY
	RunFrequency *string `pulumi:"runFrequency"`
}

type RuleDeploymentState struct {
	// Whether detections resulting from this deployment should be considered
	// alerts.
	Alerting pulumi.BoolPtrInput
	// Output only. The timestamp when the rule deployment archive state was last set to true. If the rule deployment's current archive state is not set to true, the field will be empty.
	ArchiveTime pulumi.StringPtrInput
	// The archive state of the rule deployment.
	// Cannot be set to true unless enabled is set to false i.e.
	// archiving requires a two-step process: first, disable the rule by
	// setting 'enabled' to false, then set 'archive' to true.
	// If set to true, alerting will automatically be set to false.
	// If currently set to true, enabled, alerting, and runFrequency cannot be
	// updated.
	Archived pulumi.BoolPtrInput
	// Output only. The names of the associated/chained consumer rules. Rules are considered
	// consumers of this rule if their rule text explicitly filters on this rule's ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ConsumerRules pulumi.StringArrayInput
	// Whether the rule is currently deployed continuously against incoming data.
	Enabled pulumi.BoolPtrInput
	// The execution state of the rule deployment.
	// Possible values:
	// DEFAULT
	// LIMITED
	// PAUSED
	ExecutionState pulumi.StringPtrInput
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	Instance pulumi.StringPtrInput
	// Output only. The timestamp when the rule deployment alert state was lastly changed. This is filled regardless of the current alert state.E.g. if the current alert status is false, this timestamp will be the timestamp when the alert status was changed to false.
	LastAlertStatusChangeTime pulumi.StringPtrInput
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringPtrInput
	// The resource name of the rule deployment.
	// Note that RuleDeployment is a child of the overall Rule, not any individual
	// revision, so the resource ID segment for the Rule resource must not
	// reference a specific revision.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}/deployment
	Name pulumi.StringPtrInput
	// Output only. The names of the associated/chained producer rules. Rules are considered
	// producers for this rule if this rule explicitly filters on their ruleid.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	ProducerRules pulumi.StringArrayInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The Rule ID of the rule.
	Rule pulumi.StringPtrInput
	// The run frequency of the rule deployment.
	// Possible values:
	// LIVE
	// HOURLY
	// DAILY
	RunFrequency pulumi.StringPtrInput
}

func (RuleDeploymentState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleDeploymentState)(nil)).Elem()
}

type ruleDeploymentArgs struct {
	// Whether detections resulting from this deployment should be considered
	// alerts.
	Alerting *bool `pulumi:"alerting"`
	// The archive state of the rule deployment.
	// Cannot be set to true unless enabled is set to false i.e.
	// archiving requires a two-step process: first, disable the rule by
	// setting 'enabled' to false, then set 'archive' to true.
	// If set to true, alerting will automatically be set to false.
	// If currently set to true, enabled, alerting, and runFrequency cannot be
	// updated.
	Archived *bool `pulumi:"archived"`
	// Whether the rule is currently deployed continuously against incoming data.
	Enabled *bool `pulumi:"enabled"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	Instance string `pulumi:"instance"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location string `pulumi:"location"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The Rule ID of the rule.
	Rule string `pulumi:"rule"`
	// The run frequency of the rule deployment.
	// Possible values:
	// LIVE
	// HOURLY
	// DAILY
	RunFrequency *string `pulumi:"runFrequency"`
}

// The set of arguments for constructing a RuleDeployment resource.
type RuleDeploymentArgs struct {
	// Whether detections resulting from this deployment should be considered
	// alerts.
	Alerting pulumi.BoolPtrInput
	// The archive state of the rule deployment.
	// Cannot be set to true unless enabled is set to false i.e.
	// archiving requires a two-step process: first, disable the rule by
	// setting 'enabled' to false, then set 'archive' to true.
	// If set to true, alerting will automatically be set to false.
	// If currently set to true, enabled, alerting, and runFrequency cannot be
	// updated.
	Archived pulumi.BoolPtrInput
	// Whether the rule is currently deployed continuously against incoming data.
	Enabled pulumi.BoolPtrInput
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	Instance pulumi.StringInput
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The Rule ID of the rule.
	Rule pulumi.StringInput
	// The run frequency of the rule deployment.
	// Possible values:
	// LIVE
	// HOURLY
	// DAILY
	RunFrequency pulumi.StringPtrInput
}

func (RuleDeploymentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleDeploymentArgs)(nil)).Elem()
}

type RuleDeploymentInput interface {
	pulumi.Input

	ToRuleDeploymentOutput() RuleDeploymentOutput
	ToRuleDeploymentOutputWithContext(ctx context.Context) RuleDeploymentOutput
}

func (*RuleDeployment) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleDeployment)(nil)).Elem()
}

func (i *RuleDeployment) ToRuleDeploymentOutput() RuleDeploymentOutput {
	return i.ToRuleDeploymentOutputWithContext(context.Background())
}

func (i *RuleDeployment) ToRuleDeploymentOutputWithContext(ctx context.Context) RuleDeploymentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleDeploymentOutput)
}

// RuleDeploymentArrayInput is an input type that accepts RuleDeploymentArray and RuleDeploymentArrayOutput values.
// You can construct a concrete instance of `RuleDeploymentArrayInput` via:
//
//	RuleDeploymentArray{ RuleDeploymentArgs{...} }
type RuleDeploymentArrayInput interface {
	pulumi.Input

	ToRuleDeploymentArrayOutput() RuleDeploymentArrayOutput
	ToRuleDeploymentArrayOutputWithContext(context.Context) RuleDeploymentArrayOutput
}

type RuleDeploymentArray []RuleDeploymentInput

func (RuleDeploymentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleDeployment)(nil)).Elem()
}

func (i RuleDeploymentArray) ToRuleDeploymentArrayOutput() RuleDeploymentArrayOutput {
	return i.ToRuleDeploymentArrayOutputWithContext(context.Background())
}

func (i RuleDeploymentArray) ToRuleDeploymentArrayOutputWithContext(ctx context.Context) RuleDeploymentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleDeploymentArrayOutput)
}

// RuleDeploymentMapInput is an input type that accepts RuleDeploymentMap and RuleDeploymentMapOutput values.
// You can construct a concrete instance of `RuleDeploymentMapInput` via:
//
//	RuleDeploymentMap{ "key": RuleDeploymentArgs{...} }
type RuleDeploymentMapInput interface {
	pulumi.Input

	ToRuleDeploymentMapOutput() RuleDeploymentMapOutput
	ToRuleDeploymentMapOutputWithContext(context.Context) RuleDeploymentMapOutput
}

type RuleDeploymentMap map[string]RuleDeploymentInput

func (RuleDeploymentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleDeployment)(nil)).Elem()
}

func (i RuleDeploymentMap) ToRuleDeploymentMapOutput() RuleDeploymentMapOutput {
	return i.ToRuleDeploymentMapOutputWithContext(context.Background())
}

func (i RuleDeploymentMap) ToRuleDeploymentMapOutputWithContext(ctx context.Context) RuleDeploymentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleDeploymentMapOutput)
}

type RuleDeploymentOutput struct{ *pulumi.OutputState }

func (RuleDeploymentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleDeployment)(nil)).Elem()
}

func (o RuleDeploymentOutput) ToRuleDeploymentOutput() RuleDeploymentOutput {
	return o
}

func (o RuleDeploymentOutput) ToRuleDeploymentOutputWithContext(ctx context.Context) RuleDeploymentOutput {
	return o
}

// Whether detections resulting from this deployment should be considered
// alerts.
func (o RuleDeploymentOutput) Alerting() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.BoolPtrOutput { return v.Alerting }).(pulumi.BoolPtrOutput)
}

// Output only. The timestamp when the rule deployment archive state was last set to true. If the rule deployment's current archive state is not set to true, the field will be empty.
func (o RuleDeploymentOutput) ArchiveTime() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.ArchiveTime }).(pulumi.StringOutput)
}

// The archive state of the rule deployment.
// Cannot be set to true unless enabled is set to false i.e.
// archiving requires a two-step process: first, disable the rule by
// setting 'enabled' to false, then set 'archive' to true.
// If set to true, alerting will automatically be set to false.
// If currently set to true, enabled, alerting, and runFrequency cannot be
// updated.
func (o RuleDeploymentOutput) Archived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.BoolPtrOutput { return v.Archived }).(pulumi.BoolPtrOutput)
}

// Output only. The names of the associated/chained consumer rules. Rules are considered
// consumers of this rule if their rule text explicitly filters on this rule's ruleid.
// Format:
// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
func (o RuleDeploymentOutput) ConsumerRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringArrayOutput { return v.ConsumerRules }).(pulumi.StringArrayOutput)
}

// Whether the rule is currently deployed continuously against incoming data.
func (o RuleDeploymentOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// The execution state of the rule deployment.
// Possible values:
// DEFAULT
// LIMITED
// PAUSED
func (o RuleDeploymentOutput) ExecutionState() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.ExecutionState }).(pulumi.StringOutput)
}

// The unique identifier for the Chronicle instance, which is the same as the customer ID.
func (o RuleDeploymentOutput) Instance() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.Instance }).(pulumi.StringOutput)
}

// Output only. The timestamp when the rule deployment alert state was lastly changed. This is filled regardless of the current alert state.E.g. if the current alert status is false, this timestamp will be the timestamp when the alert status was changed to false.
func (o RuleDeploymentOutput) LastAlertStatusChangeTime() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.LastAlertStatusChangeTime }).(pulumi.StringOutput)
}

// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
func (o RuleDeploymentOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The resource name of the rule deployment.
// Note that RuleDeployment is a child of the overall Rule, not any individual
// revision, so the resource ID segment for the Rule resource must not
// reference a specific revision.
// Format:
// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}/deployment
func (o RuleDeploymentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Output only. The names of the associated/chained producer rules. Rules are considered
// producers for this rule if this rule explicitly filters on their ruleid.
// Format:
// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
func (o RuleDeploymentOutput) ProducerRules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringArrayOutput { return v.ProducerRules }).(pulumi.StringArrayOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o RuleDeploymentOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The Rule ID of the rule.
func (o RuleDeploymentOutput) Rule() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringOutput { return v.Rule }).(pulumi.StringOutput)
}

// The run frequency of the rule deployment.
// Possible values:
// LIVE
// HOURLY
// DAILY
func (o RuleDeploymentOutput) RunFrequency() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleDeployment) pulumi.StringPtrOutput { return v.RunFrequency }).(pulumi.StringPtrOutput)
}

type RuleDeploymentArrayOutput struct{ *pulumi.OutputState }

func (RuleDeploymentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleDeployment)(nil)).Elem()
}

func (o RuleDeploymentArrayOutput) ToRuleDeploymentArrayOutput() RuleDeploymentArrayOutput {
	return o
}

func (o RuleDeploymentArrayOutput) ToRuleDeploymentArrayOutputWithContext(ctx context.Context) RuleDeploymentArrayOutput {
	return o
}

func (o RuleDeploymentArrayOutput) Index(i pulumi.IntInput) RuleDeploymentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RuleDeployment {
		return vs[0].([]*RuleDeployment)[vs[1].(int)]
	}).(RuleDeploymentOutput)
}

type RuleDeploymentMapOutput struct{ *pulumi.OutputState }

func (RuleDeploymentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleDeployment)(nil)).Elem()
}

func (o RuleDeploymentMapOutput) ToRuleDeploymentMapOutput() RuleDeploymentMapOutput {
	return o
}

func (o RuleDeploymentMapOutput) ToRuleDeploymentMapOutputWithContext(ctx context.Context) RuleDeploymentMapOutput {
	return o
}

func (o RuleDeploymentMapOutput) MapIndex(k pulumi.StringInput) RuleDeploymentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RuleDeployment {
		return vs[0].(map[string]*RuleDeployment)[vs[1].(string)]
	}).(RuleDeploymentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RuleDeploymentInput)(nil)).Elem(), &RuleDeployment{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleDeploymentArrayInput)(nil)).Elem(), RuleDeploymentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleDeploymentMapInput)(nil)).Elem(), RuleDeploymentMap{})
	pulumi.RegisterOutputType(RuleDeploymentOutput{})
	pulumi.RegisterOutputType(RuleDeploymentArrayOutput{})
	pulumi.RegisterOutputType(RuleDeploymentMapOutput{})
}
