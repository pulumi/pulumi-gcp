// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package chronicle

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Chronicle Rule Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/chronicle"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := chronicle.NewRule(ctx, "example", &chronicle.RuleArgs{
//				Location:       pulumi.String("us"),
//				Instance:       pulumi.String("00000000-0000-0000-0000-000000000000"),
//				DeletionPolicy: pulumi.String("DEFAULT"),
//				Text:           pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Chronicle Rule With Force Deletion
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/chronicle"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := chronicle.NewRule(ctx, "example", &chronicle.RuleArgs{
//				Location:       pulumi.String("us"),
//				Instance:       pulumi.String("00000000-0000-0000-0000-000000000000"),
//				DeletionPolicy: pulumi.String("FORCE"),
//				Text:           pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Chronicle Rule With Data Access Scope
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/chronicle"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := chronicle.NewDataAccessScope(ctx, "data_access_scope_test", &chronicle.DataAccessScopeArgs{
//				Location:          pulumi.String("us"),
//				Instance:          pulumi.String("00000000-0000-0000-0000-000000000000"),
//				DataAccessScopeId: pulumi.String("scope-name"),
//				Description:       pulumi.String("scope-description"),
//				AllowedDataAccessLabels: chronicle.DataAccessScopeAllowedDataAccessLabelArray{
//					&chronicle.DataAccessScopeAllowedDataAccessLabelArgs{
//						LogType: pulumi.String("GCP_CLOUDAUDIT"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = chronicle.NewRule(ctx, "example", &chronicle.RuleArgs{
//				Location: pulumi.String("us"),
//				Instance: pulumi.String("00000000-0000-0000-0000-000000000000"),
//				Scope:    pulumi.Any(googleChronicleDataAccessScope.DataAccessScopeTest.Name),
//				Text:     pulumi.String("rule test_rule { meta: events:  $userid = $e.principal.user.userid  match: $userid over 10m condition: $e }\n"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Rule can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule_id}}`
//
// * `{{project}}/{{location}}/{{instance}}/{{rule_id}}`
//
// * `{{location}}/{{instance}}/{{rule_id}}`
//
// When using the `pulumi import` command, Rule can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:chronicle/rule:Rule default projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule_id}}
// ```
//
// ```sh
// $ pulumi import gcp:chronicle/rule:Rule default {{project}}/{{location}}/{{instance}}/{{rule_id}}
// ```
//
// ```sh
// $ pulumi import gcp:chronicle/rule:Rule default {{location}}/{{instance}}/{{rule_id}}
// ```
type Rule struct {
	pulumi.CustomResourceState

	// Output only. The run frequencies that are allowed for the rule.
	// Populated in BASIC view and FULL view.
	AllowedRunFrequencies pulumi.StringArrayOutput `pulumi:"allowedRunFrequencies"`
	// Output only. The author of the rule. Extracted from the meta section of text.
	// Populated in BASIC view and FULL view.
	Author pulumi.StringOutput `pulumi:"author"`
	// Output only. A list of a rule's corresponding compilation diagnostic messages
	// such as compilation errors and compilation warnings.
	// Populated in FULL view.
	// Structure is documented below.
	CompilationDiagnostics RuleCompilationDiagnosticArrayOutput `pulumi:"compilationDiagnostics"`
	// Output only. The current compilation state of the rule.
	// Populated in FULL view.
	// Possible values:
	// COMPILATION_STATE_UNSPECIFIED
	// SUCCEEDED
	// FAILED
	CompilationState pulumi.StringOutput `pulumi:"compilationState"`
	// Output only. The timestamp of when the rule was created.
	// Populated in FULL view.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// Output only. Resource names of the data tables used in this rule.
	DataTables pulumi.StringArrayOutput `pulumi:"dataTables"`
	// Policy to determine if the rule should be deleted forcefully.
	// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
	// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
	// rule has no associated retrohunts, including completed retrohunts, and no
	// associated detections. Regardless of this field's value, the rule
	// deployment associated with this rule will also be deleted.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrOutput `pulumi:"deletionPolicy"`
	// The display name of the severity level. Extracted from the meta section of
	// the rule text.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// The etag for this rule.
	// If this is provided on update, the request will succeed if and only if it
	// matches the server-computed value, and will fail with an ABORTED error
	// otherwise.
	// Populated in BASIC view and FULL view.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	//
	// ***
	Instance pulumi.StringOutput `pulumi:"instance"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringOutput `pulumi:"location"`
	// Output only. Additional metadata specified in the meta section of text.
	// Populated in FULL view.
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// Full resource name for the rule. This unique identifier is generated using values provided for the URL parameters.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	Name pulumi.StringOutput `pulumi:"name"`
	// Output only. Indicate the rule can run in near real time live rule.
	// If this is true, the rule uses the near real time live rule when the run
	// frequency is set to LIVE.
	NearRealTimeLiveRuleEligible pulumi.BoolOutput `pulumi:"nearRealTimeLiveRuleEligible"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// Output only. Resource names of the reference lists used in this rule.
	// Populated in FULL view.
	ReferenceLists pulumi.StringArrayOutput `pulumi:"referenceLists"`
	// Output only. The timestamp of when the rule revision was created.
	// Populated in FULL, REVISION_METADATA_ONLY views.
	RevisionCreateTime pulumi.StringOutput `pulumi:"revisionCreateTime"`
	// Output only. The revision ID of the rule.
	// A new revision is created whenever the rule text is changed in any way.
	// Format: v_{10 digits}_{9 digits}
	// Populated in REVISION_METADATA_ONLY view and FULL view.
	RevisionId pulumi.StringOutput `pulumi:"revisionId"`
	// Rule Id is the ID of the Rule.
	RuleId pulumi.StringOutput `pulumi:"ruleId"`
	// Resource name of the DataAccessScope bound to this rule.
	// Populated in BASIC view and FULL view.
	// If reference lists are used in the rule, validations will be performed
	// against this scope to ensure that the reference lists are compatible with
	// both the user's and the rule's scopes.
	// The scope should be in the format:
	// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// (Output)
	// Output only. The severity of a rule's compilation diagnostic.
	// Possible values:
	// SEVERITY_UNSPECIFIED
	// WARNING
	// ERROR
	Severities RuleSeverityArrayOutput `pulumi:"severities"`
	// The YARA-L content of the rule.
	// Populated in FULL view.
	Text pulumi.StringPtrOutput `pulumi:"text"`
	// Possible values:
	// RULE_TYPE_UNSPECIFIED
	// SINGLE_EVENT
	// MULTI_EVENT
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewRule registers a new resource with the given unique name, arguments, and options.
func NewRule(ctx *pulumi.Context,
	name string, args *RuleArgs, opts ...pulumi.ResourceOption) (*Rule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Instance == nil {
		return nil, errors.New("invalid value for required argument 'Instance'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Rule
	err := ctx.RegisterResource("gcp:chronicle/rule:Rule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRule gets an existing Rule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleState, opts ...pulumi.ResourceOption) (*Rule, error) {
	var resource Rule
	err := ctx.ReadResource("gcp:chronicle/rule:Rule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Rule resources.
type ruleState struct {
	// Output only. The run frequencies that are allowed for the rule.
	// Populated in BASIC view and FULL view.
	AllowedRunFrequencies []string `pulumi:"allowedRunFrequencies"`
	// Output only. The author of the rule. Extracted from the meta section of text.
	// Populated in BASIC view and FULL view.
	Author *string `pulumi:"author"`
	// Output only. A list of a rule's corresponding compilation diagnostic messages
	// such as compilation errors and compilation warnings.
	// Populated in FULL view.
	// Structure is documented below.
	CompilationDiagnostics []RuleCompilationDiagnostic `pulumi:"compilationDiagnostics"`
	// Output only. The current compilation state of the rule.
	// Populated in FULL view.
	// Possible values:
	// COMPILATION_STATE_UNSPECIFIED
	// SUCCEEDED
	// FAILED
	CompilationState *string `pulumi:"compilationState"`
	// Output only. The timestamp of when the rule was created.
	// Populated in FULL view.
	CreateTime *string `pulumi:"createTime"`
	// Output only. Resource names of the data tables used in this rule.
	DataTables []string `pulumi:"dataTables"`
	// Policy to determine if the rule should be deleted forcefully.
	// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
	// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
	// rule has no associated retrohunts, including completed retrohunts, and no
	// associated detections. Regardless of this field's value, the rule
	// deployment associated with this rule will also be deleted.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy *string `pulumi:"deletionPolicy"`
	// The display name of the severity level. Extracted from the meta section of
	// the rule text.
	DisplayName *string `pulumi:"displayName"`
	// The etag for this rule.
	// If this is provided on update, the request will succeed if and only if it
	// matches the server-computed value, and will fail with an ABORTED error
	// otherwise.
	// Populated in BASIC view and FULL view.
	Etag *string `pulumi:"etag"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	//
	// ***
	Instance *string `pulumi:"instance"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location *string `pulumi:"location"`
	// Output only. Additional metadata specified in the meta section of text.
	// Populated in FULL view.
	Metadata map[string]string `pulumi:"metadata"`
	// Full resource name for the rule. This unique identifier is generated using values provided for the URL parameters.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	Name *string `pulumi:"name"`
	// Output only. Indicate the rule can run in near real time live rule.
	// If this is true, the rule uses the near real time live rule when the run
	// frequency is set to LIVE.
	NearRealTimeLiveRuleEligible *bool `pulumi:"nearRealTimeLiveRuleEligible"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Output only. Resource names of the reference lists used in this rule.
	// Populated in FULL view.
	ReferenceLists []string `pulumi:"referenceLists"`
	// Output only. The timestamp of when the rule revision was created.
	// Populated in FULL, REVISION_METADATA_ONLY views.
	RevisionCreateTime *string `pulumi:"revisionCreateTime"`
	// Output only. The revision ID of the rule.
	// A new revision is created whenever the rule text is changed in any way.
	// Format: v_{10 digits}_{9 digits}
	// Populated in REVISION_METADATA_ONLY view and FULL view.
	RevisionId *string `pulumi:"revisionId"`
	// Rule Id is the ID of the Rule.
	RuleId *string `pulumi:"ruleId"`
	// Resource name of the DataAccessScope bound to this rule.
	// Populated in BASIC view and FULL view.
	// If reference lists are used in the rule, validations will be performed
	// against this scope to ensure that the reference lists are compatible with
	// both the user's and the rule's scopes.
	// The scope should be in the format:
	// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
	Scope *string `pulumi:"scope"`
	// (Output)
	// Output only. The severity of a rule's compilation diagnostic.
	// Possible values:
	// SEVERITY_UNSPECIFIED
	// WARNING
	// ERROR
	Severities []RuleSeverity `pulumi:"severities"`
	// The YARA-L content of the rule.
	// Populated in FULL view.
	Text *string `pulumi:"text"`
	// Possible values:
	// RULE_TYPE_UNSPECIFIED
	// SINGLE_EVENT
	// MULTI_EVENT
	Type *string `pulumi:"type"`
}

type RuleState struct {
	// Output only. The run frequencies that are allowed for the rule.
	// Populated in BASIC view and FULL view.
	AllowedRunFrequencies pulumi.StringArrayInput
	// Output only. The author of the rule. Extracted from the meta section of text.
	// Populated in BASIC view and FULL view.
	Author pulumi.StringPtrInput
	// Output only. A list of a rule's corresponding compilation diagnostic messages
	// such as compilation errors and compilation warnings.
	// Populated in FULL view.
	// Structure is documented below.
	CompilationDiagnostics RuleCompilationDiagnosticArrayInput
	// Output only. The current compilation state of the rule.
	// Populated in FULL view.
	// Possible values:
	// COMPILATION_STATE_UNSPECIFIED
	// SUCCEEDED
	// FAILED
	CompilationState pulumi.StringPtrInput
	// Output only. The timestamp of when the rule was created.
	// Populated in FULL view.
	CreateTime pulumi.StringPtrInput
	// Output only. Resource names of the data tables used in this rule.
	DataTables pulumi.StringArrayInput
	// Policy to determine if the rule should be deleted forcefully.
	// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
	// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
	// rule has no associated retrohunts, including completed retrohunts, and no
	// associated detections. Regardless of this field's value, the rule
	// deployment associated with this rule will also be deleted.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrInput
	// The display name of the severity level. Extracted from the meta section of
	// the rule text.
	DisplayName pulumi.StringPtrInput
	// The etag for this rule.
	// If this is provided on update, the request will succeed if and only if it
	// matches the server-computed value, and will fail with an ABORTED error
	// otherwise.
	// Populated in BASIC view and FULL view.
	Etag pulumi.StringPtrInput
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	//
	// ***
	Instance pulumi.StringPtrInput
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringPtrInput
	// Output only. Additional metadata specified in the meta section of text.
	// Populated in FULL view.
	Metadata pulumi.StringMapInput
	// Full resource name for the rule. This unique identifier is generated using values provided for the URL parameters.
	// Format:
	// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
	Name pulumi.StringPtrInput
	// Output only. Indicate the rule can run in near real time live rule.
	// If this is true, the rule uses the near real time live rule when the run
	// frequency is set to LIVE.
	NearRealTimeLiveRuleEligible pulumi.BoolPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Output only. Resource names of the reference lists used in this rule.
	// Populated in FULL view.
	ReferenceLists pulumi.StringArrayInput
	// Output only. The timestamp of when the rule revision was created.
	// Populated in FULL, REVISION_METADATA_ONLY views.
	RevisionCreateTime pulumi.StringPtrInput
	// Output only. The revision ID of the rule.
	// A new revision is created whenever the rule text is changed in any way.
	// Format: v_{10 digits}_{9 digits}
	// Populated in REVISION_METADATA_ONLY view and FULL view.
	RevisionId pulumi.StringPtrInput
	// Rule Id is the ID of the Rule.
	RuleId pulumi.StringPtrInput
	// Resource name of the DataAccessScope bound to this rule.
	// Populated in BASIC view and FULL view.
	// If reference lists are used in the rule, validations will be performed
	// against this scope to ensure that the reference lists are compatible with
	// both the user's and the rule's scopes.
	// The scope should be in the format:
	// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
	Scope pulumi.StringPtrInput
	// (Output)
	// Output only. The severity of a rule's compilation diagnostic.
	// Possible values:
	// SEVERITY_UNSPECIFIED
	// WARNING
	// ERROR
	Severities RuleSeverityArrayInput
	// The YARA-L content of the rule.
	// Populated in FULL view.
	Text pulumi.StringPtrInput
	// Possible values:
	// RULE_TYPE_UNSPECIFIED
	// SINGLE_EVENT
	// MULTI_EVENT
	Type pulumi.StringPtrInput
}

func (RuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleState)(nil)).Elem()
}

type ruleArgs struct {
	// Policy to determine if the rule should be deleted forcefully.
	// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
	// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
	// rule has no associated retrohunts, including completed retrohunts, and no
	// associated detections. Regardless of this field's value, the rule
	// deployment associated with this rule will also be deleted.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy *string `pulumi:"deletionPolicy"`
	// The etag for this rule.
	// If this is provided on update, the request will succeed if and only if it
	// matches the server-computed value, and will fail with an ABORTED error
	// otherwise.
	// Populated in BASIC view and FULL view.
	Etag *string `pulumi:"etag"`
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	//
	// ***
	Instance string `pulumi:"instance"`
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location string `pulumi:"location"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// Rule Id is the ID of the Rule.
	RuleId *string `pulumi:"ruleId"`
	// Resource name of the DataAccessScope bound to this rule.
	// Populated in BASIC view and FULL view.
	// If reference lists are used in the rule, validations will be performed
	// against this scope to ensure that the reference lists are compatible with
	// both the user's and the rule's scopes.
	// The scope should be in the format:
	// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
	Scope *string `pulumi:"scope"`
	// The YARA-L content of the rule.
	// Populated in FULL view.
	Text *string `pulumi:"text"`
}

// The set of arguments for constructing a Rule resource.
type RuleArgs struct {
	// Policy to determine if the rule should be deleted forcefully.
	// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
	// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
	// rule has no associated retrohunts, including completed retrohunts, and no
	// associated detections. Regardless of this field's value, the rule
	// deployment associated with this rule will also be deleted.
	// Possible values: DEFAULT, FORCE
	DeletionPolicy pulumi.StringPtrInput
	// The etag for this rule.
	// If this is provided on update, the request will succeed if and only if it
	// matches the server-computed value, and will fail with an ABORTED error
	// otherwise.
	// Populated in BASIC view and FULL view.
	Etag pulumi.StringPtrInput
	// The unique identifier for the Chronicle instance, which is the same as the customer ID.
	//
	// ***
	Instance pulumi.StringInput
	// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
	Location pulumi.StringInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// Rule Id is the ID of the Rule.
	RuleId pulumi.StringPtrInput
	// Resource name of the DataAccessScope bound to this rule.
	// Populated in BASIC view and FULL view.
	// If reference lists are used in the rule, validations will be performed
	// against this scope to ensure that the reference lists are compatible with
	// both the user's and the rule's scopes.
	// The scope should be in the format:
	// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
	Scope pulumi.StringPtrInput
	// The YARA-L content of the rule.
	// Populated in FULL view.
	Text pulumi.StringPtrInput
}

func (RuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleArgs)(nil)).Elem()
}

type RuleInput interface {
	pulumi.Input

	ToRuleOutput() RuleOutput
	ToRuleOutputWithContext(ctx context.Context) RuleOutput
}

func (*Rule) ElementType() reflect.Type {
	return reflect.TypeOf((**Rule)(nil)).Elem()
}

func (i *Rule) ToRuleOutput() RuleOutput {
	return i.ToRuleOutputWithContext(context.Background())
}

func (i *Rule) ToRuleOutputWithContext(ctx context.Context) RuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleOutput)
}

// RuleArrayInput is an input type that accepts RuleArray and RuleArrayOutput values.
// You can construct a concrete instance of `RuleArrayInput` via:
//
//	RuleArray{ RuleArgs{...} }
type RuleArrayInput interface {
	pulumi.Input

	ToRuleArrayOutput() RuleArrayOutput
	ToRuleArrayOutputWithContext(context.Context) RuleArrayOutput
}

type RuleArray []RuleInput

func (RuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rule)(nil)).Elem()
}

func (i RuleArray) ToRuleArrayOutput() RuleArrayOutput {
	return i.ToRuleArrayOutputWithContext(context.Background())
}

func (i RuleArray) ToRuleArrayOutputWithContext(ctx context.Context) RuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleArrayOutput)
}

// RuleMapInput is an input type that accepts RuleMap and RuleMapOutput values.
// You can construct a concrete instance of `RuleMapInput` via:
//
//	RuleMap{ "key": RuleArgs{...} }
type RuleMapInput interface {
	pulumi.Input

	ToRuleMapOutput() RuleMapOutput
	ToRuleMapOutputWithContext(context.Context) RuleMapOutput
}

type RuleMap map[string]RuleInput

func (RuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rule)(nil)).Elem()
}

func (i RuleMap) ToRuleMapOutput() RuleMapOutput {
	return i.ToRuleMapOutputWithContext(context.Background())
}

func (i RuleMap) ToRuleMapOutputWithContext(ctx context.Context) RuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleMapOutput)
}

type RuleOutput struct{ *pulumi.OutputState }

func (RuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Rule)(nil)).Elem()
}

func (o RuleOutput) ToRuleOutput() RuleOutput {
	return o
}

func (o RuleOutput) ToRuleOutputWithContext(ctx context.Context) RuleOutput {
	return o
}

// Output only. The run frequencies that are allowed for the rule.
// Populated in BASIC view and FULL view.
func (o RuleOutput) AllowedRunFrequencies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringArrayOutput { return v.AllowedRunFrequencies }).(pulumi.StringArrayOutput)
}

// Output only. The author of the rule. Extracted from the meta section of text.
// Populated in BASIC view and FULL view.
func (o RuleOutput) Author() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Author }).(pulumi.StringOutput)
}

// Output only. A list of a rule's corresponding compilation diagnostic messages
// such as compilation errors and compilation warnings.
// Populated in FULL view.
// Structure is documented below.
func (o RuleOutput) CompilationDiagnostics() RuleCompilationDiagnosticArrayOutput {
	return o.ApplyT(func(v *Rule) RuleCompilationDiagnosticArrayOutput { return v.CompilationDiagnostics }).(RuleCompilationDiagnosticArrayOutput)
}

// Output only. The current compilation state of the rule.
// Populated in FULL view.
// Possible values:
// COMPILATION_STATE_UNSPECIFIED
// SUCCEEDED
// FAILED
func (o RuleOutput) CompilationState() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.CompilationState }).(pulumi.StringOutput)
}

// Output only. The timestamp of when the rule was created.
// Populated in FULL view.
func (o RuleOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// Output only. Resource names of the data tables used in this rule.
func (o RuleOutput) DataTables() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringArrayOutput { return v.DataTables }).(pulumi.StringArrayOutput)
}

// Policy to determine if the rule should be deleted forcefully.
// If deletionPolicy = "FORCE", any retrohunts and any detections associated with the rule
// will also be deleted. If deletionPolicy = "DEFAULT", the call will only succeed if the
// rule has no associated retrohunts, including completed retrohunts, and no
// associated detections. Regardless of this field's value, the rule
// deployment associated with this rule will also be deleted.
// Possible values: DEFAULT, FORCE
func (o RuleOutput) DeletionPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringPtrOutput { return v.DeletionPolicy }).(pulumi.StringPtrOutput)
}

// The display name of the severity level. Extracted from the meta section of
// the rule text.
func (o RuleOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// The etag for this rule.
// If this is provided on update, the request will succeed if and only if it
// matches the server-computed value, and will fail with an ABORTED error
// otherwise.
// Populated in BASIC view and FULL view.
func (o RuleOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Etag }).(pulumi.StringOutput)
}

// The unique identifier for the Chronicle instance, which is the same as the customer ID.
//
// ***
func (o RuleOutput) Instance() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Instance }).(pulumi.StringOutput)
}

// The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".
func (o RuleOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// Output only. Additional metadata specified in the meta section of text.
// Populated in FULL view.
func (o RuleOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// Full resource name for the rule. This unique identifier is generated using values provided for the URL parameters.
// Format:
// projects/{project}/locations/{location}/instances/{instance}/rules/{rule}
func (o RuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Output only. Indicate the rule can run in near real time live rule.
// If this is true, the rule uses the near real time live rule when the run
// frequency is set to LIVE.
func (o RuleOutput) NearRealTimeLiveRuleEligible() pulumi.BoolOutput {
	return o.ApplyT(func(v *Rule) pulumi.BoolOutput { return v.NearRealTimeLiveRuleEligible }).(pulumi.BoolOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o RuleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Output only. Resource names of the reference lists used in this rule.
// Populated in FULL view.
func (o RuleOutput) ReferenceLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringArrayOutput { return v.ReferenceLists }).(pulumi.StringArrayOutput)
}

// Output only. The timestamp of when the rule revision was created.
// Populated in FULL, REVISION_METADATA_ONLY views.
func (o RuleOutput) RevisionCreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.RevisionCreateTime }).(pulumi.StringOutput)
}

// Output only. The revision ID of the rule.
// A new revision is created whenever the rule text is changed in any way.
// Format: v_{10 digits}_{9 digits}
// Populated in REVISION_METADATA_ONLY view and FULL view.
func (o RuleOutput) RevisionId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.RevisionId }).(pulumi.StringOutput)
}

// Rule Id is the ID of the Rule.
func (o RuleOutput) RuleId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.RuleId }).(pulumi.StringOutput)
}

// Resource name of the DataAccessScope bound to this rule.
// Populated in BASIC view and FULL view.
// If reference lists are used in the rule, validations will be performed
// against this scope to ensure that the reference lists are compatible with
// both the user's and the rule's scopes.
// The scope should be in the format:
// "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope}".
func (o RuleOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// (Output)
// Output only. The severity of a rule's compilation diagnostic.
// Possible values:
// SEVERITY_UNSPECIFIED
// WARNING
// ERROR
func (o RuleOutput) Severities() RuleSeverityArrayOutput {
	return o.ApplyT(func(v *Rule) RuleSeverityArrayOutput { return v.Severities }).(RuleSeverityArrayOutput)
}

// The YARA-L content of the rule.
// Populated in FULL view.
func (o RuleOutput) Text() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringPtrOutput { return v.Text }).(pulumi.StringPtrOutput)
}

// Possible values:
// RULE_TYPE_UNSPECIFIED
// SINGLE_EVENT
// MULTI_EVENT
func (o RuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type RuleArrayOutput struct{ *pulumi.OutputState }

func (RuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rule)(nil)).Elem()
}

func (o RuleArrayOutput) ToRuleArrayOutput() RuleArrayOutput {
	return o
}

func (o RuleArrayOutput) ToRuleArrayOutputWithContext(ctx context.Context) RuleArrayOutput {
	return o
}

func (o RuleArrayOutput) Index(i pulumi.IntInput) RuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Rule {
		return vs[0].([]*Rule)[vs[1].(int)]
	}).(RuleOutput)
}

type RuleMapOutput struct{ *pulumi.OutputState }

func (RuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rule)(nil)).Elem()
}

func (o RuleMapOutput) ToRuleMapOutput() RuleMapOutput {
	return o
}

func (o RuleMapOutput) ToRuleMapOutputWithContext(ctx context.Context) RuleMapOutput {
	return o
}

func (o RuleMapOutput) MapIndex(k pulumi.StringInput) RuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Rule {
		return vs[0].(map[string]*Rule)[vs[1].(string)]
	}).(RuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RuleInput)(nil)).Elem(), &Rule{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleArrayInput)(nil)).Elem(), RuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleMapInput)(nil)).Elem(), RuleMap{})
	pulumi.RegisterOutputType(RuleOutput{})
	pulumi.RegisterOutputType(RuleArrayOutput{})
	pulumi.RegisterOutputType(RuleMapOutput{})
}
