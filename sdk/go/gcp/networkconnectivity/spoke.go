// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkconnectivity

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The NetworkConnectivity Spoke resource
//
// To get more information about Spoke, see:
//
// * [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1/projects.locations.spokes)
// * How-to Guides
//   - [Official Documentation](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/overview)
//
// ## Example Usage
//
// ### Network Connectivity Spoke Linked Vpc Network Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("net"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("hub1"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("spoke1"),
//				Location:    pulumi.String("global"),
//				Description: pulumi.String("A sample spoke with a linked router appliance instance"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
//					ExcludeExportRanges: pulumi.StringArray{
//						pulumi.String("198.51.100.0/24"),
//						pulumi.String("10.10.0.0/16"),
//					},
//					IncludeExportRanges: pulumi.StringArray{
//						pulumi.String("198.51.100.0/23"),
//						pulumi.String("10.0.0.0/8"),
//					},
//					Uri: network.SelfLink,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Linked Vpc Network Group
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("net-spoke"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("hub1-spoke"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			defaultGroup, err := networkconnectivity.NewGroup(ctx, "default_group", &networkconnectivity.GroupArgs{
//				Hub:         basicHub.ID(),
//				Name:        pulumi.String("default"),
//				Description: pulumi.String("A sample hub group"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("group-spoke1"),
//				Location:    pulumi.String("global"),
//				Description: pulumi.String("A sample spoke with a linked VPC"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
//					ExcludeExportRanges: pulumi.StringArray{
//						pulumi.String("198.51.100.0/24"),
//						pulumi.String("10.10.0.0/16"),
//					},
//					IncludeExportRanges: pulumi.StringArray{
//						pulumi.String("198.51.100.0/23"),
//						pulumi.String("10.0.0.0/8"),
//					},
//					Uri: network.SelfLink,
//				},
//				Group: defaultGroup.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Router Appliance Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("tf-test-network_44703"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("tf-test-subnet_9329"),
//				IpCidrRange: pulumi.String("10.0.0.0/28"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.SelfLink,
//			})
//			if err != nil {
//				return err
//			}
//			instance, err := compute.NewInstance(ctx, "instance", &compute.InstanceArgs{
//				Name:         pulumi.String("tf-test-instance_37135"),
//				MachineType:  pulumi.String("e2-medium"),
//				CanIpForward: pulumi.Bool(true),
//				Zone:         pulumi.String("us-central1-a"),
//				BootDisk: &compute.InstanceBootDiskArgs{
//					InitializeParams: &compute.InstanceBootDiskInitializeParamsArgs{
//						Image: pulumi.String("projects/debian-cloud/global/images/debian-10-buster-v20210817"),
//					},
//				},
//				NetworkInterfaces: compute.InstanceNetworkInterfaceArray{
//					&compute.InstanceNetworkInterfaceArgs{
//						Subnetwork: subnetwork.Name,
//						NetworkIp:  pulumi.String("10.0.0.2"),
//						AccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{
//							&compute.InstanceNetworkInterfaceAccessConfigArgs{
//								NetworkTier: pulumi.String("PREMIUM"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("tf-test-hub_42503"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("tf-test-name_9991"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("A sample spoke with a linked routher appliance instance"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedRouterApplianceInstances: &networkconnectivity.SpokeLinkedRouterApplianceInstancesArgs{
//					Instances: networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArray{
//						&networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArgs{
//							VirtualMachine: instance.SelfLink,
//							IpAddress:      pulumi.String("10.0.0.2"),
//						},
//					},
//					SiteToSiteDataTransfer: pulumi.Bool(true),
//					IncludeImportRanges: pulumi.StringArray{
//						pulumi.String("ALL_IPV4_RANGES"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Vpn Tunnel Basic
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("basic-hub1"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("basic-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("basic-subnetwork"),
//				IpCidrRange: pulumi.String("10.0.0.0/28"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.SelfLink,
//			})
//			if err != nil {
//				return err
//			}
//			gateway, err := compute.NewHaVpnGateway(ctx, "gateway", &compute.HaVpnGatewayArgs{
//				Name:    pulumi.String("vpn-gateway"),
//				Network: network.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			externalVpnGw, err := compute.NewExternalVpnGateway(ctx, "external_vpn_gw", &compute.ExternalVpnGatewayArgs{
//				Name:           pulumi.String("external-vpn-gateway"),
//				RedundancyType: pulumi.String("SINGLE_IP_INTERNALLY_REDUNDANT"),
//				Description:    pulumi.String("An externally managed VPN gateway"),
//				Interfaces: compute.ExternalVpnGatewayInterfaceArray{
//					&compute.ExternalVpnGatewayInterfaceArgs{
//						Id:        pulumi.Int(0),
//						IpAddress: pulumi.String("8.8.8.8"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
//				Name:    pulumi.String("external-vpn-gateway"),
//				Region:  pulumi.String("us-central1"),
//				Network: network.Name,
//				Bgp: &compute.RouterBgpArgs{
//					Asn: pulumi.Int(64514),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			tunnel1, err := compute.NewVPNTunnel(ctx, "tunnel1", &compute.VPNTunnelArgs{
//				Name:                         pulumi.String("tunnel1"),
//				Region:                       pulumi.String("us-central1"),
//				VpnGateway:                   gateway.ID(),
//				PeerExternalGateway:          externalVpnGw.ID(),
//				PeerExternalGatewayInterface: pulumi.Int(0),
//				SharedSecret:                 pulumi.String("a secret message"),
//				Router:                       router.ID(),
//				VpnGatewayInterface:          pulumi.Int(0),
//			})
//			if err != nil {
//				return err
//			}
//			tunnel2, err := compute.NewVPNTunnel(ctx, "tunnel2", &compute.VPNTunnelArgs{
//				Name:                         pulumi.String("tunnel2"),
//				Region:                       pulumi.String("us-central1"),
//				VpnGateway:                   gateway.ID(),
//				PeerExternalGateway:          externalVpnGw.ID(),
//				PeerExternalGatewayInterface: pulumi.Int(0),
//				SharedSecret:                 pulumi.String("a secret message"),
//				Router: router.ID().ApplyT(func(id string) (string, error) {
//					return fmt.Sprintf(" %v", id), nil
//				}).(pulumi.StringOutput),
//				VpnGatewayInterface: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			routerInterface1, err := compute.NewRouterInterface(ctx, "router_interface1", &compute.RouterInterfaceArgs{
//				Name:      pulumi.String("router-interface1"),
//				Router:    router.Name,
//				Region:    pulumi.String("us-central1"),
//				IpRange:   pulumi.String("169.254.0.1/30"),
//				VpnTunnel: tunnel1.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewRouterPeer(ctx, "router_peer1", &compute.RouterPeerArgs{
//				Name:                    pulumi.String("router-peer1"),
//				Router:                  router.Name,
//				Region:                  pulumi.String("us-central1"),
//				PeerIpAddress:           pulumi.String("169.254.0.2"),
//				PeerAsn:                 pulumi.Int(64515),
//				AdvertisedRoutePriority: pulumi.Int(100),
//				Interface:               routerInterface1.Name,
//			})
//			if err != nil {
//				return err
//			}
//			routerInterface2, err := compute.NewRouterInterface(ctx, "router_interface2", &compute.RouterInterfaceArgs{
//				Name:      pulumi.String("router-interface2"),
//				Router:    router.Name,
//				Region:    pulumi.String("us-central1"),
//				IpRange:   pulumi.String("169.254.1.1/30"),
//				VpnTunnel: tunnel2.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewRouterPeer(ctx, "router_peer2", &compute.RouterPeerArgs{
//				Name:                    pulumi.String("router-peer2"),
//				Router:                  router.Name,
//				Region:                  pulumi.String("us-central1"),
//				PeerIpAddress:           pulumi.String("169.254.1.2"),
//				PeerAsn:                 pulumi.Int(64515),
//				AdvertisedRoutePriority: pulumi.Int(100),
//				Interface:               routerInterface2.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "tunnel1", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("vpn-tunnel-1-spoke"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("A sample spoke with a linked VPN Tunnel"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedVpnTunnels: &networkconnectivity.SpokeLinkedVpnTunnelsArgs{
//					Uris: pulumi.StringArray{
//						tunnel1.SelfLink,
//					},
//					SiteToSiteDataTransfer: pulumi.Bool(true),
//					IncludeImportRanges: pulumi.StringArray{
//						pulumi.String("ALL_IPV4_RANGES"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "tunnel2", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("vpn-tunnel-2-spoke"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("A sample spoke with a linked VPN Tunnel"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedVpnTunnels: &networkconnectivity.SpokeLinkedVpnTunnelsArgs{
//					Uris: pulumi.StringArray{
//						tunnel2.SelfLink,
//					},
//					SiteToSiteDataTransfer: pulumi.Bool(true),
//					IncludeImportRanges: pulumi.StringArray{
//						pulumi.String("ALL_IPV4_RANGES"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Interconnect Attachment Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("basic-hub1"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("basic-network"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
//				Name:    pulumi.String("external-vpn-gateway"),
//				Region:  pulumi.String("us-central1"),
//				Network: network.Name,
//				Bgp: &compute.RouterBgpArgs{
//					Asn: pulumi.Int(16550),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			interconnect_attachment, err := compute.NewInterconnectAttachment(ctx, "interconnect-attachment", &compute.InterconnectAttachmentArgs{
//				Name:                   pulumi.String("partner-interconnect1"),
//				EdgeAvailabilityDomain: pulumi.String("AVAILABILITY_DOMAIN_1"),
//				Type:                   pulumi.String("PARTNER"),
//				Router:                 router.ID(),
//				Mtu:                    pulumi.String("1500"),
//				Region:                 pulumi.String("us-central1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("interconnect-attachment-spoke"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("A sample spoke with a linked Interconnect Attachment"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedInterconnectAttachments: &networkconnectivity.SpokeLinkedInterconnectAttachmentsArgs{
//					Uris: pulumi.StringArray{
//						interconnect_attachment.SelfLink,
//					},
//					SiteToSiteDataTransfer: pulumi.Bool(true),
//					IncludeImportRanges: pulumi.StringArray{
//						pulumi.String("ALL_IPV4_RANGES"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Linked Producer Vpc Network Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/servicenetworking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("net-spoke"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			address, err := compute.NewGlobalAddress(ctx, "address", &compute.GlobalAddressArgs{
//				Name:         pulumi.String("test-address"),
//				Purpose:      pulumi.String("VPC_PEERING"),
//				AddressType:  pulumi.String("INTERNAL"),
//				PrefixLength: pulumi.Int(16),
//				Network:      network.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			peering, err := servicenetworking.NewConnection(ctx, "peering", &servicenetworking.ConnectionArgs{
//				Network: network.ID(),
//				Service: pulumi.String("servicenetworking.googleapis.com"),
//				ReservedPeeringRanges: pulumi.StringArray{
//					address.Name,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name: pulumi.String("hub-basic"),
//			})
//			if err != nil {
//				return err
//			}
//			linkedVpcSpoke, err := networkconnectivity.NewSpoke(ctx, "linked_vpc_spoke", &networkconnectivity.SpokeArgs{
//				Name:     pulumi.String("vpc-spoke"),
//				Location: pulumi.String("global"),
//				Hub:      basicHub.ID(),
//				LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
//					Uri: network.SelfLink,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("producer-spoke"),
//				Location:    pulumi.String("global"),
//				Description: pulumi.String("A sample spoke with a linked router appliance instance"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedProducerVpcNetwork: &networkconnectivity.SpokeLinkedProducerVpcNetworkArgs{
//					Network: network.Name,
//					Peering: peering.Peering,
//					ExcludeExportRanges: pulumi.StringArray{
//						pulumi.String("198.51.100.0/24"),
//						pulumi.String("10.10.0.0/16"),
//					},
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				linkedVpcSpoke,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Center Group
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("tf-net"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			starHub, err := networkconnectivity.NewHub(ctx, "star_hub", &networkconnectivity.HubArgs{
//				Name:           pulumi.String("hub-basic"),
//				PresetTopology: pulumi.String("STAR"),
//			})
//			if err != nil {
//				return err
//			}
//			centerGroup, err := networkconnectivity.NewGroup(ctx, "center_group", &networkconnectivity.GroupArgs{
//				Name: pulumi.String("center"),
//				Hub:  starHub.ID(),
//				AutoAccept: &networkconnectivity.GroupAutoAcceptArgs{
//					AutoAcceptProjects: pulumi.StringArray{
//						pulumi.String("foo_12125"),
//						pulumi.String("bar_82749"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("vpc-spoke"),
//				Location:    pulumi.String("global"),
//				Description: pulumi.String("A sample spoke"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub:   starHub.ID(),
//				Group: centerGroup.ID(),
//				LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
//					Uri: network.SelfLink,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Linked Vpc Network Ipv6 Support
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("net"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("hub1"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("spoke1-ipv6"),
//				Location:    pulumi.String("global"),
//				Description: pulumi.String("A sample spoke with a linked VPC that include export ranges of all IPv6"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
//					IncludeExportRanges: pulumi.StringArray{
//						pulumi.String("ALL_IPV6_RANGES"),
//						pulumi.String("ALL_PRIVATE_IPV4_RANGES"),
//					},
//					Uri: network.SelfLink,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Network Connectivity Spoke Gateway
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/compute"
//	"github.com/pulumi/pulumi-gcp/sdk/v9/go/gcp/networkconnectivity"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
//				Name:                  pulumi.String("net-spoke"),
//				AutoCreateSubnetworks: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
//				Name:        pulumi.String("tf-test-subnet_15022"),
//				IpCidrRange: pulumi.String("10.0.0.0/28"),
//				Region:      pulumi.String("us-central1"),
//				Network:     network.SelfLink,
//			})
//			if err != nil {
//				return err
//			}
//			basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
//				Name:        pulumi.String("hub"),
//				Description: pulumi.String("A sample hub"),
//				Labels: pulumi.StringMap{
//					"label-two": pulumi.String("value-one"),
//				},
//				PresetTopology: pulumi.String("HYBRID_INSPECTION"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
//				Name:        pulumi.String("gateway"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("A sample spoke of type Gateway"),
//				Labels: pulumi.StringMap{
//					"label-one": pulumi.String("value-one"),
//				},
//				Hub: basicHub.ID(),
//				Gateway: &networkconnectivity.SpokeGatewayArgs{
//					IpRangeReservations: networkconnectivity.SpokeGatewayIpRangeReservationArray{
//						&networkconnectivity.SpokeGatewayIpRangeReservationArgs{
//							IpRange: pulumi.String("10.0.0.0/23"),
//						},
//					},
//					Capacity: pulumi.String("CAPACITY_1_GBPS"),
//				},
//				Group: pulumi.String("gateways"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Spoke can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/spokes/{{name}}`
//
// * `{{project}}/{{location}}/{{name}}`
//
// * `{{location}}/{{name}}`
//
// When using the `pulumi import` command, Spoke can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:networkconnectivity/spoke:Spoke default projects/{{project}}/locations/{{location}}/spokes/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:networkconnectivity/spoke:Spoke default {{project}}/{{location}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:networkconnectivity/spoke:Spoke default {{location}}/{{name}}
// ```
type Spoke struct {
	pulumi.CustomResourceState

	// Output only. The time the spoke was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// An optional description of the spoke.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// (Optional, Beta)
	// This is a gateway that can apply specialized processing to traffic going through it.
	// Structure is documented below.
	Gateway SpokeGatewayPtrOutput `pulumi:"gateway"`
	// The name of the group that this spoke is associated with.
	Group pulumi.StringOutput `pulumi:"group"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringOutput `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrOutput `pulumi:"linkedInterconnectAttachments"`
	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVpcNetwork SpokeLinkedProducerVpcNetworkPtrOutput `pulumi:"linkedProducerVpcNetwork"`
	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrOutput `pulumi:"linkedRouterApplianceInstances"`
	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVpcNetwork SpokeLinkedVpcNetworkPtrOutput `pulumi:"linkedVpcNetwork"`
	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrOutput `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location pulumi.StringOutput `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// The reasons for the current state in the lifecycle
	// Structure is documented below.
	Reasons SpokeReasonArrayOutput `pulumi:"reasons"`
	// Output only. The current lifecycle state of this spoke.
	State pulumi.StringOutput `pulumi:"state"`
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId pulumi.StringOutput `pulumi:"uniqueId"`
	// Output only. The time the spoke was last updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewSpoke registers a new resource with the given unique name, arguments, and options.
func NewSpoke(ctx *pulumi.Context,
	name string, args *SpokeArgs, opts ...pulumi.ResourceOption) (*Spoke, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Hub == nil {
		return nil, errors.New("invalid value for required argument 'Hub'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Spoke
	err := ctx.RegisterResource("gcp:networkconnectivity/spoke:Spoke", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSpoke gets an existing Spoke resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSpoke(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SpokeState, opts ...pulumi.ResourceOption) (*Spoke, error) {
	var resource Spoke
	err := ctx.ReadResource("gcp:networkconnectivity/spoke:Spoke", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Spoke resources.
type spokeState struct {
	// Output only. The time the spoke was created.
	CreateTime *string `pulumi:"createTime"`
	// An optional description of the spoke.
	Description *string `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// (Optional, Beta)
	// This is a gateway that can apply specialized processing to traffic going through it.
	// Structure is documented below.
	Gateway *SpokeGateway `pulumi:"gateway"`
	// The name of the group that this spoke is associated with.
	Group *string `pulumi:"group"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub *string `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments *SpokeLinkedInterconnectAttachments `pulumi:"linkedInterconnectAttachments"`
	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVpcNetwork *SpokeLinkedProducerVpcNetwork `pulumi:"linkedProducerVpcNetwork"`
	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances *SpokeLinkedRouterApplianceInstances `pulumi:"linkedRouterApplianceInstances"`
	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVpcNetwork *SpokeLinkedVpcNetwork `pulumi:"linkedVpcNetwork"`
	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVpnTunnels *SpokeLinkedVpnTunnels `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location *string `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// The reasons for the current state in the lifecycle
	// Structure is documented below.
	Reasons []SpokeReason `pulumi:"reasons"`
	// Output only. The current lifecycle state of this spoke.
	State *string `pulumi:"state"`
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId *string `pulumi:"uniqueId"`
	// Output only. The time the spoke was last updated.
	UpdateTime *string `pulumi:"updateTime"`
}

type SpokeState struct {
	// Output only. The time the spoke was created.
	CreateTime pulumi.StringPtrInput
	// An optional description of the spoke.
	Description pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// (Optional, Beta)
	// This is a gateway that can apply specialized processing to traffic going through it.
	// Structure is documented below.
	Gateway SpokeGatewayPtrInput
	// The name of the group that this spoke is associated with.
	Group pulumi.StringPtrInput
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringPtrInput
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrInput
	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVpcNetwork SpokeLinkedProducerVpcNetworkPtrInput
	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrInput
	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVpcNetwork SpokeLinkedVpcNetworkPtrInput
	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrInput
	// The location for the resource
	Location pulumi.StringPtrInput
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// The reasons for the current state in the lifecycle
	// Structure is documented below.
	Reasons SpokeReasonArrayInput
	// Output only. The current lifecycle state of this spoke.
	State pulumi.StringPtrInput
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId pulumi.StringPtrInput
	// Output only. The time the spoke was last updated.
	UpdateTime pulumi.StringPtrInput
}

func (SpokeState) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeState)(nil)).Elem()
}

type spokeArgs struct {
	// An optional description of the spoke.
	Description *string `pulumi:"description"`
	// (Optional, Beta)
	// This is a gateway that can apply specialized processing to traffic going through it.
	// Structure is documented below.
	Gateway *SpokeGateway `pulumi:"gateway"`
	// The name of the group that this spoke is associated with.
	Group *string `pulumi:"group"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub string `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments *SpokeLinkedInterconnectAttachments `pulumi:"linkedInterconnectAttachments"`
	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVpcNetwork *SpokeLinkedProducerVpcNetwork `pulumi:"linkedProducerVpcNetwork"`
	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances *SpokeLinkedRouterApplianceInstances `pulumi:"linkedRouterApplianceInstances"`
	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVpcNetwork *SpokeLinkedVpcNetwork `pulumi:"linkedVpcNetwork"`
	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVpnTunnels *SpokeLinkedVpnTunnels `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location string `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
}

// The set of arguments for constructing a Spoke resource.
type SpokeArgs struct {
	// An optional description of the spoke.
	Description pulumi.StringPtrInput
	// (Optional, Beta)
	// This is a gateway that can apply specialized processing to traffic going through it.
	// Structure is documented below.
	Gateway SpokeGatewayPtrInput
	// The name of the group that this spoke is associated with.
	Group pulumi.StringPtrInput
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringInput
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	// Structure is documented below.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrInput
	// Producer VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedProducerVpcNetwork SpokeLinkedProducerVpcNetworkPtrInput
	// The URIs of linked Router appliance resources
	// Structure is documented below.
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrInput
	// VPC network that is associated with the spoke.
	// Structure is documented below.
	LinkedVpcNetwork SpokeLinkedVpcNetworkPtrInput
	// The URIs of linked VPN tunnel resources
	// Structure is documented below.
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrInput
	// The location for the resource
	Location pulumi.StringInput
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
}

func (SpokeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeArgs)(nil)).Elem()
}

type SpokeInput interface {
	pulumi.Input

	ToSpokeOutput() SpokeOutput
	ToSpokeOutputWithContext(ctx context.Context) SpokeOutput
}

func (*Spoke) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil)).Elem()
}

func (i *Spoke) ToSpokeOutput() SpokeOutput {
	return i.ToSpokeOutputWithContext(context.Background())
}

func (i *Spoke) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeOutput)
}

// SpokeArrayInput is an input type that accepts SpokeArray and SpokeArrayOutput values.
// You can construct a concrete instance of `SpokeArrayInput` via:
//
//	SpokeArray{ SpokeArgs{...} }
type SpokeArrayInput interface {
	pulumi.Input

	ToSpokeArrayOutput() SpokeArrayOutput
	ToSpokeArrayOutputWithContext(context.Context) SpokeArrayOutput
}

type SpokeArray []SpokeInput

func (SpokeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Spoke)(nil)).Elem()
}

func (i SpokeArray) ToSpokeArrayOutput() SpokeArrayOutput {
	return i.ToSpokeArrayOutputWithContext(context.Background())
}

func (i SpokeArray) ToSpokeArrayOutputWithContext(ctx context.Context) SpokeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeArrayOutput)
}

// SpokeMapInput is an input type that accepts SpokeMap and SpokeMapOutput values.
// You can construct a concrete instance of `SpokeMapInput` via:
//
//	SpokeMap{ "key": SpokeArgs{...} }
type SpokeMapInput interface {
	pulumi.Input

	ToSpokeMapOutput() SpokeMapOutput
	ToSpokeMapOutputWithContext(context.Context) SpokeMapOutput
}

type SpokeMap map[string]SpokeInput

func (SpokeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Spoke)(nil)).Elem()
}

func (i SpokeMap) ToSpokeMapOutput() SpokeMapOutput {
	return i.ToSpokeMapOutputWithContext(context.Background())
}

func (i SpokeMap) ToSpokeMapOutputWithContext(ctx context.Context) SpokeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeMapOutput)
}

type SpokeOutput struct{ *pulumi.OutputState }

func (SpokeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil)).Elem()
}

func (o SpokeOutput) ToSpokeOutput() SpokeOutput {
	return o
}

func (o SpokeOutput) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return o
}

// Output only. The time the spoke was created.
func (o SpokeOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// An optional description of the spoke.
func (o SpokeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o SpokeOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// (Optional, Beta)
// This is a gateway that can apply specialized processing to traffic going through it.
// Structure is documented below.
func (o SpokeOutput) Gateway() SpokeGatewayPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeGatewayPtrOutput { return v.Gateway }).(SpokeGatewayPtrOutput)
}

// The name of the group that this spoke is associated with.
func (o SpokeOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Group }).(pulumi.StringOutput)
}

// Immutable. The URI of the hub that this spoke is attached to.
func (o SpokeOutput) Hub() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Hub }).(pulumi.StringOutput)
}

// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://docs.cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o SpokeOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
// Structure is documented below.
func (o SpokeOutput) LinkedInterconnectAttachments() SpokeLinkedInterconnectAttachmentsPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeLinkedInterconnectAttachmentsPtrOutput { return v.LinkedInterconnectAttachments }).(SpokeLinkedInterconnectAttachmentsPtrOutput)
}

// Producer VPC network that is associated with the spoke.
// Structure is documented below.
func (o SpokeOutput) LinkedProducerVpcNetwork() SpokeLinkedProducerVpcNetworkPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeLinkedProducerVpcNetworkPtrOutput { return v.LinkedProducerVpcNetwork }).(SpokeLinkedProducerVpcNetworkPtrOutput)
}

// The URIs of linked Router appliance resources
// Structure is documented below.
func (o SpokeOutput) LinkedRouterApplianceInstances() SpokeLinkedRouterApplianceInstancesPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeLinkedRouterApplianceInstancesPtrOutput { return v.LinkedRouterApplianceInstances }).(SpokeLinkedRouterApplianceInstancesPtrOutput)
}

// VPC network that is associated with the spoke.
// Structure is documented below.
func (o SpokeOutput) LinkedVpcNetwork() SpokeLinkedVpcNetworkPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeLinkedVpcNetworkPtrOutput { return v.LinkedVpcNetwork }).(SpokeLinkedVpcNetworkPtrOutput)
}

// The URIs of linked VPN tunnel resources
// Structure is documented below.
func (o SpokeOutput) LinkedVpnTunnels() SpokeLinkedVpnTunnelsPtrOutput {
	return o.ApplyT(func(v *Spoke) SpokeLinkedVpnTunnelsPtrOutput { return v.LinkedVpnTunnels }).(SpokeLinkedVpnTunnelsPtrOutput)
}

// The location for the resource
func (o SpokeOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// Immutable. The name of the spoke. Spoke names must be unique.
func (o SpokeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o SpokeOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o SpokeOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// The reasons for the current state in the lifecycle
// Structure is documented below.
func (o SpokeOutput) Reasons() SpokeReasonArrayOutput {
	return o.ApplyT(func(v *Spoke) SpokeReasonArrayOutput { return v.Reasons }).(SpokeReasonArrayOutput)
}

// Output only. The current lifecycle state of this spoke.
func (o SpokeOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
func (o SpokeOutput) UniqueId() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.UniqueId }).(pulumi.StringOutput)
}

// Output only. The time the spoke was last updated.
func (o SpokeOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

type SpokeArrayOutput struct{ *pulumi.OutputState }

func (SpokeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Spoke)(nil)).Elem()
}

func (o SpokeArrayOutput) ToSpokeArrayOutput() SpokeArrayOutput {
	return o
}

func (o SpokeArrayOutput) ToSpokeArrayOutputWithContext(ctx context.Context) SpokeArrayOutput {
	return o
}

func (o SpokeArrayOutput) Index(i pulumi.IntInput) SpokeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Spoke {
		return vs[0].([]*Spoke)[vs[1].(int)]
	}).(SpokeOutput)
}

type SpokeMapOutput struct{ *pulumi.OutputState }

func (SpokeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Spoke)(nil)).Elem()
}

func (o SpokeMapOutput) ToSpokeMapOutput() SpokeMapOutput {
	return o
}

func (o SpokeMapOutput) ToSpokeMapOutputWithContext(ctx context.Context) SpokeMapOutput {
	return o
}

func (o SpokeMapOutput) MapIndex(k pulumi.StringInput) SpokeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Spoke {
		return vs[0].(map[string]*Spoke)[vs[1].(string)]
	}).(SpokeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeInput)(nil)).Elem(), &Spoke{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeArrayInput)(nil)).Elem(), SpokeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeMapInput)(nil)).Elem(), SpokeMap{})
	pulumi.RegisterOutputType(SpokeOutput{})
	pulumi.RegisterOutputType(SpokeArrayOutput{})
	pulumi.RegisterOutputType(SpokeMapOutput{})
}
