// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package networkconnectivity

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The NetworkConnectivity Spoke resource
//
// ## Example Usage
// ### Router_appliance
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
// 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/networkconnectivity"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
// 			AutoCreateSubnetworks: pulumi.Bool(false),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
// 			IpCidrRange: pulumi.String("10.0.0.0/28"),
// 			Region:      pulumi.String("us-west1"),
// 			Network:     network.SelfLink,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		instance, err := compute.NewInstance(ctx, "instance", &compute.InstanceArgs{
// 			MachineType:  pulumi.String("e2-medium"),
// 			CanIpForward: pulumi.Bool(true),
// 			Zone:         pulumi.String("us-west1-a"),
// 			BootDisk: &compute.InstanceBootDiskArgs{
// 				InitializeParams: &compute.InstanceBootDiskInitializeParamsArgs{
// 					Image: pulumi.String("projects/debian-cloud/global/images/debian-10-buster-v20210817"),
// 				},
// 			},
// 			NetworkInterfaces: compute.InstanceNetworkInterfaceArray{
// 				&compute.InstanceNetworkInterfaceArgs{
// 					Subnetwork: subnetwork.Name,
// 					NetworkIp:  pulumi.String("10.0.0.2"),
// 					AccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{
// 						&compute.InstanceNetworkInterfaceAccessConfigArgs{
// 							NetworkTier: pulumi.String("PREMIUM"),
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		basicHub, err := networkconnectivity.NewHub(ctx, "basicHub", &networkconnectivity.HubArgs{
// 			Description: pulumi.String("A sample hub"),
// 			Labels: pulumi.StringMap{
// 				"label-two": pulumi.String("value-one"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
// 			Location:    pulumi.String("us-west1"),
// 			Description: pulumi.String("A sample spoke with a linked routher appliance instance"),
// 			Labels: pulumi.StringMap{
// 				"label-one": pulumi.String("value-one"),
// 			},
// 			Hub: basicHub.ID(),
// 			LinkedRouterApplianceInstances: &networkconnectivity.SpokeLinkedRouterApplianceInstancesArgs{
// 				Instances: networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArray{
// 					&networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArgs{
// 						VirtualMachine: instance.SelfLink,
// 						IpAddress:      pulumi.String("10.0.0.2"),
// 					},
// 				},
// 				SiteToSiteDataTransfer: pulumi.Bool(true),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Spoke can be imported using any of these accepted formats
//
// ```sh
//  $ pulumi import gcp:networkconnectivity/spoke:Spoke default projects/{{project}}/locations/{{location}}/spokes/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:networkconnectivity/spoke:Spoke default {{project}}/{{location}}/{{name}}
// ```
//
// ```sh
//  $ pulumi import gcp:networkconnectivity/spoke:Spoke default {{location}}/{{name}}
// ```
type Spoke struct {
	pulumi.CustomResourceState

	// Output only. The time the spoke was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// An optional description of the spoke.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringOutput `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrOutput `pulumi:"linkedInterconnectAttachments"`
	// The URIs of linked Router appliance resources
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrOutput `pulumi:"linkedRouterApplianceInstances"`
	// The URIs of linked VPN tunnel resources
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrOutput `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location pulumi.StringOutput `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringOutput `pulumi:"name"`
	// The project for the resource
	Project pulumi.StringOutput `pulumi:"project"`
	// Output only. The current lifecycle state of this spoke. Possible values: STATE_UNSPECIFIED, CREATING, ACTIVE, DELETING
	State pulumi.StringOutput `pulumi:"state"`
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is
	// deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId pulumi.StringOutput `pulumi:"uniqueId"`
	// Output only. The time the spoke was last updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewSpoke registers a new resource with the given unique name, arguments, and options.
func NewSpoke(ctx *pulumi.Context,
	name string, args *SpokeArgs, opts ...pulumi.ResourceOption) (*Spoke, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Hub == nil {
		return nil, errors.New("invalid value for required argument 'Hub'")
	}
	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	var resource Spoke
	err := ctx.RegisterResource("gcp:networkconnectivity/spoke:Spoke", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSpoke gets an existing Spoke resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSpoke(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SpokeState, opts ...pulumi.ResourceOption) (*Spoke, error) {
	var resource Spoke
	err := ctx.ReadResource("gcp:networkconnectivity/spoke:Spoke", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Spoke resources.
type spokeState struct {
	// Output only. The time the spoke was created.
	CreateTime *string `pulumi:"createTime"`
	// An optional description of the spoke.
	Description *string `pulumi:"description"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub *string `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels map[string]string `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	LinkedInterconnectAttachments *SpokeLinkedInterconnectAttachments `pulumi:"linkedInterconnectAttachments"`
	// The URIs of linked Router appliance resources
	LinkedRouterApplianceInstances *SpokeLinkedRouterApplianceInstances `pulumi:"linkedRouterApplianceInstances"`
	// The URIs of linked VPN tunnel resources
	LinkedVpnTunnels *SpokeLinkedVpnTunnels `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location *string `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `pulumi:"name"`
	// The project for the resource
	Project *string `pulumi:"project"`
	// Output only. The current lifecycle state of this spoke. Possible values: STATE_UNSPECIFIED, CREATING, ACTIVE, DELETING
	State *string `pulumi:"state"`
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is
	// deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId *string `pulumi:"uniqueId"`
	// Output only. The time the spoke was last updated.
	UpdateTime *string `pulumi:"updateTime"`
}

type SpokeState struct {
	// Output only. The time the spoke was created.
	CreateTime pulumi.StringPtrInput
	// An optional description of the spoke.
	Description pulumi.StringPtrInput
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringPtrInput
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels pulumi.StringMapInput
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrInput
	// The URIs of linked Router appliance resources
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrInput
	// The URIs of linked VPN tunnel resources
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrInput
	// The location for the resource
	Location pulumi.StringPtrInput
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringPtrInput
	// The project for the resource
	Project pulumi.StringPtrInput
	// Output only. The current lifecycle state of this spoke. Possible values: STATE_UNSPECIFIED, CREATING, ACTIVE, DELETING
	State pulumi.StringPtrInput
	// Output only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is
	// deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId pulumi.StringPtrInput
	// Output only. The time the spoke was last updated.
	UpdateTime pulumi.StringPtrInput
}

func (SpokeState) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeState)(nil)).Elem()
}

type spokeArgs struct {
	// An optional description of the spoke.
	Description *string `pulumi:"description"`
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub string `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels map[string]string `pulumi:"labels"`
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	LinkedInterconnectAttachments *SpokeLinkedInterconnectAttachments `pulumi:"linkedInterconnectAttachments"`
	// The URIs of linked Router appliance resources
	LinkedRouterApplianceInstances *SpokeLinkedRouterApplianceInstances `pulumi:"linkedRouterApplianceInstances"`
	// The URIs of linked VPN tunnel resources
	LinkedVpnTunnels *SpokeLinkedVpnTunnels `pulumi:"linkedVpnTunnels"`
	// The location for the resource
	Location string `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name *string `pulumi:"name"`
	// The project for the resource
	Project *string `pulumi:"project"`
}

// The set of arguments for constructing a Spoke resource.
type SpokeArgs struct {
	// An optional description of the spoke.
	Description pulumi.StringPtrInput
	// Immutable. The URI of the hub that this spoke is attached to.
	Hub pulumi.StringInput
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels pulumi.StringMapInput
	// A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
	LinkedInterconnectAttachments SpokeLinkedInterconnectAttachmentsPtrInput
	// The URIs of linked Router appliance resources
	LinkedRouterApplianceInstances SpokeLinkedRouterApplianceInstancesPtrInput
	// The URIs of linked VPN tunnel resources
	LinkedVpnTunnels SpokeLinkedVpnTunnelsPtrInput
	// The location for the resource
	Location pulumi.StringInput
	// Immutable. The name of the spoke. Spoke names must be unique.
	Name pulumi.StringPtrInput
	// The project for the resource
	Project pulumi.StringPtrInput
}

func (SpokeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeArgs)(nil)).Elem()
}

type SpokeInput interface {
	pulumi.Input

	ToSpokeOutput() SpokeOutput
	ToSpokeOutputWithContext(ctx context.Context) SpokeOutput
}

func (*Spoke) ElementType() reflect.Type {
	return reflect.TypeOf((*Spoke)(nil))
}

func (i *Spoke) ToSpokeOutput() SpokeOutput {
	return i.ToSpokeOutputWithContext(context.Background())
}

func (i *Spoke) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeOutput)
}

func (i *Spoke) ToSpokePtrOutput() SpokePtrOutput {
	return i.ToSpokePtrOutputWithContext(context.Background())
}

func (i *Spoke) ToSpokePtrOutputWithContext(ctx context.Context) SpokePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokePtrOutput)
}

type SpokePtrInput interface {
	pulumi.Input

	ToSpokePtrOutput() SpokePtrOutput
	ToSpokePtrOutputWithContext(ctx context.Context) SpokePtrOutput
}

type spokePtrType SpokeArgs

func (*spokePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil))
}

func (i *spokePtrType) ToSpokePtrOutput() SpokePtrOutput {
	return i.ToSpokePtrOutputWithContext(context.Background())
}

func (i *spokePtrType) ToSpokePtrOutputWithContext(ctx context.Context) SpokePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokePtrOutput)
}

// SpokeArrayInput is an input type that accepts SpokeArray and SpokeArrayOutput values.
// You can construct a concrete instance of `SpokeArrayInput` via:
//
//          SpokeArray{ SpokeArgs{...} }
type SpokeArrayInput interface {
	pulumi.Input

	ToSpokeArrayOutput() SpokeArrayOutput
	ToSpokeArrayOutputWithContext(context.Context) SpokeArrayOutput
}

type SpokeArray []SpokeInput

func (SpokeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Spoke)(nil)).Elem()
}

func (i SpokeArray) ToSpokeArrayOutput() SpokeArrayOutput {
	return i.ToSpokeArrayOutputWithContext(context.Background())
}

func (i SpokeArray) ToSpokeArrayOutputWithContext(ctx context.Context) SpokeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeArrayOutput)
}

// SpokeMapInput is an input type that accepts SpokeMap and SpokeMapOutput values.
// You can construct a concrete instance of `SpokeMapInput` via:
//
//          SpokeMap{ "key": SpokeArgs{...} }
type SpokeMapInput interface {
	pulumi.Input

	ToSpokeMapOutput() SpokeMapOutput
	ToSpokeMapOutputWithContext(context.Context) SpokeMapOutput
}

type SpokeMap map[string]SpokeInput

func (SpokeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Spoke)(nil)).Elem()
}

func (i SpokeMap) ToSpokeMapOutput() SpokeMapOutput {
	return i.ToSpokeMapOutputWithContext(context.Background())
}

func (i SpokeMap) ToSpokeMapOutputWithContext(ctx context.Context) SpokeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeMapOutput)
}

type SpokeOutput struct{ *pulumi.OutputState }

func (SpokeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Spoke)(nil))
}

func (o SpokeOutput) ToSpokeOutput() SpokeOutput {
	return o
}

func (o SpokeOutput) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return o
}

func (o SpokeOutput) ToSpokePtrOutput() SpokePtrOutput {
	return o.ToSpokePtrOutputWithContext(context.Background())
}

func (o SpokeOutput) ToSpokePtrOutputWithContext(ctx context.Context) SpokePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Spoke) *Spoke {
		return &v
	}).(SpokePtrOutput)
}

type SpokePtrOutput struct{ *pulumi.OutputState }

func (SpokePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil))
}

func (o SpokePtrOutput) ToSpokePtrOutput() SpokePtrOutput {
	return o
}

func (o SpokePtrOutput) ToSpokePtrOutputWithContext(ctx context.Context) SpokePtrOutput {
	return o
}

func (o SpokePtrOutput) Elem() SpokeOutput {
	return o.ApplyT(func(v *Spoke) Spoke {
		if v != nil {
			return *v
		}
		var ret Spoke
		return ret
	}).(SpokeOutput)
}

type SpokeArrayOutput struct{ *pulumi.OutputState }

func (SpokeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Spoke)(nil))
}

func (o SpokeArrayOutput) ToSpokeArrayOutput() SpokeArrayOutput {
	return o
}

func (o SpokeArrayOutput) ToSpokeArrayOutputWithContext(ctx context.Context) SpokeArrayOutput {
	return o
}

func (o SpokeArrayOutput) Index(i pulumi.IntInput) SpokeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Spoke {
		return vs[0].([]Spoke)[vs[1].(int)]
	}).(SpokeOutput)
}

type SpokeMapOutput struct{ *pulumi.OutputState }

func (SpokeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Spoke)(nil))
}

func (o SpokeMapOutput) ToSpokeMapOutput() SpokeMapOutput {
	return o
}

func (o SpokeMapOutput) ToSpokeMapOutputWithContext(ctx context.Context) SpokeMapOutput {
	return o
}

func (o SpokeMapOutput) MapIndex(k pulumi.StringInput) SpokeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Spoke {
		return vs[0].(map[string]Spoke)[vs[1].(string)]
	}).(SpokeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeInput)(nil)).Elem(), &Spoke{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpokePtrInput)(nil)).Elem(), &Spoke{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeArrayInput)(nil)).Elem(), SpokeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeMapInput)(nil)).Elem(), SpokeMap{})
	pulumi.RegisterOutputType(SpokeOutput{})
	pulumi.RegisterOutputType(SpokePtrOutput{})
	pulumi.RegisterOutputType(SpokeArrayOutput{})
	pulumi.RegisterOutputType(SpokeMapOutput{})
}
