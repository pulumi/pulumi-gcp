// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package certificatemanager

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Certificate represents a HTTP-reachable backend for a Certificate.
//
// ## Example Usage
//
// ### Certificate Manager Google Managed Certificate Dns
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := certificatemanager.NewDnsAuthorization(ctx, "instance", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			instance2, err := certificatemanager.NewDnsAuthorization(ctx, "instance2", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth2"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain2.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("dns-cert"),
//				Description: pulumi.String("The default cert"),
//				Scope:       pulumi.String("EDGE_CACHE"),
//				Labels: pulumi.StringMap{
//					"env": pulumi.String("test"),
//				},
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						instance.Domain,
//						instance2.Domain,
//					},
//					DnsAuthorizations: pulumi.StringArray{
//						instance.ID(),
//						instance2.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Google Managed Certificate Issuance Config
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificateauthority"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pool, err := certificateauthority.NewCaPool(ctx, "pool", &certificateauthority.CaPoolArgs{
//				Name:     pulumi.String("ca-pool"),
//				Location: pulumi.String("us-central1"),
//				Tier:     pulumi.String("ENTERPRISE"),
//			})
//			if err != nil {
//				return err
//			}
//			caAuthority, err := certificateauthority.NewAuthority(ctx, "ca_authority", &certificateauthority.AuthorityArgs{
//				Location:               pulumi.String("us-central1"),
//				Pool:                   pool.Name,
//				CertificateAuthorityId: pulumi.String("ca-authority"),
//				Config: &certificateauthority.AuthorityConfigArgs{
//					SubjectConfig: &certificateauthority.AuthorityConfigSubjectConfigArgs{
//						Subject: &certificateauthority.AuthorityConfigSubjectConfigSubjectArgs{
//							Organization: pulumi.String("HashiCorp"),
//							CommonName:   pulumi.String("my-certificate-authority"),
//						},
//						SubjectAltName: &certificateauthority.AuthorityConfigSubjectConfigSubjectAltNameArgs{
//							DnsNames: pulumi.StringArray{
//								pulumi.String("hashicorp.com"),
//							},
//						},
//					},
//					X509Config: &certificateauthority.AuthorityConfigX509ConfigArgs{
//						CaOptions: &certificateauthority.AuthorityConfigX509ConfigCaOptionsArgs{
//							IsCa: pulumi.Bool(true),
//						},
//						KeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageArgs{
//							BaseKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs{
//								CertSign: pulumi.Bool(true),
//								CrlSign:  pulumi.Bool(true),
//							},
//							ExtendedKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs{
//								ServerAuth: pulumi.Bool(true),
//							},
//						},
//					},
//				},
//				KeySpec: &certificateauthority.AuthorityKeySpecArgs{
//					Algorithm: pulumi.String("RSA_PKCS1_4096_SHA256"),
//				},
//				DeletionProtection:                 pulumi.Bool(false),
//				SkipGracePeriod:                    pulumi.Bool(true),
//				IgnoreActiveCertificatesOnDeletion: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			// creating certificate_issuance_config to use it in the managed certificate
//			issuanceconfig, err := certificatemanager.NewCertificateIssuanceConfig(ctx, "issuanceconfig", &certificatemanager.CertificateIssuanceConfigArgs{
//				Name:        pulumi.String("issuance-config"),
//				Description: pulumi.String("sample description for the certificate issuanceConfigs"),
//				CertificateAuthorityConfig: &certificatemanager.CertificateIssuanceConfigCertificateAuthorityConfigArgs{
//					CertificateAuthorityServiceConfig: &certificatemanager.CertificateIssuanceConfigCertificateAuthorityConfigCertificateAuthorityServiceConfigArgs{
//						CaPool: pool.ID(),
//					},
//				},
//				Lifetime:                 pulumi.String("1814400s"),
//				RotationWindowPercentage: pulumi.Int(34),
//				KeyAlgorithm:             pulumi.String("ECDSA_P256"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				caAuthority,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("issuance-config-cert"),
//				Description: pulumi.String("The default cert"),
//				Scope:       pulumi.String("EDGE_CACHE"),
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						pulumi.String("terraform.subdomain1.com"),
//					},
//					IssuanceConfig: issuanceconfig.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Certificate Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := certificatemanager.NewDnsAuthorization(ctx, "instance", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			instance2, err := certificatemanager.NewDnsAuthorization(ctx, "instance2", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth2"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain2.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("self-managed-cert"),
//				Description: pulumi.String("Global cert"),
//				Scope:       pulumi.String("EDGE_CACHE"),
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						instance.Domain,
//						instance2.Domain,
//					},
//					DnsAuthorizations: pulumi.StringArray{
//						instance.ID(),
//						instance2.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Self Managed Certificate Regional
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/cert.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			invokeFile1, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/private-key.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("self-managed-cert"),
//				Description: pulumi.String("Regional cert"),
//				Location:    pulumi.String("us-central1"),
//				SelfManaged: &certificatemanager.CertificateSelfManagedArgs{
//					PemCertificate: pulumi.String(invokeFile.Result),
//					PemPrivateKey:  pulumi.String(invokeFile1.Result),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Google Managed Certificate Issuance Config All Regions
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificateauthority"
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			pool, err := certificateauthority.NewCaPool(ctx, "pool", &certificateauthority.CaPoolArgs{
//				Name:     pulumi.String("ca-pool"),
//				Location: pulumi.String("us-central1"),
//				Tier:     pulumi.String("ENTERPRISE"),
//			})
//			if err != nil {
//				return err
//			}
//			caAuthority, err := certificateauthority.NewAuthority(ctx, "ca_authority", &certificateauthority.AuthorityArgs{
//				Location:               pulumi.String("us-central1"),
//				Pool:                   pool.Name,
//				CertificateAuthorityId: pulumi.String("ca-authority"),
//				Config: &certificateauthority.AuthorityConfigArgs{
//					SubjectConfig: &certificateauthority.AuthorityConfigSubjectConfigArgs{
//						Subject: &certificateauthority.AuthorityConfigSubjectConfigSubjectArgs{
//							Organization: pulumi.String("HashiCorp"),
//							CommonName:   pulumi.String("my-certificate-authority"),
//						},
//						SubjectAltName: &certificateauthority.AuthorityConfigSubjectConfigSubjectAltNameArgs{
//							DnsNames: pulumi.StringArray{
//								pulumi.String("hashicorp.com"),
//							},
//						},
//					},
//					X509Config: &certificateauthority.AuthorityConfigX509ConfigArgs{
//						CaOptions: &certificateauthority.AuthorityConfigX509ConfigCaOptionsArgs{
//							IsCa: pulumi.Bool(true),
//						},
//						KeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageArgs{
//							BaseKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs{
//								CertSign: pulumi.Bool(true),
//								CrlSign:  pulumi.Bool(true),
//							},
//							ExtendedKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs{
//								ServerAuth: pulumi.Bool(true),
//							},
//						},
//					},
//				},
//				KeySpec: &certificateauthority.AuthorityKeySpecArgs{
//					Algorithm: pulumi.String("RSA_PKCS1_4096_SHA256"),
//				},
//				DeletionProtection:                 pulumi.Bool(false),
//				SkipGracePeriod:                    pulumi.Bool(true),
//				IgnoreActiveCertificatesOnDeletion: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			// creating certificate_issuance_config to use it in the managed certificate
//			issuanceconfig, err := certificatemanager.NewCertificateIssuanceConfig(ctx, "issuanceconfig", &certificatemanager.CertificateIssuanceConfigArgs{
//				Name:        pulumi.String("issuance-config"),
//				Description: pulumi.String("sample description for the certificate issuanceConfigs"),
//				CertificateAuthorityConfig: &certificatemanager.CertificateIssuanceConfigCertificateAuthorityConfigArgs{
//					CertificateAuthorityServiceConfig: &certificatemanager.CertificateIssuanceConfigCertificateAuthorityConfigCertificateAuthorityServiceConfigArgs{
//						CaPool: pool.ID(),
//					},
//				},
//				Lifetime:                 pulumi.String("1814400s"),
//				RotationWindowPercentage: pulumi.Int(34),
//				KeyAlgorithm:             pulumi.String("ECDSA_P256"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				caAuthority,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("issuance-config-cert"),
//				Description: pulumi.String("sample google managed all_regions certificate with issuance config for terraform"),
//				Scope:       pulumi.String("ALL_REGIONS"),
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						pulumi.String("terraform.subdomain1.com"),
//					},
//					IssuanceConfig: issuanceconfig.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Google Managed Certificate Dns All Regions
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := certificatemanager.NewDnsAuthorization(ctx, "instance", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			instance2, err := certificatemanager.NewDnsAuthorization(ctx, "instance2", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth2"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain2.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("dns-cert"),
//				Description: pulumi.String("The default cert"),
//				Scope:       pulumi.String("ALL_REGIONS"),
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						instance.Domain,
//						instance2.Domain,
//					},
//					DnsAuthorizations: pulumi.StringArray{
//						instance.ID(),
//						instance2.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Google Managed Regional Certificate Dns Auth
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance, err := certificatemanager.NewDnsAuthorization(ctx, "instance", &certificatemanager.DnsAuthorizationArgs{
//				Name:        pulumi.String("dns-auth"),
//				Location:    pulumi.String("us-central1"),
//				Description: pulumi.String("The default dnss"),
//				Domain:      pulumi.String("subdomain.hashicorptest.com"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("dns-cert"),
//				Description: pulumi.String("regional managed certs"),
//				Location:    pulumi.String("us-central1"),
//				Managed: &certificatemanager.CertificateManagedArgs{
//					Domains: pulumi.StringArray{
//						instance.Domain,
//					},
//					DnsAuthorizations: pulumi.StringArray{
//						instance.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Certificate Manager Client Auth Certificate
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/cert.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			invokeFile1, err := std.File(ctx, &std.FileArgs{
//				Input: "test-fixtures/private-key.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
//				Name:        pulumi.String("client-auth-cert"),
//				Description: pulumi.String("Global cert"),
//				Scope:       pulumi.String("CLIENT_AUTH"),
//				SelfManaged: &certificatemanager.CertificateSelfManagedArgs{
//					PemCertificate: pulumi.String(invokeFile.Result),
//					PemPrivateKey:  pulumi.String(invokeFile1.Result),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Certificate can be imported using any of these accepted formats:
//
// * `projects/{{project}}/locations/{{location}}/certificates/{{name}}`
//
// * `{{project}}/{{location}}/{{name}}`
//
// * `{{location}}/{{name}}`
//
// When using the `pulumi import` command, Certificate can be imported using one of the formats above. For example:
//
// ```sh
// $ pulumi import gcp:certificatemanager/certificate:Certificate default projects/{{project}}/locations/{{location}}/certificates/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:certificatemanager/certificate:Certificate default {{project}}/{{location}}/{{name}}
// ```
//
// ```sh
// $ pulumi import gcp:certificatemanager/certificate:Certificate default {{location}}/{{name}}
// ```
type Certificate struct {
	pulumi.CustomResourceState

	// A human-readable description of the resource.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapOutput `pulumi:"effectiveLabels"`
	// Set of label tags associated with the Certificate resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The Certificate Manager location. If not specified, "global" is used.
	Location pulumi.StringPtrOutput `pulumi:"location"`
	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	Managed CertificateManagedPtrOutput `pulumi:"managed"`
	// A user-defined name of the certificate. Certificate names must be unique
	// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
	// and all following characters must be a dash, underscore, letter or digit.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringOutput `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapOutput `pulumi:"pulumiLabels"`
	// The list of Subject Alternative Names of dnsName type defined in the certificate (see RFC 5280 4.2.1.6)
	SanDnsnames pulumi.StringArrayOutput `pulumi:"sanDnsnames"`
	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
	// See https://cloud.google.com/compute/docs/regions-zones.
	// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
	// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
	Scope pulumi.StringPtrOutput `pulumi:"scope"`
	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	SelfManaged CertificateSelfManagedPtrOutput `pulumi:"selfManaged"`
}

// NewCertificate registers a new resource with the given unique name, arguments, and options.
func NewCertificate(ctx *pulumi.Context,
	name string, args *CertificateArgs, opts ...pulumi.ResourceOption) (*Certificate, error) {
	if args == nil {
		args = &CertificateArgs{}
	}

	secrets := pulumi.AdditionalSecretOutputs([]string{
		"effectiveLabels",
		"pulumiLabels",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Certificate
	err := ctx.RegisterResource("gcp:certificatemanager/certificate:Certificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCertificate gets an existing Certificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CertificateState, opts ...pulumi.ResourceOption) (*Certificate, error) {
	var resource Certificate
	err := ctx.ReadResource("gcp:certificatemanager/certificate:Certificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Certificate resources.
type certificateState struct {
	// A human-readable description of the resource.
	Description *string `pulumi:"description"`
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels map[string]string `pulumi:"effectiveLabels"`
	// Set of label tags associated with the Certificate resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The Certificate Manager location. If not specified, "global" is used.
	Location *string `pulumi:"location"`
	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	Managed *CertificateManaged `pulumi:"managed"`
	// A user-defined name of the certificate. Certificate names must be unique
	// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
	// and all following characters must be a dash, underscore, letter or digit.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels map[string]string `pulumi:"pulumiLabels"`
	// The list of Subject Alternative Names of dnsName type defined in the certificate (see RFC 5280 4.2.1.6)
	SanDnsnames []string `pulumi:"sanDnsnames"`
	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
	// See https://cloud.google.com/compute/docs/regions-zones.
	// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
	// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
	Scope *string `pulumi:"scope"`
	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	SelfManaged *CertificateSelfManaged `pulumi:"selfManaged"`
}

type CertificateState struct {
	// A human-readable description of the resource.
	Description pulumi.StringPtrInput
	// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
	EffectiveLabels pulumi.StringMapInput
	// Set of label tags associated with the Certificate resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The Certificate Manager location. If not specified, "global" is used.
	Location pulumi.StringPtrInput
	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	Managed CertificateManagedPtrInput
	// A user-defined name of the certificate. Certificate names must be unique
	// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
	// and all following characters must be a dash, underscore, letter or digit.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The combination of labels configured directly on the resource
	// and default labels configured on the provider.
	PulumiLabels pulumi.StringMapInput
	// The list of Subject Alternative Names of dnsName type defined in the certificate (see RFC 5280 4.2.1.6)
	SanDnsnames pulumi.StringArrayInput
	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
	// See https://cloud.google.com/compute/docs/regions-zones.
	// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
	// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
	Scope pulumi.StringPtrInput
	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	SelfManaged CertificateSelfManagedPtrInput
}

func (CertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*certificateState)(nil)).Elem()
}

type certificateArgs struct {
	// A human-readable description of the resource.
	Description *string `pulumi:"description"`
	// Set of label tags associated with the Certificate resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels map[string]string `pulumi:"labels"`
	// The Certificate Manager location. If not specified, "global" is used.
	Location *string `pulumi:"location"`
	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	Managed *CertificateManaged `pulumi:"managed"`
	// A user-defined name of the certificate. Certificate names must be unique
	// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
	// and all following characters must be a dash, underscore, letter or digit.
	Name *string `pulumi:"name"`
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project *string `pulumi:"project"`
	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
	// See https://cloud.google.com/compute/docs/regions-zones.
	// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
	// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
	Scope *string `pulumi:"scope"`
	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	SelfManaged *CertificateSelfManaged `pulumi:"selfManaged"`
}

// The set of arguments for constructing a Certificate resource.
type CertificateArgs struct {
	// A human-readable description of the resource.
	Description pulumi.StringPtrInput
	// Set of label tags associated with the Certificate resource.
	// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
	// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
	Labels pulumi.StringMapInput
	// The Certificate Manager location. If not specified, "global" is used.
	Location pulumi.StringPtrInput
	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	Managed CertificateManagedPtrInput
	// A user-defined name of the certificate. Certificate names must be unique
	// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
	// and all following characters must be a dash, underscore, letter or digit.
	Name pulumi.StringPtrInput
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project pulumi.StringPtrInput
	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
	// See https://cloud.google.com/vpc/docs/edge-locations.
	// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
	// See https://cloud.google.com/compute/docs/regions-zones.
	// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
	// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
	Scope pulumi.StringPtrInput
	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	SelfManaged CertificateSelfManagedPtrInput
}

func (CertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*certificateArgs)(nil)).Elem()
}

type CertificateInput interface {
	pulumi.Input

	ToCertificateOutput() CertificateOutput
	ToCertificateOutputWithContext(ctx context.Context) CertificateOutput
}

func (*Certificate) ElementType() reflect.Type {
	return reflect.TypeOf((**Certificate)(nil)).Elem()
}

func (i *Certificate) ToCertificateOutput() CertificateOutput {
	return i.ToCertificateOutputWithContext(context.Background())
}

func (i *Certificate) ToCertificateOutputWithContext(ctx context.Context) CertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateOutput)
}

// CertificateArrayInput is an input type that accepts CertificateArray and CertificateArrayOutput values.
// You can construct a concrete instance of `CertificateArrayInput` via:
//
//	CertificateArray{ CertificateArgs{...} }
type CertificateArrayInput interface {
	pulumi.Input

	ToCertificateArrayOutput() CertificateArrayOutput
	ToCertificateArrayOutputWithContext(context.Context) CertificateArrayOutput
}

type CertificateArray []CertificateInput

func (CertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Certificate)(nil)).Elem()
}

func (i CertificateArray) ToCertificateArrayOutput() CertificateArrayOutput {
	return i.ToCertificateArrayOutputWithContext(context.Background())
}

func (i CertificateArray) ToCertificateArrayOutputWithContext(ctx context.Context) CertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateArrayOutput)
}

// CertificateMapInput is an input type that accepts CertificateMap and CertificateMapOutput values.
// You can construct a concrete instance of `CertificateMapInput` via:
//
//	CertificateMap{ "key": CertificateArgs{...} }
type CertificateMapInput interface {
	pulumi.Input

	ToCertificateMapOutput() CertificateMapOutput
	ToCertificateMapOutputWithContext(context.Context) CertificateMapOutput
}

type CertificateMap map[string]CertificateInput

func (CertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Certificate)(nil)).Elem()
}

func (i CertificateMap) ToCertificateMapOutput() CertificateMapOutput {
	return i.ToCertificateMapOutputWithContext(context.Background())
}

func (i CertificateMap) ToCertificateMapOutputWithContext(ctx context.Context) CertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CertificateMapOutput)
}

type CertificateOutput struct{ *pulumi.OutputState }

func (CertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Certificate)(nil)).Elem()
}

func (o CertificateOutput) ToCertificateOutput() CertificateOutput {
	return o
}

func (o CertificateOutput) ToCertificateOutputWithContext(ctx context.Context) CertificateOutput {
	return o
}

// A human-readable description of the resource.
func (o CertificateOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
func (o CertificateOutput) EffectiveLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringMapOutput { return v.EffectiveLabels }).(pulumi.StringMapOutput)
}

// Set of label tags associated with the Certificate resource.
// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
// Please refer to the field `effectiveLabels` for all of the labels present on the resource.
func (o CertificateOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The Certificate Manager location. If not specified, "global" is used.
func (o CertificateOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringPtrOutput { return v.Location }).(pulumi.StringPtrOutput)
}

// Configuration and state of a Managed Certificate.
// Certificate Manager provisions and renews Managed Certificates
// automatically, for as long as it's authorized to do so.
// Structure is documented below.
func (o CertificateOutput) Managed() CertificateManagedPtrOutput {
	return o.ApplyT(func(v *Certificate) CertificateManagedPtrOutput { return v.Managed }).(CertificateManagedPtrOutput)
}

// A user-defined name of the certificate. Certificate names must be unique
// The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
// and all following characters must be a dash, underscore, letter or digit.
func (o CertificateOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (o CertificateOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The combination of labels configured directly on the resource
// and default labels configured on the provider.
func (o CertificateOutput) PulumiLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringMapOutput { return v.PulumiLabels }).(pulumi.StringMapOutput)
}

// The list of Subject Alternative Names of dnsName type defined in the certificate (see RFC 5280 4.2.1.6)
func (o CertificateOutput) SanDnsnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringArrayOutput { return v.SanDnsnames }).(pulumi.StringArrayOutput)
}

// The scope of the certificate.
// DEFAULT: Certificates with default scope are served from core Google data centers.
// If unsure, choose this option.
// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates, served from Edge Points of Presence.
// See https://cloud.google.com/vpc/docs/edge-locations.
// ALL_REGIONS: Certificates with ALL_REGIONS scope are served from all GCP regions (You can only use ALL_REGIONS with global certs).
// See https://cloud.google.com/compute/docs/regions-zones.
// CLIENT_AUTH: Certificates with CLIENT_AUTH scope are used by a load balancer (TLS client) to be presented to the backend (TLS server) when backend mTLS is configured.
// See https://cloud.google.com/load-balancing/docs/backend-authenticated-tls-backend-mtls#client-certificate.
func (o CertificateOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Certificate) pulumi.StringPtrOutput { return v.Scope }).(pulumi.StringPtrOutput)
}

// Certificate data for a SelfManaged Certificate.
// SelfManaged Certificates are uploaded by the user. Updating such
// certificates before they expire remains the user's responsibility.
// Structure is documented below.
func (o CertificateOutput) SelfManaged() CertificateSelfManagedPtrOutput {
	return o.ApplyT(func(v *Certificate) CertificateSelfManagedPtrOutput { return v.SelfManaged }).(CertificateSelfManagedPtrOutput)
}

type CertificateArrayOutput struct{ *pulumi.OutputState }

func (CertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Certificate)(nil)).Elem()
}

func (o CertificateArrayOutput) ToCertificateArrayOutput() CertificateArrayOutput {
	return o
}

func (o CertificateArrayOutput) ToCertificateArrayOutputWithContext(ctx context.Context) CertificateArrayOutput {
	return o
}

func (o CertificateArrayOutput) Index(i pulumi.IntInput) CertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Certificate {
		return vs[0].([]*Certificate)[vs[1].(int)]
	}).(CertificateOutput)
}

type CertificateMapOutput struct{ *pulumi.OutputState }

func (CertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Certificate)(nil)).Elem()
}

func (o CertificateMapOutput) ToCertificateMapOutput() CertificateMapOutput {
	return o
}

func (o CertificateMapOutput) ToCertificateMapOutputWithContext(ctx context.Context) CertificateMapOutput {
	return o
}

func (o CertificateMapOutput) MapIndex(k pulumi.StringInput) CertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Certificate {
		return vs[0].(map[string]*Certificate)[vs[1].(string)]
	}).(CertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateInput)(nil)).Elem(), &Certificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateArrayInput)(nil)).Elem(), CertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CertificateMapInput)(nil)).Elem(), CertificateMap{})
	pulumi.RegisterOutputType(CertificateOutput{})
	pulumi.RegisterOutputType(CertificateArrayOutput{})
	pulumi.RegisterOutputType(CertificateMapOutput{})
}
