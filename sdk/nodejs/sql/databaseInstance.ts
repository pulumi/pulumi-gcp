// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Creates a new Google SQL Database Instance. For more information, see the [official documentation](https://cloud.google.com/sql/docs/mysql/create-instance),
 * or the [JSON API](https://cloud.google.com/sql/docs/admin-api/v1beta4/instances).
 *
 * > **NOTE on `gcp.sql.DatabaseInstance`:** - Second-generation instances include a
 * default 'root'@'%' user with no password. This user will be deleted by Terraform on
 * instance creation. You should use `gcp.sql.User` to define a custom user with
 * a restricted host and strong password.
 *
 * > **Note**: On newer versions of the provider, you must explicitly set `deletion_protection=false`
 * (and run `pulumi up` to write the field to state) in order to destroy an instance.
 * It is recommended to not set this field (or set it to true) until you're ready to destroy the instance and its databases.
 *
 * ## Example Usage
 *
 * ### SQL Second Generation Instance
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const main = new gcp.sql.DatabaseInstance("main", {
 *     name: "main-instance",
 *     databaseVersion: "POSTGRES_15",
 *     region: "us-central1",
 *     settings: {
 *         tier: "db-f1-micro",
 *     },
 * });
 * ```
 *
 * ### Granular restriction of network access
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * import * as random from "@pulumi/random";
 *
 * const apps: gcp.compute.Instance[] = [];
 * for (const range = {value: 0}; range.value < 8; range.value++) {
 *     apps.push(new gcp.compute.Instance(`apps-${range.value}`, {
 *         networkInterfaces: [{
 *             accessConfigs: [{}],
 *             network: "default",
 *         }],
 *         name: `apps-${range.value + 1}`,
 *         machineType: "f1-micro",
 *         bootDisk: {
 *             initializeParams: {
 *                 image: "ubuntu-os-cloud/ubuntu-1804-lts",
 *             },
 *         },
 *     }));
 * }
 * const dbNameSuffix = new random.index.Id("db_name_suffix", {byteLength: 4});
 * const onprem = [
 *     "192.168.1.2",
 *     "192.168.2.3",
 * ];
 * const postgres = new gcp.sql.DatabaseInstance("postgres", {
 *     name: `postgres-instance-${dbNameSuffix.hex}`,
 *     databaseVersion: "POSTGRES_15",
 *     settings: {
 *         tier: "db-f1-micro",
 *         ipConfiguration: {
 *             authorizedNetworks: Object.entries(apps).map(([k, v]) => ({key: k, value: v})).apply(entries => entries.map(entry => ({
 *                 name: entry.value.name,
 *                 value: entry.value.networkInterface[0].accessConfig[0].natIp,
 *             }))),
 *             authorizedNetworks: onprem.map((v, k) => ({key: k, value: v})).map(entry2 => ({
 *                 name: `onprem-${entry2.key}`,
 *                 value: entry2.value,
 *             })),
 *         },
 *     },
 * });
 * ```
 *
 * ### Private IP Instance
 * > **NOTE:** For private IP instance setup, note that the `gcp.sql.DatabaseInstance` does not actually interpolate values from `gcp.servicenetworking.Connection`. You must explicitly add a `dependsOn`reference as shown below.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * import * as random from "@pulumi/random";
 *
 * const privateNetwork = new gcp.compute.Network("private_network", {name: "private-network"});
 * const privateIpAddress = new gcp.compute.GlobalAddress("private_ip_address", {
 *     name: "private-ip-address",
 *     purpose: "VPC_PEERING",
 *     addressType: "INTERNAL",
 *     prefixLength: 16,
 *     network: privateNetwork.id,
 * });
 * const privateVpcConnection = new gcp.servicenetworking.Connection("private_vpc_connection", {
 *     network: privateNetwork.id,
 *     service: "servicenetworking.googleapis.com",
 *     reservedPeeringRanges: [privateIpAddress.name],
 * });
 * const dbNameSuffix = new random.index.Id("db_name_suffix", {byteLength: 4});
 * const instance = new gcp.sql.DatabaseInstance("instance", {
 *     name: `private-instance-${dbNameSuffix.hex}`,
 *     region: "us-central1",
 *     databaseVersion: "MYSQL_5_7",
 *     settings: {
 *         tier: "db-f1-micro",
 *         ipConfiguration: {
 *             ipv4Enabled: false,
 *             privateNetwork: privateNetwork.selfLink,
 *             enablePrivatePathForGoogleCloudServices: true,
 *         },
 *     },
 * }, {
 *     dependsOn: [privateVpcConnection],
 * });
 * ```
 *
 * ### ENTERPRISE_PLUS Instance with dataCacheConfig
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const main = new gcp.sql.DatabaseInstance("main", {
 *     name: "enterprise-plus-main-instance",
 *     databaseVersion: "MYSQL_8_0_31",
 *     settings: {
 *         tier: "db-perf-optimized-N-2",
 *         edition: "ENTERPRISE_PLUS",
 *         dataCacheConfig: {
 *             dataCacheEnabled: true,
 *         },
 *     },
 * });
 * ```
 *
 * ### Cloud SQL Instance with Managed Connection Pooling
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const instance = new gcp.sql.DatabaseInstance("instance", {
 *     name: "mcp-enabled-main-instance",
 *     region: "us-central1",
 *     databaseVersion: "POSTGRES_16",
 *     settings: {
 *         tier: "db-perf-optimized-N-2",
 *         edition: "ENTERPRISE_PLUS",
 *         connectionPoolConfigs: [{
 *             connectionPoolingEnabled: true,
 *             flags: [{
 *                 name: "max_client_connections",
 *                 value: "1980",
 *             }],
 *         }],
 *     },
 * });
 * ```
 *
 * ### Cloud SQL Instance with PSC connectivity
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const main = new gcp.sql.DatabaseInstance("main", {
 *     name: "psc-enabled-main-instance",
 *     databaseVersion: "MYSQL_8_0",
 *     settings: {
 *         tier: "db-f1-micro",
 *         ipConfiguration: {
 *             pscConfigs: [{
 *                 pscEnabled: true,
 *                 allowedConsumerProjects: ["allowed-consumer-project-name"],
 *             }],
 *             ipv4Enabled: false,
 *         },
 *         backupConfiguration: {
 *             enabled: true,
 *             binaryLogEnabled: true,
 *         },
 *         availabilityType: "REGIONAL",
 *     },
 * });
 * ```
 *
 * ### Cloud SQL Instance with PSC auto connections
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const main = new gcp.sql.DatabaseInstance("main", {
 *     name: "psc-enabled-main-instance",
 *     databaseVersion: "MYSQL_8_0",
 *     settings: {
 *         tier: "db-f1-micro",
 *         ipConfiguration: {
 *             pscConfigs: [{
 *                 pscEnabled: true,
 *                 allowedConsumerProjects: ["allowed-consumer-project-name"],
 *                 pscAutoConnections: [{
 *                     consumerNetwork: "network-name",
 *                     consumerServiceProjectId: "project-id",
 *                 }],
 *             }],
 *             ipv4Enabled: false,
 *         },
 *         backupConfiguration: {
 *             enabled: true,
 *             binaryLogEnabled: true,
 *         },
 *         availabilityType: "REGIONAL",
 *     },
 * });
 * ```
 *
 * ### Cloud SQL Instance with PSC outbound
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const main = new gcp.sql.DatabaseInstance("main", {
 *     name: "psc-enabled-main-instance",
 *     databaseVersion: "MYSQL_8_0",
 *     settings: {
 *         tier: "db-f1-micro",
 *         ipConfiguration: {
 *             pscConfigs: [{
 *                 pscEnabled: true,
 *                 allowedConsumerProjects: ["allowed-consumer-project-name"],
 *                 networkAttachmentUri: "network-attachment-uri",
 *             }],
 *             ipv4Enabled: false,
 *         },
 *         backupConfiguration: {
 *             enabled: true,
 *             binaryLogEnabled: true,
 *         },
 *         availabilityType: "REGIONAL",
 *     },
 * });
 * ```
 *
 * ### Cloud SQL Instance created with backupdrBackup
 * > **NOTE:** For restoring from a backupdr_backup, note that the backup must be in active state. List down the backups using `gcp.backupdisasterrecovery.getBackup`. Replace `backupdrBackupFullPath` with the backup name.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const instance = new gcp.sql.DatabaseInstance("instance", {
 *     name: "main-instance",
 *     databaseVersion: "MYSQL_8_0",
 *     settings: {
 *         tier: "db-f1-micro",
 *         backupConfiguration: {
 *             enabled: true,
 *             binaryLogEnabled: true,
 *         },
 *     },
 *     backupdrBackup: "backupdr_backup_full_path",
 * });
 * ```
 *
 * ### Cloud SQL Instance created using pointInTimeRestore
 * > **NOTE:** Replace `backupdrDatasource` with the full datasource path, `timeStamp` should be in the format of `YYYY-MM-DDTHH:MM:SSZ`.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const instance = new gcp.sql.DatabaseInstance("instance", {
 *     name: "main-instance",
 *     databaseVersion: "MYSQL_8_0",
 *     settings: {
 *         tier: "db-f1-micro",
 *         backupConfiguration: {
 *             enabled: true,
 *             binaryLogEnabled: true,
 *         },
 *     },
 *     pointInTimeRestoreContext: {
 *         datasource: "backupdr_datasource",
 *         targetInstance: "target_instance_name",
 *         pointInTime: "time_stamp",
 *     },
 * });
 * ```
 *
 * ## Switchover
 *
 * Users can perform a switchover on a replica by following the steps below.
 *
 *   ~>**WARNING:** Failure to follow these steps can lead to data loss (You will be warned during plan stage). To prevent data loss during a switchover, please verify your plan with the checklist below.
 *
 * For a more in-depth walkthrough with example code, see the Switchover Guide
 *
 * ### Steps to Invoke Switchover
 *
 * MySQL/PostgreSQL: Create a cross-region, Enterprise Plus edition primary and replica pair, then set the value of primary's `replication_cluster.failover_dr_replica_name` as the replica.
 *
 * SQL Server: Create a `cascadable` replica in a different region from the primary (`cascadableReplica` is set to true in `replicaConfiguration`)
 *
 * #### Invoking switchover in the replica resource:
 * 1. Change instanceType from `READ_REPLICA_INSTANCE` to `CLOUD_SQL_INSTANCE`
 * 2. Remove `masterInstanceName`
 * 3. (SQL Server) Remove `replicaConfiguration`
 * 4. Add current primary's name to the replica's `replicaNames` list
 * 5. (MySQL/PostgreSQL) Add current primary's name to the replica's `replication_cluster.failover_dr_replica_name`.
 * 6. (MySQL/PostgreSQL) Adjust `backupConfiguration`. See Switchover Guide for details.
 *
 * #### Updating the primary resource:
 * 1. Change `instanceType` from `CLOUD_SQL_INSTANCE` to `READ_REPLICA_INSTANCE`
 * 2. Set `masterInstanceName` to the original replica (which will be primary after switchover)
 * 3. (SQL Server) Set `replicaConfiguration` and set `cascadableReplica` to `true`
 * 4. Remove original replica from `replicaNames`
 *    * **NOTE**: Do **not** delete the replicaNames field, even if it has no replicas remaining. Set replicaNames = [ ] to indicate it having no replicas.
 * 5. (MySQL/PostgreSQL) Set `replication_cluster.failover_dr_replica_name` as the empty string.
 * 6. (MySQL/PostgreSQL) Adjust `backupConfiguration`. See Switchover Guide for details.
 * #### Plan and verify that:
 * - `pulumi preview` outputs **"0 to add, 0 to destroy"**
 * - `pulumi preview` does not say **"must be replaced"** for any resource
 * - Every resource **"will be updated in-place"**
 * - Only the 2 instances involved in switchover have planned changes
 * - (Recommended) Use `deletionProtection` on instances as a safety measure
 *
 * ## Import
 *
 * Database instances can be imported using one of any of these accepted formats:
 *
 * * `projects/{{project}}/instances/{{name}}`
 * * `{{project}}/{{name}}`
 * * `{{name}}`
 *
 * When using the `pulumi import` command, Database instances can be imported using one of the formats above. For example:
 *
 * ```sh
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default projects/{{project}}/instances/{{name}}
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default {{project}}/{{name}}
 * $ pulumi import gcp:sql/databaseInstance:DatabaseInstance default {{name}}
 * ```
 *
 * > **NOTE:** Some fields (such as `replicaConfiguration`) won't show a diff if they are unset in
 * config and set on the server.
 * When importing, double-check that your config has all the fields set that you expect- just seeing
 * no diff isn't sufficient to know that your config could reproduce the imported resource.
 */
export class DatabaseInstance extends pulumi.CustomResource {
    /**
     * Get an existing DatabaseInstance resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DatabaseInstanceState, opts?: pulumi.CustomResourceOptions): DatabaseInstance {
        return new DatabaseInstance(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:sql/databaseInstance:DatabaseInstance';

    /**
     * Returns true if the given object is an instance of DatabaseInstance.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DatabaseInstance {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DatabaseInstance.__pulumiType;
    }

    /**
     * The list of all maintenance versions applicable on the instance.
     */
    declare public /*out*/ readonly availableMaintenanceVersions: pulumi.Output<string[]>;
    /**
     * The backupdrBackup needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    declare public readonly backupdrBackup: pulumi.Output<string | undefined>;
    /**
     * The context needed to create this instance as a clone of another instance. When this field is set during
     * resource creation, Terraform will attempt to clone another instance as indicated in the context. The
     * configuration is detailed below.
     */
    declare public readonly clone: pulumi.Output<outputs.sql.DatabaseInstanceClone | undefined>;
    /**
     * The connection name of the instance to be used in
     * connection strings. For example, when connecting with [Cloud SQL Proxy](https://cloud.google.com/sql/docs/mysql/connect-admin-proxy).
     */
    declare public /*out*/ readonly connectionName: pulumi.Output<string>;
    /**
     * The MySQL, PostgreSQL or
     * SQL Server version to use. Supported values include `MYSQL_5_6`,
     * `MYSQL_5_7`, `MYSQL_8_0`, `MYSQL_8_4`, `POSTGRES_9_6`,`POSTGRES_10`, `POSTGRES_11`,
     * `POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `POSTGRES_16`, `POSTGRES_17`,
     * `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.
     * `SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,
     * `SQLSERVER_2019_WEB`.
     * [Database Version Policies](https://cloud.google.com/sql/docs/db-versions)
     * includes an up-to-date reference of supported versions.
     */
    declare public readonly databaseVersion: pulumi.Output<string>;
    /**
     * Whether Terraform will be prevented from destroying the instance.
     * When the field is set to true or unset in Terraform state, a `pulumi up`
     * or `terraform destroy` that would delete the instance will fail.
     * When the field is set to false, deleting the instance is allowed.
     *
     * > **NOTE:** This flag only protects instances from deletion within Terraform. To protect your instances from accidental deletion across all surfaces (API, gcloud, Cloud Console and Terraform), use the API flag `settings.deletion_protection_enabled`.
     */
    declare public readonly deletionProtection: pulumi.Output<boolean | undefined>;
    /**
     * The DNS name of the instance. See [Connect to an instance using Private Service Connect](https://cloud.google.com/sql/docs/mysql/configure-private-service-connect#view-summary-information-cloud-sql-instances-psc-enabled) for more details.
     */
    declare public /*out*/ readonly dnsName: pulumi.Output<string>;
    /**
     * The list of DNS names used by this instance. Different connection types for an instance may have different DNS names. DNS names can apply to an individual instance or a cluster of instances.
     */
    declare public /*out*/ readonly dnsNames: pulumi.Output<outputs.sql.DatabaseInstanceDnsName[]>;
    /**
     * The full path to the encryption key used for the CMEK disk encryption.  Setting
     * up disk encryption currently requires manual steps outside of Terraform.
     * The provided key must be in the same region as the SQL instance.  In order
     * to use this feature, a special kind of service account must be created and
     * granted permission on this key.  This step can currently only be done
     * manually, please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#service-account).
     * That service account needs the `Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter` role on your
     * key - please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#grantkey).
     */
    declare public readonly encryptionKeyName: pulumi.Output<string>;
    /**
     * The description of final backup. Only set this field when `final_backup_config.enabled` is true.
     */
    declare public readonly finalBackupDescription: pulumi.Output<string | undefined>;
    /**
     * The first IPv4 address of any type assigned. This is to
     * support accessing the first address in the list in a terraform output
     * when the resource is configured with a `count`.
     */
    declare public /*out*/ readonly firstIpAddress: pulumi.Output<string>;
    /**
     * The type of the instance. See [API reference for SqlInstanceType](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/instances#SqlInstanceType) for supported values.
     */
    declare public readonly instanceType: pulumi.Output<string>;
    declare public /*out*/ readonly ipAddresses: pulumi.Output<outputs.sql.DatabaseInstanceIpAddress[]>;
    /**
     * The current software version on the instance. This attribute can not be set during creation. Refer to `availableMaintenanceVersions` attribute to see what `maintenanceVersion` are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a `maintenanceVersion` value that is older than the current one on the instance will be ignored.
     */
    declare public readonly maintenanceVersion: pulumi.Output<string>;
    /**
     * The name of the existing instance that will
     * act as the master in the replication setup. Note, this requires the master to
     * have `binaryLogEnabled` set, as well as existing backups.
     */
    declare public readonly masterInstanceName: pulumi.Output<string>;
    /**
     * The name of the instance. If the name is left
     * blank, Terraform will randomly generate one when the instance is first
     * created. This is done because after a name is used, it cannot be reused for
     * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * For a read pool instance, the number of nodes in the read pool. For read pools with auto scaling enabled, this field is read only.
     */
    declare public readonly nodeCount: pulumi.Output<number>;
    /**
     * The pointInTimeRestoreContext needed for performing a point-in-time recovery of an instance managed by Google Cloud Backup and Disaster Recovery. This field will
     * cause Terraform to trigger the database to restore to a point in time indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    declare public readonly pointInTimeRestoreContext: pulumi.Output<outputs.sql.DatabaseInstancePointInTimeRestoreContext | undefined>;
    /**
     * The first private (`PRIVATE`) IPv4 address assigned. This is
     * a workaround for an issue fixed in Terraform 0.12
     * but also provides a convenient way to access an IP of a specific type without
     * performing filtering in a Terraform config.
     */
    declare public /*out*/ readonly privateIpAddress: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     */
    declare public readonly project: pulumi.Output<string>;
    /**
     * the URI that points to the service attachment of the instance.
     */
    declare public /*out*/ readonly pscServiceAttachmentLink: pulumi.Output<string>;
    /**
     * The first public (`PRIMARY`) IPv4 address assigned. This is
     * a workaround for an issue fixed in Terraform 0.12
     * but also provides a convenient way to access an IP of a specific type without
     * performing filtering in a Terraform config.
     */
    declare public /*out*/ readonly publicIpAddress: pulumi.Output<string>;
    /**
     * The region the instance will sit in. If a region is not provided in the resource definition,
     * the provider region will be used instead.
     *
     * - - -
     */
    declare public readonly region: pulumi.Output<string>;
    /**
     * The configuration for replication. The
     * configuration is detailed below.
     */
    declare public readonly replicaConfiguration: pulumi.Output<outputs.sql.DatabaseInstanceReplicaConfiguration>;
    /**
     * List of replica names. Can be updated.
     */
    declare public readonly replicaNames: pulumi.Output<string[]>;
    /**
     * A primary instance and disaster recovery replica pair. Applicable to MySQL and PostgreSQL. This field can be set if the primary has psaWriteEndpoint set or both the primary and replica are created.
     */
    declare public readonly replicationCluster: pulumi.Output<outputs.sql.DatabaseInstanceReplicationCluster>;
    /**
     * The context needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    declare public readonly restoreBackupContext: pulumi.Output<outputs.sql.DatabaseInstanceRestoreBackupContext | undefined>;
    /**
     * Initial root password. Can be updated. Required for MS SQL Server.
     */
    declare public readonly rootPassword: pulumi.Output<string | undefined>;
    /**
     * **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Initial root password. Can be updated. Required for MS SQL Server. **Note**: This property is write-only and will not be read from the API.
     *
     * > **Note:** One of `rootPassword` or `rootPasswordWo` can only be set.
     */
    declare public readonly rootPasswordWo: pulumi.Output<string | undefined>;
    /**
     * Triggers update of `rootPasswordWo` write-only. Increment this value when an update to `rootPasswordWo` is needed. For more info see [updating write-only arguments](https://www.terraform.io/docs/providers/google/guides/using_write_only_arguments.html#updating-write-only-arguments)
     */
    declare public readonly rootPasswordWoVersion: pulumi.Output<string | undefined>;
    /**
     * The URI of the created resource.
     */
    declare public /*out*/ readonly selfLink: pulumi.Output<string>;
    declare public /*out*/ readonly serverCaCerts: pulumi.Output<outputs.sql.DatabaseInstanceServerCaCert[]>;
    /**
     * The service account email address assigned to the
     * instance.
     */
    declare public /*out*/ readonly serviceAccountEmailAddress: pulumi.Output<string>;
    /**
     * The settings to use for the database. The
     * configuration is detailed below. Required if `clone` is not set.
     */
    declare public readonly settings: pulumi.Output<outputs.sql.DatabaseInstanceSettings>;

    /**
     * Create a DatabaseInstance resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DatabaseInstanceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DatabaseInstanceArgs | DatabaseInstanceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DatabaseInstanceState | undefined;
            resourceInputs["availableMaintenanceVersions"] = state?.availableMaintenanceVersions;
            resourceInputs["backupdrBackup"] = state?.backupdrBackup;
            resourceInputs["clone"] = state?.clone;
            resourceInputs["connectionName"] = state?.connectionName;
            resourceInputs["databaseVersion"] = state?.databaseVersion;
            resourceInputs["deletionProtection"] = state?.deletionProtection;
            resourceInputs["dnsName"] = state?.dnsName;
            resourceInputs["dnsNames"] = state?.dnsNames;
            resourceInputs["encryptionKeyName"] = state?.encryptionKeyName;
            resourceInputs["finalBackupDescription"] = state?.finalBackupDescription;
            resourceInputs["firstIpAddress"] = state?.firstIpAddress;
            resourceInputs["instanceType"] = state?.instanceType;
            resourceInputs["ipAddresses"] = state?.ipAddresses;
            resourceInputs["maintenanceVersion"] = state?.maintenanceVersion;
            resourceInputs["masterInstanceName"] = state?.masterInstanceName;
            resourceInputs["name"] = state?.name;
            resourceInputs["nodeCount"] = state?.nodeCount;
            resourceInputs["pointInTimeRestoreContext"] = state?.pointInTimeRestoreContext;
            resourceInputs["privateIpAddress"] = state?.privateIpAddress;
            resourceInputs["project"] = state?.project;
            resourceInputs["pscServiceAttachmentLink"] = state?.pscServiceAttachmentLink;
            resourceInputs["publicIpAddress"] = state?.publicIpAddress;
            resourceInputs["region"] = state?.region;
            resourceInputs["replicaConfiguration"] = state?.replicaConfiguration;
            resourceInputs["replicaNames"] = state?.replicaNames;
            resourceInputs["replicationCluster"] = state?.replicationCluster;
            resourceInputs["restoreBackupContext"] = state?.restoreBackupContext;
            resourceInputs["rootPassword"] = state?.rootPassword;
            resourceInputs["rootPasswordWo"] = state?.rootPasswordWo;
            resourceInputs["rootPasswordWoVersion"] = state?.rootPasswordWoVersion;
            resourceInputs["selfLink"] = state?.selfLink;
            resourceInputs["serverCaCerts"] = state?.serverCaCerts;
            resourceInputs["serviceAccountEmailAddress"] = state?.serviceAccountEmailAddress;
            resourceInputs["settings"] = state?.settings;
        } else {
            const args = argsOrState as DatabaseInstanceArgs | undefined;
            if (args?.databaseVersion === undefined && !opts.urn) {
                throw new Error("Missing required property 'databaseVersion'");
            }
            resourceInputs["backupdrBackup"] = args?.backupdrBackup;
            resourceInputs["clone"] = args?.clone;
            resourceInputs["databaseVersion"] = args?.databaseVersion;
            resourceInputs["deletionProtection"] = args?.deletionProtection;
            resourceInputs["encryptionKeyName"] = args?.encryptionKeyName;
            resourceInputs["finalBackupDescription"] = args?.finalBackupDescription;
            resourceInputs["instanceType"] = args?.instanceType;
            resourceInputs["maintenanceVersion"] = args?.maintenanceVersion;
            resourceInputs["masterInstanceName"] = args?.masterInstanceName;
            resourceInputs["name"] = args?.name;
            resourceInputs["nodeCount"] = args?.nodeCount;
            resourceInputs["pointInTimeRestoreContext"] = args?.pointInTimeRestoreContext;
            resourceInputs["project"] = args?.project;
            resourceInputs["region"] = args?.region;
            resourceInputs["replicaConfiguration"] = args?.replicaConfiguration ? pulumi.secret(args.replicaConfiguration) : undefined;
            resourceInputs["replicaNames"] = args?.replicaNames;
            resourceInputs["replicationCluster"] = args?.replicationCluster;
            resourceInputs["restoreBackupContext"] = args?.restoreBackupContext;
            resourceInputs["rootPassword"] = args?.rootPassword ? pulumi.secret(args.rootPassword) : undefined;
            resourceInputs["rootPasswordWo"] = args?.rootPasswordWo ? pulumi.secret(args.rootPasswordWo) : undefined;
            resourceInputs["rootPasswordWoVersion"] = args?.rootPasswordWoVersion;
            resourceInputs["settings"] = args?.settings;
            resourceInputs["availableMaintenanceVersions"] = undefined /*out*/;
            resourceInputs["connectionName"] = undefined /*out*/;
            resourceInputs["dnsName"] = undefined /*out*/;
            resourceInputs["dnsNames"] = undefined /*out*/;
            resourceInputs["firstIpAddress"] = undefined /*out*/;
            resourceInputs["ipAddresses"] = undefined /*out*/;
            resourceInputs["privateIpAddress"] = undefined /*out*/;
            resourceInputs["pscServiceAttachmentLink"] = undefined /*out*/;
            resourceInputs["publicIpAddress"] = undefined /*out*/;
            resourceInputs["selfLink"] = undefined /*out*/;
            resourceInputs["serverCaCerts"] = undefined /*out*/;
            resourceInputs["serviceAccountEmailAddress"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["replicaConfiguration", "rootPassword", "rootPasswordWo", "serverCaCerts"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(DatabaseInstance.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DatabaseInstance resources.
 */
export interface DatabaseInstanceState {
    /**
     * The list of all maintenance versions applicable on the instance.
     */
    availableMaintenanceVersions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The backupdrBackup needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    backupdrBackup?: pulumi.Input<string>;
    /**
     * The context needed to create this instance as a clone of another instance. When this field is set during
     * resource creation, Terraform will attempt to clone another instance as indicated in the context. The
     * configuration is detailed below.
     */
    clone?: pulumi.Input<inputs.sql.DatabaseInstanceClone>;
    /**
     * The connection name of the instance to be used in
     * connection strings. For example, when connecting with [Cloud SQL Proxy](https://cloud.google.com/sql/docs/mysql/connect-admin-proxy).
     */
    connectionName?: pulumi.Input<string>;
    /**
     * The MySQL, PostgreSQL or
     * SQL Server version to use. Supported values include `MYSQL_5_6`,
     * `MYSQL_5_7`, `MYSQL_8_0`, `MYSQL_8_4`, `POSTGRES_9_6`,`POSTGRES_10`, `POSTGRES_11`,
     * `POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `POSTGRES_16`, `POSTGRES_17`,
     * `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.
     * `SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,
     * `SQLSERVER_2019_WEB`.
     * [Database Version Policies](https://cloud.google.com/sql/docs/db-versions)
     * includes an up-to-date reference of supported versions.
     */
    databaseVersion?: pulumi.Input<string>;
    /**
     * Whether Terraform will be prevented from destroying the instance.
     * When the field is set to true or unset in Terraform state, a `pulumi up`
     * or `terraform destroy` that would delete the instance will fail.
     * When the field is set to false, deleting the instance is allowed.
     *
     * > **NOTE:** This flag only protects instances from deletion within Terraform. To protect your instances from accidental deletion across all surfaces (API, gcloud, Cloud Console and Terraform), use the API flag `settings.deletion_protection_enabled`.
     */
    deletionProtection?: pulumi.Input<boolean>;
    /**
     * The DNS name of the instance. See [Connect to an instance using Private Service Connect](https://cloud.google.com/sql/docs/mysql/configure-private-service-connect#view-summary-information-cloud-sql-instances-psc-enabled) for more details.
     */
    dnsName?: pulumi.Input<string>;
    /**
     * The list of DNS names used by this instance. Different connection types for an instance may have different DNS names. DNS names can apply to an individual instance or a cluster of instances.
     */
    dnsNames?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceDnsName>[]>;
    /**
     * The full path to the encryption key used for the CMEK disk encryption.  Setting
     * up disk encryption currently requires manual steps outside of Terraform.
     * The provided key must be in the same region as the SQL instance.  In order
     * to use this feature, a special kind of service account must be created and
     * granted permission on this key.  This step can currently only be done
     * manually, please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#service-account).
     * That service account needs the `Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter` role on your
     * key - please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#grantkey).
     */
    encryptionKeyName?: pulumi.Input<string>;
    /**
     * The description of final backup. Only set this field when `final_backup_config.enabled` is true.
     */
    finalBackupDescription?: pulumi.Input<string>;
    /**
     * The first IPv4 address of any type assigned. This is to
     * support accessing the first address in the list in a terraform output
     * when the resource is configured with a `count`.
     */
    firstIpAddress?: pulumi.Input<string>;
    /**
     * The type of the instance. See [API reference for SqlInstanceType](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/instances#SqlInstanceType) for supported values.
     */
    instanceType?: pulumi.Input<string>;
    ipAddresses?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceIpAddress>[]>;
    /**
     * The current software version on the instance. This attribute can not be set during creation. Refer to `availableMaintenanceVersions` attribute to see what `maintenanceVersion` are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a `maintenanceVersion` value that is older than the current one on the instance will be ignored.
     */
    maintenanceVersion?: pulumi.Input<string>;
    /**
     * The name of the existing instance that will
     * act as the master in the replication setup. Note, this requires the master to
     * have `binaryLogEnabled` set, as well as existing backups.
     */
    masterInstanceName?: pulumi.Input<string>;
    /**
     * The name of the instance. If the name is left
     * blank, Terraform will randomly generate one when the instance is first
     * created. This is done because after a name is used, it cannot be reused for
     * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
     */
    name?: pulumi.Input<string>;
    /**
     * For a read pool instance, the number of nodes in the read pool. For read pools with auto scaling enabled, this field is read only.
     */
    nodeCount?: pulumi.Input<number>;
    /**
     * The pointInTimeRestoreContext needed for performing a point-in-time recovery of an instance managed by Google Cloud Backup and Disaster Recovery. This field will
     * cause Terraform to trigger the database to restore to a point in time indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    pointInTimeRestoreContext?: pulumi.Input<inputs.sql.DatabaseInstancePointInTimeRestoreContext>;
    /**
     * The first private (`PRIVATE`) IPv4 address assigned. This is
     * a workaround for an issue fixed in Terraform 0.12
     * but also provides a convenient way to access an IP of a specific type without
     * performing filtering in a Terraform config.
     */
    privateIpAddress?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * the URI that points to the service attachment of the instance.
     */
    pscServiceAttachmentLink?: pulumi.Input<string>;
    /**
     * The first public (`PRIMARY`) IPv4 address assigned. This is
     * a workaround for an issue fixed in Terraform 0.12
     * but also provides a convenient way to access an IP of a specific type without
     * performing filtering in a Terraform config.
     */
    publicIpAddress?: pulumi.Input<string>;
    /**
     * The region the instance will sit in. If a region is not provided in the resource definition,
     * the provider region will be used instead.
     *
     * - - -
     */
    region?: pulumi.Input<string>;
    /**
     * The configuration for replication. The
     * configuration is detailed below.
     */
    replicaConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceReplicaConfiguration>;
    /**
     * List of replica names. Can be updated.
     */
    replicaNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A primary instance and disaster recovery replica pair. Applicable to MySQL and PostgreSQL. This field can be set if the primary has psaWriteEndpoint set or both the primary and replica are created.
     */
    replicationCluster?: pulumi.Input<inputs.sql.DatabaseInstanceReplicationCluster>;
    /**
     * The context needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    restoreBackupContext?: pulumi.Input<inputs.sql.DatabaseInstanceRestoreBackupContext>;
    /**
     * Initial root password. Can be updated. Required for MS SQL Server.
     */
    rootPassword?: pulumi.Input<string>;
    /**
     * **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Initial root password. Can be updated. Required for MS SQL Server. **Note**: This property is write-only and will not be read from the API.
     *
     * > **Note:** One of `rootPassword` or `rootPasswordWo` can only be set.
     */
    rootPasswordWo?: pulumi.Input<string>;
    /**
     * Triggers update of `rootPasswordWo` write-only. Increment this value when an update to `rootPasswordWo` is needed. For more info see [updating write-only arguments](https://www.terraform.io/docs/providers/google/guides/using_write_only_arguments.html#updating-write-only-arguments)
     */
    rootPasswordWoVersion?: pulumi.Input<string>;
    /**
     * The URI of the created resource.
     */
    selfLink?: pulumi.Input<string>;
    serverCaCerts?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceServerCaCert>[]>;
    /**
     * The service account email address assigned to the
     * instance.
     */
    serviceAccountEmailAddress?: pulumi.Input<string>;
    /**
     * The settings to use for the database. The
     * configuration is detailed below. Required if `clone` is not set.
     */
    settings?: pulumi.Input<inputs.sql.DatabaseInstanceSettings>;
}

/**
 * The set of arguments for constructing a DatabaseInstance resource.
 */
export interface DatabaseInstanceArgs {
    /**
     * The backupdrBackup needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    backupdrBackup?: pulumi.Input<string>;
    /**
     * The context needed to create this instance as a clone of another instance. When this field is set during
     * resource creation, Terraform will attempt to clone another instance as indicated in the context. The
     * configuration is detailed below.
     */
    clone?: pulumi.Input<inputs.sql.DatabaseInstanceClone>;
    /**
     * The MySQL, PostgreSQL or
     * SQL Server version to use. Supported values include `MYSQL_5_6`,
     * `MYSQL_5_7`, `MYSQL_8_0`, `MYSQL_8_4`, `POSTGRES_9_6`,`POSTGRES_10`, `POSTGRES_11`,
     * `POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `POSTGRES_16`, `POSTGRES_17`,
     * `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.
     * `SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,
     * `SQLSERVER_2019_WEB`.
     * [Database Version Policies](https://cloud.google.com/sql/docs/db-versions)
     * includes an up-to-date reference of supported versions.
     */
    databaseVersion: pulumi.Input<string>;
    /**
     * Whether Terraform will be prevented from destroying the instance.
     * When the field is set to true or unset in Terraform state, a `pulumi up`
     * or `terraform destroy` that would delete the instance will fail.
     * When the field is set to false, deleting the instance is allowed.
     *
     * > **NOTE:** This flag only protects instances from deletion within Terraform. To protect your instances from accidental deletion across all surfaces (API, gcloud, Cloud Console and Terraform), use the API flag `settings.deletion_protection_enabled`.
     */
    deletionProtection?: pulumi.Input<boolean>;
    /**
     * The full path to the encryption key used for the CMEK disk encryption.  Setting
     * up disk encryption currently requires manual steps outside of Terraform.
     * The provided key must be in the same region as the SQL instance.  In order
     * to use this feature, a special kind of service account must be created and
     * granted permission on this key.  This step can currently only be done
     * manually, please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#service-account).
     * That service account needs the `Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter` role on your
     * key - please see [this step](https://cloud.google.com/sql/docs/mysql/configure-cmek#grantkey).
     */
    encryptionKeyName?: pulumi.Input<string>;
    /**
     * The description of final backup. Only set this field when `final_backup_config.enabled` is true.
     */
    finalBackupDescription?: pulumi.Input<string>;
    /**
     * The type of the instance. See [API reference for SqlInstanceType](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/instances#SqlInstanceType) for supported values.
     */
    instanceType?: pulumi.Input<string>;
    /**
     * The current software version on the instance. This attribute can not be set during creation. Refer to `availableMaintenanceVersions` attribute to see what `maintenanceVersion` are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a `maintenanceVersion` value that is older than the current one on the instance will be ignored.
     */
    maintenanceVersion?: pulumi.Input<string>;
    /**
     * The name of the existing instance that will
     * act as the master in the replication setup. Note, this requires the master to
     * have `binaryLogEnabled` set, as well as existing backups.
     */
    masterInstanceName?: pulumi.Input<string>;
    /**
     * The name of the instance. If the name is left
     * blank, Terraform will randomly generate one when the instance is first
     * created. This is done because after a name is used, it cannot be reused for
     * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
     */
    name?: pulumi.Input<string>;
    /**
     * For a read pool instance, the number of nodes in the read pool. For read pools with auto scaling enabled, this field is read only.
     */
    nodeCount?: pulumi.Input<number>;
    /**
     * The pointInTimeRestoreContext needed for performing a point-in-time recovery of an instance managed by Google Cloud Backup and Disaster Recovery. This field will
     * cause Terraform to trigger the database to restore to a point in time indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    pointInTimeRestoreContext?: pulumi.Input<inputs.sql.DatabaseInstancePointInTimeRestoreContext>;
    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The region the instance will sit in. If a region is not provided in the resource definition,
     * the provider region will be used instead.
     *
     * - - -
     */
    region?: pulumi.Input<string>;
    /**
     * The configuration for replication. The
     * configuration is detailed below.
     */
    replicaConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceReplicaConfiguration>;
    /**
     * List of replica names. Can be updated.
     */
    replicaNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A primary instance and disaster recovery replica pair. Applicable to MySQL and PostgreSQL. This field can be set if the primary has psaWriteEndpoint set or both the primary and replica are created.
     */
    replicationCluster?: pulumi.Input<inputs.sql.DatabaseInstanceReplicationCluster>;
    /**
     * The context needed to restore the database to a backup run. This field will
     * cause Terraform to trigger the database to restore from the backup run indicated. The configuration is detailed below.
     * **NOTE:** Restoring from a backup is an imperative action and not recommended via Terraform. Adding or modifying this
     * block during resource creation/update will trigger the restore action after the resource is created/updated.
     */
    restoreBackupContext?: pulumi.Input<inputs.sql.DatabaseInstanceRestoreBackupContext>;
    /**
     * Initial root password. Can be updated. Required for MS SQL Server.
     */
    rootPassword?: pulumi.Input<string>;
    /**
     * **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Initial root password. Can be updated. Required for MS SQL Server. **Note**: This property is write-only and will not be read from the API.
     *
     * > **Note:** One of `rootPassword` or `rootPasswordWo` can only be set.
     */
    rootPasswordWo?: pulumi.Input<string>;
    /**
     * Triggers update of `rootPasswordWo` write-only. Increment this value when an update to `rootPasswordWo` is needed. For more info see [updating write-only arguments](https://www.terraform.io/docs/providers/google/guides/using_write_only_arguments.html#updating-write-only-arguments)
     */
    rootPasswordWoVersion?: pulumi.Input<string>;
    /**
     * The settings to use for the database. The
     * configuration is detailed below. Required if `clone` is not set.
     */
    settings?: pulumi.Input<inputs.sql.DatabaseInstanceSettings>;
}
