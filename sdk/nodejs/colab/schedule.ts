// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * 'Colab Enterprise Notebook Execution Schedules.'
 *
 * To get more information about Schedule, see:
 *
 * * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.schedules)
 * * How-to Guides
 *     * [Schedule a notebook run](https://cloud.google.com/colab/docs/schedule-notebook-run)
 *
 * ## Example Usage
 *
 * ### Colab Schedule Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const myRuntimeTemplate = new gcp.colab.RuntimeTemplate("my_runtime_template", {
 *     name: "runtime-template",
 *     displayName: "Runtime template",
 *     location: "us-central1",
 *     machineSpec: {
 *         machineType: "e2-standard-4",
 *     },
 *     networkSpec: {
 *         enableInternetAccess: true,
 *     },
 * });
 * const outputBucket = new gcp.storage.Bucket("output_bucket", {
 *     name: "my_bucket",
 *     location: "US",
 *     forceDestroy: true,
 *     uniformBucketLevelAccess: true,
 * });
 * const notebook = new gcp.storage.BucketObject("notebook", {
 *     name: "hello_world.ipynb",
 *     bucket: outputBucket.name,
 *     content: `    {
 *       \\"cells\\": [
 *         {
 *           \\"cell_type\\": \\"code\\",
 *           \\"execution_count\\": null,
 *           \\"metadata\\": {},
 *           \\"outputs\\": [],
 *           \\"source\\": [
 *             \\"print(\\\\\\"Hello, World!\\\\\\")\\"
 *           ]
 *         }
 *       ],
 *       \\"metadata\\": {
 *         \\"kernelspec\\": {
 *           \\"display_name\\": \\"Python 3\\",
 *           \\"language\\": \\"python\\",
 *           \\"name\\": \\"python3\\"
 *         },
 *         \\"language_info\\": {
 *           \\"codemirror_mode\\": {
 *             \\"name\\": \\"ipython\\",
 *             \\"version\\": 3
 *           },
 *           \\"file_extension\\": \\".py\\",
 *           \\"mimetype\\": \\"text/x-python\\",
 *           \\"name\\": \\"python\\",
 *           \\"nbconvert_exporter\\": \\"python\\",
 *           \\"pygments_lexer\\": \\"ipython3\\",
 *           \\"version\\": \\"3.8.5\\"
 *         }
 *       },
 *       \\"nbformat\\": 4,
 *       \\"nbformat_minor\\": 4
 *     }
 * `,
 * });
 * const schedule = new gcp.colab.Schedule("schedule", {
 *     displayName: "basic-schedule",
 *     location: "us-west1",
 *     maxConcurrentRunCount: "2",
 *     cron: "TZ=America/Los_Angeles * * * * *",
 *     createNotebookExecutionJobRequest: {
 *         notebookExecutionJob: {
 *             displayName: "Notebook execution",
 *             gcsNotebookSource: {
 *                 uri: pulumi.interpolate`gs://${notebook.bucket}/${notebook.name}`,
 *                 generation: notebook.generation,
 *             },
 *             notebookRuntimeTemplateResourceName: pulumi.interpolate`projects/${myRuntimeTemplate.project}/locations/${myRuntimeTemplate.location}/notebookRuntimeTemplates/${myRuntimeTemplate.name}`,
 *             gcsOutputUri: pulumi.interpolate`gs://${outputBucket.name}`,
 *             serviceAccount: "my@service-account.com",
 *         },
 *     },
 * }, {
 *     dependsOn: [
 *         myRuntimeTemplate,
 *         outputBucket,
 *     ],
 * });
 * ```
 * ### Colab Schedule Paused
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const myRuntimeTemplate = new gcp.colab.RuntimeTemplate("my_runtime_template", {
 *     name: "runtime-template",
 *     displayName: "Runtime template",
 *     location: "us-central1",
 *     machineSpec: {
 *         machineType: "e2-standard-4",
 *     },
 *     networkSpec: {
 *         enableInternetAccess: true,
 *     },
 * });
 * const outputBucket = new gcp.storage.Bucket("output_bucket", {
 *     name: "my_bucket",
 *     location: "US",
 *     forceDestroy: true,
 *     uniformBucketLevelAccess: true,
 * });
 * const notebook = new gcp.storage.BucketObject("notebook", {
 *     name: "hello_world.ipynb",
 *     bucket: outputBucket.name,
 *     content: `    {
 *       \\"cells\\": [
 *         {
 *           \\"cell_type\\": \\"code\\",
 *           \\"execution_count\\": null,
 *           \\"metadata\\": {},
 *           \\"outputs\\": [],
 *           \\"source\\": [
 *             \\"print(\\\\\\"Hello, World!\\\\\\")\\"
 *           ]
 *         }
 *       ],
 *       \\"metadata\\": {
 *         \\"kernelspec\\": {
 *           \\"display_name\\": \\"Python 3\\",
 *           \\"language\\": \\"python\\",
 *           \\"name\\": \\"python3\\"
 *         },
 *         \\"language_info\\": {
 *           \\"codemirror_mode\\": {
 *             \\"name\\": \\"ipython\\",
 *             \\"version\\": 3
 *           },
 *           \\"file_extension\\": \\".py\\",
 *           \\"mimetype\\": \\"text/x-python\\",
 *           \\"name\\": \\"python\\",
 *           \\"nbconvert_exporter\\": \\"python\\",
 *           \\"pygments_lexer\\": \\"ipython3\\",
 *           \\"version\\": \\"3.8.5\\"
 *         }
 *       },
 *       \\"nbformat\\": 4,
 *       \\"nbformat_minor\\": 4
 *     }
 * `,
 * });
 * const schedule = new gcp.colab.Schedule("schedule", {
 *     displayName: "paused-schedule",
 *     location: "us-west1",
 *     maxConcurrentRunCount: "2",
 *     cron: "TZ=America/Los_Angeles * * * * *",
 *     desiredState: "PAUSED",
 *     createNotebookExecutionJobRequest: {
 *         notebookExecutionJob: {
 *             displayName: "Notebook execution",
 *             gcsNotebookSource: {
 *                 uri: pulumi.interpolate`gs://${notebook.bucket}/${notebook.name}`,
 *                 generation: notebook.generation,
 *             },
 *             notebookRuntimeTemplateResourceName: pulumi.interpolate`projects/${myRuntimeTemplate.project}/locations/${myRuntimeTemplate.location}/notebookRuntimeTemplates/${myRuntimeTemplate.name}`,
 *             gcsOutputUri: pulumi.interpolate`gs://${outputBucket.name}`,
 *             serviceAccount: "my@service-account.com",
 *         },
 *     },
 * }, {
 *     dependsOn: [
 *         myRuntimeTemplate,
 *         outputBucket,
 *     ],
 * });
 * ```
 * ### Colab Schedule Full
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const myRuntimeTemplate = new gcp.colab.RuntimeTemplate("my_runtime_template", {
 *     name: "runtime-template",
 *     displayName: "Runtime template",
 *     location: "us-central1",
 *     machineSpec: {
 *         machineType: "e2-standard-4",
 *     },
 *     networkSpec: {
 *         enableInternetAccess: true,
 *     },
 * });
 * const outputBucket = new gcp.storage.Bucket("output_bucket", {
 *     name: "my_bucket",
 *     location: "US",
 *     forceDestroy: true,
 *     uniformBucketLevelAccess: true,
 * });
 * const secret = new gcp.secretmanager.Secret("secret", {
 *     secretId: "secret",
 *     replication: {
 *         auto: {},
 *     },
 * });
 * const secretVersion = new gcp.secretmanager.SecretVersion("secret_version", {
 *     secret: secret.id,
 *     secretData: "secret-data",
 * });
 * const dataformRepository = new gcp.dataform.Repository("dataform_repository", {
 *     name: "dataform-repository",
 *     displayName: "dataform_repository",
 *     npmrcEnvironmentVariablesSecretVersion: secretVersion.id,
 *     kmsKeyName: "my-key",
 *     labels: {
 *         label_foo1: "label-bar1",
 *     },
 *     gitRemoteSettings: {
 *         url: "https://github.com/OWNER/REPOSITORY.git",
 *         defaultBranch: "main",
 *         authenticationTokenSecretVersion: secretVersion.id,
 *     },
 *     workspaceCompilationOverrides: {
 *         defaultDatabase: "database",
 *         schemaSuffix: "_suffix",
 *         tablePrefix: "prefix_",
 *     },
 * });
 * const schedule = new gcp.colab.Schedule("schedule", {
 *     displayName: "full-schedule",
 *     location: "us-west1",
 *     allowQueueing: true,
 *     maxConcurrentRunCount: "2",
 *     cron: "TZ=America/Los_Angeles * * * * *",
 *     maxRunCount: "5",
 *     startTime: "2014-10-02T15:01:23Z",
 *     endTime: "2014-10-10T15:01:23Z",
 *     desiredState: "ACTIVE",
 *     createNotebookExecutionJobRequest: {
 *         notebookExecutionJob: {
 *             displayName: "Notebook execution",
 *             executionTimeout: "86400s",
 *             dataformRepositorySource: {
 *                 commitSha: "randomsha123",
 *                 dataformRepositoryResourceName: pulumi.interpolate`projects/my-project-name/locations/us-west1/repositories/${dataformRepository.name}`,
 *             },
 *             notebookRuntimeTemplateResourceName: pulumi.interpolate`projects/${myRuntimeTemplate.project}/locations/${myRuntimeTemplate.location}/notebookRuntimeTemplates/${myRuntimeTemplate.name}`,
 *             gcsOutputUri: pulumi.interpolate`gs://${outputBucket.name}`,
 *             serviceAccount: "my@service-account.com",
 *         },
 *     },
 * }, {
 *     dependsOn: [
 *         myRuntimeTemplate,
 *         outputBucket,
 *         secretVersion,
 *         dataformRepository,
 *     ],
 * });
 * ```
 *
 * ## Import
 *
 * Schedule can be imported using any of these accepted formats:
 *
 * * `projects/{{project}}/locations/{{location}}/schedules/{{name}}`
 *
 * * `{{project}}/{{location}}/{{name}}`
 *
 * * `{{location}}/{{name}}`
 *
 * When using the `pulumi import` command, Schedule can be imported using one of the formats above. For example:
 *
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default projects/{{project}}/locations/{{location}}/schedules/{{name}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default {{project}}/{{location}}/{{name}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:colab/schedule:Schedule default {{location}}/{{name}}
 * ```
 */
export class Schedule extends pulumi.CustomResource {
    /**
     * Get an existing Schedule resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ScheduleState, opts?: pulumi.CustomResourceOptions): Schedule {
        return new Schedule(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:colab/schedule:Schedule';

    /**
     * Returns true if the given object is an instance of Schedule.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Schedule {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Schedule.__pulumiType;
    }

    /**
     * Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     */
    declare public readonly allowQueueing: pulumi.Output<boolean | undefined>;
    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     */
    declare public readonly createNotebookExecutionJobRequest: pulumi.Output<outputs.colab.ScheduleCreateNotebookExecutionJobRequest>;
    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     */
    declare public readonly cron: pulumi.Output<string>;
    /**
     * Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     */
    declare public readonly desiredState: pulumi.Output<string | undefined>;
    /**
     * Required. The display name of the Schedule.
     */
    declare public readonly displayName: pulumi.Output<string>;
    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    declare public readonly endTime: pulumi.Output<string | undefined>;
    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     */
    declare public readonly location: pulumi.Output<string>;
    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     */
    declare public readonly maxConcurrentRunCount: pulumi.Output<string>;
    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     */
    declare public readonly maxRunCount: pulumi.Output<string | undefined>;
    /**
     * The resource name of the Schedule
     */
    declare public /*out*/ readonly name: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    declare public readonly project: pulumi.Output<string>;
    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    declare public readonly startTime: pulumi.Output<string>;
    /**
     * Output only. The state of the schedule.
     */
    declare public /*out*/ readonly state: pulumi.Output<string>;

    /**
     * Create a Schedule resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ScheduleArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ScheduleArgs | ScheduleState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ScheduleState | undefined;
            resourceInputs["allowQueueing"] = state?.allowQueueing;
            resourceInputs["createNotebookExecutionJobRequest"] = state?.createNotebookExecutionJobRequest;
            resourceInputs["cron"] = state?.cron;
            resourceInputs["desiredState"] = state?.desiredState;
            resourceInputs["displayName"] = state?.displayName;
            resourceInputs["endTime"] = state?.endTime;
            resourceInputs["location"] = state?.location;
            resourceInputs["maxConcurrentRunCount"] = state?.maxConcurrentRunCount;
            resourceInputs["maxRunCount"] = state?.maxRunCount;
            resourceInputs["name"] = state?.name;
            resourceInputs["project"] = state?.project;
            resourceInputs["startTime"] = state?.startTime;
            resourceInputs["state"] = state?.state;
        } else {
            const args = argsOrState as ScheduleArgs | undefined;
            if (args?.createNotebookExecutionJobRequest === undefined && !opts.urn) {
                throw new Error("Missing required property 'createNotebookExecutionJobRequest'");
            }
            if (args?.cron === undefined && !opts.urn) {
                throw new Error("Missing required property 'cron'");
            }
            if (args?.displayName === undefined && !opts.urn) {
                throw new Error("Missing required property 'displayName'");
            }
            if (args?.location === undefined && !opts.urn) {
                throw new Error("Missing required property 'location'");
            }
            if (args?.maxConcurrentRunCount === undefined && !opts.urn) {
                throw new Error("Missing required property 'maxConcurrentRunCount'");
            }
            resourceInputs["allowQueueing"] = args?.allowQueueing;
            resourceInputs["createNotebookExecutionJobRequest"] = args?.createNotebookExecutionJobRequest;
            resourceInputs["cron"] = args?.cron;
            resourceInputs["desiredState"] = args?.desiredState;
            resourceInputs["displayName"] = args?.displayName;
            resourceInputs["endTime"] = args?.endTime;
            resourceInputs["location"] = args?.location;
            resourceInputs["maxConcurrentRunCount"] = args?.maxConcurrentRunCount;
            resourceInputs["maxRunCount"] = args?.maxRunCount;
            resourceInputs["project"] = args?.project;
            resourceInputs["startTime"] = args?.startTime;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Schedule.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Schedule resources.
 */
export interface ScheduleState {
    /**
     * Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     */
    allowQueueing?: pulumi.Input<boolean>;
    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     */
    createNotebookExecutionJobRequest?: pulumi.Input<inputs.colab.ScheduleCreateNotebookExecutionJobRequest>;
    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     */
    cron?: pulumi.Input<string>;
    /**
     * Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     */
    desiredState?: pulumi.Input<string>;
    /**
     * Required. The display name of the Schedule.
     */
    displayName?: pulumi.Input<string>;
    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    endTime?: pulumi.Input<string>;
    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     */
    location?: pulumi.Input<string>;
    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     */
    maxConcurrentRunCount?: pulumi.Input<string>;
    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     */
    maxRunCount?: pulumi.Input<string>;
    /**
     * The resource name of the Schedule
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    startTime?: pulumi.Input<string>;
    /**
     * Output only. The state of the schedule.
     */
    state?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Schedule resource.
 */
export interface ScheduleArgs {
    /**
     * Whether new scheduled runs can be queued when maxConcurrentRuns limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
     */
    allowQueueing?: pulumi.Input<boolean>;
    /**
     * Request for google_colab_notebook_execution.
     * Structure is documented below.
     */
    createNotebookExecutionJobRequest: pulumi.Input<inputs.colab.ScheduleCreateNotebookExecutionJobRequest>;
    /**
     * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
     */
    cron: pulumi.Input<string>;
    /**
     * Desired state of the Colab Schedule. Set this field to `ACTIVE` to start/resume the schedule, and `PAUSED` to pause the schedule.
     */
    desiredState?: pulumi.Input<string>;
    /**
     * Required. The display name of the Schedule.
     */
    displayName: pulumi.Input<string>;
    /**
     * Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either endTime is reached or when scheduledRunCount >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    endTime?: pulumi.Input<string>;
    /**
     * The location for the resource: https://cloud.google.com/colab/docs/locations
     */
    location: pulumi.Input<string>;
    /**
     * Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.
     */
    maxConcurrentRunCount: pulumi.Input<string>;
    /**
     * Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
     */
    maxRunCount?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.
     */
    startTime?: pulumi.Input<string>;
}
