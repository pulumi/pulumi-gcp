// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";

export interface ProviderBatching {
    enableBatching?: pulumi.Input<boolean>;
    sendAfter?: pulumi.Input<string>;
}

export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: pulumi.Input<string>;
        conditions: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicCondition>[]>;
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy>;
        ipSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
        members?: pulumi.Input<pulumi.Input<string>[]>;
        negate?: pulumi.Input<boolean>;
        requiredAccessLevels?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint>[]>;
        requireAdminApproval?: pulumi.Input<boolean>;
        requireCorpOwned?: pulumi.Input<boolean>;
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: pulumi.Input<string>;
        osType: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: pulumi.Input<boolean>;
    }

    export interface ApplicationIap {
        oauth2ClientId: pulumi.Input<string>;
        oauth2ClientSecret: pulumi.Input<string>;
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRule {
        domain?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        domain?: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }

    export interface DomainMappingResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingSslSettings {
        certificateId?: pulumi.Input<string>;
        pendingManagedCertificateId?: pulumi.Input<string>;
        sslManagementType: pulumi.Input<string>;
    }

    export interface EngineSplitTrafficSplit {
        allocations: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        shardBy?: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeployment {
        files?: pulumi.Input<pulumi.Input<inputs.appengine.StandardAppVersionDeploymentFile>[]>;
        zip?: pulumi.Input<inputs.appengine.StandardAppVersionDeploymentZip>;
    }

    export interface StandardAppVersionDeploymentFile {
        name: pulumi.Input<string>;
        sha1Sum?: pulumi.Input<string>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: pulumi.Input<number>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionEntrypoint {
        shell: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: pulumi.Input<string>;
        login?: pulumi.Input<string>;
        redirectHttpResponseCode?: pulumi.Input<string>;
        script?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerScript>;
        securityLevel?: pulumi.Input<string>;
        staticFiles?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerStaticFiles>;
        urlRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: pulumi.Input<boolean>;
        expiration?: pulumi.Input<string>;
        httpHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        mimeType?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        requireMatchingFile?: pulumi.Input<boolean>;
        uploadPathRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionLibrary {
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: pulumi.Input<boolean>;
        clusterId: pulumi.Input<string>;
    }

    export interface DatasetAccess {
        domain?: pulumi.Input<string>;
        groupByEmail?: pulumi.Input<string>;
        role?: pulumi.Input<string>;
        specialGroup?: pulumi.Input<string>;
        userByEmail?: pulumi.Input<string>;
        view?: pulumi.Input<inputs.bigquery.DatasetAccessView>;
    }

    export interface DatasetAccessView {
        datasetId: pulumi.Input<string>;
        projectId: pulumi.Input<string>;
        tableId: pulumi.Input<string>;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        kmsKeyName: pulumi.Input<string>;
    }

    export interface TableEncryptionConfiguration {
        kmsKeyName: pulumi.Input<string>;
    }

    export interface TableExternalDataConfiguration {
        autodetect: pulumi.Input<boolean>;
        compression?: pulumi.Input<string>;
        csvOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationCsvOptions>;
        googleSheetsOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions>;
        ignoreUnknownValues?: pulumi.Input<boolean>;
        maxBadRecords?: pulumi.Input<number>;
        sourceFormat: pulumi.Input<string>;
        sourceUris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableExternalDataConfigurationCsvOptions {
        allowJaggedRows?: pulumi.Input<boolean>;
        allowQuotedNewlines?: pulumi.Input<boolean>;
        encoding?: pulumi.Input<string>;
        fieldDelimiter?: pulumi.Input<string>;
        quote: pulumi.Input<string>;
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        range?: pulumi.Input<string>;
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableRangePartitioning {
        field: pulumi.Input<string>;
        range: pulumi.Input<inputs.bigquery.TableRangePartitioningRange>;
    }

    export interface TableRangePartitioningRange {
        end: pulumi.Input<number>;
        interval: pulumi.Input<number>;
        start: pulumi.Input<number>;
    }

    export interface TableTimePartitioning {
        expirationMs?: pulumi.Input<number>;
        field?: pulumi.Input<string>;
        requirePartitionFilter?: pulumi.Input<boolean>;
        /**
         * Describes the table type.
         */
        type: pulumi.Input<string>;
    }

    export interface TableView {
        query: pulumi.Input<string>;
        useLegacySql?: pulumi.Input<boolean>;
    }
}

export namespace bigtable {
    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         */
        days: pulumi.Input<number>;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         */
        number: pulumi.Input<number>;
    }

    export interface InstanceCluster {
        clusterId: pulumi.Input<string>;
        numNodes?: pulumi.Input<number>;
        storageType?: pulumi.Input<string>;
        zone: pulumi.Input<string>;
    }

    export interface InstanceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: pulumi.Input<string>;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AccountIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BudgetAllUpdatesRule {
        pubsubTopic: pulumi.Input<string>;
        schemaVersion?: pulumi.Input<string>;
    }

    export interface BudgetAmount {
        specifiedAmount: pulumi.Input<inputs.billing.BudgetAmountSpecifiedAmount>;
    }

    export interface BudgetAmountSpecifiedAmount {
        currencyCode?: pulumi.Input<string>;
        nanos?: pulumi.Input<number>;
        units?: pulumi.Input<string>;
    }

    export interface BudgetBudgetFilter {
        creditTypesTreatment?: pulumi.Input<string>;
        projects?: pulumi.Input<pulumi.Input<string>[]>;
        services?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BudgetThresholdRule {
        spendBasis?: pulumi.Input<string>;
        thresholdPercent: pulumi.Input<number>;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail?: pulumi.Input<string>;
        noteReference: pulumi.Input<string>;
        publicKeys?: pulumi.Input<pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey>[]>;
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: pulumi.Input<string>;
        comment?: pulumi.Input<string>;
        /**
         * an identifier for the resource with format `projects/{{project}}/attestors/{{name}}`
         */
        id?: pulumi.Input<string>;
        pkixPublicKey?: pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey>;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: pulumi.Input<string>;
        signatureAlgorithm?: pulumi.Input<string>;
    }

    export interface AttestorIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AttestorIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern: pulumi.Input<string>;
    }

    export interface PolicyClusterAdmissionRule {
        cluster: pulumi.Input<string>;
        enforcementMode: pulumi.Input<string>;
        evaluationMode: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: pulumi.Input<string>;
        evaluationMode: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: pulumi.Input<pulumi.Input<string>[]>;
        steps: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStep>[]>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        timeout?: pulumi.Input<string>;
    }

    export interface TriggerBuildStep {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        dir?: pulumi.Input<string>;
        entrypoint?: pulumi.Input<string>;
        envs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * an identifier for the resource with format `projects/{{project}}/triggers/{{trigger_id}}`
         */
        id?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        secretEnvs?: pulumi.Input<pulumi.Input<string>[]>;
        timeout?: pulumi.Input<string>;
        timing?: pulumi.Input<string>;
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStepVolume>[]>;
        waitFors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TriggerBuildStepVolume {
        name: pulumi.Input<string>;
        path: pulumi.Input<string>;
    }

    export interface TriggerGithub {
        name?: pulumi.Input<string>;
        owner?: pulumi.Input<string>;
        pullRequest?: pulumi.Input<inputs.cloudbuild.TriggerGithubPullRequest>;
        push?: pulumi.Input<inputs.cloudbuild.TriggerGithubPush>;
    }

    export interface TriggerGithubPullRequest {
        branch: pulumi.Input<string>;
        commentControl?: pulumi.Input<string>;
    }

    export interface TriggerGithubPush {
        branch?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
    }

    export interface TriggerTriggerTemplate {
        branchName?: pulumi.Input<string>;
        commitSha?: pulumi.Input<string>;
        dir?: pulumi.Input<string>;
        projectId?: pulumi.Input<string>;
        repoName?: pulumi.Input<string>;
        tagName?: pulumi.Input<string>;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        eventType: pulumi.Input<string>;
        failurePolicy?: pulumi.Input<inputs.cloudfunctions.FunctionEventTriggerFailurePolicy>;
        resource: pulumi.Input<string>;
    }

    export interface FunctionEventTriggerFailurePolicy {
        retry: pulumi.Input<boolean>;
    }

    export interface FunctionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionSourceRepository {
        deployedUrl?: pulumi.Input<string>;
        url: pulumi.Input<string>;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface DomainMappingSpec {
        certificateMode?: pulumi.Input<string>;
        forceOverride?: pulumi.Input<boolean>;
        routeName: pulumi.Input<string>;
    }

    export interface DomainMappingStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusCondition>[]>;
        mappedRouteName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        resourceRecords?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusResourceRecord>[]>;
    }

    export interface DomainMappingStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingStatusResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface IamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace?: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface ServiceStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceStatusCondition>[]>;
        latestCreatedRevisionName?: pulumi.Input<string>;
        latestReadyRevisionName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        url?: pulumi.Input<string>;
    }

    export interface ServiceStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface ServiceTemplate {
        metadata?: pulumi.Input<inputs.cloudrun.ServiceTemplateMetadata>;
        spec?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpec>;
    }

    export interface ServiceTemplateMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpec {
        containerConcurrency?: pulumi.Input<number>;
        containers?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainer>[]>;
        serviceAccountName?: pulumi.Input<string>;
        servingState?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainer {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnv>[]>;
        envFroms?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFrom>[]>;
        image: pulumi.Input<string>;
        resources?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerResources>;
        workingDir?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnv {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        configMapRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef>;
        prefix?: pulumi.Input<string>;
        secretRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerResources {
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ServiceTraffic {
        latestRevision?: pulumi.Input<boolean>;
        percent: pulumi.Input<number>;
        revisionName?: pulumi.Input<string>;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: pulumi.Input<inputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting>;
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        relativeUri: pulumi.Input<string>;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface JobHttpTarget {
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        oauthToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOauthToken>;
        oidcToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOidcToken>;
        uri: pulumi.Input<string>;
    }

    export interface JobHttpTargetOauthToken {
        scope?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobHttpTargetOidcToken {
        audience?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobPubsubTarget {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        data?: pulumi.Input<string>;
        topicName: pulumi.Input<string>;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: pulumi.Input<string>;
        maxDoublings?: pulumi.Input<number>;
        maxRetryDuration?: pulumi.Input<string>;
        minBackoffDuration?: pulumi.Input<string>;
        retryCount?: pulumi.Input<number>;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        host?: pulumi.Input<string>;
        instance?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface QueueRateLimits {
        maxBurstSize?: pulumi.Input<number>;
        maxConcurrentDispatches?: pulumi.Input<number>;
        maxDispatchesPerSecond?: pulumi.Input<number>;
    }

    export interface QueueRetryConfig {
        maxAttempts?: pulumi.Input<number>;
        maxBackoff?: pulumi.Input<string>;
        maxDoublings?: pulumi.Input<number>;
        maxRetryDuration?: pulumi.Input<string>;
        minBackoff?: pulumi.Input<string>;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri?: pulumi.Input<string>;
        dagGcsPrefix?: pulumi.Input<string>;
        gkeCluster?: pulumi.Input<string>;
        nodeConfig?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        privateEnvironmentConfig?: pulumi.Input<inputs.composer.EnvironmentConfigPrivateEnvironmentConfig>;
        softwareConfig?: pulumi.Input<inputs.composer.EnvironmentConfigSoftwareConfig>;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        ipAllocationPolicy?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy>;
        machineType?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        serviceAccount?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        zone: pulumi.Input<string>;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        clusterSecondaryRangeName?: pulumi.Input<string>;
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        servicesSecondaryRangeName?: pulumi.Input<string>;
        useIpAliases: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        masterIpv4CidrBlock?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        envVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        imageVersion?: pulumi.Input<string>;
        pypiPackages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pythonVersion?: pulumi.Input<string>;
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: pulumi.Input<number>;
    }

    export interface BackendServiceBackend {
        balancingMode?: pulumi.Input<string>;
        capacityScaler?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        group: pulumi.Input<string>;
        maxConnections?: pulumi.Input<number>;
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        maxConnectionsPerInstance?: pulumi.Input<number>;
        maxRate?: pulumi.Input<number>;
        maxRatePerEndpoint?: pulumi.Input<number>;
        maxRatePerInstance?: pulumi.Input<number>;
        maxUtilization?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: pulumi.Input<inputs.compute.BackendServiceCdnPolicyCacheKeyPolicy>;
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: pulumi.Input<boolean>;
        includeProtocol?: pulumi.Input<boolean>;
        includeQueryString?: pulumi.Input<boolean>;
        queryStringBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: pulumi.Input<inputs.compute.BackendServiceCircuitBreakersConnectTimeout>;
        maxConnections?: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
        maxRequests?: pulumi.Input<number>;
        maxRequestsPerConnection?: pulumi.Input<number>;
        maxRetries?: pulumi.Input<number>;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookie>;
        httpHeaderName?: pulumi.Input<string>;
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        ttl?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceIap {
        oauth2ClientId: pulumi.Input<string>;
        oauth2ClientSecret: pulumi.Input<string>;
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface BackendServiceLogConfig {
        enable?: pulumi.Input<boolean>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionBaseEjectionTime>;
        consecutiveErrors?: pulumi.Input<number>;
        consecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingSuccessRate?: pulumi.Input<number>;
        interval?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionInterval>;
        maxEjectionPercent?: pulumi.Input<number>;
        successRateMinimumHosts?: pulumi.Input<number>;
        successRateRequestVolume?: pulumi.Input<number>;
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/global/externalVpnGateways/{{name}}`
         */
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface FirewallAllow {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface FirewallDeny {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
         */
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface ImageGuestOsFeature {
        type: pulumi.Input<string>;
    }

    export interface ImageRawDisk {
        containerType?: pulumi.Input<string>;
        sha1?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceAttachedDisk {
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceBootDisk {
        autoDelete?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        initializeParams?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParams>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParams {
        image?: pulumi.Input<string>;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels?: pulumi.Input<{[key: string]: any}>;
        size?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        initializeParams?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParams>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: any}>;
        size?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        healthCheck: pulumi.Input<string>;
        initialDelaySec: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        maxSurgeFixed?: pulumi.Input<number>;
        maxSurgePercent?: pulumi.Input<number>;
        maxUnavailableFixed?: pulumi.Input<number>;
        maxUnavailablePercent?: pulumi.Input<number>;
        minReadySec?: pulumi.Input<number>;
        minimalAction: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerVersion {
        instanceTemplate: pulumi.Input<string>;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: pulumi.Input<string>;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: pulumi.Input<inputs.compute.InstanceGroupManagerVersionTargetSize>;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        fixed?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name of the instance group. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface InstanceGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceScratchDisk {
        interface: pulumi.Input<string>;
    }

    export interface InstanceServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateDisk {
        autoDelete?: pulumi.Input<boolean>;
        boot?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskDiskEncryptionKey>;
        diskName?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        interface?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
        sourceImage?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        kmsKeySelfLink: pulumi.Input<string>;
    }

    export interface InstanceTemplateGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q?: pulumi.Input<number>;
    }

    export interface ManagedSslCertificateManaged {
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MangedSslCertificateManaged {
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NodeGroupAutoscalingPolicy {
        maxNodes?: pulumi.Input<number>;
        minNodes?: pulumi.Input<number>;
        mode?: pulumi.Input<string>;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: pulumi.Input<string>;
        localSsd?: pulumi.Input<string>;
        memory?: pulumi.Input<string>;
    }

    export interface NodeTemplateServerBinding {
        type: pulumi.Input<string>;
    }

    export interface PacketMirroringCollectorIlb {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringFilter {
        cidrRanges?: pulumi.Input<pulumi.Input<string>[]>;
        ipProtocols?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResources {
        instances?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesInstance>[]>;
        subnetworks?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesSubnetwork>[]>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResourcesInstance {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringNetwork {
        url: pulumi.Input<string>;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceBackend {
        balancingMode?: pulumi.Input<string>;
        capacityScaler?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        failover?: pulumi.Input<boolean>;
        group: pulumi.Input<string>;
        maxConnections?: pulumi.Input<number>;
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        maxConnectionsPerInstance?: pulumi.Input<number>;
        maxRate?: pulumi.Input<number>;
        maxRatePerEndpoint?: pulumi.Input<number>;
        maxRatePerInstance?: pulumi.Input<number>;
        maxUtilization?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakers {
        connectTimeout?: pulumi.Input<inputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout>;
        maxConnections?: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
        maxRequests?: pulumi.Input<number>;
        maxRequestsPerConnection?: pulumi.Input<number>;
        maxRetries?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConsistentHash {
        httpCookie?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookie>;
        httpHeaderName?: pulumi.Input<string>;
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        ttl?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: pulumi.Input<boolean>;
        dropTrafficIfUnhealthy?: pulumi.Input<boolean>;
        failoverRatio?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceLogConfig {
        enable?: pulumi.Input<boolean>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetection {
        baseEjectionTime?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime>;
        consecutiveErrors?: pulumi.Input<number>;
        consecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingSuccessRate?: pulumi.Input<number>;
        interval?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionInterval>;
        maxEjectionPercent?: pulumi.Input<number>;
        successRateMinimumHosts?: pulumi.Input<number>;
        successRateRequestVolume?: pulumi.Input<number>;
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        healthCheck: pulumi.Input<string>;
        initialDelaySec: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        instanceRedistributionType?: pulumi.Input<string>;
        maxSurgeFixed?: pulumi.Input<number>;
        maxSurgePercent?: pulumi.Input<number>;
        maxUnavailableFixed?: pulumi.Input<number>;
        maxUnavailablePercent?: pulumi.Input<number>;
        minReadySec?: pulumi.Input<number>;
        minimalAction: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerVersion {
        instanceTemplate: pulumi.Input<string>;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: pulumi.Input<string>;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: pulumi.Input<inputs.compute.RegionInstanceGroupManagerVersionTargetSize>;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        fixed?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface RegionUrlMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRule>[]>;
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRule>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: pulumi.Input<number>;
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction>;
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule>[]>;
        priority: pulumi.Input<number>;
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: pulumi.Input<string>;
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        ignoreCase?: pulumi.Input<boolean>;
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        prefixMatch?: pulumi.Input<string>;
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        invertMatch?: pulumi.Input<boolean>;
        prefixMatch?: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        rangeMatch?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        regexMatch?: pulumi.Input<string>;
        suffixMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: pulumi.Input<number>;
        rangeStart: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled?: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: pulumi.Input<number>;
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservation {
        count: pulumi.Input<number>;
        inUseCount?: pulumi.Input<number>;
        instanceProperties: pulumi.Input<inputs.compute.ReservationSpecificReservationInstanceProperties>;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator>[]>;
        localSsds?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd>[]>;
        machineType: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: pulumi.Input<number>;
        interface?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy>;
        schedule: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySchedule>;
        snapshotProperties?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: pulumi.Input<number>;
        onSourceDiskDelete?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule>;
        hourlySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule>;
        weeklySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: pulumi.Input<pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek>[]>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: pulumi.Input<boolean>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        storageLocations?: pulumi.Input<string>;
    }

    export interface RouterBgp {
        advertiseMode?: pulumi.Input<string>;
        advertisedGroups?: pulumi.Input<pulumi.Input<string>[]>;
        advertisedIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.RouterBgpAdvertisedIpRange>[]>;
        asn: pulumi.Input<number>;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range: pulumi.Input<string>;
    }

    export interface RouterNatLogConfig {
        enable: pulumi.Input<boolean>;
        filter: pulumi.Input<string>;
    }

    export interface RouterNatSubnetwork {
        name: pulumi.Input<string>;
        secondaryIpRangeNames?: pulumi.Input<pulumi.Input<string>[]>;
        sourceIpRangesToNats: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range: pulumi.Input<string>;
    }

    export interface SecurityPolicyRule {
        action: pulumi.Input<string>;
        /**
         * An optional description of this security policy. Max size is 2048.
         */
        description?: pulumi.Input<string>;
        match: pulumi.Input<inputs.compute.SecurityPolicyRuleMatch>;
        preview?: pulumi.Input<boolean>;
        priority: pulumi.Input<number>;
    }

    export interface SecurityPolicyRuleMatch {
        config?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchConfig>;
        expr?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchExpr>;
        versionedExpr?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatchConfig {
        srcIpRanges: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyRuleMatchExpr {
        expression: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationCustomAccount>;
        googleAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationGoogleAccount>;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: pulumi.Input<string>;
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: pulumi.Input<number>;
        scheduleTime?: pulumi.Input<string>;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: pulumi.Input<string>;
    }

    export interface SubnetworkIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubnetworkIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: pulumi.Input<string>;
        flowSampling?: pulumi.Input<number>;
        metadata?: pulumi.Input<string>;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: pulumi.Input<string>;
        rangeName: pulumi.Input<string>;
    }

    export interface URLMapHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface URLMapPathMatcher {
        defaultService?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherHeaderAction>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRule>[]>;
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRule>[]>;
    }

    export interface URLMapPathMatcherHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: pulumi.Input<number>;
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRule {
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderAction>;
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRule>[]>;
        priority: pulumi.Input<number>;
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: pulumi.Input<string>;
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        ignoreCase?: pulumi.Input<boolean>;
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        prefixMatch?: pulumi.Input<string>;
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        invertMatch?: pulumi.Input<boolean>;
        prefixMatch?: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        rangeMatch?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        regexMatch?: pulumi.Input<string>;
        suffixMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: pulumi.Input<number>;
        rangeStart: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled?: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: pulumi.Input<number>;
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface URLMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        cloudrunConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigCloudrunConfig>;
        dnsCacheConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigDnsCacheConfig>;
        horizontalPodAutoscaling?: pulumi.Input<inputs.container.ClusterAddonsConfigHorizontalPodAutoscaling>;
        httpLoadBalancing?: pulumi.Input<inputs.container.ClusterAddonsConfigHttpLoadBalancing>;
        istioConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigIstioConfig>;
        networkPolicyConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigNetworkPolicyConfig>;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigDnsCacheConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigIstioConfig {
        auth?: pulumi.Input<string>;
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        securityGroup: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscaling {
        autoProvisioningDefaults?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults>;
        autoscalingProfile?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
        resourceLimits?: pulumi.Input<pulumi.Input<inputs.container.ClusterClusterAutoscalingResourceLimit>[]>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        serviceAccount?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        maximum?: pulumi.Input<number>;
        minimum?: pulumi.Input<number>;
        resourceType: pulumi.Input<string>;
    }

    export interface ClusterDatabaseEncryption {
        keyName?: pulumi.Input<string>;
        state: pulumi.Input<string>;
    }

    export interface ClusterIpAllocationPolicy {
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        clusterSecondaryRangeName?: pulumi.Input<string>;
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        servicesSecondaryRangeName?: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicy {
        dailyMaintenanceWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow>;
        recurringWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyRecurringWindow>;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration?: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: pulumi.Input<string>;
        recurrence: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMasterAuth {
        clientCertificate?: pulumi.Input<string>;
        clientCertificateConfig?: pulumi.Input<inputs.container.ClusterMasterAuthClientCertificateConfig>;
        clientKey?: pulumi.Input<string>;
        clusterCaCertificate?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: pulumi.Input<boolean>;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        cidrBlocks?: pulumi.Input<pulumi.Input<inputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock>[]>;
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: pulumi.Input<string>;
        displayName?: pulumi.Input<string>;
    }

    export interface ClusterNetworkPolicy {
        enabled: pulumi.Input<boolean>;
        provider?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfig {
        bootDiskKmsKey?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodeConfigShieldedInstanceConfig>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterNodePool {
        autoscaling?: pulumi.Input<inputs.container.ClusterNodePoolAutoscaling>;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount?: pulumi.Input<number>;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls?: pulumi.Input<pulumi.Input<string>[]>;
        management?: pulumi.Input<inputs.container.ClusterNodePoolManagement>;
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name?: pulumi.Input<string>;
        namePrefix?: pulumi.Input<string>;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations?: pulumi.Input<pulumi.Input<string>[]>;
        upgradeSettings?: pulumi.Input<inputs.container.ClusterNodePoolUpgradeSettings>;
        version?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: pulumi.Input<number>;
        minNodeCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: pulumi.Input<boolean>;
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfig {
        bootDiskKmsKey?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterNodePoolUpgradeSettings {
        maxSurge: pulumi.Input<number>;
        maxUnavailable: pulumi.Input<number>;
    }

    export interface ClusterPodSecurityPolicyConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterPrivateClusterConfig {
        enablePrivateEndpoint: pulumi.Input<boolean>;
        enablePrivateNodes?: pulumi.Input<boolean>;
        masterIpv4CidrBlock?: pulumi.Input<string>;
        peeringName?: pulumi.Input<string>;
        privateEndpoint?: pulumi.Input<string>;
        publicEndpoint?: pulumi.Input<string>;
    }

    export interface ClusterReleaseChannel {
        channel: pulumi.Input<string>;
    }

    export interface ClusterResourceUsageExportConfig {
        bigqueryDestination: pulumi.Input<inputs.container.ClusterResourceUsageExportConfigBigqueryDestination>;
        enableNetworkEgressMetering?: pulumi.Input<boolean>;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: pulumi.Input<string>;
    }

    export interface ClusterVerticalPodAutoscaling {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterWorkloadIdentityConfig {
        identityNamespace: pulumi.Input<string>;
    }

    export interface NodePoolAutoscaling {
        maxNodeCount: pulumi.Input<number>;
        minNodeCount: pulumi.Input<number>;
    }

    export interface NodePoolManagement {
        autoRepair?: pulumi.Input<boolean>;
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfig {
        bootDiskKmsKey?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        shieldedInstanceConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigShieldedInstanceConfig>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface NodePoolUpgradeSettings {
        maxSurge: pulumi.Input<number>;
        maxUnavailable: pulumi.Input<number>;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: pulumi.Input<inputs.containeranalysis.NoteAttestationAuthorityHint>;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: pulumi.Input<string>;
    }
}

export namespace datafusion {
    export interface InstanceNetworkConfig {
        ipAllocation: pulumi.Input<string>;
        network: pulumi.Input<string>;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: pulumi.Input<string>;
        yarnConfig: pulumi.Input<inputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig>;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: pulumi.Input<string>;
        scaleDownFactor: pulumi.Input<number>;
        scaleDownMinWorkerFraction?: pulumi.Input<number>;
        scaleUpFactor: pulumi.Input<number>;
        scaleUpMinWorkerFraction?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfig {
        autoscalingConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAutoscalingConfig>;
        bucket?: pulumi.Input<string>;
        encryptionConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigEncryptionConfig>;
        gceClusterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfig>;
        initializationActions?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigInitializationAction>[]>;
        lifecycleConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigLifecycleConfig>;
        masterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfig>;
        preemptibleWorkerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig>;
        securityConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfig>;
        softwareConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSoftwareConfig>;
        stagingBucket?: pulumi.Input<string>;
        workerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfig>;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        policyUri: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        kmsKeyName: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        internalIpOnly?: pulumi.Input<boolean>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        network?: pulumi.Input<string>;
        serviceAccount?: pulumi.Input<string>;
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        subnetwork?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        zone?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: pulumi.Input<string>;
        timeoutSec?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        autoDeleteTime?: pulumi.Input<string>;
        idleDeleteTtl?: pulumi.Input<string>;
        idleStartTime?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfig {
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigAccelerator>[]>;
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig>;
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        machineType?: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigSecurityConfig {
        kerberosConfig: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig>;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        crossRealmTrustAdminServer?: pulumi.Input<string>;
        crossRealmTrustKdc?: pulumi.Input<string>;
        crossRealmTrustRealm?: pulumi.Input<string>;
        crossRealmTrustSharedPasswordUri?: pulumi.Input<string>;
        enableKerberos?: pulumi.Input<boolean>;
        kdcDbKeyUri?: pulumi.Input<string>;
        keyPasswordUri?: pulumi.Input<string>;
        keystorePasswordUri?: pulumi.Input<string>;
        keystoreUri?: pulumi.Input<string>;
        kmsKeyUri: pulumi.Input<string>;
        realm?: pulumi.Input<string>;
        rootPrincipalPasswordUri: pulumi.Input<string>;
        tgtLifetimeHours?: pulumi.Input<number>;
        truststorePasswordUri?: pulumi.Input<string>;
        truststoreUri?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        imageVersion?: pulumi.Input<string>;
        optionalComponents?: pulumi.Input<pulumi.Input<string>[]>;
        overrideProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        properties?: pulumi.Input<{[key: string]: any}>;
    }

    export interface ClusterClusterConfigWorkerConfig {
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator>[]>;
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig>;
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        machineType?: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ClusterIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobHadoopConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobHadoopConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        mainJarFileUri?: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHiveConfig {
        continueOnFailure?: pulumi.Input<boolean>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobPigConfig {
        continueOnFailure?: pulumi.Input<boolean>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPigConfigLoggingConfig>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPlacement {
        clusterName: pulumi.Input<string>;
        clusterUuid?: pulumi.Input<string>;
    }

    export interface JobPysparkConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPysparkConfigLoggingConfig>;
        mainPythonFileUri: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobReference {
        jobId?: pulumi.Input<string>;
    }

    export interface JobScheduling {
        maxFailuresPerHour: pulumi.Input<number>;
    }

    export interface JobSparkConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparkConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        mainJarFileUri?: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfig {
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparksqlConfigLoggingConfig>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobStatus {
        details?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
        stateStartTime?: pulumi.Input<string>;
        substate?: pulumi.Input<string>;
    }
}

export namespace datastore {
    export interface DataStoreIndexProperty {
        direction: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeploymentTarget {
        config: pulumi.Input<inputs.deploymentmanager.DeploymentTargetConfig>;
        imports?: pulumi.Input<pulumi.Input<inputs.deploymentmanager.DeploymentTargetImport>[]>;
    }

    export interface DeploymentTargetConfig {
        content: pulumi.Input<string>;
    }

    export interface DeploymentTargetImport {
        content?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }
}

export namespace dns {
    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneDnssecConfigDefaultKeySpec>[]>;
        kind?: pulumi.Input<string>;
        nonExistence?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: pulumi.Input<string>;
        keyLength?: pulumi.Input<number>;
        keyType?: pulumi.Input<string>;
        kind?: pulumi.Input<string>;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneForwardingConfigTargetNameServer>[]>;
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        forwardingPath?: pulumi.Input<string>;
        ipv4Address: pulumi.Input<string>;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork: pulumi.Input<inputs.dns.ManagedZonePeeringConfigTargetNetwork>;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl: pulumi.Input<string>;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks: pulumi.Input<pulumi.Input<inputs.dns.ManagedZonePrivateVisibilityConfigNetwork>[]>;
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl: pulumi.Input<string>;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.PolicyAlternativeNameServerConfigTargetNameServer>[]>;
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address: pulumi.Input<string>;
    }

    export interface PolicyNetwork {
        networkUrl: pulumi.Input<string>;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods?: pulumi.Input<pulumi.Input<inputs.endpoints.ServiceApiMethod>[]>;
        name?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface ServiceApiMethod {
        name?: pulumi.Input<string>;
        requestType?: pulumi.Input<string>;
        responseType?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
    }

    export interface ServiceEndpoint {
        address?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: pulumi.Input<number>;
        name: pulumi.Input<string>;
    }

    export interface InstanceNetwork {
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        modes: pulumi.Input<pulumi.Input<string>[]>;
        network: pulumi.Input<string>;
        reservedIpRange?: pulumi.Input<string>;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: pulumi.Input<string>;
        fieldPath?: pulumi.Input<string>;
        order?: pulumi.Input<string>;
    }
}

export namespace folder {
    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace gameservices {
    export interface GameServerClusterConnectionInfo {
        gkeClusterReference: pulumi.Input<inputs.gameservices.GameServerClusterConnectionInfoGkeClusterReference>;
        namespace: pulumi.Input<string>;
    }

    export interface GameServerClusterConnectionInfoGkeClusterReference {
        cluster: pulumi.Input<string>;
    }

    export interface GameServerConfigFleetConfig {
        fleetSpec: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface GameServerConfigScalingConfig {
        fleetAutoscalerSpec: pulumi.Input<string>;
        name: pulumi.Input<string>;
        schedules?: pulumi.Input<pulumi.Input<inputs.gameservices.GameServerConfigScalingConfigSchedule>[]>;
        selectors?: pulumi.Input<pulumi.Input<inputs.gameservices.GameServerConfigScalingConfigSelector>[]>;
    }

    export interface GameServerConfigScalingConfigSchedule {
        cronJobDuration?: pulumi.Input<string>;
        cronSpec?: pulumi.Input<string>;
        endTime?: pulumi.Input<string>;
        startTime?: pulumi.Input<string>;
    }

    export interface GameServerConfigScalingConfigSelector {
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverride {
        configVersion?: pulumi.Input<string>;
        realmsSelector?: pulumi.Input<inputs.gameservices.GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector>;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector {
        realms?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace healthcare {
    export interface DatasetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatasetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface FhirStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: pulumi.Input<boolean>;
        segmentTerminator?: pulumi.Input<string>;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AppEngineServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace identityplatform {
    export interface InboundSamlConfigIdpConfig {
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate>[]>;
        idpEntityId: pulumi.Input<string>;
        signRequest?: pulumi.Input<boolean>;
        ssoUrl: pulumi.Input<string>;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfig {
        callbackUri?: pulumi.Input<string>;
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigSpConfigSpCertificate>[]>;
        spEntityId?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate>[]>;
        idpEntityId: pulumi.Input<string>;
        signRequest?: pulumi.Input<boolean>;
        ssoUrl: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfig {
        callbackUri: pulumi.Input<string>;
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate>[]>;
        spEntityId: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionTemplate {
        algorithm: pulumi.Input<string>;
        protectionLevel?: pulumi.Input<string>;
    }

    export interface KeyRingIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface KeyRingIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RegistryCredential {
        publicKeyCertificate: pulumi.Input<inputs.kms.RegistryCredentialPublicKeyCertificate>;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        certificate: pulumi.Input<string>;
        format: pulumi.Input<string>;
    }

    export interface RegistryEventNotificationConfigItem {
        pubsubTopicName: pulumi.Input<string>;
        subfolderMatches?: pulumi.Input<string>;
    }

    export interface RegistryHttpConfig {
        httpEnabledState: pulumi.Input<string>;
    }

    export interface RegistryMqttConfig {
        mqttEnabledState: pulumi.Input<string>;
    }

    export interface RegistryStateNotificationConfig {
        pubsubTopicName: pulumi.Input<string>;
    }
}

export namespace logging {
    export interface BillingAccountSinkBigqueryOptions {
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface FolderSinkBigqueryOptions {
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface MetricBucketOptions {
        explicitBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExplicitBuckets>;
        exponentialBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExponentialBuckets>;
        linearBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsLinearBuckets>;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: pulumi.Input<number>;
        numFiniteBuckets?: pulumi.Input<number>;
        scale?: pulumi.Input<number>;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: pulumi.Input<number>;
        offset?: pulumi.Input<number>;
        width?: pulumi.Input<number>;
    }

    export interface MetricMetricDescriptor {
        displayName?: pulumi.Input<string>;
        labels?: pulumi.Input<pulumi.Input<inputs.logging.MetricMetricDescriptorLabel>[]>;
        metricKind: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
        valueType: pulumi.Input<string>;
    }

    export interface MetricMetricDescriptorLabel {
        description?: pulumi.Input<string>;
        key: pulumi.Input<string>;
        valueType?: pulumi.Input<string>;
    }

    export interface OrganizationSinkBigqueryOptions {
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface ProjectSinkBigqueryOptions {
        usePartitionedTables: pulumi.Input<boolean>;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name: pulumi.Input<string>;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsent>;
        conditionThreshold?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThreshold>;
        displayName: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentAggregation>[]>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentTrigger>;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdAggregation>[]>;
        comparison: pulumi.Input<string>;
        denominatorAggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation>[]>;
        denominatorFilter?: pulumi.Input<string>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        thresholdValue?: pulumi.Input<number>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdTrigger>;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime?: pulumi.Input<string>;
        mutatedBy?: pulumi.Input<string>;
    }

    export interface AlertPolicyDocumentation {
        content?: pulumi.Input<string>;
        mimeType?: pulumi.Input<string>;
    }

    export interface NotificationChannelSensitiveLabels {
        authToken?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        serviceKey?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigContentMatcher {
        content: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        maskHeaders?: pulumi.Input<boolean>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        useSsl?: pulumi.Input<boolean>;
        validateSsl?: pulumi.Input<boolean>;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        type: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: pulumi.Input<string>;
        resourceType?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: pulumi.Input<number>;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: inputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        condition?: inputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamAuditConfigAuditLogConfig {
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        logType: pulumi.Input<string>;
    }

    export interface PolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface PolicyListPolicy {
        allow?: pulumi.Input<inputs.organizations.PolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.organizations.PolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface PolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace projects {
    export interface IAMAuditConfigAuditLogConfig {
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        logType: pulumi.Input<string>;
    }

    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace pubsub {
    export interface SubscriptionExpirationPolicy {
        ttl: pulumi.Input<string>;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfig {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        oidcToken?: pulumi.Input<inputs.pubsub.SubscriptionPushConfigOidcToken>;
        pushEndpoint: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfigOidcToken {
        audience?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface TopicIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConfigIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace secretmanager {
    export interface SecretIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SecretIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SecretReplication {
        automatic?: pulumi.Input<boolean>;
        userManaged?: pulumi.Input<inputs.secretmanager.SecretReplicationUserManaged>;
    }

    export interface SecretReplicationUserManaged {
        replicas: pulumi.Input<pulumi.Input<inputs.secretmanager.SecretReplicationUserManagedReplica>[]>;
    }

    export interface SecretReplicationUserManagedReplica {
        location: pulumi.Input<string>;
    }
}

export namespace serviceAccount {
    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryPubsubConfig {
        messageFormat: pulumi.Input<string>;
        serviceAccountEmail?: pulumi.Input<string>;
        topic: pulumi.Input<string>;
    }
}

export namespace spanner {
    export interface DatabaseIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatabaseIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress?: pulumi.Input<string>;
        timeToRetire?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        caCertificate?: pulumi.Input<string>;
        clientCertificate?: pulumi.Input<string>;
        clientKey?: pulumi.Input<string>;
        connectRetryInterval?: pulumi.Input<number>;
        dumpFilePath?: pulumi.Input<string>;
        failoverTarget?: pulumi.Input<boolean>;
        masterHeartbeatPeriod?: pulumi.Input<number>;
        password?: pulumi.Input<string>;
        sslCipher?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        verifyServerCertificate?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceServerCaCert {
        cert?: pulumi.Input<string>;
        commonName?: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        expirationTime?: pulumi.Input<string>;
        sha1Fingerprint?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettings {
        activationPolicy?: pulumi.Input<string>;
        authorizedGaeApplications?: pulumi.Input<pulumi.Input<string>[]>;
        availabilityType?: pulumi.Input<string>;
        backupConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsBackupConfiguration>;
        crashSafeReplication?: pulumi.Input<boolean>;
        databaseFlags?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsDatabaseFlag>[]>;
        diskAutoresize?: pulumi.Input<boolean>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        ipConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfiguration>;
        locationPreference?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsLocationPreference>;
        maintenanceWindow?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsMaintenanceWindow>;
        pricingPlan?: pulumi.Input<string>;
        replicationType?: pulumi.Input<string>;
        tier: pulumi.Input<string>;
        userLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        version?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        binaryLogEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        location?: pulumi.Input<string>;
        startTime?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * The name of the instance. If the name is left
         * blank, the provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork>[]>;
        ipv4Enabled?: pulumi.Input<boolean>;
        privateNetwork?: pulumi.Input<string>;
        requireSsl?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        expirationTime?: pulumi.Input<string>;
        /**
         * The name of the instance. If the name is left
         * blank, the provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        followGaeApplication?: pulumi.Input<string>;
        zone?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        day?: pulumi.Input<number>;
        hour?: pulumi.Input<number>;
        updateTrack?: pulumi.Input<string>;
    }
}

export namespace storage {
    export interface BucketCor {
        maxAgeSeconds?: pulumi.Input<number>;
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        origins?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BucketEncryption {
        defaultKmsKeyName: pulumi.Input<string>;
    }

    export interface BucketIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BucketIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BucketLifecycleRule {
        action: pulumi.Input<inputs.storage.BucketLifecycleRuleAction>;
        condition: pulumi.Input<inputs.storage.BucketLifecycleRuleCondition>;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of the new bucket. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface BucketLifecycleRuleCondition {
        age?: pulumi.Input<number>;
        createdBefore?: pulumi.Input<string>;
        matchesStorageClasses?: pulumi.Input<pulumi.Input<string>[]>;
        numNewerVersions?: pulumi.Input<number>;
        withState?: pulumi.Input<string>;
    }

    export interface BucketLogging {
        logBucket: pulumi.Input<string>;
        logObjectPrefix?: pulumi.Input<string>;
    }

    export interface BucketRetentionPolicy {
        isLocked?: pulumi.Input<boolean>;
        retentionPeriod: pulumi.Input<number>;
    }

    export interface BucketVersioning {
        enabled: pulumi.Input<boolean>;
    }

    export interface BucketWebsite {
        mainPageSuffix?: pulumi.Input<string>;
        notFoundPage?: pulumi.Input<string>;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface TransferJobSchedule {
        scheduleEndDate?: pulumi.Input<inputs.storage.TransferJobScheduleScheduleEndDate>;
        scheduleStartDate: pulumi.Input<inputs.storage.TransferJobScheduleScheduleStartDate>;
        startTimeOfDay?: pulumi.Input<inputs.storage.TransferJobScheduleStartTimeOfDay>;
    }

    export interface TransferJobScheduleScheduleEndDate {
        day: pulumi.Input<number>;
        month: pulumi.Input<number>;
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleScheduleStartDate {
        day: pulumi.Input<number>;
        month: pulumi.Input<number>;
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        hours: pulumi.Input<number>;
        minutes: pulumi.Input<number>;
        nanos: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface TransferJobTransferSpec {
        awsS3DataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSource>;
        gcsDataSink?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSink>;
        gcsDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSource>;
        httpDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecHttpDataSource>;
        objectConditions?: pulumi.Input<inputs.storage.TransferJobTransferSpecObjectConditions>;
        transferOptions?: pulumi.Input<inputs.storage.TransferJobTransferSpecTransferOptions>;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        awsAccessKey: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey>;
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        accessKeyId: pulumi.Input<string>;
        secretAccessKey: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        listUrl: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecObjectConditions {
        excludePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        includePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        maxTimeElapsedSinceLastModification?: pulumi.Input<string>;
        minTimeElapsedSinceLastModification?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecTransferOptions {
        deleteObjectsFromSourceAfterTransfer?: pulumi.Input<boolean>;
        deleteObjectsUniqueInSink?: pulumi.Input<boolean>;
        overwriteObjectsAlreadyExistingInSink?: pulumi.Input<boolean>;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface NodeSchedulingConfig {
        preemptible: pulumi.Input<boolean>;
    }
}
