// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";

export interface ProviderBatching {
    enableBatching?: pulumi.Input<boolean>;
    sendAfter?: pulumi.Input<string>;
}

export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: pulumi.Input<string>;
        conditions: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicCondition>[]>;
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy>;
        ipSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
        members?: pulumi.Input<pulumi.Input<string>[]>;
        negate?: pulumi.Input<boolean>;
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        requiredAccessLevels?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint>[]>;
        requireAdminApproval?: pulumi.Input<boolean>;
        requireCorpOwned?: pulumi.Input<boolean>;
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: pulumi.Input<string>;
        osType: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
        vpcAccessibleServices?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusVpcAccessibleServices>;
    }

    export interface ServicePerimeterStatusVpcAccessibleServices {
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        enableRestriction?: pulumi.Input<boolean>;
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: pulumi.Input<boolean>;
    }

    export interface ApplicationIap {
        oauth2ClientId: pulumi.Input<string>;
        oauth2ClientSecret: pulumi.Input<string>;
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRule {
        domain?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        domain?: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }

    export interface DomainMappingResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingSslSettings {
        certificateId?: pulumi.Input<string>;
        pendingManagedCertificateId?: pulumi.Input<string>;
        sslManagementType: pulumi.Input<string>;
    }

    export interface EngineSplitTrafficSplit {
        allocations: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        shardBy?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionApiConfig {
        authFailAction?: pulumi.Input<string>;
        login?: pulumi.Input<string>;
        script: pulumi.Input<string>;
        securityLevel?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionAutomaticScaling {
        coolDownPeriod?: pulumi.Input<string>;
        cpuUtilization: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingCpuUtilization>;
        diskUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingDiskUtilization>;
        maxConcurrentRequests?: pulumi.Input<number>;
        maxIdleInstances?: pulumi.Input<number>;
        maxPendingLatency?: pulumi.Input<string>;
        maxTotalInstances?: pulumi.Input<number>;
        minIdleInstances?: pulumi.Input<number>;
        minPendingLatency?: pulumi.Input<string>;
        minTotalInstances?: pulumi.Input<number>;
        networkUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingNetworkUtilization>;
        requestUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingRequestUtilization>;
    }

    export interface FlexibleAppVersionAutomaticScalingCpuUtilization {
        aggregationWindowLength?: pulumi.Input<string>;
        targetUtilization: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingDiskUtilization {
        targetReadBytesPerSecond?: pulumi.Input<number>;
        targetReadOpsPerSecond?: pulumi.Input<number>;
        targetWriteBytesPerSecond?: pulumi.Input<number>;
        targetWriteOpsPerSecond?: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingNetworkUtilization {
        targetReceivedBytesPerSecond?: pulumi.Input<number>;
        targetReceivedPacketsPerSecond?: pulumi.Input<number>;
        targetSentBytesPerSecond?: pulumi.Input<number>;
        targetSentPacketsPerSecond?: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingRequestUtilization {
        targetConcurrentRequests?: pulumi.Input<number>;
        targetRequestCountPerSecond?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeployment {
        cloudBuildOptions?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentCloudBuildOptions>;
        container?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentContainer>;
        files?: pulumi.Input<pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentFile>[]>;
        zip?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentZip>;
    }

    export interface FlexibleAppVersionDeploymentCloudBuildOptions {
        appYamlPath: pulumi.Input<string>;
        cloudBuildTimeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentContainer {
        image: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        sha1Sum?: pulumi.Input<string>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentZip {
        filesCount?: pulumi.Input<number>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionEndpointsApiService {
        configId?: pulumi.Input<string>;
        disableTraceSampling?: pulumi.Input<boolean>;
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        rolloutStrategy?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionEntrypoint {
        shell: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionLivenessCheck {
        checkInterval?: pulumi.Input<string>;
        failureThreshold?: pulumi.Input<number>;
        host?: pulumi.Input<string>;
        initialDelay?: pulumi.Input<string>;
        path: pulumi.Input<string>;
        successThreshold?: pulumi.Input<number>;
        timeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionManualScaling {
        instances: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionNetwork {
        forwardedPorts?: pulumi.Input<pulumi.Input<string>[]>;
        instanceTag?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        sessionAffinity?: pulumi.Input<boolean>;
        subnetwork?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionReadinessCheck {
        appStartTimeout?: pulumi.Input<string>;
        checkInterval?: pulumi.Input<string>;
        failureThreshold?: pulumi.Input<number>;
        host?: pulumi.Input<string>;
        path: pulumi.Input<string>;
        successThreshold?: pulumi.Input<number>;
        timeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionResources {
        cpu?: pulumi.Input<number>;
        diskGb?: pulumi.Input<number>;
        memoryGb?: pulumi.Input<number>;
        volumes?: pulumi.Input<pulumi.Input<inputs.appengine.FlexibleAppVersionResourcesVolume>[]>;
    }

    export interface FlexibleAppVersionResourcesVolume {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        sizeGb: pulumi.Input<number>;
        volumeType: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionVpcAccessConnector {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeployment {
        files?: pulumi.Input<pulumi.Input<inputs.appengine.StandardAppVersionDeploymentFile>[]>;
        zip?: pulumi.Input<inputs.appengine.StandardAppVersionDeploymentZip>;
    }

    export interface StandardAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        sha1Sum?: pulumi.Input<string>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: pulumi.Input<number>;
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionEntrypoint {
        shell: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: pulumi.Input<string>;
        login?: pulumi.Input<string>;
        redirectHttpResponseCode?: pulumi.Input<string>;
        script?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerScript>;
        securityLevel?: pulumi.Input<string>;
        staticFiles?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerStaticFiles>;
        urlRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: pulumi.Input<boolean>;
        expiration?: pulumi.Input<string>;
        httpHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        mimeType?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        requireMatchingFile?: pulumi.Input<boolean>;
        uploadPathRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionLibrary {
        /**
         * The identifier for this object. Format specified above.
         */
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: pulumi.Input<boolean>;
        clusterId: pulumi.Input<string>;
    }

    export interface DatasetAccess {
        domain?: pulumi.Input<string>;
        groupByEmail?: pulumi.Input<string>;
        role?: pulumi.Input<string>;
        specialGroup?: pulumi.Input<string>;
        userByEmail?: pulumi.Input<string>;
        view?: pulumi.Input<inputs.bigquery.DatasetAccessView>;
    }

    export interface DatasetAccessView {
        datasetId: pulumi.Input<string>;
        projectId: pulumi.Input<string>;
        tableId: pulumi.Input<string>;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        kmsKeyName: pulumi.Input<string>;
    }

    export interface TableEncryptionConfiguration {
        /**
         * The self link or full name of a key which should be used to
         * encrypt this table.  Note that the default bigquery service account will need to have
         * encrypt/decrypt permissions on this key - you may want to see the
         * `gcp.bigquery.getDefaultServiceAccount` datasource and the
         * `gcp.kms.CryptoKeyIAMBinding` resource.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface TableExternalDataConfiguration {
        /**
         * - Let BigQuery try to autodetect the schema
         * and format of the table.
         */
        autodetect: pulumi.Input<boolean>;
        /**
         * The compression type of the data source.
         * Valid values are "NONE" or "GZIP".
         */
        compression?: pulumi.Input<string>;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "CSV". Structure is documented below.
         */
        csvOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationCsvOptions>;
        /**
         * Additional options if
         * `sourceFormat` is set to "GOOGLE_SHEETS". Structure is
         * documented below.
         */
        googleSheetsOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions>;
        /**
         * Indicates if BigQuery should
         * allow extra values that are not represented in the table schema.
         * If true, the extra values are ignored. If false, records with
         * extra columns are treated as bad records, and if there are too
         * many bad records, an invalid error is returned in the job result.
         * The default value is false.
         */
        ignoreUnknownValues?: pulumi.Input<boolean>;
        /**
         * The maximum number of bad records that
         * BigQuery can ignore when reading data.
         */
        maxBadRecords?: pulumi.Input<number>;
        /**
         * The data format. Supported values are:
         * "CSV", "GOOGLE_SHEETS", "NEWLINE_DELIMITED_JSON", "AVRO", "PARQUET",
         * and "DATSTORE_BACKUP". To use "GOOGLE_SHEETS"
         * the `scopes` must include
         * "https://www.googleapis.com/auth/drive.readonly".
         */
        sourceFormat: pulumi.Input<string>;
        /**
         * A list of the fully-qualified URIs that point to
         * your data in Google Cloud.
         */
        sourceUris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableExternalDataConfigurationCsvOptions {
        /**
         * Indicates if BigQuery should accept rows
         * that are missing trailing optional columns.
         */
        allowJaggedRows?: pulumi.Input<boolean>;
        /**
         * Indicates if BigQuery should allow
         * quoted data sections that contain newline characters in a CSV file.
         * The default value is false.
         */
        allowQuotedNewlines?: pulumi.Input<boolean>;
        /**
         * The character encoding of the data. The supported
         * values are UTF-8 or ISO-8859-1.
         */
        encoding?: pulumi.Input<string>;
        /**
         * The separator for fields in a CSV file.
         */
        fieldDelimiter?: pulumi.Input<string>;
        /**
         * The value that is used to quote data sections in a
         * CSV file. If your data does not contain quoted sections, set the
         * property value to an empty string. If your data contains quoted newline
         * characters, you must also set the `allowQuotedNewlines` property to true.
         * The API-side default is `"`, specified in the provider escaped as `\"`. Due to
         * limitations with default values, this value is required to be
         * explicitly set.
         */
        quote: pulumi.Input<string>;
        /**
         * The number of rows at the top of the sheet
         * that BigQuery will skip when reading the data. At least one of `range` or
         * `skipLeadingRows` must be set.
         */
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        /**
         * Information required to partition based on ranges.
         * Structure is documented below.
         */
        range?: pulumi.Input<string>;
        /**
         * The number of rows at the top of the sheet
         * that BigQuery will skip when reading the data. At least one of `range` or
         * `skipLeadingRows` must be set.
         */
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableRangePartitioning {
        /**
         * The field used to determine how to create a range-based
         * partition.
         */
        field: pulumi.Input<string>;
        /**
         * Information required to partition based on ranges.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.bigquery.TableRangePartitioningRange>;
    }

    export interface TableRangePartitioningRange {
        /**
         * End of the range partitioning, exclusive.
         */
        end: pulumi.Input<number>;
        /**
         * The width of each range within the partition.
         */
        interval: pulumi.Input<number>;
        /**
         * Start of the range partitioning, inclusive.
         */
        start: pulumi.Input<number>;
    }

    export interface TableTimePartitioning {
        /**
         * Number of milliseconds for which to keep the
         * storage for a partition.
         */
        expirationMs?: pulumi.Input<number>;
        /**
         * The field used to determine how to create a range-based
         * partition.
         */
        field?: pulumi.Input<string>;
        /**
         * If set to true, queries over this table
         * require a partition filter that can be used for partition elimination to be
         * specified.
         */
        requirePartitionFilter?: pulumi.Input<boolean>;
        /**
         * The only type supported is DAY, which will generate
         * one partition per day based on data loading time.
         */
        type: pulumi.Input<string>;
    }

    export interface TableView {
        /**
         * A query that BigQuery executes when the view is referenced.
         */
        query: pulumi.Input<string>;
        /**
         * Specifies whether to use BigQuery's legacy SQL for this view.
         * The default value is true. If set to false, the view will use BigQuery's standard SQL.
         */
        useLegacySql?: pulumi.Input<boolean>;
    }
}

export namespace bigtable {
    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         */
        days: pulumi.Input<number>;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         */
        number: pulumi.Input<number>;
    }

    export interface InstanceCluster {
        /**
         * The ID of the Cloud Bigtable cluster.
         */
        clusterId: pulumi.Input<string>;
        /**
         * The number of nodes in your Cloud Bigtable cluster.
         * Required, with a minimum of `3` for a `PRODUCTION` instance. Must be left unset
         * for a `DEVELOPMENT` instance.
         */
        numNodes?: pulumi.Input<number>;
        /**
         * The storage type to use. One of `"SSD"` or
         * `"HDD"`. Defaults to `"SSD"`.
         */
        storageType?: pulumi.Input<string>;
        /**
         * The zone to create the Cloud Bigtable cluster in. Each
         * cluster must have a different zone in the same region. Zones that support
         * Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
         */
        zone: pulumi.Input<string>;
    }

    export interface InstanceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: pulumi.Input<string>;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AccountIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BudgetAllUpdatesRule {
        pubsubTopic: pulumi.Input<string>;
        schemaVersion?: pulumi.Input<string>;
    }

    export interface BudgetAmount {
        specifiedAmount: pulumi.Input<inputs.billing.BudgetAmountSpecifiedAmount>;
    }

    export interface BudgetAmountSpecifiedAmount {
        currencyCode?: pulumi.Input<string>;
        nanos?: pulumi.Input<number>;
        units?: pulumi.Input<string>;
    }

    export interface BudgetBudgetFilter {
        creditTypesTreatment?: pulumi.Input<string>;
        projects?: pulumi.Input<pulumi.Input<string>[]>;
        services?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BudgetThresholdRule {
        spendBasis?: pulumi.Input<string>;
        thresholdPercent: pulumi.Input<number>;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail?: pulumi.Input<string>;
        noteReference: pulumi.Input<string>;
        publicKeys?: pulumi.Input<pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey>[]>;
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: pulumi.Input<string>;
        comment?: pulumi.Input<string>;
        /**
         * an identifier for the resource with format `projects/{{project}}/attestors/{{name}}`
         */
        id?: pulumi.Input<string>;
        pkixPublicKey?: pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey>;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: pulumi.Input<string>;
        signatureAlgorithm?: pulumi.Input<string>;
    }

    export interface AttestorIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AttestorIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern: pulumi.Input<string>;
    }

    export interface PolicyClusterAdmissionRule {
        /**
         * The identifier for this object. Format specified above.
         */
        cluster: pulumi.Input<string>;
        enforcementMode: pulumi.Input<string>;
        evaluationMode: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: pulumi.Input<string>;
        evaluationMode: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: pulumi.Input<pulumi.Input<string>[]>;
        steps: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStep>[]>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        timeout?: pulumi.Input<string>;
    }

    export interface TriggerBuildStep {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        dir?: pulumi.Input<string>;
        entrypoint?: pulumi.Input<string>;
        envs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * an identifier for the resource with format `projects/{{project}}/triggers/{{trigger_id}}`
         */
        id?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        secretEnvs?: pulumi.Input<pulumi.Input<string>[]>;
        timeout?: pulumi.Input<string>;
        timing?: pulumi.Input<string>;
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStepVolume>[]>;
        waitFors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TriggerBuildStepVolume {
        name: pulumi.Input<string>;
        path: pulumi.Input<string>;
    }

    export interface TriggerGithub {
        name?: pulumi.Input<string>;
        owner?: pulumi.Input<string>;
        pullRequest?: pulumi.Input<inputs.cloudbuild.TriggerGithubPullRequest>;
        push?: pulumi.Input<inputs.cloudbuild.TriggerGithubPush>;
    }

    export interface TriggerGithubPullRequest {
        branch: pulumi.Input<string>;
        commentControl?: pulumi.Input<string>;
    }

    export interface TriggerGithubPush {
        branch?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
    }

    export interface TriggerTriggerTemplate {
        branchName?: pulumi.Input<string>;
        commitSha?: pulumi.Input<string>;
        dir?: pulumi.Input<string>;
        projectId?: pulumi.Input<string>;
        repoName?: pulumi.Input<string>;
        tagName?: pulumi.Input<string>;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
         * full reference of accepted triggers.
         */
        eventType: pulumi.Input<string>;
        /**
         * Specifies policy for failed executions. Structure is documented below.
         */
        failurePolicy?: pulumi.Input<inputs.cloudfunctions.FunctionEventTriggerFailurePolicy>;
        /**
         * Required. The name or partial URI of the resource from
         * which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
         */
        resource: pulumi.Input<string>;
    }

    export interface FunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure. Defaults to `false`.
         */
        retry: pulumi.Input<boolean>;
    }

    export interface FunctionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionSourceRepository {
        deployedUrl?: pulumi.Input<string>;
        /**
         * The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:
         */
        url: pulumi.Input<string>;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface DomainMappingSpec {
        certificateMode?: pulumi.Input<string>;
        forceOverride?: pulumi.Input<boolean>;
        routeName: pulumi.Input<string>;
    }

    export interface DomainMappingStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusCondition>[]>;
        mappedRouteName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        resourceRecords?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusResourceRecord>[]>;
    }

    export interface DomainMappingStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingStatusResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface IamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace?: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface ServiceStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceStatusCondition>[]>;
        latestCreatedRevisionName?: pulumi.Input<string>;
        latestReadyRevisionName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        url?: pulumi.Input<string>;
    }

    export interface ServiceStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface ServiceTemplate {
        metadata?: pulumi.Input<inputs.cloudrun.ServiceTemplateMetadata>;
        spec?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpec>;
    }

    export interface ServiceTemplateMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpec {
        containerConcurrency?: pulumi.Input<number>;
        containers?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainer>[]>;
        serviceAccountName?: pulumi.Input<string>;
        servingState?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainer {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnv>[]>;
        envFroms?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFrom>[]>;
        image: pulumi.Input<string>;
        resources?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerResources>;
        workingDir?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnv {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        configMapRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef>;
        prefix?: pulumi.Input<string>;
        secretRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerResources {
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ServiceTraffic {
        latestRevision?: pulumi.Input<boolean>;
        percent: pulumi.Input<number>;
        revisionName?: pulumi.Input<string>;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: pulumi.Input<inputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting>;
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        relativeUri: pulumi.Input<string>;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface JobHttpTarget {
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        oauthToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOauthToken>;
        oidcToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOidcToken>;
        uri: pulumi.Input<string>;
    }

    export interface JobHttpTargetOauthToken {
        scope?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobHttpTargetOidcToken {
        audience?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobPubsubTarget {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        data?: pulumi.Input<string>;
        topicName: pulumi.Input<string>;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: pulumi.Input<string>;
        maxDoublings?: pulumi.Input<number>;
        maxRetryDuration?: pulumi.Input<string>;
        minBackoffDuration?: pulumi.Input<string>;
        retryCount?: pulumi.Input<number>;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        host?: pulumi.Input<string>;
        instance?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface QueueRateLimits {
        maxBurstSize?: pulumi.Input<number>;
        maxConcurrentDispatches?: pulumi.Input<number>;
        maxDispatchesPerSecond?: pulumi.Input<number>;
    }

    export interface QueueRetryConfig {
        maxAttempts?: pulumi.Input<number>;
        maxBackoff?: pulumi.Input<string>;
        maxDoublings?: pulumi.Input<number>;
        maxRetryDuration?: pulumi.Input<string>;
        minBackoff?: pulumi.Input<string>;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri?: pulumi.Input<string>;
        dagGcsPrefix?: pulumi.Input<string>;
        gkeCluster?: pulumi.Input<string>;
        nodeConfig?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        privateEnvironmentConfig?: pulumi.Input<inputs.composer.EnvironmentConfigPrivateEnvironmentConfig>;
        softwareConfig?: pulumi.Input<inputs.composer.EnvironmentConfigSoftwareConfig>;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        ipAllocationPolicy?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy>;
        machineType?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        serviceAccount?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        zone: pulumi.Input<string>;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        clusterSecondaryRangeName?: pulumi.Input<string>;
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        servicesSecondaryRangeName?: pulumi.Input<string>;
        useIpAliases: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        masterIpv4CidrBlock?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        envVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * -
         * The version of the software running in the environment. This encapsulates both the version of Cloud Composer
         * functionality and the version of Apache Airflow. It must match the regular expression
         * `composer-[0-9]+\.[0-9]+(\.[0-9]+)?-airflow-[0-9]+\.[0-9]+(\.[0-9]+.*)?`.
         * The Cloud Composer portion of the version is a semantic version.
         * The portion of the image version following 'airflow-' is an official Apache Airflow repository release name.
         * See [documentation](https://cloud.google.com/composer/docs/reference/rest/v1beta1/projects.locations.environments#softwareconfig)
         * for allowed release names.
         */
        imageVersion?: pulumi.Input<string>;
        pypiPackages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * -
         * The major version of Python used to run the Apache Airflow scheduler, worker, and webserver processes.
         * Can be set to '2' or '3'. If not specified, the default is '2'. Cannot be updated.
         */
        pythonVersion?: pulumi.Input<string>;
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface AutoscalerAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: pulumi.Input<number>;
    }

    export interface BackendServiceBackend {
        balancingMode?: pulumi.Input<string>;
        capacityScaler?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        group: pulumi.Input<string>;
        maxConnections?: pulumi.Input<number>;
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        maxConnectionsPerInstance?: pulumi.Input<number>;
        maxRate?: pulumi.Input<number>;
        maxRatePerEndpoint?: pulumi.Input<number>;
        maxRatePerInstance?: pulumi.Input<number>;
        maxUtilization?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: pulumi.Input<inputs.compute.BackendServiceCdnPolicyCacheKeyPolicy>;
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: pulumi.Input<boolean>;
        includeProtocol?: pulumi.Input<boolean>;
        includeQueryString?: pulumi.Input<boolean>;
        queryStringBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: pulumi.Input<inputs.compute.BackendServiceCircuitBreakersConnectTimeout>;
        maxConnections?: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
        maxRequests?: pulumi.Input<number>;
        maxRequestsPerConnection?: pulumi.Input<number>;
        maxRetries?: pulumi.Input<number>;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookie>;
        httpHeaderName?: pulumi.Input<string>;
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        ttl?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceIap {
        oauth2ClientId: pulumi.Input<string>;
        oauth2ClientSecret: pulumi.Input<string>;
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface BackendServiceLogConfig {
        enable?: pulumi.Input<boolean>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionBaseEjectionTime>;
        consecutiveErrors?: pulumi.Input<number>;
        consecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingSuccessRate?: pulumi.Input<number>;
        interval?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionInterval>;
        maxEjectionPercent?: pulumi.Input<number>;
        successRateMinimumHosts?: pulumi.Input<number>;
        successRateRequestVolume?: pulumi.Input<number>;
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/global/externalVpnGateways/{{name}}`
         */
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface FirewallAllow {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface FirewallDeny {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
         */
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface ImageGuestOsFeature {
        type: pulumi.Input<string>;
    }

    export interface ImageRawDisk {
        containerType?: pulumi.Input<string>;
        sha1?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceAttachedDisk {
        /**
         * Name with which the attached disk will be accessible
         * under `/dev/disk/by-id/google-*`
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink` and `diskEncryptionKeyRaw` may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`
         * and `diskEncryptionKeyRaw` may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
         * If you have a persistent disk with data that you want to share
         * between multiple instances, detach it from any read-write instances and
         * attach it to one or more instances in read-only mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk to attach to this instance.
         */
        source: pulumi.Input<string>;
    }

    export interface InstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance
         * is deleted. Defaults to true.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Name with which the attached disk will be accessible
         * under `/dev/disk/by-id/google-*`
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink` and `diskEncryptionKeyRaw` may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * Parameters for a new disk that will be created
         * alongside the new instance. Either `initializeParams` or `source` must be set.
         * Structure is documented below.
         */
        initializeParams?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParams>;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`
         * and `diskEncryptionKeyRaw` may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
         * If you have a persistent disk with data that you want to share
         * between multiple instances, detach it from any read-write instances and
         * attach it to one or more instances in read-only mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk to attach to this instance.
         */
        source?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParams {
        /**
         * The image from which to initialize this disk. This can be
         * one of: the image's `selfLink`, `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
         * images names must include the family name. If they don't, use the
         * [gcp.compute.Image data source](https://www.terraform.io/docs/providers/google/d/datasource_compute_image.html).
         * For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
         * These images can be referred by family name here.
         */
        image?: pulumi.Input<string>;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels?: pulumi.Input<{[key: string]: any}>;
        /**
         * The size of the image in gigabytes. If not specified, it
         * will inherit the size of its base image.
         */
        size?: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        initializeParams?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParams>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: any}>;
        size?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: pulumi.Input<string>;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * - Version name.
         */
        name: pulumi.Input<string>;
        /**
         * The port number.
         * - - -
         */
        port: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        /**
         * , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `maxSurgePercent`. If neither is set, defaults to 1
         */
        maxSurgeFixed?: pulumi.Input<number>;
        /**
         * , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `maxSurgeFixed`.
         */
        maxSurgePercent?: pulumi.Input<number>;
        /**
         * , The maximum number of instances that can be unavailable during the update process. Conflicts with `maxUnavailablePercent`. If neither is set, defaults to 1
         */
        maxUnavailableFixed?: pulumi.Input<number>;
        /**
         * , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `maxUnavailableFixed`.
         */
        maxUnavailablePercent?: pulumi.Input<number>;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         * - - -
         */
        minReadySec?: pulumi.Input<number>;
        /**
         * - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: pulumi.Input<string>;
        /**
         * - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerVersion {
        /**
         * - The full URL to an instance template from which all new instances of this version will be created.
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * - Version name.
         */
        name?: pulumi.Input<string>;
        /**
         * - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         */
        targetSize?: pulumi.Input<inputs.compute.InstanceGroupManagerVersionTargetSize>;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: pulumi.Input<number>;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: pulumi.Input<number>;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name which the port will be mapped to.
         */
        name: pulumi.Input<string>;
        /**
         * The port number to map the name to.
         */
        port: pulumi.Input<number>;
    }

    export interface InstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Omit to ensure that the instance
         * is not accessible from the Internet. If omitted, ssh will not
         * work unless this provider can send traffic to the instance's network (e.g. via
         * tunnel or because it is running on another cloud instance on that network).
         * This block can be repeated multiple times. Structure documented below.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAccessConfig>[]>;
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Either `network` or `subnetwork` must be provided.
         */
        network?: pulumi.Input<string>;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The name or selfLink of the subnetwork to attach this
         * interface to. The subnetwork must exist in the same region this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The project in which the subnetwork belongs.
         * If the `subnetwork` is a self_link, this field is ignored in favor of the project
         * defined in the subnetwork self_link. If the `subnetwork` is a name and this
         * field is not provided, the provider project is used.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The [networking tier][network-tier] used for configuring this instance.
         * This field can take the following values: PREMIUM or STANDARD. If this field is
         * not specified, it is assumed to be PREMIUM.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The DNS domain name for the public PTR record.
         * To set this field on an instance, you must be verified as the owner of the domain.
         * See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
         * to become verified as a domain owner.
         */
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. This range may be a single IP address
         * (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         * Defaults to true.
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulingNodeAffinity>[]>;
        /**
         * Describes maintenance behavior for the
         * instance. Can be MIGRATE or TERMINATE, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Specifies if the instance is preemptible.
         * If this field is set to true, then `automaticRestart` must be
         * set to false.  Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: pulumi.Input<string>;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceScratchDisk {
        /**
         * The disk interface to use for attaching this disk; either SCSI or NVME.
         */
        interface: pulumi.Input<string>;
    }

    export interface InstanceServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceShieldedInstanceConfig {
        /**
         * -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateDisk {
        /**
         * Whether or not the disk should be auto-deleted.
         * This defaults to true.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Indicates that this is a boot disk.
         */
        boot?: pulumi.Input<boolean>;
        /**
         * A unique device name that is reflected into the
         * /dev/  tree of a Linux operating system running within the instance. If not
         * specified, the server chooses a default device name to apply to this disk.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * Encrypts or decrypts a disk using a customer-supplied encryption key.
         */
        diskEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskDiskEncryptionKey>;
        /**
         * Name of the disk. When not provided, this defaults
         * to the name of the instance.
         */
        diskName?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes. If not
         * specified, it will inherit the size of its base image. For SCRATCH disks,
         * the size must be exactly 375GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * The GCE disk type. Can be either `"pd-ssd"`,
         * `"local-ssd"`, or `"pd-standard"`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * Specifies the disk interface to use for attaching
         * this disk.
         */
        interface?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The mode in which to attach this disk, either READ_WRITE
         * or READ_ONLY. If you are attaching or creating a boot disk, this must
         * read-write mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name (**not self_link**)
         * of the disk (such as those managed by `gcp.compute.Disk`) to attach.
         */
        source?: pulumi.Input<string>;
        /**
         * The image from which to
         * initialize this disk. This can be one of: the image's `selfLink`,
         * `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`.
         */
        sourceImage?: pulumi.Input<string>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS
         */
        kmsKeySelfLink: pulumi.Input<string>;
    }

    export interface InstanceTemplateGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Omit to ensure that the instance
         * is not accessible from the Internet (this means that ssh provisioners will
         * not work unless you can send traffic to the instance's
         * network (e.g. via tunnel or because it is running on another cloud instance
         * on that network). This block can be repeated multiple times. Structure documented below.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAccessConfig>[]>;
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Use `network` attribute for Legacy or Auto subnetted networks and
         * `subnetwork` for custom subnetted networks.
         */
        network?: pulumi.Input<string>;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * the name of the subnetwork to attach this interface
         * to. The subnetwork must exist in the same `region` this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The ID of the project in which the subnetwork belongs.
         * If it is not provided, the provider project is used.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The [networking tier][network-tier] used for configuring
         * this instance template. This field can take the following values: PREMIUM or
         * STANDARD. If this field is not specified, it is assumed to be PREMIUM.
         */
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. At the time of writing only a
         * netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
         * error.
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateScheduling {
        /**
         * Specifies whether the instance should be
         * automatically restarted if it is terminated by Compute Engine (not
         * terminated by a user). This defaults to true.
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateSchedulingNodeAffinity>[]>;
        /**
         * Defines the maintenance behavior for this
         * instance.
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Allows instance to be preempted. This defaults to
         * false. Read more on this
         * [here](https://cloud.google.com/compute/docs/instances/preemptible).
         */
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: pulumi.Input<string>;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        /**
         * -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q?: pulumi.Input<number>;
    }

    export interface ManagedSslCertificateManaged {
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MangedSslCertificateManaged {
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NodeGroupAutoscalingPolicy {
        maxNodes?: pulumi.Input<number>;
        minNodes?: pulumi.Input<number>;
        mode?: pulumi.Input<string>;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: pulumi.Input<string>;
        localSsd?: pulumi.Input<string>;
        memory?: pulumi.Input<string>;
    }

    export interface NodeTemplateServerBinding {
        type: pulumi.Input<string>;
    }

    export interface PacketMirroringCollectorIlb {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringFilter {
        cidrRanges?: pulumi.Input<pulumi.Input<string>[]>;
        ipProtocols?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResources {
        instances?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesInstance>[]>;
        subnetworks?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesSubnetwork>[]>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResourcesInstance {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringNetwork {
        url: pulumi.Input<string>;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceBackend {
        balancingMode?: pulumi.Input<string>;
        capacityScaler?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        failover?: pulumi.Input<boolean>;
        group: pulumi.Input<string>;
        maxConnections?: pulumi.Input<number>;
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        maxConnectionsPerInstance?: pulumi.Input<number>;
        maxRate?: pulumi.Input<number>;
        maxRatePerEndpoint?: pulumi.Input<number>;
        maxRatePerInstance?: pulumi.Input<number>;
        maxUtilization?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakers {
        connectTimeout?: pulumi.Input<inputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout>;
        maxConnections?: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
        maxRequests?: pulumi.Input<number>;
        maxRequestsPerConnection?: pulumi.Input<number>;
        maxRetries?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConsistentHash {
        httpCookie?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookie>;
        httpHeaderName?: pulumi.Input<string>;
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        ttl?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: pulumi.Input<boolean>;
        dropTrafficIfUnhealthy?: pulumi.Input<boolean>;
        failoverRatio?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceLogConfig {
        enable?: pulumi.Input<boolean>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetection {
        baseEjectionTime?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime>;
        consecutiveErrors?: pulumi.Input<number>;
        consecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingSuccessRate?: pulumi.Input<number>;
        interval?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionInterval>;
        maxEjectionPercent?: pulumi.Input<number>;
        successRateMinimumHosts?: pulumi.Input<number>;
        successRateRequestVolume?: pulumi.Input<number>;
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: pulumi.Input<string>;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * - Version name.
         */
        name: pulumi.Input<string>;
        /**
         * The port number.
         * - - -
         */
        port: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        /**
         * - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
         */
        instanceRedistributionType?: pulumi.Input<string>;
        /**
         * , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `maxSurgePercent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `maxUnavailableFixed` or `maxSurgeFixed` must be greater than 0.
         */
        maxSurgeFixed?: pulumi.Input<number>;
        /**
         * , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `maxSurgeFixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
         */
        maxSurgePercent?: pulumi.Input<number>;
        /**
         * , The maximum number of instances that can be unavailable during the update process. Conflicts with `maxUnavailablePercent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `maxUnavailableFixed` or `maxSurgeFixed` must be greater than 0.
         */
        maxUnavailableFixed?: pulumi.Input<number>;
        /**
         * , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `maxUnavailableFixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
         */
        maxUnavailablePercent?: pulumi.Input<number>;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         * - - -
         */
        minReadySec?: pulumi.Input<number>;
        /**
         * - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: pulumi.Input<string>;
        /**
         * - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerVersion {
        /**
         * - The full URL to an instance template from which all new instances of this version will be created.
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * - Version name.
         */
        name?: pulumi.Input<string>;
        /**
         * - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         */
        targetSize?: pulumi.Input<inputs.compute.RegionInstanceGroupManagerVersionTargetSize>;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: pulumi.Input<number>;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: pulumi.Input<number>;
    }

    export interface RegionUrlMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRule>[]>;
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRule>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: pulumi.Input<number>;
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction>;
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule>[]>;
        priority: pulumi.Input<number>;
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: pulumi.Input<string>;
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        ignoreCase?: pulumi.Input<boolean>;
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        prefixMatch?: pulumi.Input<string>;
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        invertMatch?: pulumi.Input<boolean>;
        prefixMatch?: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        rangeMatch?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        regexMatch?: pulumi.Input<string>;
        suffixMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: pulumi.Input<number>;
        rangeStart: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled?: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: pulumi.Input<number>;
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservation {
        count: pulumi.Input<number>;
        inUseCount?: pulumi.Input<number>;
        instanceProperties: pulumi.Input<inputs.compute.ReservationSpecificReservationInstanceProperties>;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator>[]>;
        localSsds?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd>[]>;
        machineType: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: pulumi.Input<number>;
        interface?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy>;
        schedule: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySchedule>;
        snapshotProperties?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: pulumi.Input<number>;
        onSourceDiskDelete?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule>;
        hourlySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule>;
        weeklySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: pulumi.Input<pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek>[]>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: pulumi.Input<boolean>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        storageLocations?: pulumi.Input<string>;
    }

    export interface RouterBgp {
        advertiseMode?: pulumi.Input<string>;
        advertisedGroups?: pulumi.Input<pulumi.Input<string>[]>;
        advertisedIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.RouterBgpAdvertisedIpRange>[]>;
        asn: pulumi.Input<number>;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range: pulumi.Input<string>;
    }

    export interface RouterNatLogConfig {
        enable: pulumi.Input<boolean>;
        filter: pulumi.Input<string>;
    }

    export interface RouterNatSubnetwork {
        name: pulumi.Input<string>;
        secondaryIpRangeNames?: pulumi.Input<pulumi.Input<string>[]>;
        sourceIpRangesToNats: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range: pulumi.Input<string>;
    }

    export interface SecurityPolicyRule {
        /**
         * Action to take when `match` matches the request. Valid values:
         * * "allow" : allow access to target
         * * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
         */
        action: pulumi.Input<string>;
        /**
         * An optional description of this rule. Max size is 64.
         */
        description?: pulumi.Input<string>;
        /**
         * A match condition that incoming traffic is evaluated against.
         * If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
         */
        match: pulumi.Input<inputs.compute.SecurityPolicyRuleMatch>;
        /**
         * When set to true, the `action` specified above is not enforced.
         * Stackdriver logs for requests that trigger a preview action are annotated as such.
         */
        preview?: pulumi.Input<boolean>;
        /**
         * An unique positive integer indicating the priority of evaluation for a rule.
         * Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
         */
        priority: pulumi.Input<number>;
    }

    export interface SecurityPolicyRuleMatch {
        /**
         * The configuration options available when specifying `versionedExpr`.
         * This field must be specified if `versionedExpr` is specified and cannot be specified if `versionedExpr` is not specified.
         * Structure is documented below.
         */
        config?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchConfig>;
        /**
         * User defined CEVAL expression. A CEVAL expression is used to specify match criteria
         * such as origin.ip, source.region_code and contents in the request header.
         * Structure is documented below.
         */
        expr?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchExpr>;
        /**
         * Predefined rule expression. If this field is specified, `config` must also be specified.
         * Available options:
         * * SRC_IPS_V1: Must specify the corresponding `srcIpRanges` field in `config`.
         */
        versionedExpr?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatchConfig {
        /**
         * Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
         * to match against inbound traffic. There is a limit of 5 IP ranges per rule. A value of '\*' matches all IPs
         * (can be used to override the default behavior).
         */
        srcIpRanges: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyRuleMatchExpr {
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         * The application context of the containing message determines which well-known feature set of CEL is supported.
         */
        expression: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationCustomAccount>;
        googleAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationGoogleAccount>;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: pulumi.Input<string>;
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: pulumi.Input<number>;
        scheduleTime?: pulumi.Input<string>;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: pulumi.Input<string>;
    }

    export interface SubnetworkIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SubnetworkIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: pulumi.Input<string>;
        flowSampling?: pulumi.Input<number>;
        metadata?: pulumi.Input<string>;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: pulumi.Input<string>;
        rangeName: pulumi.Input<string>;
    }

    export interface URLMapHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface URLMapPathMatcher {
        defaultService?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherHeaderAction>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRule>[]>;
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRule>[]>;
    }

    export interface URLMapPathMatcherHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: pulumi.Input<number>;
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRule {
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderAction>;
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRule>[]>;
        priority: pulumi.Input<number>;
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteAction>;
        service?: pulumi.Input<string>;
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: pulumi.Input<string>;
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        ignoreCase?: pulumi.Input<boolean>;
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        prefixMatch?: pulumi.Input<string>;
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        invertMatch?: pulumi.Input<boolean>;
        prefixMatch?: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        rangeMatch?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        regexMatch?: pulumi.Input<string>;
        suffixMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: pulumi.Input<number>;
        rangeStart: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        presentMatch?: pulumi.Input<boolean>;
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout>;
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: pulumi.Input<boolean>;
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        disabled?: pulumi.Input<boolean>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: pulumi.Input<number>;
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: pulumi.Input<number>;
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: pulumi.Input<string>;
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: pulumi.Input<string>;
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: pulumi.Input<string>;
        httpsRedirect?: pulumi.Input<boolean>;
        pathRedirect?: pulumi.Input<string>;
        prefixRedirect?: pulumi.Input<string>;
        redirectResponseCode?: pulumi.Input<string>;
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface URLMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        /**
         * .
         * The status of the CloudRun addon. It requires `istioConfig` enabled. It is disabled by default.
         * Set `disabled = false` to enable. This addon can only be enabled at cluster creation time.
         */
        cloudrunConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigCloudrunConfig>;
        /**
         * .
         * The status of the NodeLocal DNSCache addon. It is disabled by default.
         * Set `enabled = true` to enable.
         */
        dnsCacheConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigDnsCacheConfig>;
        /**
         * The status of the Horizontal Pod Autoscaling
         * addon, which increases or decreases the number of replica pods a replication controller
         * has based on the resource usage of the existing pods.
         * It ensures that a Heapster pod is running in the cluster, which is also used by the Cloud Monitoring service.
         * It is enabled by default;
         * set `disabled = true` to disable.
         */
        horizontalPodAutoscaling?: pulumi.Input<inputs.container.ClusterAddonsConfigHorizontalPodAutoscaling>;
        /**
         * The status of the HTTP (L7) load balancing
         * controller addon, which makes it easy to set up HTTP load balancers for services in a
         * cluster. It is enabled by default; set `disabled = true` to disable.
         */
        httpLoadBalancing?: pulumi.Input<inputs.container.ClusterAddonsConfigHttpLoadBalancing>;
        /**
         * .
         * Structure is documented below.
         */
        istioConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigIstioConfig>;
        /**
         * Whether we should enable the network policy addon
         * for the master.  This must be enabled in order to enable network policy for the nodes.
         * To enable this, you must also define a `networkPolicy` block,
         * otherwise nothing will happen.
         * It can only be disabled if the nodes already do not have network policies enabled.
         * Defaults to disabled; set `disabled = false` to enable.
         */
        networkPolicyConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigNetworkPolicyConfig>;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigDnsCacheConfig {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigIstioConfig {
        /**
         * The authentication type between services in Istio. Available options include `AUTH_MUTUAL_TLS`.
         */
        auth?: pulumi.Input<string>;
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        /**
         * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format `gke-security-groups@yourdomain.com`.
         */
        securityGroup: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscaling {
        /**
         * Contains defaults for a node pool created by NAP.
         * Structure is documented below.
         */
        autoProvisioningDefaults?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults>;
        /**
         * Configuration
         * options for the [Autoscaling profile](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#autoscaling_profiles)
         * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
         * when deciding to remove nodes from a cluster. Can be `BALANCED` or `OPTIMIZE_UTILIZATION`. Defaults to `BALANCED`.
         */
        autoscalingProfile?: pulumi.Input<string>;
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Global constraints for machine resources in the
         * cluster. Configuring the `cpu` and `memory` types is required if node
         * auto-provisioning is enabled. These limits will apply to node pool autoscaling
         * in addition to node auto-provisioning. Structure is documented below.
         */
        resourceLimits?: pulumi.Input<pulumi.Input<inputs.container.ClusterClusterAutoscalingResourceLimit>[]>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        /**
         * Maximum amount of the resource in the cluster.
         */
        maximum?: pulumi.Input<number>;
        /**
         * Minimum amount of the resource in the cluster.
         */
        minimum?: pulumi.Input<number>;
        /**
         * The type of the resource. For example, `cpu` and
         * `memory`.  See the [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
         * for a list of types.
         */
        resourceType: pulumi.Input<string>;
    }

    export interface ClusterDatabaseEncryption {
        /**
         * the key to use to encrypt/decrypt secrets.  See the [DatabaseEncryption definition](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#Cluster.DatabaseEncryption) for more information.
         */
        keyName?: pulumi.Input<string>;
        /**
         * `ENCRYPTED` or `DECRYPTED`
         */
        state: pulumi.Input<string>;
    }

    export interface ClusterIpAllocationPolicy {
        /**
         * The IP address range for the cluster pod IPs.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the existing secondary
         * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
         * `clusterIpv4CidrBlock` can be used to automatically create a GKE-managed one.
         */
        clusterSecondaryRangeName?: pulumi.Input<string>;
        /**
         * The IP address range of the services IPs in this cluster.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the existing
         * secondary range in the cluster's subnetwork to use for service `ClusterIP`s.
         * Alternatively, `servicesIpv4CidrBlock` can be used to automatically create a
         * GKE-managed one.
         */
        servicesSecondaryRangeName?: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicy {
        /**
         * Time window specified for daily maintenance operations.
         * Specify `startTime` in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format "HH:MM,
         * where HH : \[00-23\] and MM : \[00-59\] GMT. For example:
         */
        dailyMaintenanceWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow>;
        /**
         * Time window for
         * recurring maintenance operations.
         */
        recurringWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyRecurringWindow>;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration?: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: pulumi.Input<string>;
        recurrence: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMasterAuth {
        clientCertificate?: pulumi.Input<string>;
        /**
         * Whether client certificate authorization is enabled for this cluster.  For example:
         */
        clientCertificateConfig?: pulumi.Input<inputs.container.ClusterMasterAuthClientCertificateConfig>;
        clientKey?: pulumi.Input<string>;
        clusterCaCertificate?: pulumi.Input<string>;
        /**
         * The password to use for HTTP basic authentication when accessing
         * the Kubernetes master endpoint.
         */
        password?: pulumi.Input<string>;
        /**
         * The username to use for HTTP basic authentication when accessing
         * the Kubernetes master endpoint. If not present basic auth will be disabled.
         */
        username?: pulumi.Input<string>;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: pulumi.Input<boolean>;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        /**
         * External networks that can access the
         * Kubernetes cluster master through HTTPS.
         */
        cidrBlocks?: pulumi.Input<pulumi.Input<inputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock>[]>;
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        /**
         * External network that can access Kubernetes master through HTTPS.
         * Must be specified in CIDR notation.
         */
        cidrBlock: pulumi.Input<string>;
        /**
         * Field for users to identify CIDR blocks.
         */
        displayName?: pulumi.Input<string>;
    }

    export interface ClusterNetworkPolicy {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
         */
        provider?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfig {
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType?: pulumi.Input<string>;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigGuestAccelerator>[]>;
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType?: pulumi.Input<string>;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `n1-standard-1`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * [GKE Sandbox](https://cloud.google.com/kubernetes-engine/docs/how-to/sandbox-pods) configuration. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion = "1.12.7-gke.17"` or later to use it.
         * Structure is documented below.
         */
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodeConfigSandboxConfig>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodeConfigShieldedInstanceConfig>;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigTaint>[]>;
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         */
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines if the instance has Secure Boot enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * SECURE: Prevent workloads not in hostNetwork from accessing certain VM metadata, specifically kube-env, which contains Kubelet credentials, and the instance identity token. See [Metadata Concealment](https://cloud.google.com/kubernetes-engine/docs/how-to/metadata-proxy) documentation.
         * * EXPOSE: Expose all VM metadata to pods.
         * * GKE_METADATA_SERVER: Enables [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) on the node.
         */
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterNodePool {
        autoscaling?: pulumi.Input<inputs.container.ClusterNodePoolAutoscaling>;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount?: pulumi.Input<number>;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls?: pulumi.Input<pulumi.Input<string>[]>;
        management?: pulumi.Input<inputs.container.ClusterNodePoolManagement>;
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name?: pulumi.Input<string>;
        namePrefix?: pulumi.Input<string>;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations?: pulumi.Input<pulumi.Input<string>[]>;
        upgradeSettings?: pulumi.Input<inputs.container.ClusterNodePoolUpgradeSettings>;
        version?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: pulumi.Input<number>;
        minNodeCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: pulumi.Input<boolean>;
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfig {
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType?: pulumi.Input<string>;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAccelerator>[]>;
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType?: pulumi.Input<string>;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `n1-standard-1`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * [GKE Sandbox](https://cloud.google.com/kubernetes-engine/docs/how-to/sandbox-pods) configuration. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion = "1.12.7-gke.17"` or later to use it.
         * Structure is documented below.
         */
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSandboxConfig>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig>;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigTaint>[]>;
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         */
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines if the instance has Secure Boot enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * SECURE: Prevent workloads not in hostNetwork from accessing certain VM metadata, specifically kube-env, which contains Kubelet credentials, and the instance identity token. See [Metadata Concealment](https://cloud.google.com/kubernetes-engine/docs/how-to/metadata-proxy) documentation.
         * * EXPOSE: Expose all VM metadata to pods.
         * * GKE_METADATA_SERVER: Enables [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) on the node.
         */
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterNodePoolUpgradeSettings {
        maxSurge: pulumi.Input<number>;
        maxUnavailable: pulumi.Input<number>;
    }

    export interface ClusterPodSecurityPolicyConfig {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterPrivateClusterConfig {
        /**
         * When `true`, the cluster's private
         * endpoint is used as the cluster endpoint and access through the public endpoint
         * is disabled. When `false`, either endpoint can be used. This field only applies
         * to private clusters, when `enablePrivateNodes` is `true`.
         */
        enablePrivateEndpoint: pulumi.Input<boolean>;
        /**
         * Enables the private cluster feature,
         * creating a private endpoint on the cluster. In a private cluster, nodes only
         * have RFC 1918 private addresses and communicate with the master's private
         * endpoint via private networking.
         */
        enablePrivateNodes?: pulumi.Input<boolean>;
        /**
         * The IP range in CIDR notation to use for
         * the hosted master network. This range will be used for assigning private IP
         * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
         * with any other ranges in use within the cluster's network, and it must be a /28
         * subnet. See [Private Cluster Limitations](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#limitations)
         * for more details. This field only applies to private clusters, when
         * `enablePrivateNodes` is `true`.
         */
        masterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the peering between this cluster and the Google owned VPC.
         */
        peeringName?: pulumi.Input<string>;
        /**
         * The internal IP address of this cluster's master endpoint.
         */
        privateEndpoint?: pulumi.Input<string>;
        /**
         * The external IP address of this cluster's master endpoint.
         */
        publicEndpoint?: pulumi.Input<string>;
    }

    export interface ClusterReleaseChannel {
        /**
         * The selected release channel.
         * Accepted values are:
         * * UNSPECIFIED: Not set.
         * * RAPID: Weekly upgrade cadence; Early testers and developers who requires new features.
         * * REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel.
         * * STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky.
         */
        channel: pulumi.Input<string>;
    }

    export interface ClusterResourceUsageExportConfig {
        /**
         * Parameters for using BigQuery as the destination of resource usage export.
         */
        bigqueryDestination: pulumi.Input<inputs.container.ClusterResourceUsageExportConfigBigqueryDestination>;
        /**
         * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
         * in the cluster to meter network egress traffic.
         */
        enableNetworkEgressMetering?: pulumi.Input<boolean>;
        /**
         * Whether to enable resource
         * consumption metering on this cluster. When enabled, a table will be created in
         * the resource export BigQuery dataset to store resource consumption data. The
         * resulting table can be joined with the resource usage table or with BigQuery
         * billing export. Defaults to `true`.
         */
        enableResourceConsumptionMetering?: pulumi.Input<boolean>;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: pulumi.Input<string>;
    }

    export interface ClusterVerticalPodAutoscaling {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterWorkloadIdentityConfig {
        /**
         * Currently, the only supported identity namespace is the project's default.
         */
        identityNamespace: pulumi.Input<string>;
    }

    export interface NodePoolAutoscaling {
        /**
         * Maximum number of nodes in the NodePool. Must be >= min_node_count.
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * Minimum number of nodes in the NodePool. Must be >=0 and
         * <= `maxNodeCount`.
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface NodePoolManagement {
        /**
         * Whether the nodes will be automatically repaired.
         */
        autoRepair?: pulumi.Input<boolean>;
        /**
         * Whether the nodes will be automatically upgraded.
         */
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfig {
        bootDiskKmsKey?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        shieldedInstanceConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigShieldedInstanceConfig>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface NodePoolUpgradeSettings {
        /**
         * The number of additional nodes that can be added to the node pool during
         * an upgrade. Increasing `maxSurge` raises the number of nodes that can be upgraded simultaneously.
         * Can be set to 0 or greater.
         */
        maxSurge: pulumi.Input<number>;
        /**
         * The number of nodes that can be simultaneously unavailable during
         * an upgrade. Increasing `maxUnavailable` raises the number of nodes that can be upgraded in
         * parallel. Can be set to 0 or greater.
         */
        maxUnavailable: pulumi.Input<number>;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: pulumi.Input<inputs.containeranalysis.NoteAttestationAuthorityHint>;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: pulumi.Input<string>;
    }
}

export namespace datafusion {
    export interface InstanceNetworkConfig {
        ipAllocation: pulumi.Input<string>;
        network: pulumi.Input<string>;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: pulumi.Input<string>;
        yarnConfig: pulumi.Input<inputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig>;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: pulumi.Input<string>;
        scaleDownFactor: pulumi.Input<number>;
        scaleDownMinWorkerFraction?: pulumi.Input<number>;
        scaleUpFactor: pulumi.Input<number>;
        scaleUpMinWorkerFraction?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfig {
        /**
         * The autoscaling policy config associated with the cluster.
         * Structure defined below.
         */
        autoscalingConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAutoscalingConfig>;
        bucket?: pulumi.Input<string>;
        /**
         * The Customer managed encryption keys settings for the cluster.
         * Structure defined below.
         */
        encryptionConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigEncryptionConfig>;
        /**
         * Common config settings for resources of Google Compute Engine cluster
         * instances, applicable to all instances in the cluster. Structure defined below.
         */
        gceClusterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfig>;
        /**
         * Commands to execute on each node after config is completed.
         * You can specify multiple versions of these. Structure defined below.
         */
        initializationActions?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigInitializationAction>[]>;
        lifecycleConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigLifecycleConfig>;
        /**
         * The Google Compute Engine config settings for the master instances
         * in a cluster.. Structure defined below.
         */
        masterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfig>;
        /**
         * The Google Compute Engine config settings for the additional (aka
         * preemptible) instances in a cluster. Structure defined below.
         */
        preemptibleWorkerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig>;
        /**
         * Security related configuration. Structure defined below.
         */
        securityConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfig>;
        /**
         * The config settings for software inside the cluster.
         * Structure defined below.
         */
        softwareConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSoftwareConfig>;
        /**
         * The Cloud Storage staging bucket used to stage files,
         * such as Hadoop jars, between client machines and the cluster.
         * Note: If you don't explicitly specify a `stagingBucket`
         * then GCP will auto create / assign one for you. However, you are not guaranteed
         * an auto generated bucket which is solely dedicated to your cluster; it may be shared
         * with other clusters in the same region/zone also choosing to use the auto generation
         * option.
         */
        stagingBucket?: pulumi.Input<string>;
        /**
         * The Google Compute Engine config settings for the worker instances
         * in a cluster.. Structure defined below.
         */
        workerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfig>;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        /**
         * The autoscaling policy used by the cluster.
         */
        policyUri: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        /**
         * The Cloud KMS key name to use for PD disk encryption for
         * all instances in the cluster.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        /**
         * By default, clusters are not restricted to internal IP addresses, 
         * and will have ephemeral external IP addresses assigned to each instance. If set to true, all
         * instances in the cluster will only have internal IP addresses. Note: Private Google Access
         * (also known as `privateIpGoogleAccess`) must be enabled on the subnetwork that the cluster
         * will be launched in.
         */
        internalIpOnly?: pulumi.Input<boolean>;
        /**
         * A map of the Compute Engine metadata entries to add to all instances
         * (see [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The name or selfLink of the Google Compute Engine
         * network to the cluster will be part of. Conflicts with `subnetwork`.
         * If neither is specified, this defaults to the "default" network.
         */
        network?: pulumi.Input<string>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The set of Google API scopes
         * to be made available on all of the node VMs under the `serviceAccount`
         * specified. These can be	either FQDNs, or scope aliases. The following scopes
         * must be set if any other scopes are set. They're necessary to ensure the
         * correct functioning ofthe cluster, and are set automatically by the API:
         */
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name or selfLink of the Google Compute Engine
         * subnetwork the cluster will be part of. Conflicts with `network`.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The list of instance tags applied to instances in the cluster.
         * Tags are used to identify valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The GCP zone where your data is stored and used (i.e. where
         * the master and the worker nodes will be created in). If `region` is set to 'global' (default)
         * then `zone` is mandatory, otherwise GCP is able to make use of [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/auto-zone)
         * to determine this automatically for you.
         * Note: This setting additionally determines and restricts
         * which computing resources are available for use with other configs such as
         * `cluster_config.master_config.machine_type` and `cluster_config.worker_config.machine_type`.
         */
        zone?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: pulumi.Input<string>;
        /**
         * The maximum duration (in seconds) which `script` is
         * allowed to take to execute its action. GCP will default to a predetermined
         * computed value if not set (currently 300).
         */
        timeoutSec?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        /**
         * The time when cluster will be auto-deleted.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
         * Example: "2014-10-02T15:01:23.045123456Z".
         */
        autoDeleteTime?: pulumi.Input<string>;
        /**
         * The duration to keep the cluster alive while idling
         * (no jobs running). After this TTL, the cluster will be deleted. Valid range: [10m, 14d].
         */
        idleDeleteTtl?: pulumi.Input<string>;
        idleStartTime?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfig {
        /**
         * The Compute Engine accelerator configuration for these instances. Can be specified multiple times.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigAccelerator>[]>;
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig>;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of a Google Compute Engine machine type
         * to create for the worker nodes. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigSecurityConfig {
        /**
         * Kerberos Configuration
         */
        kerberosConfig: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig>;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        /**
         * The admin server (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustAdminServer?: pulumi.Input<string>;
        /**
         * The KDC (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustKdc?: pulumi.Input<string>;
        /**
         * The remote realm the Dataproc on-cluster KDC will
         * trust, should the user enable cross realm trust.
         */
        crossRealmTrustRealm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS
         * encrypted file containing the shared password between the on-cluster Kerberos realm
         * and the remote trusted realm, in a cross realm trust relationship.
         */
        crossRealmTrustSharedPasswordUri?: pulumi.Input<string>;
        /**
         * Flag to indicate whether to Kerberize the cluster.
         */
        enableKerberos?: pulumi.Input<boolean>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the master key of the KDC database.
         */
        kdcDbKeyUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided key. For the self-signed certificate, this password
         * is generated by Dataproc.
         */
        keyPasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided keystore. For the self-signed certificated, the password
         * is generated by Dataproc.
         */
        keystorePasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the keystore file used for SSL encryption.
         * If not provided, Dataproc will provide a self-signed certificate.
         */
        keystoreUri?: pulumi.Input<string>;
        /**
         * The URI of the KMS key used to encrypt various sensitive files.
         */
        kmsKeyUri: pulumi.Input<string>;
        /**
         * The name of the on-cluster Kerberos realm. If not specified, the
         * uppercased domain of hostnames will be the realm.
         */
        realm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the root principal password.
         */
        rootPrincipalPasswordUri: pulumi.Input<string>;
        /**
         * The lifetime of the ticket granting ticket, in hours.
         */
        tgtLifetimeHours?: pulumi.Input<number>;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the password to the user provided truststore. For the self-signed
         * certificate, this password is generated by Dataproc.
         */
        truststorePasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the truststore file used for
         * SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
         */
        truststoreUri?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        /**
         * The Cloud Dataproc image version to use
         * for the cluster - this controls the sets of software versions
         * installed onto the nodes when you create clusters. If not specified, defaults to the
         * latest version. For a list of valid versions see
         * [Cloud Dataproc versions](https://cloud.google.com/dataproc/docs/concepts/dataproc-versions)
         */
        imageVersion?: pulumi.Input<string>;
        /**
         * The set of optional components to activate on the cluster. 
         * Accepted values are:
         * * ANACONDA
         * * DRUID
         * * HIVE_WEBHCAT
         * * JUPYTER
         * * KERBEROS
         * * PRESTO
         * * ZEPPELIN
         * * ZOOKEEPER
         */
        optionalComponents?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of override and additional properties (key/value pairs)
         * used to modify various aspects of the common configuration files used when creating
         * a cluster. For a list of valid properties please see
         * [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties)
         */
        overrideProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        properties?: pulumi.Input<{[key: string]: any}>;
    }

    export interface ClusterClusterConfigWorkerConfig {
        /**
         * The Compute Engine accelerator configuration for these instances. Can be specified multiple times.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator>[]>;
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig>;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of a Google Compute Engine machine type
         * to create for the worker nodes. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ClusterIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobHadoopConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobHadoopConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'. Conflicts with `mainClass`
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHiveConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobPigConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPigConfigLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPlacement {
        clusterName: pulumi.Input<string>;
        clusterUuid?: pulumi.Input<string>;
    }

    export interface JobPysparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPysparkConfigLoggingConfig>;
        mainPythonFileUri: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobReference {
        jobId?: pulumi.Input<string>;
    }

    export interface JobScheduling {
        maxFailuresPerHour: pulumi.Input<number>;
    }

    export interface JobSparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparkConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'. Conflicts with `mainClass`
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfig {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparksqlConfigLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobStatus {
        details?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
        stateStartTime?: pulumi.Input<string>;
        substate?: pulumi.Input<string>;
    }
}

export namespace datastore {
    export interface DataStoreIndexProperty {
        direction: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeploymentTarget {
        config: pulumi.Input<inputs.deploymentmanager.DeploymentTargetConfig>;
        imports?: pulumi.Input<pulumi.Input<inputs.deploymentmanager.DeploymentTargetImport>[]>;
    }

    export interface DeploymentTargetConfig {
        content: pulumi.Input<string>;
    }

    export interface DeploymentTargetImport {
        content?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }
}

export namespace dns {
    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneDnssecConfigDefaultKeySpec>[]>;
        kind?: pulumi.Input<string>;
        nonExistence?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: pulumi.Input<string>;
        keyLength?: pulumi.Input<number>;
        keyType?: pulumi.Input<string>;
        kind?: pulumi.Input<string>;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneForwardingConfigTargetNameServer>[]>;
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        forwardingPath?: pulumi.Input<string>;
        ipv4Address: pulumi.Input<string>;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork: pulumi.Input<inputs.dns.ManagedZonePeeringConfigTargetNetwork>;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl: pulumi.Input<string>;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks: pulumi.Input<pulumi.Input<inputs.dns.ManagedZonePrivateVisibilityConfigNetwork>[]>;
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl: pulumi.Input<string>;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.PolicyAlternativeNameServerConfigTargetNameServer>[]>;
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address: pulumi.Input<string>;
    }

    export interface PolicyNetwork {
        networkUrl: pulumi.Input<string>;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods?: pulumi.Input<pulumi.Input<inputs.endpoints.ServiceApiMethod>[]>;
        name?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface ServiceApiMethod {
        name?: pulumi.Input<string>;
        requestType?: pulumi.Input<string>;
        responseType?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
    }

    export interface ServiceEndpoint {
        address?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: pulumi.Input<number>;
        name: pulumi.Input<string>;
    }

    export interface InstanceNetwork {
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        modes: pulumi.Input<pulumi.Input<string>[]>;
        network: pulumi.Input<string>;
        reservedIpRange?: pulumi.Input<string>;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: pulumi.Input<string>;
        fieldPath?: pulumi.Input<string>;
        order?: pulumi.Input<string>;
    }
}

export namespace folder {
    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace gameservices {
    export interface GameServerClusterConnectionInfo {
        gkeClusterReference: pulumi.Input<inputs.gameservices.GameServerClusterConnectionInfoGkeClusterReference>;
        namespace: pulumi.Input<string>;
    }

    export interface GameServerClusterConnectionInfoGkeClusterReference {
        cluster: pulumi.Input<string>;
    }

    export interface GameServerConfigFleetConfig {
        fleetSpec: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface GameServerConfigScalingConfig {
        fleetAutoscalerSpec: pulumi.Input<string>;
        name: pulumi.Input<string>;
        schedules?: pulumi.Input<pulumi.Input<inputs.gameservices.GameServerConfigScalingConfigSchedule>[]>;
        selectors?: pulumi.Input<pulumi.Input<inputs.gameservices.GameServerConfigScalingConfigSelector>[]>;
    }

    export interface GameServerConfigScalingConfigSchedule {
        cronJobDuration?: pulumi.Input<string>;
        cronSpec?: pulumi.Input<string>;
        endTime?: pulumi.Input<string>;
        startTime?: pulumi.Input<string>;
    }

    export interface GameServerConfigScalingConfigSelector {
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverride {
        configVersion?: pulumi.Input<string>;
        realmsSelector?: pulumi.Input<inputs.gameservices.GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector>;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector {
        realms?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace healthcare {
    export interface DatasetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatasetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface FhirStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: pulumi.Input<boolean>;
        segmentTerminator?: pulumi.Input<string>;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }
}

export namespace identityplatform {
    export interface InboundSamlConfigIdpConfig {
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate>[]>;
        idpEntityId: pulumi.Input<string>;
        signRequest?: pulumi.Input<boolean>;
        ssoUrl: pulumi.Input<string>;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfig {
        callbackUri?: pulumi.Input<string>;
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigSpConfigSpCertificate>[]>;
        spEntityId?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate>[]>;
        idpEntityId: pulumi.Input<string>;
        signRequest?: pulumi.Input<boolean>;
        ssoUrl: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfig {
        callbackUri: pulumi.Input<string>;
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate>[]>;
        spEntityId: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        x509Certificate?: pulumi.Input<string>;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionTemplate {
        algorithm: pulumi.Input<string>;
        protectionLevel?: pulumi.Input<string>;
    }

    export interface KeyRingIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface KeyRingIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface RegistryCredential {
        /**
         * The certificate format and data.
         */
        publicKeyCertificate: pulumi.Input<inputs.kms.RegistryCredentialPublicKeyCertificate>;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        /**
         * The certificate data.
         */
        certificate: pulumi.Input<string>;
        /**
         * The field allows only  `X509_CERTIFICATE_PEM`.
         */
        format: pulumi.Input<string>;
    }

    export interface RegistryEventNotificationConfigItem {
        /**
         * PubSub topic name to publish device state updates.
         */
        pubsubTopicName: pulumi.Input<string>;
        /**
         * If the subfolder name matches this string
         * exactly, this configuration will be used. The string must not include the
         * leading '/' character. If empty, all strings are matched. Empty value can
         * only be used for the last `eventNotificationConfigs` item.
         */
        subfolderMatches?: pulumi.Input<string>;
    }

    export interface RegistryHttpConfig {
        /**
         * The field allows `HTTP_ENABLED` or `HTTP_DISABLED`.
         */
        httpEnabledState: pulumi.Input<string>;
    }

    export interface RegistryMqttConfig {
        /**
         * The field allows `MQTT_ENABLED` or `MQTT_DISABLED`.
         */
        mqttEnabledState: pulumi.Input<string>;
    }

    export interface RegistryStateNotificationConfig {
        /**
         * PubSub topic name to publish device state updates.
         */
        pubsubTopicName: pulumi.Input<string>;
    }
}

export namespace logging {
    export interface BillingAccountSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface FolderSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface MetricBucketOptions {
        explicitBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExplicitBuckets>;
        exponentialBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExponentialBuckets>;
        linearBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsLinearBuckets>;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: pulumi.Input<number>;
        numFiniteBuckets?: pulumi.Input<number>;
        scale?: pulumi.Input<number>;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: pulumi.Input<number>;
        offset?: pulumi.Input<number>;
        width?: pulumi.Input<number>;
    }

    export interface MetricMetricDescriptor {
        displayName?: pulumi.Input<string>;
        labels?: pulumi.Input<pulumi.Input<inputs.logging.MetricMetricDescriptorLabel>[]>;
        metricKind: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
        valueType: pulumi.Input<string>;
    }

    export interface MetricMetricDescriptorLabel {
        description?: pulumi.Input<string>;
        key: pulumi.Input<string>;
        valueType?: pulumi.Input<string>;
    }

    export interface OrganizationSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface ProjectSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name: pulumi.Input<string>;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsent>;
        conditionThreshold?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThreshold>;
        displayName: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentAggregation>[]>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentTrigger>;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdAggregation>[]>;
        comparison: pulumi.Input<string>;
        denominatorAggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation>[]>;
        denominatorFilter?: pulumi.Input<string>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        thresholdValue?: pulumi.Input<number>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdTrigger>;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime?: pulumi.Input<string>;
        mutatedBy?: pulumi.Input<string>;
    }

    export interface AlertPolicyDocumentation {
        content?: pulumi.Input<string>;
        mimeType?: pulumi.Input<string>;
    }

    export interface NotificationChannelSensitiveLabels {
        authToken?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        serviceKey?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigContentMatcher {
        content: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        maskHeaders?: pulumi.Input<boolean>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        useSsl?: pulumi.Input<boolean>;
        validateSsl?: pulumi.Input<boolean>;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        type: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: pulumi.Input<string>;
        resourceType?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: pulumi.Input<number>;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: inputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        condition?: inputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.
         * Each entry can have one of the following values:
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: pulumi.Input<string>;
    }

    export interface PolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface PolicyListPolicy {
        allow?: pulumi.Input<inputs.organizations.PolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.organizations.PolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface PolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace projects {
    export interface IAMAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.  The format is the same as that for `members`.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: pulumi.Input<string>;
    }

    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace pubsub {
    export interface SubscriptionDeadLetterPolicy {
        deadLetterTopic?: pulumi.Input<string>;
        maxDeliveryAttempts?: pulumi.Input<number>;
    }

    export interface SubscriptionExpirationPolicy {
        ttl: pulumi.Input<string>;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfig {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        oidcToken?: pulumi.Input<inputs.pubsub.SubscriptionPushConfigOidcToken>;
        pushEndpoint: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfigOidcToken {
        audience?: pulumi.Input<string>;
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface TopicIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConfigIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace secretmanager {
    export interface SecretIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SecretIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SecretReplication {
        automatic?: pulumi.Input<boolean>;
        userManaged?: pulumi.Input<inputs.secretmanager.SecretReplicationUserManaged>;
    }

    export interface SecretReplicationUserManaged {
        replicas: pulumi.Input<pulumi.Input<inputs.secretmanager.SecretReplicationUserManagedReplica>[]>;
    }

    export interface SecretReplicationUserManagedReplica {
        location: pulumi.Input<string>;
    }
}

export namespace serviceAccount {
    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryPubsubConfig {
        messageFormat: pulumi.Input<string>;
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        topic: pulumi.Input<string>;
    }
}

export namespace spanner {
    export interface DatabaseIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatabaseIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress?: pulumi.Input<string>;
        timeToRetire?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        /**
         * PEM representation of the trusted CA's x509
         * certificate.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * PEM representation of the slave's x509
         * certificate.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * PEM representation of the slave's private key. The
         * corresponding public key in encoded in the `clientCertificate`.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * The number of seconds
         * between connect retries.
         */
        connectRetryInterval?: pulumi.Input<number>;
        /**
         * Path to a SQL file in GCS from which slave
         * instances are created. Format is `gs://bucket/filename`.
         */
        dumpFilePath?: pulumi.Input<string>;
        /**
         * Specifies if the replica is the failover target.
         * If the field is set to true the replica will be designated as a failover replica.
         * If the master instance fails, the replica instance will be promoted as
         * the new master instance.
         */
        failoverTarget?: pulumi.Input<boolean>;
        /**
         * Time in ms between replication
         * heartbeats.
         */
        masterHeartbeatPeriod?: pulumi.Input<number>;
        /**
         * Password for the replication connection.
         */
        password?: pulumi.Input<string>;
        sslCipher?: pulumi.Input<string>;
        /**
         * Username for replication connection.
         */
        username?: pulumi.Input<string>;
        /**
         * True if the master's common name
         * value is checked during the SSL handshake.
         */
        verifyServerCertificate?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceServerCaCert {
        cert?: pulumi.Input<string>;
        commonName?: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        /**
         * The [RFC 3339](https://tools.ietf.org/html/rfc3339)
         * formatted date time string indicating when this whitelist expires.
         */
        expirationTime?: pulumi.Input<string>;
        sha1Fingerprint?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettings {
        /**
         * This specifies when the instance should be
         * active. Can be either `ALWAYS`, `NEVER` or `ON_DEMAND`.
         */
        activationPolicy?: pulumi.Input<string>;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * A list of Google App Engine (GAE) project names that are allowed to access this instance.
         */
        authorizedGaeApplications?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This specifies whether a PostgreSQL instance
         * should be set up for high availability (`REGIONAL`) or single zone (`ZONAL`).
         */
        availabilityType?: pulumi.Input<string>;
        backupConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsBackupConfiguration>;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * Specific to read instances, indicates
         * when crash-safe replication flags are enabled.
         */
        crashSafeReplication?: pulumi.Input<boolean>;
        databaseFlags?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsDatabaseFlag>[]>;
        /**
         * Configuration to increase storage size automatically.  Note that future `pulumi apply` calls will attempt to resize the disk to the value specified in `diskSize` - if this is set, do not set `diskSize`.
         */
        diskAutoresize?: pulumi.Input<boolean>;
        /**
         * The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased.
         */
        diskSize?: pulumi.Input<number>;
        /**
         * The type of data disk: PD_SSD or PD_HDD.
         */
        diskType?: pulumi.Input<string>;
        ipConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfiguration>;
        locationPreference?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsLocationPreference>;
        maintenanceWindow?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsMaintenanceWindow>;
        /**
         * Pricing plan for this instance, can only be `PER_USE`.
         */
        pricingPlan?: pulumi.Input<string>;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * Replication type for this instance, can be one of `ASYNCHRONOUS` or `SYNCHRONOUS`.
         */
        replicationType?: pulumi.Input<string>;
        /**
         * The machine type to use. See [tiers](https://cloud.google.com/sql/docs/admin-api/v1beta4/tiers)
         * for more details and supported versions. Postgres supports only shared-core machine types such as `db-f1-micro`,
         * and custom machine types such as `db-custom-2-13312`. See the [Custom Machine Type Documentation](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) to learn about specifying custom machine types.
         */
        tier: pulumi.Input<string>;
        /**
         * A set of key/value user label pairs to assign to the instance.
         */
        userLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        version?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        /**
         * True if binary logging is enabled. If
         * `settings.backup_configuration.enabled` is false, this must be as well.
         * Cannot be used with Postgres.
         */
        binaryLogEnabled?: pulumi.Input<boolean>;
        /**
         * True if backup configuration is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        location?: pulumi.Input<string>;
        /**
         * `HH:MM` format time indicating when backup
         * configuration starts.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * A name for this whitelist entry.
         */
        name: pulumi.Input<string>;
        /**
         * A CIDR notation IPv4 or IPv6 address that is allowed to
         * access this instance. Must be set even if other two attributes are not for
         * the whitelist to become active.
         */
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork>[]>;
        /**
         * Whether this Cloud SQL instance should be assigned
         * a public IPV4 address. Either `ipv4Enabled` must be enabled or a
         * `privateNetwork` must be configured.
         */
        ipv4Enabled?: pulumi.Input<boolean>;
        /**
         * The VPC network from which the Cloud SQL
         * instance is accessible for private IP. For example,projects/myProject/global/networks/default.
         * Specifying a network enables private IP.
         * Either `ipv4Enabled` must be enabled or a `privateNetwork` must be configured.
         * This setting can be updated, but it cannot be removed after it is set.
         */
        privateNetwork?: pulumi.Input<string>;
        /**
         * True if mysqld should default to `REQUIRE X509`
         * for users connecting over IP.
         */
        requireSsl?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        /**
         * The [RFC 3339](https://tools.ietf.org/html/rfc3339)
         * formatted date time string indicating when this whitelist expires.
         */
        expirationTime?: pulumi.Input<string>;
        /**
         * A name for this whitelist entry.
         */
        name?: pulumi.Input<string>;
        /**
         * A CIDR notation IPv4 or IPv6 address that is allowed to
         * access this instance. Must be set even if other two attributes are not for
         * the whitelist to become active.
         */
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        /**
         * A GAE application whose zone to remain
         * in. Must be in the same region as this instance.
         */
        followGaeApplication?: pulumi.Input<string>;
        /**
         * The preferred compute engine
         * [zone](https://cloud.google.com/compute/docs/zones?hl=en).
         */
        zone?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        /**
         * Day of week (`1-7`), starting on Monday
         */
        day?: pulumi.Input<number>;
        /**
         * Hour of day (`0-23`), ignored if `day` not set
         */
        hour?: pulumi.Input<number>;
        /**
         * Receive updates earlier (`canary`) or later
         * (`stable`)
         */
        updateTrack?: pulumi.Input<string>;
    }
}

export namespace storage {
    export interface BucketCors {
        /**
         * The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
         */
        maxAgeSeconds?: pulumi.Input<number>;
        /**
         * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
         */
        origins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
         */
        responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BucketEncryption {
        defaultKmsKeyName: pulumi.Input<string>;
    }

    export interface BucketIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BucketIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BucketLifecycleRule {
        /**
         * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
         */
        action: pulumi.Input<inputs.storage.BucketLifecycleRuleAction>;
        /**
         * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
         */
        condition: pulumi.Input<inputs.storage.BucketLifecycleRuleCondition>;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: pulumi.Input<string>;
        /**
         * The type of the action of this Lifecycle Rule. Supported values include: `Delete` and `SetStorageClass`.
         */
        type: pulumi.Input<string>;
    }

    export interface BucketLifecycleRuleCondition {
        /**
         * Minimum age of an object in days to satisfy this condition.
         */
        age?: pulumi.Input<number>;
        /**
         * Creation date of an object in RFC 3339 (e.g. `2017-06-13`) to satisfy this condition.
         */
        createdBefore?: pulumi.Input<string>;
        /**
         * [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `STANDARD`, `DURABLE_REDUCED_AVAILABILITY`.
         */
        matchesStorageClasses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
         */
        numNewerVersions?: pulumi.Input<number>;
        /**
         * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
         */
        withState?: pulumi.Input<string>;
    }

    export interface BucketLogging {
        /**
         * The bucket that will receive log objects.
         */
        logBucket: pulumi.Input<string>;
        /**
         * The object prefix for log objects. If it's not provided,
         * by default GCS sets this to this bucket's name.
         */
        logObjectPrefix?: pulumi.Input<string>;
    }

    export interface BucketRetentionPolicy {
        /**
         * If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
         */
        isLocked?: pulumi.Input<boolean>;
        /**
         * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.
         */
        retentionPeriod: pulumi.Input<number>;
    }

    export interface BucketVersioning {
        /**
         * While set to `true`, versioning is fully enabled for this bucket.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface BucketWebsite {
        /**
         * Behaves as the bucket's directory index where
         * missing objects are treated as potential directories.
         */
        mainPageSuffix?: pulumi.Input<string>;
        /**
         * The custom object to return when a requested
         * resource is not found.
         */
        notFoundPage?: pulumi.Input<string>;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface TransferJobSchedule {
        /**
         * The last day the recurring transfer will be run. If `scheduleEndDate` is the same as `scheduleStartDate`, the transfer will be executed only once. Structure documented below.
         */
        scheduleEndDate?: pulumi.Input<inputs.storage.TransferJobScheduleScheduleEndDate>;
        /**
         * The first day the recurring transfer is scheduled to run. If `scheduleStartDate` is in the past, the transfer will run for the first time on the following day. Structure documented below.
         */
        scheduleStartDate: pulumi.Input<inputs.storage.TransferJobScheduleScheduleStartDate>;
        /**
         * The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
         */
        startTimeOfDay?: pulumi.Input<inputs.storage.TransferJobScheduleStartTimeOfDay>;
    }

    export interface TransferJobScheduleScheduleEndDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleScheduleStartDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23
         */
        hours: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         */
        seconds: pulumi.Input<number>;
    }

    export interface TransferJobTransferSpec {
        /**
         * An AWS S3 data source. Structure documented below.
         */
        awsS3DataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSource>;
        /**
         * A Google Cloud Storage data sink. Structure documented below.
         */
        gcsDataSink?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSink>;
        /**
         * A Google Cloud Storage data source. Structure documented below.
         */
        gcsDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSource>;
        /**
         * An HTTP URL data source. Structure documented below.
         */
        httpDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecHttpDataSource>;
        /**
         * Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `lastModificationTime` do not exclude objects in a data sink. Structure documented below.
         */
        objectConditions?: pulumi.Input<inputs.storage.TransferJobTransferSpecObjectConditions>;
        /**
         * Characteristics of how to treat files from datasource and sink during job. If the option `deleteObjectsUniqueInSink` is true, object conditions based on objects' `lastModificationTime` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
         */
        transferOptions?: pulumi.Input<inputs.storage.TransferJobTransferSpecTransferOptions>;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        /**
         * AWS credentials block.
         */
        awsAccessKey: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey>;
        /**
         * S3 Bucket name.
         */
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        /**
         * AWS Key ID.
         */
        accessKeyId: pulumi.Input<string>;
        /**
         * AWS Secret Access Key.
         */
        secretAccessKey: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        /**
         * S3 Bucket name.
         */
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        /**
         * S3 Bucket name.
         */
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        /**
         * The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
         */
        listUrl: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecObjectConditions {
        /**
         * `excludePrefixes` must follow the requirements described for `includePrefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        excludePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If `includeRefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `includePrefixes` and that do not start with any of the `excludePrefixes`. If `includePrefixes` is not specified, all objects except those that have names starting with one of the `excludePrefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        includePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxTimeElapsedSinceLastModification?: pulumi.Input<string>;
        /**
         * 
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minTimeElapsedSinceLastModification?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecTransferOptions {
        /**
         * Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `deleteObjectsUniqueInSink` are mutually exclusive.
         */
        deleteObjectsFromSourceAfterTransfer?: pulumi.Input<boolean>;
        /**
         * Whether objects that exist only in the sink should be deleted. Note that this option and
         * `deleteObjectsFromSourceAfterTransfer` are mutually exclusive.
         */
        deleteObjectsUniqueInSink?: pulumi.Input<boolean>;
        /**
         * Whether overwriting objects that already exist in the sink is allowed.
         */
        overwriteObjectsAlreadyExistingInSink?: pulumi.Input<boolean>;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface NodeSchedulingConfig {
        preemptible: pulumi.Input<boolean>;
    }
}
