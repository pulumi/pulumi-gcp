// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ProviderBatching {
    enableBatching?: pulumi.Input<boolean>;
    sendAfter?: pulumi.Input<string>;
}

export interface ProviderExternalCredentials {
    audience: pulumi.Input<string>;
    identityToken: pulumi.Input<string>;
    serviceAccountEmail: pulumi.Input<string>;
}
export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        /**
         * How the conditions list should be combined to determine if a request
         * is granted this AccessLevel. If AND is used, each Condition in
         * conditions must be satisfied for the AccessLevel to be applied. If
         * OR is used, at least one Condition in conditions must be satisfied
         * for the AccessLevel to be applied.
         * Default value is `AND`.
         * Possible values are: `AND`, `OR`.
         */
        combiningFunction?: pulumi.Input<string>;
        /**
         * A set of requirements for the AccessLevel to be granted.
         * Structure is documented below.
         */
        conditions: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicCondition>[]>;
    }

    export interface AccessLevelBasicCondition {
        /**
         * Device specific restrictions, all restrictions must hold for
         * the Condition to be true. If not specified, all devices are
         * allowed.
         * Structure is documented below.
         */
        devicePolicy?: pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy>;
        /**
         * A list of CIDR block IP subnetwork specification. May be IPv4
         * or IPv6.
         * Note that for a CIDR IP address block, the specified IP address
         * portion must be properly truncated (i.e. all the host bits must
         * be zero) or the input is considered malformed. For example,
         * "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly,
         * for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32"
         * is not. The originating IP of a request must be in one of the
         * listed subnets in order for this Condition to be true.
         * If empty, all IP addresses are allowed.
         */
        ipSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An allowed list of members (users, service accounts).
         * Using groups is not supported yet.
         * The signed-in user originating the request must be a part of one
         * of the provided members. If not specified, a request may come
         * from any user (logged in/not logged in, not present in any
         * groups, etc.).
         * Formats: `user:{emailid}`, `serviceAccount:{emailid}`
         */
        members?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to negate the Condition. If true, the Condition becomes
         * a NAND over its non-empty fields, each field must be false for
         * the Condition overall to be satisfied. Defaults to false.
         */
        negate?: pulumi.Input<boolean>;
        /**
         * The request must originate from one of the provided
         * countries/regions.
         * Format: A valid ISO 3166-1 alpha-2 code.
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of other access levels defined in the same Policy,
         * referenced by resource name. Referencing an AccessLevel which
         * does not exist is an error. All access levels listed must be
         * granted for the Condition to be true.
         * Format: accessPolicies/{policy_id}/accessLevels/{short_name}
         */
        requiredAccessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together with `ipSubnetworks`.
         * Structure is documented below.
         */
        vpcNetworkSources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionVpcNetworkSource>[]>;
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        /**
         * A list of allowed device management levels.
         * An empty list allows all management levels.
         * Each value may be one of: `MANAGEMENT_UNSPECIFIED`, `NONE`, `BASIC`, `COMPLETE`.
         */
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed encryptions statuses.
         * An empty list allows all statuses.
         * Each value may be one of: `ENCRYPTION_UNSPECIFIED`, `ENCRYPTION_UNSUPPORTED`, `UNENCRYPTED`, `ENCRYPTED`.
         */
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed OS versions.
         * An empty list allows all types and all versions.
         * Structure is documented below.
         */
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint>[]>;
        /**
         * Whether the device needs to be approved by the customer admin.
         */
        requireAdminApproval?: pulumi.Input<boolean>;
        /**
         * Whether the device needs to be corp owned.
         */
        requireCorpOwned?: pulumi.Input<boolean>;
        /**
         * Whether or not screenlock is required for the DevicePolicy
         * to be true. Defaults to false.
         */
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        /**
         * The minimum allowed OS version. If not set, any version
         * of this OS satisfies the constraint.
         * Format: "major.minor.patch" such as "10.5.301", "9.2.1".
         */
        minimumVersion?: pulumi.Input<string>;
        /**
         * The operating system type of the device.
         * Possible values are: `OS_UNSPECIFIED`, `DESKTOP_MAC`, `DESKTOP_WINDOWS`, `DESKTOP_LINUX`, `DESKTOP_CHROME_OS`, `ANDROID`, `IOS`.
         */
        osType: pulumi.Input<string>;
        /**
         * If you specify DESKTOP_CHROME_OS for osType, you can optionally include requireVerifiedChromeOs to require Chrome Verified Access.
         */
        requireVerifiedChromeOs?: pulumi.Input<boolean>;
    }

    export interface AccessLevelBasicConditionVpcNetworkSource {
        /**
         * Sub networks within a VPC network.
         * Structure is documented below.
         */
        vpcSubnetwork?: pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionVpcNetworkSourceVpcSubnetwork>;
    }

    export interface AccessLevelBasicConditionVpcNetworkSourceVpcSubnetwork {
        /**
         * Required. Network name to be allowed by this Access Level. Networks of foreign organizations requires `compute.network.get` permission to be granted to caller.
         */
        network: pulumi.Input<string>;
        /**
         * A list of CIDR block IP subnetwork specification. Must be IPv4.
         */
        vpcIpSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelConditionDevicePolicy {
        /**
         * A list of allowed device management levels.
         * An empty list allows all management levels.
         * Each value may be one of: `MANAGEMENT_UNSPECIFIED`, `NONE`, `BASIC`, `COMPLETE`.
         */
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed encryptions statuses.
         * An empty list allows all statuses.
         * Each value may be one of: `ENCRYPTION_UNSPECIFIED`, `ENCRYPTION_UNSUPPORTED`, `UNENCRYPTED`, `ENCRYPTED`.
         */
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed OS versions.
         * An empty list allows all types and all versions.
         * Structure is documented below.
         */
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelConditionDevicePolicyOsConstraint>[]>;
        /**
         * Whether the device needs to be approved by the customer admin.
         */
        requireAdminApproval?: pulumi.Input<boolean>;
        /**
         * Whether the device needs to be corp owned.
         */
        requireCorpOwned?: pulumi.Input<boolean>;
        /**
         * Whether or not screenlock is required for the DevicePolicy
         * to be true. Defaults to false.
         */
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelConditionDevicePolicyOsConstraint {
        /**
         * The minimum allowed OS version. If not set, any version
         * of this OS satisfies the constraint.
         * Format: "major.minor.patch" such as "10.5.301", "9.2.1".
         */
        minimumVersion?: pulumi.Input<string>;
        /**
         * The operating system type of the device.
         * Possible values are: `OS_UNSPECIFIED`, `DESKTOP_MAC`, `DESKTOP_WINDOWS`, `DESKTOP_LINUX`, `DESKTOP_CHROME_OS`, `ANDROID`, `IOS`.
         */
        osType: pulumi.Input<string>;
    }

    export interface AccessLevelConditionVpcNetworkSource {
        /**
         * Sub networks within a VPC network.
         * Structure is documented below.
         */
        vpcSubnetwork?: pulumi.Input<inputs.accesscontextmanager.AccessLevelConditionVpcNetworkSourceVpcSubnetwork>;
    }

    export interface AccessLevelConditionVpcNetworkSourceVpcSubnetwork {
        /**
         * Required. Network name to be allowed by this Access Level. Networks of foreign organizations requires `compute.network.get` permission to be granted to caller.
         */
        network: pulumi.Input<string>;
        /**
         * CIDR block IP subnetwork specification. Must be IPv4.
         */
        vpcIpSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelCustom {
        /**
         * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language.
         * This page details the objects and attributes that are used to the build the CEL expressions for
         * custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec.
         * Structure is documented below.
         */
        expr: pulumi.Input<inputs.accesscontextmanager.AccessLevelCustomExpr>;
    }

    export interface AccessLevelCustomExpr {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface AccessLevelsAccessLevel {
        /**
         * A set of predefined conditions for the access level and a combining function.
         * Structure is documented below.
         */
        basic?: pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasic>;
        /**
         * Custom access level conditions are set using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request.
         * See CEL spec at: https://github.com/google/cel-spec.
         * Structure is documented below.
         */
        custom?: pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelCustom>;
        /**
         * Description of the AccessLevel and its use. Does not affect behavior.
         */
        description?: pulumi.Input<string>;
        /**
         * Resource name for the Access Level. The shortName component must begin
         * with a letter and only include alphanumeric and '_'.
         * Format: accessPolicies/{policy_id}/accessLevels/{short_name}
         */
        name: pulumi.Input<string>;
        /**
         * Human readable title. Must be unique within the Policy.
         */
        title: pulumi.Input<string>;
    }

    export interface AccessLevelsAccessLevelBasic {
        /**
         * How the conditions list should be combined to determine if a request
         * is granted this AccessLevel. If AND is used, each Condition in
         * conditions must be satisfied for the AccessLevel to be applied. If
         * OR is used, at least one Condition in conditions must be satisfied
         * for the AccessLevel to be applied.
         * Default value is `AND`.
         * Possible values are: `AND`, `OR`.
         */
        combiningFunction?: pulumi.Input<string>;
        /**
         * A set of requirements for the AccessLevel to be granted.
         * Structure is documented below.
         */
        conditions: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasicCondition>[]>;
    }

    export interface AccessLevelsAccessLevelBasicCondition {
        /**
         * Device specific restrictions, all restrictions must hold for
         * the Condition to be true. If not specified, all devices are
         * allowed.
         * Structure is documented below.
         */
        devicePolicy?: pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasicConditionDevicePolicy>;
        /**
         * A list of CIDR block IP subnetwork specification. May be IPv4
         * or IPv6.
         * Note that for a CIDR IP address block, the specified IP address
         * portion must be properly truncated (i.e. all the host bits must
         * be zero) or the input is considered malformed. For example,
         * "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly,
         * for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32"
         * is not. The originating IP of a request must be in one of the
         * listed subnets in order for this Condition to be true.
         * If empty, all IP addresses are allowed.
         */
        ipSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An allowed list of members (users, service accounts).
         * Using groups is not supported yet.
         * The signed-in user originating the request must be a part of one
         * of the provided members. If not specified, a request may come
         * from any user (logged in/not logged in, not present in any
         * groups, etc.).
         * Formats: `user:{emailid}`, `serviceAccount:{emailid}`
         */
        members?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to negate the Condition. If true, the Condition becomes
         * a NAND over its non-empty fields, each field must be false for
         * the Condition overall to be satisfied. Defaults to false.
         */
        negate?: pulumi.Input<boolean>;
        /**
         * The request must originate from one of the provided
         * countries/regions.
         * Format: A valid ISO 3166-1 alpha-2 code.
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of other access levels defined in the same Policy,
         * referenced by resource name. Referencing an AccessLevel which
         * does not exist is an error. All access levels listed must be
         * granted for the Condition to be true.
         * Format: accessPolicies/{policy_id}/accessLevels/{short_name}
         */
        requiredAccessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The request must originate from one of the provided VPC networks in Google Cloud. Cannot specify this field together with `ipSubnetworks`.
         * Structure is documented below.
         */
        vpcNetworkSources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasicConditionVpcNetworkSource>[]>;
    }

    export interface AccessLevelsAccessLevelBasicConditionDevicePolicy {
        /**
         * A list of allowed device management levels.
         * An empty list allows all management levels.
         * Each value may be one of: `MANAGEMENT_UNSPECIFIED`, `NONE`, `BASIC`, `COMPLETE`.
         */
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed encryptions statuses.
         * An empty list allows all statuses.
         * Each value may be one of: `ENCRYPTION_UNSPECIFIED`, `ENCRYPTION_UNSUPPORTED`, `UNENCRYPTED`, `ENCRYPTED`.
         */
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of allowed OS versions.
         * An empty list allows all types and all versions.
         * Structure is documented below.
         */
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasicConditionDevicePolicyOsConstraint>[]>;
        /**
         * Whether the device needs to be approved by the customer admin.
         */
        requireAdminApproval?: pulumi.Input<boolean>;
        /**
         * Whether the device needs to be corp owned.
         */
        requireCorpOwned?: pulumi.Input<boolean>;
        /**
         * Whether or not screenlock is required for the DevicePolicy
         * to be true. Defaults to false.
         */
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelsAccessLevelBasicConditionDevicePolicyOsConstraint {
        /**
         * The minimum allowed OS version. If not set, any version
         * of this OS satisfies the constraint.
         * Format: "major.minor.patch" such as "10.5.301", "9.2.1".
         */
        minimumVersion?: pulumi.Input<string>;
        /**
         * The operating system type of the device.
         * Possible values are: `OS_UNSPECIFIED`, `DESKTOP_MAC`, `DESKTOP_WINDOWS`, `DESKTOP_LINUX`, `DESKTOP_CHROME_OS`, `ANDROID`, `IOS`.
         */
        osType: pulumi.Input<string>;
    }

    export interface AccessLevelsAccessLevelBasicConditionVpcNetworkSource {
        /**
         * Sub networks within a VPC network.
         * Structure is documented below.
         */
        vpcSubnetwork?: pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelBasicConditionVpcNetworkSourceVpcSubnetwork>;
    }

    export interface AccessLevelsAccessLevelBasicConditionVpcNetworkSourceVpcSubnetwork {
        /**
         * Required. Network name to be allowed by this Access Level. Networks of foreign organizations requires `compute.network.get` permission to be granted to caller.
         */
        network: pulumi.Input<string>;
        /**
         * CIDR block IP subnetwork specification. Must be IPv4.
         */
        vpcIpSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelsAccessLevelCustom {
        /**
         * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language.
         * This page details the objects and attributes that are used to the build the CEL expressions for
         * custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec.
         * Structure is documented below.
         */
        expr: pulumi.Input<inputs.accesscontextmanager.AccessLevelsAccessLevelCustomExpr>;
    }

    export interface AccessLevelsAccessLevelCustomExpr {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface AccessPolicyIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AccessPolicyIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface GcpUserAccessBindingScopedAccessSetting {
        /**
         * Optional. Access settings for this scoped access settings. This field may be empty if dryRunSettings is set.
         * Structure is documented below.
         */
        activeSettings?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingActiveSettings>;
        /**
         * Optional. Dry-run access settings for this scoped access settings. This field may be empty if activeSettings is set. Cannot contain session settings.
         * Structure is documented below.
         */
        dryRunSettings?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingDryRunSettings>;
        /**
         * Optional. Application, etc. to which the access settings will be applied to. Implicitly, this is the scoped access settings key; as such, it must be unique and non-empty.
         * Structure is documented below.
         */
        scope?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingScope>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingActiveSettings {
        /**
         * Optional. Access level that a user must have to be granted access. Only one access level is supported, not multiple. This repeated field must have exactly one element. Example: "accessPolicies/9522/accessLevels/device_trusted"
         */
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Session settings applied to user access on a given AccessScope.
         * Structure is documented below.
         */
        sessionSettings?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingActiveSettingsSessionSettings>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingActiveSettingsSessionSettings {
        /**
         * Optional. How long a user is allowed to take between actions before a new access token must be issued. Only set for Google Cloud apps.
         */
        maxInactivity?: pulumi.Input<string>;
        /**
         * Optional. The session length. Setting this field to zero is equal to disabling session. Also can set infinite session by flipping the enabled bit to false below. If useOidcMaxAge is true, for OIDC apps, the session length will be the minimum of this field and OIDC maxAge param.
         */
        sessionLength?: pulumi.Input<string>;
        /**
         * Optional. This field enables or disables Google Cloud session length. When false, all fields set above will be disregarded and the session length is basically infinite.
         */
        sessionLengthEnabled?: pulumi.Input<boolean>;
        /**
         * Optional. The session challenges proposed to users when the Google Cloud session length is up.
         * Possible values are: `LOGIN`, `SECURITY_KEY`, `PASSWORD`.
         */
        sessionReauthMethod?: pulumi.Input<string>;
        /**
         * Optional. Only useful for OIDC apps. When false, the OIDC maxAge param, if passed in the authentication request will be ignored. When true, the re-auth period will be the minimum of the sessionLength field and the maxAge OIDC param.
         */
        useOidcMaxAge?: pulumi.Input<boolean>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingDryRunSettings {
        /**
         * Optional. Access level that a user must have to be granted access. Only one access level is supported, not multiple. This repeated field must have exactly one element. Example: "accessPolicies/9522/accessLevels/device_trusted"
         */
        accessLevels?: pulumi.Input<string>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingScope {
        /**
         * Optional. Client scope for this access scope.
         * Structure is documented below.
         */
        clientScope?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingScopeClientScope>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingScopeClientScope {
        /**
         * Optional. The application that is subject to this binding's scope.
         * Structure is documented below.
         */
        restrictedClientApplication?: pulumi.Input<inputs.accesscontextmanager.GcpUserAccessBindingScopedAccessSettingScopeClientScopeRestrictedClientApplication>;
    }

    export interface GcpUserAccessBindingScopedAccessSettingScopeClientScopeRestrictedClientApplication {
        /**
         * The OAuth client ID of the application.
         */
        clientId?: pulumi.Input<string>;
    }

    export interface GcpUserAccessBindingSessionSettings {
        /**
         * Optional. How long a user is allowed to take between actions before a new access token must be issued. Only set for Google Cloud apps.
         */
        maxInactivity?: pulumi.Input<string>;
        /**
         * Optional. The session length. Setting this field to zero is equal to disabling session. Also can set infinite session by flipping the enabled bit to false below. If useOidcMaxAge is true, for OIDC apps, the session length will be the minimum of this field and OIDC maxAge param.
         */
        sessionLength?: pulumi.Input<string>;
        /**
         * Optional. This field enables or disables Google Cloud session length. When false, all fields set above will be disregarded and the session length is basically infinite.
         */
        sessionLengthEnabled?: pulumi.Input<boolean>;
        /**
         * Optional. The session challenges proposed to users when the Google Cloud session length is up.
         * Possible values are: `LOGIN`, `SECURITY_KEY`, `PASSWORD`.
         */
        sessionReauthMethod?: pulumi.Input<string>;
        /**
         * Optional. Only useful for OIDC apps. When false, the OIDC maxAge param, if passed in the authentication request will be ignored. When true, the re-auth period will be the minimum of the sessionLength field and the maxAge OIDC param.
         */
        useOidcMaxAge?: pulumi.Input<boolean>;
    }

    export interface ServicePerimeterDryRunEgressPolicyEgressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimeterDryRunEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterDryRunEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterDryRunEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterDryRunEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterDryRunIngressPolicyIngressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimeterDryRunIngressPolicyIngressFromSource {
        /**
         * An `AccessLevel` resource name that allow resources within the
         * `ServicePerimeters` to be accessed from the internet. `AccessLevels` listed
         * must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent
         * `AccessLevel` will cause an error. If no `AccessLevel` names are listed,
         * resources within the perimeter can only be accessed via Google Cloud calls
         * with request origins within the perimeter.
         * Example `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.`
         * If * is specified, then all IngressSources will be allowed.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to ingress the perimeter.
         * Requests from these resources will be allowed to access perimeter data.
         * Currently only projects are allowed. Format `projects/{project_number}`
         * The project may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the case
         * of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterDryRunIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterDryRunIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong to
         * the service specified by serviceName field. A single `MethodSelector` entry
         * with `*` specified for the method field will allow all methods AND
         * permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterDryRunIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with `serviceName`
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterDryRunIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for method should be a valid method name for the corresponding
         * serviceName in `ApiOperation`. If `*` used as value for `method`, then
         * ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterEgressPolicyEgressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_UNSPECIFIED`, `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimeterEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterIngressPolicyIngressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimeterIngressPolicyIngressFromSource {
        /**
         * An `AccessLevel` resource name that allow resources within the
         * `ServicePerimeters` to be accessed from the internet. `AccessLevels` listed
         * must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent
         * `AccessLevel` will cause an error. If no `AccessLevel` names are listed,
         * resources within the perimeter can only be accessed via Google Cloud calls
         * with request origins within the perimeter.
         * Example `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL.`
         * If * is specified, then all IngressSources will be allowed.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to ingress the perimeter.
         * Requests from these resources will be allowed to access perimeter data.
         * Currently only projects and VPCs are allowed.
         * Project format: `projects/{projectNumber}`
         * VPC network format:
         * `//compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}`.
         * The project may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the case
         * of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong to
         * the service specified by serviceName field. A single `MethodSelector` entry
         * with `*` specified for the method field will allow all methods AND
         * permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with `serviceName`
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for method should be a valid method name for the corresponding
         * serviceName in `ApiOperation`. If `*` used as value for `method`, then
         * ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpec {
        /**
         * A list of AccessLevel resource names that allow resources within
         * the ServicePerimeter to be accessed from the internet.
         * AccessLevels listed must be in the same policy as this
         * ServicePerimeter. Referencing a nonexistent AccessLevel is a
         * syntax error. If no AccessLevel names are listed, resources within
         * the perimeter can only be accessed via GCP calls with request
         * origins within the perimeter. For Service Perimeter Bridge, must
         * be empty.
         * Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
         */
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of EgressPolicies to apply to the perimeter. A perimeter may
         * have multiple EgressPolicies, each of which is evaluated separately.
         * Access is granted if any EgressPolicy grants it. Must be empty for
         * a perimeter bridge.
         * Structure is documented below.
         */
        egressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicy>[]>;
        /**
         * List of `IngressPolicies` to apply to the perimeter. A perimeter may
         * have multiple `IngressPolicies`, each of which is evaluated
         * separately. Access is granted if any `Ingress Policy` grants it.
         * Must be empty for a perimeter bridge.
         * Structure is documented below.
         */
        ingressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicy>[]>;
        /**
         * A list of GCP resources that are inside of the service perimeter.
         * Currently only projects are allowed.
         * Format: projects/{project_number}
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * GCP services that are subject to the Service Perimeter
         * restrictions. Must contain a list of services. For example, if
         * `storage.googleapis.com` is specified, access to the storage
         * buckets inside the perimeter must meet the perimeter's access
         * restrictions.
         */
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how APIs are allowed to communicate within the Service
         * Perimeter.
         * Structure is documented below.
         */
        vpcAccessibleServices?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecVpcAccessibleServices>;
    }

    export interface ServicePerimeterSpecEgressPolicy {
        /**
         * Defines conditions on the source of a request causing this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicyEgressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and destination resources that
         * cause this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicyEgressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecEgressPolicyEgressFrom {
        /**
         * A list of identities that are allowed access through this `EgressPolicy`.
         * Should be in the format of email address. The email address should
         * represent individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_UNSPECIFIED`, `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimeterSpecEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterSpecEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecIngressPolicy {
        /**
         * Defines the conditions on the source of a request causing this `IngressPolicy`
         * to apply.
         * Structure is documented below.
         */
        ingressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicyIngressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and request destination that cause
         * this `IngressPolicy` to apply.
         * Structure is documented below.
         */
        ingressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicyIngressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecIngressPolicyIngressFrom {
        /**
         * A list of identities that are allowed access through this ingress policy.
         * Should be in the format of email address. The email address should represent
         * individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimeterSpecIngressPolicyIngressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterSpecIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterSpecIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterSpecVpcAccessibleServices {
        /**
         * The list of APIs usable within the Service Perimeter.
         * Must be empty unless `enableRestriction` is True.
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to restrict API calls within the Service Perimeter to the
         * list of APIs specified in 'allowedServices'.
         */
        enableRestriction?: pulumi.Input<boolean>;
    }

    export interface ServicePerimeterStatus {
        /**
         * A list of AccessLevel resource names that allow resources within
         * the ServicePerimeter to be accessed from the internet.
         * AccessLevels listed must be in the same policy as this
         * ServicePerimeter. Referencing a nonexistent AccessLevel is a
         * syntax error. If no AccessLevel names are listed, resources within
         * the perimeter can only be accessed via GCP calls with request
         * origins within the perimeter. For Service Perimeter Bridge, must
         * be empty.
         * Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
         */
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of EgressPolicies to apply to the perimeter. A perimeter may
         * have multiple EgressPolicies, each of which is evaluated separately.
         * Access is granted if any EgressPolicy grants it. Must be empty for
         * a perimeter bridge.
         * Structure is documented below.
         */
        egressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicy>[]>;
        /**
         * List of `IngressPolicies` to apply to the perimeter. A perimeter may
         * have multiple `IngressPolicies`, each of which is evaluated
         * separately. Access is granted if any `Ingress Policy` grants it.
         * Must be empty for a perimeter bridge.
         * Structure is documented below.
         */
        ingressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicy>[]>;
        /**
         * A list of GCP resources that are inside of the service perimeter.
         * Currently only projects are allowed.
         * Format: projects/{project_number}
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * GCP services that are subject to the Service Perimeter
         * restrictions. Must contain a list of services. For example, if
         * `storage.googleapis.com` is specified, access to the storage
         * buckets inside the perimeter must meet the perimeter's access
         * restrictions.
         */
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how APIs are allowed to communicate within the Service
         * Perimeter.
         * Structure is documented below.
         */
        vpcAccessibleServices?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusVpcAccessibleServices>;
    }

    export interface ServicePerimeterStatusEgressPolicy {
        /**
         * Defines conditions on the source of a request causing this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicyEgressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and destination resources that
         * cause this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicyEgressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusEgressPolicyEgressFrom {
        /**
         * A list of identities that are allowed access through this `EgressPolicy`.
         * Should be in the format of email address. The email address should
         * represent individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_UNSPECIFIED`, `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimeterStatusEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterStatusEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusIngressPolicy {
        /**
         * Defines the conditions on the source of a request causing this `IngressPolicy`
         * to apply.
         * Structure is documented below.
         */
        ingressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicyIngressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and request destination that cause
         * this `IngressPolicy` to apply.
         * Structure is documented below.
         */
        ingressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicyIngressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusIngressPolicyIngressFrom {
        /**
         * A list of identities that are allowed access through this ingress policy.
         * Should be in the format of email address. The email address should represent
         * individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimeterStatusIngressPolicyIngressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimeterStatusIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimeterStatusIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatusVpcAccessibleServices {
        /**
         * The list of APIs usable within the Service Perimeter.
         * Must be empty unless `enableRestriction` is True.
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to restrict API calls within the Service Perimeter to the
         * list of APIs specified in 'allowedServices'.
         */
        enableRestriction?: pulumi.Input<boolean>;
    }

    export interface ServicePerimetersServicePerimeter {
        /**
         * (Output)
         * Time the AccessPolicy was created in UTC.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Description of the ServicePerimeter and its use. Does not affect
         * behavior.
         */
        description?: pulumi.Input<string>;
        /**
         * Resource name for the ServicePerimeter. The shortName component must
         * begin with a letter and only include alphanumeric and '_'.
         * Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}
         */
        name: pulumi.Input<string>;
        /**
         * Specifies the type of the Perimeter. There are two types: regular and
         * bridge. Regular Service Perimeter contains resources, access levels,
         * and restricted services. Every resource can be in at most
         * ONE regular Service Perimeter.
         * In addition to being in a regular service perimeter, a resource can also
         * be in zero or more perimeter bridges. A perimeter bridge only contains
         * resources. Cross project operations are permitted if all effected
         * resources share some perimeter (whether bridge or regular). Perimeter
         * Bridge does not contain access levels or services: those are governed
         * entirely by the regular perimeter that resource is in.
         * Perimeter Bridges are typically useful when building more complex
         * topologies with many independent perimeters that need to share some data
         * with a common perimeter, but should not be able to share data among
         * themselves.
         * Default value is `PERIMETER_TYPE_REGULAR`.
         * Possible values are: `PERIMETER_TYPE_REGULAR`, `PERIMETER_TYPE_BRIDGE`.
         */
        perimeterType?: pulumi.Input<string>;
        /**
         * Proposed (or dry run) ServicePerimeter configuration.
         * This configuration allows to specify and test ServicePerimeter configuration
         * without enforcing actual access restrictions. Only allowed to be set when
         * the `useExplicitDryRunSpec` flag is set.
         * Structure is documented below.
         */
        spec?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpec>;
        /**
         * ServicePerimeter configuration. Specifies sets of resources,
         * restricted services and access levels that determine
         * perimeter content and boundaries.
         * Structure is documented below.
         */
        status?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatus>;
        /**
         * Human readable title. Must be unique within the Policy.
         */
        title: pulumi.Input<string>;
        /**
         * (Output)
         * Time the AccessPolicy was updated in UTC.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists
         * for all Service Perimeters, and that spec is identical to the status for those
         * Service Perimeters. When this flag is set, it inhibits the generation of the
         * implicit spec, thereby allowing the user to explicitly provide a
         * configuration ("spec") to use in a dry-run version of the Service Perimeter.
         * This allows the user to test changes to the enforced config ("status") without
         * actually enforcing them. This testing is done through analyzing the differences
         * between currently enforced and suggested restrictions. useExplicitDryRunSpec must
         * bet set to True if any of the fields in the spec are set to non-default values.
         */
        useExplicitDryRunSpec?: pulumi.Input<boolean>;
    }

    export interface ServicePerimetersServicePerimeterSpec {
        /**
         * A list of AccessLevel resource names that allow resources within
         * the ServicePerimeter to be accessed from the internet.
         * AccessLevels listed must be in the same policy as this
         * ServicePerimeter. Referencing a nonexistent AccessLevel is a
         * syntax error. If no AccessLevel names are listed, resources within
         * the perimeter can only be accessed via GCP calls with request
         * origins within the perimeter. For Service Perimeter Bridge, must
         * be empty.
         * Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
         */
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of EgressPolicies to apply to the perimeter. A perimeter may
         * have multiple EgressPolicies, each of which is evaluated separately.
         * Access is granted if any EgressPolicy grants it. Must be empty for
         * a perimeter bridge.
         * Structure is documented below.
         */
        egressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicy>[]>;
        /**
         * List of `IngressPolicies` to apply to the perimeter. A perimeter may
         * have multiple `IngressPolicies`, each of which is evaluated
         * separately. Access is granted if any `Ingress Policy` grants it.
         * Must be empty for a perimeter bridge.
         * Structure is documented below.
         */
        ingressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicy>[]>;
        /**
         * A list of GCP resources that are inside of the service perimeter.
         * Currently only projects are allowed.
         * Format: projects/{project_number}
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * GCP services that are subject to the Service Perimeter
         * restrictions. Must contain a list of services. For example, if
         * `storage.googleapis.com` is specified, access to the storage
         * buckets inside the perimeter must meet the perimeter's access
         * restrictions.
         */
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how APIs are allowed to communicate within the Service
         * Perimeter.
         * Structure is documented below.
         */
        vpcAccessibleServices?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecVpcAccessibleServices>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicy {
        /**
         * Defines conditions on the source of a request causing this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicyEgressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and destination resources that
         * cause this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicyEgressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicyEgressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_UNSPECIFIED`, `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicy {
        /**
         * Defines the conditions on the source of a request causing this `IngressPolicy`
         * to apply.
         * Structure is documented below.
         */
        ingressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicyIngressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and request destination that cause
         * this `IngressPolicy` to apply.
         * Structure is documented below.
         */
        ingressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicyIngressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicyIngressFrom {
        /**
         * A list of identities that are allowed access through this ingress policy.
         * Should be in the format of email address. The email address should represent
         * individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicyIngressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterSpecIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterSpecVpcAccessibleServices {
        /**
         * The list of APIs usable within the Service Perimeter.
         * Must be empty unless `enableRestriction` is True.
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to restrict API calls within the Service Perimeter to the
         * list of APIs specified in 'allowedServices'.
         */
        enableRestriction?: pulumi.Input<boolean>;
    }

    export interface ServicePerimetersServicePerimeterStatus {
        /**
         * A list of AccessLevel resource names that allow resources within
         * the ServicePerimeter to be accessed from the internet.
         * AccessLevels listed must be in the same policy as this
         * ServicePerimeter. Referencing a nonexistent AccessLevel is a
         * syntax error. If no AccessLevel names are listed, resources within
         * the perimeter can only be accessed via GCP calls with request
         * origins within the perimeter. For Service Perimeter Bridge, must
         * be empty.
         * Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}
         */
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of EgressPolicies to apply to the perimeter. A perimeter may
         * have multiple EgressPolicies, each of which is evaluated separately.
         * Access is granted if any EgressPolicy grants it. Must be empty for
         * a perimeter bridge.
         * Structure is documented below.
         */
        egressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicy>[]>;
        /**
         * List of `IngressPolicies` to apply to the perimeter. A perimeter may
         * have multiple `IngressPolicies`, each of which is evaluated
         * separately. Access is granted if any `Ingress Policy` grants it.
         * Must be empty for a perimeter bridge.
         * Structure is documented below.
         */
        ingressPolicies?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicy>[]>;
        /**
         * A list of GCP resources that are inside of the service perimeter.
         * Currently only projects are allowed.
         * Format: projects/{project_number}
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * GCP services that are subject to the Service Perimeter
         * restrictions. Must contain a list of services. For example, if
         * `storage.googleapis.com` is specified, access to the storage
         * buckets inside the perimeter must meet the perimeter's access
         * restrictions.
         */
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how APIs are allowed to communicate within the Service
         * Perimeter.
         * Structure is documented below.
         */
        vpcAccessibleServices?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusVpcAccessibleServices>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicy {
        /**
         * Defines conditions on the source of a request causing this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicyEgressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and destination resources that
         * cause this `EgressPolicy` to apply.
         * Structure is documented below.
         */
        egressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicyEgressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicyEgressFrom {
        /**
         * Identities can be an individual user, service account, Google group,
         * or third-party identity. For third-party identity, only single identities
         * are supported and other identity types are not supported.The v1 identities
         * that have the prefix user, group and serviceAccount in
         * https://cloud.google.com/iam/docs/principal-identifiers#v1 are supported.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access to outside the
         * perimeter. If left unspecified, then members of `identities` field will
         * be allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Whether to enforce traffic restrictions based on `sources` field. If the `sources` field is non-empty, then this field must be set to `SOURCE_RESTRICTION_ENABLED`.
         * Possible values are: `SOURCE_RESTRICTION_UNSPECIFIED`, `SOURCE_RESTRICTION_ENABLED`, `SOURCE_RESTRICTION_DISABLED`.
         */
        sourceRestriction?: pulumi.Input<string>;
        /**
         * Sources that this EgressPolicy authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicyEgressFromSource>[]>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicyEgressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicyEgressTo {
        /**
         * A list of external resources that are allowed to be accessed. A request
         * matches if it contains an external resource in this list (Example:
         * s3://bucket/path). Currently '*' is not allowed.
         */
        externalResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of `ApiOperations` that this egress rule applies to. A request matches
         * if it contains an operation/service in this list.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicyEgressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, that match this to stanza. A request matches
         * if it contains a resource in this list. If * is specified for resources,
         * then this `EgressTo` rule will authorize access to all resources outside
         * the perimeter.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `EgressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicyEgressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusEgressPolicyEgressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusEgressPolicyEgressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicy {
        /**
         * Defines the conditions on the source of a request causing this `IngressPolicy`
         * to apply.
         * Structure is documented below.
         */
        ingressFrom?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicyIngressFrom>;
        /**
         * Defines the conditions on the `ApiOperation` and request destination that cause
         * this `IngressPolicy` to apply.
         * Structure is documented below.
         */
        ingressTo?: pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicyIngressTo>;
        /**
         * Human readable title. Must be unique within the perimeter. Does not affect behavior.
         */
        title?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicyIngressFrom {
        /**
         * A list of identities that are allowed access through this ingress policy.
         * Should be in the format of email address. The email address should represent
         * individual user or service account only.
         */
        identities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the type of identities that are allowed access from outside the
         * perimeter. If left unspecified, then members of `identities` field will be
         * allowed access.
         * Possible values are: `IDENTITY_TYPE_UNSPECIFIED`, `ANY_IDENTITY`, `ANY_USER_ACCOUNT`, `ANY_SERVICE_ACCOUNT`.
         */
        identityType?: pulumi.Input<string>;
        /**
         * Sources that this `IngressPolicy` authorizes access from.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicyIngressFromSource>[]>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicyIngressFromSource {
        /**
         * An AccessLevel resource name that allows resources outside the ServicePerimeter to be accessed from the inside.
         */
        accessLevel?: pulumi.Input<string>;
        /**
         * A Google Cloud resource that is allowed to egress the perimeter.
         * Requests from these resources are allowed to access data outside the perimeter.
         * Currently only projects are allowed. Project format: `projects/{project_number}`.
         * The resource may be in any Google Cloud organization, not just the
         * organization that the perimeter is defined in. `*` is not allowed, the
         * case of allowing all Google Cloud resources only is not supported.
         */
        resource?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicyIngressTo {
        /**
         * A list of `ApiOperations` the sources specified in corresponding `IngressFrom`
         * are allowed to perform in this `ServicePerimeter`.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicyIngressToOperation>[]>;
        /**
         * A list of resources, currently only projects in the form
         * `projects/<projectnumber>`, protected by this `ServicePerimeter`
         * that are allowed to be accessed by sources defined in the
         * corresponding `IngressFrom`. A request matches if it contains
         * a resource in this list. If `*` is specified for resources,
         * then this `IngressTo` rule will authorize access to all
         * resources inside the perimeter, provided that the request
         * also matches the `operations` field.
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of IAM roles that represent the set of operations that the sources
         * specified in the corresponding `IngressFrom`
         * are allowed to perform.
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicyIngressToOperation {
        /**
         * API methods or permissions to allow. Method or permission must belong
         * to the service specified by `serviceName` field. A single MethodSelector
         * entry with `*` specified for the `method` field will allow all methods
         * AND permissions for the service specified in `serviceName`.
         * Structure is documented below.
         */
        methodSelectors?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.ServicePerimetersServicePerimeterStatusIngressPolicyIngressToOperationMethodSelector>[]>;
        /**
         * The name of the API whose methods or permissions the `IngressPolicy` or
         * `EgressPolicy` want to allow. A single `ApiOperation` with serviceName
         * field set to `*` will allow all methods AND permissions for all services.
         */
        serviceName?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusIngressPolicyIngressToOperationMethodSelector {
        /**
         * Value for `method` should be a valid method name for the corresponding
         * `serviceName` in `ApiOperation`. If `*` used as value for method,
         * then ALL methods and permissions are allowed.
         */
        method?: pulumi.Input<string>;
        /**
         * Value for permission should be a valid Cloud IAM permission for the
         * corresponding `serviceName` in `ApiOperation`.
         */
        permission?: pulumi.Input<string>;
    }

    export interface ServicePerimetersServicePerimeterStatusVpcAccessibleServices {
        /**
         * The list of APIs usable within the Service Perimeter.
         * Must be empty unless `enableRestriction` is True.
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to restrict API calls within the Service Perimeter to the
         * list of APIs specified in 'allowedServices'.
         */
        enableRestriction?: pulumi.Input<boolean>;
    }
}

export namespace alloydb {
    export interface BackupEncryptionConfig {
        /**
         * The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface BackupEncryptionInfo {
        /**
         * (Output)
         * Output only. Type of encryption.
         */
        encryptionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Cloud KMS key versions that are being used to protect the database or the backup.
         */
        kmsKeyVersions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackupExpiryQuantity {
        /**
         * (Output)
         * Output only. The backup's position among its backups with the same source cluster and type, by descending chronological order create time (i.e. newest first).
         */
        retentionCount?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. The length of the quantity-based queue, specified by the backup's retention policy.
         */
        totalRetentionCount?: pulumi.Input<number>;
    }

    export interface ClusterAutomatedBackupPolicy {
        /**
         * The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
         * The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        backupWindow?: pulumi.Input<string>;
        /**
         * Whether automated backups are enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
         * Structure is documented below.
         */
        encryptionConfig?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicyEncryptionConfig>;
        /**
         * Labels to apply to backups created using this configuration.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
         */
        location?: pulumi.Input<string>;
        /**
         * Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
         * Structure is documented below.
         */
        quantityBasedRetention?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicyQuantityBasedRetention>;
        /**
         * Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
         * Structure is documented below.
         */
        timeBasedRetention?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicyTimeBasedRetention>;
        /**
         * Weekly schedule for the Backup.
         * Structure is documented below.
         */
        weeklySchedule?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicyWeeklySchedule>;
    }

    export interface ClusterAutomatedBackupPolicyEncryptionConfig {
        /**
         * The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface ClusterAutomatedBackupPolicyQuantityBasedRetention {
        /**
         * The number of backups to retain.
         */
        count?: pulumi.Input<number>;
    }

    export interface ClusterAutomatedBackupPolicyTimeBasedRetention {
        /**
         * The retention period.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        retentionPeriod?: pulumi.Input<string>;
    }

    export interface ClusterAutomatedBackupPolicyWeeklySchedule {
        /**
         * The days of the week to perform a backup. At least one day of the week must be provided.
         * Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        daysOfWeeks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
         * Structure is documented below.
         */
        startTimes: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicyWeeklyScheduleStartTime>[]>;
    }

    export interface ClusterAutomatedBackupPolicyWeeklyScheduleStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Currently, only the value 0 is supported.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Currently, only the value 0 is supported.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface ClusterBackupSource {
        /**
         * The name of the backup resource.
         */
        backupName?: pulumi.Input<string>;
    }

    export interface ClusterContinuousBackupConfig {
        /**
         * Whether continuous backup recovery is enabled. If not set, defaults to true.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
         * Structure is documented below.
         */
        encryptionConfig?: pulumi.Input<inputs.alloydb.ClusterContinuousBackupConfigEncryptionConfig>;
        /**
         * The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
         * If not set, defaults to 14 days.
         */
        recoveryWindowDays?: pulumi.Input<number>;
    }

    export interface ClusterContinuousBackupConfigEncryptionConfig {
        /**
         * The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface ClusterContinuousBackupInfo {
        /**
         * (Output)
         * The earliest restorable time that can be restored to. Output only field.
         */
        earliestRestorableTime?: pulumi.Input<string>;
        /**
         * (Output)
         * When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
         */
        enabledTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
         * Structure is documented below.
         */
        encryptionInfos?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterContinuousBackupInfoEncryptionInfo>[]>;
        /**
         * (Output)
         * Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
         */
        schedules?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterContinuousBackupInfoEncryptionInfo {
        /**
         * (Output)
         * Output only. Type of encryption.
         */
        encryptionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Cloud KMS key versions that are being used to protect the database or the backup.
         */
        kmsKeyVersions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterEncryptionConfig {
        /**
         * The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface ClusterEncryptionInfo {
        /**
         * (Output)
         * Output only. Type of encryption.
         */
        encryptionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Cloud KMS key versions that are being used to protect the database or the backup.
         */
        kmsKeyVersions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterInitialUser {
        /**
         * The initial password for the user.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * The database username.
         */
        user?: pulumi.Input<string>;
    }

    export interface ClusterMaintenanceUpdatePolicy {
        /**
         * Preferred windows to perform maintenance. Currently limited to 1.
         * Structure is documented below.
         */
        maintenanceWindows?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterMaintenanceUpdatePolicyMaintenanceWindow>[]>;
    }

    export interface ClusterMaintenanceUpdatePolicyMaintenanceWindow {
        /**
         * Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.alloydb.ClusterMaintenanceUpdatePolicyMaintenanceWindowStartTime>;
    }

    export interface ClusterMaintenanceUpdatePolicyMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         */
        hours: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Currently, only the value 0 is supported.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Currently, only the value 0 is supported.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface ClusterMigrationSource {
        /**
         * The host and port of the on-premises instance in host:port format
         */
        hostPort?: pulumi.Input<string>;
        /**
         * Place holder for the external source identifier(e.g DMS job name) that created the cluster.
         */
        referenceId?: pulumi.Input<string>;
        /**
         * Type of migration source.
         */
        sourceType?: pulumi.Input<string>;
    }

    export interface ClusterNetworkConfig {
        /**
         * The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
         * If set, the instance IPs for this cluster will be created in the allocated range.
         */
        allocatedIpRange?: pulumi.Input<string>;
        /**
         * The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
         * It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
         */
        network?: pulumi.Input<string>;
    }

    export interface ClusterPscConfig {
        /**
         * Create an instance that allows connections from Private Service Connect endpoints to the instance.
         */
        pscEnabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The project number that needs to be allowlisted on the network attachment to enable outbound connectivity, if the network attachment is configured to ACCEPT_MANUAL connections.
         * In case the network attachment is configured to ACCEPT_AUTOMATIC, this project number does not need to be allowlisted explicitly.
         */
        serviceOwnedProjectNumber?: pulumi.Input<number>;
    }

    export interface ClusterRestoreBackupSource {
        /**
         * The name of the backup that this cluster is restored from.
         */
        backupName: pulumi.Input<string>;
    }

    export interface ClusterRestoreContinuousBackupSource {
        /**
         * The name of the source cluster that this cluster is restored from.
         */
        cluster: pulumi.Input<string>;
        /**
         * The point in time that this cluster is restored to, in RFC 3339 format.
         */
        pointInTime: pulumi.Input<string>;
    }

    export interface ClusterSecondaryConfig {
        /**
         * Name of the primary cluster must be in the format
         * 'projects/{project}/locations/{location}/clusters/{cluster_id}'
         */
        primaryClusterName: pulumi.Input<string>;
    }

    export interface ClusterTrialMetadata {
        /**
         * End time of the trial cluster.
         */
        endTime?: pulumi.Input<string>;
        /**
         * Grace end time of the trial cluster.
         */
        graceEndTime?: pulumi.Input<string>;
        /**
         * Start time of the trial cluster.
         */
        startTime?: pulumi.Input<string>;
        /**
         * Upgrade time of the trial cluster to standard cluster.
         */
        upgradeTime?: pulumi.Input<string>;
    }

    export interface InstanceClientConnectionConfig {
        /**
         * Configuration to enforce connectors only (ex: AuthProxy) connections to the database.
         */
        requireConnectors?: pulumi.Input<boolean>;
        /**
         * SSL config option for this instance.
         * Structure is documented below.
         */
        sslConfig?: pulumi.Input<inputs.alloydb.InstanceClientConnectionConfigSslConfig>;
    }

    export interface InstanceClientConnectionConfigSslConfig {
        /**
         * SSL mode. Specifies client-server SSL/TLS connection behavior.
         * Possible values are: `ENCRYPTED_ONLY`, `ALLOW_UNENCRYPTED_AND_ENCRYPTED`.
         */
        sslMode?: pulumi.Input<string>;
    }

    export interface InstanceMachineConfig {
        /**
         * The number of CPU's in the VM instance.
         */
        cpuCount?: pulumi.Input<number>;
        /**
         * Machine type of the VM instance.
         * E.g. "n2-highmem-4", "n2-highmem-8", "c4a-highmem-4-lssd".
         * `cpuCount` must match the number of vCPUs in the machine type.
         */
        machineType?: pulumi.Input<string>;
    }

    export interface InstanceNetworkConfig {
        /**
         * A list of external networks authorized to access this instance. This
         * field is only allowed to be set when `enablePublicIp` is set to
         * true.
         * Structure is documented below.
         */
        authorizedExternalNetworks?: pulumi.Input<pulumi.Input<inputs.alloydb.InstanceNetworkConfigAuthorizedExternalNetwork>[]>;
        /**
         * Enabling outbound public ip for the instance.
         */
        enableOutboundPublicIp?: pulumi.Input<boolean>;
        /**
         * Enabling public ip for the instance. If a user wishes to disable this,
         * please also clear the list of the authorized external networks set on
         * the same instance.
         */
        enablePublicIp?: pulumi.Input<boolean>;
    }

    export interface InstanceNetworkConfigAuthorizedExternalNetwork {
        /**
         * CIDR range for one authorized network of the instance.
         */
        cidrRange?: pulumi.Input<string>;
    }

    export interface InstanceObservabilityConfig {
        /**
         * Whether assistive experiences are enabled for this AlloyDB instance.
         */
        assistiveExperiencesEnabled?: pulumi.Input<boolean>;
        /**
         * Observability feature status for an instance.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Query string length. The default value is 10240. Any integer between 1024 and 100000 is considered valid.
         */
        maxQueryStringLength?: pulumi.Input<number>;
        /**
         * Preserve comments in the query string.
         */
        preserveComments?: pulumi.Input<boolean>;
        /**
         * Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 200 is considered valid.
         */
        queryPlansPerMinute?: pulumi.Input<number>;
        /**
         * Record application tags for an instance. This flag is turned "on" by default.
         */
        recordApplicationTags?: pulumi.Input<boolean>;
        /**
         * Track actively running queries. If not set, default value is "off".
         */
        trackActiveQueries?: pulumi.Input<boolean>;
        /**
         * Record wait event types during query execution for an instance.
         */
        trackWaitEventTypes?: pulumi.Input<boolean>;
        /**
         * Record wait events during query execution for an instance.
         */
        trackWaitEvents?: pulumi.Input<boolean>;
    }

    export interface InstancePscInstanceConfig {
        /**
         * List of consumer projects that are allowed to create PSC endpoints to service-attachments to this instance.
         * These should be specified as project numbers only.
         */
        allowedConsumerProjects?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configurations for setting up PSC service automation.
         * Structure is documented below.
         */
        pscAutoConnections?: pulumi.Input<pulumi.Input<inputs.alloydb.InstancePscInstanceConfigPscAutoConnection>[]>;
        /**
         * (Output)
         * The DNS name of the instance for PSC connectivity.
         * Name convention: <uid>.<uid>.<region>.alloydb-psc.goog
         */
        pscDnsName?: pulumi.Input<string>;
        /**
         * Configurations for setting up PSC interfaces attached to the instance
         * which are used for outbound connectivity. Currently, AlloyDB supports only 0 or 1 PSC interface.
         * Structure is documented below.
         */
        pscInterfaceConfigs?: pulumi.Input<pulumi.Input<inputs.alloydb.InstancePscInstanceConfigPscInterfaceConfig>[]>;
        /**
         * (Output)
         * The service attachment created when Private Service Connect (PSC) is enabled for the instance.
         * The name of the resource will be in the format of
         * `projects/<alloydb-tenant-project-number>/regions/<region-name>/serviceAttachments/<service-attachment-name>`
         */
        serviceAttachmentLink?: pulumi.Input<string>;
    }

    export interface InstancePscInstanceConfigPscAutoConnection {
        /**
         * The consumer network for the PSC service automation, example:
         * "projects/vpc-host-project/global/networks/default".
         * The consumer network might be hosted a different project than the
         * consumer project. The API expects the consumer project specified to be
         * the project ID (and not the project number)
         */
        consumerNetwork?: pulumi.Input<string>;
        /**
         * (Output)
         * The status of the service connection policy.
         */
        consumerNetworkStatus?: pulumi.Input<string>;
        /**
         * The consumer project to which the PSC service automation endpoint will
         * be created. The API expects the consumer project to be the project ID(
         * and not the project number).
         */
        consumerProject?: pulumi.Input<string>;
        /**
         * (Output)
         * The IP address of the PSC service automation endpoint.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * The status of the PSC service automation connection.
         */
        status?: pulumi.Input<string>;
    }

    export interface InstancePscInstanceConfigPscInterfaceConfig {
        /**
         * The network attachment resource created in the consumer project to which the PSC interface will be linked.
         * This is of the format: "projects/${CONSUMER_PROJECT}/regions/${REGION}/networkAttachments/${NETWORK_ATTACHMENT_NAME}".
         * The network attachment must be in the same region as the instance.
         */
        networkAttachmentResource?: pulumi.Input<string>;
    }

    export interface InstanceQueryInsightsConfig {
        /**
         * Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 20 is considered valid.
         */
        queryPlansPerMinute?: pulumi.Input<number>;
        /**
         * Query string length. The default value is 1024. Any integer between 256 and 4500 is considered valid.
         */
        queryStringLength?: pulumi.Input<number>;
        /**
         * Record application tags for an instance. This flag is turned "on" by default.
         */
        recordApplicationTags?: pulumi.Input<boolean>;
        /**
         * Record client address for an instance. Client address is PII information. This flag is turned "on" by default.
         */
        recordClientAddress?: pulumi.Input<boolean>;
    }

    export interface InstanceReadPoolConfig {
        /**
         * Read capacity, i.e. number of nodes in a read pool instance.
         */
        nodeCount?: pulumi.Input<number>;
    }
}

export namespace apigateway {
    export interface ApiConfigGatewayConfig {
        /**
         * Backend settings that are applied to all backends of the Gateway.
         * Structure is documented below.
         */
        backendConfig: pulumi.Input<inputs.apigateway.ApiConfigGatewayConfigBackendConfig>;
    }

    export interface ApiConfigGatewayConfigBackendConfig {
        /**
         * Google Cloud IAM service account used to sign OIDC tokens for backends that have authentication configured
         * (https://cloud.google.com/service-infrastructure/docs/service-management/reference/rest/v1/services.configs#backend).
         */
        googleServiceAccount: pulumi.Input<string>;
    }

    export interface ApiConfigGrpcService {
        /**
         * Input only. File descriptor set, generated by protoc.
         * To generate, use protoc with imports and source info included. For an example test.proto file, the following command would put the value in a new file named out.pb.
         * $ protoc --include_imports --include_source_info test.proto -o out.pb
         * Structure is documented below.
         */
        fileDescriptorSet: pulumi.Input<inputs.apigateway.ApiConfigGrpcServiceFileDescriptorSet>;
        /**
         * Uncompiled proto files associated with the descriptor set, used for display purposes (server-side compilation is not supported). These should match the inputs to 'protoc' command used to generate fileDescriptorSet.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.apigateway.ApiConfigGrpcServiceSource>[]>;
    }

    export interface ApiConfigGrpcServiceFileDescriptorSet {
        /**
         * Base64 encoded content of the file.
         */
        contents: pulumi.Input<string>;
        /**
         * The file path (full or relative path). This is typically the path of the file when it is uploaded.
         */
        path: pulumi.Input<string>;
    }

    export interface ApiConfigGrpcServiceSource {
        /**
         * Base64 encoded content of the file.
         */
        contents: pulumi.Input<string>;
        /**
         * The file path (full or relative path). This is typically the path of the file when it is uploaded.
         */
        path: pulumi.Input<string>;
    }

    export interface ApiConfigIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ApiConfigIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ApiConfigManagedServiceConfig {
        /**
         * Base64 encoded content of the file.
         */
        contents: pulumi.Input<string>;
        /**
         * The file path (full or relative path). This is typically the path of the file when it is uploaded.
         */
        path: pulumi.Input<string>;
    }

    export interface ApiConfigOpenapiDocument {
        /**
         * The OpenAPI Specification document file.
         * Structure is documented below.
         */
        document: pulumi.Input<inputs.apigateway.ApiConfigOpenapiDocumentDocument>;
    }

    export interface ApiConfigOpenapiDocumentDocument {
        /**
         * Base64 encoded content of the file.
         */
        contents: pulumi.Input<string>;
        /**
         * The file path (full or relative path). This is typically the path of the file when it is uploaded.
         */
        path: pulumi.Input<string>;
    }

    export interface ApiIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ApiIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface GatewayIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface GatewayIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace apigee {
    export interface AddonsConfigAddonsConfig {
        /**
         * Configuration for the Monetization add-on.
         * Structure is documented below.
         */
        advancedApiOpsConfig?: pulumi.Input<inputs.apigee.AddonsConfigAddonsConfigAdvancedApiOpsConfig>;
        /**
         * Configuration for the Monetization add-on.
         * Structure is documented below.
         */
        apiSecurityConfig?: pulumi.Input<inputs.apigee.AddonsConfigAddonsConfigApiSecurityConfig>;
        /**
         * Configuration for the Monetization add-on.
         * Structure is documented below.
         */
        connectorsPlatformConfig?: pulumi.Input<inputs.apigee.AddonsConfigAddonsConfigConnectorsPlatformConfig>;
        /**
         * Configuration for the Monetization add-on.
         * Structure is documented below.
         */
        integrationConfig?: pulumi.Input<inputs.apigee.AddonsConfigAddonsConfigIntegrationConfig>;
        /**
         * Configuration for the Monetization add-on.
         * Structure is documented below.
         */
        monetizationConfig?: pulumi.Input<inputs.apigee.AddonsConfigAddonsConfigMonetizationConfig>;
    }

    export interface AddonsConfigAddonsConfigAdvancedApiOpsConfig {
        /**
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface AddonsConfigAddonsConfigApiSecurityConfig {
        /**
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        expiresAt?: pulumi.Input<string>;
    }

    export interface AddonsConfigAddonsConfigConnectorsPlatformConfig {
        /**
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        expiresAt?: pulumi.Input<string>;
    }

    export interface AddonsConfigAddonsConfigIntegrationConfig {
        /**
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface AddonsConfigAddonsConfigMonetizationConfig {
        /**
         * Flag that specifies whether the Advanced API Ops add-on is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApiMetaData {
        /**
         * Time at which the API proxy was created, in milliseconds since epoch.
         */
        createdAt?: pulumi.Input<string>;
        /**
         * Time at which the API proxy was most recently modified, in milliseconds since epoch.
         */
        lastModifiedAt?: pulumi.Input<string>;
        /**
         * The type of entity described
         */
        subType?: pulumi.Input<string>;
    }

    export interface AppGroupAttribute {
        /**
         * Key of the attribute
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the attribute
         */
        value?: pulumi.Input<string>;
    }

    export interface DeveloperAttribute {
        /**
         * Key of the attribute
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the attribute
         */
        value?: pulumi.Input<string>;
    }

    export interface DnsZonePeeringConfig {
        /**
         * The name of the producer VPC network.
         *
         * - - -
         */
        targetNetworkId: pulumi.Input<string>;
        /**
         * The ID of the project that contains the producer VPC network.
         */
        targetProjectId: pulumi.Input<string>;
    }

    export interface EnvironmentIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EnvironmentIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EnvironmentNodeConfig {
        /**
         * (Output)
         * The current total number of gateway nodes that each environment currently has across
         * all instances.
         */
        currentAggregateNodeCount?: pulumi.Input<string>;
        /**
         * The maximum total number of gateway nodes that the is reserved for all instances that
         * has the specified environment. If not specified, the default is determined by the
         * recommended maximum number of nodes for that gateway.
         */
        maxNodeCount?: pulumi.Input<string>;
        /**
         * The minimum total number of gateway nodes that the is reserved for all instances that
         * has the specified environment. If not specified, the default is determined by the
         * recommended minimum number of nodes for that gateway.
         */
        minNodeCount?: pulumi.Input<string>;
    }

    export interface EnvironmentProperties {
        /**
         * List of all properties in the object.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.apigee.EnvironmentPropertiesProperty>[]>;
    }

    export interface EnvironmentPropertiesProperty {
        /**
         * The property key.
         */
        name?: pulumi.Input<string>;
        /**
         * The property value.
         */
        value?: pulumi.Input<string>;
    }

    export interface KeystoresAliasesKeyCertFileCertsInfo {
        /**
         * (Output)
         * List of all properties in the object.
         * Structure is documented below.
         */
        certInfos?: pulumi.Input<pulumi.Input<inputs.apigee.KeystoresAliasesKeyCertFileCertsInfoCertInfo>[]>;
    }

    export interface KeystoresAliasesKeyCertFileCertsInfoCertInfo {
        /**
         * (Output)
         * X.509 basic constraints extension.
         */
        basicConstraints?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 notAfter validity period in milliseconds since epoch.
         */
        expiryDate?: pulumi.Input<string>;
        /**
         * (Output)
         * Flag that specifies whether the certificate is valid.
         * Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
         */
        isValid?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 issuer.
         */
        issuer?: pulumi.Input<string>;
        /**
         * (Output)
         * Public key component of the X.509 subject public key info.
         */
        publicKey?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 serial number.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 signatureAlgorithm.
         */
        sigAlgName?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 subject.
         */
        subject?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 subject alternative names (SANs) extension.
         */
        subjectAlternativeNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * X.509 notBefore validity period in milliseconds since epoch.
         */
        validFrom?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 version.
         */
        version?: pulumi.Input<number>;
    }

    export interface KeystoresAliasesPkcs12CertsInfo {
        /**
         * (Output)
         * List of all properties in the object.
         * Structure is documented below.
         */
        certInfos?: pulumi.Input<pulumi.Input<inputs.apigee.KeystoresAliasesPkcs12CertsInfoCertInfo>[]>;
    }

    export interface KeystoresAliasesPkcs12CertsInfoCertInfo {
        /**
         * (Output)
         * X.509 basic constraints extension.
         */
        basicConstraints?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 notAfter validity period in milliseconds since epoch.
         */
        expiryDate?: pulumi.Input<string>;
        /**
         * (Output)
         * Flag that specifies whether the certificate is valid.
         * Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
         */
        isValid?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 issuer.
         */
        issuer?: pulumi.Input<string>;
        /**
         * (Output)
         * Public key component of the X.509 subject public key info.
         */
        publicKey?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 serial number.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 signatureAlgorithm.
         */
        sigAlgName?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 subject.
         */
        subject?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 subject alternative names (SANs) extension.
         */
        subjectAlternativeNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * X.509 notBefore validity period in milliseconds since epoch.
         */
        validFrom?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 version.
         */
        version?: pulumi.Input<number>;
    }

    export interface KeystoresAliasesSelfSignedCertCertsInfo {
        /**
         * (Output)
         * List of all properties in the object.
         * Structure is documented below.
         */
        certInfos?: pulumi.Input<pulumi.Input<inputs.apigee.KeystoresAliasesSelfSignedCertCertsInfoCertInfo>[]>;
    }

    export interface KeystoresAliasesSelfSignedCertCertsInfoCertInfo {
        /**
         * (Output)
         * X.509 basic constraints extension.
         */
        basicConstraints?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 notAfter validity period in milliseconds since epoch.
         */
        expiryDate?: pulumi.Input<string>;
        /**
         * (Output)
         * Flag that specifies whether the certificate is valid.
         * Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
         */
        isValid?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 issuer.
         */
        issuer?: pulumi.Input<string>;
        /**
         * (Output)
         * Public key component of the X.509 subject public key info.
         */
        publicKey?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 serial number.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 signatureAlgorithm.
         */
        sigAlgName?: pulumi.Input<string>;
        /**
         * Subject details.
         * Structure is documented below.
         */
        subject?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 subject alternative names (SANs) extension.
         */
        subjectAlternativeNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * X.509 notBefore validity period in milliseconds since epoch.
         */
        validFrom?: pulumi.Input<string>;
        /**
         * (Output)
         * X.509 version.
         */
        version?: pulumi.Input<number>;
    }

    export interface KeystoresAliasesSelfSignedCertSubject {
        /**
         * Common name of the organization. Maximum length is 64 characters.
         */
        commonName?: pulumi.Input<string>;
        /**
         * Two-letter country code. Example, IN for India, US for United States of America.
         */
        countryCode?: pulumi.Input<string>;
        /**
         * Email address. Max 255 characters.
         *
         * - - -
         */
        email?: pulumi.Input<string>;
        /**
         * City or town name. Maximum length is 128 characters.
         */
        locality?: pulumi.Input<string>;
        /**
         * Organization name. Maximum length is 64 characters.
         */
        org?: pulumi.Input<string>;
        /**
         * Organization team name. Maximum length is 64 characters.
         */
        orgUnit?: pulumi.Input<string>;
        /**
         * State or district name. Maximum length is 128 characters.
         */
        state?: pulumi.Input<string>;
    }

    export interface KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNames {
        /**
         * Subject Alternative Name
         */
        subjectAlternativeName?: pulumi.Input<string>;
    }

    export interface OrganizationProperties {
        /**
         * List of all properties in the object.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.apigee.OrganizationPropertiesProperty>[]>;
    }

    export interface OrganizationPropertiesProperty {
        /**
         * Name of the property.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the property.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityProfileV2ProfileAssessmentConfig {
        /**
         * The identifier for this object. Format specified above.
         */
        assessment: pulumi.Input<string>;
        /**
         * The weight of the assessment.
         * Possible values are: `MINOR`, `MODERATE`, `MAJOR`.
         *
         * - - -
         */
        weight: pulumi.Input<string>;
    }

    export interface SharedflowMetaData {
        /**
         * Time at which the API proxy was created, in milliseconds since epoch.
         */
        createdAt?: pulumi.Input<string>;
        /**
         * Time at which the API proxy was most recently modified, in milliseconds since epoch.
         */
        lastModifiedAt?: pulumi.Input<string>;
        /**
         * The type of entity described
         */
        subType?: pulumi.Input<string>;
    }

    export interface TargetServerSSlInfo {
        /**
         * The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
         */
        ciphers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Enables two-way TLS.
         */
        clientAuthEnabled?: pulumi.Input<boolean>;
        /**
         * The TLS Common Name of the certificate.
         * Structure is documented below.
         */
        commonName?: pulumi.Input<inputs.apigee.TargetServerSSlInfoCommonName>;
        /**
         * Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * If true, TLS is strictly enforced.
         */
        enforce?: pulumi.Input<boolean>;
        /**
         * If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
         */
        ignoreValidationErrors?: pulumi.Input<boolean>;
        /**
         * Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
         */
        keyAlias?: pulumi.Input<string>;
        /**
         * Required if clientAuthEnabled is true. The resource ID of the keystore.
         */
        keyStore?: pulumi.Input<string>;
        /**
         * The TLS versioins to be used.
         */
        protocols?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The resource ID of the truststore.
         */
        trustStore?: pulumi.Input<string>;
    }

    export interface TargetServerSSlInfoCommonName {
        /**
         * The TLS Common Name string of the certificate.
         */
        value?: pulumi.Input<string>;
        /**
         * Indicates whether the cert should be matched against as a wildcard cert.
         */
        wildcardMatch?: pulumi.Input<boolean>;
    }
}

export namespace apihub {
    export interface ApiHubInstanceConfig {
        /**
         * Optional. The Customer Managed Encryption Key (CMEK) used for data encryption.
         * The CMEK name should follow the format of
         * `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`,
         * where the location must match the instance location.
         * If the CMEK is not provided, a GMEK will be created for the instance.
         */
        cmekKeyName?: pulumi.Input<string>;
        /**
         * Optional. If true, the search will be disabled for the instance. The default value
         * is false.
         */
        disableSearch?: pulumi.Input<boolean>;
        /**
         * Optional. Encryption type for the region. If the encryption type is CMEK, the
         * cmekKeyName must be provided. If no encryption type is provided,
         * GMEK will be used.
         * Possible values:
         * ENCRYPTION_TYPE_UNSPECIFIED
         * GMEK
         * CMEK
         */
        encryptionType?: pulumi.Input<string>;
        /**
         * Optional. The name of the Vertex AI location where the data store is stored.
         *
         * - - -
         */
        vertexLocation?: pulumi.Input<string>;
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: pulumi.Input<boolean>;
    }

    export interface ApplicationIap {
        /**
         * (Optional) Whether the serving infrastructure will authenticate and authorize all incoming requests. 
         * (default is false)
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * OAuth2 client ID to use for the authentication flow.
         */
        oauth2ClientId: pulumi.Input<string>;
        /**
         * OAuth2 client secret to use for the authentication flow.
         * The SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field.
         */
        oauth2ClientSecret: pulumi.Input<string>;
        /**
         * Hex-encoded SHA-256 hash of the client secret.
         */
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRule {
        domain?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        /**
         * Domain name to match against. The wildcard "*" is supported if specified before a period: "*.".
         * Defaults to matching all domains: "*".
         */
        domain?: pulumi.Input<string>;
        /**
         * Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
         * The sum of the lengths of the domain and path may not exceed 100 characters.
         */
        path: pulumi.Input<string>;
        /**
         * Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path.
         * The sum of the lengths of the domain and path may not exceed 100 characters.
         *
         * - - -
         */
        service: pulumi.Input<string>;
    }

    export interface DomainMappingResourceRecord {
        /**
         * Relative name of the object affected by this record. Only applicable for CNAME records. Example: 'www'.
         */
        name?: pulumi.Input<string>;
        /**
         * Data for this record. Values vary by record type, as defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1).
         */
        rrdata?: pulumi.Input<string>;
        /**
         * Resource record type. Example: `AAAA`.
         * Possible values are: `A`, `AAAA`, `CNAME`.
         */
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingSslSettings {
        /**
         * ID of the AuthorizedCertificate resource configuring SSL for the application. Clearing this field will
         * remove SSL support.
         * By default, a managed certificate is automatically created for every domain mapping. To omit SSL support
         * or to configure SSL manually, specify `SslManagementType.MANUAL` on a `CREATE` or `UPDATE` request. You must be
         * authorized to administer the `AuthorizedCertificate` resource to manually map it to a DomainMapping resource.
         * Example: 12345.
         */
        certificateId?: pulumi.Input<string>;
        /**
         * (Output)
         * ID of the managed `AuthorizedCertificate` resource currently being provisioned, if applicable. Until the new
         * managed certificate has been successfully provisioned, the previous SSL state will be preserved. Once the
         * provisioning process completes, the `certificateId` field will reflect the new managed certificate and this
         * field will be left empty. To remove SSL support while there is still a pending managed certificate, clear the
         * `certificateId` field with an update request.
         */
        pendingManagedCertificateId?: pulumi.Input<string>;
        /**
         * SSL management type for this domain. If `AUTOMATIC`, a managed certificate is automatically provisioned.
         * If `MANUAL`, `certificateId` must be manually specified in order to configure SSL for this domain.
         * Possible values are: `AUTOMATIC`, `MANUAL`.
         */
        sslManagementType: pulumi.Input<string>;
    }

    export interface EngineSplitTrafficSplit {
        /**
         * Mapping from version IDs within the service to fractional (0.000, 1] allocations of traffic for that version. Each version can be specified only once, but some versions in the service may not have any traffic allocation. Services that have traffic allocated cannot be deleted until either the service is deleted or their traffic allocation is removed. Allocations must sum to 1. Up to two decimal place precision is supported for IP-based splits and up to three decimal places is supported for cookie-based splits.
         *
         * - - -
         */
        allocations: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Mechanism used to determine which version a request is sent to. The traffic selection algorithm will be stable for either type until allocations are changed.
         * Possible values are: `UNSPECIFIED`, `COOKIE`, `IP`, `RANDOM`.
         */
        shardBy?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionApiConfig {
        /**
         * Action to take when users access resources that require authentication.
         * Default value is `AUTH_FAIL_ACTION_REDIRECT`.
         * Possible values are: `AUTH_FAIL_ACTION_REDIRECT`, `AUTH_FAIL_ACTION_UNAUTHORIZED`.
         */
        authFailAction?: pulumi.Input<string>;
        /**
         * Level of login required to access this resource.
         * Default value is `LOGIN_OPTIONAL`.
         * Possible values are: `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, `LOGIN_REQUIRED`.
         */
        login?: pulumi.Input<string>;
        /**
         * Path to the script from the application root directory.
         */
        script: pulumi.Input<string>;
        /**
         * Security (HTTPS) enforcement for this URL.
         * Possible values are: `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, `SECURE_ALWAYS`.
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * URL to serve the endpoint at.
         */
        url?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionAutomaticScaling {
        /**
         * The time period that the Autoscaler should wait before it starts collecting information from a new instance.
         * This prevents the autoscaler from collecting information when the instance is initializing,
         * during which the collected usage would not be reliable. Default: 120s
         */
        coolDownPeriod?: pulumi.Input<string>;
        /**
         * Target scaling by CPU usage.
         * Structure is documented below.
         */
        cpuUtilization: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingCpuUtilization>;
        /**
         * Target scaling by disk usage.
         * Structure is documented below.
         */
        diskUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingDiskUtilization>;
        /**
         * Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
         * Defaults to a runtime-specific value.
         */
        maxConcurrentRequests?: pulumi.Input<number>;
        /**
         * Maximum number of idle instances that should be maintained for this version.
         */
        maxIdleInstances?: pulumi.Input<number>;
        /**
         * Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
         */
        maxPendingLatency?: pulumi.Input<string>;
        /**
         * Maximum number of instances that should be started to handle requests for this version. Default: 20
         */
        maxTotalInstances?: pulumi.Input<number>;
        /**
         * Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
         */
        minIdleInstances?: pulumi.Input<number>;
        /**
         * Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
         */
        minPendingLatency?: pulumi.Input<string>;
        /**
         * Minimum number of running instances that should be maintained for this version. Default: 2
         */
        minTotalInstances?: pulumi.Input<number>;
        /**
         * Target scaling by network usage.
         * Structure is documented below.
         */
        networkUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingNetworkUtilization>;
        /**
         * Target scaling by request utilization.
         * Structure is documented below.
         */
        requestUtilization?: pulumi.Input<inputs.appengine.FlexibleAppVersionAutomaticScalingRequestUtilization>;
    }

    export interface FlexibleAppVersionAutomaticScalingCpuUtilization {
        /**
         * Period of time over which CPU utilization is calculated.
         */
        aggregationWindowLength?: pulumi.Input<string>;
        /**
         * Target CPU utilization ratio to maintain when scaling. Must be between 0 and 1.
         */
        targetUtilization: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingDiskUtilization {
        /**
         * Target bytes read per second.
         */
        targetReadBytesPerSecond?: pulumi.Input<number>;
        /**
         * Target ops read per seconds.
         */
        targetReadOpsPerSecond?: pulumi.Input<number>;
        /**
         * Target bytes written per second.
         */
        targetWriteBytesPerSecond?: pulumi.Input<number>;
        /**
         * Target ops written per second.
         */
        targetWriteOpsPerSecond?: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingNetworkUtilization {
        /**
         * Target bytes received per second.
         */
        targetReceivedBytesPerSecond?: pulumi.Input<number>;
        /**
         * Target packets received per second.
         */
        targetReceivedPacketsPerSecond?: pulumi.Input<number>;
        /**
         * Target bytes sent per second.
         */
        targetSentBytesPerSecond?: pulumi.Input<number>;
        /**
         * Target packets sent per second.
         */
        targetSentPacketsPerSecond?: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionAutomaticScalingRequestUtilization {
        /**
         * Target number of concurrent requests.
         */
        targetConcurrentRequests?: pulumi.Input<number>;
        /**
         * Target requests per second.
         */
        targetRequestCountPerSecond?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeployment {
        /**
         * Options for the build operations performed as a part of the version deployment. Only applicable when creating a version using source code directly.
         * Structure is documented below.
         */
        cloudBuildOptions?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentCloudBuildOptions>;
        /**
         * The Docker image for the container that runs the version.
         * Structure is documented below.
         */
        container?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentContainer>;
        /**
         * Manifest of the files stored in Google Cloud Storage that are included as part of this version.
         * All files must be readable using the credentials supplied with this call.
         * Structure is documented below.
         */
        files?: pulumi.Input<pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentFile>[]>;
        /**
         * Zip File
         * Structure is documented below.
         */
        zip?: pulumi.Input<inputs.appengine.FlexibleAppVersionDeploymentZip>;
    }

    export interface FlexibleAppVersionDeploymentCloudBuildOptions {
        /**
         * Path to the yaml file used in deployment, used to determine runtime configuration details.
         */
        appYamlPath: pulumi.Input<string>;
        /**
         * The Cloud Build timeout used as part of any dependent builds performed by version creation. Defaults to 10 minutes.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        cloudBuildTimeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentContainer {
        /**
         * URI to the hosted container image in Google Container Registry. The URI must be fully qualified and include a tag or digest.
         * Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
         */
        image: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        /**
         * SHA1 checksum of the file
         */
        sha1Sum?: pulumi.Input<string>;
        /**
         * Source URL
         */
        sourceUrl: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionDeploymentZip {
        /**
         * files count
         */
        filesCount?: pulumi.Input<number>;
        /**
         * Source URL
         */
        sourceUrl: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionEndpointsApiService {
        /**
         * Endpoints service configuration ID as specified by the Service Management API. For example "2016-09-19r1".
         * By default, the rollout strategy for Endpoints is "FIXED". This means that Endpoints starts up with a particular configuration ID.
         * When a new configuration is rolled out, Endpoints must be given the new configuration ID. The configId field is used to give the configuration ID
         * and is required in this case.
         * Endpoints also has a rollout strategy called "MANAGED". When using this, Endpoints fetches the latest configuration and does not need
         * the configuration ID. In this case, configId must be omitted.
         */
        configId?: pulumi.Input<string>;
        /**
         * Enable or disable trace sampling. By default, this is set to false for enabled.
         */
        disableTraceSampling?: pulumi.Input<boolean>;
        /**
         * Endpoints service name which is the name of the "service" resource in the Service Management API.
         * For example "myapi.endpoints.myproject.cloud.goog"
         */
        name: pulumi.Input<string>;
        /**
         * Endpoints rollout strategy. If FIXED, configId must be specified. If MANAGED, configId must be omitted.
         * Default value is `FIXED`.
         * Possible values are: `FIXED`, `MANAGED`.
         */
        rolloutStrategy?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionEntrypoint {
        /**
         * The format should be a shell command that can be fed to bash -c.
         */
        shell: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionFlexibleRuntimeSettings {
        /**
         * Operating System of the application runtime.
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The runtime version of an App Engine flexible application.
         */
        runtimeVersion?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionHandler {
        /**
         * Actions to take when the user is not logged in.
         * Possible values are: `AUTH_FAIL_ACTION_REDIRECT`, `AUTH_FAIL_ACTION_UNAUTHORIZED`.
         */
        authFailAction?: pulumi.Input<string>;
        /**
         * Methods to restrict access to a URL based on login status.
         * Possible values are: `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, `LOGIN_REQUIRED`.
         */
        login?: pulumi.Input<string>;
        /**
         * 30x code to use when performing redirects for the secure field.
         * Possible values are: `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, `REDIRECT_HTTP_RESPONSE_CODE_307`.
         */
        redirectHttpResponseCode?: pulumi.Input<string>;
        /**
         * Executes a script to handle the requests that match this URL pattern.
         * Only the auto value is supported for Node.js in the App Engine standard environment, for example "script:" "auto".
         * Structure is documented below.
         */
        script?: pulumi.Input<inputs.appengine.FlexibleAppVersionHandlerScript>;
        /**
         * Security (HTTPS) enforcement for this URL.
         * Possible values are: `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, `SECURE_ALWAYS`.
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files.
         * Static file handlers describe which files in the application directory are static files, and which URLs serve them.
         * Structure is documented below.
         */
        staticFiles?: pulumi.Input<inputs.appengine.FlexibleAppVersionHandlerStaticFiles>;
        /**
         * URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
         * All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
         */
        urlRegex?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionHandlerScript {
        /**
         * Path to the script from the application root directory.
         */
        scriptPath: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionHandlerStaticFiles {
        /**
         * Whether files should also be uploaded as code data. By default, files declared in static file handlers are
         * uploaded as static data and are only served to end users; they cannot be read by the application. If enabled,
         * uploads are charged against both your code and static data storage resource quotas.
         */
        applicationReadable?: pulumi.Input<boolean>;
        /**
         * Time a static file served by this handler should be cached by web proxies and browsers.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
         * Default is '0s'
         */
        expiration?: pulumi.Input<string>;
        /**
         * HTTP headers to use for all responses from these URLs.
         * An object containing a list of "key:value" value pairs.".
         */
        httpHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * MIME type used to serve all files served by this handler.
         * Defaults to file-specific MIME types, which are derived from each file's filename extension.
         */
        mimeType?: pulumi.Input<string>;
        /**
         * Path to the static files matched by the URL pattern, from the application root directory.
         * The path can refer to text matched in groupings in the URL pattern.
         */
        path?: pulumi.Input<string>;
        /**
         * Whether this handler should match the request if the file referenced by the handler does not exist.
         */
        requireMatchingFile?: pulumi.Input<boolean>;
        /**
         * Regular expression that matches the file paths for all files that should be referenced by this handler.
         */
        uploadPathRegex?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionLivenessCheck {
        /**
         * Interval between health checks.
         */
        checkInterval?: pulumi.Input<string>;
        /**
         * Number of consecutive failed checks required before considering the VM unhealthy. Default: 4.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
         */
        host?: pulumi.Input<string>;
        /**
         * The initial delay before starting to execute the checks. Default: "300s"
         *
         * - - -
         */
        initialDelay?: pulumi.Input<string>;
        /**
         * The request path.
         */
        path: pulumi.Input<string>;
        /**
         * Number of consecutive successful checks required before considering the VM healthy. Default: 2.
         */
        successThreshold?: pulumi.Input<number>;
        /**
         * Time before the check is considered failed. Default: "4s"
         */
        timeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionManualScaling {
        /**
         * Number of instances to assign to the service at the start.
         * **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
         * Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manualScaling"[0].instances]` to prevent drift detection.
         */
        instances: pulumi.Input<number>;
    }

    export interface FlexibleAppVersionNetwork {
        /**
         * List of ports, or port pairs, to forward from the virtual machine to the application container.
         */
        forwardedPorts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Prevent instances from receiving an ephemeral external IP address.
         * Possible values are: `EXTERNAL`, `INTERNAL`.
         */
        instanceIpMode?: pulumi.Input<string>;
        /**
         * Tag to apply to the instance during creation.
         */
        instanceTag?: pulumi.Input<string>;
        /**
         * Google Compute Engine network where the virtual machines are created. Specify the short name, not the resource path.
         */
        name: pulumi.Input<string>;
        /**
         * Enable session affinity.
         */
        sessionAffinity?: pulumi.Input<boolean>;
        /**
         * Google Cloud Platform sub-network where the virtual machines are created. Specify the short name, not the resource path.
         * If the network that the instance is being created in is a Legacy network, then the IP address is allocated from the IPv4Range.
         * If the network that the instance is being created in is an auto Subnet Mode Network, then only network name should be specified (not the subnetworkName) and the IP address is created from the IPCidrRange of the subnetwork that exists in that zone for that network.
         * If the network that the instance is being created in is a custom Subnet Mode Network, then the subnetworkName must be specified and the IP address is created from the IPCidrRange of the subnetwork.
         * If specified, the subnetwork must exist in the same region as the App Engine flexible environment application.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionReadinessCheck {
        /**
         * A maximum time limit on application initialization, measured from moment the application successfully
         * replies to a healthcheck until it is ready to serve traffic. Default: "300s"
         */
        appStartTimeout?: pulumi.Input<string>;
        /**
         * Interval between health checks.  Default: "5s".
         */
        checkInterval?: pulumi.Input<string>;
        /**
         * Number of consecutive failed checks required before removing traffic. Default: 2.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * Host header to send when performing a HTTP Readiness check. Example: "myapp.appspot.com"
         */
        host?: pulumi.Input<string>;
        /**
         * The request path.
         */
        path: pulumi.Input<string>;
        /**
         * Number of consecutive successful checks required before receiving traffic. Default: 2.
         */
        successThreshold?: pulumi.Input<number>;
        /**
         * Time before the check is considered failed. Default: "4s"
         */
        timeout?: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionResources {
        /**
         * Number of CPU cores needed.
         */
        cpu?: pulumi.Input<number>;
        /**
         * Disk size (GB) needed.
         */
        diskGb?: pulumi.Input<number>;
        /**
         * Memory (GB) needed.
         */
        memoryGb?: pulumi.Input<number>;
        /**
         * List of ports, or port pairs, to forward from the virtual machine to the application container.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.appengine.FlexibleAppVersionResourcesVolume>[]>;
    }

    export interface FlexibleAppVersionResourcesVolume {
        /**
         * Unique name for the volume.
         */
        name: pulumi.Input<string>;
        /**
         * Volume size in gigabytes.
         */
        sizeGb: pulumi.Input<number>;
        /**
         * Underlying volume type, e.g. 'tmpfs'.
         */
        volumeType: pulumi.Input<string>;
    }

    export interface FlexibleAppVersionVpcAccessConnector {
        /**
         * Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceNetworkSettingsNetworkSettings {
        /**
         * The ingress settings for version or service.
         * Default value is `INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED`.
         * Possible values are: `INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED`, `INGRESS_TRAFFIC_ALLOWED_ALL`, `INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY`, `INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB`.
         *
         * - - -
         */
        ingressTrafficAllowed?: pulumi.Input<string>;
    }

    export interface StandardAppVersionAutomaticScaling {
        /**
         * Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance.
         * Defaults to a runtime-specific value.
         */
        maxConcurrentRequests?: pulumi.Input<number>;
        /**
         * Maximum number of idle instances that should be maintained for this version.
         */
        maxIdleInstances?: pulumi.Input<number>;
        /**
         * Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxPendingLatency?: pulumi.Input<string>;
        /**
         * Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
         */
        minIdleInstances?: pulumi.Input<number>;
        /**
         * Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minPendingLatency?: pulumi.Input<string>;
        /**
         * Scheduler settings for standard environment.
         * Structure is documented below.
         */
        standardSchedulerSettings?: pulumi.Input<inputs.appengine.StandardAppVersionAutomaticScalingStandardSchedulerSettings>;
    }

    export interface StandardAppVersionAutomaticScalingStandardSchedulerSettings {
        /**
         * Maximum number of instances to run for this version. Set to zero to disable maxInstances configuration.
         * **Note:** Starting from March 2025, App Engine sets the maxInstances default for standard environment deployments to 20. This change doesn't impact existing apps. To override the default, specify a new value between 0 and 2147483647, and deploy a new version or redeploy over an existing version. To disable the maxInstances default configuration setting, specify the maximum permitted value 2147483647.
         */
        maxInstances?: pulumi.Input<number>;
        /**
         * Minimum number of instances to run for this version. Set to zero to disable minInstances configuration.
         */
        minInstances?: pulumi.Input<number>;
        /**
         * Target CPU utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
         */
        targetCpuUtilization?: pulumi.Input<number>;
        /**
         * Target throughput utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
         */
        targetThroughputUtilization?: pulumi.Input<number>;
    }

    export interface StandardAppVersionBasicScaling {
        /**
         * Duration of time after the last request that an instance must wait before the instance is shut down.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
         */
        idleTimeout?: pulumi.Input<string>;
        /**
         * Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
         */
        maxInstances: pulumi.Input<number>;
    }

    export interface StandardAppVersionDeployment {
        /**
         * Manifest of the files stored in Google Cloud Storage that are included as part of this version.
         * All files must be readable using the credentials supplied with this call.
         * Structure is documented below.
         */
        files?: pulumi.Input<pulumi.Input<inputs.appengine.StandardAppVersionDeploymentFile>[]>;
        /**
         * Zip File
         * Structure is documented below.
         */
        zip?: pulumi.Input<inputs.appengine.StandardAppVersionDeploymentZip>;
    }

    export interface StandardAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        /**
         * SHA1 checksum of the file
         */
        sha1Sum?: pulumi.Input<string>;
        /**
         * Source URL
         */
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeploymentZip {
        /**
         * files count
         */
        filesCount?: pulumi.Input<number>;
        /**
         * Source URL
         */
        sourceUrl: pulumi.Input<string>;
    }

    export interface StandardAppVersionEntrypoint {
        /**
         * The format should be a shell command that can be fed to bash -c.
         *
         * - - -
         */
        shell: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandler {
        /**
         * Actions to take when the user is not logged in.
         * Possible values are: `AUTH_FAIL_ACTION_REDIRECT`, `AUTH_FAIL_ACTION_UNAUTHORIZED`.
         */
        authFailAction?: pulumi.Input<string>;
        /**
         * Methods to restrict access to a URL based on login status.
         * Possible values are: `LOGIN_OPTIONAL`, `LOGIN_ADMIN`, `LOGIN_REQUIRED`.
         */
        login?: pulumi.Input<string>;
        /**
         * 30x code to use when performing redirects for the secure field.
         * Possible values are: `REDIRECT_HTTP_RESPONSE_CODE_301`, `REDIRECT_HTTP_RESPONSE_CODE_302`, `REDIRECT_HTTP_RESPONSE_CODE_303`, `REDIRECT_HTTP_RESPONSE_CODE_307`.
         */
        redirectHttpResponseCode?: pulumi.Input<string>;
        /**
         * Executes a script to handle the requests that match this URL pattern.
         * Only the auto value is supported for Node.js in the App Engine standard environment, for example "script:" "auto".
         * Structure is documented below.
         */
        script?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerScript>;
        /**
         * Security (HTTPS) enforcement for this URL.
         * Possible values are: `SECURE_DEFAULT`, `SECURE_NEVER`, `SECURE_OPTIONAL`, `SECURE_ALWAYS`.
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files. Static file handlers describe which files in the application directory are static files, and which URLs serve them.
         * Structure is documented below.
         */
        staticFiles?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerStaticFiles>;
        /**
         * URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings.
         * All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
         */
        urlRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerScript {
        /**
         * Path to the script from the application root directory.
         */
        scriptPath: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        /**
         * Whether files should also be uploaded as code data. By default, files declared in static file handlers are uploaded as
         * static data and are only served to end users; they cannot be read by the application. If enabled, uploads are charged
         * against both your code and static data storage resource quotas.
         */
        applicationReadable?: pulumi.Input<boolean>;
        /**
         * Time a static file served by this handler should be cached by web proxies and browsers.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
         */
        expiration?: pulumi.Input<string>;
        /**
         * HTTP headers to use for all responses from these URLs.
         * An object containing a list of "key:value" value pairs.".
         */
        httpHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * MIME type used to serve all files served by this handler.
         * Defaults to file-specific MIME types, which are derived from each file's filename extension.
         */
        mimeType?: pulumi.Input<string>;
        /**
         * Path to the static files matched by the URL pattern, from the application root directory. The path can refer to text matched in groupings in the URL pattern.
         */
        path?: pulumi.Input<string>;
        /**
         * Whether this handler should match the request if the file referenced by the handler does not exist.
         */
        requireMatchingFile?: pulumi.Input<boolean>;
        /**
         * Regular expression that matches the file paths for all files that should be referenced by this handler.
         */
        uploadPathRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionLibrary {
        /**
         * Name of the library. Example "django".
         */
        name?: pulumi.Input<string>;
        /**
         * Version of the library to select, or "latest".
         */
        version?: pulumi.Input<string>;
    }

    export interface StandardAppVersionManualScaling {
        /**
         * Number of instances to assign to the service at the start.
         * **Note:** When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2
         * Modules API set_num_instances() you must use `lifecycle.ignore_changes = ["manualScaling"[0].instances]` to prevent drift detection.
         */
        instances: pulumi.Input<number>;
    }

    export interface StandardAppVersionVpcAccessConnector {
        /**
         * The egress setting for the connector, controlling what traffic is diverted through it.
         */
        egressSetting?: pulumi.Input<string>;
        /**
         * Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
         */
        name: pulumi.Input<string>;
    }
}

export namespace apphub {
    export interface ApplicationAttributes {
        /**
         * Optional. Business team that ensures user needs are met and value is delivered
         * Structure is documented below.
         */
        businessOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ApplicationAttributesBusinessOwner>[]>;
        /**
         * Criticality of the Application, Service, or Workload
         * Structure is documented below.
         */
        criticality?: pulumi.Input<inputs.apphub.ApplicationAttributesCriticality>;
        /**
         * Optional. Developer team that owns development and coding.
         * Structure is documented below.
         */
        developerOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ApplicationAttributesDeveloperOwner>[]>;
        /**
         * Environment of the Application, Service, or Workload
         * Structure is documented below.
         */
        environment?: pulumi.Input<inputs.apphub.ApplicationAttributesEnvironment>;
        /**
         * Optional. Operator team that ensures runtime and operations.
         * Structure is documented below.
         */
        operatorOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ApplicationAttributesOperatorOwner>[]>;
    }

    export interface ApplicationAttributesBusinessOwner {
        /**
         * Optional. Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ApplicationAttributesCriticality {
        /**
         * Criticality type.
         * Possible values are: `MISSION_CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        type: pulumi.Input<string>;
    }

    export interface ApplicationAttributesDeveloperOwner {
        /**
         * Optional. Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ApplicationAttributesEnvironment {
        /**
         * Environment type.
         * Possible values are: `PRODUCTION`, `STAGING`, `TEST`, `DEVELOPMENT`.
         */
        type: pulumi.Input<string>;
    }

    export interface ApplicationAttributesOperatorOwner {
        /**
         * Optional. Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ApplicationScope {
        /**
         * Required. Scope Type.
         * Possible values:
         * REGIONAL
         * GLOBAL
         * Possible values are: `REGIONAL`, `GLOBAL`.
         *
         * - - -
         */
        type: pulumi.Input<string>;
    }

    export interface ServiceAttributes {
        /**
         * Business team that ensures user needs are met and value is delivered
         * Structure is documented below.
         */
        businessOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ServiceAttributesBusinessOwner>[]>;
        /**
         * Criticality of the Application, Service, or Workload
         * Structure is documented below.
         */
        criticality?: pulumi.Input<inputs.apphub.ServiceAttributesCriticality>;
        /**
         * Developer team that owns development and coding.
         * Structure is documented below.
         */
        developerOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ServiceAttributesDeveloperOwner>[]>;
        /**
         * Environment of the Application, Service, or Workload
         * Structure is documented below.
         */
        environment?: pulumi.Input<inputs.apphub.ServiceAttributesEnvironment>;
        /**
         * Operator team that ensures runtime and operations.
         * Structure is documented below.
         */
        operatorOwners?: pulumi.Input<pulumi.Input<inputs.apphub.ServiceAttributesOperatorOwner>[]>;
    }

    export interface ServiceAttributesBusinessOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ServiceAttributesCriticality {
        /**
         * Criticality type.
         * Possible values are: `MISSION_CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        type: pulumi.Input<string>;
    }

    export interface ServiceAttributesDeveloperOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ServiceAttributesEnvironment {
        /**
         * Environment type.
         * Possible values are: `PRODUCTION`, `STAGING`, `TEST`, `DEVELOPMENT`.
         */
        type: pulumi.Input<string>;
    }

    export interface ServiceAttributesOperatorOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Required. Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface ServiceServiceProperty {
        /**
         * (Output)
         * Output only. The service project identifier that the underlying cloud resource resides in.
         */
        gcpProject?: pulumi.Input<string>;
        /**
         * Part of `parent`.  Full resource name of a parent Application. Example: projects/{HOST_PROJECT_ID}/locations/{LOCATION}/applications/{APPLICATION_ID}
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The location that the underlying resource resides in if it is zonal, for example, us-west1-a).
         */
        zone?: pulumi.Input<string>;
    }

    export interface ServiceServiceReference {
        /**
         * (Output)
         * Output only. The underlying resource URI (For example, URI of Forwarding Rule, URL Map,
         * and Backend Service).
         */
        uri?: pulumi.Input<string>;
    }

    export interface WorkloadAttributes {
        /**
         * Business team that ensures user needs are met and value is delivered
         * Structure is documented below.
         */
        businessOwners?: pulumi.Input<pulumi.Input<inputs.apphub.WorkloadAttributesBusinessOwner>[]>;
        /**
         * Criticality of the Application, Service, or Workload
         * Structure is documented below.
         */
        criticality?: pulumi.Input<inputs.apphub.WorkloadAttributesCriticality>;
        /**
         * Developer team that owns development and coding.
         * Structure is documented below.
         */
        developerOwners?: pulumi.Input<pulumi.Input<inputs.apphub.WorkloadAttributesDeveloperOwner>[]>;
        /**
         * Environment of the Application, Service, or Workload
         * Structure is documented below.
         */
        environment?: pulumi.Input<inputs.apphub.WorkloadAttributesEnvironment>;
        /**
         * Operator team that ensures runtime and operations.
         * Structure is documented below.
         */
        operatorOwners?: pulumi.Input<pulumi.Input<inputs.apphub.WorkloadAttributesOperatorOwner>[]>;
    }

    export interface WorkloadAttributesBusinessOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface WorkloadAttributesCriticality {
        /**
         * Criticality type.
         * Possible values are: `MISSION_CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        type: pulumi.Input<string>;
    }

    export interface WorkloadAttributesDeveloperOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface WorkloadAttributesEnvironment {
        /**
         * Environment type.
         * Possible values are: `PRODUCTION`, `STAGING`, `TEST`, `DEVELOPMENT`.
         */
        type: pulumi.Input<string>;
    }

    export interface WorkloadAttributesOperatorOwner {
        /**
         * Contact's name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Email address of the contacts.
         */
        email: pulumi.Input<string>;
    }

    export interface WorkloadWorkloadProperty {
        /**
         * (Output)
         * Output only. The service project identifier that the underlying cloud resource resides in. Empty for non cloud resources.
         */
        gcpProject?: pulumi.Input<string>;
        /**
         * Part of `parent`.  Full resource name of a parent Application. Example: projects/{HOST_PROJECT_ID}/locations/{LOCATION}/applications/{APPLICATION_ID}
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The location that the underlying compute resource resides in if it is zonal (e.g us-west1-a).
         */
        zone?: pulumi.Input<string>;
    }

    export interface WorkloadWorkloadReference {
        /**
         * (Output)
         * Output only. The underlying compute resource uri.
         */
        uri?: pulumi.Input<string>;
    }
}

export namespace applicationintegration {
    export interface AuthConfigClientCertificate {
        /**
         * The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.
         */
        encryptedPrivateKey: pulumi.Input<string>;
        /**
         * 'passphrase' should be left unset if private key is not encrypted.
         * Note that 'passphrase' is not the password for web server, but an extra layer of security to protected private key.
         */
        passphrase?: pulumi.Input<string>;
        /**
         * The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.
         */
        sslCertificate: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredential {
        /**
         * Auth token credential.
         * Structure is documented below.
         */
        authToken?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialAuthToken>;
        /**
         * Credential type associated with auth configs.
         */
        credentialType: pulumi.Input<string>;
        /**
         * JWT credential.
         * Structure is documented below.
         */
        jwt?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialJwt>;
        /**
         * OAuth2 authorization code credential.
         * Structure is documented below.
         */
        oauth2AuthorizationCode?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2AuthorizationCode>;
        /**
         * OAuth2 client credentials.
         * Structure is documented below.
         */
        oauth2ClientCredentials?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentials>;
        /**
         * Google OIDC ID Token.
         * Structure is documented below.
         */
        oidcToken?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOidcToken>;
        /**
         * Service account credential.
         * Structure is documented below.
         */
        serviceAccountCredentials?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialServiceAccountCredentials>;
        /**
         * Username and password credential.
         * Structure is documented below.
         */
        usernameAndPassword?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialUsernameAndPassword>;
    }

    export interface AuthConfigDecryptedCredentialAuthToken {
        /**
         * The token for the auth type.
         */
        token?: pulumi.Input<string>;
        /**
         * Authentication type, e.g. "Basic", "Bearer", etc.
         */
        type?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialJwt {
        /**
         * (Output)
         * The token calculated by the header, payload and signature.
         */
        jwt?: pulumi.Input<string>;
        /**
         * Identifies which algorithm is used to generate the signature.
         */
        jwtHeader?: pulumi.Input<string>;
        /**
         * Contains a set of claims. The JWT specification defines seven Registered Claim Names which are the standard fields commonly included in tokens. Custom claims are usually also included, depending on the purpose of the token.
         */
        jwtPayload?: pulumi.Input<string>;
        /**
         * User's pre-shared secret to sign the token.
         */
        secret?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialOauth2AuthorizationCode {
        /**
         * The auth url endpoint to send the auth code request to.
         */
        authEndpoint?: pulumi.Input<string>;
        /**
         * The client's id.
         */
        clientId?: pulumi.Input<string>;
        /**
         * The client's secret.
         */
        clientSecret?: pulumi.Input<string>;
        /**
         * A space-delimited list of requested scope permissions.
         */
        scope?: pulumi.Input<string>;
        /**
         * The token url endpoint to send the token request to.
         */
        tokenEndpoint?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentials {
        /**
         * The client's ID.
         */
        clientId?: pulumi.Input<string>;
        /**
         * The client's secret.
         */
        clientSecret?: pulumi.Input<string>;
        /**
         * Represent how to pass parameters to fetch access token Possible values: ["REQUEST_TYPE_UNSPECIFIED", "REQUEST_BODY", "QUERY_PARAMETERS", "ENCODED_HEADER"]
         */
        requestType?: pulumi.Input<string>;
        /**
         * A space-delimited list of requested scope permissions.
         */
        scope?: pulumi.Input<string>;
        /**
         * The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token.
         */
        tokenEndpoint?: pulumi.Input<string>;
        /**
         * Token parameters for the auth request.
         */
        tokenParams?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams {
        /**
         * A list of parameter map entries.
         * Structure is documented below.
         */
        entries?: pulumi.Input<pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntry>[]>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntry {
        /**
         * Key of the map entry.
         * Structure is documented below.
         */
        key?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryKey>;
        /**
         * Value of the map entry.
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryValue>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryKey {
        /**
         * Passing a literal value
         * Structure is documented below.
         */
        literalValue?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryKeyLiteralValue>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryKeyLiteralValue {
        /**
         * String.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryValue {
        /**
         * Passing a literal value
         * Structure is documented below.
         */
        literalValue?: pulumi.Input<inputs.applicationintegration.AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryValueLiteralValue>;
    }

    export interface AuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntryValueLiteralValue {
        /**
         * String.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialOidcToken {
        /**
         * Audience to be used when generating OIDC token. The audience claim identifies the recipients that the JWT is intended for.
         */
        audience?: pulumi.Input<string>;
        /**
         * The service account email to be used as the identity for the token.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * (Output)
         * ID token obtained for the service account.
         */
        token?: pulumi.Input<string>;
        /**
         * (Output)
         * The approximate time until the token retrieved is valid.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        tokenExpireTime?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialServiceAccountCredentials {
        /**
         * A space-delimited list of requested scope permissions.
         */
        scope?: pulumi.Input<string>;
        /**
         * Name of the service account that has the permission to make the request.
         */
        serviceAccount?: pulumi.Input<string>;
    }

    export interface AuthConfigDecryptedCredentialUsernameAndPassword {
        /**
         * Password to be used.
         *
         * <a name="nestedDecryptedCredentialOauth2AuthorizationCode"></a>The `oauth2AuthorizationCode` block supports:
         */
        password?: pulumi.Input<string>;
        /**
         * Username to be used.
         */
        username?: pulumi.Input<string>;
    }

    export interface ClientCloudKmsConfig {
        /**
         * A Cloud KMS key is a named object containing one or more key versions, along
         * with metadata for the key. A key exists on exactly one key ring tied to a
         * specific location.
         */
        key: pulumi.Input<string>;
        /**
         * Each version of a key contains key material used for encryption or signing.
         * A key's version is represented by an integer, starting at 1. To decrypt data
         * or verify a signature, you must use the same key version that was used to
         * encrypt or sign the data.
         */
        keyVersion?: pulumi.Input<string>;
        /**
         * Location name of the key ring, e.g. "us-west1".
         */
        kmsLocation: pulumi.Input<string>;
        /**
         * The Google Cloud project id of the project where the kms key stored. If empty,
         * the kms key is stored at the same project as customer's project and ecrypted
         * with CMEK, otherwise, the kms key is stored in the tenant project and
         * encrypted with GMEK.
         */
        kmsProjectId?: pulumi.Input<string>;
        /**
         * A key ring organizes keys in a specific Google Cloud location and allows you to
         * manage access control on groups of keys. A key ring's name does not need to be
         * unique across a Google Cloud project, but must be unique within a given location.
         */
        kmsRing: pulumi.Input<string>;
    }
}

export namespace artifactregistry {
    export interface RepositoryCleanupPolicy {
        /**
         * Policy action.
         * Possible values are: `DELETE`, `KEEP`.
         */
        action?: pulumi.Input<string>;
        /**
         * Policy condition for matching versions.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.artifactregistry.RepositoryCleanupPolicyCondition>;
        /**
         * The identifier for this object. Format specified above.
         */
        id: pulumi.Input<string>;
        /**
         * Policy condition for retaining a minimum number of versions. May only be
         * specified with a Keep action.
         * Structure is documented below.
         */
        mostRecentVersions?: pulumi.Input<inputs.artifactregistry.RepositoryCleanupPolicyMostRecentVersions>;
    }

    export interface RepositoryCleanupPolicyCondition {
        /**
         * Match versions newer than a duration.
         */
        newerThan?: pulumi.Input<string>;
        /**
         * Match versions older than a duration.
         */
        olderThan?: pulumi.Input<string>;
        /**
         * Match versions by package prefix. Applied on any prefix match.
         */
        packageNamePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Match versions by tag prefix. Applied on any prefix match.
         */
        tagPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Match versions by tag status.
         * Default value is `ANY`.
         * Possible values are: `TAGGED`, `UNTAGGED`, `ANY`.
         */
        tagState?: pulumi.Input<string>;
        /**
         * Match versions by version name prefix. Applied on any prefix match.
         */
        versionNamePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RepositoryCleanupPolicyMostRecentVersions {
        /**
         * Minimum number of versions to keep.
         */
        keepCount?: pulumi.Input<number>;
        /**
         * Match versions by package prefix. Applied on any prefix match.
         */
        packageNamePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RepositoryDockerConfig {
        /**
         * The repository which enabled this flag prevents all tags from being modified, moved or deleted. This does not prevent tags from being created.
         */
        immutableTags?: pulumi.Input<boolean>;
    }

    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryMavenConfig {
        /**
         * The repository with this flag will allow publishing the same
         * snapshot versions.
         */
        allowSnapshotOverwrites?: pulumi.Input<boolean>;
        /**
         * Version policy defines the versions that the registry will accept.
         * Default value is `VERSION_POLICY_UNSPECIFIED`.
         * Possible values are: `VERSION_POLICY_UNSPECIFIED`, `RELEASE`, `SNAPSHOT`.
         */
        versionPolicy?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfig {
        /**
         * Specific settings for an Apt remote repository.
         * Structure is documented below.
         */
        aptRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigAptRepository>;
        /**
         * Specific settings for an Artifact Registory remote repository.
         * Structure is documented below.
         */
        commonRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigCommonRepository>;
        /**
         * The description of the remote source.
         */
        description?: pulumi.Input<string>;
        /**
         * If true, the remote repository upstream and upstream credentials will
         * not be validated.
         */
        disableUpstreamValidation?: pulumi.Input<boolean>;
        /**
         * Specific settings for a Docker remote repository.
         * Structure is documented below.
         */
        dockerRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigDockerRepository>;
        /**
         * Specific settings for a Maven remote repository.
         * Structure is documented below.
         */
        mavenRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigMavenRepository>;
        /**
         * Specific settings for an Npm remote repository.
         * Structure is documented below.
         */
        npmRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigNpmRepository>;
        /**
         * Specific settings for a Python remote repository.
         * Structure is documented below.
         */
        pythonRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigPythonRepository>;
        /**
         * The credentials used to access the remote repository.
         * Structure is documented below.
         */
        upstreamCredentials?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigUpstreamCredentials>;
        /**
         * Specific settings for an Yum remote repository.
         * Structure is documented below.
         */
        yumRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigYumRepository>;
    }

    export interface RepositoryRemoteRepositoryConfigAptRepository {
        /**
         * One of the publicly available Apt repositories supported by Artifact Registry.
         * Structure is documented below.
         */
        publicRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigAptRepositoryPublicRepository>;
    }

    export interface RepositoryRemoteRepositoryConfigAptRepositoryPublicRepository {
        /**
         * A common public repository base for Yum.
         * Possible values are: `CENTOS`, `CENTOS_DEBUG`, `CENTOS_VAULT`, `CENTOS_STREAM`, `ROCKY`, `EPEL`.
         */
        repositoryBase: pulumi.Input<string>;
        /**
         * Specific repository from the base, e.g. `"pub/rocky/9/BaseOS/x86_64/os"`
         */
        repositoryPath: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigCommonRepository {
        /**
         * One of:
         * a. Artifact Registry Repository resource, e.g. `projects/UPSTREAM_PROJECT_ID/locations/REGION/repositories/UPSTREAM_REPOSITORY`
         * b. URI to the registry, e.g. `"https://registry-1.docker.io"`
         * c. URI to Artifact Registry Repository, e.g. `"https://REGION-docker.pkg.dev/UPSTREAM_PROJECT_ID/UPSTREAM_REPOSITORY"`
         */
        uri: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigDockerRepository {
        /**
         * [Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.
         * Structure is documented below.
         */
        customRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigDockerRepositoryCustomRepository>;
        /**
         * Address of the remote repository.
         * Default value is `DOCKER_HUB`.
         * Possible values are: `DOCKER_HUB`.
         */
        publicRepository?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigDockerRepositoryCustomRepository {
        /**
         * Specific uri to the registry, e.g. `"https://pypi.io"`
         */
        uri?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigMavenRepository {
        /**
         * [Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.
         * Structure is documented below.
         */
        customRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigMavenRepositoryCustomRepository>;
        /**
         * Address of the remote repository.
         * Default value is `MAVEN_CENTRAL`.
         * Possible values are: `MAVEN_CENTRAL`.
         */
        publicRepository?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigMavenRepositoryCustomRepository {
        /**
         * Specific uri to the registry, e.g. `"https://pypi.io"`
         */
        uri?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigNpmRepository {
        /**
         * [Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.
         * Structure is documented below.
         */
        customRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigNpmRepositoryCustomRepository>;
        /**
         * Address of the remote repository.
         * Default value is `NPMJS`.
         * Possible values are: `NPMJS`.
         */
        publicRepository?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigNpmRepositoryCustomRepository {
        /**
         * Specific uri to the registry, e.g. `"https://pypi.io"`
         */
        uri?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigPythonRepository {
        /**
         * [Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.
         * Structure is documented below.
         */
        customRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigPythonRepositoryCustomRepository>;
        /**
         * Address of the remote repository.
         * Default value is `PYPI`.
         * Possible values are: `PYPI`.
         */
        publicRepository?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigPythonRepositoryCustomRepository {
        /**
         * Specific uri to the registry, e.g. `"https://pypi.io"`
         */
        uri?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigUpstreamCredentials {
        /**
         * Use username and password to access the remote repository.
         * Structure is documented below.
         */
        usernamePasswordCredentials?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigUpstreamCredentialsUsernamePasswordCredentials>;
    }

    export interface RepositoryRemoteRepositoryConfigUpstreamCredentialsUsernamePasswordCredentials {
        /**
         * The Secret Manager key version that holds the password to access the
         * remote repository. Must be in the format of
         * `projects/{project}/secrets/{secret}/versions/{version}`.
         */
        passwordSecretVersion?: pulumi.Input<string>;
        /**
         * The username to access the remote repository.
         */
        username?: pulumi.Input<string>;
    }

    export interface RepositoryRemoteRepositoryConfigYumRepository {
        /**
         * One of the publicly available Yum repositories supported by Artifact Registry.
         * Structure is documented below.
         */
        publicRepository?: pulumi.Input<inputs.artifactregistry.RepositoryRemoteRepositoryConfigYumRepositoryPublicRepository>;
    }

    export interface RepositoryRemoteRepositoryConfigYumRepositoryPublicRepository {
        /**
         * A common public repository base for Yum.
         * Possible values are: `CENTOS`, `CENTOS_DEBUG`, `CENTOS_VAULT`, `CENTOS_STREAM`, `ROCKY`, `EPEL`.
         */
        repositoryBase: pulumi.Input<string>;
        /**
         * Specific repository from the base, e.g. `"pub/rocky/9/BaseOS/x86_64/os"`
         */
        repositoryPath: pulumi.Input<string>;
    }

    export interface RepositoryVirtualRepositoryConfig {
        /**
         * Policies that configure the upstream artifacts distributed by the Virtual
         * Repository. Upstream policies cannot be set on a standard repository.
         * Structure is documented below.
         */
        upstreamPolicies?: pulumi.Input<pulumi.Input<inputs.artifactregistry.RepositoryVirtualRepositoryConfigUpstreamPolicy>[]>;
    }

    export interface RepositoryVirtualRepositoryConfigUpstreamPolicy {
        /**
         * The user-provided ID of the upstream policy.
         */
        id?: pulumi.Input<string>;
        /**
         * Entries with a greater priority value take precedence in the pull order.
         */
        priority?: pulumi.Input<number>;
        /**
         * A reference to the repository resource, for example:
         * "projects/p1/locations/us-central1/repository/repo1".
         */
        repository?: pulumi.Input<string>;
    }

    export interface RepositoryVulnerabilityScanningConfig {
        /**
         * This configures whether vulnerability scanning is automatically performed for artifacts pushed to this repository.
         * Possible values are: `INHERITED`, `DISABLED`.
         */
        enablementConfig?: pulumi.Input<string>;
        /**
         * (Output)
         * This field returns whether scanning is active for this repository.
         */
        enablementState?: pulumi.Input<string>;
        /**
         * (Output)
         * This provides an explanation for the state of scanning on this repository.
         */
        enablementStateReason?: pulumi.Input<string>;
    }
}

export namespace assuredworkloads {
    export interface WorkloadComplianceStatus {
        /**
         * Number of current orgPolicy violations which are acknowledged.
         */
        acknowledgedViolationCounts?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Number of current orgPolicy violations which are not acknowledged.
         */
        activeViolationCounts?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface WorkloadEkmProvisioningResponse {
        /**
         * Indicates Ekm provisioning error if any. Possible values: EKM_PROVISIONING_ERROR_DOMAIN_UNSPECIFIED, UNSPECIFIED_ERROR, GOOGLE_SERVER_ERROR, EXTERNAL_USER_ERROR, EXTERNAL_PARTNER_ERROR, TIMEOUT_ERROR
         */
        ekmProvisioningErrorDomain?: pulumi.Input<string>;
        /**
         * Detailed error message if Ekm provisioning fails Possible values: EKM_PROVISIONING_ERROR_MAPPING_UNSPECIFIED, INVALID_SERVICE_ACCOUNT, MISSING_METRICS_SCOPE_ADMIN_PERMISSION, MISSING_EKM_CONNECTION_ADMIN_PERMISSION
         */
        ekmProvisioningErrorMapping?: pulumi.Input<string>;
        /**
         * Indicates Ekm enrollment Provisioning of a given workload. Possible values: EKM_PROVISIONING_STATE_UNSPECIFIED, EKM_PROVISIONING_STATE_PENDING, EKM_PROVISIONING_STATE_FAILED, EKM_PROVISIONING_STATE_COMPLETED
         */
        ekmProvisioningState?: pulumi.Input<string>;
    }

    export interface WorkloadKmsSettings {
        /**
         * Required. Input only. Immutable. The time at which the Key Management Service will automatically create a new version of the crypto key and mark it as the primary.
         */
        nextRotationTime: pulumi.Input<string>;
        /**
         * Required. Input only. Immutable. will be advanced by this period when the Key Management Service automatically rotates a key. Must be at least 24 hours and at most 876,000 hours.
         */
        rotationPeriod: pulumi.Input<string>;
    }

    export interface WorkloadPartnerPermissions {
        /**
         * Optional. Allow partner to view violation alerts.
         */
        assuredWorkloadsMonitoring?: pulumi.Input<boolean>;
        /**
         * Allow the partner to view inspectability logs and monitoring violations.
         */
        dataLogsViewer?: pulumi.Input<boolean>;
        /**
         * Optional. Allow partner to view access approval logs.
         */
        serviceAccessApprover?: pulumi.Input<boolean>;
    }

    export interface WorkloadResource {
        /**
         * Resource identifier. For a project this represents project_number.
         */
        resourceId?: pulumi.Input<number>;
        /**
         * Indicates the type of resource. Possible values: RESOURCE_TYPE_UNSPECIFIED, CONSUMER_PROJECT, ENCRYPTION_KEYS_PROJECT, KEYRING, CONSUMER_FOLDER
         */
        resourceType?: pulumi.Input<string>;
    }

    export interface WorkloadResourceSetting {
        /**
         * User-assigned resource display name. If not empty it will be used to create a resource with the specified name.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Resource identifier. For a project this represents projectId. If the project is already taken, the workload creation will fail. For KeyRing, this represents the keyring_id. For a folder, don't set this value as folderId is assigned by Google.
         */
        resourceId?: pulumi.Input<string>;
        /**
         * Indicates the type of resource. This field should be specified to correspond the id to the right project type (CONSUMER_PROJECT or ENCRYPTION_KEYS_PROJECT) Possible values: RESOURCE_TYPE_UNSPECIFIED, CONSUMER_PROJECT, ENCRYPTION_KEYS_PROJECT, KEYRING, CONSUMER_FOLDER
         */
        resourceType?: pulumi.Input<string>;
    }

    export interface WorkloadSaaEnrollmentResponse {
        /**
         * Indicates SAA enrollment setup error if any.
         */
        setupErrors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Indicates SAA enrollment status of a given workload. Possible values: SETUP_STATE_UNSPECIFIED, STATUS_PENDING, STATUS_COMPLETE
         */
        setupStatus?: pulumi.Input<string>;
    }

    export interface WorkloadWorkloadOptions {
        /**
         * Indicates type of KAJ enrollment for the workload. Currently, only specifiying KEY_ACCESS_TRANSPARENCY_OFF is implemented to not enroll in KAT-level KAJ enrollment for Regional Controls workloads. Possible values: KAJ_ENROLLMENT_TYPE_UNSPECIFIED, FULL_KAJ, EKM_ONLY, KEY_ACCESS_TRANSPARENCY_OFF
         */
        kajEnrollmentType?: pulumi.Input<string>;
    }
}

export namespace backupdisasterrecovery {
    export interface BackupPlanAssociationRulesConfigInfo {
        /**
         * (Output)
         * google.rpc.Status object to store the last backup error
         * Structure is documented below.
         */
        lastBackupErrors?: pulumi.Input<pulumi.Input<inputs.backupdisasterrecovery.BackupPlanAssociationRulesConfigInfoLastBackupError>[]>;
        /**
         * (Output)
         * State of last backup taken.
         */
        lastBackupState?: pulumi.Input<string>;
        /**
         * (Output)
         * Backup Rule id fetched from backup plan.
         */
        ruleId?: pulumi.Input<string>;
    }

    export interface BackupPlanAssociationRulesConfigInfoLastBackupError {
        /**
         * (Output)
         * The status code, which should be an enum value of [google.rpc.Code]
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English.
         */
        message?: pulumi.Input<string>;
    }

    export interface BackupPlanBackupRule {
        /**
         * Configures the duration for which backup data will be kept. The value should be greater than or equal to minimum enforced retention of the backup vault.
         */
        backupRetentionDays: pulumi.Input<number>;
        /**
         * The unique ID of this `BackupRule`. The `ruleId` is unique per `BackupPlan`.
         */
        ruleId: pulumi.Input<string>;
        /**
         * StandardSchedule defines a schedule that runs within the confines of a defined window of days.
         * Structure is documented below.
         */
        standardSchedule: pulumi.Input<inputs.backupdisasterrecovery.BackupPlanBackupRuleStandardSchedule>;
    }

    export interface BackupPlanBackupRuleStandardSchedule {
        /**
         * A BackupWindow defines the window of the day during which backup jobs will run. Jobs are queued at the beginning of the window and will be marked as
         * `NOT_RUN` if they do not start by the end of the window.
         * Structure is documented below.
         */
        backupWindow?: pulumi.Input<inputs.backupdisasterrecovery.BackupPlanBackupRuleStandardScheduleBackupWindow>;
        /**
         * Specifies days of months like 1, 5, or 14 on which jobs will run.
         */
        daysOfMonths?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Specifies days of week like MONDAY or TUESDAY, on which jobs will run. This is required for `recurrenceType`, `WEEKLY` and is not applicable otherwise.
         * Each value may be one of: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        daysOfWeeks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies frequency for hourly backups. An hourly frequency of 2 means jobs will run every 2 hours from start time till end time defined.
         * This is required for `recurrenceType`, `HOURLY` and is not applicable otherwise.
         */
        hourlyFrequency?: pulumi.Input<number>;
        /**
         * Specifies values of months
         * Each value may be one of: `MONTH_UNSPECIFIED`, `JANUARY`, `FEBRUARY`, `MARCH`, `APRIL`, `MAY`, `JUNE`, `JULY`, `AUGUST`, `SEPTEMBER`, `OCTOBER`, `NOVEMBER`, `DECEMBER`.
         */
        months?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * RecurrenceType enumerates the applicable periodicity for the schedule.
         * Possible values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
         */
        recurrenceType: pulumi.Input<string>;
        /**
         * The time zone to be used when interpreting the schedule.
         */
        timeZone: pulumi.Input<string>;
        /**
         * Specifies a week day of the month like FIRST SUNDAY or LAST MONDAY, on which jobs will run.
         * Structure is documented below.
         */
        weekDayOfMonth?: pulumi.Input<inputs.backupdisasterrecovery.BackupPlanBackupRuleStandardScheduleWeekDayOfMonth>;
    }

    export interface BackupPlanBackupRuleStandardScheduleBackupWindow {
        /**
         * The hour of the day (1-24) when the window ends, for example, if the value of end hour of the day is 10, that means the backup window end time is 10:00.
         * The end hour of the day should be greater than the start
         *
         * - - -
         */
        endHourOfDay?: pulumi.Input<number>;
        /**
         * The hour of the day (0-23) when the window starts, for example, if the value of the start hour of the day is 6, that means the backup window starts at 6:00.
         */
        startHourOfDay: pulumi.Input<number>;
    }

    export interface BackupPlanBackupRuleStandardScheduleWeekDayOfMonth {
        /**
         * Specifies the day of the week.
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeek: pulumi.Input<string>;
        /**
         * WeekOfMonth enumerates possible weeks in the month, e.g. the first, third, or last week of the month.
         * Possible values are: `WEEK_OF_MONTH_UNSPECIFIED`, `FIRST`, `SECOND`, `THIRD`, `FOURTH`, `LAST`.
         */
        weekOfMonth: pulumi.Input<string>;
    }

    export interface ManagementServerManagementUri {
        /**
         * (Output)
         * The management console api endpoint.
         */
        api?: pulumi.Input<string>;
        /**
         * (Output)
         * The management console webUi.
         */
        webUi?: pulumi.Input<string>;
    }

    export interface ManagementServerNetwork {
        /**
         * Network with format `projects/{{project_id}}/global/networks/{{network_id}}`
         */
        network: pulumi.Input<string>;
        /**
         * Type of Network peeringMode
         * Default value is `PRIVATE_SERVICE_ACCESS`.
         * Possible values are: `PRIVATE_SERVICE_ACCESS`.
         */
        peeringMode?: pulumi.Input<string>;
    }
}

export namespace beyondcorp {
    export interface AppConnectionApplicationEndpoint {
        /**
         * Hostname or IP address of the remote application endpoint.
         */
        host: pulumi.Input<string>;
        /**
         * Port of the remote application endpoint.
         *
         * - - -
         */
        port: pulumi.Input<number>;
    }

    export interface AppConnectionGateway {
        /**
         * AppGateway name in following format: projects/{project_id}/locations/{locationId}/appgateways/{gateway_id}.
         */
        appGateway: pulumi.Input<string>;
        /**
         * (Output)
         * Ingress port reserved on the gateways for this AppConnection, if not specified or zero, the default port is 19443.
         */
        ingressPort?: pulumi.Input<number>;
        /**
         * The type of hosting used by the gateway. Refer to
         * https://cloud.google.com/beyondcorp/docs/reference/rest/v1/projects.locations.appConnections#Type_1
         * for a list of possible values.
         */
        type?: pulumi.Input<string>;
        /**
         * (Output)
         * Server-defined URI for this resource.
         */
        uri?: pulumi.Input<string>;
    }

    export interface AppConnectorPrincipalInfo {
        /**
         * ServiceAccount represents a GCP service account.
         * Structure is documented below.
         */
        serviceAccount: pulumi.Input<inputs.beyondcorp.AppConnectorPrincipalInfoServiceAccount>;
    }

    export interface AppConnectorPrincipalInfoServiceAccount {
        /**
         * Email address of the service account.
         *
         * - - -
         */
        email: pulumi.Input<string>;
    }

    export interface AppGatewayAllocatedConnection {
        /**
         * The ingress port of an allocated connection.
         */
        ingressPort?: pulumi.Input<number>;
        /**
         * The PSC uri of an allocated connection.
         */
        pscUri?: pulumi.Input<string>;
    }

    export interface ApplicationEndpointMatcher {
        /**
         * Required. Hostname of the application.
         */
        hostname: pulumi.Input<string>;
        /**
         * Optional. Ports of the application.
         *
         * - - -
         */
        ports?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface ApplicationIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ApplicationIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ApplicationUpstream {
        /**
         * Optional. Routing policy information.
         * Structure is documented below.
         */
        egressPolicy?: pulumi.Input<inputs.beyondcorp.ApplicationUpstreamEgressPolicy>;
        /**
         * Network to forward traffic to.
         * Structure is documented below.
         */
        network?: pulumi.Input<inputs.beyondcorp.ApplicationUpstreamNetwork>;
    }

    export interface ApplicationUpstreamEgressPolicy {
        /**
         * Required. List of regions where the application sends traffic to.
         */
        regions: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplicationUpstreamNetwork {
        /**
         * Required. Network name is of the format:
         * `projects/{project}/global/networks/{network}`
         */
        name: pulumi.Input<string>;
    }

    export interface SecurityGatewayHub {
        /**
         * Internet Gateway configuration.
         * Structure is documented below.
         */
        internetGateway?: pulumi.Input<inputs.beyondcorp.SecurityGatewayHubInternetGateway>;
        /**
         * The identifier for this object. Format specified above.
         */
        region: pulumi.Input<string>;
    }

    export interface SecurityGatewayHubInternetGateway {
        /**
         * (Output)
         * Output only. List of IP addresses assigned to the Cloud NAT.
         */
        assignedIps?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityGatewayIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SecurityGatewayIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }
}

export namespace biglake {
    export interface DatabaseHiveOptions {
        /**
         * Cloud Storage folder URI where the database data is stored, starting with "gs://".
         */
        locationUri?: pulumi.Input<string>;
        /**
         * Stores user supplied Hive database parameters. An object containing a
         * list of"key": value pairs.
         * Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         *
         * - - -
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface TableHiveOptions {
        /**
         * Stores user supplied Hive table parameters. An object containing a
         * list of "key": value pairs.
         * Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Stores physical storage information on the data.
         * Structure is documented below.
         */
        storageDescriptor?: pulumi.Input<inputs.biglake.TableHiveOptionsStorageDescriptor>;
        /**
         * Hive table type. For example, MANAGED_TABLE, EXTERNAL_TABLE.
         */
        tableType?: pulumi.Input<string>;
    }

    export interface TableHiveOptionsStorageDescriptor {
        /**
         * The fully qualified Java class name of the input format.
         */
        inputFormat?: pulumi.Input<string>;
        /**
         * Cloud Storage folder URI where the table data is stored, starting with "gs://".
         */
        locationUri?: pulumi.Input<string>;
        /**
         * The fully qualified Java class name of the output format.
         */
        outputFormat?: pulumi.Input<string>;
    }
}

export namespace bigquery {
    export interface AppProfileDataBoostIsolationReadOnly {
        /**
         * The Compute Billing Owner for this Data Boost App Profile.
         * Possible values are: `HOST_PAYS`.
         */
        computeBillingOwner: pulumi.Input<string>;
    }

    export interface AppProfileSingleClusterRouting {
        /**
         * If true, CheckAndMutateRow and ReadModifyWriteRow requests are allowed by this app profile.
         * It is unsafe to send these requests to the same table/row/column in multiple clusters.
         */
        allowTransactionalWrites?: pulumi.Input<boolean>;
        /**
         * The cluster to which read/write requests should be routed.
         */
        clusterId: pulumi.Input<string>;
    }

    export interface AppProfileStandardIsolation {
        /**
         * The priority of requests sent using this app profile.
         * Possible values are: `PRIORITY_LOW`, `PRIORITY_MEDIUM`, `PRIORITY_HIGH`.
         */
        priority: pulumi.Input<string>;
    }

    export interface BiReservationPreferredTable {
        /**
         * The ID of the dataset in the above project.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The assigned project ID of the project.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The ID of the table in the above dataset.
         */
        tableId?: pulumi.Input<string>;
    }

    export interface ConnectionAws {
        /**
         * Authentication using Google owned service account to assume into customer's AWS IAM Role.
         * Structure is documented below.
         */
        accessRole: pulumi.Input<inputs.bigquery.ConnectionAwsAccessRole>;
    }

    export interface ConnectionAwsAccessRole {
        /**
         * The users AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
         */
        iamRoleId: pulumi.Input<string>;
        /**
         * (Output)
         * A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's AWS IAM Role.
         */
        identity?: pulumi.Input<string>;
    }

    export interface ConnectionAzure {
        /**
         * (Output)
         * The name of the Azure Active Directory Application.
         */
        application?: pulumi.Input<string>;
        /**
         * (Output)
         * The client id of the Azure Active Directory Application.
         */
        clientId?: pulumi.Input<string>;
        /**
         * The id of customer's directory that host the data.
         */
        customerTenantId: pulumi.Input<string>;
        /**
         * The Azure Application (client) ID where the federated credentials will be hosted.
         */
        federatedApplicationClientId?: pulumi.Input<string>;
        /**
         * (Output)
         * A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's Azure Active Directory Application.
         */
        identity?: pulumi.Input<string>;
        /**
         * (Output)
         * The object id of the Azure Active Directory Application.
         */
        objectId?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL user will be redirected to after granting consent during connection setup.
         */
        redirectUri?: pulumi.Input<string>;
    }

    export interface ConnectionCloudResource {
        /**
         * (Output)
         * The account ID of the service created for the purpose of this connection.
         */
        serviceAccountId?: pulumi.Input<string>;
    }

    export interface ConnectionCloudSpanner {
        /**
         * Cloud Spanner database in the form `project/instance/database'.
         */
        database: pulumi.Input<string>;
        /**
         * Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as `SELECT` and `INSERT`. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
         */
        databaseRole?: pulumi.Input<string>;
        /**
         * Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. `useParallelism` and `useDataBoost` must be set when setting max parallelism.
         */
        maxParallelism?: pulumi.Input<number>;
        /**
         * If set, the request will be executed via Spanner independent compute resources. `useParallelism` must be set when using data boost.
         */
        useDataBoost?: pulumi.Input<boolean>;
        /**
         * If parallelism should be used when reading from Cloud Spanner.
         */
        useParallelism?: pulumi.Input<boolean>;
        /**
         * (Optional, Deprecated)
         * If the serverless analytics service should be used to read data from Cloud Spanner. `useParallelism` must be set when using serverless analytics.
         *
         * > **Warning:** `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.
         *
         * @deprecated `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.
         */
        useServerlessAnalytics?: pulumi.Input<boolean>;
    }

    export interface ConnectionCloudSql {
        /**
         * Cloud SQL properties.
         * Structure is documented below.
         */
        credential: pulumi.Input<inputs.bigquery.ConnectionCloudSqlCredential>;
        /**
         * Database name.
         */
        database: pulumi.Input<string>;
        /**
         * Cloud SQL instance ID in the form project:location:instance.
         */
        instanceId: pulumi.Input<string>;
        /**
         * (Output)
         * When the connection is used in the context of an operation in BigQuery, this service account will serve as the identity being used for connecting to the CloudSQL instance specified in this connection.
         */
        serviceAccountId?: pulumi.Input<string>;
        /**
         * Type of the Cloud SQL database.
         * Possible values are: `DATABASE_TYPE_UNSPECIFIED`, `POSTGRES`, `MYSQL`.
         */
        type: pulumi.Input<string>;
    }

    export interface ConnectionCloudSqlCredential {
        /**
         * Password for database.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * Username for database.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConnectionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConnectionSpark {
        /**
         * Dataproc Metastore Service configuration for the connection.
         * Structure is documented below.
         */
        metastoreServiceConfig?: pulumi.Input<inputs.bigquery.ConnectionSparkMetastoreServiceConfig>;
        /**
         * (Output)
         * The account ID of the service created for the purpose of this connection.
         */
        serviceAccountId?: pulumi.Input<string>;
        /**
         * Spark History Server configuration for the connection.
         * Structure is documented below.
         */
        sparkHistoryServerConfig?: pulumi.Input<inputs.bigquery.ConnectionSparkSparkHistoryServerConfig>;
    }

    export interface ConnectionSparkMetastoreServiceConfig {
        /**
         * Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
         */
        metastoreService?: pulumi.Input<string>;
    }

    export interface ConnectionSparkSparkHistoryServerConfig {
        /**
         * Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[clusterName].
         */
        dataprocCluster?: pulumi.Input<string>;
    }

    export interface DataTransferConfigEmailPreferences {
        /**
         * If true, email notifications will be sent on transfer run failures.
         */
        enableFailureEmail: pulumi.Input<boolean>;
    }

    export interface DataTransferConfigEncryptionConfiguration {
        /**
         * The name of the KMS key used for encrypting BigQuery data.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface DataTransferConfigScheduleOptions {
        /**
         * If true, automatic scheduling of data transfer runs for this
         * configuration will be disabled. The runs can be started on ad-hoc
         * basis using transferConfigs.startManualRuns API. When automatic
         * scheduling is disabled, the TransferConfig.schedule field will
         * be ignored.
         */
        disableAutoScheduling?: pulumi.Input<boolean>;
        /**
         * Defines time to stop scheduling transfer runs. A transfer run cannot be
         * scheduled at or after the end time. The end time can be changed at any
         * moment. The time when a data transfer can be triggered manually is not
         * limited by this option.
         */
        endTime?: pulumi.Input<string>;
        /**
         * Specifies time to start scheduling transfer runs. The first run will be
         * scheduled at or after the start time according to a recurrence pattern
         * defined in the schedule string. The start time can be changed at any
         * moment. The time when a data transfer can be triggered manually is not
         * limited by this option.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface DataTransferConfigSensitiveParams {
        /**
         * The Secret Access Key of the AWS account transferring data from.
         */
        secretAccessKey?: pulumi.Input<string>;
    }

    export interface DatasetAccess {
        /**
         * Condition for the binding. If CEL expression in this field is true, this
         * access binding will be considered.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.bigquery.DatasetAccessCondition>;
        /**
         * Grants all resources of particular types in a particular dataset read access to the current dataset.
         * Structure is documented below.
         */
        dataset?: pulumi.Input<inputs.bigquery.DatasetAccessDataset>;
        /**
         * A domain to grant access to. Any users signed in with the
         * domain specified will be granted the specified access
         */
        domain?: pulumi.Input<string>;
        /**
         * An email address of a Google Group to grant access to.
         */
        groupByEmail?: pulumi.Input<string>;
        /**
         * Some other type of member that appears in the IAM Policy but isn't a user,
         * group, domain, or special group. For example: `allUsers`
         */
        iamMember?: pulumi.Input<string>;
        /**
         * Describes the rights granted to the user specified by the other
         * member of the access object. Basic, predefined, and custom roles
         * are supported. Predefined roles that have equivalent basic roles
         * are swapped by the API to their basic counterparts. See
         * [official docs](https://cloud.google.com/bigquery/docs/access-control).
         */
        role?: pulumi.Input<string>;
        /**
         * A routine from a different dataset to grant access to. Queries
         * executed against that routine will have read access to tables in
         * this dataset. The role field is not required when this field is
         * set. If that routine is updated by any user, access to the routine
         * needs to be granted again via an update operation.
         * Structure is documented below.
         */
        routine?: pulumi.Input<inputs.bigquery.DatasetAccessRoutine>;
        /**
         * A special group to grant access to. Possible values include:
         * * `projectOwners`: Owners of the enclosing project.
         * * `projectReaders`: Readers of the enclosing project.
         * * `projectWriters`: Writers of the enclosing project.
         * * `allAuthenticatedUsers`: All authenticated BigQuery users.
         */
        specialGroup?: pulumi.Input<string>;
        /**
         * An email address of a user to grant access to. For example:
         * fred@example.com
         */
        userByEmail?: pulumi.Input<string>;
        /**
         * A view from a different dataset to grant access to. Queries
         * executed against that view will have read access to tables in
         * this dataset. The role field is not required when this field is
         * set. If that view is updated by any user, access to the view
         * needs to be granted again via an update operation.
         * Structure is documented below.
         */
        view?: pulumi.Input<inputs.bigquery.DatasetAccessView>;
    }

    export interface DatasetAccessAuthorizedDataset {
        /**
         * The dataset this entry applies to
         * Structure is documented below.
         */
        dataset: pulumi.Input<inputs.bigquery.DatasetAccessAuthorizedDatasetDataset>;
        /**
         * Which resources in the dataset this entry applies to. Currently, only views are supported,
         * but additional target types may be added in the future. Possible values: VIEWS
         */
        targetTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatasetAccessAuthorizedDatasetDataset {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
    }

    export interface DatasetAccessCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file
         * name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface DatasetAccessDataset {
        /**
         * The dataset this entry applies to
         * Structure is documented below.
         */
        dataset: pulumi.Input<inputs.bigquery.DatasetAccessDatasetDataset>;
        /**
         * Which resources in the dataset this entry applies to. Currently, only views are supported,
         * but additional target types may be added in the future. Possible values: VIEWS
         */
        targetTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatasetAccessDatasetDataset {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
    }

    export interface DatasetAccessRoutine {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The ID of the routine. The ID must contain only letters (a-z,
         * A-Z), numbers (0-9), or underscores (_). The maximum length
         * is 256 characters.
         */
        routineId: pulumi.Input<string>;
    }

    export interface DatasetAccessView {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The ID of the table. The ID must contain only letters (a-z,
         * A-Z), numbers (0-9), or underscores (_). The maximum length
         * is 1,024 characters.
         */
        tableId: pulumi.Input<string>;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination
         * BigQuery table. The BigQuery Service Account associated with your project requires
         * access to this encryption key.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface DatasetExternalCatalogDatasetOptions {
        /**
         * The storage location URI for all tables in the dataset. Equivalent to hive metastore's
         * database locationUri. Maximum length of 1024 characters.
         */
        defaultStorageLocationUri?: pulumi.Input<string>;
        /**
         * A map of key value pairs defining the parameters and properties of the open source schema.
         * Maximum size of 2Mib.
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface DatasetExternalDatasetReference {
        /**
         * The connection id that is used to access the externalSource.
         * Format: projects/{projectId}/locations/{locationId}/connections/{connectionId}
         */
        connection: pulumi.Input<string>;
        /**
         * External source that backs this dataset.
         */
        externalSource: pulumi.Input<string>;
    }

    export interface DatasetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatasetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobCopy {
        /**
         * Specifies whether the job is allowed to create new tables. The following values are supported:
         * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
         * CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
         * Creation, truncation and append actions occur as one atomic update upon job completion
         * Default value is `CREATE_IF_NEEDED`.
         * Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
         */
        createDisposition?: pulumi.Input<string>;
        /**
         * Custom encryption configuration (e.g., Cloud KMS keys)
         * Structure is documented below.
         */
        destinationEncryptionConfiguration?: pulumi.Input<inputs.bigquery.JobCopyDestinationEncryptionConfiguration>;
        /**
         * The destination table.
         * Structure is documented below.
         */
        destinationTable?: pulumi.Input<inputs.bigquery.JobCopyDestinationTable>;
        /**
         * Source tables to copy.
         * Structure is documented below.
         */
        sourceTables: pulumi.Input<pulumi.Input<inputs.bigquery.JobCopySourceTable>[]>;
        /**
         * Specifies the action that occurs if the destination table already exists. The following values are supported:
         * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
         * WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
         * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
         * Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
         * Creation, truncation and append actions occur as one atomic update upon job completion.
         * Default value is `WRITE_EMPTY`.
         * Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
         */
        writeDisposition?: pulumi.Input<string>;
    }

    export interface JobCopyDestinationEncryptionConfiguration {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
         * The BigQuery Service Account associated with your project requires access to this encryption key.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * (Output)
         * Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
         */
        kmsKeyVersion?: pulumi.Input<string>;
    }

    export interface JobCopyDestinationTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The table. Can be specified `{{table_id}}` if `projectId` and `datasetId` are also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
         */
        tableId: pulumi.Input<string>;
    }

    export interface JobCopySourceTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The table. Can be specified `{{table_id}}` if `projectId` and `datasetId` are also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
         */
        tableId: pulumi.Input<string>;
    }

    export interface JobExtract {
        /**
         * The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE.
         * The default value is NONE. DEFLATE and SNAPPY are only supported for Avro.
         */
        compression?: pulumi.Input<string>;
        /**
         * The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models.
         * The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV.
         * The default value for models is SAVED_MODEL.
         */
        destinationFormat?: pulumi.Input<string>;
        /**
         * A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
         */
        destinationUris: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * When extracting data in CSV format, this defines the delimiter to use between fields in the exported data.
         * Default is ','
         */
        fieldDelimiter?: pulumi.Input<string>;
        /**
         * Whether to print out a header row in the results. Default is true.
         */
        printHeader?: pulumi.Input<boolean>;
        /**
         * A reference to the model being exported.
         * Structure is documented below.
         */
        sourceModel?: pulumi.Input<inputs.bigquery.JobExtractSourceModel>;
        /**
         * A reference to the table being exported.
         * Structure is documented below.
         */
        sourceTable?: pulumi.Input<inputs.bigquery.JobExtractSourceTable>;
        /**
         * Whether to use logical types when extracting to AVRO format.
         */
        useAvroLogicalTypes?: pulumi.Input<boolean>;
    }

    export interface JobExtractSourceModel {
        /**
         * The ID of the dataset containing this model.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the model.
         *
         * - - -
         */
        modelId: pulumi.Input<string>;
        /**
         * The ID of the project containing this model.
         */
        projectId: pulumi.Input<string>;
    }

    export interface JobExtractSourceTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The table. Can be specified `{{table_id}}` if `projectId` and `datasetId` are also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
         */
        tableId: pulumi.Input<string>;
    }

    export interface JobLoad {
        /**
         * Accept rows that are missing trailing optional columns. The missing values are treated as nulls.
         * If false, records with missing trailing columns are treated as bad records, and if there are too many bad records,
         * an invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.
         */
        allowJaggedRows?: pulumi.Input<boolean>;
        /**
         * Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file.
         * The default value is false.
         */
        allowQuotedNewlines?: pulumi.Input<boolean>;
        /**
         * Indicates if we should automatically infer the options and schema for CSV and JSON sources.
         */
        autodetect?: pulumi.Input<boolean>;
        /**
         * Specifies whether the job is allowed to create new tables. The following values are supported:
         * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
         * CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
         * Creation, truncation and append actions occur as one atomic update upon job completion
         * Default value is `CREATE_IF_NEEDED`.
         * Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
         */
        createDisposition?: pulumi.Input<string>;
        /**
         * Custom encryption configuration (e.g., Cloud KMS keys)
         * Structure is documented below.
         */
        destinationEncryptionConfiguration?: pulumi.Input<inputs.bigquery.JobLoadDestinationEncryptionConfiguration>;
        /**
         * The destination table to load the data into.
         * Structure is documented below.
         */
        destinationTable: pulumi.Input<inputs.bigquery.JobLoadDestinationTable>;
        /**
         * The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.
         * The default value is UTF-8. BigQuery decodes the data after the raw, binary data
         * has been split using the values of the quote and fieldDelimiter properties.
         */
        encoding?: pulumi.Input<string>;
        /**
         * The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character.
         * To use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts
         * the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the
         * data in its raw, binary state. BigQuery also supports the escape sequence "\t" to specify a tab separator.
         * The default value is a comma (',').
         */
        fieldDelimiter?: pulumi.Input<string>;
        /**
         * Indicates if BigQuery should allow extra values that are not represented in the table schema.
         * If true, the extra values are ignored. If false, records with extra columns are treated as bad records,
         * and if there are too many bad records, an invalid error is returned in the job result.
         * The default value is false. The sourceFormat property determines what BigQuery treats as an extra value:
         * CSV: Trailing columns
         * JSON: Named values that don't match any column names
         */
        ignoreUnknownValues?: pulumi.Input<boolean>;
        /**
         * If sourceFormat is set to newline-delimited JSON, indicates whether it should be processed as a JSON variant such as GeoJSON.
         * For a sourceFormat other than JSON, omit this field. If the sourceFormat is newline-delimited JSON: - for newline-delimited
         * GeoJSON: set to GEOJSON.
         */
        jsonExtension?: pulumi.Input<string>;
        /**
         * The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value,
         * an invalid error is returned in the job result. The default value is 0, which requires that all records are valid.
         */
        maxBadRecords?: pulumi.Input<number>;
        /**
         * Specifies a string that represents a null value in a CSV file. The default value is the empty string. If you set this
         * property to a custom value, BigQuery throws an error if an
         * empty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as
         * an empty value.
         */
        nullMarker?: pulumi.Input<string>;
        /**
         * Parquet Options for load and make external tables.
         * Structure is documented below.
         */
        parquetOptions?: pulumi.Input<inputs.bigquery.JobLoadParquetOptions>;
        /**
         * If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity properties to load into BigQuery from a Cloud Datastore backup.
         * Property names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties.
         * If any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.
         */
        projectionFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding,
         * and then uses the first byte of the encoded string to split the data in its raw, binary state.
         * The default value is a double-quote ('"'). If your data does not contain quoted sections, set the property value to an empty string.
         * If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.
         */
        quote?: pulumi.Input<string>;
        /**
         * Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or
         * supplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
         * when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators.
         * For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified:
         * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
         * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
         */
        schemaUpdateOptions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The number of rows at the top of a CSV file that BigQuery will skip when loading the data.
         * The default value is 0. This property is useful if you have header rows in the file that should be skipped.
         * When autodetect is on, the behavior is the following:
         * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected,
         * the row is read as data. Otherwise data is read starting from the second row.
         * skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row.
         * skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected,
         * row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
         */
        skipLeadingRows?: pulumi.Input<number>;
        /**
         * The format of the data files. For CSV files, specify "CSV". For datastore backups, specify "DATASTORE_BACKUP".
         * For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet, specify "PARQUET".
         * For orc, specify "ORC". [Beta] For Bigtable, specify "BIGTABLE".
         * The default value is CSV.
         */
        sourceFormat?: pulumi.Input<string>;
        /**
         * The fully-qualified URIs that point to your data in Google Cloud.
         * For Google Cloud Storage URIs: Each URI can contain one '\*' wildcard character
         * and it must come after the 'bucket' name. Size limits related to load jobs apply
         * to external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be
         * specified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table.
         * For Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '\*' wildcard character is not allowed.
         */
        sourceUris: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Time-based partitioning specification for the destination table.
         * Structure is documented below.
         */
        timePartitioning?: pulumi.Input<inputs.bigquery.JobLoadTimePartitioning>;
        /**
         * Specifies the action that occurs if the destination table already exists. The following values are supported:
         * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
         * WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
         * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
         * Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
         * Creation, truncation and append actions occur as one atomic update upon job completion.
         * Default value is `WRITE_EMPTY`.
         * Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
         */
        writeDisposition?: pulumi.Input<string>;
    }

    export interface JobLoadDestinationEncryptionConfiguration {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
         * The BigQuery Service Account associated with your project requires access to this encryption key.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * (Output)
         * Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
         */
        kmsKeyVersion?: pulumi.Input<string>;
    }

    export interface JobLoadDestinationTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The table. Can be specified `{{table_id}}` if `projectId` and `datasetId` are also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
         */
        tableId: pulumi.Input<string>;
    }

    export interface JobLoadParquetOptions {
        /**
         * If sourceFormat is set to PARQUET, indicates whether to use schema inference specifically for Parquet LIST logical type.
         */
        enableListInference?: pulumi.Input<boolean>;
        /**
         * If sourceFormat is set to PARQUET, indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
         */
        enumAsString?: pulumi.Input<boolean>;
    }

    export interface JobLoadTimePartitioning {
        /**
         * Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.
         */
        expirationMs?: pulumi.Input<string>;
        /**
         * If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field.
         * The field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED.
         * A wrapper is used here because an empty string is an invalid value.
         */
        field?: pulumi.Input<string>;
        /**
         * The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error,
         * but in OnePlatform the field will be treated as unset.
         */
        type: pulumi.Input<string>;
    }

    export interface JobQuery {
        /**
         * If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance.
         * Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed.
         * However, you must still set destinationTable when result size exceeds the allowed maximum response size.
         */
        allowLargeResults?: pulumi.Input<boolean>;
        /**
         * Whether to run the query as continuous or a regular query.
         */
        continuous?: pulumi.Input<boolean>;
        /**
         * Specifies whether the job is allowed to create new tables. The following values are supported:
         * CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
         * CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
         * Creation, truncation and append actions occur as one atomic update upon job completion
         * Default value is `CREATE_IF_NEEDED`.
         * Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
         */
        createDisposition?: pulumi.Input<string>;
        /**
         * Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
         * Structure is documented below.
         */
        defaultDataset?: pulumi.Input<inputs.bigquery.JobQueryDefaultDataset>;
        /**
         * Custom encryption configuration (e.g., Cloud KMS keys)
         * Structure is documented below.
         */
        destinationEncryptionConfiguration?: pulumi.Input<inputs.bigquery.JobQueryDestinationEncryptionConfiguration>;
        /**
         * Describes the table where the query results should be stored.
         * This property must be set for large results that exceed the maximum response size.
         * For queries that produce anonymous (cached) results, this field will be populated by BigQuery.
         * Structure is documented below.
         */
        destinationTable?: pulumi.Input<inputs.bigquery.JobQueryDestinationTable>;
        /**
         * If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results.
         * allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
         */
        flattenResults?: pulumi.Input<boolean>;
        /**
         * Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge).
         * If unspecified, this will be set to your project default.
         */
        maximumBillingTier?: pulumi.Input<number>;
        /**
         * Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge).
         * If unspecified, this will be set to your project default.
         */
        maximumBytesBilled?: pulumi.Input<string>;
        /**
         * Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
         */
        parameterMode?: pulumi.Input<string>;
        /**
         * Specifies a priority for the query.
         * Default value is `INTERACTIVE`.
         * Possible values are: `INTERACTIVE`, `BATCH`.
         */
        priority?: pulumi.Input<string>;
        /**
         * SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
         * *NOTE*: queries containing [DML language](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
         * (`DELETE`, `UPDATE`, `MERGE`, `INSERT`) must specify `createDisposition = ""` and `writeDisposition = ""`.
         */
        query: pulumi.Input<string>;
        /**
         * Allows the schema of the destination table to be updated as a side effect of the query job.
         * Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
         * when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table,
         * specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema.
         * One or more of the following values are specified:
         * ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
         * ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
         */
        schemaUpdateOptions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Options controlling the execution of scripts.
         * Structure is documented below.
         */
        scriptOptions?: pulumi.Input<inputs.bigquery.JobQueryScriptOptions>;
        /**
         * Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true.
         * If set to false, the query will use BigQuery's standard SQL.
         */
        useLegacySql?: pulumi.Input<boolean>;
        /**
         * Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever
         * tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified.
         * The default value is true.
         */
        useQueryCache?: pulumi.Input<boolean>;
        /**
         * Describes user-defined function resources used in the query.
         * Structure is documented below.
         */
        userDefinedFunctionResources?: pulumi.Input<pulumi.Input<inputs.bigquery.JobQueryUserDefinedFunctionResource>[]>;
        /**
         * Specifies the action that occurs if the destination table already exists. The following values are supported:
         * WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
         * WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
         * WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
         * Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
         * Creation, truncation and append actions occur as one atomic update upon job completion.
         * Default value is `WRITE_EMPTY`.
         * Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
         */
        writeDisposition?: pulumi.Input<string>;
    }

    export interface JobQueryDefaultDataset {
        /**
         * The dataset. Can be specified `{{dataset_id}}` if `projectId` is also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}` if not.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
    }

    export interface JobQueryDestinationEncryptionConfiguration {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
         * The BigQuery Service Account associated with your project requires access to this encryption key.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * (Output)
         * Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
         */
        kmsKeyVersion?: pulumi.Input<string>;
    }

    export interface JobQueryDestinationTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The table. Can be specified `{{table_id}}` if `projectId` and `datasetId` are also set,
         * or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
         */
        tableId: pulumi.Input<string>;
    }

    export interface JobQueryScriptOptions {
        /**
         * Determines which statement in the script represents the "key result",
         * used to populate the schema and query results of the script job.
         * Possible values are: `LAST`, `FIRST_SELECT`.
         */
        keyResultStatement?: pulumi.Input<string>;
        /**
         * Limit on the number of bytes billed per statement. Exceeding this budget results in an error.
         */
        statementByteBudget?: pulumi.Input<string>;
        /**
         * Timeout period for each statement in a script.
         */
        statementTimeoutMs?: pulumi.Input<string>;
    }

    export interface JobQueryUserDefinedFunctionResource {
        /**
         * An inline resource that contains code for a user-defined function (UDF).
         * Providing a inline code resource is equivalent to providing a URI for a file containing the same code.
         */
        inlineCode?: pulumi.Input<string>;
        /**
         * A code resource to load from a Google Cloud Storage URI (gs://bucket/path).
         */
        resourceUri?: pulumi.Input<string>;
    }

    export interface JobStatus {
        /**
         * (Output)
         * Final error result of the job. If present, indicates that the job has completed and was unsuccessful.
         * Structure is documented below.
         */
        errorResults?: pulumi.Input<pulumi.Input<inputs.bigquery.JobStatusErrorResult>[]>;
        /**
         * (Output)
         * The first errors encountered during the running of the job. The final message
         * includes the number of errors that caused the process to stop. Errors here do
         * not necessarily mean that the job has not completed or was unsuccessful.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.bigquery.JobStatusError>[]>;
        /**
         * (Output)
         * Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.
         */
        state?: pulumi.Input<string>;
    }

    export interface JobStatusError {
        /**
         * Specifies where the error occurred, if present.
         */
        location?: pulumi.Input<string>;
        /**
         * A human-readable description of the error.
         */
        message?: pulumi.Input<string>;
        /**
         * A short error code that summarizes the error.
         */
        reason?: pulumi.Input<string>;
    }

    export interface JobStatusErrorResult {
        /**
         * Specifies where the error occurred, if present.
         */
        location?: pulumi.Input<string>;
        /**
         * A human-readable description of the error.
         */
        message?: pulumi.Input<string>;
        /**
         * A short error code that summarizes the error.
         */
        reason?: pulumi.Input<string>;
    }

    export interface ReservationAutoscale {
        /**
         * (Output)
         * The slot capacity added to this reservation when autoscale happens. Will be between [0, maxSlots].
         */
        currentSlots?: pulumi.Input<number>;
        /**
         * Number of slots to be scaled when needed.
         */
        maxSlots?: pulumi.Input<number>;
    }

    export interface ReservationReplicationStatus {
        /**
         * (Output)
         * The last error encountered while trying to replicate changes from the primary to the
         * secondary. This field is only available if the replication has not succeeded since.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.bigquery.ReservationReplicationStatusError>[]>;
        /**
         * (Output)
         * The time at which the last error was encountered while trying to replicate changes from
         * the primary to the secondary. This field is only available if the replication has not
         * succeeded since.
         */
        lastErrorTime?: pulumi.Input<string>;
        /**
         * (Output)
         * A timestamp corresponding to the last change on the primary that was successfully
         * replicated to the secondary.
         */
        lastReplicationTime?: pulumi.Input<string>;
    }

    export interface ReservationReplicationStatusError {
        /**
         * (Output)
         * The status code, which should be an enum value of [google.rpc.Code](https://cloud.google.com/bigquery/docs/reference/reservations/rpc/google.rpc#google.rpc.Code).
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English.
         */
        message?: pulumi.Input<string>;
    }

    export interface RoutineArgument {
        /**
         * Defaults to FIXED_TYPE.
         * Default value is `FIXED_TYPE`.
         * Possible values are: `FIXED_TYPE`, `ANY_TYPE`.
         */
        argumentKind?: pulumi.Input<string>;
        /**
         * A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
         * ~>**NOTE**: Because this field expects a JSON string, any changes to the string
         * will create a diff, even if the JSON itself hasn't changed. If the API returns
         * a different value for the same schema, e.g. it switched the order of values
         * or replaced STRUCT field type with RECORD field type, we currently cannot
         * suppress the recurring diff this causes. As a workaround, we recommend using
         * the schema as returned by the API.
         */
        dataType?: pulumi.Input<string>;
        /**
         * Specifies whether the argument is input or output. Can be set for procedures only.
         * Possible values are: `IN`, `OUT`, `INOUT`.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name of this argument. Can be absent for function return argument.
         */
        name?: pulumi.Input<string>;
    }

    export interface RoutineRemoteFunctionOptions {
        /**
         * Fully qualified name of the user-provided connection object which holds
         * the authentication information to send requests to the remote service.
         * Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
         */
        connection?: pulumi.Input<string>;
        /**
         * Endpoint of the user-provided remote service, e.g.
         * `https://us-east1-my_gcf_project.cloudfunctions.net/remote_add`
         */
        endpoint?: pulumi.Input<string>;
        /**
         * Max number of rows in each batch sent to the remote service. If absent or if 0,
         * BigQuery dynamically decides the number of rows in a batch.
         */
        maxBatchingRows?: pulumi.Input<string>;
        /**
         * User-defined context as a set of key/value pairs, which will be sent as function
         * invocation context together with batched arguments in the requests to the remote
         * service. The total number of bytes of keys and values must be less than 8KB.
         * An object containing a list of "key": value pairs. Example:
         * `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
         */
        userDefinedContext?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RoutineSparkOptions {
        /**
         * Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully qualified name of the user-provided Spark connection object.
         * Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
         */
        connection?: pulumi.Input<string>;
        /**
         * Custom container image for the runtime environment.
         */
        containerImage?: pulumi.Input<string>;
        /**
         * Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
         */
        jarUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The fully qualified name of a class in jarUris, for example, com.example.wordcount.
         * Exactly one of mainClass and mainJarUri field should be set for Java/Scala language type.
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The main file/jar URI of the Spark application.
         * Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
         * Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
         */
        mainFileUri?: pulumi.Input<string>;
        /**
         * Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
         * For more information, see Apache Spark and the procedure option list.
         * An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
         */
        pyFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Runtime version. If not specified, the default runtime version is used.
         */
        runtimeVersion?: pulumi.Input<string>;
    }

    export interface TableBiglakeConfiguration {
        /**
         * The connection specifying the credentials to be used to
         * read and write to external storage, such as Cloud Storage. The connectionId can
         * have the form "&lt;project\_id&gt;.&lt;location\_id&gt;.&lt;connection\_id&gt;" or
         * projects/&lt;project\_id&gt;/locations/&lt;location\_id&gt;/connections/&lt;connection\_id&gt;".
         */
        connectionId: pulumi.Input<string>;
        /**
         * The file format the table data is stored in.
         */
        fileFormat: pulumi.Input<string>;
        /**
         * The fully qualified location prefix of the external folder where table data
         * is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
         */
        storageUri: pulumi.Input<string>;
        /**
         * The table format the metadata only snapshots are stored in.
         */
        tableFormat: pulumi.Input<string>;
    }

    export interface TableEncryptionConfiguration {
        /**
         * The self link or full name of a key which should be used to
         * encrypt this table.  Note that the default bigquery service account will need to have
         * encrypt/decrypt permissions on this key - you may want to see the
         * `gcp.bigquery.getDefaultServiceAccount` datasource and the
         * `gcp.kms.CryptoKeyIAMBinding` resource.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * The self link or full name of the kms key version used to encrypt this table.
         */
        kmsKeyVersion?: pulumi.Input<string>;
    }

    export interface TableExternalCatalogTableOptions {
        /**
         * The connection specifying the credentials to be
         * used to read external storage, such as Azure Blob, Cloud Storage, or S3. The
         * connection is needed to read the open source table from BigQuery Engine. The
         * connectionId can have the form `<project_id>.<location_id>.<connection_id>`
         * or `projects/<project_id>/locations/<location_id>/connections/<connection_id>`.
         */
        connectionId?: pulumi.Input<string>;
        /**
         * A map of key value pairs defining the parameters and
         * properties of the open source table. Corresponds with hive meta store table
         * parameters. Maximum size of 4Mib.
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A storage descriptor containing information
         * about the physical storage of this table. Structure is documented below.
         */
        storageDescriptor?: pulumi.Input<inputs.bigquery.TableExternalCatalogTableOptionsStorageDescriptor>;
    }

    export interface TableExternalCatalogTableOptionsStorageDescriptor {
        /**
         * Specifies the fully qualified class name of the
         * InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The
         * maximum length is 128 characters.
         */
        inputFormat?: pulumi.Input<string>;
        /**
         * The physical location of the table (e.g.
         * 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or
         * 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
         */
        locationUri?: pulumi.Input<string>;
        /**
         * Specifies the fully qualified class name of the
         * OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The
         * maximum length is 128 characters.
         */
        outputFormat?: pulumi.Input<string>;
        /**
         * Serializer and deserializer information. Structure
         * is documented below.
         */
        serdeInfo?: pulumi.Input<inputs.bigquery.TableExternalCatalogTableOptionsStorageDescriptorSerdeInfo>;
    }

    export interface TableExternalCatalogTableOptionsStorageDescriptorSerdeInfo {
        /**
         * Name of the SerDe. The maximum length is 256 characters.
         */
        name?: pulumi.Input<string>;
        /**
         * Key-value pairs that define the initialization
         * parameters for the serialization library. Maximum size 10 Kib.
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Specifies a fully-qualified class name of
         * the serialization library that is responsible for the translation of data
         * between table representation and the underlying low-level input and output
         * format structures. The maximum length is 256 characters.
         */
        serializationLibrary: pulumi.Input<string>;
    }

    export interface TableExternalDataConfiguration {
        /**
         * Let BigQuery try to autodetect the schema
         * and format of the table.
         */
        autodetect: pulumi.Input<boolean>;
        /**
         * Additional options if `sourceFormat` is set to
         * "AVRO".  Structure is documented below.
         */
        avroOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationAvroOptions>;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "BIGTABLE". Structure is documented below.
         */
        bigtableOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationBigtableOptions>;
        /**
         * The compression type of the data source.
         * Valid values are "NONE" or "GZIP".
         */
        compression?: pulumi.Input<string>;
        /**
         * The connection specifying the credentials to be used to read
         * external storage, such as Azure Blob, Cloud Storage, or S3. The `connectionId` can have
         * the form `{{project}}.{{location}}.{{connection_id}}`
         * or `projects/{{project}}/locations/{{location}}/connections/{{connection_id}}`.
         *
         * ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
         * table schema must be specified using the top-level `schema` field
         * documented above.
         */
        connectionId?: pulumi.Input<string>;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "CSV". Structure is documented below.
         */
        csvOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationCsvOptions>;
        /**
         * Specifies how source URIs are interpreted for constructing the file set to load.
         * By default source URIs are expanded against the underlying storage.
         * Other options include specifying manifest files. Only applicable to object storage systems. Docs
         */
        fileSetSpecType?: pulumi.Input<string>;
        /**
         * Additional options if
         * `sourceFormat` is set to "GOOGLE_SHEETS". Structure is
         * documented below.
         */
        googleSheetsOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions>;
        /**
         * When set, configures hive partitioning
         * support. Not all storage formats support hive partitioning -- requesting hive
         * partitioning on an unsupported format will lead to an error, as will providing
         * an invalid specification. Structure is documented below.
         */
        hivePartitioningOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationHivePartitioningOptions>;
        /**
         * Indicates if BigQuery should
         * allow extra values that are not represented in the table schema.
         * If true, the extra values are ignored. If false, records with
         * extra columns are treated as bad records, and if there are too
         * many bad records, an invalid error is returned in the job result.
         * The default value is false.
         */
        ignoreUnknownValues?: pulumi.Input<boolean>;
        /**
         * Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the `JSON` source format. Valid values are: `GEOJSON`.
         */
        jsonExtension?: pulumi.Input<string>;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "JSON". Structure is documented below.
         */
        jsonOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationJsonOptions>;
        /**
         * The maximum number of bad records that
         * BigQuery can ignore when reading data.
         */
        maxBadRecords?: pulumi.Input<number>;
        /**
         * Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are `AUTOMATIC` and `MANUAL`.
         */
        metadataCacheMode?: pulumi.Input<string>;
        /**
         * Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If `objectMetadata` is set, `sourceFormat` should be omitted.
         */
        objectMetadata?: pulumi.Input<string>;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "PARQUET". Structure is documented below.
         */
        parquetOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationParquetOptions>;
        /**
         * When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
         */
        referenceFileSchemaUri?: pulumi.Input<string>;
        /**
         * A JSON schema for the external table. Schema is required
         * for CSV and JSON formats if autodetect is not on. Schema is disallowed
         * for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
         * ~>**NOTE:** Because this field expects a JSON string, any changes to the
         * string will create a diff, even if the JSON itself hasn't changed.
         * Furthermore drift for this field cannot not be detected because BigQuery
         * only uses this schema to compute the effective schema for the table, therefore
         * any changes on the configured value will force the table to be recreated.
         * This schema is effectively only applied when creating a table from an external
         * datasource, after creation the computed schema will be stored in
         * `google_bigquery_table.schema`
         *
         * ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
         * table schema must be specified using the top-level `schema` field
         * documented above.
         */
        schema?: pulumi.Input<string>;
        /**
         * The data format. Please see sourceFormat under
         * [ExternalDataConfiguration](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#externaldataconfiguration)
         * in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
         * the `scopes` must include "https://www.googleapis.com/auth/drive.readonly".
         */
        sourceFormat?: pulumi.Input<string>;
        /**
         * A list of the fully-qualified URIs that point to
         * your data in Google Cloud.
         */
        sourceUris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableExternalDataConfigurationAvroOptions {
        /**
         * If is set to true, indicates whether
         * to interpret logical types as the corresponding BigQuery data type
         * (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
         */
        useAvroLogicalTypes: pulumi.Input<boolean>;
    }

    export interface TableExternalDataConfigurationBigtableOptions {
        /**
         * A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
         */
        columnFamilies?: pulumi.Input<pulumi.Input<inputs.bigquery.TableExternalDataConfigurationBigtableOptionsColumnFamily>[]>;
        /**
         * If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
         */
        ignoreUnspecifiedColumnFamilies?: pulumi.Input<boolean>;
        /**
         * If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
         */
        outputColumnFamiliesAsJson?: pulumi.Input<boolean>;
        /**
         * If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
         */
        readRowkeyAsString?: pulumi.Input<boolean>;
    }

    export interface TableExternalDataConfigurationBigtableOptionsColumnFamily {
        /**
         * A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
         */
        columns?: pulumi.Input<pulumi.Input<inputs.bigquery.TableExternalDataConfigurationBigtableOptionsColumnFamilyColumn>[]>;
        /**
         * The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. This can be overridden for a specific column by listing that column in 'columns' and specifying an encoding for it.
         */
        encoding?: pulumi.Input<string>;
        /**
         * Identifier of the column family.
         */
        familyId?: pulumi.Input<string>;
        /**
         * If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
         */
        onlyReadLatest?: pulumi.Input<boolean>;
        /**
         * The type to convert the value in cells of this column family. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON". Default type is BYTES. This can be overridden for a specific column by listing that column in 'columns' and specifying a type for it.
         */
        type?: pulumi.Input<string>;
    }

    export interface TableExternalDataConfigurationBigtableOptionsColumnFamilyColumn {
        /**
         * The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.
         */
        encoding?: pulumi.Input<string>;
        /**
         * If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
         */
        fieldName?: pulumi.Input<string>;
        /**
         * If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.
         */
        onlyReadLatest?: pulumi.Input<boolean>;
        /**
         * Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
         */
        qualifierEncoded?: pulumi.Input<string>;
        /**
         * Qualifier string.
         */
        qualifierString?: pulumi.Input<string>;
        /**
         * The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON", Default type is "BYTES". 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.
         */
        type?: pulumi.Input<string>;
    }

    export interface TableExternalDataConfigurationCsvOptions {
        /**
         * Indicates if BigQuery should accept rows
         * that are missing trailing optional columns.
         */
        allowJaggedRows?: pulumi.Input<boolean>;
        /**
         * Indicates if BigQuery should allow
         * quoted data sections that contain newline characters in a CSV file.
         * The default value is false.
         */
        allowQuotedNewlines?: pulumi.Input<boolean>;
        /**
         * The character encoding of the data. The supported
         * values are UTF-8 or ISO-8859-1.
         */
        encoding?: pulumi.Input<string>;
        /**
         * The separator for fields in a CSV file.
         */
        fieldDelimiter?: pulumi.Input<string>;
        /**
         * The value that is used to quote data sections in a
         * CSV file. If your data does not contain quoted sections, set the
         * property value to an empty string. If your data contains quoted newline
         * characters, you must also set the `allowQuotedNewlines` property to true.
         * The API-side default is `"`, specified in the provider escaped as `\"`. Due to
         * limitations with default values, this value is required to be
         * explicitly set.
         */
        quote: pulumi.Input<string>;
        /**
         * The number of rows at the top of a CSV
         * file that BigQuery will skip when reading the data.
         */
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        /**
         * Range of a sheet to query from. Only used when
         * non-empty. At least one of `range` or `skipLeadingRows` must be set.
         * Typical format: "sheet_name!top_left_cell_id:bottom_right_cell_id"
         * For example: "sheet1!A1:B20"
         */
        range?: pulumi.Input<string>;
        /**
         * The number of rows at the top of the sheet
         * that BigQuery will skip when reading the data. At least one of `range` or
         * `skipLeadingRows` must be set.
         */
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableExternalDataConfigurationHivePartitioningOptions {
        /**
         * When set, what mode of hive partitioning to use when
         * reading data. The following modes are supported.
         * * AUTO: automatically infer partition key name(s) and type(s).
         * * STRINGS: automatically infer partition key name(s). All types are
         * Not all storage formats support hive partitioning. Requesting hive
         * partitioning on an unsupported format will lead to an error.
         * Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
         * * CUSTOM: when set to `CUSTOM`, you must encode the partition key schema within the `sourceUriPrefix` by setting `sourceUriPrefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
         */
        mode?: pulumi.Input<string>;
        /**
         * If set to true, queries over this table
         * require a partition filter that can be used for partition elimination to be
         * specified.
         */
        requirePartitionFilter?: pulumi.Input<boolean>;
        /**
         * When hive partition detection is requested,
         * a common for all source uris must be required. The prefix must end immediately
         * before the partition key encoding begins. For example, consider files following
         * this data layout. `gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro`
         * `gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro` When hive
         * partitioning is requested with either AUTO or STRINGS detection, the common prefix
         * can be either of `gs://bucket/path_to_table` or `gs://bucket/path_to_table/`.
         * Note that when `mode` is set to `CUSTOM`, you must encode the partition key schema within the `sourceUriPrefix` by setting `sourceUriPrefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
         */
        sourceUriPrefix?: pulumi.Input<string>;
    }

    export interface TableExternalDataConfigurationJsonOptions {
        /**
         * The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
         */
        encoding?: pulumi.Input<string>;
    }

    export interface TableExternalDataConfigurationParquetOptions {
        /**
         * Indicates whether to use schema inference specifically for Parquet LIST logical type.
         */
        enableListInference?: pulumi.Input<boolean>;
        /**
         * Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
         */
        enumAsString?: pulumi.Input<boolean>;
    }

    export interface TableMaterializedView {
        /**
         * Allow non incremental materialized view definition.
         * The default value is false.
         */
        allowNonIncrementalDefinition?: pulumi.Input<boolean>;
        /**
         * Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
         * The default value is true.
         */
        enableRefresh?: pulumi.Input<boolean>;
        /**
         * A query whose result is persisted.
         */
        query: pulumi.Input<string>;
        /**
         * The maximum frequency at which this materialized view will be refreshed.
         * The default value is 1800000
         */
        refreshIntervalMs?: pulumi.Input<number>;
    }

    export interface TableRangePartitioning {
        /**
         * The field used to determine how to create a range-based
         * partition.
         */
        field: pulumi.Input<string>;
        /**
         * Information required to partition based on ranges.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.bigquery.TableRangePartitioningRange>;
    }

    export interface TableRangePartitioningRange {
        /**
         * End of the range partitioning, exclusive.
         */
        end: pulumi.Input<number>;
        /**
         * The width of each range within the partition.
         */
        interval: pulumi.Input<number>;
        /**
         * Start of the range partitioning, inclusive.
         */
        start: pulumi.Input<number>;
    }

    export interface TableSchemaForeignTypeInfo {
        /**
         * Specifies the system which defines the foreign data
         * type.
         */
        typeSystem: pulumi.Input<string>;
    }

    export interface TableTableConstraints {
        /**
         * Present only if the table has a foreign key.
         * The foreign key is not enforced.
         * Structure is documented below.
         */
        foreignKeys?: pulumi.Input<pulumi.Input<inputs.bigquery.TableTableConstraintsForeignKey>[]>;
        /**
         * Represents the primary key constraint
         * on a table's columns. Present only if the table has a primary key.
         * The primary key is not enforced.
         * Structure is documented below.
         */
        primaryKey?: pulumi.Input<inputs.bigquery.TableTableConstraintsPrimaryKey>;
    }

    export interface TableTableConstraintsForeignKey {
        /**
         * The pair of the foreign key column and primary key column.
         * Structure is documented below.
         */
        columnReferences: pulumi.Input<inputs.bigquery.TableTableConstraintsForeignKeyColumnReferences>;
        /**
         * Set only if the foreign key constraint is named.
         */
        name?: pulumi.Input<string>;
        /**
         * The table that holds the primary key
         * and is referenced by this foreign key.
         * Structure is documented below.
         */
        referencedTable: pulumi.Input<inputs.bigquery.TableTableConstraintsForeignKeyReferencedTable>;
    }

    export interface TableTableConstraintsForeignKeyColumnReferences {
        /**
         * The column in the primary key that are
         * referenced by the referencingColumn
         */
        referencedColumn: pulumi.Input<string>;
        /**
         * The column that composes the foreign key.
         */
        referencingColumn: pulumi.Input<string>;
    }

    export interface TableTableConstraintsForeignKeyReferencedTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The ID of the table. The ID must contain only
         * letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
         * length is 1,024 characters. Certain operations allow suffixing of
         * the table ID with a partition decorator, such as
         * sample_table$20190123.
         */
        tableId: pulumi.Input<string>;
    }

    export interface TableTableConstraintsPrimaryKey {
        /**
         * The columns that are composed of the primary key constraint.
         */
        columns: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableTableReplicationInfo {
        /**
         * The interval at which the source
         * materialized view is polled for updates. The default is 300000.
         */
        replicationIntervalMs?: pulumi.Input<number>;
        /**
         * The ID of the source dataset.
         */
        sourceDatasetId: pulumi.Input<string>;
        /**
         * The ID of the source project.
         */
        sourceProjectId: pulumi.Input<string>;
        /**
         * The ID of the source materialized view.
         */
        sourceTableId: pulumi.Input<string>;
    }

    export interface TableTimePartitioning {
        /**
         * Number of milliseconds for which to keep the
         * storage for a partition.
         */
        expirationMs?: pulumi.Input<number>;
        /**
         * The field used to determine how to create a time-based
         * partition. If time-based partitioning is enabled without this value, the
         * table is partitioned based on the load time.
         */
        field?: pulumi.Input<string>;
        /**
         * If set to true, queries over this table
         * require a partition filter that can be used for partition elimination to be
         * specified. `requirePartitionFilter` is deprecated and will be removed in
         * a future major release. Use the top level field with the same name instead.
         *
         * @deprecated This field is deprecated and will be removed in a future major release; please use the top level field with the same name instead.
         */
        requirePartitionFilter?: pulumi.Input<boolean>;
        /**
         * The supported types are DAY, HOUR, MONTH, and YEAR,
         * which will generate one partition per day, hour, month, and year, respectively.
         */
        type: pulumi.Input<string>;
    }

    export interface TableView {
        /**
         * A query that BigQuery executes when the view is referenced.
         */
        query: pulumi.Input<string>;
        /**
         * Specifies whether to use BigQuery's legacy SQL for this view.
         * The default value is true. If set to false, the view will use BigQuery's standard SQL.
         */
        useLegacySql?: pulumi.Input<boolean>;
    }
}

export namespace bigqueryanalyticshub {
    export interface DataExchangeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DataExchangeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DataExchangeSharingEnvironmentConfig {
        /**
         * Data Clean Room (DCR), used for privacy-safe and secured data sharing.
         */
        dcrExchangeConfig?: pulumi.Input<inputs.bigqueryanalyticshub.DataExchangeSharingEnvironmentConfigDcrExchangeConfig>;
        /**
         * Default Analytics Hub data exchange, used for secured data sharing.
         */
        defaultExchangeConfig?: pulumi.Input<inputs.bigqueryanalyticshub.DataExchangeSharingEnvironmentConfigDefaultExchangeConfig>;
    }

    export interface DataExchangeSharingEnvironmentConfigDcrExchangeConfig {
    }

    export interface DataExchangeSharingEnvironmentConfigDefaultExchangeConfig {
    }

    export interface ListingBigqueryDataset {
        /**
         * Resource name of the dataset source for this listing. e.g. projects/myproject/datasets/123
         */
        dataset: pulumi.Input<string>;
        /**
         * Resource in this dataset that is selectively shared. This field is required for data clean room exchanges.
         * Structure is documented below.
         */
        selectedResources?: pulumi.Input<pulumi.Input<inputs.bigqueryanalyticshub.ListingBigqueryDatasetSelectedResource>[]>;
    }

    export interface ListingBigqueryDatasetSelectedResource {
        /**
         * Format: For table: projects/{projectId}/datasets/{datasetId}/tables/{tableId} Example:"projects/test_project/datasets/test_dataset/tables/test_table"
         *
         * - - -
         */
        table?: pulumi.Input<string>;
    }

    export interface ListingDataProvider {
        /**
         * Name of the data provider.
         */
        name: pulumi.Input<string>;
        /**
         * Email or URL of the data provider.
         */
        primaryContact?: pulumi.Input<string>;
    }

    export interface ListingIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ListingIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ListingPublisher {
        /**
         * Name of the listing publisher.
         */
        name: pulumi.Input<string>;
        /**
         * Email or URL of the listing publisher.
         */
        primaryContact?: pulumi.Input<string>;
    }

    export interface ListingRestrictedExportConfig {
        /**
         * If true, enable restricted export.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * If true, restrict direct table access(read api/tabledata.list) on linked table.
         */
        restrictDirectTableAccess?: pulumi.Input<boolean>;
        /**
         * If true, restrict export of query result derived from restricted linked dataset table.
         */
        restrictQueryResult?: pulumi.Input<boolean>;
    }

    export interface ListingSubscriptionDestinationDataset {
        /**
         * A reference that identifies the destination dataset.
         * Structure is documented below.
         */
        datasetReference: pulumi.Input<inputs.bigqueryanalyticshub.ListingSubscriptionDestinationDatasetDatasetReference>;
        /**
         * A user-friendly description of the dataset.
         */
        description?: pulumi.Input<string>;
        /**
         * A descriptive name for the dataset.
         */
        friendlyName?: pulumi.Input<string>;
        /**
         * The labels associated with this dataset. You can use these to
         * organize and group your datasets.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The geographic location where the dataset should reside.
         * See https://cloud.google.com/bigquery/docs/locations for supported locations.
         */
        location: pulumi.Input<string>;
    }

    export interface ListingSubscriptionDestinationDatasetDatasetReference {
        /**
         * A unique ID for this dataset, without the project name. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this dataset.
         *
         * - - -
         */
        projectId: pulumi.Input<string>;
    }

    export interface ListingSubscriptionLinkedDatasetMap {
        /**
         * (Output)
         * Output only. Name of the linked dataset, e.g. projects/subscriberproject/datasets/linkedDataset
         */
        linkedDataset?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Listing for which linked resource is created.
         */
        listing?: pulumi.Input<string>;
        /**
         * (Required) The identifier for this object. Format specified above.
         */
        resourceName: pulumi.Input<string>;
    }

    export interface ListingSubscriptionLinkedResource {
        /**
         * (Output)
         * Output only. Name of the linked dataset, e.g. projects/subscriberproject/datasets/linkedDataset
         */
        linkedDataset?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Listing for which linked resource is created.
         */
        listing?: pulumi.Input<string>;
    }
}

export namespace bigquerydatapolicy {
    export interface DataPolicyDataMaskingPolicy {
        /**
         * The available masking rules. Learn more here: https://cloud.google.com/bigquery/docs/column-data-masking-intro#masking_options.
         * Possible values are: `SHA256`, `ALWAYS_NULL`, `DEFAULT_MASKING_VALUE`, `LAST_FOUR_CHARACTERS`, `FIRST_FOUR_CHARACTERS`, `EMAIL_MASK`, `DATE_YEAR_MASK`.
         */
        predefinedExpression?: pulumi.Input<string>;
        /**
         * The name of the BigQuery routine that contains the custom masking routine, in the format of projects/{projectNumber}/datasets/{dataset_id}/routines/{routine_id}.
         */
        routine?: pulumi.Input<string>;
    }

    export interface DataPolicyIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DataPolicyIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace bigtable {
    export interface AuthorizedViewSubsetView {
        /**
         * A group of column family subsets to be included in the authorized view. This can be specified multiple times. Structure is documented below.
         *
         * -----
         */
        familySubsets?: pulumi.Input<pulumi.Input<inputs.bigtable.AuthorizedViewSubsetViewFamilySubset>[]>;
        /**
         * A list of Base64-encoded row prefixes to be included in the authorized view. To provide access to all rows, include the empty string as a prefix ("").
         */
        rowPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthorizedViewSubsetViewFamilySubset {
        /**
         * Name of the column family to be included in the authorized view. The specified column family must exist in the parent table of this authorized view.
         */
        familyName: pulumi.Input<string>;
        /**
         * A list of Base64-encoded prefixes for qualifiers of the column family to be included in the authorized view.
         * Every qualifier starting with one of these prefixes is included in the authorized view. To provide access to all qualifiers, include the empty string as a prefix ("").
         */
        qualifierPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of Base64-encoded individual exact column qualifiers of the column family to be included in the authorized view.
         */
        qualifiers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         *
         * @deprecated Deprecated in favor of duration
         */
        days?: pulumi.Input<number>;
        /**
         * Duration before applying GC policy (ex. "8h"). This is required when `days` isn't set
         *
         * -----
         */
        duration?: pulumi.Input<string>;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         *
         * -----
         * `gcRules` include 2 fields:
         */
        number: pulumi.Input<number>;
    }

    export interface InstanceCluster {
        /**
         * [Autoscaling](https://cloud.google.com/bigtable/docs/autoscaling#parameters) config for the cluster, contains the following arguments:
         */
        autoscalingConfig?: pulumi.Input<inputs.bigtable.InstanceClusterAutoscalingConfig>;
        /**
         * The ID of the Cloud Bigtable cluster. Must be 6-30 characters and must only contain hyphens, lowercase letters and numbers.
         */
        clusterId: pulumi.Input<string>;
        /**
         * Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * The node scaling factor for this cluster. One of `"NodeScalingFactor1X"` or `"NodeScalingFactor2X"`. Defaults to `"NodeScalingFactor1X"`. If `"NodeScalingFactor2X"` is specified, then `numNodes`, `minNodes`, and `maxNodes` would need to be specified in increments of 2. This value cannot be updated after the cluster is created.
         *
         * > **Note**: Removing the field entirely from the config will cause the provider to default to the backend value.
         *
         * !> **Warning**: Modifying this field will cause the provider to delete/recreate the entire resource.
         *
         * !> **Warning:** Modifying the `storageType`, `zone` or `kmsKeyName` of an existing cluster (by
         * `clusterId`) will cause the provider to delete/recreate the entire
         * `gcp.bigtable.Instance` resource. If these values are changing, use a new
         * `clusterId`.
         */
        nodeScalingFactor?: pulumi.Input<string>;
        /**
         * The number of nodes in the cluster.
         * If no value is set, Cloud Bigtable automatically allocates nodes based on your data footprint and optimized for 50% storage utilization.
         */
        numNodes?: pulumi.Input<number>;
        /**
         * describes the current state of the cluster.
         */
        state?: pulumi.Input<string>;
        /**
         * The storage type to use. One of `"SSD"` or
         * `"HDD"`. Defaults to `"SSD"`.
         */
        storageType?: pulumi.Input<string>;
        /**
         * The zone to create the Cloud Bigtable cluster in. If it not
         * specified, the provider zone is used. Each cluster must have a different zone in the same region. Zones that support
         * Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
         */
        zone?: pulumi.Input<string>;
    }

    export interface InstanceClusterAutoscalingConfig {
        /**
         * The target CPU utilization for autoscaling, in percentage. Must be between 10 and 80.
         */
        cpuTarget: pulumi.Input<number>;
        /**
         * The maximum number of nodes for autoscaling.
         */
        maxNodes: pulumi.Input<number>;
        /**
         * The minimum number of nodes for autoscaling.
         */
        minNodes: pulumi.Input<number>;
        /**
         * The target storage utilization for autoscaling, in GB, for each node in a cluster. This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD cluster and between 8192 (8TiB) and 16384 (16 TiB) for an HDD cluster. If not set, whatever is already set for the cluster will not change, or if the cluster is just being created, it will use the default value of 2560 for SSD clusters and 8192 for HDD clusters.
         *
         * !> **Warning**: Only one of `autoscalingConfig` or `numNodes` should be set for a cluster. If both are set, `numNodes` is ignored. If none is set, autoscaling will be disabled and sized to the current node count.
         */
        storageTarget?: pulumi.Input<number>;
    }

    export interface InstanceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * For `gcp.bigtable.InstanceIamPolicy` only:
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * For `gcp.bigtable.InstanceIamPolicy` only:
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TableAutomatedBackupPolicy {
        /**
         * How frequently automated backups should occur.
         */
        frequency?: pulumi.Input<string>;
        /**
         * How long the automated backups should be retained.
         */
        retentionPeriod?: pulumi.Input<string>;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: pulumi.Input<string>;
        /**
         * The type of the column family.
         */
        type?: pulumi.Input<string>;
    }

    export interface TableIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TableIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AccountIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BudgetAllUpdatesRule {
        /**
         * Boolean. When set to true, disables default notifications sent
         * when a threshold is exceeded. Default recipients are
         * those with Billing Account Administrators and Billing
         * Account Users IAM roles for the target account.
         */
        disableDefaultIamRecipients?: pulumi.Input<boolean>;
        /**
         * When set to true, and when the budget has a single project configured,
         * notifications will be sent to project level recipients of that project.
         * This field will be ignored if the budget has multiple or no project configured.
         * Currently, project level recipients are the users with Owner role on a cloud project.
         */
        enableProjectLevelRecipients?: pulumi.Input<boolean>;
        /**
         * The full resource name of a monitoring notification
         * channel in the form
         * projects/{project_id}/notificationChannels/{channel_id}.
         * A maximum of 5 channels are allowed.
         */
        monitoringNotificationChannels?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the Cloud Pub/Sub topic where budget related
         * messages will be published, in the form
         * projects/{project_id}/topics/{topic_id}. Updates are sent
         * at regular intervals to the topic.
         */
        pubsubTopic?: pulumi.Input<string>;
        /**
         * The schema version of the notification. Only "1.0" is
         * accepted. It represents the JSON schema as defined in
         * https://cloud.google.com/billing/docs/how-to/budgets#notification_format.
         */
        schemaVersion?: pulumi.Input<string>;
    }

    export interface BudgetAmount {
        /**
         * Configures a budget amount that is automatically set to 100% of
         * last period's spend.
         * Boolean. Set value to true to use. Do not set to false, instead
         * use the `specifiedAmount` block.
         */
        lastPeriodAmount?: pulumi.Input<boolean>;
        /**
         * A specified amount to use as the budget. currencyCode is
         * optional. If specified, it must match the currency of the
         * billing account. The currencyCode is provided on output.
         * Structure is documented below.
         */
        specifiedAmount?: pulumi.Input<inputs.billing.BudgetAmountSpecifiedAmount>;
    }

    export interface BudgetAmountSpecifiedAmount {
        /**
         * The 3-letter currency code defined in ISO 4217.
         */
        currencyCode?: pulumi.Input<string>;
        /**
         * Number of nano (10^-9) units of the amount.
         * The value must be between -999,999,999 and +999,999,999
         * inclusive. If units is positive, nanos must be positive or
         * zero. If units is zero, nanos can be positive, zero, or
         * negative. If units is negative, nanos must be negative or
         * zero. For example $-1.75 is represented as units=-1 and
         * nanos=-750,000,000.
         *
         * - - -
         */
        nanos?: pulumi.Input<number>;
        /**
         * The whole units of the amount. For example if currencyCode
         * is "USD", then 1 unit is one US dollar.
         */
        units?: pulumi.Input<string>;
    }

    export interface BudgetBudgetFilter {
        /**
         * A CalendarPeriod represents the abstract concept of a recurring time period that has a
         * canonical start. Grammatically, "the start of the current CalendarPeriod".
         * All calendar times begin at 12 AM US and Canadian Pacific Time (UTC-8).
         * Exactly one of `calendarPeriod`, `customPeriod` must be provided.
         * Possible values are: `MONTH`, `QUARTER`, `YEAR`, `CALENDAR_PERIOD_UNSPECIFIED`.
         */
        calendarPeriod?: pulumi.Input<string>;
        /**
         * Optional. If creditTypesTreatment is INCLUDE_SPECIFIED_CREDITS,
         * this is a list of credit types to be subtracted from gross cost to determine the spend for threshold calculations. See a list of acceptable credit type values.
         * If creditTypesTreatment is not INCLUDE_SPECIFIED_CREDITS, this field must be empty.
         * **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
         */
        creditTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how credits should be treated when determining spend
         * for threshold calculations.
         * Default value is `INCLUDE_ALL_CREDITS`.
         * Possible values are: `INCLUDE_ALL_CREDITS`, `EXCLUDE_ALL_CREDITS`, `INCLUDE_SPECIFIED_CREDITS`.
         */
        creditTypesTreatment?: pulumi.Input<string>;
        /**
         * Specifies to track usage from any start date (required) to any end date (optional).
         * This time period is static, it does not recur.
         * Exactly one of `calendarPeriod`, `customPeriod` must be provided.
         * Structure is documented below.
         */
        customPeriod?: pulumi.Input<inputs.billing.BudgetBudgetFilterCustomPeriod>;
        /**
         * A single label and value pair specifying that usage from only
         * this set of labeled resources should be included in the budget.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A set of projects of the form projects/{project_number},
         * specifying that usage from only this set of projects should be
         * included in the budget. If omitted, the report will include
         * all usage for the billing account, regardless of which project
         * the usage occurred on.
         */
        projects?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A set of folder and organization names of the form folders/{folderId} or organizations/{organizationId},
         * specifying that usage from only this set of folders and organizations should be included in the budget.
         * If omitted, the budget includes all usage that the billing account pays for. If the folder or organization
         * contains projects that are paid for by a different Cloud Billing account, the budget doesn't apply to those projects.
         */
        resourceAncestors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A set of services of the form services/{service_id},
         * specifying that usage from only this set of services should be
         * included in the budget. If omitted, the report will include
         * usage for all the services. The service names are available
         * through the Catalog API:
         * https://cloud.google.com/billing/v1/how-tos/catalog-api.
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A set of subaccounts of the form billingAccounts/{account_id},
         * specifying that usage from only this set of subaccounts should
         * be included in the budget. If a subaccount is set to the name of
         * the parent account, usage from the parent account will be included.
         * If the field is omitted, the report will include usage from the parent
         * account and all subaccounts, if they exist.
         * **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
         */
        subaccounts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BudgetBudgetFilterCustomPeriod {
        /**
         * Optional. The end date of the time period. Budgets with elapsed end date won't be processed.
         * If unset, specifies to track all usage incurred since the startDate.
         * Structure is documented below.
         */
        endDate?: pulumi.Input<inputs.billing.BudgetBudgetFilterCustomPeriodEndDate>;
        /**
         * A start date is required. The start date must be after January 1, 2017.
         * Structure is documented below.
         */
        startDate: pulumi.Input<inputs.billing.BudgetBudgetFilterCustomPeriodStartDate>;
    }

    export interface BudgetBudgetFilterCustomPeriodEndDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface BudgetBudgetFilterCustomPeriodStartDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface BudgetThresholdRule {
        /**
         * The type of basis used to determine if spend has passed
         * the threshold.
         * Default value is `CURRENT_SPEND`.
         * Possible values are: `CURRENT_SPEND`, `FORECASTED_SPEND`.
         */
        spendBasis?: pulumi.Input<string>;
        /**
         * Send an alert when this threshold is exceeded. This is a
         * 1.0-based percentage, so 0.5 = 50%. Must be >= 0.
         */
        thresholdPercent: pulumi.Input<number>;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        /**
         * (Output)
         * This field will contain the service account email address that
         * this Attestor will use as the principal when querying Container
         * Analysis. Attestor administrators must grant this service account
         * the IAM role needed to read attestations from the noteReference in
         * Container Analysis (containeranalysis.notes.occurrences.viewer).
         * This email address is fixed for the lifetime of the Attestor, but
         * callers should not make any other assumptions about the service
         * account email; future versions may use an email based on a
         * different naming pattern.
         */
        delegationServiceAccountEmail?: pulumi.Input<string>;
        /**
         * The resource name of a ATTESTATION_AUTHORITY Note, created by the
         * user. If the Note is in a different project from the Attestor, it
         * should be specified in the format `projects/*&#47;notes/*` (or the legacy
         * `providers/*&#47;notes/*`). This field may not be updated.
         * An attestation by this attestor is stored as a Container Analysis
         * ATTESTATION_AUTHORITY Occurrence that names a container image
         * and that links to this Note.
         */
        noteReference: pulumi.Input<string>;
        /**
         * Public keys that verify attestations signed by this attestor. This
         * field may be updated.
         * If this field is non-empty, one of the specified public keys must
         * verify that an attestation was signed by this attestor for the
         * image specified in the admission request.
         * If this field is empty, this attestor always returns that no valid
         * attestations exist.
         * Structure is documented below.
         */
        publicKeys?: pulumi.Input<pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey>[]>;
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        /**
         * ASCII-armored representation of a PGP public key, as the
         * entire output by the command
         * `gpg --export --armor foo@example.com` (either LF or CRLF
         * line endings). When using this field, id should be left
         * blank. The BinAuthz API handlers will calculate the ID
         * and fill it in automatically. BinAuthz computes this ID
         * as the OpenPGP RFC4880 V4 fingerprint, represented as
         * upper-case hex. If id is provided by the caller, it will
         * be overwritten by the API-calculated ID.
         */
        asciiArmoredPgpPublicKey?: pulumi.Input<string>;
        /**
         * A descriptive comment. This field may be updated.
         */
        comment?: pulumi.Input<string>;
        /**
         * The ID of this public key. Signatures verified by BinAuthz
         * must include the ID of the public key that can be used to
         * verify them, and that ID must match the contents of this
         * field exactly. Additional restrictions on this field can
         * be imposed based on which public key type is encapsulated.
         * See the documentation on publicKey cases below for details.
         */
        id?: pulumi.Input<string>;
        /**
         * A raw PKIX SubjectPublicKeyInfo format public key.
         * NOTE: id may be explicitly provided by the caller when using this
         * type of public key, but it MUST be a valid RFC3986 URI. If id is left
         * blank, a default one will be computed based on the digest of the DER
         * encoding of the public key.
         * Structure is documented below.
         */
        pkixPublicKey?: pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey>;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        /**
         * A PEM-encoded public key, as described in
         * `https://tools.ietf.org/html/rfc7468#section-13`
         */
        publicKeyPem?: pulumi.Input<string>;
        /**
         * The signature algorithm used to verify a message against
         * a signature using this key. These signature algorithm must
         * match the structure and any object identifiers encoded in
         * publicKeyPem (i.e. this algorithm must match that of the
         * public key).
         *
         * - - -
         */
        signatureAlgorithm?: pulumi.Input<string>;
    }

    export interface AttestorIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AttestorIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface PolicyAdmissionWhitelistPattern {
        /**
         * An image name pattern to whitelist, in the form
         * `registry/path/to/image`. This supports a trailing * as a
         * wildcard, but this is allowed only in text after the registry/
         * part.
         */
        namePattern: pulumi.Input<string>;
    }

    export interface PolicyClusterAdmissionRule {
        /**
         * The identifier for this object. Format specified above.
         */
        cluster: pulumi.Input<string>;
        /**
         * The action when a pod creation is denied by the admission rule.
         * Possible values are: `ENFORCED_BLOCK_AND_AUDIT_LOG`, `DRYRUN_AUDIT_LOG_ONLY`.
         */
        enforcementMode: pulumi.Input<string>;
        /**
         * How this admission rule will be evaluated.
         * Possible values are: `ALWAYS_ALLOW`, `REQUIRE_ATTESTATION`, `ALWAYS_DENY`.
         */
        evaluationMode: pulumi.Input<string>;
        /**
         * The resource names of the attestors that must attest to a
         * container image. If the attestor is in a different project from the
         * policy, it should be specified in the format `projects/*&#47;attestors/*`.
         * Each attestor must exist before a policy can reference it. To add an
         * attestor to a policy the principal issuing the policy change
         * request must be able to read the attestor resource.
         * Note: this field must be non-empty when the evaluationMode field
         * specifies REQUIRE_ATTESTATION, otherwise it must be empty.
         */
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyDefaultAdmissionRule {
        /**
         * The action when a pod creation is denied by the admission rule.
         * Possible values are: `ENFORCED_BLOCK_AND_AUDIT_LOG`, `DRYRUN_AUDIT_LOG_ONLY`.
         *
         * - - -
         */
        enforcementMode: pulumi.Input<string>;
        /**
         * How this admission rule will be evaluated.
         * Possible values are: `ALWAYS_ALLOW`, `REQUIRE_ATTESTATION`, `ALWAYS_DENY`.
         */
        evaluationMode: pulumi.Input<string>;
        /**
         * The resource names of the attestors that must attest to a
         * container image. If the attestor is in a different project from the
         * policy, it should be specified in the format `projects/*&#47;attestors/*`.
         * Each attestor must exist before a policy can reference it. To add an
         * attestor to a policy the principal issuing the policy change
         * request must be able to read the attestor resource.
         * Note: this field must be non-empty when the evaluationMode field
         * specifies REQUIRE_ATTESTATION, otherwise it must be empty.
         */
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace blockchainnodeengine {
    export interface BlockchainNodesConnectionInfo {
        /**
         * (Output)
         * The endpoint information through which to interact with a blockchain node.
         * Structure is documented below.
         */
        endpointInfos?: pulumi.Input<pulumi.Input<inputs.blockchainnodeengine.BlockchainNodesConnectionInfoEndpointInfo>[]>;
        /**
         * (Output)
         * A service attachment that exposes a node, and has the following format: projects/{project}/regions/{region}/serviceAttachments/{service_attachment_name}
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface BlockchainNodesConnectionInfoEndpointInfo {
        /**
         * (Output)
         * The assigned URL for the node JSON-RPC API endpoint.
         */
        jsonRpcApiEndpoint?: pulumi.Input<string>;
        /**
         * (Output)
         * The assigned URL for the node WebSockets API endpoint.
         */
        websocketsApiEndpoint?: pulumi.Input<string>;
    }

    export interface BlockchainNodesEthereumDetails {
        /**
         * (Output)
         * User-provided key-value pairs
         * Structure is documented below.
         */
        additionalEndpoints?: pulumi.Input<pulumi.Input<inputs.blockchainnodeengine.BlockchainNodesEthereumDetailsAdditionalEndpoint>[]>;
        /**
         * Enables JSON-RPC access to functions in the admin namespace. Defaults to false.
         */
        apiEnableAdmin?: pulumi.Input<boolean>;
        /**
         * Enables JSON-RPC access to functions in the debug namespace. Defaults to false.
         */
        apiEnableDebug?: pulumi.Input<boolean>;
        /**
         * The consensus client
         * Possible values are: `CONSENSUS_CLIENT_UNSPECIFIED`, `LIGHTHOUSE`.
         */
        consensusClient?: pulumi.Input<string>;
        /**
         * The execution client
         * Possible values are: `EXECUTION_CLIENT_UNSPECIFIED`, `GETH`, `ERIGON`.
         */
        executionClient?: pulumi.Input<string>;
        /**
         * User-provided key-value pairs
         * Structure is documented below.
         */
        gethDetails?: pulumi.Input<inputs.blockchainnodeengine.BlockchainNodesEthereumDetailsGethDetails>;
        /**
         * The Ethereum environment being accessed.
         * Possible values are: `MAINNET`, `TESTNET_GOERLI_PRATER`, `TESTNET_SEPOLIA`.
         */
        network?: pulumi.Input<string>;
        /**
         * The type of Ethereum node.
         * Possible values are: `LIGHT`, `FULL`, `ARCHIVE`.
         */
        nodeType?: pulumi.Input<string>;
        /**
         * Configuration for validator-related parameters on the beacon client, and for any managed validator client.
         * Structure is documented below.
         */
        validatorConfig?: pulumi.Input<inputs.blockchainnodeengine.BlockchainNodesEthereumDetailsValidatorConfig>;
    }

    export interface BlockchainNodesEthereumDetailsAdditionalEndpoint {
        /**
         * The assigned URL for the node's Beacon API endpoint.
         */
        beaconApiEndpoint?: pulumi.Input<string>;
        /**
         * The assigned URL for the node's Beacon Prometheus metrics endpoint.
         */
        beaconPrometheusMetricsApiEndpoint?: pulumi.Input<string>;
        /**
         * The assigned URL for the node's execution client's Prometheus metrics endpoint.
         */
        executionClientPrometheusMetricsApiEndpoint?: pulumi.Input<string>;
    }

    export interface BlockchainNodesEthereumDetailsGethDetails {
        /**
         * Blockchain garbage collection modes. Only applicable when NodeType is FULL or ARCHIVE.
         * Possible values are: `FULL`, `ARCHIVE`.
         *
         * <a name="nestedEthereumDetailsAdditionalEndpoints"></a>The `additionalEndpoints` block contains:
         */
        garbageCollectionMode?: pulumi.Input<string>;
    }

    export interface BlockchainNodesEthereumDetailsValidatorConfig {
        /**
         * URLs for MEV-relay services to use for block building. When set, a managed MEV-boost service is configured on the beacon client.
         */
        mevRelayUrls?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace certificateauthority {
    export interface AuthorityAccessUrl {
        /**
         * (Output)
         * The URL where this CertificateAuthority's CA certificate is published. This will only be
         * set for CAs that have been activated.
         */
        caCertificateAccessUrl?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL where this CertificateAuthority's CRLs are published. This will only be set for
         * CAs that have been activated.
         */
        crlAccessUrls?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthorityConfig {
        /**
         * Specifies some of the values in a certificate that are related to the subject.
         * Structure is documented below.
         */
        subjectConfig: pulumi.Input<inputs.certificateauthority.AuthorityConfigSubjectConfig>;
        /**
         * When specified this provides a custom SKI to be used in the certificate. This should only be used to maintain a SKI of an existing CA originally created outside CA service, which was not generated using method (1) described in RFC 5280 section 4.2.1.2..
         * Structure is documented below.
         */
        subjectKeyId?: pulumi.Input<inputs.certificateauthority.AuthorityConfigSubjectKeyId>;
        /**
         * Describes how some of the technical X.509 fields in a certificate should be populated.
         * Structure is documented below.
         */
        x509Config: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509Config>;
    }

    export interface AuthorityConfigSubjectConfig {
        /**
         * Contains distinguished name fields such as the location and organization.
         * Structure is documented below.
         */
        subject: pulumi.Input<inputs.certificateauthority.AuthorityConfigSubjectConfigSubject>;
        /**
         * The subject alternative name fields.
         * Structure is documented below.
         */
        subjectAltName?: pulumi.Input<inputs.certificateauthority.AuthorityConfigSubjectConfigSubjectAltName>;
    }

    export interface AuthorityConfigSubjectConfigSubject {
        /**
         * The common name of the distinguished name.
         */
        commonName: pulumi.Input<string>;
        /**
         * The country code of the subject.
         */
        countryCode?: pulumi.Input<string>;
        /**
         * The locality or city of the subject.
         */
        locality?: pulumi.Input<string>;
        /**
         * The organization of the subject.
         */
        organization?: pulumi.Input<string>;
        /**
         * The organizational unit of the subject.
         */
        organizationalUnit?: pulumi.Input<string>;
        /**
         * The postal code of the subject.
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The province, territory, or regional state of the subject.
         */
        province?: pulumi.Input<string>;
        /**
         * The street address of the subject.
         */
        streetAddress?: pulumi.Input<string>;
    }

    export interface AuthorityConfigSubjectConfigSubjectAltName {
        /**
         * Contains only valid, fully-qualified host names.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 2822 E-mail addresses.
         */
        emailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 3986 URIs.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthorityConfigSubjectKeyId {
        /**
         * The value of the KeyId in lowercase hexadecimal.
         *
         * <a name="nestedConfigX509Config"></a>The `x509Config` block supports:
         */
        keyId?: pulumi.Input<string>;
    }

    export interface AuthorityConfigX509Config {
        /**
         * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigAdditionalExtension>[]>;
        /**
         * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the
         * "Authority Information Access" extension in the certificate.
         */
        aiaOcspServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Describes values that are relevant in a CA certificate.
         */
        caOptions: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigCaOptions>;
        /**
         * Indicates the intended use for keys that correspond to a certificate.
         */
        keyUsage: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigKeyUsage>;
        /**
         * Describes the X.509 name constraints extension.
         */
        nameConstraints?: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigNameConstraints>;
        /**
         * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
         */
        policyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigPolicyId>[]>;
    }

    export interface AuthorityConfigX509ConfigAdditionalExtension {
        /**
         * Indicates whether or not this extension is critical (i.e., if the client does not know how to
         * handle this extension, the client should consider this to be an error).
         */
        critical: pulumi.Input<boolean>;
        /**
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        objectId: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigAdditionalExtensionObjectId>;
        /**
         * The value of this X.509 extension. A base64-encoded string.
         */
        value: pulumi.Input<string>;
    }

    export interface AuthorityConfigX509ConfigAdditionalExtensionObjectId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AuthorityConfigX509ConfigCaOptions {
        /**
         * When true, the "CA" in Basic Constraints extension will be set to true.
         */
        isCa: pulumi.Input<boolean>;
        /**
         * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of
         * subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. Setting the value to 0
         * requires setting `zeroMaxIssuerPathLength = true`.
         */
        maxIssuerPathLength?: pulumi.Input<number>;
        /**
         * When true, the "CA" in Basic Constraints extension will be set to false.
         * If both `isCa` and `nonCa` are unset, the extension will be omitted from the CA certificate.
         */
        nonCa?: pulumi.Input<boolean>;
        /**
         * When true, the "path length constraint" in Basic Constraints extension will be set to 0.
         * If both `maxIssuerPathLength` and `zeroMaxIssuerPathLength` are unset,
         * the max path length will be omitted from the CA certificate.
         */
        zeroMaxIssuerPathLength?: pulumi.Input<boolean>;
    }

    export interface AuthorityConfigX509ConfigKeyUsage {
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        baseKeyUsage: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsage>;
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        extendedKeyUsage: pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsage>;
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         * Structure is documented below.
         */
        unknownExtendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.AuthorityConfigX509ConfigKeyUsageUnknownExtendedKeyUsage>[]>;
    }

    export interface AuthorityConfigX509ConfigKeyUsageBaseKeyUsage {
        /**
         * The key may be used to sign certificates.
         */
        certSign?: pulumi.Input<boolean>;
        /**
         * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
         */
        contentCommitment?: pulumi.Input<boolean>;
        /**
         * The key may be used sign certificate revocation lists.
         */
        crlSign?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher data.
         */
        dataEncipherment?: pulumi.Input<boolean>;
        /**
         * The key may be used to decipher only.
         */
        decipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used for digital signatures.
         */
        digitalSignature?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher only.
         */
        encipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used in a key agreement protocol.
         */
        keyAgreement?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher other keys.
         */
        keyEncipherment?: pulumi.Input<boolean>;
    }

    export interface AuthorityConfigX509ConfigKeyUsageExtendedKeyUsage {
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
         */
        clientAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
         */
        codeSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
         */
        emailProtection?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
         */
        ocspSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
         */
        serverAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
         */
        timeStamping?: pulumi.Input<boolean>;
    }

    export interface AuthorityConfigX509ConfigKeyUsageUnknownExtendedKeyUsage {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AuthorityConfigX509ConfigNameConstraints {
        /**
         * Indicates whether or not the name constraints are marked critical.
         */
        critical: pulumi.Input<boolean>;
        /**
         * Contains excluded DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        excludedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        excludedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        excludedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        excludedUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains permitted DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        permittedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        permittedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        permittedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        permittedUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthorityConfigX509ConfigPolicyId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AuthorityKeySpec {
        /**
         * The algorithm to use for creating a managed Cloud KMS key for a for a simplified
         * experience. All managed keys will be have their ProtectionLevel as HSM.
         * Possible values are: `SIGN_HASH_ALGORITHM_UNSPECIFIED`, `RSA_PSS_2048_SHA256`, `RSA_PSS_3072_SHA256`, `RSA_PSS_4096_SHA256`, `RSA_PKCS1_2048_SHA256`, `RSA_PKCS1_3072_SHA256`, `RSA_PKCS1_4096_SHA256`, `EC_P256_SHA256`, `EC_P384_SHA384`.
         *
         * - - -
         */
        algorithm?: pulumi.Input<string>;
        /**
         * The resource name for an existing Cloud KMS CryptoKeyVersion in the format
         * `projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*&#47;cryptoKeyVersions/*`.
         */
        cloudKmsKeyVersion?: pulumi.Input<string>;
    }

    export interface AuthoritySubordinateConfig {
        /**
         * This can refer to a CertificateAuthority that was used to create a
         * subordinate CertificateAuthority. This field is used for information
         * and usability purposes only. The resource name is in the format
         * `projects/*&#47;locations/*&#47;caPools/*&#47;certificateAuthorities/*`.
         */
        certificateAuthority?: pulumi.Input<string>;
        /**
         * Contains the PEM certificate chain for the issuers of this CertificateAuthority,
         * but not pem certificate for this CA itself.
         * Structure is documented below.
         */
        pemIssuerChain?: pulumi.Input<inputs.certificateauthority.AuthoritySubordinateConfigPemIssuerChain>;
    }

    export interface AuthoritySubordinateConfigPemIssuerChain {
        /**
         * Expected to be in leaf-to-root order according to RFC 5246.
         */
        pemCertificates?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthorityUserDefinedAccessUrls {
        /**
         * A list of URLs where this CertificateAuthority's CA certificate is published that is specified by users.
         */
        aiaIssuingCertificateUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of URLs where this CertificateAuthority's CRLs are published that is specified by users.
         */
        crlAccessUrls?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CaPoolIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CaPoolIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CaPoolIssuancePolicy {
        /**
         * IssuanceModes specifies the allowed ways in which Certificates may be requested from this CaPool.
         * Structure is documented below.
         */
        allowedIssuanceModes?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyAllowedIssuanceModes>;
        /**
         * If any AllowedKeyType is specified, then the certificate request's public key must match one of the key types listed here.
         * Otherwise, any key may be used.
         * Structure is documented below.
         */
        allowedKeyTypes?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyAllowedKeyType>[]>;
        /**
         * The duration to backdate all certificates issued from this CaPool. If not set, the
         * certificates will be issued with a notBeforeTime of the issuance time (i.e. the current
         * time). If set, the certificates will be issued with a notBeforeTime of the issuance
         * time minus the backdate_duration. The notAfterTime will be adjusted to preserve the
         * requested lifetime. The backdateDuration must be less than or equal to 48 hours.
         */
        backdateDuration?: pulumi.Input<string>;
        /**
         * A set of X.509 values that will be applied to all certificates issued through this CaPool. If a certificate request
         * includes conflicting values for the same properties, they will be overwritten by the values defined here. If a certificate
         * request uses a CertificateTemplate that defines conflicting predefinedValues for the same properties, the certificate
         * issuance request will fail.
         * Structure is documented below.
         */
        baselineValues?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValues>;
        /**
         * Describes constraints on identities that may appear in Certificates issued through this CaPool.
         * If this is omitted, then this CaPool will not add restrictions on a certificate's identity.
         * Structure is documented below.
         */
        identityConstraints?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyIdentityConstraints>;
        /**
         * The maximum lifetime allowed for issued Certificates. Note that if the issuing CertificateAuthority
         * expires before a Certificate's requested maximumLifetime, the effective lifetime will be explicitly truncated to match it.
         */
        maximumLifetime?: pulumi.Input<string>;
    }

    export interface CaPoolIssuancePolicyAllowedIssuanceModes {
        /**
         * When true, allows callers to create Certificates by specifying a CertificateConfig.
         */
        allowConfigBasedIssuance: pulumi.Input<boolean>;
        /**
         * When true, allows callers to create Certificates by specifying a CSR.
         */
        allowCsrBasedIssuance: pulumi.Input<boolean>;
    }

    export interface CaPoolIssuancePolicyAllowedKeyType {
        /**
         * Represents an allowed Elliptic Curve key type.
         * Structure is documented below.
         */
        ellipticCurve?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyAllowedKeyTypeEllipticCurve>;
        /**
         * Describes an RSA key that may be used in a Certificate issued from a CaPool.
         * Structure is documented below.
         */
        rsa?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyAllowedKeyTypeRsa>;
    }

    export interface CaPoolIssuancePolicyAllowedKeyTypeEllipticCurve {
        /**
         * The algorithm used.
         * Possible values are: `ECDSA_P256`, `ECDSA_P384`, `EDDSA_25519`.
         */
        signatureAlgorithm: pulumi.Input<string>;
    }

    export interface CaPoolIssuancePolicyAllowedKeyTypeRsa {
        /**
         * The maximum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the
         * service will not enforce an explicit upper bound on RSA modulus sizes.
         */
        maxModulusSize?: pulumi.Input<string>;
        /**
         * The minimum allowed RSA modulus size, in bits. If this is not set, or if set to zero, the
         * service-level min RSA modulus size will continue to apply.
         */
        minModulusSize?: pulumi.Input<string>;
    }

    export interface CaPoolIssuancePolicyBaselineValues {
        /**
         * Specifies an X.509 extension, which may be used in different parts of X.509 objects like certificates, CSRs, and CRLs.
         * Structure is documented below.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesAdditionalExtension>[]>;
        /**
         * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the
         * "Authority Information Access" extension in the certificate.
         */
        aiaOcspServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        caOptions: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesCaOptions>;
        /**
         * Indicates the intended use for keys that correspond to a certificate.
         * Structure is documented below.
         */
        keyUsage: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsage>;
        /**
         * Describes the X.509 name constraints extension.
         * Structure is documented below.
         */
        nameConstraints?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesNameConstraints>;
        /**
         * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
         * Structure is documented below.
         */
        policyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesPolicyId>[]>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesAdditionalExtension {
        /**
         * Indicates whether or not this extension is critical (i.e., if the client does not know how to
         * handle this extension, the client should consider this to be an error).
         */
        critical: pulumi.Input<boolean>;
        /**
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        objectId: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesAdditionalExtensionObjectId>;
        /**
         * The value of this X.509 extension. A base64-encoded string.
         */
        value: pulumi.Input<string>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesAdditionalExtensionObjectId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesCaOptions {
        /**
         * When true, the "CA" in Basic Constraints extension will be set to true.
         */
        isCa?: pulumi.Input<boolean>;
        /**
         * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of
         * subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
         */
        maxIssuerPathLength?: pulumi.Input<number>;
        /**
         * When true, the "CA" in Basic Constraints extension will be set to false.
         * If both `isCa` and `nonCa` are unset, the extension will be omitted from the CA certificate.
         */
        nonCa?: pulumi.Input<boolean>;
        /**
         * When true, the "path length constraint" in Basic Constraints extension will be set to 0.
         * if both `maxIssuerPathLength` and `zeroMaxIssuerPathLength` are unset,
         * the max path length will be omitted from the CA certificate.
         */
        zeroMaxIssuerPathLength?: pulumi.Input<boolean>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesKeyUsage {
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        baseKeyUsage: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage>;
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        extendedKeyUsage: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage>;
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         * Structure is documented below.
         */
        unknownExtendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsage>[]>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsage {
        /**
         * The key may be used to sign certificates.
         */
        certSign?: pulumi.Input<boolean>;
        /**
         * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
         */
        contentCommitment?: pulumi.Input<boolean>;
        /**
         * The key may be used sign certificate revocation lists.
         */
        crlSign?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher data.
         */
        dataEncipherment?: pulumi.Input<boolean>;
        /**
         * The key may be used to decipher only.
         */
        decipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used for digital signatures.
         */
        digitalSignature?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher only.
         */
        encipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used in a key agreement protocol.
         */
        keyAgreement?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher other keys.
         */
        keyEncipherment?: pulumi.Input<boolean>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsage {
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
         */
        clientAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
         */
        codeSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
         */
        emailProtection?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
         */
        ocspSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
         */
        serverAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
         */
        timeStamping?: pulumi.Input<boolean>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesKeyUsageUnknownExtendedKeyUsage {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesNameConstraints {
        /**
         * Indicates whether or not the name constraints are marked critical.
         */
        critical: pulumi.Input<boolean>;
        /**
         * Contains excluded DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        excludedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        excludedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        excludedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        excludedUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains permitted DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        permittedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        permittedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        permittedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        permittedUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CaPoolIssuancePolicyBaselineValuesPolicyId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CaPoolIssuancePolicyIdentityConstraints {
        /**
         * If this is set, the SubjectAltNames extension may be copied from a certificate request into the signed certificate.
         * Otherwise, the requested SubjectAltNames will be discarded.
         */
        allowSubjectAltNamesPassthrough: pulumi.Input<boolean>;
        /**
         * If this is set, the Subject field may be copied from a certificate request into the signed certificate.
         * Otherwise, the requested Subject will be discarded.
         */
        allowSubjectPassthrough: pulumi.Input<boolean>;
        /**
         * A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a
         * certificate is signed. To see the full allowed syntax and some examples,
         * see https://cloud.google.com/certificate-authority-service/docs/cel-guide
         * Structure is documented below.
         */
        celExpression?: pulumi.Input<inputs.certificateauthority.CaPoolIssuancePolicyIdentityConstraintsCelExpression>;
    }

    export interface CaPoolIssuancePolicyIdentityConstraintsCelExpression {
        /**
         * Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface CaPoolPublishingOptions {
        /**
         * Specifies the encoding format of each CertificateAuthority's CA
         * certificate and CRLs. If this is omitted, CA certificates and CRLs
         * will be published in PEM.
         * Possible values are: `PEM`, `DER`.
         */
        encodingFormat?: pulumi.Input<string>;
        /**
         * When true, publishes each CertificateAuthority's CA certificate and includes its URL in the "Authority Information Access"
         * X.509 extension in all issued Certificates. If this is false, the CA certificate will not be published and the corresponding
         * X.509 extension will not be written in issued certificates.
         */
        publishCaCert: pulumi.Input<boolean>;
        /**
         * When true, publishes each CertificateAuthority's CRL and includes its URL in the "CRL Distribution Points" X.509 extension
         * in all issued Certificates. If this is false, CRLs will not be published and the corresponding X.509 extension will not
         * be written in issued certificates. CRLs will expire 7 days from their creation. However, we will rebuild daily. CRLs are
         * also rebuilt shortly after a certificate is revoked.
         */
        publishCrl: pulumi.Input<boolean>;
    }

    export interface CertificateCertificateDescription {
        /**
         * (Output)
         * Describes lists of issuer CA certificate URLs that appear in the "Authority Information Access" extension in the certificate.
         */
        aiaIssuingCertificateUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Identifies the subjectKeyId of the parent certificate, per https://tools.ietf.org/html/rfc5280#section-4.2.1.1
         * Structure is documented below.
         */
        authorityKeyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionAuthorityKeyId>[]>;
        /**
         * (Output)
         * The hash of the x.509 certificate.
         * Structure is documented below.
         */
        certFingerprints?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionCertFingerprint>[]>;
        /**
         * (Output)
         * Describes a list of locations to obtain CRL information, i.e. the DistributionPoint.fullName described by https://tools.ietf.org/html/rfc5280#section-4.2.1.13
         */
        crlDistributionPoints?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * A PublicKey describes a public key.
         * Structure is documented below.
         */
        publicKeys?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionPublicKey>[]>;
        /**
         * (Output)
         * Describes some of the values in a certificate that are related to the subject and lifetime.
         * Structure is documented below.
         */
        subjectDescriptions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectDescription>[]>;
        /**
         * (Output)
         * Provides a means of identifiying certificates that contain a particular public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
         * Structure is documented below.
         */
        subjectKeyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectKeyId>[]>;
        /**
         * (Output)
         * A structured description of the issued X.509 certificate.
         * Structure is documented below.
         */
        x509Descriptions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509Description>[]>;
    }

    export interface CertificateCertificateDescriptionAuthorityKeyId {
        /**
         * (Output)
         * Optional. The value of this KeyId encoded in lowercase hexadecimal. This is most likely the 160 bit SHA-1 hash of the public key.
         */
        keyId?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionCertFingerprint {
        /**
         * (Output)
         * The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate.
         */
        sha256Hash?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionPublicKey {
        /**
         * The format of the public key. Currently, only PEM format is supported.
         * Possible values are: `KEY_TYPE_UNSPECIFIED`, `PEM`.
         */
        format?: pulumi.Input<string>;
        /**
         * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
         */
        key?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionSubjectDescription {
        /**
         * (Output)
         * The serial number encoded in lowercase hexadecimal.
         */
        hexSerialNumber?: pulumi.Input<string>;
        /**
         * The desired lifetime of the CA certificate. Used to create the "notBeforeTime" and
         * "notAfterTime" fields inside an X.509 certificate. A duration in seconds with up to nine
         * fractional digits, terminated by 's'. Example: "3.5s".
         */
        lifetime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time at which the certificate expires.
         */
        notAfterTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time at which the certificate becomes valid.
         */
        notBeforeTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The subject alternative name fields.
         * Structure is documented below.
         */
        subjectAltNames?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectDescriptionSubjectAltName>[]>;
        /**
         * (Output)
         * Contains distinguished name fields such as the location and organization.
         * Structure is documented below.
         */
        subjects?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectDescriptionSubject>[]>;
    }

    export interface CertificateCertificateDescriptionSubjectDescriptionSubject {
        /**
         * The common name of the distinguished name.
         */
        commonName?: pulumi.Input<string>;
        /**
         * The country code of the subject.
         */
        countryCode?: pulumi.Input<string>;
        /**
         * The locality or city of the subject.
         */
        locality?: pulumi.Input<string>;
        /**
         * The organization of the subject.
         */
        organization?: pulumi.Input<string>;
        /**
         * The organizational unit of the subject.
         */
        organizationalUnit?: pulumi.Input<string>;
        /**
         * The postal code of the subject.
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The province, territory, or regional state of the subject.
         */
        province?: pulumi.Input<string>;
        /**
         * The street address of the subject.
         */
        streetAddress?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionSubjectDescriptionSubjectAltName {
        /**
         * (Output)
         * Contains additional subject alternative name values.
         * Structure is documented below.
         */
        customSans?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectDescriptionSubjectAltNameCustomSan>[]>;
        /**
         * Contains only valid, fully-qualified host names.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 2822 E-mail addresses.
         */
        emailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 3986 URIs.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CertificateCertificateDescriptionSubjectDescriptionSubjectAltNameCustomSan {
        /**
         * (Output)
         * Indicates whether or not the name constraints are marked critical.
         */
        critical?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Describes how some of the technical fields in a certificate should be populated.
         * Structure is documented below.
         */
        obectIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionSubjectDescriptionSubjectAltNameCustomSanObectId>[]>;
        /**
         * The value of this X.509 extension. A base64-encoded string.
         */
        value?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionSubjectDescriptionSubjectAltNameCustomSanObectId {
        /**
         * (Output)
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateCertificateDescriptionSubjectKeyId {
        /**
         * The value of the KeyId in lowercase hexadecimal.
         */
        keyId?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionX509Description {
        /**
         * (Output)
         * Describes custom X.509 extensions.
         * Structure is documented below.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionAdditionalExtension>[]>;
        /**
         * (Output)
         * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the
         * "Authority Information Access" extension in the certificate.
         */
        aiaOcspServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        caOptions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionCaOption>[]>;
        /**
         * (Output)
         * Indicates the intended use for keys that correspond to a certificate.
         * Structure is documented below.
         */
        keyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionKeyUsage>[]>;
        /**
         * (Output)
         * Describes the X.509 name constraints extension.
         * Structure is documented below.
         */
        nameConstraints?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionNameConstraint>[]>;
        /**
         * (Output)
         * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
         * Structure is documented below.
         */
        policyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionPolicyId>[]>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionAdditionalExtension {
        /**
         * Indicates whether or not this extension is critical (i.e., if the client does not know how to
         * handle this extension, the client should consider this to be an error).
         */
        critical?: pulumi.Input<boolean>;
        /**
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        objectIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionAdditionalExtensionObjectId>[]>;
        /**
         * The value of this X.509 extension. A base64-encoded string.
         */
        value?: pulumi.Input<string>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionAdditionalExtensionObjectId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionCaOption {
        /**
         * When true, the "CA" in Basic Constraints extension will be set to true.
         */
        isCa?: pulumi.Input<boolean>;
        /**
         * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of
         * subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
         */
        maxIssuerPathLength?: pulumi.Input<number>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionKeyUsage {
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        baseKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionKeyUsageBaseKeyUsage>[]>;
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        extendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionKeyUsageExtendedKeyUsage>[]>;
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         * Structure is documented below.
         */
        unknownExtendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateCertificateDescriptionX509DescriptionKeyUsageUnknownExtendedKeyUsage>[]>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionKeyUsageBaseKeyUsage {
        /**
         * The key may be used to sign certificates.
         */
        certSign?: pulumi.Input<boolean>;
        /**
         * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
         */
        contentCommitment?: pulumi.Input<boolean>;
        /**
         * The key may be used sign certificate revocation lists.
         */
        crlSign?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher data.
         */
        dataEncipherment?: pulumi.Input<boolean>;
        /**
         * The key may be used to decipher only.
         */
        decipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used for digital signatures.
         */
        digitalSignature?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher only.
         */
        encipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used in a key agreement protocol.
         */
        keyAgreement?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher other keys.
         */
        keyEncipherment?: pulumi.Input<boolean>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionKeyUsageExtendedKeyUsage {
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
         */
        clientAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
         */
        codeSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
         */
        emailProtection?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
         */
        ocspSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
         */
        serverAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
         */
        timeStamping?: pulumi.Input<boolean>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionKeyUsageUnknownExtendedKeyUsage {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionNameConstraint {
        /**
         * Indicates whether or not the name constraints are marked critical.
         */
        critical?: pulumi.Input<boolean>;
        /**
         * Contains excluded DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        excludedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        excludedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        excludedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        excludedUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains permitted DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        permittedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        permittedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        permittedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        permittedUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CertificateCertificateDescriptionX509DescriptionPolicyId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateConfig {
        /**
         * A PublicKey describes a public key.
         * Structure is documented below.
         *
         *
         * <a name="nestedConfigX509Config"></a>The `x509Config` block supports:
         */
        publicKey: pulumi.Input<inputs.certificateauthority.CertificateConfigPublicKey>;
        /**
         * Specifies some of the values in a certificate that are related to the subject.
         * Structure is documented below.
         */
        subjectConfig: pulumi.Input<inputs.certificateauthority.CertificateConfigSubjectConfig>;
        /**
         * When specified this provides a custom SKI to be used in the certificate. This should only be used to maintain a SKI of an existing CA originally created outside CA service, which was not generated using method (1) described in RFC 5280 section 4.2.1.2..
         * Structure is documented below.
         */
        subjectKeyId?: pulumi.Input<inputs.certificateauthority.CertificateConfigSubjectKeyId>;
        /**
         * Describes how some of the technical X.509 fields in a certificate should be populated.
         * Structure is documented below.
         */
        x509Config: pulumi.Input<inputs.certificateauthority.CertificateConfigX509Config>;
    }

    export interface CertificateConfigPublicKey {
        /**
         * The format of the public key. Currently, only PEM format is supported.
         * Possible values are: `KEY_TYPE_UNSPECIFIED`, `PEM`.
         */
        format: pulumi.Input<string>;
        /**
         * Required. A public key. When this is specified in a request, the padding and encoding can be any of the options described by the respective 'KeyType' value. When this is generated by the service, it will always be an RFC 5280 SubjectPublicKeyInfo structure containing an algorithm identifier and a key. A base64-encoded string.
         */
        key?: pulumi.Input<string>;
    }

    export interface CertificateConfigSubjectConfig {
        /**
         * Contains distinguished name fields such as the location and organization.
         * Structure is documented below.
         */
        subject: pulumi.Input<inputs.certificateauthority.CertificateConfigSubjectConfigSubject>;
        /**
         * The subject alternative name fields.
         * Structure is documented below.
         */
        subjectAltName?: pulumi.Input<inputs.certificateauthority.CertificateConfigSubjectConfigSubjectAltName>;
    }

    export interface CertificateConfigSubjectConfigSubject {
        /**
         * The common name of the distinguished name.
         */
        commonName: pulumi.Input<string>;
        /**
         * The country code of the subject.
         */
        countryCode?: pulumi.Input<string>;
        /**
         * The locality or city of the subject.
         */
        locality?: pulumi.Input<string>;
        /**
         * The organization of the subject.
         */
        organization: pulumi.Input<string>;
        /**
         * The organizational unit of the subject.
         */
        organizationalUnit?: pulumi.Input<string>;
        /**
         * The postal code of the subject.
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The province, territory, or regional state of the subject.
         */
        province?: pulumi.Input<string>;
        /**
         * The street address of the subject.
         */
        streetAddress?: pulumi.Input<string>;
    }

    export interface CertificateConfigSubjectConfigSubjectAltName {
        /**
         * Contains only valid, fully-qualified host names.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 2822 E-mail addresses.
         */
        emailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains only valid RFC 3986 URIs.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CertificateConfigSubjectKeyId {
        /**
         * The value of the KeyId in lowercase hexadecimal.
         */
        keyId?: pulumi.Input<string>;
    }

    export interface CertificateConfigX509Config {
        /**
         * (Output)
         * Describes custom X.509 extensions.
         * Structure is documented below.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigAdditionalExtension>[]>;
        /**
         * (Output)
         * Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the
         * "Authority Information Access" extension in the certificate.
         */
        aiaOcspServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        caOptions?: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigCaOptions>;
        /**
         * (Output)
         * Indicates the intended use for keys that correspond to a certificate.
         * Structure is documented below.
         */
        keyUsage: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigKeyUsage>;
        /**
         * (Output)
         * Describes the X.509 name constraints extension.
         * Structure is documented below.
         */
        nameConstraints?: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigNameConstraints>;
        /**
         * (Output)
         * Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
         * Structure is documented below.
         */
        policyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigPolicyId>[]>;
    }

    export interface CertificateConfigX509ConfigAdditionalExtension {
        /**
         * Indicates whether or not this extension is critical (i.e., if the client does not know how to
         * handle this extension, the client should consider this to be an error).
         */
        critical: pulumi.Input<boolean>;
        /**
         * Describes values that are relevant in a CA certificate.
         * Structure is documented below.
         */
        objectId: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigAdditionalExtensionObjectId>;
        /**
         * The value of this X.509 extension. A base64-encoded string.
         */
        value: pulumi.Input<string>;
    }

    export interface CertificateConfigX509ConfigAdditionalExtensionObjectId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateConfigX509ConfigCaOptions {
        /**
         * When true, the "CA" in Basic Constraints extension will be set to true.
         */
        isCa?: pulumi.Input<boolean>;
        /**
         * Refers to the "path length constraint" in Basic Constraints extension. For a CA certificate, this value describes the depth of
         * subordinate CA certificates that are allowed. If this value is less than 0, the request will fail.
         */
        maxIssuerPathLength?: pulumi.Input<number>;
        /**
         * When true, the "CA" in Basic Constraints extension will be set to false.
         * If both `isCa` and `nonCa` are unset, the extension will be omitted from the CA certificate.
         */
        nonCa?: pulumi.Input<boolean>;
        /**
         * When true, the "path length constraint" in Basic Constraints extension will be set to 0.
         * if both `maxIssuerPathLength` and `zeroMaxIssuerPathLength` are unset,
         * the max path length will be omitted from the CA certificate.
         */
        zeroMaxIssuerPathLength?: pulumi.Input<boolean>;
    }

    export interface CertificateConfigX509ConfigKeyUsage {
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        baseKeyUsage: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigKeyUsageBaseKeyUsage>;
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        extendedKeyUsage: pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigKeyUsageExtendedKeyUsage>;
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         * Structure is documented below.
         */
        unknownExtendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateConfigX509ConfigKeyUsageUnknownExtendedKeyUsage>[]>;
    }

    export interface CertificateConfigX509ConfigKeyUsageBaseKeyUsage {
        /**
         * The key may be used to sign certificates.
         */
        certSign?: pulumi.Input<boolean>;
        /**
         * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
         */
        contentCommitment?: pulumi.Input<boolean>;
        /**
         * The key may be used sign certificate revocation lists.
         */
        crlSign?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher data.
         */
        dataEncipherment?: pulumi.Input<boolean>;
        /**
         * The key may be used to decipher only.
         */
        decipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used for digital signatures.
         */
        digitalSignature?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher only.
         */
        encipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used in a key agreement protocol.
         */
        keyAgreement?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher other keys.
         */
        keyEncipherment?: pulumi.Input<boolean>;
    }

    export interface CertificateConfigX509ConfigKeyUsageExtendedKeyUsage {
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
         */
        clientAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
         */
        codeSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
         */
        emailProtection?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
         */
        ocspSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
         */
        serverAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
         */
        timeStamping?: pulumi.Input<boolean>;
    }

    export interface CertificateConfigX509ConfigKeyUsageUnknownExtendedKeyUsage {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateConfigX509ConfigNameConstraints {
        /**
         * Indicates whether or not the name constraints are marked critical.
         */
        critical: pulumi.Input<boolean>;
        /**
         * Contains excluded DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        excludedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        excludedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        excludedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the excluded URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        excludedUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains permitted DNS names. Any DNS name that can be
         * constructed by simply adding zero or more labels to
         * the left-hand side of the name satisfies the name constraint.
         * For example, `example.com`, `www.example.com`, `www.sub.example.com`
         * would satisfy `example.com` while `example1.com` does not.
         */
        permittedDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted email addresses. The value can be a particular
         * email address, a hostname to indicate all email addresses on that host or
         * a domain with a leading period (e.g. `.example.com`) to indicate
         * all email addresses in that domain.
         */
        permittedEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted IP ranges. For IPv4 addresses, the ranges
         * are expressed using CIDR notation as specified in RFC 4632.
         * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
         * addresses.
         */
        permittedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Contains the permitted URIs that apply to the host part of the name.
         * The value can be a hostname or a domain with a
         * leading period (like `.example.com`)
         */
        permittedUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CertificateConfigX509ConfigPolicyId {
        /**
         * An ObjectId specifies an object identifier (OID). These provide context and describe types in ASN.1 messages.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateRevocationDetail {
        /**
         * (Output)
         * Indicates why a Certificate was revoked.
         */
        revocationState?: pulumi.Input<string>;
        /**
         * (Output)
         * The time at which this Certificate was revoked.
         */
        revocationTime?: pulumi.Input<string>;
    }

    export interface CertificateTemplateIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CertificateTemplateIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CertificateTemplateIdentityConstraints {
        /**
         * Required. If this is true, the SubjectAltNames extension may be copied from a certificate request into the signed certificate. Otherwise, the requested SubjectAltNames will be discarded.
         */
        allowSubjectAltNamesPassthrough: pulumi.Input<boolean>;
        /**
         * Required. If this is true, the Subject field may be copied from a certificate request into the signed certificate. Otherwise, the requested Subject will be discarded.
         */
        allowSubjectPassthrough: pulumi.Input<boolean>;
        /**
         * Optional. A CEL expression that may be used to validate the resolved X.509 Subject and/or Subject Alternative Name before a certificate is signed. To see the full allowed syntax and some examples, see https://cloud.google.com/certificate-authority-service/docs/using-cel
         * Structure is documented below.
         */
        celExpression?: pulumi.Input<inputs.certificateauthority.CertificateTemplateIdentityConstraintsCelExpression>;
    }

    export interface CertificateTemplateIdentityConstraintsCelExpression {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface CertificateTemplatePassthroughExtensions {
        /**
         * Optional. A set of ObjectIds identifying custom X.509 extensions. Will be combined with knownExtensions to determine the full set of X.509 extensions.
         * Structure is documented below.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateTemplatePassthroughExtensionsAdditionalExtension>[]>;
        /**
         * Optional. A set of named X.509 extensions. Will be combined with additionalExtensions to determine the full set of X.509 extensions.
         */
        knownExtensions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CertificateTemplatePassthroughExtensionsAdditionalExtension {
        /**
         * Required. The parts of an OID path. The most significant parts of the path come first.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateTemplatePredefinedValues {
        /**
         * Optional. Describes custom X.509 extensions.
         * Structure is documented below.
         */
        additionalExtensions?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesAdditionalExtension>[]>;
        /**
         * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses that appear in the "Authority Information Access" extension in the certificate.
         */
        aiaOcspServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Describes options in this X509Parameters that are relevant in a CA certificate.
         * Structure is documented below.
         */
        caOptions?: pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesCaOptions>;
        /**
         * Optional. Indicates the intended use for keys that correspond to a certificate.
         * Structure is documented below.
         */
        keyUsage?: pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesKeyUsage>;
        /**
         * Optional. Describes the X.509 certificate policy object identifiers, per https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
         * Structure is documented below.
         */
        policyIds?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesPolicyId>[]>;
    }

    export interface CertificateTemplatePredefinedValuesAdditionalExtension {
        /**
         * Optional. Indicates whether or not this extension is critical (i.e., if the client does not know how to handle this extension, the client should consider this to be an error).
         */
        critical?: pulumi.Input<boolean>;
        /**
         * Required. The OID for this X.509 extension.
         * Structure is documented below.
         */
        objectId: pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesAdditionalExtensionObjectId>;
        /**
         * Required. The value of this X.509 extension.
         */
        value: pulumi.Input<string>;
    }

    export interface CertificateTemplatePredefinedValuesAdditionalExtensionObjectId {
        /**
         * Required. The parts of an OID path. The most significant parts of the path come first.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateTemplatePredefinedValuesCaOptions {
        /**
         * Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this value is missing, the extension will be omitted from the CA certificate.
         */
        isCa?: pulumi.Input<boolean>;
        /**
         * Optional. Refers to the path length restriction X.509 extension. For a CA certificate, this value describes the depth of subordinate CA certificates that are allowed. If this value is less than 0, the request will fail. If this value is missing, the max path length will be omitted from the CA certificate.
         */
        maxIssuerPathLength?: pulumi.Input<number>;
    }

    export interface CertificateTemplatePredefinedValuesKeyUsage {
        /**
         * Describes high-level ways in which a key may be used.
         * Structure is documented below.
         */
        baseKeyUsage?: pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesKeyUsageBaseKeyUsage>;
        /**
         * Detailed scenarios in which a key may be used.
         * Structure is documented below.
         */
        extendedKeyUsage?: pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesKeyUsageExtendedKeyUsage>;
        /**
         * Used to describe extended key usages that are not listed in the KeyUsage.ExtendedKeyUsageOptions message.
         * Structure is documented below.
         */
        unknownExtendedKeyUsages?: pulumi.Input<pulumi.Input<inputs.certificateauthority.CertificateTemplatePredefinedValuesKeyUsageUnknownExtendedKeyUsage>[]>;
    }

    export interface CertificateTemplatePredefinedValuesKeyUsageBaseKeyUsage {
        /**
         * The key may be used to sign certificates.
         */
        certSign?: pulumi.Input<boolean>;
        /**
         * The key may be used for cryptographic commitments. Note that this may also be referred to as "non-repudiation".
         */
        contentCommitment?: pulumi.Input<boolean>;
        /**
         * The key may be used sign certificate revocation lists.
         */
        crlSign?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher data.
         */
        dataEncipherment?: pulumi.Input<boolean>;
        /**
         * The key may be used to decipher only.
         */
        decipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used for digital signatures.
         */
        digitalSignature?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher only.
         */
        encipherOnly?: pulumi.Input<boolean>;
        /**
         * The key may be used in a key agreement protocol.
         */
        keyAgreement?: pulumi.Input<boolean>;
        /**
         * The key may be used to encipher other keys.
         */
        keyEncipherment?: pulumi.Input<boolean>;
    }

    export interface CertificateTemplatePredefinedValuesKeyUsageExtendedKeyUsage {
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW client authentication", though regularly used for non-WWW TLS.
         */
        clientAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of downloadable executable code client authentication".
         */
        codeSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email protection".
         */
        emailProtection?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing OCSP responses".
         */
        ocspSigning?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW server authentication", though regularly used for non-WWW TLS.
         */
        serverAuth?: pulumi.Input<boolean>;
        /**
         * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding the hash of an object to a time".
         */
        timeStamping?: pulumi.Input<boolean>;
    }

    export interface CertificateTemplatePredefinedValuesKeyUsageUnknownExtendedKeyUsage {
        /**
         * Required. The parts of an OID path. The most significant parts of the path come first.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateTemplatePredefinedValuesPolicyId {
        /**
         * Required. The parts of an OID path. The most significant parts of the path come first.
         */
        objectIdPaths: pulumi.Input<pulumi.Input<number>[]>;
    }

}

export namespace certificatemanager {
    export interface CertificateIssuanceConfigCertificateAuthorityConfig {
        /**
         * Defines a CertificateAuthorityServiceConfig.
         * Structure is documented below.
         */
        certificateAuthorityServiceConfig?: pulumi.Input<inputs.certificatemanager.CertificateIssuanceConfigCertificateAuthorityConfigCertificateAuthorityServiceConfig>;
    }

    export interface CertificateIssuanceConfigCertificateAuthorityConfigCertificateAuthorityServiceConfig {
        /**
         * A CA pool resource used to issue a certificate.
         * The CA pool string has a relative resource path following the form
         * "projects/{project}/locations/{location}/caPools/{caPool}".
         *
         * - - -
         */
        caPool: pulumi.Input<string>;
    }

    export interface CertificateManaged {
        /**
         * (Output)
         * Detailed state of the latest authorization attempt for each domain
         * specified for this Managed Certificate.
         * Structure is documented below.
         *
         *
         * <a name="nestedManagedProvisioningIssue"></a>The `provisioningIssue` block contains:
         */
        authorizationAttemptInfos?: pulumi.Input<pulumi.Input<inputs.certificatemanager.CertificateManagedAuthorizationAttemptInfo>[]>;
        /**
         * Authorizations that will be used for performing domain authorization. Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
         */
        dnsAuthorizations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The domains for which a managed SSL certificate will be generated.
         * Wildcard domains are only supported with DNS challenge resolution
         */
        domains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The resource name for a CertificateIssuanceConfig used to configure private PKI certificates in the format projects/*&#47;locations/*&#47;certificateIssuanceConfigs/*.
         * If this field is not set, the certificates will instead be publicly signed as documented at https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
         * Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
         */
        issuanceConfig?: pulumi.Input<string>;
        /**
         * (Output)
         * Information about issues with provisioning this Managed Certificate.
         * Structure is documented below.
         */
        provisioningIssues?: pulumi.Input<pulumi.Input<inputs.certificatemanager.CertificateManagedProvisioningIssue>[]>;
        /**
         * (Output)
         * State of the domain for managed certificate issuance.
         */
        state?: pulumi.Input<string>;
    }

    export interface CertificateManagedAuthorizationAttemptInfo {
        /**
         * Human readable explanation for reaching the state. Provided to help
         * address the configuration issues.
         * Not guaranteed to be stable. For programmatic access use 'failure_reason' field.
         */
        details?: pulumi.Input<string>;
        /**
         * Domain name of the authorization attempt.
         */
        domain?: pulumi.Input<string>;
        /**
         * Reason for failure of the authorization attempt for the domain.
         */
        failureReason?: pulumi.Input<string>;
        /**
         * State of the domain for managed certificate issuance.
         */
        state?: pulumi.Input<string>;
    }

    export interface CertificateManagedProvisioningIssue {
        /**
         * Human readable explanation about the issue. Provided to help address
         * the configuration issues.
         * Not guaranteed to be stable. For programmatic access use 'reason' field.
         */
        details?: pulumi.Input<string>;
        /**
         * Reason for provisioning failures.
         */
        reason?: pulumi.Input<string>;
    }

    export interface CertificateMapGclbTarget {
        /**
         * An IP configuration where this Certificate Map is serving
         * Structure is documented below.
         */
        ipConfigs?: pulumi.Input<pulumi.Input<inputs.certificatemanager.CertificateMapGclbTargetIpConfig>[]>;
        /**
         * Proxy name must be in the format projects/*&#47;locations/*&#47;targetHttpsProxies/*.
         * This field is part of a union field `targetProxy`: Only one of `targetHttpsProxy` or
         * `targetSslProxy` may be set.
         */
        targetHttpsProxy?: pulumi.Input<string>;
        /**
         * Proxy name must be in the format projects/*&#47;locations/*&#47;targetSslProxies/*.
         * This field is part of a union field `targetProxy`: Only one of `targetHttpsProxy` or
         * `targetSslProxy` may be set.
         */
        targetSslProxy?: pulumi.Input<string>;
    }

    export interface CertificateMapGclbTargetIpConfig {
        /**
         * An external IP address
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * A list of ports
         */
        ports?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CertificateSelfManaged {
        /**
         * (Optional, Deprecated)
         * The certificate chain in PEM-encoded form.
         * Leaf certificate comes first, followed by intermediate ones if any.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         *
         * > **Warning:** `certificatePem` is deprecated and will be removed in a future major release. Use `pemCertificate` instead.
         *
         * @deprecated `certificatePem` is deprecated and will be removed in a future major release. Use `pemCertificate` instead.
         */
        certificatePem?: pulumi.Input<string>;
        /**
         * The certificate chain in PEM-encoded form.
         * Leaf certificate comes first, followed by intermediate ones if any.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        pemCertificate?: pulumi.Input<string>;
        /**
         * The private key of the leaf certificate in PEM-encoded form.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        pemPrivateKey?: pulumi.Input<string>;
        /**
         * (Optional, Deprecated)
         * The private key of the leaf certificate in PEM-encoded form.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         *
         * > **Warning:** `privateKeyPem` is deprecated and will be removed in a future major release. Use `pemPrivateKey` instead.
         *
         * @deprecated `privateKeyPem` is deprecated and will be removed in a future major release. Use `pemPrivateKey` instead.
         */
        privateKeyPem?: pulumi.Input<string>;
    }

    export interface DnsAuthorizationDnsResourceRecord {
        /**
         * (Output)
         * Data of the DNS Resource Record.
         */
        data?: pulumi.Input<string>;
        /**
         * Name of the resource; provided by the client when the resource is created.
         * The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
         * and all following characters must be a dash, underscore, letter or digit.
         *
         *
         * - - -
         */
        name?: pulumi.Input<string>;
        /**
         * type of DNS authorization. If unset during the resource creation, FIXED_RECORD will
         * be used for global resources, and PER_PROJECT_RECORD will be used for other locations.
         * FIXED_RECORD DNS authorization uses DNS-01 validation method
         * PER_PROJECT_RECORD DNS authorization allows for independent management
         * of Google-managed certificates with DNS authorization across multiple
         * projects.
         * Possible values are: `FIXED_RECORD`, `PER_PROJECT_RECORD`.
         */
        type?: pulumi.Input<string>;
    }

    export interface TrustConfigAllowlistedCertificate {
        /**
         * PEM certificate that is allowlisted. The certificate can be up to 5k bytes, and must be a parseable X.509 certificate.
         */
        pemCertificate: pulumi.Input<string>;
    }

    export interface TrustConfigTrustStore {
        /**
         * Set of intermediate CA certificates used for the path building phase of chain validation.
         * The field is currently not supported if trust config is used for the workload certificate feature.
         * Structure is documented below.
         */
        intermediateCas?: pulumi.Input<pulumi.Input<inputs.certificatemanager.TrustConfigTrustStoreIntermediateCa>[]>;
        /**
         * List of Trust Anchors to be used while performing validation against a given TrustStore.
         * Structure is documented below.
         */
        trustAnchors?: pulumi.Input<pulumi.Input<inputs.certificatemanager.TrustConfigTrustStoreTrustAnchor>[]>;
    }

    export interface TrustConfigTrustStoreIntermediateCa {
        /**
         * PEM intermediate certificate used for building up paths for validation.
         * Each certificate provided in PEM format may occupy up to 5kB.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        pemCertificate?: pulumi.Input<string>;
    }

    export interface TrustConfigTrustStoreTrustAnchor {
        /**
         * PEM root certificate of the PKI used for validation.
         * Each certificate provided in PEM format may occupy up to 5kB.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        pemCertificate?: pulumi.Input<string>;
    }
}

export namespace chronicle {
    export interface DataAccessScopeAllowedDataAccessLabel {
        /**
         * The asset namespace configured in the forwarder
         * of the customer's events.
         */
        assetNamespace?: pulumi.Input<string>;
        /**
         * The name of the data access label.
         */
        dataAccessLabel?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The display name of the label.
         * Data access label and log types's name
         * will match the display name of the resource.
         * The asset namespace will match the namespace itself.
         * The ingestion key value pair will match the key of the tuple.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Representation of an ingestion label type.
         * Structure is documented below.
         */
        ingestionLabel?: pulumi.Input<inputs.chronicle.DataAccessScopeAllowedDataAccessLabelIngestionLabel>;
        /**
         * The name of the log type.
         */
        logType?: pulumi.Input<string>;
    }

    export interface DataAccessScopeAllowedDataAccessLabelIngestionLabel {
        /**
         * Required. The key of the ingestion label. Always required.
         */
        ingestionLabelKey: pulumi.Input<string>;
        /**
         * Optional. The value of the ingestion label. Optional. An object
         * with no provided value and some key provided would match
         * against the given key and ANY value.
         */
        ingestionLabelValue?: pulumi.Input<string>;
    }

    export interface DataAccessScopeDeniedDataAccessLabel {
        /**
         * The asset namespace configured in the forwarder
         * of the customer's events.
         */
        assetNamespace?: pulumi.Input<string>;
        /**
         * The name of the data access label.
         */
        dataAccessLabel?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The display name of the label.
         * Data access label and log types's name
         * will match the display name of the resource.
         * The asset namespace will match the namespace itself.
         * The ingestion key value pair will match the key of the tuple.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Representation of an ingestion label type.
         * Structure is documented below.
         */
        ingestionLabel?: pulumi.Input<inputs.chronicle.DataAccessScopeDeniedDataAccessLabelIngestionLabel>;
        /**
         * The name of the log type.
         */
        logType?: pulumi.Input<string>;
    }

    export interface DataAccessScopeDeniedDataAccessLabelIngestionLabel {
        /**
         * Required. The key of the ingestion label. Always required.
         */
        ingestionLabelKey: pulumi.Input<string>;
        /**
         * Optional. The value of the ingestion label. Optional. An object
         * with no provided value and some key provided would match
         * against the given key and ANY value.
         */
        ingestionLabelValue?: pulumi.Input<string>;
    }

    export interface ReferenceListEntry {
        /**
         * Required. The value of the entry. Maximum length is 512 characters.
         *
         * - - -
         */
        value: pulumi.Input<string>;
    }

    export interface ReferenceListScopeInfo {
        /**
         * ReferenceListScope specifies the list of scope names of the reference list.
         * Structure is documented below.
         */
        referenceListScope: pulumi.Input<inputs.chronicle.ReferenceListScopeInfoReferenceListScope>;
    }

    export interface ReferenceListScopeInfoReferenceListScope {
        /**
         * Optional. The list of scope names of the reference list. The scope names should be
         * full resource names and should be of the format:
         * "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
         */
        scopeNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RetrohuntExecutionInterval {
        /**
         * Optional. Exclusive end of the interval.
         * If specified, a Timestamp matching this interval will have to be before the
         * end.
         */
        endTime?: pulumi.Input<string>;
        /**
         * Optional. Inclusive start of the interval.
         * If specified, a Timestamp matching this interval will have to be the same
         * or after the start.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface RetrohuntProcessInterval {
        /**
         * Exclusive end of the interval.
         *
         * - - -
         */
        endTime: pulumi.Input<string>;
        /**
         * Inclusive start of the interval.
         */
        startTime: pulumi.Input<string>;
    }

    export interface RuleCompilationDiagnostic {
        /**
         * (Output)
         * Output only. The diagnostic message.
         */
        message?: pulumi.Input<string>;
        /**
         * CompilationPosition represents the location of a compilation diagnostic in
         * rule text.
         * Structure is documented below.
         */
        position?: pulumi.Input<inputs.chronicle.RuleCompilationDiagnosticPosition>;
        /**
         * (Output)
         * Output only. The severity of a rule's compilation diagnostic.
         * Possible values:
         * SEVERITY_UNSPECIFIED
         * WARNING
         * ERROR
         */
        severity?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Link to documentation that describes a diagnostic in more detail.
         */
        uri?: pulumi.Input<string>;
    }

    export interface RuleCompilationDiagnosticPosition {
        /**
         * (Output)
         * Output only. End column number, beginning at 1.
         */
        endColumn?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. End line number, beginning at 1.
         */
        endLine?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Start column number, beginning at 1.
         */
        startColumn?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Start line number, beginning at 1.
         */
        startLine?: pulumi.Input<number>;
    }

    export interface RuleSeverity {
        /**
         * The display name of the severity level. Extracted from the meta section of
         * the rule text.
         */
        displayName?: pulumi.Input<string>;
    }

    export interface WatchlistEntityCount {
        /**
         * (Output)
         * Output only. Count of asset type entities in the watchlist.
         */
        asset?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Count of user type entities in the watchlist.
         */
        user?: pulumi.Input<number>;
    }

    export interface WatchlistEntityPopulationMechanism {
        /**
         * Entities are added manually.
         *
         * - - -
         */
        manual?: pulumi.Input<inputs.chronicle.WatchlistEntityPopulationMechanismManual>;
    }

    export interface WatchlistEntityPopulationMechanismManual {
    }

    export interface WatchlistWatchlistUserPreferences {
        /**
         * Optional. Whether the watchlist is pinned on the dashboard.
         */
        pinned?: pulumi.Input<boolean>;
    }
}

export namespace cloudasset {
    export interface FolderFeedCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file
         * name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface FolderFeedFeedOutputConfig {
        /**
         * Destination on Cloud Pubsub.
         * Structure is documented below.
         */
        pubsubDestination: pulumi.Input<inputs.cloudasset.FolderFeedFeedOutputConfigPubsubDestination>;
    }

    export interface FolderFeedFeedOutputConfigPubsubDestination {
        /**
         * Destination on Cloud Pubsub topic.
         *
         * - - -
         */
        topic: pulumi.Input<string>;
    }

    export interface OrganizationFeedCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file
         * name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface OrganizationFeedFeedOutputConfig {
        /**
         * Destination on Cloud Pubsub.
         * Structure is documented below.
         */
        pubsubDestination: pulumi.Input<inputs.cloudasset.OrganizationFeedFeedOutputConfigPubsubDestination>;
    }

    export interface OrganizationFeedFeedOutputConfigPubsubDestination {
        /**
         * Destination on Cloud Pubsub topic.
         *
         * - - -
         */
        topic: pulumi.Input<string>;
    }

    export interface ProjectFeedCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file
         * name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ProjectFeedFeedOutputConfig {
        /**
         * Destination on Cloud Pubsub.
         * Structure is documented below.
         */
        pubsubDestination: pulumi.Input<inputs.cloudasset.ProjectFeedFeedOutputConfigPubsubDestination>;
    }

    export interface ProjectFeedFeedOutputConfigPubsubDestination {
        /**
         * Destination on Cloud Pubsub topic.
         *
         * - - -
         */
        topic: pulumi.Input<string>;
    }
}

export namespace cloudbuild {
    export interface BitbucketServerConfigConnectedRepository {
        /**
         * Identifier for the project storing the repository.
         */
        projectKey: pulumi.Input<string>;
        /**
         * Identifier for the repository.
         */
        repoSlug: pulumi.Input<string>;
    }

    export interface BitbucketServerConfigSecrets {
        /**
         * The resource name for the admin access token's secret version.
         */
        adminAccessTokenVersionName: pulumi.Input<string>;
        /**
         * The resource name for the read access token's secret version.
         */
        readAccessTokenVersionName: pulumi.Input<string>;
        /**
         * Immutable. The resource name for the webhook secret's secret version. Once this field has been set, it cannot be changed.
         * Changing this field will result in deleting/ recreating the resource.
         *
         * - - -
         */
        webhookSecretVersionName: pulumi.Input<string>;
    }

    export interface TriggerApprovalConfig {
        /**
         * Whether or not approval is needed. If this is set on a build, it will become pending when run,
         * and will need to be explicitly approved to start.
         */
        approvalRequired?: pulumi.Input<boolean>;
    }

    export interface TriggerBitbucketServerTriggerConfig {
        /**
         * The Bitbucket server config resource that this trigger config maps to.
         */
        bitbucketServerConfigResource: pulumi.Input<string>;
        /**
         * Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is "TEST".
         */
        projectKey: pulumi.Input<string>;
        /**
         * Filter to match changes in pull requests.
         * Structure is documented below.
         */
        pullRequest?: pulumi.Input<inputs.cloudbuild.TriggerBitbucketServerTriggerConfigPullRequest>;
        /**
         * Filter to match changes in refs like branches, tags.
         * Structure is documented below.
         */
        push?: pulumi.Input<inputs.cloudbuild.TriggerBitbucketServerTriggerConfigPush>;
        /**
         * Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
         * For example, if the repository name is 'test repo', in the URL it would become 'test-repo' as in https://mybitbucket.server/projects/TEST/repos/test-repo.
         */
        repoSlug: pulumi.Input<string>;
    }

    export interface TriggerBitbucketServerTriggerConfigPullRequest {
        /**
         * Regex of branches to match.
         * The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
         */
        branch: pulumi.Input<string>;
        /**
         * Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
         * Possible values are: `COMMENTS_DISABLED`, `COMMENTS_ENABLED`, `COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY`.
         */
        commentControl?: pulumi.Input<string>;
        /**
         * If true, branches that do NOT match the gitRef will trigger a build.
         */
        invertRegex?: pulumi.Input<boolean>;
    }

    export interface TriggerBitbucketServerTriggerConfigPush {
        /**
         * Regex of branches to match.  Specify only one of branch or tag.
         */
        branch?: pulumi.Input<string>;
        /**
         * When true, only trigger a build if the revision regex does NOT match the gitRef regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * Regex of tags to match.  Specify only one of branch or tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface TriggerBuild {
        /**
         * Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
         * Structure is documented below.
         */
        artifacts?: pulumi.Input<inputs.cloudbuild.TriggerBuildArtifacts>;
        /**
         * Secrets and secret environment variables.
         * Structure is documented below.
         */
        availableSecrets?: pulumi.Input<inputs.cloudbuild.TriggerBuildAvailableSecrets>;
        /**
         * A list of images to be pushed upon the successful completion of all build steps.
         * The images are pushed using the builder service account's credentials.
         * The digests of the pushed images will be stored in the Build resource's results field.
         * If any of the images fail to be pushed, the build status is marked FAILURE.
         */
        images?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Google Cloud Storage bucket where logs should be written.
         * Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
         */
        logsBucket?: pulumi.Input<string>;
        /**
         * Special options for this build.
         * Structure is documented below.
         */
        options?: pulumi.Input<inputs.cloudbuild.TriggerBuildOptions>;
        /**
         * TTL in queue for this build. If provided and the build is enqueued longer than this value,
         * the build will expire and the build status will be EXPIRED.
         * The TTL starts ticking from createTime.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        queueTtl?: pulumi.Input<string>;
        /**
         * Secrets to decrypt using Cloud Key Management Service.
         * Structure is documented below.
         */
        secrets?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildSecret>[]>;
        /**
         * The location of the source files to build.
         * One of `storageSource` or `repoSource` must be provided.
         * Structure is documented below.
         */
        source?: pulumi.Input<inputs.cloudbuild.TriggerBuildSource>;
        /**
         * The operations to be performed on the workspace.
         * Structure is documented below.
         */
        steps: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStep>[]>;
        /**
         * Substitutions data for Build resource.
         */
        substitutions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Tags for annotation of a Build. These are not docker tags.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Amount of time that this build should be allowed to run, to second granularity.
         * If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.
         * This timeout must be equal to or greater than the sum of the timeouts for build steps within the build.
         * The expected format is the number of seconds followed by s.
         * Default time is ten minutes (600s).
         */
        timeout?: pulumi.Input<string>;
    }

    export interface TriggerBuildArtifacts {
        /**
         * A list of images to be pushed upon the successful completion of all build steps.
         * The images will be pushed using the builder service account's credentials.
         * The digests of the pushed images will be stored in the Build resource's results field.
         * If any of the images fail to be pushed, the build is marked FAILURE.
         */
        images?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A Maven artifact to upload to Artifact Registry upon successful completion of all build steps.
         * The location and generation of the uploaded objects will be stored in the Build resource's results field.
         * If any objects fail to be pushed, the build is marked FAILURE.
         * Structure is documented below.
         */
        mavenArtifacts?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildArtifactsMavenArtifact>[]>;
        /**
         * Npm package to upload to Artifact Registry upon successful completion of all build steps.
         * The location and generation of the uploaded objects will be stored in the Build resource's results field.
         * If any objects fail to be pushed, the build is marked FAILURE.
         * Structure is documented below.
         */
        npmPackages?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildArtifactsNpmPackage>[]>;
        /**
         * A list of objects to be uploaded to Cloud Storage upon successful completion of all build steps.
         * Files in the workspace matching specified paths globs will be uploaded to the
         * Cloud Storage location using the builder service account's credentials.
         * The location and generation of the uploaded objects will be stored in the Build resource's results field.
         * If any objects fail to be pushed, the build is marked FAILURE.
         * Structure is documented below.
         */
        objects?: pulumi.Input<inputs.cloudbuild.TriggerBuildArtifactsObjects>;
        /**
         * Python package to upload to Artifact Registry upon successful completion of all build steps. A package can encapsulate multiple objects to be uploaded to a single repository.
         * The location and generation of the uploaded objects will be stored in the Build resource's results field.
         * If any objects fail to be pushed, the build is marked FAILURE.
         * Structure is documented below.
         */
        pythonPackages?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildArtifactsPythonPackage>[]>;
    }

    export interface TriggerBuildArtifactsMavenArtifact {
        /**
         * Maven artifactId value used when uploading the artifact to Artifact Registry.
         */
        artifactId?: pulumi.Input<string>;
        /**
         * Maven groupId value used when uploading the artifact to Artifact Registry.
         */
        groupId?: pulumi.Input<string>;
        /**
         * Path to an artifact in the build's workspace to be uploaded to Artifact Registry. This can be either an absolute path, e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar or a relative path from /workspace, e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
         */
        path?: pulumi.Input<string>;
        /**
         * Artifact Registry repository, in the form "https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY"
         * Artifact in the workspace specified by path will be uploaded to Artifact Registry with this location as a prefix.
         */
        repository?: pulumi.Input<string>;
        /**
         * Maven version value used when uploading the artifact to Artifact Registry.
         */
        version?: pulumi.Input<string>;
    }

    export interface TriggerBuildArtifactsNpmPackage {
        /**
         * Path to the package.json. e.g. workspace/path/to/package
         */
        packagePath?: pulumi.Input<string>;
        /**
         * Artifact Registry repository, in the form "https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY"
         * Npm package in the workspace specified by path will be zipped and uploaded to Artifact Registry with this location as a prefix.
         */
        repository?: pulumi.Input<string>;
    }

    export interface TriggerBuildArtifactsObjects {
        /**
         * Cloud Storage bucket and optional object path, in the form "gs://bucket/path/to/somewhere/".
         * Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
         * this location as a prefix.
         */
        location?: pulumi.Input<string>;
        /**
         * Path globs used to match files in the build's workspace.
         */
        paths?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Output only. Stores timing information for pushing all artifact objects.
         * Structure is documented below.
         *
         *
         * <a name="nestedBuildArtifactsObjectsTiming"></a>The `timing` block contains:
         */
        timings?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildArtifactsObjectsTiming>[]>;
    }

    export interface TriggerBuildArtifactsObjectsTiming {
        /**
         * End of time span.
         *
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to
         * nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        endTime?: pulumi.Input<string>;
        /**
         * Start of time span.
         *
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to
         * nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        startTime?: pulumi.Input<string>;
    }

    export interface TriggerBuildArtifactsPythonPackage {
        /**
         * Path globs used to match files in the build's workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
         */
        paths?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Artifact Registry repository, in the form "https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY"
         * Files in the workspace matching any path pattern will be uploaded to Artifact Registry with this location as a prefix.
         */
        repository?: pulumi.Input<string>;
    }

    export interface TriggerBuildAvailableSecrets {
        /**
         * Pairs a secret environment variable with a SecretVersion in Secret Manager.
         * Structure is documented below.
         */
        secretManagers: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildAvailableSecretsSecretManager>[]>;
    }

    export interface TriggerBuildAvailableSecretsSecretManager {
        /**
         * Environment variable name to associate with the secret. Secret environment
         * variables must be unique across all of a build's secrets, and must be used
         * by at least one build step.
         */
        env: pulumi.Input<string>;
        /**
         * Resource name of the SecretVersion. In format: projects/*&#47;secrets/*&#47;versions/*
         */
        versionName: pulumi.Input<string>;
    }

    export interface TriggerBuildOptions {
        /**
         * Requested disk size for the VM that runs the build. Note that this is NOT "disk free";
         * some of the space will be used by the operating system and build utilities.
         * Also note that this is the minimum disk size that will be allocated for the build --
         * the build may run with a larger disk than requested. At present, the maximum disk size
         * is 1000GB; builds that request more than the maximum are rejected with an error.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Option to specify whether or not to apply bash style string operations to the substitutions.
         * NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
         */
        dynamicSubstitutions?: pulumi.Input<boolean>;
        /**
         * A list of global environment variable definitions that will exist for all build steps
         * in this build. If a variable is defined in both globally and in a build step,
         * the variable will use the build step value.
         * The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
         */
        envs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Option to define build log streaming behavior to Google Cloud Storage.
         * Possible values are: `STREAM_DEFAULT`, `STREAM_ON`, `STREAM_OFF`.
         */
        logStreamingOption?: pulumi.Input<string>;
        /**
         * Option to specify the logging mode, which determines if and where build logs are stored.
         * Possible values are: `LOGGING_UNSPECIFIED`, `LEGACY`, `GCS_ONLY`, `STACKDRIVER_ONLY`, `CLOUD_LOGGING_ONLY`, `NONE`.
         */
        logging?: pulumi.Input<string>;
        /**
         * Compute Engine machine type on which to run the build.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Requested verifiability options.
         * Possible values are: `NOT_VERIFIED`, `VERIFIED`.
         */
        requestedVerifyOption?: pulumi.Input<string>;
        /**
         * A list of global environment variables, which are encrypted using a Cloud Key Management
         * Service crypto key. These values must be specified in the build's Secret. These variables
         * will be available to all build steps in this build.
         */
        secretEnvs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Requested hash for SourceProvenance.
         * Each value may be one of: `NONE`, `SHA256`, `MD5`.
         */
        sourceProvenanceHashes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Option to specify behavior when there is an error in the substitution checks.
         * NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden
         * in the build configuration file.
         * Possible values are: `MUST_MATCH`, `ALLOW_LOOSE`.
         */
        substitutionOption?: pulumi.Input<string>;
        /**
         * Global list of volumes to mount for ALL build steps
         * Each volume is created as an empty volume prior to starting the build process.
         * Upon completion of the build, volumes and their contents are discarded. Global
         * volume names and paths cannot conflict with the volumes defined a build step.
         * Using a global volume in a build with only one step is not valid as it is indicative
         * of a build request with an incorrect configuration.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildOptionsVolume>[]>;
        /**
         * Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}
         * This field is experimental.
         */
        workerPool?: pulumi.Input<string>;
    }

    export interface TriggerBuildOptionsVolume {
        /**
         * Name of the volume to mount.
         * Volume names must be unique per build step and must be valid names for Docker volumes.
         * Each named volume must be used by at least two build steps.
         */
        name?: pulumi.Input<string>;
        /**
         * Path at which to mount the volume.
         * Paths must be absolute and cannot conflict with other volume paths on the same
         * build step or with certain reserved volume paths.
         */
        path?: pulumi.Input<string>;
    }

    export interface TriggerBuildSecret {
        /**
         * Cloud KMS key name to use to decrypt these envs.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * Map of environment variable name to its encrypted value.
         * Secret environment variables must be unique across all of a build's secrets,
         * and must be used by at least one build step. Values can be at most 64 KB in size.
         * There can be at most 100 secret values across all of a build's secrets.
         */
        secretEnv?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface TriggerBuildSource {
        /**
         * Location of the source in a Google Cloud Source Repository.
         * Structure is documented below.
         */
        repoSource?: pulumi.Input<inputs.cloudbuild.TriggerBuildSourceRepoSource>;
        /**
         * Location of the source in an archive file in Google Cloud Storage.
         * Structure is documented below.
         */
        storageSource?: pulumi.Input<inputs.cloudbuild.TriggerBuildSourceStorageSource>;
    }

    export interface TriggerBuildSourceRepoSource {
        /**
         * Regex matching branches to build. Exactly one a of branch name, tag, or commit SHA must be provided.
         * The syntax of the regular expressions accepted is the syntax accepted by RE2 and
         * described at https://github.com/google/re2/wiki/Syntax
         */
        branchName?: pulumi.Input<string>;
        /**
         * Explicit commit SHA to build. Exactly one a of branch name, tag, or commit SHA must be provided.
         */
        commitSha?: pulumi.Input<string>;
        /**
         * Directory, relative to the source root, in which to run the build.
         * This must be a relative path. If a step's dir is specified and is an absolute path,
         * this value is ignored for that step's execution.
         */
        dir?: pulumi.Input<string>;
        /**
         * Only trigger a build if the revision regex does NOT match the revision regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * ID of the project that owns the Cloud Source Repository.
         * If omitted, the project ID requesting the build is assumed.
         */
        projectId?: pulumi.Input<string>;
        /**
         * Name of the Cloud Source Repository.
         */
        repoName: pulumi.Input<string>;
        /**
         * Substitutions to use in a triggered build. Should only be used with triggers.run
         */
        substitutions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Regex matching tags to build. Exactly one a of branch name, tag, or commit SHA must be provided.
         * The syntax of the regular expressions accepted is the syntax accepted by RE2 and
         * described at https://github.com/google/re2/wiki/Syntax
         */
        tagName?: pulumi.Input<string>;
    }

    export interface TriggerBuildSourceStorageSource {
        /**
         * Google Cloud Storage bucket containing the source.
         */
        bucket: pulumi.Input<string>;
        /**
         * Google Cloud Storage generation for the object.
         * If the generation is omitted, the latest generation will be used
         */
        generation?: pulumi.Input<string>;
        /**
         * Google Cloud Storage object containing the source.
         * This object must be a gzipped archive file (.tar.gz) containing source to build.
         */
        object: pulumi.Input<string>;
    }

    export interface TriggerBuildStep {
        /**
         * Allow this build step to fail without failing the entire build if and
         * only if the exit code is one of the specified codes.
         * If `allowFailure` is also specified, this field will take precedence.
         */
        allowExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Allow this build step to fail without failing the entire build.
         * If false, the entire build will fail if this step fails. Otherwise, the
         * build will succeed, but this step will still have a failure status.
         * Error information will be reported in the `failureDetail` field.
         * `allowExitCodes` takes precedence over this field.
         */
        allowFailure?: pulumi.Input<boolean>;
        /**
         * A list of arguments that will be presented to the step when it is started.
         * If the image used to run the step's container has an entrypoint, the args
         * are used as arguments to that entrypoint. If the image does not define an
         * entrypoint, the first element in args is used as the entrypoint, and the
         * remainder will be used as arguments.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Working directory to use when running this step's container.
         * If this value is a relative path, it is relative to the build's working
         * directory. If this value is absolute, it may be outside the build's working
         * directory, in which case the contents of the path may not be persisted
         * across build step executions, unless a `volume` for that path is specified.
         * If the build specifies a `RepoSource` with `dir` and a step with a
         * `dir`,
         * which specifies an absolute path, the `RepoSource` `dir` is ignored
         * for the step's execution.
         */
        dir?: pulumi.Input<string>;
        /**
         * Entrypoint to be used instead of the build step image's
         * default entrypoint.
         * If unset, the image's default entrypoint is used
         */
        entrypoint?: pulumi.Input<string>;
        /**
         * A list of environment variable definitions to be used when
         * running a step.
         * The elements are of the form "KEY=VALUE" for the environment variable
         * "KEY" being given the value "VALUE".
         */
        envs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Unique identifier for this build step, used in `waitFor` to
         * reference this build step as a dependency.
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the container image that will run this particular build step.
         * If the image is available in the host's Docker daemon's cache, it will be
         * run directly. If not, the host will attempt to pull the image first, using
         * the builder service account's credentials if necessary.
         * The Docker daemon's cache will already have the latest versions of all of
         * the officially supported build steps (see https://github.com/GoogleCloudPlatform/cloud-builders
         * for images and examples).
         * The Docker daemon will also have cached many of the layers for some popular
         * images, like "ubuntu", "debian", but they will be refreshed at the time
         * you attempt to use them.
         * If you built an image in a previous build step, it will be stored in the
         * host's Docker daemon's cache and is available to use as the name for a
         * later build step.
         */
        name: pulumi.Input<string>;
        /**
         * A shell script to be executed in the step.
         * When script is provided, the user cannot specify the entrypoint or args.
         */
        script?: pulumi.Input<string>;
        /**
         * A list of environment variables which are encrypted using
         * a Cloud Key
         * Management Service crypto key. These values must be specified in
         * the build's `Secret`.
         */
        secretEnvs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Time limit for executing this build step. If not defined,
         * the step has no
         * time limit and will be allowed to continue to run until either it
         * completes or the build itself times out.
         */
        timeout?: pulumi.Input<string>;
        /**
         * Output only. Stores timing information for executing this
         * build step.
         */
        timing?: pulumi.Input<string>;
        /**
         * List of volumes to mount into the build step.
         * Each volume is created as an empty volume prior to execution of the
         * build step. Upon completion of the build, volumes and their contents
         * are discarded.
         * Using a named volume in only one step is not valid as it is
         * indicative of a build request with an incorrect configuration.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStepVolume>[]>;
        /**
         * The ID(s) of the step(s) that this build step depends on.
         * This build step will not start until all the build steps in `waitFor`
         * have completed successfully. If `waitFor` is empty, this build step
         * will start when all previous build steps in the `Build.Steps` list
         * have completed successfully.
         */
        waitFors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TriggerBuildStepVolume {
        /**
         * Name of the volume to mount.
         * Volume names must be unique per build step and must be valid names for Docker volumes.
         * Each named volume must be used by at least two build steps.
         */
        name: pulumi.Input<string>;
        /**
         * Path at which to mount the volume.
         * Paths must be absolute and cannot conflict with other volume paths on the same
         * build step or with certain reserved volume paths.
         */
        path: pulumi.Input<string>;
    }

    export interface TriggerGitFileSource {
        /**
         * The full resource name of the bitbucket server config.
         * Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
         */
        bitbucketServerConfig?: pulumi.Input<string>;
        /**
         * The full resource name of the github enterprise config.
         * Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
         */
        githubEnterpriseConfig?: pulumi.Input<string>;
        /**
         * The path of the file, with the repo root as the root of the path.
         */
        path: pulumi.Input<string>;
        /**
         * The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
         * Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
         * Possible values are: `UNKNOWN`, `CLOUD_SOURCE_REPOSITORIES`, `GITHUB`, `BITBUCKET_SERVER`.
         */
        repoType: pulumi.Input<string>;
        /**
         * The fully qualified resource name of the Repo API repository. The fully qualified resource name of the Repo API repository.
         * If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
         */
        repository?: pulumi.Input<string>;
        /**
         * The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the
         * filename (optional). This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions
         * If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
         */
        revision?: pulumi.Input<string>;
        /**
         * The URI of the repo (optional). If unspecified, the repo from which the trigger
         * invocation originated is assumed to be the repo from which to read the specified path.
         */
        uri?: pulumi.Input<string>;
    }

    export interface TriggerGithub {
        /**
         * The resource name of the github enterprise config that should be applied to this installation.
         * For example: "projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}"
         */
        enterpriseConfigResourceName?: pulumi.Input<string>;
        /**
         * Name of the repository. For example: The name for
         * https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
         */
        name?: pulumi.Input<string>;
        /**
         * Owner of the repository. For example: The owner for
         * https://github.com/googlecloudplatform/cloud-builders is "googlecloudplatform".
         */
        owner?: pulumi.Input<string>;
        /**
         * filter to match changes in pull requests. Specify only one of `pullRequest` or `push`.
         * Structure is documented below.
         */
        pullRequest?: pulumi.Input<inputs.cloudbuild.TriggerGithubPullRequest>;
        /**
         * filter to match changes in refs, like branches or tags. Specify only one of `pullRequest` or `push`.
         * Structure is documented below.
         */
        push?: pulumi.Input<inputs.cloudbuild.TriggerGithubPush>;
    }

    export interface TriggerGithubPullRequest {
        /**
         * Regex of branches to match.
         * The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
         */
        branch: pulumi.Input<string>;
        /**
         * Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
         * Possible values are: `COMMENTS_DISABLED`, `COMMENTS_ENABLED`, `COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY`.
         */
        commentControl?: pulumi.Input<string>;
        /**
         * If true, branches that do NOT match the gitRef will trigger a build.
         */
        invertRegex?: pulumi.Input<boolean>;
    }

    export interface TriggerGithubPush {
        /**
         * Regex of branches to match.  Specify only one of branch or tag.
         */
        branch?: pulumi.Input<string>;
        /**
         * When true, only trigger a build if the revision regex does NOT match the gitRef regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * Regex of tags to match.  Specify only one of branch or tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface TriggerPubsubConfig {
        /**
         * Service account that will make the push request.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * (Output)
         * Potential issues with the underlying Pub/Sub subscription configuration.
         * Only populated on get requests.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Name of the subscription.
         */
        subscription?: pulumi.Input<string>;
        /**
         * The name of the topic from which this subscription is receiving messages.
         */
        topic: pulumi.Input<string>;
    }

    export interface TriggerRepositoryEventConfig {
        /**
         * Contains filter properties for matching Pull Requests.
         * Structure is documented below.
         */
        pullRequest?: pulumi.Input<inputs.cloudbuild.TriggerRepositoryEventConfigPullRequest>;
        /**
         * Contains filter properties for matching git pushes.
         * Structure is documented below.
         */
        push?: pulumi.Input<inputs.cloudbuild.TriggerRepositoryEventConfigPush>;
        /**
         * The resource name of the Repo API resource.
         */
        repository?: pulumi.Input<string>;
    }

    export interface TriggerRepositoryEventConfigPullRequest {
        /**
         * Regex of branches to match.
         * The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
         */
        branch?: pulumi.Input<string>;
        /**
         * Configure builds to run whether a repository owner or collaborator need to comment /gcbrun.
         * Possible values are: `COMMENTS_DISABLED`, `COMMENTS_ENABLED`, `COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY`.
         */
        commentControl?: pulumi.Input<string>;
        /**
         * If true, branches that do NOT match the gitRef will trigger a build.
         */
        invertRegex?: pulumi.Input<boolean>;
    }

    export interface TriggerRepositoryEventConfigPush {
        /**
         * Regex of branches to match.  Specify only one of branch or tag.
         */
        branch?: pulumi.Input<string>;
        /**
         * When true, only trigger a build if the revision regex does NOT match the gitRef regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * Regex of tags to match.  Specify only one of branch or tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface TriggerSourceToBuild {
        /**
         * The full resource name of the bitbucket server config.
         * Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
         */
        bitbucketServerConfig?: pulumi.Input<string>;
        /**
         * The full resource name of the github enterprise config.
         * Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
         */
        githubEnterpriseConfig?: pulumi.Input<string>;
        /**
         * The branch or tag to use. Must start with "refs/" (required).
         */
        ref: pulumi.Input<string>;
        /**
         * The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
         * Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER
         * Possible values are: `UNKNOWN`, `CLOUD_SOURCE_REPOSITORIES`, `GITHUB`, `BITBUCKET_SERVER`.
         */
        repoType: pulumi.Input<string>;
        /**
         * The qualified resource name of the Repo API repository.
         * Either uri or repository can be specified and is required.
         */
        repository?: pulumi.Input<string>;
        /**
         * The URI of the repo.
         */
        uri?: pulumi.Input<string>;
    }

    export interface TriggerTriggerTemplate {
        /**
         * Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
         * This field is a regular expression.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
         */
        commitSha?: pulumi.Input<string>;
        /**
         * Directory, relative to the source root, in which to run the build.
         * This must be a relative path. If a step's dir is specified and
         * is an absolute path, this value is ignored for that step's
         * execution.
         */
        dir?: pulumi.Input<string>;
        /**
         * Only trigger a build if the revision regex does NOT match the revision regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * ID of the project that owns the Cloud Source Repository. If
         * omitted, the project ID requesting the build is assumed.
         */
        projectId?: pulumi.Input<string>;
        /**
         * Name of the Cloud Source Repository. If omitted, the name "default" is assumed.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
         * This field is a regular expression.
         */
        tagName?: pulumi.Input<string>;
    }

    export interface TriggerWebhookConfig {
        /**
         * Resource name for the secret required as a URL parameter.
         */
        secret: pulumi.Input<string>;
        /**
         * (Output)
         * Potential issues with the underlying Pub/Sub subscription configuration.
         * Only populated on get requests.
         */
        state?: pulumi.Input<string>;
    }

    export interface WorkerPoolNetworkConfig {
        /**
         * Immutable. The network definition that the workers are peered to. If this section is left empty, the workers will be peered to `WorkerPool.project_id` on the service producer network. Must be in the format `projects/{project}/global/networks/{network}`, where `{project}` is a project number, such as `12345`, and `{network}` is the name of a VPC network in the project. See (https://cloud.google.com/cloud-build/docs/custom-workers/set-up-custom-worker-pool-environment#understanding_the_network_configuration_options)
         */
        peeredNetwork: pulumi.Input<string>;
        /**
         * Immutable. Subnet IP range within the peered network. This is specified in CIDR notation with a slash and the subnet prefix size. You can optionally specify an IP address before the subnet prefix value. e.g. `192.168.0.0/29` would specify an IP range starting at 192.168.0.0 with a prefix size of 29 bits. `/16` would specify a prefix size of 16 bits, with an automatically determined IP within the peered VPC. If unspecified, a value of `/24` will be used.
         */
        peeredNetworkIpRange?: pulumi.Input<string>;
    }

    export interface WorkerPoolPrivateServiceConnect {
        /**
         * Required. Immutable. The network attachment that the worker network interface is connected to. Must be in the format `projects/{project}/regions/{region}/networkAttachments/{networkAttachment}`. The region of network attachment must be the same as the worker pool. See [Network Attachments](https://cloud.google.com/vpc/docs/about-network-attachments)
         */
        networkAttachment: pulumi.Input<string>;
        /**
         * Immutable. Route all traffic through PSC interface. Enable this if you want full control of traffic in the private pool. Configure Cloud NAT for the subnet of network attachment if you need to access public Internet. If false, Only route private IPs, e.g. 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 through PSC interface.
         */
        routeAllTraffic?: pulumi.Input<boolean>;
    }

    export interface WorkerPoolWorkerConfig {
        /**
         * Size of the disk attached to the worker, in GB. See [diskSizeGb](https://cloud.google.com/build/docs/private-pools/private-pool-config-file-schema#disksizegb). Specify a value of up to 1000. If `0` is specified, Cloud Build will use a standard disk size.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Machine type of a worker, such as `n1-standard-1`. See [machineType](https://cloud.google.com/build/docs/private-pools/private-pool-config-file-schema#machinetype). If left blank, Cloud Build will use `n1-standard-1`.
         */
        machineType?: pulumi.Input<string>;
        /**
         * If true, workers are created without any public address, which prevents network egress to public IPs.
         */
        noExternalIp?: pulumi.Input<boolean>;
    }
}

export namespace cloudbuildv2 {
    export interface ConnectionBitbucketCloudConfig {
        /**
         * Required. An access token with the `webhook`, `repository`, `repository:admin` and `pullrequest` scope access. It can be either a workspace, project or repository access token. It's recommended to use a system account to generate these credentials.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionBitbucketCloudConfigAuthorizerCredential>;
        /**
         * Required. An access token with the `repository` access. It can be either a workspace, project or repository access token. It's recommended to use a system account to generate the credentials.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionBitbucketCloudConfigReadAuthorizerCredential>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook events, formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
        /**
         * The Bitbucket Cloud Workspace ID to be connected to Google Cloud Platform.
         */
        workspace: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketCloudConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketCloudConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfig {
        /**
         * Required. A http access token with the `REPO_ADMIN` scope access.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionBitbucketDataCenterConfigAuthorizerCredential>;
        /**
         * The URI of the Bitbucket Data Center host this connection is for.
         */
        hostUri: pulumi.Input<string>;
        /**
         * Required. A http access token with the `REPO_READ` access.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionBitbucketDataCenterConfigReadAuthorizerCredential>;
        /**
         * (Output)
         * Output only. Version of the Bitbucket Data Center running on the `hostUri`.
         */
        serverVersion?: pulumi.Input<string>;
        /**
         * Configuration for using Service Directory to privately connect to a Bitbucket Data Center. This should only be set if the Bitbucket Data Center is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the Bitbucket Data Center will be made over the public internet.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.cloudbuildv2.ConnectionBitbucketDataCenterConfigServiceDirectoryConfig>;
        /**
         * SSL certificate to use for requests to the Bitbucket Data Center.
         */
        sslCa?: pulumi.Input<string>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook events, formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionGithubConfig {
        /**
         * GitHub App installation id.
         */
        appInstallationId?: pulumi.Input<number>;
        /**
         * OAuth credential of the account that authorized the Cloud Build GitHub App. It is recommended to use a robot account instead of a human user account. The OAuth token must be tied to the Cloud Build GitHub App.
         * Structure is documented below.
         */
        authorizerCredential?: pulumi.Input<inputs.cloudbuildv2.ConnectionGithubConfigAuthorizerCredential>;
    }

    export interface ConnectionGithubConfigAuthorizerCredential {
        /**
         * A SecretManager resource containing the OAuth token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        oauthTokenSecretVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGithubEnterpriseConfig {
        /**
         * Id of the GitHub App created from the manifest.
         */
        appId?: pulumi.Input<number>;
        /**
         * ID of the installation of the GitHub App.
         */
        appInstallationId?: pulumi.Input<number>;
        /**
         * The URL-friendly name of the GitHub App.
         */
        appSlug?: pulumi.Input<string>;
        /**
         * Required. The URI of the GitHub Enterprise host this connection is for.
         */
        hostUri: pulumi.Input<string>;
        /**
         * SecretManager resource containing the private key of the GitHub App, formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        privateKeySecretVersion?: pulumi.Input<string>;
        /**
         * Configuration for using Service Directory to privately connect to a GitHub Enterprise server. This should only be set if the GitHub Enterprise server is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the GitHub Enterprise server will be made over the public internet.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.cloudbuildv2.ConnectionGithubEnterpriseConfigServiceDirectoryConfig>;
        /**
         * SSL certificate to use for requests to GitHub Enterprise.
         */
        sslCa?: pulumi.Input<string>;
        /**
         * SecretManager resource containing the webhook secret of the GitHub App, formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        webhookSecretSecretVersion?: pulumi.Input<string>;
    }

    export interface ConnectionGithubEnterpriseConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfig {
        /**
         * Required. A GitLab personal access token with the `api` scope access.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionGitlabConfigAuthorizerCredential>;
        /**
         * The URI of the GitLab Enterprise host this connection is for. If not specified, the default value is https://gitlab.com.
         */
        hostUri?: pulumi.Input<string>;
        /**
         * Required. A GitLab personal access token with the minimum `readApi` scope access.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.cloudbuildv2.ConnectionGitlabConfigReadAuthorizerCredential>;
        /**
         * (Output)
         * Output only. Version of the GitLab Enterprise server running on the `hostUri`.
         */
        serverVersion?: pulumi.Input<string>;
        /**
         * Configuration for using Service Directory to privately connect to a GitLab Enterprise server. This should only be set if the GitLab Enterprise server is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the GitLab Enterprise server will be made over the public internet.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.cloudbuildv2.ConnectionGitlabConfigServiceDirectoryConfig>;
        /**
         * SSL certificate to use for requests to GitLab Enterprise.
         */
        sslCa?: pulumi.Input<string>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret of a GitLab Enterprise project, formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated to this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConnectionIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConnectionInstallationState {
        /**
         * (Output)
         * Output only. Link to follow for next action. Empty string if the installation is already complete.
         */
        actionUri?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Message of what the user should do next to continue the installation. Empty string if the installation is already complete.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Current step of the installation process.
         */
        stage?: pulumi.Input<string>;
    }
}

export namespace clouddeploy {
    export interface AutomationRule {
        /**
         * Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
         * Structure is documented below.
         */
        advanceRolloutRule?: pulumi.Input<inputs.clouddeploy.AutomationRuleAdvanceRolloutRule>;
        /**
         * Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
         * Structure is documented below.
         */
        promoteReleaseRule?: pulumi.Input<inputs.clouddeploy.AutomationRulePromoteReleaseRule>;
        /**
         * Optional. The RepairRolloutRule will automatically repair a failed rollout.
         * Structure is documented below.
         */
        repairRolloutRule?: pulumi.Input<inputs.clouddeploy.AutomationRuleRepairRolloutRule>;
        /**
         * Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
         * Structure is documented below.
         */
        timedPromoteReleaseRule?: pulumi.Input<inputs.clouddeploy.AutomationRuleTimedPromoteReleaseRule>;
    }

    export interface AutomationRuleAdvanceRolloutRule {
        /**
         * Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
         */
        id: pulumi.Input<string>;
        /**
         * Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
         */
        sourcePhases?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. How long to wait after a rollout is finished.
         */
        wait?: pulumi.Input<string>;
    }

    export interface AutomationRulePromoteReleaseRule {
        /**
         * Optional. The starting phase of the rollout created by this operation. Default to the first phase.
         */
        destinationPhase?: pulumi.Input<string>;
        /**
         * Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
         */
        destinationTargetId?: pulumi.Input<string>;
        /**
         * Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
         */
        id: pulumi.Input<string>;
        /**
         * Optional. How long the release need to be paused until being promoted to the next target.
         */
        wait?: pulumi.Input<string>;
    }

    export interface AutomationRuleRepairRolloutRule {
        /**
         * Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
         */
        id: pulumi.Input<string>;
        /**
         * Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
         */
        jobs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
         */
        phases?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
         * Structure is documented below.
         */
        repairPhases?: pulumi.Input<pulumi.Input<inputs.clouddeploy.AutomationRuleRepairRolloutRuleRepairPhase>[]>;
    }

    export interface AutomationRuleRepairRolloutRuleRepairPhase {
        /**
         * Optional. Retries a failed job.
         * Structure is documented below.
         */
        retry?: pulumi.Input<inputs.clouddeploy.AutomationRuleRepairRolloutRuleRepairPhaseRetry>;
        /**
         * Optional. Rolls back a Rollout.
         * Structure is documented below.
         */
        rollback?: pulumi.Input<inputs.clouddeploy.AutomationRuleRepairRolloutRuleRepairPhaseRollback>;
    }

    export interface AutomationRuleRepairRolloutRuleRepairPhaseRetry {
        /**
         * Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
         */
        attempts: pulumi.Input<string>;
        /**
         * Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
         * Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
         */
        backoffMode?: pulumi.Input<string>;
        /**
         * Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
         */
        wait?: pulumi.Input<string>;
    }

    export interface AutomationRuleRepairRolloutRuleRepairPhaseRollback {
        /**
         * Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
         */
        destinationPhase?: pulumi.Input<string>;
        /**
         * Optional. If pending rollout exists on the target, the rollback operation will be aborted.
         */
        disableRollbackIfRolloutPending?: pulumi.Input<boolean>;
    }

    export interface AutomationRuleTimedPromoteReleaseRule {
        /**
         * Optional. The starting phase of the rollout created by this rule. Default to the first phase.
         *
         * - - -
         */
        destinationPhase?: pulumi.Input<string>;
        /**
         * Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
         * - The last segment of a target name
         * - "@next", the next target in the promotion sequence"
         */
        destinationTargetId?: pulumi.Input<string>;
        /**
         * Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
         */
        id: pulumi.Input<string>;
        /**
         * Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
         */
        schedule: pulumi.Input<string>;
        /**
         * Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
         */
        timeZone: pulumi.Input<string>;
    }

    export interface AutomationSelector {
        /**
         * Contains attributes about a target.
         * Structure is documented below.
         */
        targets: pulumi.Input<pulumi.Input<inputs.clouddeploy.AutomationSelectorTarget>[]>;
    }

    export interface AutomationSelectorTarget {
        /**
         * ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
         */
        id?: pulumi.Input<string>;
        /**
         * Target labels.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface CustomTargetTypeCustomActions {
        /**
         * The Skaffold custom action responsible for deploy operations.
         */
        deployAction: pulumi.Input<string>;
        /**
         * List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
         * Structure is documented below.
         */
        includeSkaffoldModules?: pulumi.Input<pulumi.Input<inputs.clouddeploy.CustomTargetTypeCustomActionsIncludeSkaffoldModule>[]>;
        /**
         * The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
         */
        renderAction?: pulumi.Input<string>;
    }

    export interface CustomTargetTypeCustomActionsIncludeSkaffoldModule {
        /**
         * The Skaffold Config modules to use from the specified source.
         */
        configs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Remote git repository containing the Skaffold Config modules.
         * Structure is documented below.
         */
        git?: pulumi.Input<inputs.clouddeploy.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit>;
        /**
         * Cloud Build 2nd gen repository containing the Skaffold Config modules.
         * Structure is documented below.
         */
        googleCloudBuildRepo?: pulumi.Input<inputs.clouddeploy.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo>;
        /**
         * Cloud Storage bucket containing Skaffold Config modules.
         * Structure is documented below.
         */
        googleCloudStorage?: pulumi.Input<inputs.clouddeploy.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage>;
    }

    export interface CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit {
        /**
         * Relative path from the repository root to the Skaffold file.
         */
        path?: pulumi.Input<string>;
        /**
         * Git ref the package should be cloned from.
         */
        ref?: pulumi.Input<string>;
        /**
         * Git repository the package should be cloned from.
         */
        repo: pulumi.Input<string>;
    }

    export interface CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo {
        /**
         * Relative path from the repository root to the Skaffold file.
         */
        path?: pulumi.Input<string>;
        /**
         * Branch or tag to use when cloning the repository.
         */
        ref?: pulumi.Input<string>;
        /**
         * Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
         */
        repository: pulumi.Input<string>;
    }

    export interface CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage {
        /**
         * Relative path from the source to the Skaffold file.
         */
        path?: pulumi.Input<string>;
        /**
         * Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
         */
        source: pulumi.Input<string>;
    }

    export interface CustomTargetTypeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface CustomTargetTypeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DeliveryPipelineCondition {
        /**
         * Details around the Pipeline's overall status.
         */
        pipelineReadyConditions?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineConditionPipelineReadyCondition>[]>;
        /**
         * Details around targets enumerated in the pipeline.
         */
        targetsPresentConditions?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineConditionTargetsPresentCondition>[]>;
        /**
         * Details on the whether the targets enumerated in the pipeline are of the same type.
         */
        targetsTypeConditions?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineConditionTargetsTypeCondition>[]>;
    }

    export interface DeliveryPipelineConditionPipelineReadyCondition {
        /**
         * True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
         */
        status?: pulumi.Input<boolean>;
        /**
         * Output only. Most recent time at which the pipeline was updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface DeliveryPipelineConditionTargetsPresentCondition {
        /**
         * The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
         */
        missingTargets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * True if there aren't any missing Targets.
         */
        status?: pulumi.Input<boolean>;
        /**
         * Output only. Most recent time at which the pipeline was updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface DeliveryPipelineConditionTargetsTypeCondition {
        /**
         * Human readable error message.
         */
        errorDetails?: pulumi.Input<string>;
        /**
         * True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
         */
        status?: pulumi.Input<boolean>;
    }

    export interface DeliveryPipelineIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DeliveryPipelineIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DeliveryPipelineSerialPipeline {
        /**
         * Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
         */
        stages?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStage>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStage {
        /**
         * Optional. The deploy parameters to use for the target in this stage.
         */
        deployParameters?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageDeployParameter>[]>;
        /**
         * Skaffold profiles to use when rendering the manifest for this stage's `Target`.
         */
        profiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. The strategy to use for a `Rollout` to this stage.
         */
        strategy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategy>;
        /**
         * The targetId to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
         */
        targetId?: pulumi.Input<string>;
    }

    export interface DeliveryPipelineSerialPipelineStageDeployParameter {
        /**
         * Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
         */
        matchTargetLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Required. Values are deploy parameters in key-value pairs.
         */
        values: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategy {
        /**
         * Canary deployment strategy provides progressive percentage based deployments to a Target.
         */
        canary?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanary>;
        /**
         * Standard deployment strategy executes a single deploy and allows verifying the deployment.
         */
        standard?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyStandard>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanary {
        /**
         * Configures the progressive based deployment for a Target.
         */
        canaryDeployment?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment>;
        /**
         * Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
         */
        customCanaryDeployment?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment>;
        /**
         * Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
         */
        runtimeConfig?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment {
        /**
         * Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
         */
        percentages: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
         */
        postdeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy>;
        /**
         * Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
         */
        predeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy>;
        /**
         * Whether to run verify tests after each percentage deployment.
         */
        verify?: pulumi.Input<boolean>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment {
        /**
         * Required. Configuration for each phase in the canary deployment in the order executed.
         */
        phaseConfigs: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig {
        /**
         * Required. Percentage deployment for the phase.
         */
        percentage: pulumi.Input<number>;
        /**
         * Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
         */
        phaseId: pulumi.Input<string>;
        /**
         * Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
         */
        postdeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy>;
        /**
         * Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
         */
        predeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy>;
        /**
         * Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
         */
        profiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to run verify tests after the deployment.
         */
        verify?: pulumi.Input<boolean>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig {
        /**
         * Cloud Run runtime configuration.
         */
        cloudRun?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun>;
        /**
         * Kubernetes runtime configuration.
         */
        kubernetes?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun {
        /**
         * Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
         */
        automaticTrafficControl?: pulumi.Input<boolean>;
        /**
         * Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
         */
        canaryRevisionTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
         */
        priorRevisionTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
         */
        stableRevisionTags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes {
        /**
         * Kubernetes Gateway API service mesh configuration.
         */
        gatewayServiceMesh?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh>;
        /**
         * Kubernetes Service networking configuration.
         */
        serviceNetworking?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh {
        /**
         * Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
         */
        deployment: pulumi.Input<string>;
        /**
         * Required. Name of the Gateway API HTTPRoute.
         */
        httpRoute: pulumi.Input<string>;
        /**
         * Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
         */
        podSelectorLabel?: pulumi.Input<string>;
        /**
         * Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
         */
        routeDestinations?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations>;
        /**
         * Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
         */
        routeUpdateWaitTime?: pulumi.Input<string>;
        /**
         * Required. Name of the Kubernetes Service.
         */
        service: pulumi.Input<string>;
        /**
         * Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
         */
        stableCutbackDuration?: pulumi.Input<string>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations {
        /**
         * Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
         */
        destinationIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
         */
        propagateService?: pulumi.Input<boolean>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking {
        /**
         * Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
         */
        deployment: pulumi.Input<string>;
        /**
         * Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
         */
        disablePodOverprovisioning?: pulumi.Input<boolean>;
        /**
         * Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
         */
        podSelectorLabel?: pulumi.Input<string>;
        /**
         * Required. Name of the Kubernetes Service.
         */
        service: pulumi.Input<string>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyStandard {
        /**
         * Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
         */
        postdeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy>;
        /**
         * Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
         */
        predeploy?: pulumi.Input<inputs.clouddeploy.DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy>;
        /**
         * Whether to verify a deployment.
         */
        verify?: pulumi.Input<boolean>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy {
        /**
         * Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeployPolicyRule {
        /**
         * Optional. Rollout restrictions.
         * Structure is documented below.
         */
        rolloutRestriction?: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestriction>;
    }

    export interface DeployPolicyRuleRolloutRestriction {
        /**
         * Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
         * Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
         */
        actions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
         */
        id: pulumi.Input<string>;
        /**
         * Optional. What invoked the action. If left empty, all invoker types will be restricted.
         * Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
         */
        invokers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. Time window within which actions are restricted.
         * Structure is documented below.
         */
        timeWindows?: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindows>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindows {
        /**
         * Optional. One-time windows within which actions are restricted.
         * Structure is documented below.
         */
        oneTimeWindows?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow>[]>;
        /**
         * Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
         */
        timeZone: pulumi.Input<string>;
        /**
         * Optional. Recurring weekly windows within which actions are restricted.
         * Structure is documented below.
         */
        weeklyWindows?: pulumi.Input<pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow>[]>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow {
        /**
         * Required. End date.
         * Structure is documented below.
         */
        endDate: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate>;
        /**
         * Required. End time (exclusive). You may use 24:00 for the end of the day.
         * Structure is documented below.
         */
        endTime: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime>;
        /**
         * Required. Start date.
         * Structure is documented below.
         */
        startDate: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate>;
        /**
         * Required. Start time (inclusive). Use 00:00 for the beginning of the day.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month.
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999.
         */
        year?: pulumi.Input<number>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime {
        /**
         * Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
         *
         * - - -
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime {
        /**
         * Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow {
        /**
         * Optional. Days of week. If left empty, all days of the week will be included.
         * Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        daysOfWeeks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
         * Structure is documented below.
         */
        endTime?: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime>;
        /**
         * Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
         * Structure is documented below.
         */
        startTime?: pulumi.Input<inputs.clouddeploy.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime {
        /**
         * Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
         *
         * - - -
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime {
        /**
         * Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface DeployPolicySelector {
        /**
         * Contains attributes about a delivery pipeline.
         * Structure is documented below.
         */
        deliveryPipeline?: pulumi.Input<inputs.clouddeploy.DeployPolicySelectorDeliveryPipeline>;
        /**
         * Contains attributes about a target.
         * Structure is documented below.
         */
        target?: pulumi.Input<inputs.clouddeploy.DeployPolicySelectorTarget>;
    }

    export interface DeployPolicySelectorDeliveryPipeline {
        /**
         * Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
         * - The last segment of a pipeline name
         * - "*", all delivery pipelines in a location
         */
        id?: pulumi.Input<string>;
        /**
         * DeliveryPipeline labels.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface DeployPolicySelectorTarget {
        /**
         * ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
         */
        id?: pulumi.Input<string>;
        /**
         * Target labels.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface TargetAnthosCluster {
        /**
         * Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface TargetAssociatedEntity {
        /**
         * Optional. Information specifying Anthos clusters as associated entities.
         */
        anthosClusters?: pulumi.Input<pulumi.Input<inputs.clouddeploy.TargetAssociatedEntityAnthosCluster>[]>;
        /**
         * The name for the key in the map for which this object is mapped to in the API
         */
        entityId: pulumi.Input<string>;
        /**
         * Optional. Information specifying GKE clusters as associated entities.
         */
        gkeClusters?: pulumi.Input<pulumi.Input<inputs.clouddeploy.TargetAssociatedEntityGkeCluster>[]>;
    }

    export interface TargetAssociatedEntityAnthosCluster {
        /**
         * Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface TargetAssociatedEntityGkeCluster {
        /**
         * Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
         */
        cluster?: pulumi.Input<string>;
        /**
         * Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
         */
        internalIp?: pulumi.Input<boolean>;
        /**
         * Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
         */
        proxyUrl?: pulumi.Input<string>;
    }

    export interface TargetCustomTarget {
        /**
         * Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
         */
        customTargetType: pulumi.Input<string>;
    }

    export interface TargetExecutionConfig {
        /**
         * Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
         */
        artifactStorage?: pulumi.Input<string>;
        /**
         * Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
         */
        executionTimeout?: pulumi.Input<string>;
        /**
         * Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Required. Usages when this configuration should be applied.
         */
        usages: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. If true, additional logging will be enabled when running builds in this execution environment.
         */
        verbose?: pulumi.Input<boolean>;
        /**
         * Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
         */
        workerPool?: pulumi.Input<string>;
    }

    export interface TargetGke {
        /**
         * Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
         */
        cluster?: pulumi.Input<string>;
        /**
         * Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dnsEndpoint` and `internalIp` cannot be set to true.
         */
        dnsEndpoint?: pulumi.Input<boolean>;
        /**
         * Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
         */
        internalIp?: pulumi.Input<boolean>;
        /**
         * Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
         */
        proxyUrl?: pulumi.Input<string>;
    }

    export interface TargetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TargetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TargetMultiTarget {
        /**
         * Required. The targetIds of this multiTarget.
         */
        targetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TargetRun {
        /**
         * Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
         */
        location: pulumi.Input<string>;
    }
}

export namespace clouddomains {
    export interface RegistrationContactSettings {
        /**
         * Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.
         * Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
         * avoid domain suspension.
         * Structure is documented below.
         */
        adminContact: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsAdminContact>;
        /**
         * Required. Privacy setting for the contacts associated with the Registration.
         * Values are PUBLIC_CONTACT_DATA, PRIVATE_CONTACT_DATA, and REDACTED_CONTACT_DATA
         */
        privacy: pulumi.Input<string>;
        /**
         * Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.
         * Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
         * avoid domain suspension.
         * Structure is documented below.
         */
        registrantContact: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsRegistrantContact>;
        /**
         * Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.
         * Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
         * avoid domain suspension.
         * Structure is documented below.
         */
        technicalContact: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsTechnicalContact>;
    }

    export interface RegistrationContactSettingsAdminContact {
        /**
         * Required. Email address of the contact.
         */
        email: pulumi.Input<string>;
        /**
         * Fax number of the contact in international format. For example, "+1-800-555-0123".
         */
        faxNumber?: pulumi.Input<string>;
        /**
         * Required. Phone number of the contact in international format. For example, "+1-800-555-0123".
         */
        phoneNumber: pulumi.Input<string>;
        /**
         * Required. Postal address of the contact.
         * Structure is documented below.
         */
        postalAddress: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsAdminContactPostalAddress>;
    }

    export interface RegistrationContactSettingsAdminContactPostalAddress {
        /**
         * Unstructured address lines describing the lower levels of an address.
         * Because values in addressLines do not have type information and may sometimes contain multiple values in a single
         * field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
         * "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), addressLanguage
         * is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
         * the most specific line of an address can be selected based on the language.
         */
        addressLines?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
         * a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
         * (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
         * this should be left unpopulated.
         */
        administrativeArea?: pulumi.Input<string>;
        /**
         * Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
         * where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.
         */
        locality?: pulumi.Input<string>;
        /**
         * The name of the organization at the address.
         */
        organization?: pulumi.Input<string>;
        /**
         * Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
         * they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
         * it might contain "care of" information.
         *
         * - - -
         */
        recipients?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
         * ensure the value is correct. See https://cldr.unicode.org/ and
         * https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
         */
        regionCode: pulumi.Input<string>;
    }

    export interface RegistrationContactSettingsRegistrantContact {
        /**
         * Required. Email address of the contact.
         */
        email: pulumi.Input<string>;
        /**
         * Fax number of the contact in international format. For example, "+1-800-555-0123".
         */
        faxNumber?: pulumi.Input<string>;
        /**
         * Required. Phone number of the contact in international format. For example, "+1-800-555-0123".
         */
        phoneNumber: pulumi.Input<string>;
        /**
         * Required. Postal address of the contact.
         * Structure is documented below.
         */
        postalAddress: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsRegistrantContactPostalAddress>;
    }

    export interface RegistrationContactSettingsRegistrantContactPostalAddress {
        /**
         * Unstructured address lines describing the lower levels of an address.
         * Because values in addressLines do not have type information and may sometimes contain multiple values in a single
         * field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
         * "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), addressLanguage
         * is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
         * the most specific line of an address can be selected based on the language.
         */
        addressLines?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
         * a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
         * (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
         * this should be left unpopulated.
         */
        administrativeArea?: pulumi.Input<string>;
        /**
         * Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
         * where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.
         */
        locality?: pulumi.Input<string>;
        /**
         * The name of the organization at the address.
         */
        organization?: pulumi.Input<string>;
        /**
         * Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
         * they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
         * it might contain "care of" information.
         *
         * - - -
         */
        recipients?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
         * ensure the value is correct. See https://cldr.unicode.org/ and
         * https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
         */
        regionCode: pulumi.Input<string>;
    }

    export interface RegistrationContactSettingsTechnicalContact {
        /**
         * Required. Email address of the contact.
         */
        email: pulumi.Input<string>;
        /**
         * Fax number of the contact in international format. For example, "+1-800-555-0123".
         */
        faxNumber?: pulumi.Input<string>;
        /**
         * Required. Phone number of the contact in international format. For example, "+1-800-555-0123".
         */
        phoneNumber: pulumi.Input<string>;
        /**
         * Required. Postal address of the contact.
         * Structure is documented below.
         */
        postalAddress: pulumi.Input<inputs.clouddomains.RegistrationContactSettingsTechnicalContactPostalAddress>;
    }

    export interface RegistrationContactSettingsTechnicalContactPostalAddress {
        /**
         * Unstructured address lines describing the lower levels of an address.
         * Because values in addressLines do not have type information and may sometimes contain multiple values in a single
         * field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
         * "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), addressLanguage
         * is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
         * the most specific line of an address can be selected based on the language.
         */
        addressLines?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
         * a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
         * (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
         * this should be left unpopulated.
         */
        administrativeArea?: pulumi.Input<string>;
        /**
         * Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
         * where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.
         */
        locality?: pulumi.Input<string>;
        /**
         * The name of the organization at the address.
         */
        organization?: pulumi.Input<string>;
        /**
         * Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
         * they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
         */
        postalCode?: pulumi.Input<string>;
        /**
         * The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
         * it might contain "care of" information.
         *
         * - - -
         */
        recipients?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
         * ensure the value is correct. See https://cldr.unicode.org/ and
         * https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
         */
        regionCode: pulumi.Input<string>;
    }

    export interface RegistrationDnsSettings {
        /**
         * Configuration for an arbitrary DNS provider.
         * Structure is documented below.
         */
        customDns?: pulumi.Input<inputs.clouddomains.RegistrationDnsSettingsCustomDns>;
        /**
         * The list of glue records for this Registration. Commonly empty.
         * Structure is documented below.
         */
        glueRecords?: pulumi.Input<pulumi.Input<inputs.clouddomains.RegistrationDnsSettingsGlueRecord>[]>;
    }

    export interface RegistrationDnsSettingsCustomDns {
        /**
         * The list of DS records for this domain, which are used to enable DNSSEC. The domain's DNS provider can provide
         * the values to set here. If this field is empty, DNSSEC is disabled.
         * Structure is documented below.
         */
        dsRecords?: pulumi.Input<pulumi.Input<inputs.clouddomains.RegistrationDnsSettingsCustomDnsDsRecord>[]>;
        /**
         * Required. A list of name servers that store the DNS zone for this domain. Each name server is a domain
         * name, with Unicode domain names expressed in Punycode format.
         */
        nameServers: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegistrationDnsSettingsCustomDnsDsRecord {
        /**
         * The algorithm used to generate the referenced DNSKEY.
         */
        algorithm?: pulumi.Input<string>;
        /**
         * The digest generated from the referenced DNSKEY.
         */
        digest?: pulumi.Input<string>;
        /**
         * The hash function used to generate the digest of the referenced DNSKEY.
         */
        digestType?: pulumi.Input<string>;
        /**
         * The key tag of the record. Must be set in range 0 -- 65535.
         */
        keyTag?: pulumi.Input<number>;
    }

    export interface RegistrationDnsSettingsGlueRecord {
        /**
         * Required. Domain name of the host in Punycode format.
         */
        hostName: pulumi.Input<string>;
        /**
         * List of IPv4 addresses corresponding to this host in the standard decimal format (e.g. 198.51.100.1).
         * At least one of ipv4Address and ipv6Address must be set.
         */
        ipv4Addresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of IPv4 addresses corresponding to this host in the standard decimal format (e.g. 198.51.100.1).
         * At least one of ipv4Address and ipv6Address must be set.
         */
        ipv6Addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegistrationManagementSettings {
        /**
         * The desired renewal method for this Registration. The actual renewalMethod is automatically updated to reflect this choice.
         * If unset or equal to RENEWAL_METHOD_UNSPECIFIED, the actual renewalMethod is treated as if it were set to AUTOMATIC_RENEWAL.
         * You cannot use RENEWAL_DISABLED during resource creation, and you can update the renewal status only when the Registration
         * resource has state ACTIVE or SUSPENDED.
         * When preferredRenewalMethod is set to AUTOMATIC_RENEWAL, the actual renewalMethod can be set to RENEWAL_DISABLED in case of
         * problems with the billing account or reported domain abuse. In such cases, check the issues field on the Registration. After
         * the problem is resolved, the renewalMethod is automatically updated to preferredRenewalMethod in a few hours.
         */
        preferredRenewalMethod?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The actual renewal method for this Registration. When preferredRenewalMethod is set to AUTOMATIC_RENEWAL,
         * the actual renewalMethod can be equal to RENEWAL_DISABLEDfor example, when there are problems with the billing account
         * or reported domain abuse. In such cases, check the issues field on the Registration. After the problem is resolved, the
         * renewalMethod is automatically updated to preferredRenewalMethod in a few hours.
         */
        renewalMethod?: pulumi.Input<string>;
        /**
         * Controls whether the domain can be transferred to another registrar. Values are UNLOCKED or LOCKED.
         */
        transferLockState?: pulumi.Input<string>;
    }

    export interface RegistrationYearlyPrice {
        /**
         * The three-letter currency code defined in ISO 4217.
         */
        currencyCode?: pulumi.Input<string>;
        /**
         * The whole units of the amount. For example if currencyCode is "USD", then 1 unit is one US dollar.
         */
        units?: pulumi.Input<string>;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
         * full reference of accepted triggers.
         */
        eventType: pulumi.Input<string>;
        /**
         * Specifies policy for failed executions. Structure is documented below.
         */
        failurePolicy?: pulumi.Input<inputs.cloudfunctions.FunctionEventTriggerFailurePolicy>;
        /**
         * Required. The name or partial URI of the resource from
         * which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
         */
        resource: pulumi.Input<string>;
    }

    export interface FunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure. Defaults to `false`.
         */
        retry: pulumi.Input<boolean>;
    }

    export interface FunctionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionSecretEnvironmentVariable {
        /**
         * Name of the environment variable.
         */
        key: pulumi.Input<string>;
        /**
         * Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
         */
        projectId?: pulumi.Input<string>;
        /**
         * ID of the secret in secret manager (not the full resource name).
         */
        secret: pulumi.Input<string>;
        /**
         * Version of the secret (version number or the string "latest"). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new clones start.
         */
        version: pulumi.Input<string>;
    }

    export interface FunctionSecretVolume {
        /**
         * The path within the container to mount the secret volume. For example, setting the mountPath as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".
         */
        mountPath: pulumi.Input<string>;
        /**
         * Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
         */
        projectId?: pulumi.Input<string>;
        /**
         * ID of the secret in secret manager (not the full resource name).
         */
        secret: pulumi.Input<string>;
        /**
         * List of secret versions to mount for this secret. If empty, the "latest" version of the secret will be made available in a file named after the secret under the mount point. Structure is documented below.
         */
        versions?: pulumi.Input<pulumi.Input<inputs.cloudfunctions.FunctionSecretVolumeVersion>[]>;
    }

    export interface FunctionSecretVolumeVersion {
        /**
         * Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as "/etc/secrets" and path as "/secret_foo" would mount the secret value file at "/etc/secrets/secret_foo".
         */
        path: pulumi.Input<string>;
        /**
         * Version of the secret (version number or the string "latest"). It is preferable to use "latest" version with secret volumes as secret value changes are reflected immediately.
         */
        version: pulumi.Input<string>;
    }

    export interface FunctionSourceRepository {
        /**
         * The URL pointing to the hosted repository where the function was defined at the time of deployment.
         */
        deployedUrl?: pulumi.Input<string>;
        /**
         * The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:
         *
         * * To refer to a specific commit: `https://source.developers.google.com/projects/*&#47;repos/*&#47;revisions/*&#47;paths/*`
         * * To refer to a moveable alias (branch): `https://source.developers.google.com/projects/*&#47;repos/*&#47;moveable-aliases/*&#47;paths/*`. To refer to HEAD, use the `master` moveable alias.
         * * To refer to a specific fixed alias (tag): `https://source.developers.google.com/projects/*&#47;repos/*&#47;fixed-aliases/*&#47;paths/*`
         */
        url: pulumi.Input<string>;
    }

}

export namespace cloudfunctionsv2 {
    export interface FunctionBuildConfig {
        /**
         * Security patches are applied automatically to the runtime without requiring
         * the function to be redeployed.
         */
        automaticUpdatePolicy?: pulumi.Input<inputs.cloudfunctionsv2.FunctionBuildConfigAutomaticUpdatePolicy>;
        /**
         * (Output)
         * The Cloud Build name of the latest successful
         * deployment of the function.
         */
        build?: pulumi.Input<string>;
        /**
         * User managed repository created in Artifact Registry optionally with a customer managed encryption key.
         */
        dockerRepository?: pulumi.Input<string>;
        /**
         * The name of the function (as defined in source code) that will be executed.
         * Defaults to the resource name suffix, if not specified. For backward
         * compatibility, if function with given name is not found, then the system
         * will try to use function named "function". For Node.js this is name of a
         * function exported by the module specified in source_location.
         */
        entryPoint?: pulumi.Input<string>;
        /**
         * User-provided build-time environment variables for the function.
         */
        environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Security patches are only applied when a function is redeployed.
         * Structure is documented below.
         */
        onDeployUpdatePolicy?: pulumi.Input<inputs.cloudfunctionsv2.FunctionBuildConfigOnDeployUpdatePolicy>;
        /**
         * The runtime in which to run the function. Required when deploying a new
         * function, optional when updating an existing function.
         */
        runtime?: pulumi.Input<string>;
        /**
         * The fully-qualified name of the service account to be used for building the container.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The location of the function source code.
         * Structure is documented below.
         */
        source?: pulumi.Input<inputs.cloudfunctionsv2.FunctionBuildConfigSource>;
        /**
         * Name of the Cloud Build Custom Worker Pool that should be used to build the function.
         */
        workerPool?: pulumi.Input<string>;
    }

    export interface FunctionBuildConfigAutomaticUpdatePolicy {
    }

    export interface FunctionBuildConfigOnDeployUpdatePolicy {
        /**
         * (Output)
         * The runtime version which was used during latest function deployment.
         */
        runtimeVersion?: pulumi.Input<string>;
    }

    export interface FunctionBuildConfigSource {
        /**
         * If provided, get the source from this location in a Cloud Source Repository.
         * Structure is documented below.
         */
        repoSource?: pulumi.Input<inputs.cloudfunctionsv2.FunctionBuildConfigSourceRepoSource>;
        /**
         * If provided, get the source from this location in Google Cloud Storage.
         * Structure is documented below.
         */
        storageSource?: pulumi.Input<inputs.cloudfunctionsv2.FunctionBuildConfigSourceStorageSource>;
    }

    export interface FunctionBuildConfigSourceRepoSource {
        /**
         * Regex matching branches to build.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Regex matching tags to build.
         */
        commitSha?: pulumi.Input<string>;
        /**
         * Directory, relative to the source root, in which to run the build.
         */
        dir?: pulumi.Input<string>;
        /**
         * Only trigger a build if the revision regex does
         * NOT match the revision regex.
         */
        invertRegex?: pulumi.Input<boolean>;
        /**
         * ID of the project that owns the Cloud Source Repository. If omitted, the
         * project ID requesting the build is assumed.
         */
        projectId?: pulumi.Input<string>;
        /**
         * Name of the Cloud Source Repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Regex matching tags to build.
         */
        tagName?: pulumi.Input<string>;
    }

    export interface FunctionBuildConfigSourceStorageSource {
        /**
         * Google Cloud Storage bucket containing the source
         */
        bucket?: pulumi.Input<string>;
        /**
         * Google Cloud Storage generation for the object. If the generation
         * is omitted, the latest generation will be used.
         */
        generation?: pulumi.Input<number>;
        /**
         * Google Cloud Storage object containing the source.
         */
        object?: pulumi.Input<string>;
    }

    export interface FunctionEventTrigger {
        /**
         * Criteria used to filter events.
         * Structure is documented below.
         */
        eventFilters?: pulumi.Input<pulumi.Input<inputs.cloudfunctionsv2.FunctionEventTriggerEventFilter>[]>;
        /**
         * Required. The type of event to observe.
         */
        eventType?: pulumi.Input<string>;
        /**
         * The name of a Pub/Sub topic in the same project that will be used
         * as the transport topic for the event delivery.
         */
        pubsubTopic?: pulumi.Input<string>;
        /**
         * Describes the retry policy in case of function's execution failure.
         * Retried execution is charged as any other execution.
         * Possible values are: `RETRY_POLICY_UNSPECIFIED`, `RETRY_POLICY_DO_NOT_RETRY`, `RETRY_POLICY_RETRY`.
         */
        retryPolicy?: pulumi.Input<string>;
        /**
         * Optional. The email of the trigger's service account. The service account
         * must have permission to invoke Cloud Run services. If empty, defaults to the
         * Compute Engine default service account: {project_number}-compute@developer.gserviceaccount.com.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The resource name of the Eventarc trigger.
         */
        trigger?: pulumi.Input<string>;
        /**
         * The region that the trigger will be in. The trigger will only receive
         * events originating in this region. It can be the same
         * region as the function, a different region or multi-region, or the global
         * region. If not provided, defaults to the same region as the function.
         */
        triggerRegion?: pulumi.Input<string>;
    }

    export interface FunctionEventTriggerEventFilter {
        /**
         * 'Required. The name of a CloudEvents attribute.
         * Currently, only a subset of attributes are supported for filtering. Use the `gcloud eventarc providers describe` command to learn more about events and their attributes.
         * Do not filter for the 'type' attribute here, as this is already achieved by the resource's `eventType` attribute.
         */
        attribute: pulumi.Input<string>;
        /**
         * Optional. The operator used for matching the events with the value of
         * the filter. If not specified, only events that have an exact key-value
         * pair specified in the filter are matched.
         * The only allowed value is `match-path-pattern`.
         * [See documentation on path patterns here](https://cloud.google.com/eventarc/docs/path-patterns)'
         */
        operator?: pulumi.Input<string>;
        /**
         * Required. The value for the attribute.
         * If the operator field is set as `match-path-pattern`, this value can be a path pattern instead of an exact value.
         */
        value: pulumi.Input<string>;
    }

    export interface FunctionIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FunctionServiceConfig {
        /**
         * Whether 100% of traffic is routed to the latest revision. Defaults to true.
         */
        allTrafficOnLatestRevision?: pulumi.Input<boolean>;
        /**
         * The number of CPUs used in a single container instance. Default value is calculated from available memory.
         */
        availableCpu?: pulumi.Input<string>;
        /**
         * The amount of memory available for a function.
         * Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
         * supplied the value is interpreted as bytes.
         */
        availableMemory?: pulumi.Input<string>;
        /**
         * The binary authorization policy to be checked when deploying the Cloud Run service.
         */
        binaryAuthorizationPolicy?: pulumi.Input<string>;
        /**
         * Environment variables that shall be available during function execution.
         */
        environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * URIs of the Service deployed
         */
        gcfUri?: pulumi.Input<string>;
        /**
         * Available ingress settings. Defaults to "ALLOW_ALL" if unspecified.
         * Default value is `ALLOW_ALL`.
         * Possible values are: `ALLOW_ALL`, `ALLOW_INTERNAL_ONLY`, `ALLOW_INTERNAL_AND_GCLB`.
         */
        ingressSettings?: pulumi.Input<string>;
        /**
         * The limit on the maximum number of function instances that may coexist at a
         * given time.
         */
        maxInstanceCount?: pulumi.Input<number>;
        /**
         * Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.
         */
        maxInstanceRequestConcurrency?: pulumi.Input<number>;
        /**
         * The limit on the minimum number of function instances that may coexist at a
         * given time.
         */
        minInstanceCount?: pulumi.Input<number>;
        /**
         * Secret environment variables configuration.
         * Structure is documented below.
         */
        secretEnvironmentVariables?: pulumi.Input<pulumi.Input<inputs.cloudfunctionsv2.FunctionServiceConfigSecretEnvironmentVariable>[]>;
        /**
         * Secret volumes configuration.
         * Structure is documented below.
         */
        secretVolumes?: pulumi.Input<pulumi.Input<inputs.cloudfunctionsv2.FunctionServiceConfigSecretVolume>[]>;
        /**
         * Name of the service associated with a Function.
         */
        service?: pulumi.Input<string>;
        /**
         * The email of the service account for this function.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * The function execution timeout. Execution is considered failed and
         * can be terminated if the function is not completed at the end of the
         * timeout period. Defaults to 60 seconds.
         */
        timeoutSeconds?: pulumi.Input<number>;
        /**
         * (Output)
         * URI of the Service deployed.
         */
        uri?: pulumi.Input<string>;
        /**
         * The Serverless VPC Access connector that this cloud function can connect to.
         */
        vpcConnector?: pulumi.Input<string>;
        /**
         * Available egress settings.
         * Possible values are: `VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED`, `PRIVATE_RANGES_ONLY`, `ALL_TRAFFIC`.
         */
        vpcConnectorEgressSettings?: pulumi.Input<string>;
    }

    export interface FunctionServiceConfigSecretEnvironmentVariable {
        /**
         * Name of the environment variable.
         */
        key: pulumi.Input<string>;
        /**
         * Project identifier (preferably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
         */
        projectId: pulumi.Input<string>;
        /**
         * Name of the secret in secret manager (not the full resource name).
         */
        secret: pulumi.Input<string>;
        /**
         * Version of the secret (version number or the string 'latest'). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new instances start.
         */
        version: pulumi.Input<string>;
    }

    export interface FunctionServiceConfigSecretVolume {
        /**
         * The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets
         */
        mountPath: pulumi.Input<string>;
        /**
         * Project identifier (preferably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.
         */
        projectId: pulumi.Input<string>;
        /**
         * Name of the secret in secret manager (not the full resource name).
         */
        secret: pulumi.Input<string>;
        /**
         * List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.'
         * Structure is documented below.
         */
        versions?: pulumi.Input<pulumi.Input<inputs.cloudfunctionsv2.FunctionServiceConfigSecretVolumeVersion>[]>;
    }

    export interface FunctionServiceConfigSecretVolumeVersion {
        /**
         * Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secretFoo would mount the secret value file at /etc/secrets/secret_foo.
         */
        path: pulumi.Input<string>;
        /**
         * Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.
         */
        version: pulumi.Input<string>;
    }

}

export namespace cloudidentity {
    export interface GetGroupLookupGroupKey {
        /**
         * (Required) The ID of the entity.
         * For Google-managed entities, the id is the email address of an existing group or user.
         * For external-identity-mapped entities, the id is a string conforming
         * to the Identity Source's requirements.
         */
        id: string;
        /**
         * (Optional) The namespace in which the entity exists.
         * If not populated, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If populated, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         */
        namespace?: string;
    }

    export interface GetGroupLookupGroupKeyArgs {
        /**
         * (Required) The ID of the entity.
         * For Google-managed entities, the id is the email address of an existing group or user.
         * For external-identity-mapped entities, the id is a string conforming
         * to the Identity Source's requirements.
         */
        id: pulumi.Input<string>;
        /**
         * (Optional) The namespace in which the entity exists.
         * If not populated, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If populated, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GroupAdditionalGroupKey {
        /**
         * (Output)
         * The ID of the entity.
         * For Google-managed entities, the id must be the email address of an existing
         * group or user.
         * For external-identity-mapped entities, the id must be a string conforming
         * to the Identity Source's requirements.
         * Must be unique within a namespace.
         */
        id?: pulumi.Input<string>;
        /**
         * (Output)
         * The namespace in which the entity exists.
         * If not specified, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If specified, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GroupGroupKey {
        /**
         * The ID of the entity.
         * For Google-managed entities, the id must be the email address of an existing
         * group or user.
         * For external-identity-mapped entities, the id must be a string conforming
         * to the Identity Source's requirements.
         * Must be unique within a namespace.
         */
        id: pulumi.Input<string>;
        /**
         * The namespace in which the entity exists.
         * If not specified, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If specified, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         *
         * - - -
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GroupMembershipMemberKey {
        /**
         * The ID of the entity.
         * For Google-managed entities, the id must be the email address of an existing
         * group or user.
         * For external-identity-mapped entities, the id must be a string conforming
         * to the Identity Source's requirements.
         * Must be unique within a namespace.
         */
        id: pulumi.Input<string>;
        /**
         * The namespace in which the entity exists.
         * If not specified, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If specified, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GroupMembershipPreferredMemberKey {
        /**
         * The ID of the entity.
         * For Google-managed entities, the id must be the email address of an existing
         * group or user.
         * For external-identity-mapped entities, the id must be a string conforming
         * to the Identity Source's requirements.
         * Must be unique within a namespace.
         */
        id: pulumi.Input<string>;
        /**
         * The namespace in which the entity exists.
         * If not specified, the EntityKey represents a Google-managed entity
         * such as a Google user or a Google Group.
         * If specified, the EntityKey represents an external-identity-mapped group.
         * The namespace must correspond to an identity source created in Admin Console
         * and must be in the form of `identitysources/{identity_source_id}`.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GroupMembershipRole {
        /**
         * The MembershipRole expiry details, only supported for MEMBER role.
         * Other roles cannot be accompanied with MEMBER role having expiry.
         * Structure is documented below.
         */
        expiryDetail?: pulumi.Input<inputs.cloudidentity.GroupMembershipRoleExpiryDetail>;
        /**
         * The name of the MembershipRole. Must be one of OWNER, MANAGER, MEMBER.
         * Possible values are: `OWNER`, `MANAGER`, `MEMBER`.
         */
        name: pulumi.Input<string>;
    }

    export interface GroupMembershipRoleExpiryDetail {
        /**
         * The time at which the MembershipRole will expire.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         *
         * - - -
         */
        expireTime: pulumi.Input<string>;
    }
}

export namespace cloudquota {
    export interface SQuotaPreferenceQuotaConfig {
        /**
         * The annotations map for clients to store small amounts of arbitrary data. Do not put PII or other sensitive information here. See https://google.aip.dev/128#annotations.
         * An object containing a list of "key: value" pairs. Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Granted quota value.
         */
        grantedValue?: pulumi.Input<string>;
        /**
         * The preferred value. Must be greater than or equal to -1. If set to -1, it means the value is "unlimited".
         */
        preferredValue: pulumi.Input<string>;
        /**
         * (Output)
         * The origin of the quota preference request.
         *
         * - - -
         */
        requestOrigin?: pulumi.Input<string>;
        /**
         * (Output)
         * Optional details about the state of this quota preference.
         */
        stateDetail?: pulumi.Input<string>;
        /**
         * (Output)
         * The trace id that the Google Cloud uses to provision the requested quota. This trace id may be used by the client to contact Cloud support to track the state of a quota preference request. The trace id is only produced for increase requests and is unique for each request. The quota decrease requests do not have a trace id.
         */
        traceId?: pulumi.Input<string>;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        /**
         * Annotations is a key value map stored with a resource that
         * may be set by external tools to store and retrieve arbitrary metadata.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
         * **Note**: The Cloud Run API may add additional annotations that were not provided in your config.
         * If the provider plan shows a diff where a server-side annotation is added, you can add it to your config
         * or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        effectiveAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
         */
        effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * A sequence number representing a specific generation of the desired state.
         */
        generation?: pulumi.Input<number>;
        /**
         * Map of string keys and values that can be used to organize and categorize
         * (scope and select) objects. May match selectors of replication controllers
         * and routes.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * In Cloud Run the namespace must be equal to either the
         * project ID or project number.
         */
        namespace: pulumi.Input<string>;
        /**
         * (Output)
         * The combination of labels configured directly on the resource
         * and default labels configured on the provider.
         */
        pulumiLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * An opaque value that represents the internal version of this object that
         * can be used by clients to determine when objects have changed. May be used
         * for optimistic concurrency, change detection, and the watch operation on a
         * resource or set of resources. They may only be valid for a
         * particular resource or set of resources.
         * More info:
         * https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
         */
        resourceVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * SelfLink is a URL representing this object.
         */
        selfLink?: pulumi.Input<string>;
        /**
         * (Output)
         * UID is a unique id generated by the server on successful creation of a resource and is not
         * allowed to change on PUT operations.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
         */
        uid?: pulumi.Input<string>;
    }

    export interface DomainMappingSpec {
        /**
         * The mode of the certificate.
         * Default value is `AUTOMATIC`.
         * Possible values are: `NONE`, `AUTOMATIC`.
         *
         * - - -
         */
        certificateMode?: pulumi.Input<string>;
        /**
         * If set, the mapping will override any mapping set before this spec was set.
         * It is recommended that the user leaves this empty to receive an error
         * warning about a potential conflict and only set it once the respective UI
         * has given such a warning.
         */
        forceOverride?: pulumi.Input<boolean>;
        /**
         * The name of the Cloud Run Service that this DomainMapping applies to.
         * The route must exist.
         */
        routeName: pulumi.Input<string>;
    }

    export interface DomainMappingStatus {
        /**
         * (Output)
         * Array of observed DomainMappingConditions, indicating the current state
         * of the DomainMapping.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusCondition>[]>;
        /**
         * (Output)
         * The name of the route that the mapping currently points to.
         */
        mappedRouteName?: pulumi.Input<string>;
        /**
         * (Output)
         * ObservedGeneration is the 'Generation' of the DomainMapping that
         * was last processed by the controller.
         */
        observedGeneration?: pulumi.Input<number>;
        /**
         * The resource records required to configure this domain mapping. These
         * records must be added to the domain's DNS configuration in order to
         * serve the application via this domain mapping.
         * Structure is documented below.
         */
        resourceRecords?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusResourceRecord>[]>;
    }

    export interface DomainMappingStatusCondition {
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * One-word CamelCase reason for the condition's current status.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * Status of the condition, one of True, False, Unknown.
         */
        status?: pulumi.Input<string>;
        /**
         * Resource record type. Example: `AAAA`.
         * Possible values are: `A`, `AAAA`, `CNAME`.
         */
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingStatusResourceRecord {
        /**
         * Name should be a [verified](https://support.google.com/webmasters/answer/9008080) domain
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * Data for this record. Values vary by record type, as defined in RFC 1035
         * (section 5) and RFC 1034 (section 3.6.1).
         */
        rrdata?: pulumi.Input<string>;
        /**
         * Resource record type. Example: `AAAA`.
         * Possible values are: `A`, `AAAA`, `CNAME`.
         */
        type?: pulumi.Input<string>;
    }

    export interface IamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceMetadata {
        /**
         * Annotations is a key value map stored with a resource that
         * may be set by external tools to store and retrieve arbitrary metadata.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
         * **Note**: The Cloud Run API may add additional annotations that were not provided in your config.
         * If the provider plan shows a diff where a server-side annotation is added, you can add it to your config
         * or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.
         * Annotations with `run.googleapis.com/` and `autoscaling.knative.dev` are restricted. Use the following annotation
         * keys to configure features on a Service:
         * - `run.googleapis.com/binary-authorization-breakglass` sets the [Binary Authorization breakglass](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--breakglass).
         * - `run.googleapis.com/binary-authorization` sets the [Binary Authorization](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--binary-authorization).
         * - `run.googleapis.com/client-name` sets the client name calling the Cloud Run API.
         * - `run.googleapis.com/custom-audiences` sets the [custom audiences](https://cloud.google.com/sdk/gcloud/reference/alpha/run/deploy#--add-custom-audiences)
         * that can be used in the audience field of ID token for authenticated requests.
         * - `run.googleapis.com/description` sets a user defined description for the Service.
         * - `run.googleapis.com/ingress` sets the [ingress settings](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--ingress)
         * for the Service. For example, `"run.googleapis.com/ingress" = "all"`.
         * - `run.googleapis.com/launch-stage` sets the [launch stage](https://cloud.google.com/run/docs/troubleshooting#launch-stage-validation)
         * when a preview feature is used. For example, `"run.googleapis.com/launch-stage": "BETA"`
         * - `run.googleapis.com/minScale` sets the [minimum number of container instances](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--min) of the Service.
         * - `run.googleapis.com/scalingMode` sets the type of scaling mode for the service. The supported values for scaling mode are "manual" and "automatic". If not provided, it defaults to "automatic".
         * - `run.googleapis.com/manualInstanceCount` sets the total instance count for the service in manual scaling mode. This number of instances is divided among all revisions with specified traffic based on the percent of traffic they are receiving.
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        effectiveAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
         */
        effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * A sequence number representing a specific generation of the desired state.
         */
        generation?: pulumi.Input<number>;
        /**
         * Map of string keys and values that can be used to organize and categorize
         * (scope and select) objects. May match selectors of replication controllers
         * and routes.
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * In Cloud Run the namespace must be equal to either the
         * project ID or project number.
         */
        namespace?: pulumi.Input<string>;
        /**
         * (Output)
         * The combination of labels configured directly on the resource
         * and default labels configured on the provider.
         */
        pulumiLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * An opaque value that represents the internal version of this object that
         * can be used by clients to determine when objects have changed. May be used
         * for optimistic concurrency, change detection, and the watch operation on a
         * resource or set of resources. They may only be valid for a
         * particular resource or set of resources.
         */
        resourceVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * SelfLink is a URL representing this object.
         */
        selfLink?: pulumi.Input<string>;
        /**
         * (Output)
         * UID is a unique id generated by the server on successful creation of a resource and is not
         * allowed to change on PUT operations.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ServiceStatus {
        /**
         * (Output)
         * Array of observed Service Conditions, indicating the current ready state of the service.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceStatusCondition>[]>;
        /**
         * (Output)
         * From ConfigurationStatus. LatestCreatedRevisionName is the last revision that was created
         * from this Service's Configuration. It might not be ready yet, for that use
         * LatestReadyRevisionName.
         */
        latestCreatedRevisionName?: pulumi.Input<string>;
        /**
         * (Output)
         * From ConfigurationStatus. LatestReadyRevisionName holds the name of the latest Revision
         * stamped out from this Service's Configuration that has had its "Ready" condition become
         * "True".
         */
        latestReadyRevisionName?: pulumi.Input<string>;
        /**
         * (Output)
         * ObservedGeneration is the 'Generation' of the Route that was last processed by the
         * controller.
         * Clients polling for completed reconciliation should poll until observedGeneration =
         * metadata.generation and the Ready condition's status is True or False.
         */
        observedGeneration?: pulumi.Input<number>;
        /**
         * (Output)
         * Traffic specifies how to distribute traffic over a collection of Knative Revisions
         * and Configurations
         * Structure is documented below.
         */
        traffics?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceStatusTraffic>[]>;
        /**
         * (Output)
         * URL displays the URL for accessing tagged traffic targets. URL is displayed in status,
         * and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname,
         * but may not contain anything else (e.g. basic auth, url path, etc.)
         */
        url?: pulumi.Input<string>;
    }

    export interface ServiceStatusCondition {
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * One-word CamelCase reason for the condition's current status.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * Status of the condition, one of True, False, Unknown.
         */
        status?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of domain mapping condition.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServiceStatusTraffic {
        /**
         * LatestRevision may be optionally provided to indicate that the latest ready
         * Revision of the Configuration should be used for this traffic target. When
         * provided LatestRevision must be true if RevisionName is empty; it must be
         * false when RevisionName is non-empty.
         */
        latestRevision?: pulumi.Input<boolean>;
        /**
         * Percent specifies percent of the traffic to this Revision or Configuration.
         */
        percent?: pulumi.Input<number>;
        /**
         * RevisionName of a specific revision to which to send this portion of traffic.
         */
        revisionName?: pulumi.Input<string>;
        /**
         * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
         */
        tag?: pulumi.Input<string>;
        /**
         * (Output)
         * URL displays the URL for accessing tagged traffic targets. URL is displayed in status,
         * and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname,
         * but may not contain anything else (e.g. basic auth, url path, etc.)
         */
        url?: pulumi.Input<string>;
    }

    export interface ServiceTemplate {
        /**
         * Optional metadata for this Revision, including labels and annotations.
         * Name will be generated by the Configuration. To set minimum instances
         * for this revision, use the "autoscaling.knative.dev/minScale" annotation
         * key. To set maximum instances for this revision, use the
         * "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL
         * connections for the revision, use the "run.googleapis.com/cloudsql-instances"
         * annotation key.
         * Structure is documented below.
         */
        metadata?: pulumi.Input<inputs.cloudrun.ServiceTemplateMetadata>;
        /**
         * RevisionSpec holds the desired state of the Revision (from the client).
         * Structure is documented below.
         */
        spec?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpec>;
    }

    export interface ServiceTemplateMetadata {
        /**
         * Annotations is a key value map stored with a resource that
         * may be set by external tools to store and retrieve arbitrary metadata.
         * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
         * **Note**: The Cloud Run API may add additional annotations that were not provided in your config.
         * If the provider plan shows a diff where a server-side annotation is added, you can add it to your config
         * or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.
         * Annotations with `run.googleapis.com/` and `autoscaling.knative.dev` are restricted. Use the following annotation
         * keys to configure features on a Service:
         * - `run.googleapis.com/binary-authorization-breakglass` sets the [Binary Authorization breakglass](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--breakglass).
         * - `run.googleapis.com/binary-authorization` sets the [Binary Authorization](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--binary-authorization).
         * - `run.googleapis.com/client-name` sets the client name calling the Cloud Run API.
         * - `run.googleapis.com/custom-audiences` sets the [custom audiences](https://cloud.google.com/sdk/gcloud/reference/alpha/run/deploy#--add-custom-audiences)
         * that can be used in the audience field of ID token for authenticated requests.
         * - `run.googleapis.com/description` sets a user defined description for the Service.
         * - `run.googleapis.com/ingress` sets the [ingress settings](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--ingress)
         * for the Service. For example, `"run.googleapis.com/ingress" = "all"`.
         * - `run.googleapis.com/launch-stage` sets the [launch stage](https://cloud.google.com/run/docs/troubleshooting#launch-stage-validation)
         * when a preview feature is used. For example, `"run.googleapis.com/launch-stage": "BETA"`
         * - `run.googleapis.com/minScale` sets the [minimum number of container instances](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--min) of the Service.
         * - `run.googleapis.com/scalingMode` sets the type of scaling mode for the service. The supported values for scaling mode are "manual" and "automatic". If not provided, it defaults to "automatic".
         * - `run.googleapis.com/manualInstanceCount` sets the total instance count for the service in manual scaling mode. This number of instances is divided among all revisions with specified traffic based on the percent of traffic they are receiving.
         * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
         * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * A sequence number representing a specific generation of the desired state.
         */
        generation?: pulumi.Input<number>;
        /**
         * Map of string keys and values that can be used to organize and categorize
         * (scope and select) objects. May match selectors of replication controllers
         * and routes.
         * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
         * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name must be unique within a Google Cloud project and region.
         * Is required when creating resources. Name is primarily intended
         * for creation idempotence and configuration definition. Cannot be updated.
         */
        name?: pulumi.Input<string>;
        /**
         * In Cloud Run the namespace must be equal to either the
         * project ID or project number.
         */
        namespace?: pulumi.Input<string>;
        /**
         * (Output)
         * An opaque value that represents the internal version of this object that
         * can be used by clients to determine when objects have changed. May be used
         * for optimistic concurrency, change detection, and the watch operation on a
         * resource or set of resources. They may only be valid for a
         * particular resource or set of resources.
         */
        resourceVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * SelfLink is a URL representing this object.
         */
        selfLink?: pulumi.Input<string>;
        /**
         * (Output)
         * UID is a unique id generated by the server on successful creation of a resource and is not
         * allowed to change on PUT operations.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpec {
        /**
         * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
         * requests per container of the Revision. If not specified or 0, defaults to 80 when
         * requested CPU >= 1 and defaults to 1 when requested CPU < 1.
         */
        containerConcurrency?: pulumi.Input<number>;
        /**
         * Containers defines the unit of execution for this Revision.
         * Structure is documented below.
         */
        containers?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainer>[]>;
        /**
         * Node Selector describes the hardware requirements of the resources.
         * Use the following node selector keys to configure features on a Revision:
         * - `run.googleapis.com/accelerator` sets the [type of GPU](https://cloud.google.com/run/docs/configuring/services/gpu) required by the Revision to run.
         */
        nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Email address of the IAM service account associated with the revision of the
         * service. The service account represents the identity of the running revision,
         * and determines what permissions the revision has. If not provided, the revision
         * will use the project's default service account.
         */
        serviceAccountName?: pulumi.Input<string>;
        /**
         * (Output, Deprecated)
         * ServingState holds a value describing the state the resources
         * are in for this Revision.
         * It is expected
         * that the system will manipulate this based on routability and load.
         *
         * > **Warning:** `servingState` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         *
         * @deprecated `servingState` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         */
        servingState?: pulumi.Input<string>;
        /**
         * TimeoutSeconds holds the max duration the instance is allowed for responding to a request.
         */
        timeoutSeconds?: pulumi.Input<number>;
        /**
         * Volume represents a named volume in a container.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolume>[]>;
    }

    export interface ServiceTemplateSpecContainer {
        /**
         * Arguments to the entrypoint.
         * The docker image's CMD is used if this is not provided.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Entrypoint array. Not executed within a shell.
         * The docker image's ENTRYPOINT is used if this is not provided.
         */
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Optional, Deprecated)
         * List of sources to populate environment variables in the container.
         * All invalid keys will be reported as an event when the container is starting.
         * When a key exists in multiple sources, the value associated with the last source will
         * take precedence. Values defined by an Env with a duplicate key will take
         * precedence.
         * Structure is documented below.
         *
         * > **Warning:** `envFrom` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         *
         * @deprecated `envFrom` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         */
        envFroms?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFrom>[]>;
        /**
         * List of environment variables to set in the container.
         * Structure is documented below.
         */
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnv>[]>;
        /**
         * Docker image name. This is most often a reference to a container located
         * in the container registry, such as gcr.io/cloudrun/hello
         */
        image: pulumi.Input<string>;
        /**
         * Periodic probe of container liveness. Container will be restarted if the probe fails. More info:
         * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         * Structure is documented below.
         */
        livenessProbe?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerLivenessProbe>;
        /**
         * Name of the container
         */
        name?: pulumi.Input<string>;
        /**
         * List of open ports in the container.
         * Structure is documented below.
         */
        ports?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerPort>[]>;
        /**
         * Compute Resources required by this container. Used to set values such as max memory
         * Structure is documented below.
         */
        resources?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerResources>;
        /**
         * Startup probe of application within the container.
         * All other probes are disabled if a startup probe is provided, until it
         * succeeds. Container will not be added to service endpoints if the probe fails.
         * Structure is documented below.
         */
        startupProbe?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerStartupProbe>;
        /**
         * Volume to mount into the container's filesystem.
         * Only supports SecretVolumeSources.
         * Structure is documented below.
         */
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerVolumeMount>[]>;
        /**
         * (Optional, Deprecated)
         * Container's working directory.
         * If not specified, the container runtime's default will be used, which
         * might be configured in the container image.
         *
         * > **Warning:** `workingDir` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         *
         * @deprecated `workingDir` is deprecated and will be removed in a future major release. This field is not supported by the Cloud Run API.
         */
        workingDir?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnv {
        /**
         * Name of the environment variable.
         */
        name?: pulumi.Input<string>;
        /**
         * Defaults to "".
         */
        value?: pulumi.Input<string>;
        /**
         * Source for the environment variable's value. Only supports secret_key_ref.
         * Structure is documented below.
         */
        valueFrom?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvValueFrom>;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        /**
         * The ConfigMap to select from.
         * Structure is documented below.
         */
        configMapRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef>;
        /**
         * An optional identifier to prepend to each key in the ConfigMap.
         */
        prefix?: pulumi.Input<string>;
        /**
         * The Secret to select from.
         * Structure is documented below.
         */
        secretRef?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        /**
         * The ConfigMap to select from.
         * Structure is documented below.
         */
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference>;
        /**
         * Specify whether the ConfigMap must be defined
         */
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        /**
         * Name of the referent.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        /**
         * The Secret to select from.
         * Structure is documented below.
         */
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference>;
        /**
         * Specify whether the Secret must be defined
         */
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        /**
         * Name of the referent.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerEnvValueFrom {
        /**
         * Selects a key (version) of a secret in Secret Manager.
         * Structure is documented below.
         */
        secretKeyRef: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerEnvValueFromSecretKeyRef>;
    }

    export interface ServiceTemplateSpecContainerEnvValueFromSecretKeyRef {
        /**
         * A Cloud Secret Manager secret version. Must be 'latest' for the latest
         * version or an integer for a specific version.
         */
        key: pulumi.Input<string>;
        /**
         * The name of the secret in Cloud Secret Manager. By default, the secret is assumed to be in the same project.
         * If the secret is in another project, you must define an alias.
         * An alias definition has the form:
         * {alias}:projects/{project-id|project-number}/secrets/{secret-name}.
         * If multiple alias definitions are needed, they must be separated by commas.
         * The alias definitions must be set on the run.googleapis.com/secrets annotation.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerLivenessProbe {
        /**
         * Minimum consecutive failures for the probe to be considered failed after
         * having succeeded. Defaults to 3. Minimum value is 1.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * GRPC specifies an action involving a GRPC port.
         * Structure is documented below.
         */
        grpc?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerLivenessProbeGrpc>;
        /**
         * HttpGet specifies the http request to perform.
         * Structure is documented below.
         */
        httpGet?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerLivenessProbeHttpGet>;
        /**
         * Number of seconds after the container has started before the probe is
         * initiated.
         * Defaults to 0 seconds. Minimum value is 0. Maximum value is 3600.
         */
        initialDelaySeconds?: pulumi.Input<number>;
        /**
         * How often (in seconds) to perform the probe.
         * Default to 10 seconds. Minimum value is 1. Maximum value is 3600.
         */
        periodSeconds?: pulumi.Input<number>;
        /**
         * Number of seconds after which the probe times out.
         * Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
         * Must be smaller than period_seconds.
         */
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ServiceTemplateSpecContainerLivenessProbeGrpc {
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
        /**
         * The name of the service to place in the gRPC HealthCheckRequest
         * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
         * If this is not specified, the default behavior is defined by gRPC.
         */
        service?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerLivenessProbeHttpGet {
        /**
         * Custom headers to set in the request. HTTP allows repeated headers.
         * Structure is documented below.
         */
        httpHeaders?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerLivenessProbeHttpGetHttpHeader>[]>;
        /**
         * Path to access on the HTTP server. If set, it should not be empty string.
         */
        path?: pulumi.Input<string>;
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateSpecContainerLivenessProbeHttpGetHttpHeader {
        /**
         * The header field name.
         */
        name: pulumi.Input<string>;
        /**
         * The header field value.
         */
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerPort {
        /**
         * Port number the container listens on. This must be a valid port number (between 1 and 65535). Defaults to "8080".
         */
        containerPort?: pulumi.Input<number>;
        /**
         * If specified, used to specify which protocol to use. Allowed values are "http1" (HTTP/1) and "h2c" (HTTP/2 end-to-end). Defaults to "http1".
         */
        name?: pulumi.Input<string>;
        /**
         * Protocol for port. Must be "TCP". Defaults to "TCP".
         */
        protocol?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerResources {
        /**
         * Limits describes the maximum amount of compute resources allowed.
         * The values of the map is string form of the 'quantity' k8s type:
         * https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
         */
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Requests describes the minimum amount of compute resources required.
         * If Requests is omitted for a container, it defaults to Limits if that is
         * explicitly specified, otherwise to an implementation-defined value.
         * The values of the map is string form of the 'quantity' k8s type:
         * https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
         */
        requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ServiceTemplateSpecContainerStartupProbe {
        /**
         * Minimum consecutive failures for the probe to be considered failed after
         * having succeeded. Defaults to 3. Minimum value is 1.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * GRPC specifies an action involving a GRPC port.
         * Structure is documented below.
         */
        grpc?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerStartupProbeGrpc>;
        /**
         * HttpGet specifies the http request to perform.
         * Structure is documented below.
         */
        httpGet?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerStartupProbeHttpGet>;
        /**
         * Number of seconds after the container has started before the probe is
         * initiated.
         * Defaults to 0 seconds. Minimum value is 0. Maximum value is 240.
         */
        initialDelaySeconds?: pulumi.Input<number>;
        /**
         * How often (in seconds) to perform the probe.
         * Default to 10 seconds. Minimum value is 1. Maximum value is 240.
         */
        periodSeconds?: pulumi.Input<number>;
        /**
         * TcpSocket specifies an action involving a TCP port.
         * Structure is documented below.
         */
        tcpSocket?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerStartupProbeTcpSocket>;
        /**
         * Number of seconds after which the probe times out.
         * Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
         * Must be smaller than periodSeconds.
         */
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ServiceTemplateSpecContainerStartupProbeGrpc {
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
        /**
         * The name of the service to place in the gRPC HealthCheckRequest
         * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
         * If this is not specified, the default behavior is defined by gRPC.
         */
        service?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerStartupProbeHttpGet {
        /**
         * Custom headers to set in the request. HTTP allows repeated headers.
         * Structure is documented below.
         */
        httpHeaders?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecContainerStartupProbeHttpGetHttpHeader>[]>;
        /**
         * Path to access on the HTTP server. If set, it should not be empty string.
         */
        path?: pulumi.Input<string>;
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateSpecContainerStartupProbeHttpGetHttpHeader {
        /**
         * The header field name.
         */
        name: pulumi.Input<string>;
        /**
         * The header field value.
         */
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecContainerStartupProbeTcpSocket {
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateSpecContainerVolumeMount {
        /**
         * Path within the container at which the volume should be mounted.  Must
         * not contain ':'.
         */
        mountPath: pulumi.Input<string>;
        /**
         * This must match the Name of a Volume.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecVolume {
        /**
         * A filesystem specified by the Container Storage Interface (CSI).
         * Structure is documented below.
         */
        csi?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolumeCsi>;
        /**
         * Ephemeral storage which can be backed by real disks (HD, SSD), network storage or memory (i.e. tmpfs). For now only in memory (tmpfs) is supported. It is ephemeral in the sense that when the sandbox is taken down, the data is destroyed with it (it does not persist across sandbox runs).
         * Structure is documented below.
         */
        emptyDir?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolumeEmptyDir>;
        /**
         * Volume's name.
         */
        name: pulumi.Input<string>;
        /**
         * A filesystem backed by a Network File System share. This filesystem requires the
         * run.googleapis.com/execution-environment annotation to be unset or set to "gen2"
         * Structure is documented below.
         */
        nfs?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolumeNfs>;
        /**
         * The secret's value will be presented as the content of a file whose
         * name is defined in the item path. If no items are defined, the name of
         * the file is the secret_name.
         * Structure is documented below.
         */
        secret?: pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolumeSecret>;
    }

    export interface ServiceTemplateSpecVolumeCsi {
        /**
         * Unique name representing the type of file system to be created. Cloud Run supports the following values:
         * * gcsfuse.run.googleapis.com: Mount a Google Cloud Storage bucket using GCSFuse. This driver requires the
         * run.googleapis.com/execution-environment annotation to be unset or set to "gen2"
         */
        driver: pulumi.Input<string>;
        /**
         * If true, all mounts created from this volume will be read-only.
         */
        readOnly?: pulumi.Input<boolean>;
        /**
         * Driver-specific attributes. The following options are supported for available drivers:
         * * gcsfuse.run.googleapis.com
         * * bucketName: The name of the Cloud Storage Bucket that backs this volume. The Cloud Run Service identity must have access to this bucket.
         */
        volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ServiceTemplateSpecVolumeEmptyDir {
        /**
         * The medium on which the data is stored. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory.
         */
        medium?: pulumi.Input<string>;
        /**
         * Limit on the storage usable by this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. This field's values are of the 'Quantity' k8s type: https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir.
         */
        sizeLimit?: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecVolumeNfs {
        /**
         * Path exported by the NFS server
         */
        path: pulumi.Input<string>;
        /**
         * If true, mount the NFS volume as read only in all mounts. Defaults to false.
         *
         * - - -
         */
        readOnly?: pulumi.Input<boolean>;
        /**
         * IP address or hostname of the NFS server
         */
        server: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecVolumeSecret {
        /**
         * Mode bits to use on created files by default. Must be a value between 0000
         * and 0777. Defaults to 0644. Directories within the path are not affected by
         * this setting. This might be in conflict with other options that affect the
         * file mode, like fsGroup, and the result can be other mode bits set.
         */
        defaultMode?: pulumi.Input<number>;
        /**
         * If unspecified, the volume will expose a file whose name is the
         * secret_name.
         * If specified, the key will be used as the version to fetch from Cloud
         * Secret Manager and the path will be the name of the file exposed in the
         * volume. When items are defined, they must specify a key and a path.
         * Structure is documented below.
         */
        items?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceTemplateSpecVolumeSecretItem>[]>;
        /**
         * The name of the secret in Cloud Secret Manager. By default, the secret
         * is assumed to be in the same project.
         * If the secret is in another project, you must define an alias.
         * An alias definition has the form:
         * {alias}:projects/{project-id|project-number}/secrets/{secret-name}.
         * If multiple alias definitions are needed, they must be separated by
         * commas.
         * The alias definitions must be set on the run.googleapis.com/secrets
         * annotation.
         */
        secretName: pulumi.Input<string>;
    }

    export interface ServiceTemplateSpecVolumeSecretItem {
        /**
         * The Cloud Secret Manager secret version.
         * Can be 'latest' for the latest value or an integer for a specific version.
         */
        key: pulumi.Input<string>;
        /**
         * Mode bits to use on this file, must be a value between 0000 and 0777. If
         * not specified, the volume defaultMode will be used. This might be in
         * conflict with other options that affect the file mode, like fsGroup, and
         * the result can be other mode bits set.
         */
        mode?: pulumi.Input<number>;
        /**
         * The relative path of the file to map the key to.
         * May not be an absolute path.
         * May not contain the path element '..'.
         * May not start with the string '..'.
         */
        path: pulumi.Input<string>;
    }

    export interface ServiceTraffic {
        /**
         * LatestRevision may be optionally provided to indicate that the latest ready
         * Revision of the Configuration should be used for this traffic target. When
         * provided LatestRevision must be true if RevisionName is empty; it must be
         * false when RevisionName is non-empty.
         */
        latestRevision?: pulumi.Input<boolean>;
        /**
         * Percent specifies percent of the traffic to this Revision or Configuration.
         */
        percent: pulumi.Input<number>;
        /**
         * RevisionName of a specific revision to which to send this portion of traffic.
         */
        revisionName?: pulumi.Input<string>;
        /**
         * Tag is optionally used to expose a dedicated url for referencing this target exclusively.
         */
        tag?: pulumi.Input<string>;
        /**
         * (Output)
         * URL displays the URL for accessing tagged traffic targets. URL is displayed in status,
         * and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname,
         * but may not contain anything else (e.g. basic auth, url path, etc.)
         */
        url?: pulumi.Input<string>;
    }
}

export namespace cloudrunv2 {
    export interface JobBinaryAuthorization {
        /**
         * If present, indicates to use Breakglass using this justification. If useDefault is False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
         */
        breakglassJustification?: pulumi.Input<string>;
        /**
         * The path to a binary authorization policy. Format: projects/{project}/platforms/cloudRun/{policy-name}
         */
        policy?: pulumi.Input<string>;
        /**
         * If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled.
         */
        useDefault?: pulumi.Input<boolean>;
    }

    export interface JobCondition {
        /**
         * (Output)
         * A reason for the execution condition.
         */
        executionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * Last time the condition transitioned from one status to another.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A common (service-level) reason for this condition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * A reason for the revision condition.
         */
        revisionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * How to interpret failures of this condition, one of Error, Warning, Info
         */
        severity?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting Types common to all resources include: * "Ready": True when the Resource is ready.
         */
        type?: pulumi.Input<string>;
    }

    export interface JobIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobLatestCreatedExecution {
        /**
         * (Output)
         * Completion timestamp of the execution.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        completionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Creation timestamp of the execution.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        createTime?: pulumi.Input<string>;
        /**
         * Name of the Job.
         */
        name?: pulumi.Input<string>;
    }

    export interface JobTemplate {
        /**
         * Unstructured key value map that may be set by external tools to store and arbitrary metadata. They are not queryable and should be preserved when modifying objects.
         * Cloud Run API v2 does not support annotations with `run.googleapis.com`, `cloud.googleapis.com`, `serving.knative.dev`, or `autoscaling.knative.dev` namespaces, and they will be rejected.
         * All system annotations in v1 now have a corresponding field in v2 ExecutionTemplate.
         * This field follows Kubernetes annotations' namespacing, limits, and rules.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Unstructured key value map that can be used to organize and categorize objects. User-provided labels are shared with Google's billing system, so they can be used to filter,
         * or break down billing charges by team, component, environment, state, etc. For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or
         * https://cloud.google.com/run/docs/configuring/labels.
         * Cloud Run API v2 does not support labels with `run.googleapis.com`, `cloud.googleapis.com`, `serving.knative.dev`, or `autoscaling.knative.dev` namespaces, and they will be rejected.
         * All system labels in v1 now have a corresponding field in v2 ExecutionTemplate.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Specifies the maximum desired number of tasks the execution should run at given time. Must be <= taskCount. When the job is run, if this field is 0 or unset, the maximum possible value will be used for that execution. The actual number of tasks running in steady state will be less than this number when there are fewer tasks waiting to be completed remaining, i.e. when the work left to do is less than max parallelism.
         */
        parallelism?: pulumi.Input<number>;
        /**
         * Specifies the desired number of tasks the execution should run. Setting to 1 means that parallelism is limited to 1 and the success of that task signals the success of the execution. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
         */
        taskCount?: pulumi.Input<number>;
        /**
         * Describes the task(s) that will be created when executing an execution
         * Structure is documented below.
         */
        template: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplate>;
    }

    export interface JobTemplateTemplate {
        /**
         * Holds the single container that defines the unit of execution for this task.
         * Structure is documented below.
         */
        containers?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainer>[]>;
        /**
         * A reference to a customer managed encryption key (CMEK) to use to encrypt this container image. For more information, go to https://cloud.google.com/run/docs/securing/using-cmek
         */
        encryptionKey?: pulumi.Input<string>;
        /**
         * The execution environment being used to host this Task.
         * Possible values are: `EXECUTION_ENVIRONMENT_GEN1`, `EXECUTION_ENVIRONMENT_GEN2`.
         */
        executionEnvironment?: pulumi.Input<string>;
        /**
         * Number of retries allowed per Task, before marking this Task failed. Defaults to 3. Minimum value is 0.
         */
        maxRetries?: pulumi.Input<number>;
        /**
         * Email address of the IAM service account associated with the Task of a Job. The service account represents the identity of the running task, and determines what permissions the task has. If not provided, the task will use the project's default service account.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Max allowed time duration the Task may be active before the system will actively try to mark it failed and kill associated containers. This applies per attempt of a task, meaning each retry can run for the full timeout.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        timeout?: pulumi.Input<string>;
        /**
         * A list of Volumes to make available to containers.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolume>[]>;
        /**
         * VPC Access configuration to use for this Task. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc.
         * Structure is documented below.
         */
        vpcAccess?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVpcAccess>;
    }

    export interface JobTemplateTemplateContainer {
        /**
         * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references are not supported in Cloud Run.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         */
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of environment variables to set in the container.
         * Structure is documented below.
         */
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerEnv>[]>;
        /**
         * URL of the Container image in Google Container Registry or Google Artifact Registry. More info: https://kubernetes.io/docs/concepts/containers/images
         */
        image: pulumi.Input<string>;
        /**
         * Name of the container specified as a DNS_LABEL.
         */
        name?: pulumi.Input<string>;
        /**
         * List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible.
         * If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on
         * Structure is documented below.
         */
        ports?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerPort>[]>;
        /**
         * Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
         * Structure is documented below.
         */
        resources?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerResources>;
        /**
         * Volume to mount into the container's filesystem.
         * Structure is documented below.
         */
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerVolumeMount>[]>;
        /**
         * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.
         */
        workingDir?: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateContainerEnv {
        /**
         * Name of the environment variable. Must be a C_IDENTIFIER, and mnay not exceed 32768 characters.
         */
        name: pulumi.Input<string>;
        /**
         * Literal value of the environment variable. Defaults to "" and the maximum allowed length is 32768 characters. Variable references are not supported in Cloud Run.
         */
        value?: pulumi.Input<string>;
        /**
         * Source for the environment variable's value.
         * Structure is documented below.
         */
        valueSource?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerEnvValueSource>;
    }

    export interface JobTemplateTemplateContainerEnvValueSource {
        /**
         * Selects a secret and a specific version from Cloud Secret Manager.
         * Structure is documented below.
         */
        secretKeyRef?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateContainerEnvValueSourceSecretKeyRef>;
    }

    export interface JobTemplateTemplateContainerEnvValueSourceSecretKeyRef {
        /**
         * The name of the secret in Cloud Secret Manager. Format: {secretName} if the secret is in the same project. projects/{project}/secrets/{secretName} if the secret is in a different project.
         */
        secret: pulumi.Input<string>;
        /**
         * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
         */
        version: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateContainerPort {
        /**
         * Port number the container listens on. This must be a valid TCP port number, 0 < containerPort < 65536.
         */
        containerPort?: pulumi.Input<number>;
        /**
         * If specified, used to specify which protocol to use. Allowed values are "http1" and "h2c".
         */
        name?: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateContainerResources {
        /**
         * Only memory and CPU are supported. Use key `cpu` for CPU limit and `memory` for memory limit. Note: The only supported values for CPU are '1', '2', '4', and '8'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
         */
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobTemplateTemplateContainerVolumeMount {
        /**
         * Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be /cloudsql. All instances defined in the Volume will be available as /cloudsql/[instance]. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run
         */
        mountPath: pulumi.Input<string>;
        /**
         * This must match the Name of a Volume.
         */
        name: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateVolume {
        /**
         * For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run.
         * Structure is documented below.
         */
        cloudSqlInstance?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeCloudSqlInstance>;
        /**
         * Ephemeral storage used as a shared volume.
         * Structure is documented below.
         */
        emptyDir?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeEmptyDir>;
        /**
         * Cloud Storage bucket mounted as a volume using GCSFuse.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeGcs>;
        /**
         * Volume's name.
         */
        name: pulumi.Input<string>;
        /**
         * NFS share mounted as a volume.
         * Structure is documented below.
         */
        nfs?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeNfs>;
        /**
         * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
         * Structure is documented below.
         */
        secret?: pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeSecret>;
    }

    export interface JobTemplateTemplateVolumeCloudSqlInstance {
        /**
         * The Cloud SQL instance connection names, as can be found in https://console.cloud.google.com/sql/instances. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Format: {project}:{location}:{instance}
         */
        instances?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobTemplateTemplateVolumeEmptyDir {
        /**
         * The different types of medium supported for EmptyDir.
         * Default value is `MEMORY`.
         * Possible values are: `MEMORY`.
         */
        medium?: pulumi.Input<string>;
        /**
         * Limit on the storage usable by this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. This field's values are of the 'Quantity' k8s type: https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir.
         */
        sizeLimit?: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateVolumeGcs {
        /**
         * Name of the cloud storage bucket to back the volume. The resource service account must have permission to access the bucket.
         */
        bucket: pulumi.Input<string>;
        /**
         * A list of flags to pass to the gcsfuse command for configuring this volume.
         * Flags should be passed without leading dashes.
         */
        mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, mount this volume as read-only in all mounts. If false, mount this volume as read-write.
         */
        readOnly?: pulumi.Input<boolean>;
    }

    export interface JobTemplateTemplateVolumeNfs {
        /**
         * Path that is exported by the NFS server.
         */
        path?: pulumi.Input<string>;
        /**
         * If true, mount this volume as read-only in all mounts.
         */
        readOnly?: pulumi.Input<boolean>;
        /**
         * Hostname or IP address of the NFS server.
         */
        server: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateVolumeSecret {
        /**
         * Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0444. Directories within the path are not affected by this setting.
         */
        defaultMode?: pulumi.Input<number>;
        /**
         * If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version.
         * Structure is documented below.
         */
        items?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVolumeSecretItem>[]>;
        /**
         * The name of the secret in Cloud Secret Manager. Format: {secret} if the secret is in the same project. projects/{project}/secrets/{secret} if the secret is in a different project.
         */
        secret: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateVolumeSecretItem {
        /**
         * Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used.
         */
        mode?: pulumi.Input<number>;
        /**
         * The relative path of the secret in the container.
         */
        path: pulumi.Input<string>;
        /**
         * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version
         */
        version: pulumi.Input<string>;
    }

    export interface JobTemplateTemplateVpcAccess {
        /**
         * VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}, where {project} can be project id or number.
         */
        connector?: pulumi.Input<string>;
        /**
         * Traffic VPC egress settings.
         * Possible values are: `ALL_TRAFFIC`, `PRIVATE_RANGES_ONLY`.
         */
        egress?: pulumi.Input<string>;
        /**
         * Direct VPC egress settings. Currently only single network interface is supported.
         * Structure is documented below.
         */
        networkInterfaces?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.JobTemplateTemplateVpcAccessNetworkInterface>[]>;
    }

    export interface JobTemplateTemplateVpcAccessNetworkInterface {
        /**
         * The VPC network that the Cloud Run resource will be able to send traffic to. At least one of network or subnetwork must be specified. If both
         * network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If network is not specified, it will be
         * looked up from the subnetwork.
         */
        network?: pulumi.Input<string>;
        /**
         * The VPC subnetwork that the Cloud Run resource will get IPs from. At least one of network or subnetwork must be specified. If both
         * network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If subnetwork is not specified, the
         * subnetwork with the same name with the network will be used.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * Network tags applied to this Cloud Run job.
         *
         * - - -
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobTerminalCondition {
        /**
         * (Output)
         * A reason for the execution condition.
         */
        executionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * Last time the condition transitioned from one status to another.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A common (service-level) reason for this condition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * A reason for the revision condition.
         */
        revisionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * How to interpret failures of this condition, one of Error, Warning, Info
         */
        severity?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting Types common to all resources include: * "Ready": True when the Resource is ready.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServiceBinaryAuthorization {
        /**
         * If present, indicates to use Breakglass using this justification. If useDefault is False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass
         */
        breakglassJustification?: pulumi.Input<string>;
        /**
         * The path to a binary authorization policy. Format: projects/{project}/platforms/cloudRun/{policy-name}
         */
        policy?: pulumi.Input<string>;
        /**
         * If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled.
         */
        useDefault?: pulumi.Input<boolean>;
    }

    export interface ServiceBuildConfig {
        /**
         * The base image used to build the function.
         */
        baseImage?: pulumi.Input<string>;
        /**
         * Sets whether the function will receive automatic base image updates.
         */
        enableAutomaticUpdates?: pulumi.Input<boolean>;
        /**
         * User-provided build-time environment variables for the function.
         */
        environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix, if not specified. For backward compatibility, if function with given name is not found, then the system will try to use function named "function".
         */
        functionTarget?: pulumi.Input<string>;
        /**
         * Artifact Registry URI to store the built image.
         */
        imageUri?: pulumi.Input<string>;
        /**
         * (Output)
         * The Cloud Build name of the latest successful deployment of the function.
         */
        name?: pulumi.Input<string>;
        /**
         * Service account to be used for building the container. The format of this field is `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The Cloud Storage bucket URI where the function source code is located.
         */
        sourceLocation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Build Custom Worker Pool that should be used to build the Cloud Run function. The format of this field is `projects/{project}/locations/{region}/workerPools/{workerPool}` where {project} and {region} are the project id and region respectively where the worker pool is defined and {workerPool} is the short name of the worker pool.
         */
        workerPool?: pulumi.Input<string>;
    }

    export interface ServiceCondition {
        /**
         * (Output)
         * A reason for the execution condition.
         */
        executionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * Last time the condition transitioned from one status to another.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A common (service-level) reason for this condition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * A reason for the revision condition.
         */
        revisionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * How to interpret failures of this condition, one of Error, Warning, Info
         */
        severity?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * The allocation type for this traffic target.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceScaling {
        /**
         * Total instance count for the service in manual scaling mode. This number of instances is divided among all revisions with specified traffic based on the percent of traffic they are receiving.
         */
        manualInstanceCount?: pulumi.Input<number>;
        /**
         * Minimum number of instances for the service, to be divided among all revisions receiving traffic.
         */
        minInstanceCount?: pulumi.Input<number>;
        /**
         * The [scaling mode](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services#scalingmode) for the service.
         * Possible values are: `AUTOMATIC`, `MANUAL`.
         */
        scalingMode?: pulumi.Input<string>;
    }

    export interface ServiceTemplate {
        /**
         * Unstructured key value map that may be set by external tools to store and arbitrary metadata. They are not queryable and should be preserved when modifying objects.
         * Cloud Run API v2 does not support annotations with `run.googleapis.com`, `cloud.googleapis.com`, `serving.knative.dev`, or `autoscaling.knative.dev` namespaces, and they will be rejected.
         * All system annotations in v1 now have a corresponding field in v2 RevisionTemplate.
         * This field follows Kubernetes annotations' namespacing, limits, and rules.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Holds the containers that define the unit of execution for this Service.
         * Structure is documented below.
         */
        containers?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainer>[]>;
        /**
         * A reference to a customer managed encryption key (CMEK) to use to encrypt this container image. For more information, go to https://cloud.google.com/run/docs/securing/using-cmek
         */
        encryptionKey?: pulumi.Input<string>;
        /**
         * The sandbox environment to host this Revision.
         * Possible values are: `EXECUTION_ENVIRONMENT_GEN1`, `EXECUTION_ENVIRONMENT_GEN2`.
         */
        executionEnvironment?: pulumi.Input<string>;
        /**
         * True if GPU zonal redundancy is disabled on this revision.
         */
        gpuZonalRedundancyDisabled?: pulumi.Input<boolean>;
        /**
         * Unstructured key value map that can be used to organize and categorize objects. User-provided labels are shared with Google's billing system, so they can be used to filter, or break down billing charges by team, component, environment, state, etc.
         * For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or https://cloud.google.com/run/docs/configuring/labels.
         * Cloud Run API v2 does not support labels with `run.googleapis.com`, `cloud.googleapis.com`, `serving.knative.dev`, or `autoscaling.knative.dev` namespaces, and they will be rejected.
         * All system labels in v1 now have a corresponding field in v2 RevisionTemplate.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Sets the maximum number of requests that each serving instance can receive.
         * If not specified or 0, defaults to 80 when requested CPU >= 1 and defaults to 1 when requested CPU < 1.
         */
        maxInstanceRequestConcurrency?: pulumi.Input<number>;
        /**
         * Node Selector describes the hardware requirements of the resources.
         * Structure is documented below.
         */
        nodeSelector?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateNodeSelector>;
        /**
         * The unique name for the revision. If this field is omitted, it will be automatically generated based on the Service name.
         */
        revision?: pulumi.Input<string>;
        /**
         * Scaling settings for this Revision.
         * Structure is documented below.
         */
        scaling?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateScaling>;
        /**
         * Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Enables Cloud Service Mesh for this Revision.
         * Structure is documented below.
         */
        serviceMesh?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateServiceMesh>;
        /**
         * Enables session affinity. For more information, go to https://cloud.google.com/run/docs/configuring/session-affinity
         */
        sessionAffinity?: pulumi.Input<boolean>;
        /**
         * Max allowed time for an instance to respond to a request.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        timeout?: pulumi.Input<string>;
        /**
         * A list of Volumes to make available to containers.
         * Structure is documented below.
         */
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolume>[]>;
        /**
         * VPC Access configuration to use for this Task. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc.
         * Structure is documented below.
         */
        vpcAccess?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVpcAccess>;
    }

    export interface ServiceTemplateContainer {
        /**
         * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references are not supported in Cloud Run.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Base image for this container. If set, it indicates that the service is enrolled into automatic base image update.
         */
        baseImageUri?: pulumi.Input<string>;
        /**
         * (Output)
         * The build info of the container image.
         * Structure is documented below.
         */
        buildInfos?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerBuildInfo>[]>;
        /**
         * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
         */
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Containers which should be started before this container. If specified the container will wait to start until all containers with the listed names are healthy.
         */
        dependsOns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of environment variables to set in the container.
         * Structure is documented below.
         */
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerEnv>[]>;
        /**
         * URL of the Container image in Google Container Registry or Google Artifact Registry. More info: https://kubernetes.io/docs/concepts/containers/images
         */
        image: pulumi.Input<string>;
        /**
         * Periodic probe of container liveness. Container will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         * Structure is documented below.
         */
        livenessProbe?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerLivenessProbe>;
        /**
         * Name of the container specified as a DNS_LABEL.
         */
        name?: pulumi.Input<string>;
        /**
         * List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible.
         * If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on
         * Structure is documented below.
         */
        ports?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerPorts>;
        /**
         * Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
         * Structure is documented below.
         */
        resources?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerResources>;
        /**
         * Startup probe of application within the container. All other probes are disabled if a startup probe is provided, until it succeeds. Container will not be added to service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         * Structure is documented below.
         */
        startupProbe?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerStartupProbe>;
        /**
         * Volume to mount into the container's filesystem.
         * Structure is documented below.
         */
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerVolumeMount>[]>;
        /**
         * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.
         */
        workingDir?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerBuildInfo {
        /**
         * Entry point of the function when the image is a Cloud Run function.
         */
        functionTarget?: pulumi.Input<string>;
        /**
         * Source code location of the image.
         */
        sourceLocation?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerEnv {
        /**
         * Name of the environment variable. Must be a C_IDENTIFIER, and may not exceed 32768 characters.
         */
        name: pulumi.Input<string>;
        /**
         * Literal value of the environment variable. Defaults to "" and the maximum allowed length is 32768 characters. Variable references are not supported in Cloud Run.
         */
        value?: pulumi.Input<string>;
        /**
         * Source for the environment variable's value.
         * Structure is documented below.
         */
        valueSource?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerEnvValueSource>;
    }

    export interface ServiceTemplateContainerEnvValueSource {
        /**
         * Selects a secret and a specific version from Cloud Secret Manager.
         * Structure is documented below.
         */
        secretKeyRef?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerEnvValueSourceSecretKeyRef>;
    }

    export interface ServiceTemplateContainerEnvValueSourceSecretKeyRef {
        /**
         * The name of the secret in Cloud Secret Manager. Format: {secretName} if the secret is in the same project. projects/{project}/secrets/{secretName} if the secret is in a different project.
         */
        secret: pulumi.Input<string>;
        /**
         * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.
         */
        version?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerLivenessProbe {
        /**
         * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * GRPC specifies an action involving a GRPC port.
         * Structure is documented below.
         */
        grpc?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerLivenessProbeGrpc>;
        /**
         * HTTPGet specifies the http request to perform.
         * Structure is documented below.
         */
        httpGet?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerLivenessProbeHttpGet>;
        /**
         * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        initialDelaySeconds?: pulumi.Input<number>;
        /**
         * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
         */
        periodSeconds?: pulumi.Input<number>;
        /**
         * TCPSocketAction describes an action based on opening a socket
         * Structure is documented below.
         */
        tcpSocket?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerLivenessProbeTcpSocket>;
        /**
         * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerLivenessProbeGrpc {
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
        /**
         * The name of the service to place in the gRPC HealthCheckRequest
         * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
         * If this is not specified, the default behavior is defined by gRPC.
         *
         * <a name="nestedTemplateContainersContainersBuildInfo"></a>The `buildInfo` block contains:
         */
        service?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerLivenessProbeHttpGet {
        /**
         * Custom headers to set in the request. HTTP allows repeated headers.
         * Structure is documented below.
         */
        httpHeaders?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerLivenessProbeHttpGetHttpHeader>[]>;
        /**
         * Path to access on the HTTP server. Defaults to '/'.
         */
        path?: pulumi.Input<string>;
        /**
         * Port number to access on the container. Must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerLivenessProbeHttpGetHttpHeader {
        /**
         * The header field name
         */
        name: pulumi.Input<string>;
        /**
         * The header field value
         */
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerLivenessProbeTcpSocket {
        /**
         * Port number to access on the container. Must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerPorts {
        /**
         * Port number the container listens on. This must be a valid TCP port number, 0 < containerPort < 65536.
         */
        containerPort?: pulumi.Input<number>;
        /**
         * If specified, used to specify which protocol to use. Allowed values are "http1" and "h2c".
         */
        name?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerResources {
        /**
         * Determines whether CPU is only allocated during requests. True by default if the parent `resources` field is not set. However, if
         * `resources` is set, this field must be explicitly set to true to preserve the default behavior.
         */
        cpuIdle?: pulumi.Input<boolean>;
        /**
         * Only memory, CPU, and nvidia.com/gpu are supported. Use key `cpu` for CPU limit, `memory` for memory limit, `nvidia.com/gpu` for gpu limit. Note: The only supported values for CPU are '1', '2', '4', and '8'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
         */
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Determines whether CPU should be boosted on startup of a new container instance above the requested CPU threshold, this can help reduce cold-start latency.
         */
        startupCpuBoost?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateContainerStartupProbe {
        /**
         * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
         */
        failureThreshold?: pulumi.Input<number>;
        /**
         * GRPC specifies an action involving a GRPC port.
         * Structure is documented below.
         */
        grpc?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerStartupProbeGrpc>;
        /**
         * HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified.
         * Structure is documented below.
         */
        httpGet?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerStartupProbeHttpGet>;
        /**
         * Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        initialDelaySeconds?: pulumi.Input<number>;
        /**
         * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds
         */
        periodSeconds?: pulumi.Input<number>;
        /**
         * TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified.
         * Structure is documented below.
         */
        tcpSocket?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerStartupProbeTcpSocket>;
        /**
         * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerStartupProbeGrpc {
        /**
         * Port number to access on the container. Number must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
        /**
         * The name of the service to place in the gRPC HealthCheckRequest
         * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
         * If this is not specified, the default behavior is defined by gRPC.
         *
         * <a name="nestedTemplateContainersContainersBuildInfo"></a>The `buildInfo` block contains:
         */
        service?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerStartupProbeHttpGet {
        /**
         * Custom headers to set in the request. HTTP allows repeated headers.
         * Structure is documented below.
         */
        httpHeaders?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateContainerStartupProbeHttpGetHttpHeader>[]>;
        /**
         * Path to access on the HTTP server. Defaults to '/'.
         */
        path?: pulumi.Input<string>;
        /**
         * Port number to access on the container. Must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerStartupProbeHttpGetHttpHeader {
        /**
         * The header field name
         */
        name: pulumi.Input<string>;
        /**
         * The header field value
         */
        value?: pulumi.Input<string>;
    }

    export interface ServiceTemplateContainerStartupProbeTcpSocket {
        /**
         * Port number to access on the container. Must be in the range 1 to 65535.
         * If not specified, defaults to the same value as container.ports[0].containerPort.
         */
        port?: pulumi.Input<number>;
    }

    export interface ServiceTemplateContainerVolumeMount {
        /**
         * Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be /cloudsql. All instances defined in the Volume will be available as /cloudsql/[instance]. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run
         */
        mountPath: pulumi.Input<string>;
        /**
         * This must match the Name of a Volume.
         */
        name: pulumi.Input<string>;
    }

    export interface ServiceTemplateNodeSelector {
        /**
         * The GPU to attach to an instance. See https://cloud.google.com/run/docs/configuring/services/gpu for configuring GPU.
         *
         * - - -
         */
        accelerator: pulumi.Input<string>;
    }

    export interface ServiceTemplateScaling {
        /**
         * Maximum number of serving instances that this resource should have. Must not be less than minimum instance count. If absent, Cloud Run will calculate
         * a default value based on the project's available container instances quota in the region and specified instance size.
         */
        maxInstanceCount?: pulumi.Input<number>;
        /**
         * Minimum number of instances for the service, to be divided among all revisions receiving traffic.
         */
        minInstanceCount?: pulumi.Input<number>;
    }

    export interface ServiceTemplateServiceMesh {
        /**
         * The Mesh resource name. For more information see https://cloud.google.com/service-mesh/docs/reference/network-services/rest/v1/projects.locations.meshes#resource:-mesh.
         */
        mesh?: pulumi.Input<string>;
    }

    export interface ServiceTemplateVolume {
        /**
         * For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run.
         * Structure is documented below.
         */
        cloudSqlInstance?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeCloudSqlInstance>;
        /**
         * Ephemeral storage used as a shared volume.
         * Structure is documented below.
         */
        emptyDir?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeEmptyDir>;
        /**
         * Cloud Storage bucket mounted as a volume using GCSFuse. This feature is only supported in the gen2 execution environment.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeGcs>;
        /**
         * Volume's name.
         */
        name: pulumi.Input<string>;
        /**
         * Represents an NFS mount.
         * Structure is documented below.
         */
        nfs?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeNfs>;
        /**
         * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
         * Structure is documented below.
         */
        secret?: pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeSecret>;
    }

    export interface ServiceTemplateVolumeCloudSqlInstance {
        /**
         * The Cloud SQL instance connection names, as can be found in https://console.cloud.google.com/sql/instances. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Format: {project}:{location}:{instance}
         */
        instances?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServiceTemplateVolumeEmptyDir {
        /**
         * The different types of medium supported for EmptyDir.
         * Default value is `MEMORY`.
         * Possible values are: `MEMORY`.
         */
        medium?: pulumi.Input<string>;
        /**
         * Limit on the storage usable by this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. This field's values are of the 'Quantity' k8s type: https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir.
         */
        sizeLimit?: pulumi.Input<string>;
    }

    export interface ServiceTemplateVolumeGcs {
        /**
         * GCS Bucket name
         */
        bucket: pulumi.Input<string>;
        /**
         * A list of flags to pass to the gcsfuse command for configuring this volume.
         * Flags should be passed without leading dashes.
         */
        mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, mount the GCS bucket as read-only
         */
        readOnly?: pulumi.Input<boolean>;
    }

    export interface ServiceTemplateVolumeNfs {
        /**
         * Path that is exported by the NFS server.
         */
        path: pulumi.Input<string>;
        /**
         * If true, mount the NFS volume as read only
         */
        readOnly?: pulumi.Input<boolean>;
        /**
         * Hostname or IP address of the NFS server
         */
        server: pulumi.Input<string>;
    }

    export interface ServiceTemplateVolumeSecret {
        /**
         * Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0444. Directories within the path are not affected by this setting.
         */
        defaultMode?: pulumi.Input<number>;
        /**
         * If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version.
         * Structure is documented below.
         */
        items?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateVolumeSecretItem>[]>;
        /**
         * The name of the secret in Cloud Secret Manager. Format: {secret} if the secret is in the same project. projects/{project}/secrets/{secret} if the secret is in a different project.
         */
        secret: pulumi.Input<string>;
    }

    export interface ServiceTemplateVolumeSecretItem {
        /**
         * Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used.
         */
        mode?: pulumi.Input<number>;
        /**
         * The relative path of the secret in the container.
         */
        path: pulumi.Input<string>;
        /**
         * The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version
         */
        version?: pulumi.Input<string>;
    }

    export interface ServiceTemplateVpcAccess {
        /**
         * VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}, where {project} can be project id or number.
         */
        connector?: pulumi.Input<string>;
        /**
         * Traffic VPC egress settings.
         * Possible values are: `ALL_TRAFFIC`, `PRIVATE_RANGES_ONLY`.
         */
        egress?: pulumi.Input<string>;
        /**
         * Direct VPC egress settings. Currently only single network interface is supported.
         * Structure is documented below.
         */
        networkInterfaces?: pulumi.Input<pulumi.Input<inputs.cloudrunv2.ServiceTemplateVpcAccessNetworkInterface>[]>;
    }

    export interface ServiceTemplateVpcAccessNetworkInterface {
        /**
         * The VPC network that the Cloud Run resource will be able to send traffic to. At least one of network or subnetwork must be specified. If both
         * network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If network is not specified, it will be
         * looked up from the subnetwork.
         */
        network?: pulumi.Input<string>;
        /**
         * The VPC subnetwork that the Cloud Run resource will get IPs from. At least one of network or subnetwork must be specified. If both
         * network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If subnetwork is not specified, the
         * subnetwork with the same name with the network will be used.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * Network tags applied to this Cloud Run service.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServiceTerminalCondition {
        /**
         * (Output)
         * A reason for the execution condition.
         */
        executionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * Last time the condition transitioned from one status to another.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A common (service-level) reason for this condition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * A reason for the revision condition.
         */
        revisionReason?: pulumi.Input<string>;
        /**
         * (Output)
         * How to interpret failures of this condition, one of Error, Warning, Info
         */
        severity?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * The allocation type for this traffic target.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServiceTraffic {
        /**
         * Specifies percent of the traffic to this Revision. This defaults to zero if unspecified.
         */
        percent?: pulumi.Input<number>;
        /**
         * Revision to which to send this portion of traffic, if traffic allocation is by revision.
         */
        revision?: pulumi.Input<string>;
        /**
         * Indicates a string to be part of the URI to exclusively reference this target.
         */
        tag?: pulumi.Input<string>;
        /**
         * The allocation type for this traffic target.
         * Possible values are: `TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST`, `TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION`.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServiceTrafficStatus {
        /**
         * (Output)
         * Specifies percent of the traffic to this Revision.
         */
        percent?: pulumi.Input<number>;
        /**
         * (Output)
         * Revision to which this traffic is sent.
         */
        revision?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates the string used in the URI to exclusively reference this target.
         */
        tag?: pulumi.Input<string>;
        /**
         * (Output)
         * The allocation type for this traffic target.
         */
        type?: pulumi.Input<string>;
        /**
         * (Output)
         * Displays the target URI.
         */
        uri?: pulumi.Input<string>;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        /**
         * App Engine Routing setting for the job.
         * Structure is documented below.
         */
        appEngineRouting?: pulumi.Input<inputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting>;
        /**
         * HTTP request body.
         * A request body is allowed only if the HTTP method is POST or PUT.
         * It will result in invalid argument error to set a body on a job with an incompatible HttpMethod.
         * A base64-encoded string.
         */
        body?: pulumi.Input<string>;
        /**
         * HTTP request headers.
         * This map contains the header field names and values.
         * Headers can be set when the job is created.
         */
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Which HTTP method to use for the request.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * The relative URI.
         * The relative URL must begin with "/" and must be a valid HTTP relative URL.
         * It can contain a path, query string arguments, and \# fragments.
         * If the relative URL is empty, then the root path "/" will be used.
         * No spaces are allowed, and the maximum length allowed is 2083 characters
         */
        relativeUri: pulumi.Input<string>;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        /**
         * App instance.
         * By default, the job is sent to an instance which is available when the job is attempted.
         */
        instance?: pulumi.Input<string>;
        /**
         * App service.
         * By default, the job is sent to the service which is the default service when the job is attempted.
         */
        service?: pulumi.Input<string>;
        /**
         * App version.
         * By default, the job is sent to the version which is the default version when the job is attempted.
         */
        version?: pulumi.Input<string>;
    }

    export interface JobHttpTarget {
        /**
         * HTTP request body.
         * A request body is allowed only if the HTTP method is POST, PUT, or PATCH.
         * It is an error to set body on a job with an incompatible HttpMethod.
         * A base64-encoded string.
         */
        body?: pulumi.Input<string>;
        /**
         * This map contains the header field names and values.
         * Repeated headers are not supported, but a header value can contain commas.
         */
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Which HTTP method to use for the request.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * Contains information needed for generating an OAuth token.
         * This type of authorization should be used when sending requests to a GCP endpoint.
         * Structure is documented below.
         */
        oauthToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOauthToken>;
        /**
         * Contains information needed for generating an OpenID Connect token.
         * This type of authorization should be used when sending requests to third party endpoints or Cloud Run.
         * Structure is documented below.
         */
        oidcToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOidcToken>;
        /**
         * The full URI path that the request will be sent to.
         */
        uri: pulumi.Input<string>;
    }

    export interface JobHttpTargetOauthToken {
        /**
         * OAuth scope to be used for generating OAuth access token. If not specified,
         * "https://www.googleapis.com/auth/cloud-platform" will be used.
         */
        scope?: pulumi.Input<string>;
        /**
         * Service account email to be used for generating OAuth token.
         * The service account must be within the same project as the job.
         */
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobHttpTargetOidcToken {
        /**
         * Audience to be used when generating OIDC token. If not specified,
         * the URI specified in target will be used.
         */
        audience?: pulumi.Input<string>;
        /**
         * Service account email to be used for generating OAuth token.
         * The service account must be within the same project as the job.
         */
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface JobPubsubTarget {
        /**
         * Attributes for PubsubMessage.
         * Pubsub message must contain either non-empty data, or at least one attribute.
         */
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The message payload for PubsubMessage.
         * Pubsub message must contain either non-empty data, or at least one attribute.
         * A base64-encoded string.
         */
        data?: pulumi.Input<string>;
        /**
         * The full resource name for the Cloud Pub/Sub topic to which
         * messages will be published when a job is delivered. ~>**NOTE:**
         * The topic name must be in the same format as required by PubSub's
         * PublishRequest.name, e.g. `projects/my-project/topics/my-topic`.
         */
        topicName: pulumi.Input<string>;
    }

    export interface JobRetryConfig {
        /**
         * The maximum amount of time to wait before retrying a job after it fails.
         * A duration in seconds with up to nine fractional digits, terminated by 's'.
         */
        maxBackoffDuration?: pulumi.Input<string>;
        /**
         * The time between retries will double maxDoublings times.
         * A job's retry interval starts at minBackoffDuration,
         * then doubles maxDoublings times, then increases linearly,
         * and finally retries retries at intervals of maxBackoffDuration up to retryCount times.
         */
        maxDoublings?: pulumi.Input<number>;
        /**
         * The time limit for retrying a failed job, measured from time when an execution was first attempted.
         * If specified with retryCount, the job will be retried until both limits are reached.
         * A duration in seconds with up to nine fractional digits, terminated by 's'.
         */
        maxRetryDuration?: pulumi.Input<string>;
        /**
         * The minimum amount of time to wait before retrying a job after it fails.
         * A duration in seconds with up to nine fractional digits, terminated by 's'.
         */
        minBackoffDuration?: pulumi.Input<string>;
        /**
         * The number of attempts that the system will make to run a
         * job using the exponential backoff procedure described by maxDoublings.
         * Values greater than 5 and negative values are not allowed.
         */
        retryCount?: pulumi.Input<number>;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        /**
         * (Output)
         * The host that the task is sent to.
         */
        host?: pulumi.Input<string>;
        /**
         * App instance.
         * By default, the task is sent to an instance which is available when the task is attempted.
         */
        instance?: pulumi.Input<string>;
        /**
         * App service.
         * By default, the task is sent to the service which is the default service when the task is attempted.
         */
        service?: pulumi.Input<string>;
        /**
         * App version.
         * By default, the task is sent to the version which is the default version when the task is attempted.
         */
        version?: pulumi.Input<string>;
    }

    export interface QueueHttpTarget {
        /**
         * HTTP target headers.
         * This map contains the header field names and values.
         * Headers will be set when running the CreateTask and/or BufferTask.
         * These headers represent a subset of the headers that will be configured for the task's HTTP request.
         * Some HTTP request headers will be ignored or replaced.
         * Headers which can have multiple values (according to RFC2616) can be specified using comma-separated values.
         * The size of the headers must be less than 80KB. Queue-level headers to override headers of all the tasks in the queue.
         * Structure is documented below.
         */
        headerOverrides?: pulumi.Input<pulumi.Input<inputs.cloudtasks.QueueHttpTargetHeaderOverride>[]>;
        /**
         * The HTTP method to use for the request.
         * When specified, it overrides HttpRequest for the task.
         * Note that if the value is set to GET the body of the task will be ignored at execution time.
         * Possible values are: `HTTP_METHOD_UNSPECIFIED`, `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * If specified, an OAuth token is generated and attached as the Authorization header in the HTTP request.
         * This type of authorization should generally be used only when calling Google APIs hosted on *.googleapis.com.
         * Note that both the service account email and the scope MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         */
        oauthToken?: pulumi.Input<inputs.cloudtasks.QueueHttpTargetOauthToken>;
        /**
         * If specified, an OIDC token is generated and attached as an Authorization header in the HTTP request.
         * This type of authorization can be used for many scenarios, including calling Cloud Run, or endpoints where you intend to validate the token yourself.
         * Note that both the service account email and the audience MUST be specified when using the queue-level authorization override.
         * Structure is documented below.
         */
        oidcToken?: pulumi.Input<inputs.cloudtasks.QueueHttpTargetOidcToken>;
        /**
         * URI override.
         * When specified, overrides the execution URI for all the tasks in the queue.
         * Structure is documented below.
         */
        uriOverride?: pulumi.Input<inputs.cloudtasks.QueueHttpTargetUriOverride>;
    }

    export interface QueueHttpTargetHeaderOverride {
        /**
         * Header embodying a key and a value.
         * Structure is documented below.
         */
        header: pulumi.Input<inputs.cloudtasks.QueueHttpTargetHeaderOverrideHeader>;
    }

    export interface QueueHttpTargetHeaderOverrideHeader {
        /**
         * The Key of the header.
         */
        key: pulumi.Input<string>;
        /**
         * The Value of the header.
         */
        value: pulumi.Input<string>;
    }

    export interface QueueHttpTargetOauthToken {
        /**
         * OAuth scope to be used for generating OAuth access token.
         * If not specified, "https://www.googleapis.com/auth/cloud-platform" will be used.
         */
        scope?: pulumi.Input<string>;
        /**
         * Service account email to be used for generating OAuth token.
         * The service account must be within the same project as the queue.
         * The caller must have iam.serviceAccounts.actAs permission for the service account.
         */
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface QueueHttpTargetOidcToken {
        /**
         * Audience to be used when generating OIDC token. If not specified, the URI specified in target will be used.
         */
        audience?: pulumi.Input<string>;
        /**
         * Service account email to be used for generating OIDC token.
         * The service account must be within the same project as the queue.
         * The caller must have iam.serviceAccounts.actAs permission for the service account.
         */
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface QueueHttpTargetUriOverride {
        /**
         * Host override.
         * When specified, replaces the host part of the task URL.
         * For example, if the task URL is "https://www.google.com", and host value
         * is set to "example.net", the overridden URI will be changed to "https://example.net".
         * Host value cannot be an empty string (INVALID_ARGUMENT).
         */
        host?: pulumi.Input<string>;
        /**
         * URI path.
         * When specified, replaces the existing path of the task URL.
         * Setting the path value to an empty string clears the URI path segment.
         * Structure is documented below.
         */
        pathOverride?: pulumi.Input<inputs.cloudtasks.QueueHttpTargetUriOverridePathOverride>;
        /**
         * Port override.
         * When specified, replaces the port part of the task URI.
         * For instance, for a URI http://www.google.com/foo and port=123, the overridden URI becomes http://www.google.com:123/foo.
         * Note that the port value must be a positive integer.
         * Setting the port to 0 (Zero) clears the URI port.
         */
        port?: pulumi.Input<string>;
        /**
         * URI query.
         * When specified, replaces the query part of the task URI. Setting the query value to an empty string clears the URI query segment.
         * Structure is documented below.
         */
        queryOverride?: pulumi.Input<inputs.cloudtasks.QueueHttpTargetUriOverrideQueryOverride>;
        /**
         * Scheme override.
         * When specified, the task URI scheme is replaced by the provided value (HTTP or HTTPS).
         * Possible values are: `HTTP`, `HTTPS`.
         */
        scheme?: pulumi.Input<string>;
        /**
         * URI Override Enforce Mode
         * When specified, determines the Target UriOverride mode. If not specified, it defaults to ALWAYS.
         * Possible values are: `ALWAYS`, `IF_NOT_EXISTS`.
         */
        uriOverrideEnforceMode?: pulumi.Input<string>;
    }

    export interface QueueHttpTargetUriOverridePathOverride {
        /**
         * The URI path (e.g., /users/1234). Default is an empty string.
         */
        path?: pulumi.Input<string>;
    }

    export interface QueueHttpTargetUriOverrideQueryOverride {
        /**
         * The query parameters (e.g., qparam1=123&qparam2=456). Default is an empty string.
         */
        queryParams?: pulumi.Input<string>;
    }

    export interface QueueIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface QueueIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface QueueRateLimits {
        /**
         * (Output)
         * The max burst size.
         * Max burst size limits how fast tasks in queue are processed when many tasks are
         * in the queue and the rate is high. This field allows the queue to have a high
         * rate so processing starts shortly after a task is enqueued, but still limits
         * resource usage when many tasks are enqueued in a short period of time.
         */
        maxBurstSize?: pulumi.Input<number>;
        /**
         * The maximum number of concurrent tasks that Cloud Tasks allows to
         * be dispatched for this queue. After this threshold has been
         * reached, Cloud Tasks stops dispatching tasks until the number of
         * concurrent requests decreases.
         */
        maxConcurrentDispatches?: pulumi.Input<number>;
        /**
         * The maximum rate at which tasks are dispatched from this queue.
         * If unspecified when the queue is created, Cloud Tasks will pick the default.
         */
        maxDispatchesPerSecond?: pulumi.Input<number>;
    }

    export interface QueueRetryConfig {
        /**
         * Number of attempts per task.
         * Cloud Tasks will attempt the task maxAttempts times (that is, if
         * the first attempt fails, then there will be maxAttempts - 1
         * retries). Must be >= -1.
         * If unspecified when the queue is created, Cloud Tasks will pick
         * the default.
         * -1 indicates unlimited attempts.
         */
        maxAttempts?: pulumi.Input<number>;
        /**
         * A task will be scheduled for retry between minBackoff and
         * maxBackoff duration after it fails, if the queue's RetryConfig
         * specifies that the task should be retried.
         */
        maxBackoff?: pulumi.Input<string>;
        /**
         * The time between retries will double maxDoublings times.
         * A task's retry interval starts at minBackoff, then doubles maxDoublings times,
         * then increases linearly, and finally retries retries at intervals of maxBackoff
         * up to maxAttempts times.
         */
        maxDoublings?: pulumi.Input<number>;
        /**
         * If positive, maxRetryDuration specifies the time limit for
         * retrying a failed task, measured from when the task was first
         * attempted. Once maxRetryDuration time has passed and the task has
         * been attempted maxAttempts times, no further attempts will be
         * made and the task will be deleted.
         * If zero, then the task age is unlimited.
         */
        maxRetryDuration?: pulumi.Input<string>;
        /**
         * A task will be scheduled for retry between minBackoff and
         * maxBackoff duration after it fails, if the queue's RetryConfig
         * specifies that the task should be retried.
         */
        minBackoff?: pulumi.Input<string>;
    }

    export interface QueueStackdriverLoggingConfig {
        /**
         * Specifies the fraction of operations to write to Stackdriver Logging.
         * This field may contain any value between 0.0 and 1.0, inclusive. 0.0 is the
         * default and means that no operations are logged.
         */
        samplingRatio: pulumi.Input<number>;
    }
}

export namespace colab {
    export interface NotebookExecutionDataformRepositorySource {
        /**
         * The commit SHA to read repository with. If unset, the file will be read at HEAD.
         */
        commitSha?: pulumi.Input<string>;
        /**
         * The resource name of the Dataform Repository.
         */
        dataformRepositoryResourceName: pulumi.Input<string>;
    }

    export interface NotebookExecutionDirectNotebookSource {
        /**
         * The base64-encoded contents of the input notebook file.
         */
        content: pulumi.Input<string>;
    }

    export interface NotebookExecutionGcsNotebookSource {
        /**
         * The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
         */
        generation?: pulumi.Input<string>;
        /**
         * The Cloud Storage uri pointing to the ipynb file.
         */
        uri: pulumi.Input<string>;
    }

    export interface RuntimeNotebookRuntimeTemplateRef {
        /**
         * The resource name of the NotebookRuntimeTemplate based on which a NotebookRuntime will be created.
         */
        notebookRuntimeTemplate: pulumi.Input<string>;
    }

    export interface RuntimeTemplateDataPersistentDiskSpec {
        /**
         * The disk size of the runtime in GB. If specified, the diskType must also be specified. The minimum size is 10GB and the maximum is 65536GB.
         */
        diskSizeGb?: pulumi.Input<string>;
        /**
         * The type of the persistent disk.
         */
        diskType?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateEncryptionSpec {
        /**
         * The Cloud KMS encryption key (customer-managed encryption key) used to protect the runtime.
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateEucConfig {
        /**
         * Disable end user credential access for the runtime.
         */
        eucDisabled?: pulumi.Input<boolean>;
    }

    export interface RuntimeTemplateIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RuntimeTemplateIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RuntimeTemplateIdleShutdownConfig {
        /**
         * The duration after which the runtime is automatically shut down. An input of 0s disables the idle shutdown feature, and a valid range is [10m, 24h].
         */
        idleTimeout?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateMachineSpec {
        /**
         * The number of accelerators used by the runtime.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * The type of hardware accelerator used by the runtime. If specified, acceleratorCount must also be specified.
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * The Compute Engine machine type selected for the runtime.
         */
        machineType?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateNetworkSpec {
        /**
         * Enable public internet access for the runtime.
         */
        enableInternetAccess?: pulumi.Input<boolean>;
        /**
         * The name of the VPC that this runtime is in.
         */
        network?: pulumi.Input<string>;
        /**
         * The name of the subnetwork that this runtime is in.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateShieldedVmConfig {
        /**
         * Enables secure boot for the runtime.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface RuntimeTemplateSoftwareConfig {
        /**
         * Environment variables to be passed to the container.
         * Structure is documented below.
         */
        envs?: pulumi.Input<pulumi.Input<inputs.colab.RuntimeTemplateSoftwareConfigEnv>[]>;
        /**
         * Post startup script config.
         * Structure is documented below.
         */
        postStartupScriptConfig?: pulumi.Input<inputs.colab.RuntimeTemplateSoftwareConfigPostStartupScriptConfig>;
    }

    export interface RuntimeTemplateSoftwareConfigEnv {
        /**
         * Name of the environment variable. Must be a valid C identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * Variables that reference a $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not.
         */
        value?: pulumi.Input<string>;
    }

    export interface RuntimeTemplateSoftwareConfigPostStartupScriptConfig {
        /**
         * Post startup script to run after runtime is started.
         */
        postStartupScript?: pulumi.Input<string>;
        /**
         * Post startup script behavior that defines download and execution behavior.
         * Possible values are: `RUN_ONCE`, `RUN_EVERY_START`, `DOWNLOAD_AND_RUN_EVERY_START`.
         */
        postStartupScriptBehavior?: pulumi.Input<string>;
        /**
         * Post startup script url to download. Example: https://bucket/script.sh.
         */
        postStartupScriptUrl?: pulumi.Input<string>;
    }

    export interface ScheduleCreateNotebookExecutionJobRequest {
        /**
         * The NotebookExecutionJob to create.
         * Structure is documented below.
         */
        notebookExecutionJob: pulumi.Input<inputs.colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob>;
    }

    export interface ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob {
        /**
         * The Dataform Repository containing the input notebook.
         * Structure is documented below.
         */
        dataformRepositorySource?: pulumi.Input<inputs.colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource>;
        /**
         * Required. The display name of the Notebook Execution.
         */
        displayName: pulumi.Input<string>;
        /**
         * Max running time of the execution job in seconds (default 86400s / 24 hrs). A duration in seconds with up to nine fractional digits, ending with "s". Example: "3.5s".
         */
        executionTimeout?: pulumi.Input<string>;
        /**
         * The user email to run the execution as.
         */
        executionUser?: pulumi.Input<string>;
        /**
         * The Cloud Storage uri for the input notebook.
         * Structure is documented below.
         */
        gcsNotebookSource?: pulumi.Input<inputs.colab.ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource>;
        /**
         * The Cloud Storage location to upload the result to. Format:`gs://bucket-name`
         */
        gcsOutputUri: pulumi.Input<string>;
        /**
         * The NotebookRuntimeTemplate to source compute configuration from.
         */
        notebookRuntimeTemplateResourceName: pulumi.Input<string>;
        /**
         * The service account to run the execution as.
         */
        serviceAccount?: pulumi.Input<string>;
    }

    export interface ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource {
        /**
         * The commit SHA to read repository with. If unset, the file will be read at HEAD.
         */
        commitSha?: pulumi.Input<string>;
        /**
         * The resource name of the Dataform Repository.
         */
        dataformRepositoryResourceName: pulumi.Input<string>;
    }

    export interface ScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource {
        /**
         * The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
         *
         * - - -
         */
        generation?: pulumi.Input<string>;
        /**
         * The Cloud Storage uri pointing to the ipynb file. Format: gs://bucket/notebook_file.ipynb
         */
        uri: pulumi.Input<string>;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        /**
         * The URI of the Apache Airflow Web UI hosted within this
         * environment.
         */
        airflowUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage prefix of the DAGs for this environment.
         * Although Cloud Storage objects reside in a flat namespace, a
         * hierarchical file tree can be simulated using '/'-delimited
         * object name prefixes. DAG objects for this environment
         * reside in a simulated directory with this prefix.
         */
        dagGcsPrefix?: pulumi.Input<string>;
        /**
         * The configuration setting for Airflow data retention mechanism. This field is supported for Cloud Composer environments in versions composer-2.0.32-airflow-2.1.4. or newer
         */
        dataRetentionConfig?: pulumi.Input<inputs.composer.EnvironmentConfigDataRetentionConfig>;
        /**
         * The configuration of Cloud SQL instance that is used by the Apache Airflow software. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        databaseConfig?: pulumi.Input<inputs.composer.EnvironmentConfigDatabaseConfig>;
        /**
         * Optional. If true, builds performed during operations that install Python packages have only private connectivity to Google services. If false, the builds also have access to the internet.
         */
        enablePrivateBuildsOnly?: pulumi.Input<boolean>;
        /**
         * Optional. If true, a private Composer environment will be created.
         */
        enablePrivateEnvironment?: pulumi.Input<boolean>;
        /**
         * The encryption options for the Composer environment and its dependencies.
         */
        encryptionConfig?: pulumi.Input<inputs.composer.EnvironmentConfigEncryptionConfig>;
        /**
         * The size of the Cloud Composer environment. This field is supported for Cloud Composer environments in versions composer-2.*.*-airflow-*.*.* and newer.
         */
        environmentSize?: pulumi.Input<string>;
        /**
         * The Kubernetes Engine cluster used to run this environment.
         */
        gkeCluster?: pulumi.Input<string>;
        /**
         * The configuration for Cloud Composer maintenance window.
         */
        maintenanceWindow?: pulumi.Input<inputs.composer.EnvironmentConfigMaintenanceWindow>;
        /**
         * Configuration options for the master authorized networks feature. Enabled master authorized networks will disallow all external traffic to access Kubernetes master through HTTPS except traffic from the given CIDR blocks, Google Compute Engine Public IPs and Google Prod IPs.
         */
        masterAuthorizedNetworksConfig?: pulumi.Input<inputs.composer.EnvironmentConfigMasterAuthorizedNetworksConfig>;
        /**
         * The configuration used for the Kubernetes Engine cluster.
         */
        nodeConfig?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfig>;
        /**
         * The number of nodes in the Kubernetes Engine cluster that will be used to run this environment. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        nodeCount?: pulumi.Input<number>;
        /**
         * The configuration used for the Private IP Cloud Composer environment.
         */
        privateEnvironmentConfig?: pulumi.Input<inputs.composer.EnvironmentConfigPrivateEnvironmentConfig>;
        /**
         * The recovery configuration settings for the Cloud Composer environment
         */
        recoveryConfig?: pulumi.Input<inputs.composer.EnvironmentConfigRecoveryConfig>;
        /**
         * Whether high resilience is enabled or not. This field is supported for Cloud Composer environments in versions composer-2.1.15-airflow-*.*.* and newer.
         */
        resilienceMode?: pulumi.Input<string>;
        /**
         * The configuration settings for software inside the environment.
         */
        softwareConfig?: pulumi.Input<inputs.composer.EnvironmentConfigSoftwareConfig>;
        /**
         * The configuration settings for the Airflow web server App Engine instance. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        webServerConfig?: pulumi.Input<inputs.composer.EnvironmentConfigWebServerConfig>;
        /**
         * Network-level access control policy for the Airflow web server.
         */
        webServerNetworkAccessControl?: pulumi.Input<inputs.composer.EnvironmentConfigWebServerNetworkAccessControl>;
        /**
         * The workloads configuration settings for the GKE cluster associated with the Cloud Composer environment. Supported for Cloud Composer environments in versions composer-2.*.*-airflow-*.*.* and newer.
         */
        workloadsConfig?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfig>;
    }

    export interface EnvironmentConfigDataRetentionConfig {
        /**
         * Optional. The policy for airflow metadata database retention.
         */
        airflowMetadataRetentionConfigs?: pulumi.Input<pulumi.Input<inputs.composer.EnvironmentConfigDataRetentionConfigAirflowMetadataRetentionConfig>[]>;
        /**
         * Optional. The configuration setting for Task Logs.
         */
        taskLogsRetentionConfigs?: pulumi.Input<pulumi.Input<inputs.composer.EnvironmentConfigDataRetentionConfigTaskLogsRetentionConfig>[]>;
    }

    export interface EnvironmentConfigDataRetentionConfigAirflowMetadataRetentionConfig {
        /**
         * How many days data should be retained for. This field is supported for Cloud Composer environments in composer 3 and newer.
         */
        retentionDays?: pulumi.Input<number>;
        /**
         * Whether database retention is enabled or not. This field is supported for Cloud Composer environments in composer 3 and newer.
         */
        retentionMode?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigDataRetentionConfigTaskLogsRetentionConfig {
        /**
         * Whether logs in cloud logging only is enabled or not. This field is supported for Cloud Composer environments in versions composer-2.0.32-airflow-2.1.4 and newer but not in composer-3*
         */
        storageMode?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigDatabaseConfig {
        /**
         * Optional. Cloud SQL machine type used by Airflow database. It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8 or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Optional. Cloud SQL database preferred zone.
         */
        zone?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigEncryptionConfig {
        /**
         * Optional. Customer-managed Encryption Key available through Google's Key Management Service. Cannot be updated.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface EnvironmentConfigMaintenanceWindow {
        /**
         * Maintenance window end time. It is used only to calculate the duration of the maintenance window. The value for end-time must be in the future, relative to 'start_time'.
         */
        endTime: pulumi.Input<string>;
        /**
         * Maintenance window recurrence. Format is a subset of RFC-5545 (https://tools.ietf.org/html/rfc5545) 'RRULE'. The only allowed values for 'FREQ' field are 'FREQ=DAILY' and 'FREQ=WEEKLY;BYDAY=...'. Example values: 'FREQ=WEEKLY;BYDAY=TU,WE', 'FREQ=DAILY'.
         */
        recurrence: pulumi.Input<string>;
        /**
         * Start time of the first recurrence of the maintenance window.
         */
        startTime: pulumi.Input<string>;
    }

    export interface EnvironmentConfigMasterAuthorizedNetworksConfig {
        /**
         * cidr_blocks define up to 50 external networks that could access Kubernetes master through HTTPS.
         */
        cidrBlocks?: pulumi.Input<pulumi.Input<inputs.composer.EnvironmentConfigMasterAuthorizedNetworksConfigCidrBlock>[]>;
        /**
         * Whether or not master authorized networks is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigMasterAuthorizedNetworksConfigCidrBlock {
        /**
         * cidr_block must be specified in CIDR notation.
         */
        cidrBlock: pulumi.Input<string>;
        /**
         * display_name is a field for users to identify CIDR blocks.
         */
        displayName?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigNodeConfig {
        /**
         * IPv4 cidr range that will be used by Composer internal components.
         */
        composerInternalIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * PSC (Private Service Connect) Network entry point. Customers can pre-create the Network Attachment and point Cloud Composer environment to use. It is possible to share network attachment among many environments, provided enough IP addresses are available.
         */
        composerNetworkAttachment?: pulumi.Input<string>;
        /**
         * The disk size in GB used for node VMs. Minimum size is 20GB. If unspecified, defaults to 100GB. Cannot be updated. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Deploys 'ip-masq-agent' daemon set in the GKE cluster and defines nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for all destination addresses, except between pods traffic. See: https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent
         */
        enableIpMasqAgent?: pulumi.Input<boolean>;
        /**
         * Configuration for controlling how IPs are allocated in the GKE cluster. Cannot be updated.
         */
        ipAllocationPolicy?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy>;
        /**
         * The Compute Engine machine type used for cluster instances, specified as a name or relative resource name. For example: "projects/{project}/zones/{zone}/machineTypes/{machineType}". Must belong to the enclosing environment's project and region/zone. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        machineType?: pulumi.Input<string>;
        /**
         * The maximum pods per node in the GKE cluster allocated during environment creation. Lowering this value reduces IP address consumption by the Cloud Composer Kubernetes cluster. This value can only be set during environment creation, and only if the environment is VPC-Native. The range of possible values is 8-110, and the default is 32. Cannot be updated. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The Compute Engine machine type used for cluster instances, specified as a name or relative resource name. For example: "projects/{project}/zones/{zone}/machineTypes/{machineType}". Must belong to the enclosing environment's project and region/zone. The network must belong to the environment's project. If unspecified, the "default" network ID in the environment's project is used. If a Custom Subnet Network is provided, subnetwork must also be provided.
         */
        network?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available on all node VMs. Cannot be updated. If empty, defaults to ["https://www.googleapis.com/auth/cloud-platform"]. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Google Cloud Platform Service Account to be used by the node VMs. If a service account is not specified, the "default" Compute Engine service account is used. Cannot be updated. If given, note that the service account must have roles/composer.worker for any GCP resources created under the Cloud Composer Environment.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The Compute Engine subnetwork to be used for machine communications, specified as a self-link, relative resource name (e.g. "projects/{project}/regions/{region}/subnetworks/{subnetwork}"), or by name. If subnetwork is provided, network must also be provided and the subnetwork must belong to the enclosing environment's project and region.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The list of instance tags applied to all node VMs. Tags are used to identify valid sources or targets for network firewalls. Each tag within the list must comply with RFC1035. Cannot be updated.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Compute Engine zone in which to deploy the VMs running the Apache Airflow software, specified as the zone name or relative resource name (e.g. "projects/{project}/zones/{zone}"). Must belong to the enclosing environment's project and region. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        zone?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        /**
         * The IP address range used to allocate IP addresses to pods in the cluster. For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*, this field is applicable only when useIpAliases is true. Set to blank to have GKE choose a range with the default size. Set to /netmask (e.g. /14) to have GKE choose a range with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Specify either clusterSecondaryRangeName or clusterIpv4CidrBlock but not both.
         */
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the cluster's secondary range used to allocate IP addresses to pods. Specify either clusterSecondaryRangeName or clusterIpv4CidrBlock but not both. For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*, this field is applicable only when useIpAliases is true.
         */
        clusterSecondaryRangeName?: pulumi.Input<string>;
        /**
         * The IP address range used to allocate IP addresses in this cluster. For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*, this field is applicable only when useIpAliases is true. Set to blank to have GKE choose a range with the default size. Set to /netmask (e.g. /14) to have GKE choose a range with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use. Specify either servicesSecondaryRangeName or servicesIpv4CidrBlock but not both.
         */
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the services' secondary range used to allocate IP addresses to the cluster. Specify either servicesSecondaryRangeName or servicesIpv4CidrBlock but not both. For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*, this field is applicable only when useIpAliases is true.
         */
        servicesSecondaryRangeName?: pulumi.Input<string>;
        /**
         * Whether or not to enable Alias IPs in the GKE cluster. If true, a VPC-native cluster is created. Defaults to true if the ipAllocationPolicy block is present in config. This field is only supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*. Environments in newer versions always use VPC-native GKE clusters.
         */
        useIpAliases?: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        /**
         * When specified, the environment will use Private Service Connect instead of VPC peerings to connect to Cloud SQL in the Tenant Project, and the PSC endpoint in the Customer Project will use an IP address from this subnetwork. This field is supported for Cloud Composer environments in versions composer-2.*.*-airflow-*.*.* and newer.
         */
        cloudComposerConnectionSubnetwork?: pulumi.Input<string>;
        /**
         * The CIDR block from which IP range for Cloud Composer Network in tenant project will be reserved. Needs to be disjoint from private_cluster_config.master_ipv4_cidr_block and cloud_sql_ipv4_cidr_block. This field is supported for Cloud Composer environments in versions composer-2.*.*-airflow-*.*.* and newer.
         */
        cloudComposerNetworkIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The CIDR block from which IP range in tenant project will be reserved for Cloud SQL. Needs to be disjoint from web_server_ipv4_cidr_block.
         */
        cloudSqlIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * Mode of internal communication within the Composer environment. Must be one of "VPC_PEERING" or "PRIVATE_SERVICE_CONNECT".
         */
        connectionType?: pulumi.Input<string>;
        /**
         * If true, access to the public endpoint of the GKE cluster is denied. If this field is set to true, ip_allocation_policy.use_ip_aliases must be set to true for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        /**
         * When enabled, IPs from public (non-RFC1918) ranges can be used for ip_allocation_policy.cluster_ipv4_cidr_block and ip_allocation_policy.service_ipv4_cidr_block.
         */
        enablePrivatelyUsedPublicIps?: pulumi.Input<boolean>;
        /**
         * The IP range in CIDR notation to use for the hosted master network. This range is used for assigning internal IP addresses to the cluster master or set of masters and to the internal load balancer virtual IP. This range must not overlap with any other ranges in use within the cluster's network. If left blank, the default value of '172.16.0.0/28' is used.
         */
        masterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The CIDR block from which IP range for web server will be reserved. Needs to be disjoint from masterIpv4CidrBlock and cloud_sql_ipv4_cidr_block. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*.
         */
        webServerIpv4CidrBlock?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigRecoveryConfig {
        /**
         * The configuration settings for scheduled snapshots.
         */
        scheduledSnapshotsConfig?: pulumi.Input<inputs.composer.EnvironmentConfigRecoveryConfigScheduledSnapshotsConfig>;
    }

    export interface EnvironmentConfigRecoveryConfigScheduledSnapshotsConfig {
        /**
         * When enabled, Cloud Composer periodically saves snapshots of your environment to a Cloud Storage bucket.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Snapshot schedule, in the unix-cron format.
         */
        snapshotCreationSchedule?: pulumi.Input<string>;
        /**
         * the URI of a bucket folder where to save the snapshot.
         */
        snapshotLocation?: pulumi.Input<string>;
        /**
         * A time zone for the schedule. This value is a time offset and does not take into account daylight saving time changes. Valid values are from UTC-12 to UTC+12. Examples: UTC, UTC-01, UTC+03.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigSoftwareConfig {
        /**
         * Apache Airflow configuration properties to override. Property keys contain the section and property names, separated by a hyphen, for example "core-dags_are_paused_at_creation". Section names must not contain hyphens ("-"), opening square brackets ("["), or closing square brackets ("]"). The property name must not be empty and cannot contain "=" or ";". Section and property names cannot contain characters: "." Apache Airflow configuration property names must be written in snake_case. Property values can contain any character, and can be written in any lower/upper case format. Certain Apache Airflow configuration property values are blacklisted, and cannot be overridden.
         */
        airflowConfigOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The configuration for Cloud Data Lineage integration. Supported for Cloud Composer environments in versions composer-2.1.2-airflow-*.*.* and newer
         */
        cloudDataLineageIntegration?: pulumi.Input<inputs.composer.EnvironmentConfigSoftwareConfigCloudDataLineageIntegration>;
        /**
         * Additional environment variables to provide to the Apache Airflow scheduler, worker, and webserver processes. Environment variable names must match the regular expression [a-zA-Z_][a-zA-Z0-9_]*. They cannot specify Apache Airflow software configuration overrides (they cannot match the regular expression AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+), and they cannot match any of the following reserved names: AIRFLOW_HOME C_FORCE_ROOT CONTAINER_NAME DAGS_FOLDER GCP_PROJECT GCS_BUCKET GKE_CLUSTER_NAME SQL_DATABASE SQL_INSTANCE SQL_PASSWORD SQL_PROJECT SQL_REGION SQL_USER.
         */
        envVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The version of the software running in the environment. This encapsulates both the version of Cloud Composer functionality and the version of Apache Airflow. It must match the regular expression composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?). The Cloud Composer portion of the image version is a full semantic version, or an alias in the form of major version number or 'latest'. The Apache Airflow portion of the image version is a full semantic version that points to one of the supported Apache Airflow versions, or an alias in the form of only major or major.minor versions specified. See documentation for more details and version list.
         */
        imageVersion?: pulumi.Input<string>;
        /**
         * Custom Python Package Index (PyPI) packages to be installed in the environment. Keys refer to the lowercase package name (e.g. "numpy"). Values are the lowercase extras and version specifier (e.g. "==1.12.0", "[devel,gcp_api]", "[devel]>=1.8.2, <1.9.2"). To specify a package without pinning it to a version specifier, use the empty string as the value.
         */
        pypiPackages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The major version of Python used to run the Apache Airflow scheduler, worker, and webserver processes. Can be set to '2' or '3'. If not specified, the default is '2'. Cannot be updated. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*. Environments in newer versions always use Python major version 3.
         */
        pythonVersion?: pulumi.Input<string>;
        /**
         * The number of schedulers for Airflow. This field is supported for Cloud Composer environments in versions composer-1.*.*-airflow-2.*.*.
         */
        schedulerCount?: pulumi.Input<number>;
        /**
         * Should be either 'ENABLED' or 'DISABLED'. Defaults to 'ENABLED'. Used in Composer 3.
         */
        webServerPluginsMode?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigSoftwareConfigCloudDataLineageIntegration {
        /**
         * Whether or not Cloud Data Lineage integration is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigWebServerConfig {
        /**
         * Optional. Machine type on which Airflow web server is running. It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or composer-n1-webserver-8. If not specified, composer-n1-webserver-2 will be used. Value custom is returned only in response, if Airflow web server parameters were manually changed to a non-standard values.
         */
        machineType: pulumi.Input<string>;
    }

    export interface EnvironmentConfigWebServerNetworkAccessControl {
        /**
         * A collection of allowed IP ranges with descriptions.
         */
        allowedIpRanges?: pulumi.Input<pulumi.Input<inputs.composer.EnvironmentConfigWebServerNetworkAccessControlAllowedIpRange>[]>;
    }

    export interface EnvironmentConfigWebServerNetworkAccessControlAllowedIpRange {
        /**
         * A description of this ip range.
         */
        description?: pulumi.Input<string>;
        /**
         * IP address or range, defined using CIDR notation, of requests that this rule applies to. Examples: 192.168.1.1 or 192.168.0.0/16 or 2001:db8::/32 or 2001:0db8:0000:0042:0000:8a2e:0370:7334. IP range prefixes should be properly truncated. For example, 1.2.3.4/24 should be truncated to 1.2.3.0/24. Similarly, for IPv6, 2001:db8::1/32 should be truncated to 2001:db8::/32.
         */
        value: pulumi.Input<string>;
    }

    export interface EnvironmentConfigWorkloadsConfig {
        /**
         * Configuration for resources used by DAG processor.
         */
        dagProcessor?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfigDagProcessor>;
        /**
         * Configuration for resources used by Airflow schedulers.
         */
        scheduler?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfigScheduler>;
        /**
         * Configuration for resources used by Airflow triggerers.
         */
        triggerer?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfigTriggerer>;
        /**
         * Configuration for resources used by Airflow web server.
         */
        webServer?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfigWebServer>;
        /**
         * Configuration for resources used by Airflow workers.
         */
        worker?: pulumi.Input<inputs.composer.EnvironmentConfigWorkloadsConfigWorker>;
    }

    export interface EnvironmentConfigWorkloadsConfigDagProcessor {
        /**
         * Number of DAG processors.
         */
        count?: pulumi.Input<number>;
        /**
         * CPU request and limit for DAG processor.
         */
        cpu?: pulumi.Input<number>;
        /**
         * Memory (GB) request and limit for DAG processor.
         */
        memoryGb?: pulumi.Input<number>;
        /**
         * Storage (GB) request and limit for DAG processor.
         */
        storageGb?: pulumi.Input<number>;
    }

    export interface EnvironmentConfigWorkloadsConfigScheduler {
        /**
         * The number of schedulers.
         */
        count?: pulumi.Input<number>;
        /**
         * CPU request and limit for a single Airflow scheduler replica
         */
        cpu?: pulumi.Input<number>;
        /**
         * Memory (GB) request and limit for a single Airflow scheduler replica.
         */
        memoryGb?: pulumi.Input<number>;
        /**
         * Storage (GB) request and limit for a single Airflow scheduler replica.
         */
        storageGb?: pulumi.Input<number>;
    }

    export interface EnvironmentConfigWorkloadsConfigTriggerer {
        /**
         * The number of triggerers.
         */
        count: pulumi.Input<number>;
        /**
         * CPU request and limit for a single Airflow triggerer replica.
         */
        cpu: pulumi.Input<number>;
        /**
         * Memory (GB) request and limit for a single Airflow triggerer replica.
         */
        memoryGb: pulumi.Input<number>;
    }

    export interface EnvironmentConfigWorkloadsConfigWebServer {
        /**
         * CPU request and limit for Airflow web server.
         */
        cpu?: pulumi.Input<number>;
        /**
         * Memory (GB) request and limit for Airflow web server.
         */
        memoryGb?: pulumi.Input<number>;
        /**
         * Storage (GB) request and limit for Airflow web server.
         */
        storageGb?: pulumi.Input<number>;
    }

    export interface EnvironmentConfigWorkloadsConfigWorker {
        /**
         * CPU request and limit for a single Airflow worker replica.
         */
        cpu?: pulumi.Input<number>;
        /**
         * Maximum number of workers for autoscaling.
         */
        maxCount?: pulumi.Input<number>;
        /**
         * Memory (GB) request and limit for a single Airflow worker replica.
         */
        memoryGb?: pulumi.Input<number>;
        /**
         * Minimum number of workers for autoscaling.
         */
        minCount?: pulumi.Input<number>;
        /**
         * Storage (GB) request and limit for a single Airflow worker replica.
         */
        storageGb?: pulumi.Input<number>;
    }

    export interface EnvironmentStorageConfig {
        /**
         * Optional. Name of an existing Cloud Storage bucket to be used by the environment.
         */
        bucket: pulumi.Input<string>;
    }

}

export namespace compute {
    export interface AutoscalerAutoscalingPolicy {
        /**
         * The number of seconds that the autoscaler should wait before it
         * starts collecting information from a new instance. This prevents
         * the autoscaler from collecting information when the instance is
         * initializing, during which the collected usage would not be
         * reliable. The default time autoscaler waits is 60 seconds.
         * Virtual machine initialization times might vary because of
         * numerous factors. We recommend that you test how long an
         * instance may take to initialize. To do this, create an instance
         * and time the startup process.
         */
        cooldownPeriod?: pulumi.Input<number>;
        /**
         * Defines the CPU utilization policy that allows the autoscaler to
         * scale based on the average CPU utilization of a managed instance
         * group.
         * Structure is documented below.
         */
        cpuUtilization?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyCpuUtilization>;
        /**
         * Configuration parameters of autoscaling based on a load balancer.
         * Structure is documented below.
         */
        loadBalancingUtilization?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        /**
         * The maximum number of instances that the autoscaler can scale up
         * to. This is required when creating or updating an autoscaler. The
         * maximum number of replicas should not be lower than minimal number
         * of replicas.
         */
        maxReplicas: pulumi.Input<number>;
        /**
         * Configuration parameters of autoscaling based on a custom metric.
         * Structure is documented below.
         */
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyMetric>[]>;
        /**
         * The minimum number of replicas that the autoscaler can scale down
         * to. This cannot be less than 0. If not provided, autoscaler will
         * choose a default value depending on maximum number of instances
         * allowed.
         */
        minReplicas: pulumi.Input<number>;
        /**
         * Defines operating mode for this policy.
         */
        mode?: pulumi.Input<string>;
        /**
         * Defines scale down controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events
         * Structure is documented below.
         */
        scaleDownControl?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyScaleDownControl>;
        /**
         * Defines scale in controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events
         * Structure is documented below.
         */
        scaleInControl?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyScaleInControl>;
        /**
         * Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
         * Structure is documented below.
         */
        scalingSchedules?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyScalingSchedule>[]>;
    }

    export interface AutoscalerAutoscalingPolicyCpuUtilization {
        /**
         * Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
         * - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
         * - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
         */
        predictiveMethod?: pulumi.Input<string>;
        /**
         * The target CPU utilization that the autoscaler should maintain.
         * Must be a float value in the range (0, 1]. If not specified, the
         * default is 0.6.
         * If the CPU level is below the target utilization, the autoscaler
         * scales down the number of instances until it reaches the minimum
         * number of instances you specified or until the average CPU of
         * your instances reaches the target utilization.
         * If the average CPU is above the target utilization, the autoscaler
         * scales up until it reaches the maximum number of instances you
         * specified or until the average utilization reaches the target
         * utilization.
         */
        target: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyLoadBalancingUtilization {
        /**
         * Fraction of backend capacity utilization (set in HTTP(s) load
         * balancing configuration) that autoscaler should maintain. Must
         * be a positive float value. If not defined, the default is 0.8.
         */
        target: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyMetric {
        /**
         * A filter string to be used as the filter string for
         * a Stackdriver Monitoring TimeSeries.list API call.
         * This filter is used to select a specific TimeSeries for
         * the purpose of autoscaling and to determine whether the metric
         * is exporting per-instance or per-group data.
         * You can only use the AND operator for joining selectors.
         * You can only use direct equality comparison operator (=) without
         * any functions for each selector.
         * You can specify the metric in both the filter string and in the
         * metric field. However, if specified in both places, the metric must
         * be identical.
         * The monitored resource type determines what kind of values are
         * expected for the metric. If it is a gce_instance, the autoscaler
         * expects the metric to include a separate TimeSeries for each
         * instance in a group. In such a case, you cannot filter on resource
         * labels.
         * If the resource type is any other value, the autoscaler expects
         * this metric to contain values that apply to the entire autoscaled
         * instance group and resource label filtering can be performed to
         * point autoscaler at the correct TimeSeries to scale upon.
         * This is called a per-group metric for the purpose of autoscaling.
         * If not specified, the type defaults to gce_instance.
         * You should provide a filter that is selective enough to pick just
         * one TimeSeries for the autoscaled group or for each of the instances
         * (if you are using gceInstance resource type). If multiple
         * TimeSeries are returned upon the query execution, the autoscaler
         * will sum their respective values to obtain its scaling value.
         */
        filter?: pulumi.Input<string>;
        /**
         * The identifier (type) of the Stackdriver Monitoring metric.
         * The metric cannot have negative values.
         * The metric must have a value type of INT64 or DOUBLE.
         */
        name: pulumi.Input<string>;
        /**
         * If scaling is based on a per-group metric value that represents the
         * total amount of work to be done or resource usage, set this value to
         * an amount assigned for a single instance of the scaled group.
         * The autoscaler will keep the number of instances proportional to the
         * value of this metric, the metric itself should not change value due
         * to group resizing.
         * For example, a good metric to use with the target is
         * `pubsub.googleapis.com/subscription/num_undelivered_messages`
         * or a custom metric exporting the total number of requests coming to
         * your instances.
         * A bad example would be a metric exporting an average or median
         * latency, since this value can't include a chunk assignable to a
         * single instance, it could be better used with utilizationTarget
         * instead.
         */
        singleInstanceAssignment?: pulumi.Input<number>;
        /**
         * The target value of the metric that autoscaler should
         * maintain. This must be a positive value. A utilization
         * metric scales number of virtual machines handling requests
         * to increase or decrease proportionally to the metric.
         * For example, a good metric to use as a utilizationTarget is
         * www.googleapis.com/compute/instance/network/received_bytes_count.
         * The autoscaler will work to keep this value constant for each
         * of the instances.
         */
        target?: pulumi.Input<number>;
        /**
         * Defines how target utilization value is expressed for a
         * Stackdriver Monitoring metric.
         * Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
         */
        type?: pulumi.Input<string>;
    }

    export interface AutoscalerAutoscalingPolicyScaleDownControl {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        maxScaledDownReplicas?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas>;
        /**
         * How long back autoscaling should look when computing recommendations
         * to include directives regarding slower scale down, as described above.
         */
        timeWindowSec?: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas {
        /**
         * Specifies a fixed number of VM instances. This must be a positive
         * integer.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies a percentage of instances between 0 to 100%, inclusive.
         * For example, specify 80 for 80%.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyScaleInControl {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        maxScaledInReplicas?: pulumi.Input<inputs.compute.AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas>;
        /**
         * How long back autoscaling should look when computing recommendations
         * to include directives regarding slower scale down, as described above.
         */
        timeWindowSec?: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas {
        /**
         * Specifies a fixed number of VM instances. This must be a positive
         * integer.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies a percentage of instances between 0 to 100%, inclusive.
         * For example, specify 80 for 80%.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AutoscalerAutoscalingPolicyScalingSchedule {
        /**
         * An optional description of this resource.
         */
        description?: pulumi.Input<string>;
        /**
         * A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
         */
        durationSec: pulumi.Input<number>;
        /**
         * Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
         */
        minRequiredReplicas: pulumi.Input<number>;
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        /**
         * The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
         */
        schedule: pulumi.Input<string>;
        /**
         * The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface BackendBucketCdnPolicy {
        /**
         * Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
         * Structure is documented below.
         */
        bypassCacheOnRequestHeaders?: pulumi.Input<pulumi.Input<inputs.compute.BackendBucketCdnPolicyBypassCacheOnRequestHeader>[]>;
        /**
         * The CacheKeyPolicy for this CdnPolicy.
         * Structure is documented below.
         */
        cacheKeyPolicy?: pulumi.Input<inputs.compute.BackendBucketCdnPolicyCacheKeyPolicy>;
        /**
         * Specifies the cache setting for all responses from this backend.
         * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
         * Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
         */
        cacheMode?: pulumi.Input<string>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin. When the
         * `cacheMode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
         */
        clientTtl?: pulumi.Input<number>;
        /**
         * Specifies the default TTL for cached content served by this origin for responses
         * that do not have an existing valid TTL (max-age or s-max-age). When the `cacheMode`
         * is set to "USE_ORIGIN_HEADERS", you must omit this field.
         */
        defaultTtl?: pulumi.Input<number>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin. When the
         * `cacheMode` is set to "USE_ORIGIN_HEADERS", you must omit this field.
         */
        maxTtl?: pulumi.Input<number>;
        /**
         * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
         */
        negativeCaching?: pulumi.Input<boolean>;
        /**
         * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
         * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
         * Structure is documented below.
         */
        negativeCachingPolicies?: pulumi.Input<pulumi.Input<inputs.compute.BackendBucketCdnPolicyNegativeCachingPolicy>[]>;
        /**
         * If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
         */
        requestCoalescing?: pulumi.Input<boolean>;
        /**
         * Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
         */
        serveWhileStale?: pulumi.Input<number>;
        /**
         * Maximum number of seconds the response to a signed URL request will
         * be considered fresh. After this time period,
         * the response will be revalidated before being served.
         * When serving responses to signed URL requests,
         * Cloud CDN will internally behave as though
         * all responses from this backend had a "Cache-Control: public,
         * max-age=[TTL]" header, regardless of any existing Cache-Control
         * header. The actual headers served in responses will not be altered.
         */
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendBucketCdnPolicyBypassCacheOnRequestHeader {
        /**
         * The header field name to match on when bypassing cache. Values are case-insensitive.
         */
        headerName?: pulumi.Input<string>;
    }

    export interface BackendBucketCdnPolicyCacheKeyPolicy {
        /**
         * Allows HTTP request headers (by name) to be used in the
         * cache key.
         */
        includeHttpHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of query string parameters to include in cache keys.
         * Default parameters are always included. '&' and '=' will
         * be percent encoded and not treated as delimiters.
         */
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendBucketCdnPolicyNegativeCachingPolicy {
        /**
         * The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
         * can be specified as values, and you cannot specify a status code more than once.
         */
        code?: pulumi.Input<number>;
        /**
         * The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
         * (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
         */
        ttl?: pulumi.Input<number>;
    }

    export interface BackendBucketIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BackendBucketIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BackendServiceBackend {
        /**
         * Specifies the balancing mode for this backend.
         * For global HTTP(S) or TCP/SSL load balancing, the default is
         * UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S)),
         * CUSTOM_METRICS (for HTTP(s)) and CONNECTION (for TCP/SSL).
         * See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
         * for an explanation of load balancing modes.
         * Default value is `UTILIZATION`.
         * Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`.
         */
        balancingMode?: pulumi.Input<string>;
        /**
         * A multiplier applied to the group's maximum servicing capacity
         * (based on UTILIZATION, RATE or CONNECTION).
         * Default value is 1, which means the group will serve up to 100%
         * of its configured capacity (depending on balancingMode). A
         * setting of 0 means the group is completely drained, offering
         * 0% of its available Capacity. Valid range is [0.0,1.0].
         */
        capacityScaler?: pulumi.Input<number>;
        /**
         * The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
         * Structure is documented below.
         */
        customMetrics?: pulumi.Input<pulumi.Input<inputs.compute.BackendServiceBackendCustomMetric>[]>;
        /**
         * An optional description of this resource.
         * Provide this property when you create the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * The fully-qualified URL of an Instance Group or Network Endpoint
         * Group resource. In case of instance group this defines the list
         * of instances that serve traffic. Member virtual machine
         * instances from each instance group must live in the same zone as
         * the instance group itself. No two backends in a backend service
         * are allowed to use same Instance Group resource.
         * For Network Endpoint Groups this defines list of endpoints. All
         * endpoints of Network Endpoint Group must be hosted on instances
         * located in the same zone as the Network Endpoint Group.
         * Backend services cannot mix Instance Group and
         * Network Endpoint Group backends.
         * Note that you must specify an Instance Group or Network Endpoint
         * Group resource using the fully-qualified URL, rather than a
         * partial URL.
         */
        group: pulumi.Input<string>;
        /**
         * The max number of simultaneous connections for the group. Can
         * be used with either CONNECTION or UTILIZATION balancing modes.
         * For CONNECTION mode, either maxConnections or one
         * of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
         * as appropriate for group type, must be set.
         */
        maxConnections?: pulumi.Input<number>;
        /**
         * The max number of simultaneous connections that a single backend
         * network endpoint can handle. This is used to calculate the
         * capacity of the group. Can be used in either CONNECTION or
         * UTILIZATION balancing modes.
         * For CONNECTION mode, either
         * maxConnections or maxConnectionsPerEndpoint must be set.
         */
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        /**
         * The max number of simultaneous connections that a single
         * backend instance can handle. This is used to calculate the
         * capacity of the group. Can be used in either CONNECTION or
         * UTILIZATION balancing modes.
         * For CONNECTION mode, either maxConnections or
         * maxConnectionsPerInstance must be set.
         */
        maxConnectionsPerInstance?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) of the group.
         * Can be used with either RATE or UTILIZATION balancing modes,
         * but required if RATE mode. For RATE mode, either maxRate or one
         * of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
         * group type, must be set.
         */
        maxRate?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) that a single backend network
         * endpoint can handle. This is used to calculate the capacity of
         * the group. Can be used in either balancing mode. For RATE mode,
         * either maxRate or maxRatePerEndpoint must be set.
         */
        maxRatePerEndpoint?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) that a single backend
         * instance can handle. This is used to calculate the capacity of
         * the group. Can be used in either balancing mode. For RATE mode,
         * either maxRate or maxRatePerInstance must be set.
         */
        maxRatePerInstance?: pulumi.Input<number>;
        /**
         * Used when balancingMode is UTILIZATION. This ratio defines the
         * CPU utilization target for the group. Valid range is [0.0, 1.0].
         */
        maxUtilization?: pulumi.Input<number>;
        /**
         * This field indicates whether this backend should be fully utilized before sending traffic to backends
         * with default preference. This field cannot be set when loadBalancingScheme is set to 'EXTERNAL'. The possible values are:
         * - PREFERRED: Backends with this preference level will be filled up to their capacity limits first,
         * based on RTT.
         * - DEFAULT: If preferred backends don't have enough capacity, backends in this layer would be used and
         * traffic would be assigned based on the load balancing algorithm you use. This is the default
         * Possible values are: `PREFERRED`, `DEFAULT`.
         */
        preference?: pulumi.Input<string>;
    }

    export interface BackendServiceBackendCustomMetric {
        /**
         * If true, the metric data is not used for load balancing.
         */
        dryRun: pulumi.Input<boolean>;
        /**
         * Optional parameter to define a target utilization for the Custom Metrics
         * balancing mode. The valid range is <code>[0.0, 1.0]</code>.
         */
        maxUtilization?: pulumi.Input<number>;
        /**
         * Name of a custom utilization signal. The name must be 1-64 characters
         * long and match the regular expression a-z? which
         * means the first character must be a lowercase letter, and all following
         * characters must be a dash, period, underscore, lowercase letter, or
         * digit, except the last character, which cannot be a dash, period, or
         * underscore. For usage guidelines, see Custom Metrics balancing mode. This
         * field can only be used for a global or regional backend service with the
         * loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
         * <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
         */
        name: pulumi.Input<string>;
    }

    export interface BackendServiceCdnPolicy {
        /**
         * Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
         * The cache is bypassed for all cdnPolicy.cacheMode settings.
         * Structure is documented below.
         */
        bypassCacheOnRequestHeaders?: pulumi.Input<pulumi.Input<inputs.compute.BackendServiceCdnPolicyBypassCacheOnRequestHeader>[]>;
        /**
         * The CacheKeyPolicy for this CdnPolicy.
         * Structure is documented below.
         */
        cacheKeyPolicy?: pulumi.Input<inputs.compute.BackendServiceCdnPolicyCacheKeyPolicy>;
        /**
         * Specifies the cache setting for all responses from this backend.
         * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
         * Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
         */
        cacheMode?: pulumi.Input<string>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin.
         */
        clientTtl?: pulumi.Input<number>;
        /**
         * Specifies the default TTL for cached content served by this origin for responses
         * that do not have an existing valid TTL (max-age or s-max-age).
         */
        defaultTtl?: pulumi.Input<number>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin.
         */
        maxTtl?: pulumi.Input<number>;
        /**
         * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
         */
        negativeCaching?: pulumi.Input<boolean>;
        /**
         * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
         * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
         * Structure is documented below.
         */
        negativeCachingPolicies?: pulumi.Input<pulumi.Input<inputs.compute.BackendServiceCdnPolicyNegativeCachingPolicy>[]>;
        /**
         * If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests
         * to the origin.
         */
        requestCoalescing?: pulumi.Input<boolean>;
        /**
         * Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
         */
        serveWhileStale?: pulumi.Input<number>;
        /**
         * Maximum number of seconds the response to a signed URL request
         * will be considered fresh, defaults to 1hr (3600s). After this
         * time period, the response will be revalidated before
         * being served.
         * When serving responses to signed URL requests, Cloud CDN will
         * internally behave as though all responses from this backend had a
         * "Cache-Control: public, max-age=[TTL]" header, regardless of any
         * existing Cache-Control header. The actual headers served in
         * responses will not be altered.
         */
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicyBypassCacheOnRequestHeader {
        /**
         * The header field name to match on when bypassing cache. Values are case-insensitive.
         */
        headerName: pulumi.Input<string>;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        /**
         * If true requests to different hosts will be cached separately.
         */
        includeHost?: pulumi.Input<boolean>;
        /**
         * Allows HTTP request headers (by name) to be used in the
         * cache key.
         */
        includeHttpHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of cookies to include in cache keys.
         */
        includeNamedCookies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, http and https requests will be cached separately.
         */
        includeProtocol?: pulumi.Input<boolean>;
        /**
         * If true, include query string parameters in the cache key
         * according to queryStringWhitelist and
         * query_string_blacklist. If neither is set, the entire query
         * string will be included.
         * If false, the query string will be excluded from the cache
         * key entirely.
         */
        includeQueryString?: pulumi.Input<boolean>;
        /**
         * Names of query string parameters to exclude in cache keys.
         * All other parameters will be included. Either specify
         * queryStringWhitelist or query_string_blacklist, not both.
         * '&' and '=' will be percent encoded and not treated as
         * delimiters.
         */
        queryStringBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of query string parameters to include in cache keys.
         * All other parameters will be excluded. Either specify
         * queryStringWhitelist or query_string_blacklist, not both.
         * '&' and '=' will be percent encoded and not treated as
         * delimiters.
         */
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendServiceCdnPolicyNegativeCachingPolicy {
        /**
         * The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
         * can be specified as values, and you cannot specify a status code more than once.
         */
        code?: pulumi.Input<number>;
        /**
         * The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
         * (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
         */
        ttl?: pulumi.Input<number>;
    }

    export interface BackendServiceCircuitBreakers {
        /**
         * The timeout for new network connections to hosts.
         * Structure is documented below.
         */
        connectTimeout?: pulumi.Input<inputs.compute.BackendServiceCircuitBreakersConnectTimeout>;
        /**
         * The maximum number of connections to the backend cluster.
         * Defaults to 1024.
         */
        maxConnections?: pulumi.Input<number>;
        /**
         * The maximum number of pending requests to the backend cluster.
         * Defaults to 1024.
         */
        maxPendingRequests?: pulumi.Input<number>;
        /**
         * The maximum number of parallel requests to the backend cluster.
         * Defaults to 1024.
         */
        maxRequests?: pulumi.Input<number>;
        /**
         * Maximum requests for a single backend connection. This parameter
         * is respected by both the HTTP/1.1 and HTTP/2 implementations. If
         * not specified, there is no limit. Setting this parameter to 1
         * will effectively disable keep alive.
         */
        maxRequestsPerConnection?: pulumi.Input<number>;
        /**
         * The maximum number of parallel retries to the backend cluster.
         * Defaults to 3.
         */
        maxRetries?: pulumi.Input<number>;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHash {
        /**
         * Hash is based on HTTP Cookie. This field describes a HTTP cookie
         * that will be used as the hash key for the consistent hash load
         * balancer. If the cookie is not present, it will be generated.
         * This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
         * Structure is documented below.
         */
        httpCookie?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookie>;
        /**
         * The hash based on the value of the specified header field.
         * This field is applicable if the sessionAffinity is set to HEADER_FIELD.
         */
        httpHeaderName?: pulumi.Input<string>;
        /**
         * The minimum number of virtual nodes to use for the hash ring.
         * Larger ring sizes result in more granular load
         * distributions. If the number of hosts in the load balancing pool
         * is larger than the ring size, each host will be assigned a single
         * virtual node.
         * Defaults to 1024.
         */
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        /**
         * Name of the cookie.
         */
        name?: pulumi.Input<string>;
        /**
         * Path to set for the cookie.
         */
        path?: pulumi.Input<string>;
        /**
         * Lifetime of the cookie.
         * Structure is documented below.
         */
        ttl?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceCustomMetric {
        /**
         * If true, the metric data is not used for load balancing.
         */
        dryRun: pulumi.Input<boolean>;
        /**
         * Name of a custom utilization signal. The name must be 1-64 characters
         * long and match the regular expression a-z? which
         * means the first character must be a lowercase letter, and all following
         * characters must be a dash, period, underscore, lowercase letter, or
         * digit, except the last character, which cannot be a dash, period, or
         * underscore. For usage guidelines, see Custom Metrics balancing mode. This
         * field can only be used for a global or regional backend service with the
         * loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
         * <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
         */
        name: pulumi.Input<string>;
    }

    export interface BackendServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BackendServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BackendServiceIap {
        /**
         * Whether the serving infrastructure will authenticate and authorize all incoming requests.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * OAuth2 Client ID for IAP
         */
        oauth2ClientId?: pulumi.Input<string>;
        /**
         * OAuth2 Client Secret for IAP
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        oauth2ClientSecret?: pulumi.Input<string>;
        /**
         * (Output)
         * OAuth2 Client Secret SHA-256 for IAP
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface BackendServiceLocalityLbPolicy {
        /**
         * The configuration for a custom policy implemented by the user and
         * deployed with the client.
         * Structure is documented below.
         */
        customPolicy?: pulumi.Input<inputs.compute.BackendServiceLocalityLbPolicyCustomPolicy>;
        /**
         * The configuration for a built-in load balancing policy.
         * Structure is documented below.
         */
        policy?: pulumi.Input<inputs.compute.BackendServiceLocalityLbPolicyPolicy>;
    }

    export interface BackendServiceLocalityLbPolicyCustomPolicy {
        /**
         * An optional, arbitrary JSON object with configuration data, understood
         * by a locally installed custom policy implementation.
         */
        data?: pulumi.Input<string>;
        /**
         * Identifies the custom policy.
         * The value should match the type the custom implementation is registered
         * with on the gRPC clients. It should follow protocol buffer
         * message naming conventions and include the full path (e.g.
         * myorg.CustomLbPolicy). The maximum length is 256 characters.
         * Note that specifying the same custom policy more than once for a
         * backend is not a valid configuration and will be rejected.
         */
        name: pulumi.Input<string>;
    }

    export interface BackendServiceLocalityLbPolicyPolicy {
        /**
         * The name of a locality load balancer policy to be used. The value
         * should be one of the predefined ones as supported by localityLbPolicy,
         * although at the moment only ROUND_ROBIN is supported.
         * This field should only be populated when the customPolicy field is not
         * used.
         * Note that specifying the same policy more than once for a backend is
         * not a valid configuration and will be rejected.
         * The possible values are:
         * * `ROUND_ROBIN`: This is a simple policy in which each healthy backend
         * is selected in round robin order.
         * * `LEAST_REQUEST`: An O(1) algorithm which selects two random healthy
         * hosts and picks the host which has fewer active requests.
         * * `RING_HASH`: The ring/modulo hash load balancer implements consistent
         * hashing to backends. The algorithm has the property that the
         * addition/removal of a host from a set of N hosts only affects
         * 1/N of the requests.
         * * `RANDOM`: The load balancer selects a random healthy host.
         * * `ORIGINAL_DESTINATION`: Backend host is selected based on the client
         * connection metadata, i.e., connections are opened
         * to the same address as the destination address of
         * the incoming connection before the connection
         * was redirected to the load balancer.
         * * `MAGLEV`: used as a drop in replacement for the ring hash load balancer.
         * Maglev is not as stable as ring hash but has faster table lookup
         * build times and host selection times. For more information about
         * Maglev, refer to https://ai.google/research/pubs/pub44824
         * Possible values are: `ROUND_ROBIN`, `LEAST_REQUEST`, `RING_HASH`, `RANDOM`, `ORIGINAL_DESTINATION`, `MAGLEV`.
         */
        name: pulumi.Input<string>;
    }

    export interface BackendServiceLogConfig {
        /**
         * Whether to enable logging for the load balancer traffic served by this backend service.
         */
        enable?: pulumi.Input<boolean>;
        /**
         * This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode"
         * was set to CUSTOM. Contains a list of optional fields you want to include in the logs.
         * For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
         */
        optionalFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the optional logging mode for the load balancer traffic.
         * Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
         * Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
         */
        optionalMode?: pulumi.Input<string>;
        /**
         * This field can only be specified if logging is enabled for this backend service. The value of
         * the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
         * where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
         * The default value is 1.0.
         */
        sampleRate?: pulumi.Input<number>;
    }

    export interface BackendServiceMaxStreamDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution.
         * Durations less than one second are represented with a 0 seconds field and a positive nanos field.
         * Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. (int64 format)
         */
        seconds: pulumi.Input<string>;
    }

    export interface BackendServiceOutlierDetection {
        /**
         * The base time that a host is ejected for. The real time is equal to the base
         * time multiplied by the number of times the host has been ejected. Defaults to
         * 30000ms or 30s.
         * Structure is documented below.
         */
        baseEjectionTime?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionBaseEjectionTime>;
        /**
         * Number of errors before a host is ejected from the connection pool. When the
         * backend host is accessed over HTTP, a 5xx return code qualifies as an error.
         * Defaults to 5.
         */
        consecutiveErrors?: pulumi.Input<number>;
        /**
         * The number of consecutive gateway failures (502, 503, 504 status or connection
         * errors that are mapped to one of those status codes) before a consecutive
         * gateway failure ejection occurs. Defaults to 5.
         */
        consecutiveGatewayFailure?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through consecutive 5xx. This setting can be used to disable
         * ejection or to ramp it up slowly. Defaults to 100.
         */
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through consecutive gateway failures. This setting can be
         * used to disable ejection or to ramp it up slowly. Defaults to 0.
         */
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through success rate statistics. This setting can be used to
         * disable ejection or to ramp it up slowly. Defaults to 100.
         */
        enforcingSuccessRate?: pulumi.Input<number>;
        /**
         * Time interval between ejection sweep analysis. This can result in both new
         * ejections as well as hosts being returned to service. Defaults to 10 seconds.
         * Structure is documented below.
         */
        interval?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionInterval>;
        /**
         * Maximum percentage of hosts in the load balancing pool for the backend service
         * that can be ejected. Defaults to 10%.
         */
        maxEjectionPercent?: pulumi.Input<number>;
        /**
         * The number of hosts in a cluster that must have enough request volume to detect
         * success rate outliers. If the number of hosts is less than this setting, outlier
         * detection via success rate statistics is not performed for any host in the
         * cluster. Defaults to 5.
         */
        successRateMinimumHosts?: pulumi.Input<number>;
        /**
         * The minimum number of total requests that must be collected in one interval (as
         * defined by the interval duration above) to include this host in success rate
         * based outlier detection. If the volume is lower than this setting, outlier
         * detection via success rate statistics is not performed for that host. Defaults
         * to 100.
         */
        successRateRequestVolume?: pulumi.Input<number>;
        /**
         * This factor is used to determine the ejection threshold for success rate outlier
         * ejection. The ejection threshold is the difference between the mean success
         * rate, and the product of this factor and the standard deviation of the mean
         * success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
         * by a thousand to get a double. That is, if the desired factor is 1.9, the
         * runtime value should be 1900. Defaults to 1900.
         */
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations
         * less than one second are represented with a 0 `seconds` field and a positive
         * `nanos` field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
         * inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionInterval {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations
         * less than one second are represented with a 0 `seconds` field and a positive
         * `nanos` field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
         * inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceSecuritySettings {
        /**
         * The configuration needed to generate a signature for access to private storage buckets that support AWS's Signature Version 4 for authentication.
         * Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
         * Structure is documented below.
         *
         *
         * <a name="nestedSecuritySettingsAwsV4Authentication"></a>The `awsV4Authentication` block supports:
         */
        awsV4Authentication?: pulumi.Input<inputs.compute.BackendServiceSecuritySettingsAwsV4Authentication>;
        /**
         * ClientTlsPolicy is a resource that specifies how a client should authenticate
         * connections to backends of a service. This resource itself does not affect
         * configuration unless it is attached to a backend service resource.
         */
        clientTlsPolicy?: pulumi.Input<string>;
        /**
         * A list of alternate names to verify the subject identity in the certificate.
         * If specified, the client will verify that the server certificate's subject
         * alt name matches one of the specified values.
         */
        subjectAltNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendServiceSecuritySettingsAwsV4Authentication {
        /**
         * The access key used for s3 bucket authentication.
         * Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * The identifier of an access key used for s3 bucket authentication.
         */
        accessKeyId?: pulumi.Input<string>;
        /**
         * The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
         */
        accessKeyVersion?: pulumi.Input<string>;
        /**
         * The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin.
         * For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
         */
        originRegion?: pulumi.Input<string>;
    }

    export interface BackendServiceStrongSessionAffinityCookie {
        /**
         * Name of the cookie.
         */
        name?: pulumi.Input<string>;
        /**
         * Path to set for the cookie.
         */
        path?: pulumi.Input<string>;
        /**
         * Lifetime of the cookie.
         * Structure is documented below.
         */
        ttl?: pulumi.Input<inputs.compute.BackendServiceStrongSessionAffinityCookieTtl>;
    }

    export interface BackendServiceStrongSessionAffinityCookieTtl {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceTlsSettings {
        /**
         * Reference to the BackendAuthenticationConfig resource from the networksecurity.googleapis.com namespace.
         * Can be used in authenticating TLS connections to the backend, as specified by the authenticationMode field.
         * Can only be specified if authenticationMode is not NONE.
         */
        authenticationConfig?: pulumi.Input<string>;
        /**
         * Server Name Indication - see RFC3546 section 3.1. If set, the load balancer sends this string as the SNI hostname in the
         * TLS connection to the backend, and requires that this string match a Subject Alternative Name (SAN) in the backend's
         * server certificate. With a Regional Internet NEG backend, if the SNI is specified here, the load balancer uses it
         * regardless of whether the Regional Internet NEG is specified with FQDN or IP address and port.
         */
        sni?: pulumi.Input<string>;
        /**
         * A list of Subject Alternative Names (SANs) that the Load Balancer verifies during a TLS handshake with the backend.
         * When the server presents its X.509 certificate to the Load Balancer, the Load Balancer inspects the certificate's SAN field,
         * and requires that at least one SAN match one of the subjectAltNames in the list. This field is limited to 5 entries.
         * When both sni and subjectAltNames are specified, the load balancer matches the backend certificate's SAN only to
         * subjectAltNames.
         * Structure is documented below.
         */
        subjectAltNames?: pulumi.Input<pulumi.Input<inputs.compute.BackendServiceTlsSettingsSubjectAltName>[]>;
    }

    export interface BackendServiceTlsSettingsSubjectAltName {
        /**
         * The SAN specified as a DNS Name.
         */
        dnsName?: pulumi.Input<string>;
        /**
         * The SAN specified as a URI.
         */
        uniformResourceIdentifier?: pulumi.Input<string>;
    }

    export interface DiskAsyncPrimaryDisk {
        /**
         * Primary disk for asynchronous disk replication.
         */
        disk: pulumi.Input<string>;
    }

    export interface DiskAsyncReplicationSecondaryDisk {
        /**
         * The secondary disk.
         */
        disk: pulumi.Input<string>;
        /**
         * Output-only. Status of replication on the secondary disk.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface DiskDiskEncryptionKey {
        /**
         * The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
         * customer-supplied encryption key to either encrypt or decrypt
         * this resource. You can provide either the rawKey or the rsaEncryptedKey.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface DiskGuestOsFeature {
        /**
         * The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         */
        type: pulumi.Input<string>;
    }

    export interface DiskIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DiskIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DiskParams {
        /**
         * Resource manager tags to be bound to the disk. Tag keys and values have the
         * same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
         * and values are in the format tagValues/456.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface DiskSourceImageEncryptionKey {
        /**
         * The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key used to encrypt the disk. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * The numeric ID for this interface. Allowed values are based on the redundancy type
         * of this external VPN gateway
         * * `0 - SINGLE_IP_INTERNALLY_REDUNDANT`
         * * `0, 1 - TWO_IPS_REDUNDANCY`
         * * `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`
         */
        id?: pulumi.Input<number>;
        /**
         * IP address of the interface in the external VPN gateway.
         * Only IPv4 is supported. This IP address can be either from
         * your on-premise gateway or another Cloud provider's VPN gateway,
         * it cannot be an IP address from Google Compute Engine.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * IPv6 address of the interface in the external VPN gateway. This IPv6
         * address can be either from your on-premise gateway or another Cloud
         * provider's VPN gateway, it cannot be an IP address from Google Compute
         * Engine. Must specify an IPv6 address (not IPV4-mapped) using any format
         * described in RFC 4291 (e.g. 2001:db8:0:0:2d9:51:0:0). The output format
         * is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
         */
        ipv6Address?: pulumi.Input<string>;
    }

    export interface FirewallAllow {
        /**
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: [22], [80, 443], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP protocol to which this rule applies. The protocol type is
         * required when creating a firewall rule. This value can either be
         * one of the following well known protocol strings (tcp, udp,
         * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
         */
        protocol: pulumi.Input<string>;
    }

    export interface FirewallDeny {
        /**
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: [22], [80, 443], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP protocol to which this rule applies. The protocol type is
         * required when creating a firewall rule. This value can either be
         * one of the following well known protocol strings (tcp, udp,
         * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
         */
        protocol: pulumi.Input<string>;
    }

    export interface FirewallLogConfig {
        /**
         * This field denotes whether to include or exclude metadata for firewall logs.
         * Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`.
         */
        metadata: pulumi.Input<string>;
    }

    export interface FirewallPolicyRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.FirewallPolicyRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
         *
         *
         * <a name="nestedMatchLayer4Configs"></a>The `layer4Configs` block supports:
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FirewallPolicyRuleMatchLayer4Config {
        /**
         * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
         * This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FirewallPolicyWithRulesPredefinedRule {
        /**
         * (Output)
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action?: pulumi.Input<string>;
        /**
         * (Output)
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         */
        direction?: pulumi.Input<string>;
        /**
         * (Output)
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * (Output)
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.compute.FirewallPolicyWithRulesPredefinedRuleMatch>[]>;
        /**
         * (Output)
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority?: pulumi.Input<number>;
        /**
         * (Output)
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * (Output)
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * (Output)
         * A list of network resource URLs to which this rule applies.
         * This field allows you to control which network's VMs get
         * this rule. If this field is left blank, all VMs
         * within the organization will receive the rule.
         */
        targetResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface FirewallPolicyWithRulesPredefinedRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        layer4Configs?: pulumi.Input<pulumi.Input<inputs.compute.FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FirewallPolicyWithRulesPredefinedRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol?: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FirewallPolicyWithRulesRule {
        /**
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action: pulumi.Input<string>;
        /**
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         * Possible values are: `INGRESS`, `EGRESS`.
         */
        direction?: pulumi.Input<string>;
        /**
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        match: pulumi.Input<inputs.compute.FirewallPolicyWithRulesRuleMatch>;
        /**
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority: pulumi.Input<number>;
        /**
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * A list of network resource URLs to which this rule applies.
         * This field allows you to control which network's VMs get
         * this rule. If this field is left blank, all VMs
         * within the organization will receive the rule.
         */
        targetResources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface FirewallPolicyWithRulesRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.FirewallPolicyWithRulesRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FirewallPolicyWithRulesRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ForwardingRuleServiceDirectoryRegistrations {
        /**
         * Service Directory namespace to register the forwarding rule under.
         */
        namespace?: pulumi.Input<string>;
        /**
         * Service Directory service to register the forwarding rule under.
         */
        service?: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        /**
         * The list of label value pairs that must match labels in the
         * provided metadata based on filterMatchCriteria
         * This list must not be empty and can have at the most 64 entries.
         * Structure is documented below.
         */
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel>[]>;
        /**
         * Specifies how individual filterLabel matches within the list of
         * filterLabels contribute towards the overall metadataFilter match.
         * MATCH_ANY - At least one of the filterLabels must have a matching
         * label in the provided metadata.
         * MATCH_ALL - All filterLabels must have matching labels in the
         * provided metadata.
         * Possible values are: `MATCH_ANY`, `MATCH_ALL`.
         */
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        /**
         * Name of the metadata label. The length must be between
         * 1 and 1024 characters, inclusive.
         */
        name: pulumi.Input<string>;
        /**
         * The value that the label must match. The value has a maximum
         * length of 1024 characters.
         */
        value: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleServiceDirectoryRegistrations {
        /**
         * Service Directory namespace to register the forwarding rule under.
         */
        namespace?: pulumi.Input<string>;
        /**
         * [Optional] Service Directory region to register this global forwarding rule under.
         * Default to "us-central1". Only used for PSC for Google APIs. All PSC for
         * Google APIs Forwarding Rules on the same network should use the same Service
         * Directory region.
         */
        serviceDirectoryRegion?: pulumi.Input<string>;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * The numeric ID of this VPN gateway interface.
         */
        id?: pulumi.Input<number>;
        /**
         * URL of the interconnect attachment resource. When the value
         * of this field is present, the VPN Gateway will be used for
         * IPsec-encrypted Cloud Interconnect; all Egress or Ingress
         * traffic for this VPN Gateway interface will go through the
         * specified interconnect attachment resource.
         * Not currently available publicly.
         */
        interconnectAttachment?: pulumi.Input<string>;
        /**
         * (Output)
         * The external IP address for this VPN gateway interface.
         */
        ipAddress?: pulumi.Input<string>;
    }

    export interface HealthCheckGrpcHealthCheck {
        /**
         * The gRPC service name for the health check.
         * The value of grpcServiceName has the following meanings by convention:
         * - Empty serviceName means the overall status of all services at the backend.
         * - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
         * The grpcServiceName can only be ASCII.
         */
        grpcServiceName?: pulumi.Input<string>;
        /**
         * The port number for the health check request.
         * Must be specified if portName and portSpecification are not set
         * or if portSpecification is USE_FIXED_PORT. Valid values are 1 through 65535.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, gRPC health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
    }

    export interface HealthCheckGrpcTlsHealthCheck {
        /**
         * The gRPC service name for the health check.
         * The value of grpcServiceName has the following meanings by convention:
         * - Empty serviceName means the overall status of all services at the backend.
         * - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
         * The grpcServiceName can only be ASCII.
         */
        grpcServiceName?: pulumi.Input<string>;
        /**
         * The port number for the health check request.
         * Must be specified if portSpecification is USE_FIXED_PORT. Valid values are 1 through 65535.
         */
        port?: pulumi.Input<number>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, gRPC with TLS health check follows behavior specified in the `port` field.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
    }

    export interface HealthCheckHttp2HealthCheck {
        /**
         * The value of the host header in the HTTP2 health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTP2 health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         *
         *   * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
         *
         *   * 'USE_NAMED_PORT': The 'portName' is used for health checking.
         *
         *   * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
         *   network endpoint is used for health checking. For other backends, the
         *   port or named port specified in the Backend Service is used for health
         *   checking.
         *
         * If not specified, HTTP2 health check follows behavior specified in 'port' and
         * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTP2 health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpHealthCheck {
        /**
         * The value of the host header in the HTTP health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTP health check request.
         * The default value is 80.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTP health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTP health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpsHealthCheck {
        /**
         * The value of the host header in the HTTPS health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTPS health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTPS health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTPS health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckLogConfig {
        /**
         * Indicates whether or not to export logs. This is false by default,
         * which means no health check logging will be done.
         */
        enable?: pulumi.Input<boolean>;
    }

    export interface HealthCheckSslHealthCheck {
        /**
         * The TCP port number for the HTTP2 health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTP2 health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The application data to send once the SSL connection has been
         * established (default value is empty). If both request and response are
         * empty, the connection establishment alone will indicate health. The request
         * data can only be ASCII.
         */
        request?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckTcpHealthCheck {
        /**
         * The TCP port number for the TCP health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, TCP health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The application data to send once the TCP connection has been
         * established (default value is empty). If both request and response are
         * empty, the connection establishment alone will indicate health. The request
         * data can only be ASCII.
         */
        request?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface ImageGuestOsFeature {
        /**
         * The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         * Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `IDPF`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`, `SEV_LIVE_MIGRATABLE_V2`.
         */
        type: pulumi.Input<string>;
    }

    export interface ImageIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ImageIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ImageImageEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud
         * KMS.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the
         * given KMS key. If absent, the Compute Engine default service
         * account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface ImageRawDisk {
        /**
         * The format used to encode and transmit the block device, which
         * should be TAR. This is just a container and transmission format
         * and not a runtime format. Provided by the client when the disk
         * image is created.
         * Default value is `TAR`.
         * Possible values are: `TAR`.
         */
        containerType?: pulumi.Input<string>;
        /**
         * An optional SHA1 checksum of the disk image before unpackaging.
         * This is provided by the client when the disk image is created.
         */
        sha1?: pulumi.Input<string>;
        /**
         * The full Google Cloud Storage URL where disk storage is stored
         * You must provide either this property or the sourceDisk property
         * but not both.
         */
        source: pulumi.Input<string>;
    }

    export interface ImageShieldedInstanceInitialState {
        /**
         * The Key Database (db).
         * Structure is documented below.
         */
        dbs?: pulumi.Input<pulumi.Input<inputs.compute.ImageShieldedInstanceInitialStateDb>[]>;
        /**
         * The forbidden key database (dbx).
         * Structure is documented below.
         */
        dbxs?: pulumi.Input<pulumi.Input<inputs.compute.ImageShieldedInstanceInitialStateDbx>[]>;
        /**
         * The Key Exchange Key (KEK).
         * Structure is documented below.
         */
        keks?: pulumi.Input<pulumi.Input<inputs.compute.ImageShieldedInstanceInitialStateKek>[]>;
        /**
         * The Platform Key (PK).
         * Structure is documented below.
         */
        pk?: pulumi.Input<inputs.compute.ImageShieldedInstanceInitialStatePk>;
    }

    export interface ImageShieldedInstanceInitialStateDb {
        /**
         * The raw content in the secure keys file.
         * A base64-encoded string.
         */
        content: pulumi.Input<string>;
        /**
         * The file type of source file.
         */
        fileType?: pulumi.Input<string>;
    }

    export interface ImageShieldedInstanceInitialStateDbx {
        /**
         * The raw content in the secure keys file.
         * A base64-encoded string.
         */
        content: pulumi.Input<string>;
        /**
         * The file type of source file.
         */
        fileType?: pulumi.Input<string>;
    }

    export interface ImageShieldedInstanceInitialStateKek {
        /**
         * The raw content in the secure keys file.
         * A base64-encoded string.
         */
        content: pulumi.Input<string>;
        /**
         * The file type of source file.
         */
        fileType?: pulumi.Input<string>;
    }

    export interface ImageShieldedInstanceInitialStatePk {
        /**
         * The raw content in the secure keys file.
         * A base64-encoded string.
         */
        content: pulumi.Input<string>;
        /**
         * The file type of source file.
         */
        fileType?: pulumi.Input<string>;
    }

    export interface ImageSourceDiskEncryptionKey {
        /**
         * The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the
         * given KMS key. If absent, the Compute Engine default service
         * account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
         * customer-supplied encryption key to either encrypt or decrypt
         * this resource. You can provide either the rawKey or the rsaEncryptedKey.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface ImageSourceImageEncryptionKey {
        /**
         * The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the
         * given KMS key. If absent, the Compute Engine default service
         * account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
         * customer-supplied encryption key to either encrypt or decrypt
         * this resource. You can provide either the rawKey or the rsaEncryptedKey.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface ImageSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key used to decrypt this resource. Also called KmsKeyName
         * in the cloud console. Your project's Compute Engine System service account
         * (`service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com`) must have
         * `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.
         * See https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the
         * given KMS key. If absent, the Compute Engine default service
         * account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
         * customer-supplied encryption key to either encrypt or decrypt
         * this resource. You can provide either the rawKey or the rsaEncryptedKey.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface InstanceAdvancedMachineFeatures {
        /**
         * Defines whether the instance should have nested virtualization  enabled. Defaults to false.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * Whether to enable UEFI networking for instance creation.
         */
        enableUefiNetworking?: pulumi.Input<boolean>;
        /**
         * [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
         */
        performanceMonitoringUnit?: pulumi.Input<string>;
        /**
         * The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
         */
        threadsPerCore?: pulumi.Input<number>;
        /**
         * Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
         */
        turboMode?: pulumi.Input<string>;
        /**
         * The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
         */
        visibleCoreCount?: pulumi.Input<number>;
    }

    export interface InstanceAttachedDisk {
        /**
         * Name with which the attached disk will be accessible
         * under `/dev/disk/by-id/google-*`
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink`, `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         * may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kmsKeySelfLink`, `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         * may be set.
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * encoded SHA-256 hash of the [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`, `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
         * If you have a persistent disk with data that you want to share
         * between multiple instances, detach it from any read-write instances and
         * attach it to one or more instances in read-only mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk to attach to this instance.
         */
        source: pulumi.Input<string>;
    }

    export interface InstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance
         * is deleted. Defaults to true.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Name with which attached disk will be accessible.
         * On the instance, this device will be `/dev/disk/by-id/google-{{device_name}}`.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink`, `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         * may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to encrypt this disk. Only one of `kmsKeySelfLink`, `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * encoded SHA-256 hash of the [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * boolean field that determines whether to force attach the regional
         * disk even if it's currently attached to another instance. If you try to force attach a zonal
         * disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters for a new disk that will be created
         * alongside the new instance. Either `initializeParams` or `source` must be set.
         * Structure is documented below.
         */
        initializeParams?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParams>;
        /**
         * The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attachedDisk and only used for specific cases, please don't specify this field without advice from Google.)
         */
        interface?: pulumi.Input<string>;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`,
         * `diskEncryptionKeyRsa` and `diskEncryptionKeyRaw`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The mode in which to attach this disk, either `READ_WRITE`
         * or `READ_ONLY`. If not specified, the default is to attach the disk in `READ_WRITE` mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the existing disk (such as those managed by
         * `gcp.compute.Disk`) or disk image. To create an instance from a snapshot, first create a
         * `gcp.compute.Disk` from a snapshot and reference it here.
         */
        source?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParams {
        /**
         * The architecture of the attached disk. Valid values are `ARM64` or `x8664`.
         */
        architecture?: pulumi.Input<string>;
        /**
         * Whether this disk is using confidential compute mode.
         * Note: Only supported on hyperdisk skus, diskEncryptionKey is required when setting to true.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
        /**
         * The image from which to initialize this disk. This can be
         * one of: the image's `selfLink`, `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
         * images names must include the family name. If they don't, use the
         * [gcp.compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).
         * For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
         * These images can be referred by family name here.
         */
        image?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs assigned to the disk. This
         * field is only applicable for persistent disks.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Indicates how many IOPS to provision for the disk.
         * This sets the number of I/O operations per second that the disk can handle.
         * For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
         * Note: Updating currently is only supported for hyperdisk skus via disk update
         * api/gcloud without the need to delete and recreate the disk, hyperdisk allows
         * for an update of IOPS every 4 hours. To update your hyperdisk more frequently,
         * you'll need to manually delete and recreate it.
         */
        provisionedIops?: pulumi.Input<number>;
        /**
         * Indicates how much throughput to provision for the disk.
         * This sets the number of throughput mb per second that the disk can handle.
         * For more details,see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
         * Note: Updating currently is only supported for hyperdisk skus via disk update
         * api/gcloud without the need to delete and recreate the disk, hyperdisk allows
         * for an update of throughput every 4 hours. To update your hyperdisk more
         * frequently, you'll need to manually delete and recreate it.
         */
        provisionedThroughput?: pulumi.Input<number>;
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of selfLinks of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate, so any external values are not set until the user specifies this field. Currently a max of 1 resource policy is supported.
         */
        resourcePolicies?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes. If not specified, it
         * will inherit the size of its base image.
         */
        size?: pulumi.Input<number>;
        /**
         * The snapshot from which to initialize this disk. To create a disk with a snapshot that you created, specify the snapshot name in the following format: `global/snapshots/my-backup`
         */
        snapshot?: pulumi.Input<string>;
        /**
         * Encryption key used to decrypt the given image. Structure is documented below.
         */
        sourceImageEncryptionKey?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParamsSourceImageEncryptionKey>;
        /**
         * Encryption key used to decrypt the given snapshot. Structure is documented below.
         */
        sourceSnapshotEncryptionKey?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey>;
        /**
         * The URL or the name of the storage pool in which the new disk is created.
         * For example:
         * * https://www.googleapis.com/compute/v1/projects/{project}/zones/{zone}/storagePools/{storagePool}
         * * /projects/{project}/zones/{zone}/storagePools/{storagePool}
         * * /zones/{zone}/storagePools/{storagePool}
         * * /{storagePool}
         */
        storagePool?: pulumi.Input<string>;
        /**
         * The GCE disk type. Such as pd-standard, pd-balanced or pd-ssd.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParamsSourceImageEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * encoded SHA-256 hash of the [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParamsSourceSnapshotEncryptionKey {
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to decrypt the given image. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to decrypt the given snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * encoded SHA-256 hash of the [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceConfidentialInstanceConfig {
        /**
         * Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `onHostMaintenance` can be set to MIGRATE if `confidentialInstanceType` is set to `SEV` and `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `minCpuPlatform` has to be set to `"AMD Milan"` or this will fail to create the VM.
         */
        confidentialInstanceType?: pulumi.Input<string>;
        /**
         * Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `onHostMaintenance` can be set to MIGRATE if `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface InstanceFromMachineImageAdvancedMachineFeatures {
        /**
         * Whether to enable nested virtualization or not.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * Whether to enable UEFI networking for the instance.
         */
        enableUefiNetworking?: pulumi.Input<boolean>;
        /**
         * The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
         */
        performanceMonitoringUnit?: pulumi.Input<string>;
        /**
         * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
         */
        threadsPerCore?: pulumi.Input<number>;
        /**
         * Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
         */
        turboMode?: pulumi.Input<string>;
        /**
         * The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\'s nominal CPU count and the underlying platform\'s SMT width.
         */
        visibleCoreCount?: pulumi.Input<number>;
    }

    export interface InstanceFromMachineImageAttachedDisk {
        /**
         * Name with which the attached disk is accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * The selfLink of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Name with which attached disk will be accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * A list of features to enable on the guest operating system. Applicable only for bootable images.
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters with which a disk was created alongside the instance.
         */
        initializeParams?: pulumi.Input<inputs.compute.InstanceFromMachineImageBootDiskInitializeParams>;
        /**
         * The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attachedDisk and only used for specific cases, please don't specify this field without advice from Google.)
         */
        interface?: pulumi.Input<string>;
        /**
         * The selfLink of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageBootDiskInitializeParams {
        /**
         * The architecture of the disk. One of "X86_64" or "ARM64".
         */
        architecture?: pulumi.Input<string>;
        /**
         * A flag to enable confidential compute mode on boot disk
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
        /**
         * The image from which this disk was initialised.
         */
        image?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs assigned to the disk.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
         */
        provisionedIops?: pulumi.Input<number>;
        /**
         * Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
         */
        provisionedThroughput?: pulumi.Input<number>;
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of selfLinks of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
         */
        resourcePolicies?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes.
         */
        size?: pulumi.Input<number>;
        /**
         * The snapshot from which this disk was initialised.
         */
        snapshot?: pulumi.Input<string>;
        /**
         * The encryption key used to decrypt the source image.
         */
        sourceImageEncryptionKey?: pulumi.Input<inputs.compute.InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey>;
        /**
         * The encryption key used to decrypt the source snapshot.
         */
        sourceSnapshotEncryptionKey?: pulumi.Input<inputs.compute.InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey>;
        /**
         * The URL of the storage pool in which the new disk is created
         */
        storagePool?: pulumi.Input<string>;
        /**
         * The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageBootDiskInitializeParamsSourceImageEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the encryption key used to encrypt this disk.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageBootDiskInitializeParamsSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the encryption key used to encrypt this disk.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageConfidentialInstanceConfig {
        /**
         * The confidential computing technology the instance uses.
         * 								SEV is an AMD feature. TDX is an Intel feature. One of the following
         * 								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, minCpuPlatform =
         * 								"AMD Milan" is currently required.
         */
        confidentialInstanceType?: pulumi.Input<string>;
        /**
         * Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface InstanceFromMachineImageGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageInstanceEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the customer's encryption key.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromMachineImageNetworkInterfaceAccessConfig>[]>;
        /**
         * An array of alias IP ranges for this network interface.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromMachineImageNetworkInterfaceAliasIpRange>[]>;
        /**
         * The prefix length of the primary internal IPv6 range.
         */
        internalIpv6PrefixLength?: pulumi.Input<number>;
        /**
         * An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
         */
        ipv6AccessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig>[]>;
        /**
         * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
         */
        ipv6AccessType?: pulumi.Input<string>;
        /**
         * An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
         */
        ipv6Address?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network?: pulumi.Input<string>;
        /**
         * The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
         */
        networkAttachment?: pulumi.Input<string>;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
         */
        nicType?: pulumi.Input<string>;
        /**
         * The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
        /**
         * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
         */
        stackType?: pulumi.Input<string>;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageNetworkInterfaceAccessConfig {
        /**
         * The IP address that is be 1:1 mapped to the instance's network ip.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig {
        /**
         * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
         */
        externalIpv6?: pulumi.Input<string>;
        /**
         * The prefix length of the external IPv6 range.
         */
        externalIpv6PrefixLength?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
         */
        networkTier: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageNetworkPerformanceConfig {
        /**
         * The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageParams {
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceFromMachineImageReservationAffinity {
        /**
         * Specifies the label selector for the reservation to use.
         */
        specificReservation?: pulumi.Input<inputs.compute.InstanceFromMachineImageReservationAffinitySpecificReservation>;
        /**
         * The type of reservation from which this instance can consume resources.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageReservationAffinitySpecificReservation {
        /**
         * Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
         */
        key: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromMachineImageScheduling {
        /**
         * Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies the availability domain, which this instance should be scheduled on.
         */
        availabilityDomain?: pulumi.Input<number>;
        /**
         * Settings for the instance to perform a graceful shutdown.
         */
        gracefulShutdown?: pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingGracefulShutdown>;
        /**
         * Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
         */
        hostErrorTimeoutSeconds?: pulumi.Input<number>;
        /**
         * Specifies the action GCE should take when SPOT VM is preempted.
         */
        instanceTerminationAction?: pulumi.Input<string>;
        /**
         * Specifies the maximum amount of time a Local Ssd Vm should wait while
         *   recovery of the Local Ssd state is attempted. Its value should be in
         *   between 0 and 168 hours with hour granularity and the default value being 1
         *   hour.
         */
        localSsdRecoveryTimeout?: pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout>;
        /**
         * Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
         */
        maintenanceInterval?: pulumi.Input<string>;
        /**
         * The timeout for new network connections to hosts.
         */
        maxRunDuration?: pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingMaxRunDuration>;
        minNodeCpus?: pulumi.Input<number>;
        /**
         * Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingNodeAffinity>[]>;
        /**
         * Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Defines the behaviour for instances with the instance_termination_action.
         */
        onInstanceStopAction?: pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingOnInstanceStopAction>;
        /**
         * Whether the instance is preemptible.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Whether the instance is spot. If this is set as SPOT.
         */
        provisioningModel?: pulumi.Input<string>;
        /**
         * Specifies the timestamp, when the instance will be terminated,
         * in RFC3339 text format. If specified, the instance termination action
         * will be performed at the termination time.
         */
        terminationTime?: pulumi.Input<string>;
    }

    export interface InstanceFromMachineImageSchedulingGracefulShutdown {
        /**
         * Opts-in for graceful shutdown.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The time allotted for the instance to gracefully shut down.
         * 										If the graceful shutdown isn't complete after this time, then the instance
         * 										transitions to the STOPPING state.
         */
        maxDuration?: pulumi.Input<inputs.compute.InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration>;
    }

    export interface InstanceFromMachineImageSchedulingGracefulShutdownMaxDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * 													resolution. Durations less than one second are represented
         * 													with a 0 seconds field and a positive nanos field. Must
         * 													be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * 													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromMachineImageSchedulingLocalSsdRecoveryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromMachineImageSchedulingMaxRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromMachineImageSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromMachineImageSchedulingOnInstanceStopAction {
        /**
         * If true, the contents of any attached Local SSD disks will be discarded.
         */
        discardLocalSsd?: pulumi.Input<boolean>;
    }

    export interface InstanceFromMachineImageScratchDisk {
        /**
         * Name with which the attached disk is accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * The disk interface used for attaching this disk. One of SCSI or NVME.
         */
        interface: pulumi.Input<string>;
        /**
         * The size of the disk in gigabytes. One of 375 or 3000.
         */
        size?: pulumi.Input<number>;
    }

    export interface InstanceFromMachineImageServiceAccount {
        /**
         * The service account e-mail address.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes.
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromMachineImageShieldedInstanceConfig {
        /**
         * Whether integrity monitoring is enabled for the instance.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Whether secure boot is enabled for the instance.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Whether the instance uses vTPM.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceFromMachineImageSourceMachineImageEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        kmsKeyServiceAccount?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        rsaEncryptedKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateAdvancedMachineFeatures {
        /**
         * Whether to enable nested virtualization or not.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * Whether to enable UEFI networking for the instance.
         */
        enableUefiNetworking?: pulumi.Input<boolean>;
        /**
         * The PMU is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are "STANDARD", "ENHANCED", and "ARCHITECTURAL".
         */
        performanceMonitoringUnit?: pulumi.Input<string>;
        /**
         * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
         */
        threadsPerCore?: pulumi.Input<number>;
        /**
         * Turbo frequency mode to use for the instance. Currently supported modes is "ALL_CORE_MAX".
         */
        turboMode?: pulumi.Input<string>;
        /**
         * The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\'s nominal CPU count and the underlying platform\'s SMT width.
         */
        visibleCoreCount?: pulumi.Input<number>;
    }

    export interface InstanceFromTemplateAttachedDisk {
        /**
         * Name with which the attached disk is accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * The selfLink of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRsa and diskEncryptionKeyRaw may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Name with which attached disk will be accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        diskEncryptionKeyRsa?: pulumi.Input<string>;
        /**
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
         */
        diskEncryptionKeySha256?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used
         */
        diskEncryptionServiceAccount?: pulumi.Input<string>;
        /**
         * Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error. Setting this parameter cause VM recreation.
         */
        forceAttach?: pulumi.Input<boolean>;
        /**
         * A list of features to enable on the guest operating system. Applicable only for bootable images.
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters with which a disk was created alongside the instance.
         */
        initializeParams?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParams>;
        /**
         * The disk interface used for attaching this disk. One of SCSI or NVME. (This field is shared with attachedDisk and only used for specific cases, please don't specify this field without advice from Google.)
         */
        interface?: pulumi.Input<string>;
        /**
         * The selfLink of the encryption key that is stored in Google Cloud KMS to encrypt this disk. Only one of kms_key_self_link, diskEncryptionKeyRaw and diskEncryptionKeyRsa may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
         */
        mode?: pulumi.Input<string>;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        /**
         * The architecture of the disk. One of "X86_64" or "ARM64".
         */
        architecture?: pulumi.Input<string>;
        /**
         * A flag to enable confidential compute mode on boot disk
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
        /**
         * The image from which this disk was initialised.
         */
        image?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs assigned to the disk.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle.
         */
        provisionedIops?: pulumi.Input<number>;
        /**
         * Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle.
         */
        provisionedThroughput?: pulumi.Input<number>;
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of selfLinks of resource policies to attach to the instance's boot disk. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.
         */
        resourcePolicies?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes.
         */
        size?: pulumi.Input<number>;
        /**
         * The snapshot from which this disk was initialised.
         */
        snapshot?: pulumi.Input<string>;
        /**
         * The encryption key used to decrypt the source image.
         */
        sourceImageEncryptionKey?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey>;
        /**
         * The encryption key used to decrypt the source snapshot.
         */
        sourceSnapshotEncryptionKey?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey>;
        /**
         * The URL of the storage pool in which the new disk is created
         */
        storagePool?: pulumi.Input<string>;
        /**
         * The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParamsSourceImageEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the encryption key used to encrypt this disk.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParamsSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. Only one of kms_key_self_link, rsaEncryptedKey and rawKey may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the encryption key used to encrypt this disk.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateConfidentialInstanceConfig {
        /**
         * The confidential computing technology the instance uses.
         * 								SEV is an AMD feature. TDX is an Intel feature. One of the following
         * 								values is required: SEV, SEV_SNP, TDX. If SEV_SNP, minCpuPlatform =
         * 								"AMD Milan" is currently required.
         */
        confidentialInstanceType?: pulumi.Input<string>;
        /**
         * Defines whether the instance should have confidential compute enabled. Field will be deprecated in a future release
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateInstanceEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the customer's encryption key.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig>[]>;
        /**
         * An array of alias IP ranges for this network interface.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * The prefix length of the primary internal IPv6 range.
         */
        internalIpv6PrefixLength?: pulumi.Input<number>;
        /**
         * An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
         */
        ipv6AccessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceIpv6AccessConfig>[]>;
        /**
         * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
         */
        ipv6AccessType?: pulumi.Input<string>;
        /**
         * An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
         */
        ipv6Address?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network?: pulumi.Input<string>;
        /**
         * The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
         */
        networkAttachment?: pulumi.Input<string>;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET, IDPF, MRDMA, and IRDMA
         */
        nicType?: pulumi.Input<string>;
        /**
         * The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
        /**
         * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
         */
        stackType?: pulumi.Input<string>;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        /**
         * The IP address that is be 1:1 mapped to the instance's network ip.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceIpv6AccessConfig {
        /**
         * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
         */
        externalIpv6?: pulumi.Input<string>;
        /**
         * The prefix length of the external IPv6 range.
         */
        externalIpv6PrefixLength?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
         */
        networkTier: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkPerformanceConfig {
        /**
         * The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateParams {
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceFromTemplateReservationAffinity {
        /**
         * Specifies the label selector for the reservation to use.
         */
        specificReservation?: pulumi.Input<inputs.compute.InstanceFromTemplateReservationAffinitySpecificReservation>;
        /**
         * The type of reservation from which this instance can consume resources.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateReservationAffinitySpecificReservation {
        /**
         * Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
         */
        key: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateScheduling {
        /**
         * Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies the availability domain, which this instance should be scheduled on.
         */
        availabilityDomain?: pulumi.Input<number>;
        /**
         * Settings for the instance to perform a graceful shutdown.
         */
        gracefulShutdown?: pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingGracefulShutdown>;
        /**
         * Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
         */
        hostErrorTimeoutSeconds?: pulumi.Input<number>;
        /**
         * Specifies the action GCE should take when SPOT VM is preempted.
         */
        instanceTerminationAction?: pulumi.Input<string>;
        /**
         * Specifies the maximum amount of time a Local Ssd Vm should wait while
         *   recovery of the Local Ssd state is attempted. Its value should be in
         *   between 0 and 168 hours with hour granularity and the default value being 1
         *   hour.
         */
        localSsdRecoveryTimeout?: pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout>;
        /**
         * Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
         */
        maintenanceInterval?: pulumi.Input<string>;
        /**
         * The timeout for new network connections to hosts.
         */
        maxRunDuration?: pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingMaxRunDuration>;
        minNodeCpus?: pulumi.Input<number>;
        /**
         * Specifies node affinities or anti-affinities to determine which sole-tenant nodes your instances and managed instance groups will use as host systems.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingNodeAffinity>[]>;
        /**
         * Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Defines the behaviour for instances with the instance_termination_action.
         */
        onInstanceStopAction?: pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingOnInstanceStopAction>;
        /**
         * Whether the instance is preemptible.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Whether the instance is spot. If this is set as SPOT.
         */
        provisioningModel?: pulumi.Input<string>;
        /**
         * Specifies the timestamp, when the instance will be terminated,
         * in RFC3339 text format. If specified, the instance termination action
         * will be performed at the termination time.
         */
        terminationTime?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateSchedulingGracefulShutdown {
        /**
         * Opts-in for graceful shutdown.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The time allotted for the instance to gracefully shut down.
         * 										If the graceful shutdown isn't complete after this time, then the instance
         * 										transitions to the STOPPING state.
         */
        maxDuration?: pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingGracefulShutdownMaxDuration>;
    }

    export interface InstanceFromTemplateSchedulingGracefulShutdownMaxDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * 													resolution. Durations less than one second are represented
         * 													with a 0 seconds field and a positive nanos field. Must
         * 													be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * 													The value must be between 1 and 3600, which is 3,600 seconds (one hour).
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromTemplateSchedulingLocalSsdRecoveryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromTemplateSchedulingMaxRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateSchedulingOnInstanceStopAction {
        /**
         * If true, the contents of any attached Local SSD disks will be discarded.
         */
        discardLocalSsd?: pulumi.Input<boolean>;
    }

    export interface InstanceFromTemplateScratchDisk {
        /**
         * Name with which the attached disk is accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * The disk interface used for attaching this disk. One of SCSI or NVME.
         */
        interface: pulumi.Input<string>;
        /**
         * The size of the disk in gigabytes. One of 375 or 3000.
         */
        size?: pulumi.Input<number>;
    }

    export interface InstanceFromTemplateServiceAccount {
        /**
         * The service account e-mail address.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes.
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        /**
         * Whether integrity monitoring is enabled for the instance.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Whether secure boot is enabled for the instance.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Whether the instance uses vTPM.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerAllInstancesConfig {
        /**
         * , The label key-value pairs that you want to patch onto the instance.
         *
         * - - -
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * , The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: pulumi.Input<string>;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerInstanceLifecyclePolicy {
        /**
         * , Specifies the action that a MIG performs on a failed VM. If the value of the `onFailedHealthCheck` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
         */
        defaultActionOnFailure?: pulumi.Input<string>;
        /**
         * , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
         */
        forceUpdateOnRepair?: pulumi.Input<string>;
        /**
         * , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `defaultActionOnFailure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG.
         *
         * - - -
         */
        onFailedHealthCheck?: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the port.
         */
        name: pulumi.Input<string>;
        /**
         * The port number.
         * - - -
         */
        port: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerParams {
        /**
         * Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceGroupManagerStandbyPolicy {
        /**
         * Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
         */
        initialDelaySec?: pulumi.Input<number>;
        /**
         * Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
         * - - -
         */
        mode?: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerStatefulDisk {
        /**
         * , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The device name of the disk to be attached.
         */
        deviceName: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerStatefulExternalIp {
        /**
         * , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The network interface name of the external Ip. Possible value: `nic0`
         */
        interfaceName?: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerStatefulInternalIp {
        /**
         * , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The network interface name of the internal Ip. Possible value: `nic0`
         */
        interfaceName?: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerStatus {
        /**
         * Properties to set on all instances in the group. After setting
         * allInstancesConfig on the group, you must update the group's instances to
         * apply the configuration.
         */
        allInstancesConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceGroupManagerStatusAllInstancesConfig>[]>;
        /**
         * A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
         */
        isStable?: pulumi.Input<boolean>;
        /**
         * Stateful status of the given Instance Group Manager.
         */
        statefuls?: pulumi.Input<pulumi.Input<inputs.compute.InstanceGroupManagerStatusStateful>[]>;
        /**
         * A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
         */
        versionTargets?: pulumi.Input<pulumi.Input<inputs.compute.InstanceGroupManagerStatusVersionTarget>[]>;
    }

    export interface InstanceGroupManagerStatusAllInstancesConfig {
        /**
         * Current all-instances configuration revision. This value is in RFC3339 text format.
         */
        currentRevision?: pulumi.Input<string>;
        /**
         * A bit indicating whether this configuration has been applied to all managed instances in the group.
         */
        effective?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerStatusStateful {
        /**
         * A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
         */
        hasStatefulConfig?: pulumi.Input<boolean>;
        /**
         * Status of per-instance configs on the instances.
         */
        perInstanceConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceGroupManagerStatusStatefulPerInstanceConfig>[]>;
    }

    export interface InstanceGroupManagerStatusStatefulPerInstanceConfig {
        /**
         * A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
         */
        allEffective?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerStatusVersionTarget {
        /**
         * A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
         */
        isReached?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        /**
         * , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `maxSurgePercent`. Both cannot be 0.
         */
        maxSurgeFixed?: pulumi.Input<number>;
        /**
         * , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `maxSurgeFixed`.
         */
        maxSurgePercent?: pulumi.Input<number>;
        /**
         * , Specifies a fixed number of VM instances. This must be a positive integer.
         */
        maxUnavailableFixed?: pulumi.Input<number>;
        /**
         * , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
         */
        maxUnavailablePercent?: pulumi.Input<number>;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         */
        minReadySec?: pulumi.Input<number>;
        /**
         * Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: pulumi.Input<string>;
        /**
         * Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
         */
        mostDisruptiveAllowedAction?: pulumi.Input<string>;
        /**
         * , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set maxUnavailableFixed or maxUnavailablePercent to be greater than 0.
         * - - -
         */
        replacementMethod?: pulumi.Input<string>;
        /**
         * The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerVersion {
        /**
         * The full URL to an instance template from which all new instances of this version will be created. It is recommended to reference instance templates through their unique id (`selfLinkUnique` attribute).
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * Version name.
         */
        name?: pulumi.Input<string>;
        /**
         * The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         *
         * > Exactly one `version` you specify must not have a `targetSize` specified. During a rolling update, the instance group manager will fulfill the `targetSize`
         * constraints of every other `version`, and any remaining instances will be provisioned with the version where `targetSize` is unset.
         */
        targetSize?: pulumi.Input<inputs.compute.InstanceGroupManagerVersionTargetSize>;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: pulumi.Input<number>;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: pulumi.Input<number>;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name which the port will be mapped to.
         */
        name: pulumi.Input<string>;
        /**
         * The port number to map the name to.
         */
        port: pulumi.Input<number>;
    }

    export interface InstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceInstanceEncryptionKey {
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt the data on this instance.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * The SHA256 hash of the customer's encryption key.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAccessConfig>[]>;
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAliasIpRange>[]>;
        /**
         * The prefix length of the primary internal IPv6 range.
         */
        internalIpv6PrefixLength?: pulumi.Input<number>;
        /**
         * An array of IPv6 access configurations for this interface.
         * Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
         * specified, then this instance will have no external IPv6 Internet access. Structure documented below.
         */
        ipv6AccessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceIpv6AccessConfig>[]>;
        /**
         * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet.
         * This field is always inherited from its subnetwork.
         */
        ipv6AccessType?: pulumi.Input<string>;
        /**
         * An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
         */
        ipv6Address?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Either `network` or `subnetwork` must be provided. If network isn't provided it will
         * be inferred from the subnetwork.
         */
        network?: pulumi.Input<string>;
        /**
         * The URL of the network attachment that this interface should connect to in the following format: `projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}`.
         */
        networkAttachment?: pulumi.Input<string>;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, IDPF, MRDMA, IRDMA.
         */
        nicType?: pulumi.Input<string>;
        /**
         * The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
        /**
         * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
         */
        stackType?: pulumi.Input<string>;
        /**
         * The name or selfLink of the subnetwork to attach this
         * interface to. Either `network` or `subnetwork` must be provided. If network isn't provided
         * it will be inferred from the subnetwork. The subnetwork must exist in the same region this
         * instance will be created in. If the network resource is in
         * [legacy](https://cloud.google.com/vpc/docs/legacy) mode, do not specify this field. If the
         * network is in auto subnet mode, specifying the subnetwork is optional. If the network is
         * in custom subnet mode, specifying the subnetwork is required.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The project in which the subnetwork belongs.
         * If the `subnetwork` is a self_link, this field is set to the project
         * defined in the subnetwork self_link. If the `subnetwork` is a name and this
         * field is not provided, the provider project is used.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the
         * subnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6
         * records for the external IPv6 ranges..
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. This range may be a single IP address
         * (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceIpv6AccessConfig {
        /**
         * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
         */
        externalIpv6?: pulumi.Input<string>;
        /**
         * The prefix length of the external IPv6 range.
         */
        externalIpv6PrefixLength?: pulumi.Input<string>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
         */
        networkTier: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
         */
        publicPtrDomainName?: pulumi.Input<string>;
        /**
         * A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    export interface InstanceNetworkPerformanceConfig {
        /**
         * The egress bandwidth tier to enable.
         * Possible values: TIER_1, DEFAULT
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface InstanceParams {
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceReservationAffinity {
        /**
         * Specifies the label selector for the reservation to use..
         * Structure is documented below.
         */
        specificReservation?: pulumi.Input<inputs.compute.InstanceReservationAffinitySpecificReservation>;
        /**
         * The type of reservation from which this instance can consume resources.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceReservationAffinitySpecificReservation {
        /**
         * Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
         */
        key: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         * Defaults to true.
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
         */
        availabilityDomain?: pulumi.Input<number>;
        /**
         * Settings for the instance to perform a graceful shutdown. Structure is documented below.
         */
        gracefulShutdown?: pulumi.Input<inputs.compute.InstanceSchedulingGracefulShutdown>;
        /**
         * Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
         */
        hostErrorTimeoutSeconds?: pulumi.Input<number>;
        /**
         * Describe the type of termination action for VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
         */
        instanceTerminationAction?: pulumi.Input<string>;
        /**
         * Specifies the maximum amount of time a Local Ssd Vm should wait while
         *   recovery of the Local Ssd state is attempted. Its value should be in
         *   between 0 and 168 hours with hour granularity and the default value being 1
         *   hour.
         */
        localSsdRecoveryTimeout?: pulumi.Input<inputs.compute.InstanceSchedulingLocalSsdRecoveryTimeout>;
        /**
         * Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
         */
        maintenanceInterval?: pulumi.Input<string>;
        /**
         * The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instanceTerminationAction`. Structure is documented below.
         */
        maxRunDuration?: pulumi.Input<inputs.compute.InstanceSchedulingMaxRunDuration>;
        /**
         * The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
         */
        minNodeCpus?: pulumi.Input<number>;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulingNodeAffinity>[]>;
        /**
         * Describes maintenance behavior for the
         * instance. Can be MIGRATE or TERMINATE, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Specifies the action to be performed when the instance is terminated using `maxRunDuration` and `STOP` `instanceTerminationAction`. Only support `true` `discardLocalSsd` at this point. Structure is documented below.
         */
        onInstanceStopAction?: pulumi.Input<inputs.compute.InstanceSchedulingOnInstanceStopAction>;
        /**
         * Specifies if the instance is preemptible.
         * If this field is set to true, then `automaticRestart` must be
         * set to false.  Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
         * `preemptible` should be `true` and `automaticRestart` should be
         * `false`. For more info about
         * `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
         */
        provisioningModel?: pulumi.Input<string>;
        /**
         * Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
         */
        terminationTime?: pulumi.Input<string>;
    }

    export interface InstanceSchedulingGracefulShutdown {
        /**
         * Opts-in for graceful shutdown.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The time allotted for the instance to gracefully shut down.
         * If the graceful shutdown isn't complete after this time, then the instance
         * transitions to the STOPPING state. Structure is documented below:
         */
        maxDuration?: pulumi.Input<inputs.compute.InstanceSchedulingGracefulShutdownMaxDuration>;
    }

    export interface InstanceSchedulingGracefulShutdownMaxDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceSchedulingLocalSsdRecoveryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to
         * 315,576,000,000 inclusive. Note: these bounds are computed from: 60
         * sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceSchedulingMaxRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to
         * 315,576,000,000 inclusive. Note: these bounds are computed from: 60
         * sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: pulumi.Input<string>;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: pulumi.Input<string>;
        /**
         * The values for the node affinity label.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceSchedulingOnInstanceStopAction {
        /**
         * Whether to discard local SSDs attached to the VM while terminating using `maxRunDuration`. Only supports `true` at this point.
         */
        discardLocalSsd?: pulumi.Input<boolean>;
    }

    export interface InstanceScratchDisk {
        /**
         * Name with which the attached disk is accessible under /dev/disk/by-id/
         */
        deviceName?: pulumi.Input<string>;
        /**
         * The disk interface to use for attaching this disk; either SCSI or NVME.
         */
        interface: pulumi.Input<string>;
        /**
         * The size of the disk in gigabytes. One of 375 or 3000.
         */
        size?: pulumi.Input<number>;
    }

    export interface InstanceServiceAccount {
        /**
         * The service account e-mail address.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceSettingsMetadata {
        /**
         * A metadata key/value items map. The total size of all keys and values must be less than 512KB
         */
        items?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceShieldedInstanceConfig {
        /**
         * - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateAdvancedMachineFeatures {
        /**
         * Defines whether the instance should have nested virtualization enabled. Defaults to false.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * Whether to enable UEFI networking for instance creation.
         */
        enableUefiNetworking?: pulumi.Input<boolean>;
        /**
         * [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
         */
        performanceMonitoringUnit?: pulumi.Input<string>;
        /**
         * The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
         */
        threadsPerCore?: pulumi.Input<number>;
        /**
         * Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
         */
        turboMode?: pulumi.Input<string>;
        /**
         * The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
         */
        visibleCoreCount?: pulumi.Input<number>;
    }

    export interface InstanceTemplateConfidentialInstanceConfig {
        /**
         * Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `onHostMaintenance` can be set to MIGRATE if `confidentialInstanceType` is set to `SEV` and `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `minCpuPlatform` has to be set to `"AMD Milan"` or this will fail to create the VM.
         */
        confidentialInstanceType?: pulumi.Input<string>;
        /**
         * Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `onHostMaintenance` can be set to MIGRATE if `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateDisk {
        /**
         * The architecture of the attached disk. Valid values are `ARM64` or `x8664`.
         */
        architecture?: pulumi.Input<string>;
        /**
         * Whether or not the disk should be auto-deleted.
         * This defaults to true.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Indicates that this is a boot disk.
         */
        boot?: pulumi.Input<boolean>;
        /**
         * A unique device name that is reflected into the
         * /dev/  tree of a Linux operating system running within the instance. If not
         * specified, the server chooses a default device name to apply to this disk.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * Encrypts or decrypts a disk using a customer-supplied encryption key.
         *
         * If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.
         *
         * If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.
         *
         * If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.
         *
         * Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
         */
        diskEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskDiskEncryptionKey>;
        /**
         * Name of the disk. When not provided, this defaults
         * to the name of the instance.
         */
        diskName?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes. If not
         * specified, it will inherit the size of its base image. For SCRATCH disks,
         * the size must be exactly 375GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
         * `"pd-balanced"` or `"pd-standard"`, `"hyperdisk-balanced"`, `"hyperdisk-throughput"` or `"hyperdisk-extreme"`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the disk interface to use for attaching this disk,
         * which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
         * and the request will fail if you attempt to attach a persistent disk in any other format
         * than SCSI. Local SSDs can use either NVME or SCSI.
         */
        interface?: pulumi.Input<string>;
        /**
         * A set of ket/value label pairs to assign to disk created from
         * this template
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The mode in which to attach this disk, either READ_WRITE
         * or READ_ONLY. If you are attaching or creating a boot disk, this must
         * read-write mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * Indicates how many IOPS to provision for the disk. This
         * sets the number of I/O operations per second that the disk can handle.
         * Values must be between 10,000 and 120,000. For more details, see the
         * [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
         */
        provisionedIops?: pulumi.Input<number>;
        /**
         * Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
         */
        provisionedThroughput?: pulumi.Input<number>;
        /**
         * A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
         */
        resourcePolicies?: pulumi.Input<string>;
        /**
         * The name (**not self_link**)
         * of the disk (such as those managed by `gcp.compute.Disk`) to attach.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        source?: pulumi.Input<string>;
        /**
         * The image from which to
         * initialize this disk. This can be one of: the image's `selfLink`,
         * `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        sourceImage?: pulumi.Input<string>;
        /**
         * The customer-supplied encryption
         * key of the source image. Required if the source image is protected by a
         * customer-supplied encryption key.
         *
         * Instance templates do not store customer-supplied encryption keys, so you
         * cannot create disks for instances in a managed instance group if the source
         * images are encrypted with your own keys. Structure
         * documented below.
         */
        sourceImageEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskSourceImageEncryptionKey>;
        /**
         * The source snapshot to create this disk.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        sourceSnapshot?: pulumi.Input<string>;
        /**
         * The customer-supplied encryption
         * key of the source snapshot. Structure
         * documented below.
         */
        sourceSnapshotEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskSourceSnapshotEncryptionKey>;
        /**
         * The type of GCE disk, can be either `"SCRATCH"` or
         * `"PERSISTENT"`.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskSourceImageEncryptionKey {
        /**
         * The self link of the encryption key that is
         * stored in Google Cloud KMS. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to decrypt the given image. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key that is
         * stored in Google Cloud KMS. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to decrypt this snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface InstanceTemplateGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceTemplateIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceTemplateIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Omit to ensure that the instance
         * is not accessible from the Internet (this means that ssh provisioners will
         * not work unless you can send traffic to the instance's
         * network (e.g. via tunnel or because it is running on another cloud instance
         * on that network). This block can be specified once per `networkInterface`. Structure documented below.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAccessConfig>[]>;
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * The prefix length of the primary internal IPv6 range.
         */
        internalIpv6PrefixLength?: pulumi.Input<number>;
        /**
         * An array of IPv6 access configurations for this interface.
         * Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
         * specified, then this instance will have no external IPv6 Internet access. Structure documented below.
         */
        ipv6AccessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceIpv6AccessConfig>[]>;
        /**
         * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
         */
        ipv6AccessType?: pulumi.Input<string>;
        /**
         * An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
         */
        ipv6Address?: pulumi.Input<string>;
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Use `network` attribute for Legacy or Auto subnetted networks and
         * `subnetwork` for custom subnetted networks.
         */
        network?: pulumi.Input<string>;
        /**
         * The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
         */
        networkAttachment?: pulumi.Input<string>;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
         */
        nicType?: pulumi.Input<string>;
        /**
         * The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
         */
        stackType?: pulumi.Input<string>;
        /**
         * the name of the subnetwork to attach this interface
         * to. The subnetwork must exist in the same `region` this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The ID of the project in which the subnetwork belongs.
         * If it is not provided, the provider project is used.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the
         * subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
         */
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. At the time of writing only a
         * netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
         * error.
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceIpv6AccessConfig {
        /**
         * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
         */
        externalIpv6?: pulumi.Input<string>;
        /**
         * The prefix length of the external IPv6 range.
         */
        externalIpv6PrefixLength?: pulumi.Input<string>;
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
         */
        networkTier: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
         */
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkPerformanceConfig {
        /**
         * The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface InstanceTemplateReservationAffinity {
        /**
         * Specifies the label selector for the reservation to use..
         * Structure is documented below.
         */
        specificReservation?: pulumi.Input<inputs.compute.InstanceTemplateReservationAffinitySpecificReservation>;
        /**
         * The type of reservation from which this instance can consume resources.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceTemplateReservationAffinitySpecificReservation {
        /**
         * Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
         */
        key: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateScheduling {
        /**
         * Specifies whether the instance should be
         * automatically restarted if it is terminated by Compute Engine (not
         * terminated by a user). This defaults to true.
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
         */
        availabilityDomain?: pulumi.Input<number>;
        /**
         * Settings for the instance to perform a graceful shutdown. Structure is documented below.
         */
        gracefulShutdown?: pulumi.Input<inputs.compute.InstanceTemplateSchedulingGracefulShutdown>;
        /**
         * Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
         */
        hostErrorTimeoutSeconds?: pulumi.Input<number>;
        /**
         * Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
         */
        instanceTerminationAction?: pulumi.Input<string>;
        /**
         * Specifies the maximum amount of time a Local Ssd Vm should wait while
         *   recovery of the Local Ssd state is attempted. Its value should be in
         *   between 0 and 168 hours with hour granularity and the default value being 1
         *   hour.
         */
        localSsdRecoveryTimeouts?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateSchedulingLocalSsdRecoveryTimeout>[]>;
        /**
         * Specifies the frequency of planned maintenance events. The accepted values are: `PERIODIC`.
         */
        maintenanceInterval?: pulumi.Input<string>;
        /**
         * The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instanceTerminationAction`. Structure is documented below.
         */
        maxRunDuration?: pulumi.Input<inputs.compute.InstanceTemplateSchedulingMaxRunDuration>;
        /**
         * Minimum number of cpus for the instance.
         */
        minNodeCpus?: pulumi.Input<number>;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateSchedulingNodeAffinity>[]>;
        /**
         * Defines the maintenance behavior for this
         * instance.
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Specifies the action to be performed when the instance is terminated using `maxRunDuration` and `STOP` `instanceTerminationAction`. Only support `true` `discardLocalSsd` at this point. Structure is documented below.
         */
        onInstanceStopAction?: pulumi.Input<inputs.compute.InstanceTemplateSchedulingOnInstanceStopAction>;
        /**
         * Allows instance to be preempted. This defaults to
         * false. Read more on this
         * [here](https://cloud.google.com/compute/docs/instances/preemptible).
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
         * `preemptible` should be `true` and `automaticRestart` should be
         * `false`. For more info about
         * `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
         */
        provisioningModel?: pulumi.Input<string>;
        /**
         * Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
         */
        terminationTime?: pulumi.Input<string>;
    }

    export interface InstanceTemplateSchedulingGracefulShutdown {
        /**
         * Opts-in for graceful shutdown.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The time allotted for the instance to gracefully shut down.
         * If the graceful shutdown isn't complete after this time, then the instance
         * transitions to the STOPPING state. Structure is documented below:
         */
        maxDuration?: pulumi.Input<inputs.compute.InstanceTemplateSchedulingGracefulShutdownMaxDuration>;
    }

    export interface InstanceTemplateSchedulingGracefulShutdownMaxDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceTemplateSchedulingLocalSsdRecoveryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to
         * 315,576,000,000 inclusive. Note: these bounds are computed from: 60
         * sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceTemplateSchedulingMaxRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to
         * 315,576,000,000 inclusive. Note: these bounds are computed from: 60
         * sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
         */
        seconds: pulumi.Input<number>;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: pulumi.Input<string>;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateSchedulingOnInstanceStopAction {
        /**
         * Whether to discard local SSDs attached to the VM while terminating using `maxRunDuration`. Only supports `true` at this point.
         */
        discardLocalSsd?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         *
         * The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
         * explains that access scopes are the legacy method of specifying permissions for your instance.
         * To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
         * To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
         * See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
         * and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        /**
         * - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstantSnapshotIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstantSnapshotIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        /**
         * (Output)
         * 802.1q encapsulation tag to be used for traffic between
         * Google and the customer, going to and from this network and region.
         */
        tag8021q?: pulumi.Input<number>;
    }

    export interface InterconnectCircuitInfo {
        /**
         * (Output)
         * Customer-side demarc ID for this circuit.
         */
        customerDemarcId?: pulumi.Input<string>;
        /**
         * (Output)
         * Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
         */
        googleCircuitId?: pulumi.Input<string>;
        /**
         * (Output)
         * Google-side demarc ID for this circuit. Assigned at circuit turn-up and provided by
         * Google to the customer in the LOA.
         */
        googleDemarcId?: pulumi.Input<string>;
    }

    export interface InterconnectExpectedOutage {
        /**
         * (Output)
         * If issueType is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs that will be
         * affected.
         */
        affectedCircuits?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Scheduled end time for the outage (milliseconds since Unix epoch).
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Form this outage is expected to take. Note that the versions of this enum prefixed with
         * "IT_" have been deprecated in favor of the unprefixed values. Can take one of the
         * following values:
         * - OUTAGE: The Interconnect may be completely out of service for some or all of the
         * specified window.
         * - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain
         * up, but with reduced bandwidth.
         */
        issueType?: pulumi.Input<string>;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be
         * 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters
         * long and match the regular expression `a-z?` which means the first
         * character must be a lowercase letter, and all following characters must be a dash,
         * lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * The party that generated this notification. Note that the value of NSRC_GOOGLE has been
         * deprecated in favor of GOOGLE. Can take the following value:
         * - GOOGLE: this notification as generated by Google.
         */
        source?: pulumi.Input<string>;
        /**
         * (Output)
         * Scheduled start time for the outage (milliseconds since Unix epoch).
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * State of this notification. Note that the versions of this enum prefixed with "NS_" have
         * been deprecated in favor of the unprefixed values. Can take one of the following values:
         * - ACTIVE: This outage notification is active. The event could be in the past, present,
         * or future. See startTime and endTime for scheduling.
         * - CANCELLED: The outage associated with this notification was cancelled before the
         * outage was due to start.
         * - COMPLETED: The outage associated with this notification is complete.
         */
        state?: pulumi.Input<string>;
    }

    export interface InterconnectMacsec {
        /**
         * If set to true, the Interconnect connection is configured with a should-secure
         * MACsec security policy, that allows the Google router to fallback to cleartext
         * traffic if the MKA session cannot be established. By default, the Interconnect
         * connection is configured with a must-secure security policy that drops all traffic
         * if the MKA session cannot be established with your router.
         */
        failOpen?: pulumi.Input<boolean>;
        /**
         * A keychain placeholder describing a set of named key objects along with their
         * start times. A MACsec CKN/CAK is generated for each key in the key chain.
         * Google router automatically picks the key with the most recent startTime when establishing
         * or re-establishing a MACsec secure link.
         * Structure is documented below.
         */
        preSharedKeys: pulumi.Input<pulumi.Input<inputs.compute.InterconnectMacsecPreSharedKey>[]>;
    }

    export interface InterconnectMacsecPreSharedKey {
        /**
         * (Optional, Deprecated)
         * If set to true, the Interconnect connection is configured with a should-secure
         * MACsec security policy, that allows the Google router to fallback to cleartext
         * traffic if the MKA session cannot be established. By default, the Interconnect
         * connection is configured with a must-secure security policy that drops all traffic
         * if the MKA session cannot be established with your router.
         *
         * > **Warning:** `failOpen` is deprecated and will be removed in a future major release. Use other `failOpen` instead.
         *
         * @deprecated `failOpen` is deprecated and will be removed in a future major release. Use other `failOpen` instead.
         */
        failOpen?: pulumi.Input<boolean>;
        /**
         * A name for this pre-shared key. The name must be 1-63 characters long, and
         * comply with RFC1035. Specifically, the name must be 1-63 characters long and match
         * the regular expression `a-z?` which means the first character
         * must be a lowercase letter, and all following characters must be a dash, lowercase
         * letter, or digit, except the last character, which cannot be a dash.
         */
        name: pulumi.Input<string>;
        /**
         * A RFC3339 timestamp on or after which the key is valid. startTime can be in the
         * future. If the keychain has a single key, startTime can be omitted. If the keychain
         * has multiple keys, startTime is mandatory for each key. The start times of keys must
         * be in increasing order. The start times of two consecutive keys must be at least 6
         * hours apart.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface MachineImageIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface MachineImageIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface MachineImageMachineImageEncryptionKey {
        /**
         * The name of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the
         * customer-supplied encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface ManagedSslCertificateManaged {
        /**
         * Domains for which a managed SSL certificate will be valid.  Currently,
         * there can be up to 100 domains in this list.
         */
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MangedSslCertificateManaged {
        /**
         * Domains for which a managed SSL certificate will be valid.  Currently,
         * there can be up to 100 domains in this list.
         */
        domains: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkAttachmentConnectionEndpoint {
        /**
         * (Output)
         * The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * The project id or number of the interface to which the IP was assigned.
         */
        projectIdOrNum?: pulumi.Input<string>;
        /**
         * (Output)
         * Alias IP ranges from the same subnetwork.
         */
        secondaryIpCidrRanges?: pulumi.Input<string>;
        /**
         * (Output)
         * The status of a connected endpoint to this network attachment.
         */
        status?: pulumi.Input<string>;
        /**
         * (Output)
         * The subnetwork used to assign the IP to the producer instance network interface.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface NetworkEndpointListNetworkEndpoint {
        /**
         * The name for a specific VM instance that the IP address belongs to.
         * This is required for network endpoints of type GCE_VM_IP_PORT.
         * The instance must be in the same zone as the network endpoint group.
         */
        instance?: pulumi.Input<string>;
        /**
         * IPv4 address of network endpoint. The IP address must belong
         * to a VM in GCE (either the primary IP or as part of an aliased IP
         * range).
         */
        ipAddress: pulumi.Input<string>;
        /**
         * Port number of network endpoint.
         * **Note** `port` is required unless the Network Endpoint Group is created
         * with the type of `GCE_VM_IP`
         */
        port?: pulumi.Input<number>;
    }

    export interface NetworkFirewallPolicyPacketMirroringRuleMatch {
        /**
         * CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         *
         *
         * <a name="nestedMatchLayer4Configs"></a>The `layer4Configs` block supports:
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config>[]>;
        /**
         * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyPacketMirroringRuleMatchLayer4Config {
        /**
         * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
         * This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyPacketMirroringRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * diff_suppress_func: 'tpgresource.CompareSelfLinkOrResourceName'
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
         *
         *
         * <a name="nestedMatchLayer4Configs"></a>The `layer4Configs` block supports:
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyRuleMatchLayer4Config {
        /**
         * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
         * This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyWithRulesPredefinedRule {
        /**
         * (Output)
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action?: pulumi.Input<string>;
        /**
         * (Output)
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         */
        direction?: pulumi.Input<string>;
        /**
         * (Output)
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * (Output)
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesPredefinedRuleMatch>[]>;
        /**
         * (Output)
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority?: pulumi.Input<number>;
        /**
         * (Output)
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * (Output)
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * (Output)
         * A list of secure tags that controls which instances the firewall rule
         * applies to. If <code>targetSecureTag</code> are specified, then the
         * firewall rule applies only to instances in the VPC network that have one
         * of those EFFECTIVE secure tags, if all the targetSecureTag are in
         * INEFFECTIVE state, then this rule will be ignored.
         * <code>targetSecureTag</code> may not be set at the same time as
         * <code>targetServiceAccounts</code>.
         * If neither <code>targetServiceAccounts</code> nor
         * <code>targetSecureTag</code> are specified, the firewall rule applies
         * to all instances on the specified network.
         * Maximum number of target label tags allowed is 256.
         * Structure is documented below.
         */
        targetSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag>[]>;
        /**
         * (Output)
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface NetworkFirewallPolicyWithRulesPredefinedRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source
         * of the traffic.
         * For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
         * and there is no <code>srcIpRange</code>, this rule will be ignored.
         * Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol?: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyWithRulesRule {
        /**
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action: pulumi.Input<string>;
        /**
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         * Possible values are: `INGRESS`, `EGRESS`.
         */
        direction?: pulumi.Input<string>;
        /**
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        match: pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesRuleMatch>;
        /**
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority: pulumi.Input<number>;
        /**
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * A list of secure tags that controls which instances the firewall rule
         * applies to. If <code>targetSecureTag</code> are specified, then the
         * firewall rule applies only to instances in the VPC network that have one
         * of those EFFECTIVE secure tags, if all the targetSecureTag are in
         * INEFFECTIVE state, then this rule will be ignored.
         * <code>targetSecureTag</code> may not be set at the same time as
         * <code>targetServiceAccounts</code>.
         * If neither <code>targetServiceAccounts</code> nor
         * <code>targetSecureTag</code> are specified, the firewall rule applies
         * to all instances on the specified network.
         * Maximum number of target label tags allowed is 256.
         * Structure is documented below.
         */
        targetSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesRuleTargetSecureTag>[]>;
        /**
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface NetworkFirewallPolicyWithRulesRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source
         * of the traffic.
         * For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
         * and there is no <code>srcIpRange</code>, this rule will be ignored.
         * Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyWithRulesRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkFirewallPolicyWithRulesRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface NodeGroupAutoscalingPolicy {
        /**
         * Maximum size of the node group. Set to a value less than or equal
         * to 100 and greater than or equal to min-nodes.
         */
        maxNodes?: pulumi.Input<number>;
        /**
         * Minimum size of the node group. Must be less
         * than or equal to max-nodes. The default value is 0.
         */
        minNodes?: pulumi.Input<number>;
        /**
         * The autoscaling mode. Set to one of the following:
         * - OFF: Disables the autoscaler.
         * - ON: Enables scaling in and scaling out.
         * - ONLY_SCALE_OUT: Enables only scaling out.
         * You must use this mode if your node groups are configured to
         * restart their hosted VMs on minimal servers.
         * Possible values are: `OFF`, `ON`, `ONLY_SCALE_OUT`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface NodeGroupMaintenanceWindow {
        /**
         * instances.start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
         */
        startTime: pulumi.Input<string>;
    }

    export interface NodeGroupShareSettings {
        /**
         * A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
         * Structure is documented below.
         */
        projectMaps?: pulumi.Input<pulumi.Input<inputs.compute.NodeGroupShareSettingsProjectMap>[]>;
        /**
         * Node group sharing type.
         * Possible values are: `ORGANIZATION`, `SPECIFIC_PROJECTS`, `LOCAL`.
         */
        shareType: pulumi.Input<string>;
    }

    export interface NodeGroupShareSettingsProjectMap {
        /**
         * The identifier for this object. Format specified above.
         */
        id: pulumi.Input<string>;
        /**
         * The project id/number should be the same as the key of this project config in the project map.
         */
        projectId: pulumi.Input<string>;
    }

    export interface NodeTemplateAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this
         * node template.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * Full or partial URL of the accelerator type resource to expose
         * to this node template.
         */
        acceleratorType?: pulumi.Input<string>;
    }

    export interface NodeTemplateDisk {
        /**
         * Specifies the number of such disks.
         */
        diskCount?: pulumi.Input<number>;
        /**
         * Specifies the size of the disk in base-2 GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Specifies the desired disk type on the node. This disk type must be a local storage type (e.g.: local-ssd). Note that for nodeTemplates, this should be the name of the disk type and not its URL.
         */
        diskType?: pulumi.Input<string>;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        /**
         * Number of virtual CPUs to use.
         */
        cpus?: pulumi.Input<string>;
        /**
         * (Output)
         * Use local SSD
         */
        localSsd?: pulumi.Input<string>;
        /**
         * Physical memory available to the node, defined in MB.
         */
        memory?: pulumi.Input<string>;
    }

    export interface NodeTemplateServerBinding {
        /**
         * Type of server binding policy. If `RESTART_NODE_ON_ANY_SERVER`,
         * nodes using this template will restart on any physical server
         * following a maintenance event.
         * If `RESTART_NODE_ON_MINIMAL_SERVER`, nodes using this template
         * will restart on the same physical server following a maintenance
         * event, instead of being live migrated to or restarted on a new
         * physical server. This option may be useful if you are using
         * software licenses tied to the underlying server characteristics
         * such as physical sockets or cores, to avoid the need for
         * additional licenses when maintenance occurs. However, VMs on such
         * nodes will experience outages while maintenance is applied.
         * Possible values are: `RESTART_NODE_ON_ANY_SERVER`, `RESTART_NODE_ON_MINIMAL_SERVERS`.
         */
        type: pulumi.Input<string>;
    }

    export interface OrganizationSecurityPolicyRuleMatch {
        /**
         * The configuration options for matching the rule.
         * Structure is documented below.
         */
        config: pulumi.Input<inputs.compute.OrganizationSecurityPolicyRuleMatchConfig>;
        /**
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * Preconfigured versioned expression. For organization security policy rules,
         * the only supported type is "FIREWALL".
         * Default value is `FIREWALL`.
         * Possible values are: `FIREWALL`.
         */
        versionedExpr?: pulumi.Input<string>;
    }

    export interface OrganizationSecurityPolicyRuleMatchConfig {
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         *
         *
         * <a name="nestedMatchConfigLayer4Config"></a>The `layer4Config` block supports:
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.OrganizationSecurityPolicyRuleMatchConfigLayer4Config>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationSecurityPolicyRuleMatchConfigLayer4Config {
        /**
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         *
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringCollectorIlb {
        /**
         * The URL of the forwarding rule.
         */
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringFilter {
        /**
         * IP CIDR ranges that apply as a filter on the source (ingress) or
         * destination (egress) IP in the IP header. Only IPv4 is supported.
         */
        cidrRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Direction of traffic to mirror.
         * Default value is `BOTH`.
         * Possible values are: `INGRESS`, `EGRESS`, `BOTH`.
         */
        direction?: pulumi.Input<string>;
        /**
         * Possible IP protocols including tcp, udp, icmp and esp
         */
        ipProtocols?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResources {
        /**
         * All the listed instances will be mirrored.  Specify at most 50.
         * Structure is documented below.
         */
        instances?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesInstance>[]>;
        /**
         * All instances in one of these subnetworks will be mirrored.
         * Structure is documented below.
         */
        subnetworks?: pulumi.Input<pulumi.Input<inputs.compute.PacketMirroringMirroredResourcesSubnetwork>[]>;
        /**
         * All instances with these tags will be mirrored.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PacketMirroringMirroredResourcesInstance {
        /**
         * The URL of the instances where this rule should be active.
         *
         * - - -
         */
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        /**
         * The URL of the subnetwork where this rule should be active.
         */
        url: pulumi.Input<string>;
    }

    export interface PacketMirroringNetwork {
        /**
         * The full selfLink URL of the network where this rule is active.
         */
        url: pulumi.Input<string>;
    }

    export interface PerInstanceConfigPreservedState {
        /**
         * Stateful disks for the instance.
         * Structure is documented below.
         */
        disks?: pulumi.Input<pulumi.Input<inputs.compute.PerInstanceConfigPreservedStateDisk>[]>;
        /**
         * Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
         * Structure is documented below.
         */
        externalIps?: pulumi.Input<pulumi.Input<inputs.compute.PerInstanceConfigPreservedStateExternalIp>[]>;
        /**
         * Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
         * Structure is documented below.
         */
        internalIps?: pulumi.Input<pulumi.Input<inputs.compute.PerInstanceConfigPreservedStateInternalIp>[]>;
        /**
         * Preserved metadata defined for this instance. This is a list of key->value pairs.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface PerInstanceConfigPreservedStateDisk {
        /**
         * A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
         * The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
         * `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
         * `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
         * deleted from the instance group.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
         */
        deviceName: pulumi.Input<string>;
        /**
         * The mode of the disk.
         * Default value is `READ_WRITE`.
         * Possible values are: `READ_ONLY`, `READ_WRITE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * The URI of an existing persistent disk to attach under the specified device-name in the format
         * `projects/project-id/zones/zone/disks/disk-name`.
         */
        source: pulumi.Input<string>;
    }

    export interface PerInstanceConfigPreservedStateExternalIp {
        /**
         * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        autoDelete?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        interfaceName: pulumi.Input<string>;
        /**
         * Ip address representation
         * Structure is documented below.
         */
        ipAddress?: pulumi.Input<inputs.compute.PerInstanceConfigPreservedStateExternalIpIpAddress>;
    }

    export interface PerInstanceConfigPreservedStateExternalIpIpAddress {
        /**
         * The URL of the reservation for this IP address.
         */
        address?: pulumi.Input<string>;
    }

    export interface PerInstanceConfigPreservedStateInternalIp {
        /**
         * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        autoDelete?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        interfaceName: pulumi.Input<string>;
        /**
         * Ip address representation
         * Structure is documented below.
         */
        ipAddress?: pulumi.Input<inputs.compute.PerInstanceConfigPreservedStateInternalIpIpAddress>;
    }

    export interface PerInstanceConfigPreservedStateInternalIpIpAddress {
        /**
         * The URL of the reservation for this IP address.
         */
        address?: pulumi.Input<string>;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        /**
         * The number of seconds that the autoscaler should wait before it
         * starts collecting information from a new instance. This prevents
         * the autoscaler from collecting information when the instance is
         * initializing, during which the collected usage would not be
         * reliable. The default time autoscaler waits is 60 seconds.
         * Virtual machine initialization times might vary because of
         * numerous factors. We recommend that you test how long an
         * instance may take to initialize. To do this, create an instance
         * and time the startup process.
         */
        cooldownPeriod?: pulumi.Input<number>;
        /**
         * Defines the CPU utilization policy that allows the autoscaler to
         * scale based on the average CPU utilization of a managed instance
         * group.
         * Structure is documented below.
         */
        cpuUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization>;
        /**
         * Configuration parameters of autoscaling based on a load balancer.
         * Structure is documented below.
         */
        loadBalancingUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        /**
         * The maximum number of instances that the autoscaler can scale up
         * to. This is required when creating or updating an autoscaler. The
         * maximum number of replicas should not be lower than minimal number
         * of replicas.
         */
        maxReplicas: pulumi.Input<number>;
        /**
         * Configuration parameters of autoscaling based on a custom metric.
         * Structure is documented below.
         */
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyMetric>[]>;
        /**
         * The minimum number of replicas that the autoscaler can scale down
         * to. This cannot be less than 0. If not provided, autoscaler will
         * choose a default value depending on maximum number of instances
         * allowed.
         */
        minReplicas: pulumi.Input<number>;
        /**
         * Defines operating mode for this policy.
         */
        mode?: pulumi.Input<string>;
        /**
         * Defines scale down controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events
         * Structure is documented below.
         */
        scaleDownControl?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyScaleDownControl>;
        /**
         * Defines scale in controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events
         * Structure is documented below.
         */
        scaleInControl?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyScaleInControl>;
        /**
         * Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler and they can overlap.
         * Structure is documented below.
         */
        scalingSchedules?: pulumi.Input<pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyScalingSchedule>[]>;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        /**
         * Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
         * - NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics.
         * - OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
         */
        predictiveMethod?: pulumi.Input<string>;
        /**
         * The target CPU utilization that the autoscaler should maintain.
         * Must be a float value in the range (0, 1]. If not specified, the
         * default is 0.6.
         * If the CPU level is below the target utilization, the autoscaler
         * scales down the number of instances until it reaches the minimum
         * number of instances you specified or until the average CPU of
         * your instances reaches the target utilization.
         * If the average CPU is above the target utilization, the autoscaler
         * scales up until it reaches the maximum number of instances you
         * specified or until the average utilization reaches the target
         * utilization.
         */
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        /**
         * Fraction of backend capacity utilization (set in HTTP(s) load
         * balancing configuration) that autoscaler should maintain. Must
         * be a positive float value. If not defined, the default is 0.8.
         */
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        /**
         * A filter string to be used as the filter string for
         * a Stackdriver Monitoring TimeSeries.list API call.
         * This filter is used to select a specific TimeSeries for
         * the purpose of autoscaling and to determine whether the metric
         * is exporting per-instance or per-group data.
         * You can only use the AND operator for joining selectors.
         * You can only use direct equality comparison operator (=) without
         * any functions for each selector.
         * You can specify the metric in both the filter string and in the
         * metric field. However, if specified in both places, the metric must
         * be identical.
         * The monitored resource type determines what kind of values are
         * expected for the metric. If it is a gce_instance, the autoscaler
         * expects the metric to include a separate TimeSeries for each
         * instance in a group. In such a case, you cannot filter on resource
         * labels.
         * If the resource type is any other value, the autoscaler expects
         * this metric to contain values that apply to the entire autoscaled
         * instance group and resource label filtering can be performed to
         * point autoscaler at the correct TimeSeries to scale upon.
         * This is called a per-group metric for the purpose of autoscaling.
         * If not specified, the type defaults to gce_instance.
         * You should provide a filter that is selective enough to pick just
         * one TimeSeries for the autoscaled group or for each of the instances
         * (if you are using gceInstance resource type). If multiple
         * TimeSeries are returned upon the query execution, the autoscaler
         * will sum their respective values to obtain its scaling value.
         */
        filter?: pulumi.Input<string>;
        /**
         * The identifier (type) of the Stackdriver Monitoring metric.
         * The metric cannot have negative values.
         * The metric must have a value type of INT64 or DOUBLE.
         */
        name: pulumi.Input<string>;
        /**
         * If scaling is based on a per-group metric value that represents the
         * total amount of work to be done or resource usage, set this value to
         * an amount assigned for a single instance of the scaled group.
         * The autoscaler will keep the number of instances proportional to the
         * value of this metric, the metric itself should not change value due
         * to group resizing.
         * For example, a good metric to use with the target is
         * `pubsub.googleapis.com/subscription/num_undelivered_messages`
         * or a custom metric exporting the total number of requests coming to
         * your instances.
         * A bad example would be a metric exporting an average or median
         * latency, since this value can't include a chunk assignable to a
         * single instance, it could be better used with utilizationTarget
         * instead.
         */
        singleInstanceAssignment?: pulumi.Input<number>;
        /**
         * The target value of the metric that autoscaler should
         * maintain. This must be a positive value. A utilization
         * metric scales number of virtual machines handling requests
         * to increase or decrease proportionally to the metric.
         * For example, a good metric to use as a utilizationTarget is
         * www.googleapis.com/compute/instance/network/received_bytes_count.
         * The autoscaler will work to keep this value constant for each
         * of the instances.
         */
        target?: pulumi.Input<number>;
        /**
         * Defines how target utilization value is expressed for a
         * Stackdriver Monitoring metric.
         * Possible values are: `GAUGE`, `DELTA_PER_SECOND`, `DELTA_PER_MINUTE`.
         */
        type?: pulumi.Input<string>;
    }

    export interface RegionAutoscalerAutoscalingPolicyScaleDownControl {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        maxScaledDownReplicas?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas>;
        /**
         * How long back autoscaling should look when computing recommendations
         * to include directives regarding slower scale down, as described above.
         */
        timeWindowSec?: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyScaleDownControlMaxScaledDownReplicas {
        /**
         * Specifies a fixed number of VM instances. This must be a positive
         * integer.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies a percentage of instances between 0 to 100%, inclusive.
         * For example, specify 80 for 80%.
         */
        percent?: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyScaleInControl {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        maxScaledInReplicas?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas>;
        /**
         * How long back autoscaling should look when computing recommendations
         * to include directives regarding slower scale down, as described above.
         */
        timeWindowSec?: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyScaleInControlMaxScaledInReplicas {
        /**
         * Specifies a fixed number of VM instances. This must be a positive
         * integer.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies a percentage of instances between 0 to 100%, inclusive.
         * For example, specify 80 for 80%.
         */
        percent?: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyScalingSchedule {
        /**
         * An optional description of this resource.
         */
        description?: pulumi.Input<string>;
        /**
         * A boolean value that specifies if a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * The duration of time intervals (in seconds) for which this scaling schedule will be running. The minimum allowed value is 300.
         */
        durationSec: pulumi.Input<number>;
        /**
         * Minimum number of VM instances that autoscaler will recommend in time intervals starting according to schedule.
         */
        minRequiredReplicas: pulumi.Input<number>;
        /**
         * The identifier for this object. Format specified above.
         */
        name: pulumi.Input<string>;
        /**
         * The start timestamps of time intervals when this scaling schedule should provide a scaling signal. This field uses the extended cron format (with an optional year field).
         */
        schedule: pulumi.Input<string>;
        /**
         * The time zone to be used when interpreting the schedule. The value of this field must be a time zone name from the tz database: http://en.wikipedia.org/wiki/Tz_database.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceBackend {
        /**
         * Specifies the balancing mode for this backend.
         * See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
         * for an explanation of load balancing modes.
         * Default value is `UTILIZATION`.
         * Possible values are: `UTILIZATION`, `RATE`, `CONNECTION`, `CUSTOM_METRICS`.
         */
        balancingMode?: pulumi.Input<string>;
        /**
         * A multiplier applied to the group's maximum servicing capacity
         * (based on UTILIZATION, RATE or CONNECTION).
         * ~>**NOTE**: This field cannot be set for
         * INTERNAL region backend services (default loadBalancingScheme),
         * but is required for non-INTERNAL backend service. The total
         * capacityScaler for all backends must be non-zero.
         * A setting of 0 means the group is completely drained, offering
         * 0% of its available Capacity. Valid range is [0.0,1.0].
         */
        capacityScaler?: pulumi.Input<number>;
        /**
         * The set of custom metrics that are used for <code>CUSTOM_METRICS</code> BalancingMode.
         * Structure is documented below.
         */
        customMetrics?: pulumi.Input<pulumi.Input<inputs.compute.RegionBackendServiceBackendCustomMetric>[]>;
        /**
         * An optional description of this resource.
         * Provide this property when you create the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * This field designates whether this is a failover backend. More
         * than one failover backend can be configured for a given RegionBackendService.
         */
        failover?: pulumi.Input<boolean>;
        /**
         * The fully-qualified URL of an Instance Group or Network Endpoint
         * Group resource. In case of instance group this defines the list
         * of instances that serve traffic. Member virtual machine
         * instances from each instance group must live in the same zone as
         * the instance group itself. No two backends in a backend service
         * are allowed to use same Instance Group resource.
         * For Network Endpoint Groups this defines list of endpoints. All
         * endpoints of Network Endpoint Group must be hosted on instances
         * located in the same zone as the Network Endpoint Group.
         * Backend services cannot mix Instance Group and
         * Network Endpoint Group backends.
         * When the `loadBalancingScheme` is INTERNAL, only instance groups
         * are supported.
         * Note that you must specify an Instance Group or Network Endpoint
         * Group resource using the fully-qualified URL, rather than a
         * partial URL.
         */
        group: pulumi.Input<string>;
        /**
         * The max number of simultaneous connections for the group. Can
         * be used with either CONNECTION or UTILIZATION balancing modes.
         * Cannot be set for INTERNAL backend services.
         * For CONNECTION mode, either maxConnections or one
         * of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
         * as appropriate for group type, must be set.
         */
        maxConnections?: pulumi.Input<number>;
        /**
         * The max number of simultaneous connections that a single backend
         * network endpoint can handle. Cannot be set
         * for INTERNAL backend services.
         * This is used to calculate the capacity of the group. Can be
         * used in either CONNECTION or UTILIZATION balancing modes. For
         * CONNECTION mode, either maxConnections or
         * maxConnectionsPerEndpoint must be set.
         */
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        /**
         * The max number of simultaneous connections that a single
         * backend instance can handle. Cannot be set for INTERNAL backend
         * services.
         * This is used to calculate the capacity of the group.
         * Can be used in either CONNECTION or UTILIZATION balancing modes.
         * For CONNECTION mode, either maxConnections or
         * maxConnectionsPerInstance must be set.
         */
        maxConnectionsPerInstance?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) of the group. Cannot be set
         * for INTERNAL backend services.
         * Can be used with either RATE or UTILIZATION balancing modes,
         * but required if RATE mode. Either maxRate or one
         * of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
         * group type, must be set.
         */
        maxRate?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) that a single backend network
         * endpoint can handle. This is used to calculate the capacity of
         * the group. Can be used in either balancing mode. For RATE mode,
         * either maxRate or maxRatePerEndpoint must be set. Cannot be set
         * for INTERNAL backend services.
         */
        maxRatePerEndpoint?: pulumi.Input<number>;
        /**
         * The max requests per second (RPS) that a single backend
         * instance can handle. This is used to calculate the capacity of
         * the group. Can be used in either balancing mode. For RATE mode,
         * either maxRate or maxRatePerInstance must be set. Cannot be set
         * for INTERNAL backend services.
         */
        maxRatePerInstance?: pulumi.Input<number>;
        /**
         * Used when balancingMode is UTILIZATION. This ratio defines the
         * CPU utilization target for the group. Valid range is [0.0, 1.0].
         * Cannot be set for INTERNAL backend services.
         */
        maxUtilization?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceBackendCustomMetric {
        /**
         * If true, the metric data is not used for load balancing.
         */
        dryRun: pulumi.Input<boolean>;
        /**
         * Optional parameter to define a target utilization for the Custom Metrics
         * balancing mode. The valid range is <code>[0.0, 1.0]</code>.
         */
        maxUtilization?: pulumi.Input<number>;
        /**
         * Name of a custom utilization signal. The name must be 1-64 characters
         * long and match the regular expression a-z? which
         * means the first character must be a lowercase letter, and all following
         * characters must be a dash, period, underscore, lowercase letter, or
         * digit, except the last character, which cannot be a dash, period, or
         * underscore. For usage guidelines, see Custom Metrics balancing mode. This
         * field can only be used for a global or regional backend service with the
         * loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
         * <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
         */
        name: pulumi.Input<string>;
    }

    export interface RegionBackendServiceCdnPolicy {
        /**
         * The CacheKeyPolicy for this CdnPolicy.
         * Structure is documented below.
         */
        cacheKeyPolicy?: pulumi.Input<inputs.compute.RegionBackendServiceCdnPolicyCacheKeyPolicy>;
        /**
         * Specifies the cache setting for all responses from this backend.
         * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
         * Possible values are: `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `CACHE_ALL_STATIC`.
         */
        cacheMode?: pulumi.Input<string>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin.
         */
        clientTtl?: pulumi.Input<number>;
        /**
         * Specifies the default TTL for cached content served by this origin for responses
         * that do not have an existing valid TTL (max-age or s-max-age).
         */
        defaultTtl?: pulumi.Input<number>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin.
         */
        maxTtl?: pulumi.Input<number>;
        /**
         * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
         */
        negativeCaching?: pulumi.Input<boolean>;
        /**
         * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
         * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
         * Structure is documented below.
         */
        negativeCachingPolicies?: pulumi.Input<pulumi.Input<inputs.compute.RegionBackendServiceCdnPolicyNegativeCachingPolicy>[]>;
        /**
         * Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
         */
        serveWhileStale?: pulumi.Input<number>;
        /**
         * Maximum number of seconds the response to a signed URL request
         * will be considered fresh, defaults to 1hr (3600s). After this
         * time period, the response will be revalidated before
         * being served.
         * When serving responses to signed URL requests, Cloud CDN will
         * internally behave as though all responses from this backend had a
         * "Cache-Control: public, max-age=[TTL]" header, regardless of any
         * existing Cache-Control header. The actual headers served in
         * responses will not be altered.
         */
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCdnPolicyCacheKeyPolicy {
        /**
         * If true requests to different hosts will be cached separately.
         */
        includeHost?: pulumi.Input<boolean>;
        /**
         * Names of cookies to include in cache keys.
         */
        includeNamedCookies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, http and https requests will be cached separately.
         */
        includeProtocol?: pulumi.Input<boolean>;
        /**
         * If true, include query string parameters in the cache key
         * according to queryStringWhitelist and
         * query_string_blacklist. If neither is set, the entire query
         * string will be included.
         * If false, the query string will be excluded from the cache
         * key entirely.
         */
        includeQueryString?: pulumi.Input<boolean>;
        /**
         * Names of query string parameters to exclude in cache keys.
         * All other parameters will be included. Either specify
         * queryStringWhitelist or query_string_blacklist, not both.
         * '&' and '=' will be percent encoded and not treated as
         * delimiters.
         */
        queryStringBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of query string parameters to include in cache keys.
         * All other parameters will be excluded. Either specify
         * queryStringWhitelist or query_string_blacklist, not both.
         * '&' and '=' will be percent encoded and not treated as
         * delimiters.
         */
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionBackendServiceCdnPolicyNegativeCachingPolicy {
        /**
         * The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
         * can be specified as values, and you cannot specify a status code more than once.
         */
        code?: pulumi.Input<number>;
        /**
         * The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
         * (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
         */
        ttl?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakers {
        /**
         * The timeout for new network connections to hosts.
         * Structure is documented below.
         */
        connectTimeout?: pulumi.Input<inputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout>;
        /**
         * The maximum number of connections to the backend cluster.
         * Defaults to 1024.
         */
        maxConnections?: pulumi.Input<number>;
        /**
         * The maximum number of pending requests to the backend cluster.
         * Defaults to 1024.
         */
        maxPendingRequests?: pulumi.Input<number>;
        /**
         * The maximum number of parallel requests to the backend cluster.
         * Defaults to 1024.
         */
        maxRequests?: pulumi.Input<number>;
        /**
         * Maximum requests for a single backend connection. This parameter
         * is respected by both the HTTP/1.1 and HTTP/2 implementations. If
         * not specified, there is no limit. Setting this parameter to 1
         * will effectively disable keep alive.
         */
        maxRequestsPerConnection?: pulumi.Input<number>;
        /**
         * The maximum number of parallel retries to the backend cluster.
         * Defaults to 3.
         */
        maxRetries?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConnectionTrackingPolicy {
        /**
         * Specifies connection persistence when backends are unhealthy.
         * If set to `DEFAULT_FOR_PROTOCOL`, the existing connections persist on
         * unhealthy backends only for connection-oriented protocols (TCP and SCTP)
         * and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
         * or the Session Affinity is configured for 5-tuple. They do not persist
         * for UDP.
         * If set to `NEVER_PERSIST`, after a backend becomes unhealthy, the existing
         * connections on the unhealthy backend are never persisted on the unhealthy
         * backend. They are always diverted to newly selected healthy backends
         * (unless all backends are unhealthy).
         * If set to `ALWAYS_PERSIST`, existing connections always persist on
         * unhealthy backends regardless of protocol and session affinity. It is
         * generally not recommended to use this mode overriding the default.
         * Default value is `DEFAULT_FOR_PROTOCOL`.
         * Possible values are: `DEFAULT_FOR_PROTOCOL`, `NEVER_PERSIST`, `ALWAYS_PERSIST`.
         */
        connectionPersistenceOnUnhealthyBackends?: pulumi.Input<string>;
        /**
         * Enable Strong Session Affinity for Network Load Balancing. This option is not available publicly.
         */
        enableStrongAffinity?: pulumi.Input<boolean>;
        /**
         * Specifies how long to keep a Connection Tracking entry while there is
         * no matching traffic (in seconds).
         * For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
         * For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
         */
        idleTimeoutSec?: pulumi.Input<number>;
        /**
         * Specifies the key used for connection tracking. There are two options:
         * `PER_CONNECTION`: The Connection Tracking is performed as per the
         * Connection Key (default Hash Method) for the specific protocol.
         * `PER_SESSION`: The Connection Tracking is performed as per the
         * configured Session Affinity. It matches the configured Session Affinity.
         * Default value is `PER_CONNECTION`.
         * Possible values are: `PER_CONNECTION`, `PER_SESSION`.
         */
        trackingMode?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceConsistentHash {
        /**
         * Hash is based on HTTP Cookie. This field describes a HTTP cookie
         * that will be used as the hash key for the consistent hash load
         * balancer. If the cookie is not present, it will be generated.
         * This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
         * Structure is documented below.
         */
        httpCookie?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookie>;
        /**
         * The hash based on the value of the specified header field.
         * This field is applicable if the sessionAffinity is set to HEADER_FIELD.
         */
        httpHeaderName?: pulumi.Input<string>;
        /**
         * The minimum number of virtual nodes to use for the hash ring.
         * Larger ring sizes result in more granular load
         * distributions. If the number of hosts in the load balancing pool
         * is larger than the ring size, each host will be assigned a single
         * virtual node.
         * Defaults to 1024.
         */
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        /**
         * Name of the cookie.
         */
        name?: pulumi.Input<string>;
        /**
         * Path to set for the cookie.
         */
        path?: pulumi.Input<string>;
        /**
         * Lifetime of the cookie.
         * Structure is documented below.
         */
        ttl?: pulumi.Input<inputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceCustomMetric {
        /**
         * If true, the metric data is not used for load balancing.
         */
        dryRun: pulumi.Input<boolean>;
        /**
         * Name of a custom utilization signal. The name must be 1-64 characters
         * long and match the regular expression a-z? which
         * means the first character must be a lowercase letter, and all following
         * characters must be a dash, period, underscore, lowercase letter, or
         * digit, except the last character, which cannot be a dash, period, or
         * underscore. For usage guidelines, see Custom Metrics balancing mode. This
         * field can only be used for a global or regional backend service with the
         * loadBalancingScheme set to <code>EXTERNAL_MANAGED</code>,
         * <code>INTERNAL_MANAGED</code> <code>INTERNAL_SELF_MANAGED</code>.
         */
        name: pulumi.Input<string>;
    }

    export interface RegionBackendServiceFailoverPolicy {
        /**
         * On failover or failback, this field indicates whether connection drain
         * will be honored. Setting this to true has the following effect: connections
         * to the old active pool are not drained. Connections to the new active pool
         * use the timeout of 10 min (currently fixed). Setting to false has the
         * following effect: both old and new connections will have a drain timeout
         * of 10 min.
         * This can be set to true only if the protocol is TCP.
         * The default is false.
         */
        disableConnectionDrainOnFailover?: pulumi.Input<boolean>;
        /**
         * This option is used only when no healthy VMs are detected in the primary
         * and backup instance groups. When set to true, traffic is dropped. When
         * set to false, new connections are sent across all VMs in the primary group.
         * The default is false.
         */
        dropTrafficIfUnhealthy?: pulumi.Input<boolean>;
        /**
         * The value of the field must be in [0, 1]. If the ratio of the healthy
         * VMs in the primary backend is at or below this number, traffic arriving
         * at the load-balanced IP will be directed to the failover backend.
         * In case where 'failoverRatio' is not set or all the VMs in the backup
         * backend are unhealthy, the traffic will be directed back to the primary
         * backend in the "force" mode, where traffic will be spread to the healthy
         * VMs with the best effort, or to all VMs when no VM is healthy.
         * This field is only used with l4 load balancing.
         */
        failoverRatio?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface RegionBackendServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface RegionBackendServiceIap {
        /**
         * Whether the serving infrastructure will authenticate and authorize all incoming requests.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * OAuth2 Client ID for IAP
         */
        oauth2ClientId?: pulumi.Input<string>;
        /**
         * OAuth2 Client Secret for IAP
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        oauth2ClientSecret?: pulumi.Input<string>;
        /**
         * (Output)
         * OAuth2 Client Secret SHA-256 for IAP
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceLogConfig {
        /**
         * Whether to enable logging for the load balancer traffic served by this backend service.
         */
        enable?: pulumi.Input<boolean>;
        /**
         * Specifies the fields to include in logging. This field can only be specified if logging is enabled for this backend service.
         */
        optionalFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the optional logging mode for the load balancer traffic.
         * Supported values: INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM.
         * Possible values are: `INCLUDE_ALL_OPTIONAL`, `EXCLUDE_ALL_OPTIONAL`, `CUSTOM`.
         */
        optionalMode?: pulumi.Input<string>;
        /**
         * This field can only be specified if logging is enabled for this backend service. The value of
         * the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
         * where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
         * The default value is 1.0.
         */
        sampleRate?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetection {
        /**
         * The base time that a host is ejected for. The real time is equal to the base
         * time multiplied by the number of times the host has been ejected. Defaults to
         * 30000ms or 30s.
         * Structure is documented below.
         */
        baseEjectionTime?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime>;
        /**
         * Number of errors before a host is ejected from the connection pool. When the
         * backend host is accessed over HTTP, a 5xx return code qualifies as an error.
         * Defaults to 5.
         */
        consecutiveErrors?: pulumi.Input<number>;
        /**
         * The number of consecutive gateway failures (502, 503, 504 status or connection
         * errors that are mapped to one of those status codes) before a consecutive
         * gateway failure ejection occurs. Defaults to 5.
         */
        consecutiveGatewayFailure?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through consecutive 5xx. This setting can be used to disable
         * ejection or to ramp it up slowly. Defaults to 100.
         */
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through consecutive gateway failures. This setting can be
         * used to disable ejection or to ramp it up slowly. Defaults to 0.
         */
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        /**
         * The percentage chance that a host will be actually ejected when an outlier
         * status is detected through success rate statistics. This setting can be used to
         * disable ejection or to ramp it up slowly. Defaults to 100.
         */
        enforcingSuccessRate?: pulumi.Input<number>;
        /**
         * Time interval between ejection sweep analysis. This can result in both new
         * ejections as well as hosts being returned to service. Defaults to 10 seconds.
         * Structure is documented below.
         */
        interval?: pulumi.Input<inputs.compute.RegionBackendServiceOutlierDetectionInterval>;
        /**
         * Maximum percentage of hosts in the load balancing pool for the backend service
         * that can be ejected. Defaults to 10%.
         */
        maxEjectionPercent?: pulumi.Input<number>;
        /**
         * The number of hosts in a cluster that must have enough request volume to detect
         * success rate outliers. If the number of hosts is less than this setting, outlier
         * detection via success rate statistics is not performed for any host in the
         * cluster. Defaults to 5.
         */
        successRateMinimumHosts?: pulumi.Input<number>;
        /**
         * The minimum number of total requests that must be collected in one interval (as
         * defined by the interval duration above) to include this host in success rate
         * based outlier detection. If the volume is lower than this setting, outlier
         * detection via success rate statistics is not performed for that host. Defaults
         * to 100.
         */
        successRateRequestVolume?: pulumi.Input<number>;
        /**
         * This factor is used to determine the ejection threshold for success rate outlier
         * ejection. The ejection threshold is the difference between the mean success
         * rate, and the product of this factor and the standard deviation of the mean
         * success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
         * by a thousand to get a double. That is, if the desired factor is 1.9, the
         * runtime value should be 1900. Defaults to 1900.
         */
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations
         * less than one second are represented with a 0 `seconds` field and a positive
         * `nanos` field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
         * inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations
         * less than one second are represented with a 0 `seconds` field and a positive
         * `nanos` field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
         * inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceStrongSessionAffinityCookie {
        /**
         * Name of the cookie.
         */
        name?: pulumi.Input<string>;
        /**
         * Path to set for the cookie.
         */
        path?: pulumi.Input<string>;
        /**
         * Lifetime of the cookie.
         * Structure is documented below.
         */
        ttl?: pulumi.Input<inputs.compute.RegionBackendServiceStrongSessionAffinityCookieTtl>;
    }

    export interface RegionBackendServiceStrongSessionAffinityCookieTtl {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionBackendServiceSubsetting {
        /**
         * The algorithm used for subsetting.
         * Possible values are: `CONSISTENT_HASH_SUBSETTING`.
         */
        policy: pulumi.Input<string>;
    }

    export interface RegionCommitmentLicenseResource {
        /**
         * The number of licenses purchased.
         */
        amount?: pulumi.Input<string>;
        /**
         * Specifies the core range of the instance for which this license applies.
         */
        coresPerLicense?: pulumi.Input<string>;
        /**
         * Any applicable license URI.
         */
        license: pulumi.Input<string>;
    }

    export interface RegionCommitmentResource {
        /**
         * Name of the accelerator type resource. Applicable only when the type is ACCELERATOR.
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * The amount of the resource purchased (in a type-dependent unit,
         * such as bytes). For vCPUs, this can just be an integer. For memory,
         * this must be provided in MB. Memory must be a multiple of 256 MB,
         * with up to 6.5GB of memory per every vCPU.
         */
        amount?: pulumi.Input<string>;
        /**
         * Type of resource for which this commitment applies.
         * Possible values are VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
         */
        type?: pulumi.Input<string>;
    }

    export interface RegionDiskAsyncPrimaryDisk {
        /**
         * Primary disk for asynchronous disk replication.
         */
        disk: pulumi.Input<string>;
    }

    export interface RegionDiskDiskEncryptionKey {
        /**
         * The name of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
         * customer-supplied encryption key to either encrypt or decrypt
         * this resource. You can provide either the rawKey or the rsaEncryptedKey.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface RegionDiskGuestOsFeature {
        /**
         * The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         * Possible values are: `MULTI_IP_SUBNET`, `SECURE_BOOT`, `SEV_CAPABLE`, `UEFI_COMPATIBLE`, `VIRTIO_SCSI_MULTIQUEUE`, `WINDOWS`, `GVNIC`, `SEV_LIVE_MIGRATABLE`, `SEV_SNP_CAPABLE`, `SUSPEND_RESUME_COMPATIBLE`, `TDX_CAPABLE`.
         */
        type: pulumi.Input<string>;
    }

    export interface RegionDiskIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RegionDiskIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        /**
         * The name of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckGrpcHealthCheck {
        /**
         * The gRPC service name for the health check.
         * The value of grpcServiceName has the following meanings by convention:
         * * Empty serviceName means the overall status of all services at the backend.
         * * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
         * The grpcServiceName can only be ASCII.
         */
        grpcServiceName?: pulumi.Input<string>;
        /**
         * The port number for the health check request.
         * Must be specified if portName and portSpecification are not set
         * or if portSpecification is USE_FIXED_PORT. Valid values are 1 through 65535.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, gRPC health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckGrpcTlsHealthCheck {
        /**
         * The gRPC service name for the health check.
         * The value of grpcServiceName has the following meanings by convention:
         * * Empty serviceName means the overall status of all services at the backend.
         * * Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
         * The grpcServiceName can only be ASCII.
         */
        grpcServiceName?: pulumi.Input<string>;
        /**
         * The port number for the health check request.
         * Must be specified if portSpecification is USE_FIXED_PORT. Valid values are 1 through 65535.
         */
        port?: pulumi.Input<number>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: Not supported for GRPC with TLS health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, gRPC health check follows behavior specified in the `port` field.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        /**
         * The value of the host header in the HTTP2 health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTP2 health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         *
         *   * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
         *
         *   * 'USE_NAMED_PORT': The 'portName' is used for health checking.
         *
         *   * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
         *   network endpoint is used for health checking. For other backends, the
         *   port or named port specified in the Backend Service is used for health
         *   checking.
         *
         * If not specified, HTTP2 health check follows behavior specified in 'port' and
         * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"]
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"]
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTP2 health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        /**
         * The value of the host header in the HTTP health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTP health check request.
         * The default value is 80.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTP health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTP health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        /**
         * The value of the host header in the HTTPS health check request.
         * If left empty (default value), the public IP on behalf of which this health
         * check is performed will be used.
         */
        host?: pulumi.Input<string>;
        /**
         * The TCP port number for the HTTPS health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTPS health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The request path of the HTTPS health check request.
         * The default value is /.
         */
        requestPath?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckLogConfig {
        /**
         * Indicates whether or not to export logs. This is false by default,
         * which means no health check logging will be done.
         */
        enable?: pulumi.Input<boolean>;
    }

    export interface RegionHealthCheckSslHealthCheck {
        /**
         * The TCP port number for the HTTP2 health check request.
         * The default value is 443.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, HTTP2 health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The application data to send once the SSL connection has been
         * established (default value is empty). If both request and response are
         * empty, the connection establishment alone will indicate health. The request
         * data can only be ASCII.
         */
        request?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        /**
         * The TCP port number for the TCP health check request.
         * The default value is 80.
         */
        port?: pulumi.Input<number>;
        /**
         * Port name as defined in InstanceGroup#NamedPort#name. If both port and
         * portName are defined, port takes precedence.
         */
        portName?: pulumi.Input<string>;
        /**
         * Specifies how port is selected for health checking, can be one of the
         * following values:
         * * `USE_FIXED_PORT`: The port number in `port` is used for health checking.
         * * `USE_NAMED_PORT`: The `portName` is used for health checking.
         * * `USE_SERVING_PORT`: For NetworkEndpointGroup, the port specified for each
         * network endpoint is used for health checking. For other backends, the
         * port or named port specified in the Backend Service is used for health
         * checking.
         * If not specified, TCP health check follows behavior specified in `port` and
         * `portName` fields.
         * Possible values are: `USE_FIXED_PORT`, `USE_NAMED_PORT`, `USE_SERVING_PORT`.
         */
        portSpecification?: pulumi.Input<string>;
        /**
         * Specifies the type of proxy header to append before sending data to the
         * backend.
         * Default value is `NONE`.
         * Possible values are: `NONE`, `PROXY_V1`.
         */
        proxyHeader?: pulumi.Input<string>;
        /**
         * The application data to send once the TCP connection has been
         * established (default value is empty). If both request and response are
         * empty, the connection establishment alone will indicate health. The request
         * data can only be ASCII.
         */
        request?: pulumi.Input<string>;
        /**
         * The bytes to match against the beginning of the response data. If left empty
         * (the default value), any response will indicate health. The response data
         * can only be ASCII.
         */
        response?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerAllInstancesConfig {
        /**
         * The label key-value pairs that you want to patch onto the instance,
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata,
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: pulumi.Input<string>;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerInstanceFlexibilityPolicy {
        /**
         * Named instance selections configuring properties that the group will use when creating new VMs.
         */
        instanceSelections?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection>[]>;
    }

    export interface RegionInstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection {
        /**
         * Full machine-type names, e.g. "n1-standard-16"
         */
        machineTypes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        /**
         * Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
         */
        rank?: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerInstanceLifecyclePolicy {
        /**
         * , Specifies the action that a MIG performs on a failed VM. If the value of the `onFailedHealthCheck` field is `DEFAULT_ACTION`, then the same action also applies to the VMs on which your application fails a health check. Valid options are: `DO_NOTHING`, `REPAIR`. If `DO_NOTHING`, then MIG does not repair a failed VM. If `REPAIR` (default), then MIG automatically repairs a failed VM by recreating it. For more information, see about repairing VMs in a MIG.
         */
        defaultActionOnFailure?: pulumi.Input<string>;
        /**
         * , Specifies whether to apply the group's latest configuration when repairing a VM. Valid options are: `YES`, `NO`. If `YES` and you updated the group's instance template or per-instance configurations after the VM was created, then these changes are applied when VM is repaired. If `NO` (default), then updates are applied in accordance with the group's update policy type.
         */
        forceUpdateOnRepair?: pulumi.Input<string>;
        /**
         * , Specifies the action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid options are: `DEFAULT_ACTION`, `DO_NOTHING`, `REPAIR`. If `DEFAULT_ACTION` (default), then MIG uses the same action configured for the  `defaultActionOnFailure` field. If `DO_NOTHING`, then MIG does not repair unhealthy VM. If `REPAIR`, then MIG automatically repairs an unhealthy VM by recreating it. For more information, see about repairing VMs in a MIG. 
         *
         * - - -
         * <a name="nestedInstanceFlexibilityPolicy"></a>The `instanceFlexibilityPolicy` block supports:
         */
        onFailedHealthCheck?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the port.
         */
        name: pulumi.Input<string>;
        /**
         * The port number.
         * - - -
         */
        port: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerParams {
        /**
         * Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RegionInstanceGroupManagerStandbyPolicy {
        /**
         * Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
         */
        initialDelaySec?: pulumi.Input<number>;
        /**
         * Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. Valid options are: `MANUAL`, `SCALE_OUT_POOL`. If `MANUAL`(default), you have full control over which VMs are stopped and suspended in the MIG. If `SCALE_OUT_POOL`, the MIG uses the VMs from the standby pools to accelerate the scale out by resuming or starting them and then automatically replenishes the standby pool with new VMs to maintain the target sizes.
         * - - -
         */
        mode?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerStatefulDisk {
        /**
         * , A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The device name of the disk to be attached.
         */
        deviceName: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerStatefulExternalIp {
        /**
         * , A value that prescribes what should happen to the external ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the external ip when the VM is permanently deleted from the instance group.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The network interface name of the external Ip. Possible value: `nic0`.
         */
        interfaceName?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerStatefulInternalIp {
        /**
         * , A value that prescribes what should happen to the internal ip when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the ip when the VM is deleted, but do not delete the ip. `ON_PERMANENT_INSTANCE_DELETION` will delete the internal ip when the VM is permanently deleted from the instance group.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * , The network interface name of the internal Ip. Possible value: `nic0`.
         */
        interfaceName?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerStatus {
        /**
         * Properties to set on all instances in the group. After setting
         * allInstancesConfig on the group, you must update the group's instances to
         * apply the configuration.
         */
        allInstancesConfigs?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceGroupManagerStatusAllInstancesConfig>[]>;
        /**
         * A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
         */
        isStable?: pulumi.Input<boolean>;
        /**
         * Stateful status of the given Instance Group Manager.
         */
        statefuls?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceGroupManagerStatusStateful>[]>;
        /**
         * A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
         */
        versionTargets?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceGroupManagerStatusVersionTarget>[]>;
    }

    export interface RegionInstanceGroupManagerStatusAllInstancesConfig {
        /**
         * Current all-instances configuration revision. This value is in RFC3339 text format.
         */
        currentRevision?: pulumi.Input<string>;
        /**
         * A bit indicating whether this configuration has been applied to all managed instances in the group.
         */
        effective?: pulumi.Input<boolean>;
    }

    export interface RegionInstanceGroupManagerStatusStateful {
        /**
         * A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
         */
        hasStatefulConfig?: pulumi.Input<boolean>;
        /**
         * Status of per-instance configs on the instances.
         */
        perInstanceConfigs?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceGroupManagerStatusStatefulPerInstanceConfig>[]>;
    }

    export interface RegionInstanceGroupManagerStatusStatefulPerInstanceConfig {
        /**
         * A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.
         */
        allEffective?: pulumi.Input<boolean>;
    }

    export interface RegionInstanceGroupManagerStatusVersionTarget {
        /**
         * A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
         */
        isReached?: pulumi.Input<boolean>;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        /**
         * The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
         */
        instanceRedistributionType?: pulumi.Input<string>;
        /**
         * , Specifies a fixed number of VM instances. This must be a positive integer. Conflicts with `maxSurgePercent`. Both cannot be 0.
         */
        maxSurgeFixed?: pulumi.Input<number>;
        /**
         * , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%. Conflicts with `maxSurgeFixed`.
         */
        maxSurgePercent?: pulumi.Input<number>;
        /**
         * , Specifies a fixed number of VM instances. This must be a positive integer.
         */
        maxUnavailableFixed?: pulumi.Input<number>;
        /**
         * , Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%..
         */
        maxUnavailablePercent?: pulumi.Input<number>;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         */
        minReadySec?: pulumi.Input<number>;
        /**
         * Minimal action to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: pulumi.Input<string>;
        /**
         * Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
         */
        mostDisruptiveAllowedAction?: pulumi.Input<string>;
        /**
         * , The instance replacement method for managed instance groups. Valid values are: "RECREATE", "SUBSTITUTE". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set maxUnavailableFixed or maxUnavailablePercent to be greater than 0.
         * - - -
         */
        replacementMethod?: pulumi.Input<string>;
        /**
         * The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerVersion {
        /**
         * The full URL to an instance template from which all new instances of this version will be created.
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * Version name.
         */
        name?: pulumi.Input<string>;
        /**
         * The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         *
         * > Exactly one `version` you specify must not have a `targetSize` specified. During a rolling update, the instance group manager will fulfill the `targetSize`
         * constraints of every other `version`, and any remaining instances will be provisioned with the version where `targetSize` is unset.
         */
        targetSize?: pulumi.Input<inputs.compute.RegionInstanceGroupManagerVersionTargetSize>;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: pulumi.Input<number>;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: pulumi.Input<number>;
    }

    export interface RegionInstanceTemplateAdvancedMachineFeatures {
        /**
         * Defines whether the instance should have nested virtualization enabled. Defaults to false.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * Whether to enable UEFI networking for instance creation.
         */
        enableUefiNetworking?: pulumi.Input<boolean>;
        /**
         * [The PMU](https://cloud.google.com/compute/docs/pmu-overview) is a hardware component within the CPU core that monitors how the processor runs code. Valid values for the level of PMU are `STANDARD`, `ENHANCED`, and `ARCHITECTURAL`.
         */
        performanceMonitoringUnit?: pulumi.Input<string>;
        /**
         * The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.
         */
        threadsPerCore?: pulumi.Input<number>;
        /**
         * Turbo frequency mode to use for the instance. Supported modes are currently either `ALL_CORE_MAX` or unset (default).
         */
        turboMode?: pulumi.Input<string>;
        /**
         * The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).
         */
        visibleCoreCount?: pulumi.Input<number>;
    }

    export interface RegionInstanceTemplateConfidentialInstanceConfig {
        /**
         * Defines the confidential computing technology the instance uses. SEV is an AMD feature. TDX is an Intel feature. One of the following values is required: `SEV`, `SEV_SNP`, `TDX`. `onHostMaintenance` can be set to MIGRATE if `confidentialInstanceType` is set to `SEV` and `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM. If `SEV_SNP`, currently `minCpuPlatform` has to be set to `"AMD Milan"` or this will fail to create the VM.
         */
        confidentialInstanceType?: pulumi.Input<string>;
        /**
         * Defines whether the instance should have confidential compute enabled with AMD SEV. If enabled, `onHostMaintenance` can be set to MIGRATE if `minCpuPlatform` is set to `"AMD Milan"`. Otherwise, `onHostMaintenance` has to be set to TERMINATE or this will fail to create the VM.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface RegionInstanceTemplateDisk {
        /**
         * The architecture of the attached disk. Valid values are `ARM64` or `x8664`.
         */
        architecture?: pulumi.Input<string>;
        /**
         * Whether or not the disk should be auto-deleted.
         * This defaults to true.
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * Indicates that this is a boot disk.
         */
        boot?: pulumi.Input<boolean>;
        /**
         * A unique device name that is reflected into the
         * /dev/  tree of a Linux operating system running within the instance. If not
         * specified, the server chooses a default device name to apply to this disk.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * Encrypts or decrypts a disk using a customer-supplied encryption key.
         *
         * If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key.
         *
         * If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance.
         *
         * If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.
         *
         * Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. Structure documented below.
         */
        diskEncryptionKey?: pulumi.Input<inputs.compute.RegionInstanceTemplateDiskDiskEncryptionKey>;
        /**
         * Name of the disk. When not provided, this defaults
         * to the name of the instance.
         */
        diskName?: pulumi.Input<string>;
        /**
         * The size of the image in gigabytes. If not
         * specified, it will inherit the size of its base image. For SCRATCH disks,
         * the size must be exactly 375GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * The GCE disk type. Such as `"pd-ssd"`, `"local-ssd"`,
         * `"pd-balanced"` or `"pd-standard"`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * A list of features to enable on the guest operating system. Applicable only for bootable images. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options.
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the disk interface to use for attaching this disk,
         * which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI
         * and the request will fail if you attempt to attach a persistent disk in any other format
         * than SCSI. Local SSDs can use either NVME or SCSI.
         */
        interface?: pulumi.Input<string>;
        /**
         * A set of ket/value label pairs to assign to disk created from
         * this template
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The mode in which to attach this disk, either READ_WRITE
         * or READ_ONLY. If you are attaching or creating a boot disk, this must
         * read-write mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * Indicates how many IOPS to provision for the disk. This
         * sets the number of I/O operations per second that the disk can handle.
         * Values must be between 10,000 and 120,000. For more details, see the
         * [Extreme persistent disk documentation](https://cloud.google.com/compute/docs/disks/extreme-persistent-disk).
         */
        provisionedIops?: pulumi.Input<number>;
        /**
         * Indicates how much throughput to provision for the disk, in MB/s. This sets the amount of data that can be read or written from the disk per second. Values must greater than or equal to 1. For more details, see the [Hyperdisk documentation](https://cloud.google.com/compute/docs/disks/hyperdisks).
         */
        provisionedThroughput?: pulumi.Input<number>;
        /**
         * A set of key/value resource manager tag pairs to bind to this disk. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * - A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.
         */
        resourcePolicies?: pulumi.Input<string>;
        /**
         * The name (**not self_link**)
         * of the disk (such as those managed by `gcp.compute.Disk`) to attach.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        source?: pulumi.Input<string>;
        /**
         * The image from which to
         * initialize this disk. This can be one of: the image's `selfLink`,
         * `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        sourceImage?: pulumi.Input<string>;
        /**
         * The customer-supplied encryption
         * key of the source image. Required if the source image is protected by a
         * customer-supplied encryption key.
         *
         * Instance templates do not store customer-supplied encryption keys, so you
         * cannot create disks for instances in a managed instance group if the source
         * images are encrypted with your own keys. Structure
         * documented below.
         */
        sourceImageEncryptionKey?: pulumi.Input<inputs.compute.RegionInstanceTemplateDiskSourceImageEncryptionKey>;
        /**
         * The source snapshot to create this disk.
         * > **Note:** Either `source`, `sourceImage`, or `sourceSnapshot` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.
         */
        sourceSnapshot?: pulumi.Input<string>;
        /**
         * The customer-supplied encryption
         * key of the source snapshot. Structure
         * documented below.
         */
        sourceSnapshotEncryptionKey?: pulumi.Input<inputs.compute.RegionInstanceTemplateDiskSourceSnapshotEncryptionKey>;
        /**
         * The type of GCE disk, can be either `"SCRATCH"` or
         * `"PERSISTENT"`.
         */
        type?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateDiskDiskEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateDiskSourceImageEncryptionKey {
        /**
         * The self link of the encryption key that is
         * stored in Google Cloud KMS. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to decrypt the given image. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt the given image. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateDiskSourceSnapshotEncryptionKey {
        /**
         * The self link of the encryption key that is
         * stored in Google Cloud KMS. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account being used for the
         * encryption request for the given KMS key. If absent, the Compute Engine
         * default service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to decrypt this snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption) to decrypt this snapshot. Only one of `kmsKeySelfLink`, `rsaEncryptedKey` and `rawKey`
         * may be set.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceTemplateNetworkInterfaceAccessConfig>[]>;
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * The prefix length of the primary internal IPv6 range.
         */
        internalIpv6PrefixLength?: pulumi.Input<number>;
        /**
         * An array of IPv6 access configurations for this interface.
         * Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig
         * specified, then this instance will have no external IPv6 Internet access. Structure documented below.
         */
        ipv6AccessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig>[]>;
        /**
         * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
         */
        ipv6AccessType?: pulumi.Input<string>;
        /**
         * An IPv6 internal network address for this network interface. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
         */
        ipv6Address?: pulumi.Input<string>;
        /**
         * The name of the network_interface.
         */
        name?: pulumi.Input<string>;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Use `network` attribute for Legacy or Auto subnetted networks and
         * `subnetwork` for custom subnetted networks.
         */
        network?: pulumi.Input<string>;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET, MRDMA, IRDMA.
         */
        nicType?: pulumi.Input<string>;
        /**
         * The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6, IPV6_ONLY or IPV4_ONLY. If not specified, IPV4_ONLY will be used.
         */
        stackType?: pulumi.Input<string>;
        /**
         * the name of the subnetwork to attach this interface
         * to. The subnetwork must exist in the same `region` this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The ID of the project in which the subnetwork belongs.
         * If it is not provided, the provider project is used.
         */
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the
         * subnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.
         */
        networkTier?: pulumi.Input<string>;
        /**
         * The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
         */
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. At the time of writing only a
         * netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
         * error.
         */
        ipCidrRange: pulumi.Input<string>;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateNetworkInterfaceIpv6AccessConfig {
        /**
         * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
         */
        externalIpv6?: pulumi.Input<string>;
        /**
         * The prefix length of the external IPv6 range.
         */
        externalIpv6PrefixLength?: pulumi.Input<string>;
        /**
         * The name of this access configuration.
         */
        name?: pulumi.Input<string>;
        /**
         * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6
         */
        networkTier: pulumi.Input<string>;
        /**
         * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
         */
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateNetworkPerformanceConfig {
        /**
         * The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateReservationAffinity {
        /**
         * Specifies the label selector for the reservation to use..
         * Structure is documented below.
         */
        specificReservation?: pulumi.Input<inputs.compute.RegionInstanceTemplateReservationAffinitySpecificReservation>;
        /**
         * The type of reservation from which this instance can consume resources.
         */
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateReservationAffinitySpecificReservation {
        /**
         * Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
         */
        key: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionInstanceTemplateScheduling {
        /**
         * Specifies whether the instance should be
         * automatically restarted if it is terminated by Compute Engine (not
         * terminated by a user). This defaults to true.
         */
        automaticRestart?: pulumi.Input<boolean>;
        /**
         * Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
         */
        availabilityDomain?: pulumi.Input<number>;
        /**
         * Settings for the instance to perform a graceful shutdown.
         */
        gracefulShutdown?: pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingGracefulShutdown>;
        /**
         * Specifies the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
         */
        hostErrorTimeoutSeconds?: pulumi.Input<number>;
        /**
         * Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)
         */
        instanceTerminationAction?: pulumi.Input<string>;
        /**
         * Specifies the maximum amount of time a Local Ssd Vm should wait while
         *   recovery of the Local Ssd state is attempted. Its value should be in
         *   between 0 and 168 hours with hour granularity and the default value being 1
         *   hour.
         */
        localSsdRecoveryTimeouts?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout>[]>;
        /**
         * Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC
         */
        maintenanceInterval?: pulumi.Input<string>;
        /**
         * The duration of the instance. Instance will run and be terminated after then, the termination action could be defined in `instanceTerminationAction`. Only support `DELETE` `instanceTerminationAction` at this point. Structure is documented below.
         */
        maxRunDuration?: pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingMaxRunDuration>;
        /**
         * Minimum number of cpus for the instance.
         */
        minNodeCpus?: pulumi.Input<number>;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingNodeAffinity>[]>;
        /**
         * Defines the maintenance behavior for this
         * instance.
         */
        onHostMaintenance?: pulumi.Input<string>;
        /**
         * Defines the behaviour for instances with the instance_termination_action.
         */
        onInstanceStopAction?: pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingOnInstanceStopAction>;
        /**
         * Allows instance to be preempted. This defaults to
         * false. Read more on this
         * [here](https://cloud.google.com/compute/docs/instances/preemptible).
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,
         * `preemptible` should be `true` and `automaticRestart` should be
         * `false`. For more info about
         * `SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)
         */
        provisioningModel?: pulumi.Input<string>;
        /**
         * Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
         */
        terminationTime?: pulumi.Input<string>;
    }

    export interface RegionInstanceTemplateSchedulingGracefulShutdown {
        /**
         * Opts-in for graceful shutdown.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The time allotted for the instance to gracefully shut down.
         * If the graceful shutdown isn't complete after this time, then the instance
         * transitions to the STOPPING state. Structure is documented below:
         */
        maxDuration?: pulumi.Input<inputs.compute.RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration>;
    }

    export interface RegionInstanceTemplateSchedulingGracefulShutdownMaxDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * The value must be between 1 and 3600, which is 3,600 seconds (one hour).`
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionInstanceTemplateSchedulingLocalSsdRecoveryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must
         * be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second.
         * Must be from 0 to 315,576,000,000 inclusive.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionInstanceTemplateSchedulingMaxRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond
         * resolution. Durations less than one second are represented with a 0
         * `seconds` field and a positive `nanos` field. Must be from 0 to
         * 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to
         * 315,576,000,000 inclusive. Note: these bounds are computed from: 60
         * sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
         */
        seconds: pulumi.Input<number>;
    }

    export interface RegionInstanceTemplateSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: pulumi.Input<string>;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: pulumi.Input<string>;
        /**
         * Corresponds to the label values of a reservation resource.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionInstanceTemplateSchedulingOnInstanceStopAction {
        /**
         * If true, the contents of any attached Local SSD disks will be discarded.
         */
        discardLocalSsd?: pulumi.Input<boolean>;
    }

    export interface RegionInstanceTemplateServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         */
        email?: pulumi.Input<string>;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         *
         * The [service accounts documentation](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
         * explains that access scopes are the legacy method of specifying permissions for your instance.
         * To follow best practices you should create a dedicated service account with the minimum permissions the VM requires.
         * To use a dedicated service account this field should be configured as a list containing the `cloud-platform` scope.
         * See [Authenticate workloads using service accounts best practices](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#best_practices)
         * and [Best practices for using service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts#single-purpose).
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionInstanceTemplateShieldedInstanceConfig {
        /**
         * - Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * - Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * - Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface RegionNetworkEndpointGroupAppEngine {
        /**
         * Optional serving service.
         * The service name must be 1-63 characters long, and comply with RFC1035.
         * Example value: "default", "my-service".
         */
        service?: pulumi.Input<string>;
        /**
         * A template to parse service and version fields from a request URL.
         * URL mask allows for routing to multiple App Engine services without
         * having to create multiple Network Endpoint Groups and backend services.
         * For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
         * "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with
         * URL mask "-dot-appname.appspot.com/". The URL mask will parse
         * them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
         */
        urlMask?: pulumi.Input<string>;
        /**
         * Optional serving version.
         * The version must be 1-63 characters long, and comply with RFC1035.
         * Example value: "v1", "v2".
         */
        version?: pulumi.Input<string>;
    }

    export interface RegionNetworkEndpointGroupCloudFunction {
        /**
         * A user-defined name of the Cloud Function.
         * The function name is case-sensitive and must be 1-63 characters long.
         * Example value: "func1".
         */
        function?: pulumi.Input<string>;
        /**
         * A template to parse function field from a request URL. URL mask allows
         * for routing to multiple Cloud Functions without having to create
         * multiple Network Endpoint Groups and backend services.
         * For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
         * can be backed by the same Serverless NEG with URL mask "/". The URL mask
         * will parse them to { function = "function1" } and { function = "function2" } respectively.
         */
        urlMask?: pulumi.Input<string>;
    }

    export interface RegionNetworkEndpointGroupCloudRun {
        /**
         * Cloud Run service is the main resource of Cloud Run.
         * The service must be 1-63 characters long, and comply with RFC1035.
         * Example value: "run-service".
         */
        service?: pulumi.Input<string>;
        /**
         * Cloud Run tag represents the "named-revision" to provide
         * additional fine-grained traffic routing information.
         * The tag must be 1-63 characters long, and comply with RFC1035.
         * Example value: "revision-0010".
         */
        tag?: pulumi.Input<string>;
        /**
         * A template to parse service and tag fields from a request URL.
         * URL mask allows for routing to multiple Run services without having
         * to create multiple network endpoint groups and backend services.
         * For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
         * an be backed by the same Serverless Network Endpoint Group (NEG) with
         * URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
         * and { service="bar2", tag="foo2" } respectively.
         */
        urlMask?: pulumi.Input<string>;
    }

    export interface RegionNetworkEndpointGroupPscData {
        /**
         * The PSC producer port to use when consumer PSC NEG connects to a producer. If
         * this flag isn't specified for a PSC NEG with endpoint type
         * private-service-connect, then PSC NEG will be connected to a first port in the
         * available PSC producer port range.
         */
        producerPort?: pulumi.Input<string>;
    }

    export interface RegionNetworkEndpointGroupServerlessDeployment {
        /**
         * The platform of the NEG backend target(s). Possible values:
         * API Gateway: apigateway.googleapis.com
         */
        platform: pulumi.Input<string>;
        /**
         * The user-defined name of the workload/instance. This value must be provided explicitly or in the urlMask.
         * The resource identified by this value is platform-specific and is as follows: API Gateway: The gateway ID, App Engine: The service name,
         * Cloud Functions: The function name, Cloud Run: The service name
         */
        resource?: pulumi.Input<string>;
        /**
         * A template to parse platform-specific fields from a request URL. URL mask allows for routing to multiple resources
         * on the same serverless platform without having to create multiple Network Endpoint Groups and backend resources.
         * The fields parsed by this template are platform-specific and are as follows: API Gateway: The gateway ID,
         * App Engine: The service and version, Cloud Functions: The function name, Cloud Run: The service and tag
         */
        urlMask?: pulumi.Input<string>;
        /**
         * The optional resource version. The version identified by this value is platform-specific and is follows:
         * API Gateway: Unused, App Engine: The service version, Cloud Functions: Unused, Cloud Run: The service tag
         */
        version?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
         *
         *
         * <a name="nestedMatchLayer4Configs"></a>The `layer4Configs` block supports:
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyRuleMatchLayer4Config {
        /**
         * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule.
         * This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the secure tag, either EFFECTIVE or INEFFECTIVE. A secure tag is INEFFECTIVE when it is deleted or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesPredefinedRule {
        /**
         * (Output)
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action?: pulumi.Input<string>;
        /**
         * (Output)
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         */
        direction?: pulumi.Input<string>;
        /**
         * (Output)
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * (Output)
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch>[]>;
        /**
         * (Output)
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority?: pulumi.Input<number>;
        /**
         * (Output)
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * (Output)
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * (Output)
         * A list of secure tags that controls which instances the firewall rule
         * applies to. If <code>targetSecureTag</code> are specified, then the
         * firewall rule applies only to instances in the VPC network that have one
         * of those EFFECTIVE secure tags, if all the targetSecureTag are in
         * INEFFECTIVE state, then this rule will be ignored.
         * <code>targetSecureTag</code> may not be set at the same time as
         * <code>targetServiceAccounts</code>.
         * If neither <code>targetServiceAccounts</code> nor
         * <code>targetSecureTag</code> are specified, the firewall rule applies
         * to all instances on the specified network.
         * Maximum number of target label tags allowed is 256.
         * Structure is documented below.
         */
        targetSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag>[]>;
        /**
         * (Output)
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source
         * of the traffic.
         * For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
         * and there is no <code>srcIpRange</code>, this rule will be ignored.
         * Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol?: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesPredefinedRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesPredefinedRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesRule {
        /**
         * The Action to perform when the client connection triggers the rule. Can currently be either
         * "allow", "deny", "applySecurityProfileGroup" or "gotoNext".
         */
        action: pulumi.Input<string>;
        /**
         * A description of the rule.
         */
        description?: pulumi.Input<string>;
        /**
         * The direction in which this rule applies. If unspecified an INGRESS rule is created.
         * Possible values are: `INGRESS`, `EGRESS`.
         */
        direction?: pulumi.Input<string>;
        /**
         * Denotes whether the firewall policy rule is disabled. When set to true,
         * the firewall policy rule is not enforced and traffic behaves as if it did
         * not exist. If this is unspecified, the firewall policy rule will be
         * enabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Denotes whether to enable logging for a particular rule.
         * If logging is enabled, logs will be exported to the
         * configured export destination in Stackdriver.
         */
        enableLogging?: pulumi.Input<boolean>;
        /**
         * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        match: pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesRuleMatch>;
        /**
         * An integer indicating the priority of a rule in the list. The priority must be a value
         * between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the
         * highest priority and 2147483647 is the lowest priority.
         */
        priority: pulumi.Input<number>;
        /**
         * An optional name for the rule. This field is not a unique identifier
         * and can be updated.
         */
        ruleName?: pulumi.Input<string>;
        /**
         * A fully-qualified URL of a SecurityProfile resource instance.
         * Example:
         * https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group
         * Must be specified if action is 'apply_security_profile_group'.
         */
        securityProfileGroup?: pulumi.Input<string>;
        /**
         * A list of secure tags that controls which instances the firewall rule
         * applies to. If <code>targetSecureTag</code> are specified, then the
         * firewall rule applies only to instances in the VPC network that have one
         * of those EFFECTIVE secure tags, if all the targetSecureTag are in
         * INEFFECTIVE state, then this rule will be ignored.
         * <code>targetSecureTag</code> may not be set at the same time as
         * <code>targetServiceAccounts</code>.
         * If neither <code>targetServiceAccounts</code> nor
         * <code>targetSecureTag</code> are specified, the firewall rule applies
         * to all instances on the specified network.
         * Maximum number of target label tags allowed is 256.
         * Structure is documented below.
         */
        targetSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag>[]>;
        /**
         * A list of service accounts indicating the sets of
         * instances that are applied with this rule.
         */
        targetServiceAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Boolean flag indicating if the traffic should be TLS decrypted.
         * It can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
         */
        tlsInspect?: pulumi.Input<boolean>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesRuleMatch {
        /**
         * Address groups which should be matched against the traffic destination.
         * Maximum number of destination address groups is 10.
         */
        destAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic destination. Maximum number of destination fqdn allowed is 100.
         */
        destFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination IP address range in CIDR format. Required for
         * EGRESS rules.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic destination.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        destNetworkScope?: pulumi.Input<string>;
        /**
         * Region codes whose IP addresses will be used to match for destination
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of destination region codes allowed is 5000.
         */
        destRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic destination.
         */
        destThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Pairs of IP protocols and ports that the rule should match.
         * Structure is documented below.
         */
        layer4Configs: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config>[]>;
        /**
         * Address groups which should be matched against the traffic source.
         * Maximum number of source address groups is 10.
         */
        srcAddressGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fully Qualified Domain Name (FQDN) which should be matched against
         * traffic source. Maximum number of source fqdn allowed is 100.
         */
        srcFqdns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source IP address range in CIDR format. Required for
         * INGRESS rules.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network scope of the traffic source.
         * Possible values are: `INTERNET`, `INTRA_VPC`, `NON_INTERNET`, `VPC_NETWORKS`.
         */
        srcNetworkScope?: pulumi.Input<string>;
        /**
         * Networks of the traffic source. It can be either a full or partial url.
         */
        srcNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Region codes whose IP addresses will be used to match for source
         * of traffic. Should be specified as 2 letter country code defined as per
         * ISO 3166 alpha-2 country codes. ex."US"
         * Maximum number of source region codes allowed is 5000.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of secure tag values, which should be matched at the source
         * of the traffic.
         * For INGRESS rule, if all the <code>srcSecureTag</code> are INEFFECTIVE,
         * and there is no <code>srcIpRange</code>, this rule will be ignored.
         * Maximum number of source tag values allowed is 256.
         * Structure is documented below.
         *
         *
         * <a name="nestedRuleRuleMatchLayer4Config"></a>The `layer4Config` block supports:
         */
        srcSecureTags?: pulumi.Input<pulumi.Input<inputs.compute.RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag>[]>;
        /**
         * Names of Network Threat Intelligence lists.
         * The IPs in these lists will be matched against traffic source.
         */
        srcThreatIntelligences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesRuleMatchLayer4Config {
        /**
         * (Output)
         * The IP protocol to which this rule applies. The protocol
         * type is required when creating a firewall rule.
         * This value can either be one of the following well
         * known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),
         * or the IP protocol number.
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * (Output)
         * An optional list of ports to which this rule applies. This field
         * is only applicable for UDP or TCP protocol. Each entry must be
         * either an integer or a range. If not specified, this rule
         * applies to connections through any port.
         * Example inputs include: ["22"], ["80","443"], and
         * ["12345-12349"].
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesRuleMatchSrcSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionNetworkFirewallPolicyWithRulesRuleTargetSecureTag {
        /**
         * Name of the secure tag, created with TagManager's TagValue API.
         * @pattern tagValues/[0-9]+
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * [Output Only] State of the secure tag, either `EFFECTIVE` or
         * `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
         * or its network is deleted.
         *
         * - - -
         */
        state?: pulumi.Input<string>;
    }

    export interface RegionPerInstanceConfigPreservedState {
        /**
         * Stateful disks for the instance.
         * Structure is documented below.
         */
        disks?: pulumi.Input<pulumi.Input<inputs.compute.RegionPerInstanceConfigPreservedStateDisk>[]>;
        /**
         * Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
         * Structure is documented below.
         */
        externalIps?: pulumi.Input<pulumi.Input<inputs.compute.RegionPerInstanceConfigPreservedStateExternalIp>[]>;
        /**
         * Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
         * Structure is documented below.
         */
        internalIps?: pulumi.Input<pulumi.Input<inputs.compute.RegionPerInstanceConfigPreservedStateInternalIp>[]>;
        /**
         * Preserved metadata defined for this instance. This is a list of key->value pairs.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RegionPerInstanceConfigPreservedStateDisk {
        /**
         * A value that prescribes what should happen to the stateful disk when the VM instance is deleted.
         * The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`.
         * `NEVER` - detach the disk when the VM is deleted, but do not delete the disk.
         * `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently
         * deleted from the instance group.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        deleteRule?: pulumi.Input<string>;
        /**
         * A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance.
         */
        deviceName: pulumi.Input<string>;
        /**
         * The mode of the disk.
         * Default value is `READ_WRITE`.
         * Possible values are: `READ_ONLY`, `READ_WRITE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * The URI of an existing persistent disk to attach under the specified device-name in the format
         * `projects/project-id/zones/zone/disks/disk-name`.
         */
        source: pulumi.Input<string>;
    }

    export interface RegionPerInstanceConfigPreservedStateExternalIp {
        /**
         * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        autoDelete?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        interfaceName: pulumi.Input<string>;
        /**
         * Ip address representation
         * Structure is documented below.
         */
        ipAddress?: pulumi.Input<inputs.compute.RegionPerInstanceConfigPreservedStateExternalIpIpAddress>;
    }

    export interface RegionPerInstanceConfigPreservedStateExternalIpIpAddress {
        /**
         * The URL of the reservation for this IP address.
         */
        address?: pulumi.Input<string>;
    }

    export interface RegionPerInstanceConfigPreservedStateInternalIp {
        /**
         * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
         * Default value is `NEVER`.
         * Possible values are: `NEVER`, `ON_PERMANENT_INSTANCE_DELETION`.
         */
        autoDelete?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        interfaceName: pulumi.Input<string>;
        /**
         * Ip address representation
         * Structure is documented below.
         */
        ipAddress?: pulumi.Input<inputs.compute.RegionPerInstanceConfigPreservedStateInternalIpIpAddress>;
    }

    export interface RegionPerInstanceConfigPreservedStateInternalIpIpAddress {
        /**
         * The URL of the reservation for this IP address.
         */
        address?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestRequestedRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatus {
        /**
         * (Output)
         * Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusError>[]>;
        /**
         * (Output)
         * Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
         * Structure is documented below.
         */
        lastAttempts?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttempt>[]>;
    }

    export interface RegionResizeRequestStatusError {
        /**
         * (Output)
         * The array of errors encountered while processing this operation.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorError>[]>;
    }

    export interface RegionResizeRequestStatusErrorError {
        /**
         * (Output)
         * The error type identifier for this error.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
         * Structure is documented below.
         */
        errorDetails?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetail>[]>;
        /**
         * (Output)
         * Indicates the field in the request that caused the error. This property is optional.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetail {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        errorInfos?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        helps?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetailHelp>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        localizedMessages?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        quotaInfos?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo>[]>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetailErrorInfo {
        /**
         * (Output)
         * The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
         */
        domain?: pulumi.Input<string>;
        /**
         * (Output)
         * Additional structured details about this error.
         */
        metadatas?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
         */
        reason?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetailHelp {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        links?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusErrorErrorErrorDetailHelpLink>[]>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetailHelpLink {
        /**
         * An optional description of this resize-request.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL of the link.
         */
        url?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetailLocalizedMessage {
        /**
         * (Output)
         * The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
         */
        locale?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusErrorErrorErrorDetailQuotaInfo {
        /**
         * (Output)
         * The map holding related quota dimensions
         */
        dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
         */
        futureLimit?: pulumi.Input<number>;
        /**
         * (Output)
         * Current effective quota limit. The limit's unit depends on the quota type or metric.
         */
        limit?: pulumi.Input<number>;
        /**
         * (Output)
         * The name of the quota limit.
         */
        limitName?: pulumi.Input<string>;
        /**
         * (Output)
         * The Compute Engine quota metric name.
         */
        metricName?: pulumi.Input<string>;
        /**
         * (Output)
         * Rollout status of the future quota limit.
         */
        rolloutStatus?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusLastAttempt {
        /**
         * (Output)
         * Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptError>[]>;
    }

    export interface RegionResizeRequestStatusLastAttemptError {
        /**
         * (Output)
         * The array of errors encountered while processing this operation.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorError>[]>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorError {
        /**
         * (Output)
         * The error type identifier for this error.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
         * Structure is documented below.
         */
        errorDetails?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail>[]>;
        /**
         * (Output)
         * Indicates the field in the request that caused the error. This property is optional.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetail {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        errorInfos?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        helps?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        localizedMessages?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        quotaInfos?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo>[]>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo {
        /**
         * (Output)
         * The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
         */
        domain?: pulumi.Input<string>;
        /**
         * (Output)
         * Additional structured details about this error.
         */
        metadatas?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
         */
        reason?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        links?: pulumi.Input<pulumi.Input<inputs.compute.RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink>[]>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink {
        /**
         * An optional description of this resize-request.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL of the link.
         */
        url?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage {
        /**
         * (Output)
         * The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
         */
        locale?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface RegionResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo {
        /**
         * (Output)
         * The map holding related quota dimensions
         */
        dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
         */
        futureLimit?: pulumi.Input<number>;
        /**
         * (Output)
         * Current effective quota limit. The limit's unit depends on the quota type or metric.
         */
        limit?: pulumi.Input<number>;
        /**
         * (Output)
         * The name of the quota limit.
         */
        limitName?: pulumi.Input<string>;
        /**
         * (Output)
         * The Compute Engine quota metric name.
         */
        metricName?: pulumi.Input<string>;
        /**
         * (Output)
         * Rollout status of the future quota limit.
         */
        rolloutStatus?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyDdosProtectionConfig {
        /**
         * Google Cloud Armor offers the following options to help protect systems against DDoS attacks:
         * - STANDARD: basic always-on protection for network load balancers, protocol forwarding, or VMs with public IP addresses.
         * - ADVANCED: additional protections for Managed Protection Plus subscribers who use network load balancers, protocol forwarding, or VMs with public IP addresses.
         * - ADVANCED_PREVIEW: flag to enable the security policy in preview mode.
         * Possible values are: `ADVANCED`, `ADVANCED_PREVIEW`, `STANDARD`.
         */
        ddosProtection: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRule {
        /**
         * The Action to perform when the rule is matched. The following are the valid actions:
         * * allow: allow access to target.
         * * deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for STATUS are 403, 404, and 502.
         * * rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rateLimitOptions to be set.
         * * redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR.
         * * throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rateLimitOptions to be set for this.
         */
        action: pulumi.Input<string>;
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * A match condition that incoming traffic is evaluated against.
         * If it evaluates to true, the corresponding 'action' is enforced.
         * Structure is documented below.
         */
        match?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleMatch>;
        /**
         * A match condition that incoming packets are evaluated against for CLOUD_ARMOR_NETWORK security policies. If it matches, the corresponding 'action' is enforced.
         * The match criteria for a rule consists of built-in match fields (like 'srcIpRanges') and potentially multiple user-defined match fields ('userDefinedFields').
         * Field values may be extracted directly from the packet or derived from it (e.g. 'srcRegionCodes'). Some fields may not be present in every packet (e.g. 'srcPorts'). A user-defined field is only present if the base header is found in the packet and the entire field is in bounds.
         * Each match field may specify which values can match it, listing one or more ranges, prefixes, or exact values that are considered a match for the field. A field value must be present in order to match a specified match field. If no match values are specified for a match field, then any field value is considered to match it, and it's not required to be present. For strings specifying '*' is also equivalent to match all.
         * For a packet to match a rule, all specified match fields must match the corresponding field values derived from the packet.
         * Example:
         * networkMatch: srcIpRanges: - "192.0.2.0/24" - "198.51.100.0/24" userDefinedFields: - name: "ipv4FragmentOffset" values: - "1-0x1fff"
         * The above match condition matches packets with a source IP in 192.0.2.0/24 or 198.51.100.0/24 and a user-defined field named "ipv4FragmentOffset" with a value between 1 and 0x1fff inclusive
         * Structure is documented below.
         */
        networkMatch?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleNetworkMatch>;
        /**
         * Preconfigured WAF configuration to be applied for the rule.
         * If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
         * Structure is documented below.
         */
        preconfiguredWafConfig?: pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfig>;
        /**
         * If set to true, the specified action is not enforced.
         */
        preview?: pulumi.Input<boolean>;
        /**
         * An integer indicating the priority of a rule in the list.
         * The priority must be a positive value between 0 and 2147483647.
         * Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
         */
        priority: pulumi.Input<number>;
        /**
         * Must be specified if the action is "rateBasedBan" or "throttle". Cannot be specified for any other actions.
         * Structure is documented below.
         */
        rateLimitOptions?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleRateLimitOptions>;
    }

    export interface RegionSecurityPolicyRuleMatch {
        /**
         * The configuration options available when specifying versionedExpr.
         * This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
         * Structure is documented below.
         */
        config?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleMatchConfig>;
        /**
         * User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
         * Structure is documented below.
         */
        expr?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleMatchExpr>;
        /**
         * Preconfigured versioned expression. If this field is specified, config must also be specified.
         * Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
         * Possible values are: `SRC_IPS_V1`.
         */
        versionedExpr?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRuleMatchConfig {
        /**
         * CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionSecurityPolicyRuleMatchExpr {
        /**
         * Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
         */
        expression: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRuleNetworkMatch {
        /**
         * Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
         */
        destIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
         */
        destPorts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
         */
        ipProtocols?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * BGP Autonomous System Number associated with the source IP address.
         */
        srcAsns?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
         */
        srcPorts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
         */
        srcRegionCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * User-defined fields. Each element names a defined field and lists the matching values for that field.
         * Structure is documented below.
         */
        userDefinedFields?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRuleNetworkMatchUserDefinedField>[]>;
    }

    export interface RegionSecurityPolicyRuleNetworkMatchUserDefinedField {
        /**
         * Name of the user-defined field, as given in the definition.
         */
        name?: pulumi.Input<string>;
        /**
         * Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfig {
        /**
         * An exclusion to apply during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        exclusions?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfigExclusion>[]>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfigExclusion {
        /**
         * Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        requestCookies?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky>[]>;
        /**
         * Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        requestHeaders?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader>[]>;
        /**
         * Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Note that the parameter can be in the query string or in the POST body.
         * Structure is documented below.
         */
        requestQueryParams?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam>[]>;
        /**
         * Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
         * When specifying this field, the query or fragment part should be excluded.
         * Structure is documented below.
         */
        requestUris?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri>[]>;
        /**
         * A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
         * If omitted, it refers to all the rule IDs under the WAF rule set.
         */
        targetRuleIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Target WAF rule set to apply the preconfigured WAF exclusion.
         */
        targetRuleSet: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         * Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         * Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         * Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         * Possible values are: `CONTAINS`, `ENDS_WITH`, `EQUALS`, `EQUALS_ANY`, `STARTS_WITH`.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRuleRateLimitOptions {
        /**
         * Can only be specified if the action for the rule is "rateBasedBan".
         * If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
         */
        banDurationSec?: pulumi.Input<number>;
        /**
         * Can only be specified if the action for the rule is "rateBasedBan".
         * If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
         * Structure is documented below.
         */
        banThreshold?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleRateLimitOptionsBanThreshold>;
        /**
         * Action to take for requests that are under the configured rate limit threshold.
         * Valid option is "allow" only.
         */
        conformAction?: pulumi.Input<string>;
        /**
         * Determines the key to enforce the rateLimitThreshold on. Possible values are:
         * * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
         * * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
         * * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
         * * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
         * * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
         * * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
         * * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
         * * REGION_CODE: The country/region from which the request originates.
         * * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
         * * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
         * Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `USER_IP`.
         */
        enforceOnKey?: pulumi.Input<string>;
        /**
         * If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
         * You can specify up to 3 enforceOnKeyConfigs.
         * If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
         * Structure is documented below.
         */
        enforceOnKeyConfigs?: pulumi.Input<pulumi.Input<inputs.compute.RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig>[]>;
        /**
         * Rate limit key name applicable only for the following key types:
         * HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
         * HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
         */
        enforceOnKeyName?: pulumi.Input<string>;
        /**
         * Action to take for requests that are above the configured rate limit threshold, to deny with a specified HTTP response code.
         * Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
         */
        exceedAction?: pulumi.Input<string>;
        /**
         * Threshold at which to begin ratelimiting.
         * Structure is documented below.
         */
        rateLimitThreshold?: pulumi.Input<inputs.compute.RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold>;
    }

    export interface RegionSecurityPolicyRuleRateLimitOptionsBanThreshold {
        /**
         * Number of HTTP(S) requests for calculating the threshold.
         */
        count?: pulumi.Input<number>;
        /**
         * Interval over which the threshold is computed.
         */
        intervalSec?: pulumi.Input<number>;
    }

    export interface RegionSecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
        /**
         * Rate limit key name applicable only for the following key types:
         * HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
         * HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
         */
        enforceOnKeyName?: pulumi.Input<string>;
        /**
         * Determines the key to enforce the rateLimitThreshold on. Possible values are:
         * * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
         * * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
         * * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
         * * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
         * * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
         * * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
         * * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
         * * REGION_CODE: The country/region from which the request originates.
         * * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
         * * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
         * Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `USER_IP`.
         */
        enforceOnKeyType?: pulumi.Input<string>;
    }

    export interface RegionSecurityPolicyRuleRateLimitOptionsRateLimitThreshold {
        /**
         * Number of HTTP(S) requests for calculating the threshold.
         */
        count?: pulumi.Input<number>;
        /**
         * Interval over which the threshold is computed.
         */
        intervalSec?: pulumi.Input<number>;
    }

    export interface RegionSecurityPolicyUserDefinedField {
        /**
         * The base relative to which 'offset' is measured. Possible values are:
         * - IPV4: Points to the beginning of the IPv4 header.
         * - IPV6: Points to the beginning of the IPv6 header.
         * - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
         * - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments.
         * Possible values are: `IPV4`, `IPV6`, `TCP`, `UDP`.
         */
        base: pulumi.Input<string>;
        /**
         * If specified, apply this mask (bitwise AND) to the field to ignore bits before matching.
         * Encoded as a hexadecimal number (starting with "0x").
         * The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
         */
        mask?: pulumi.Input<string>;
        /**
         * Name of the user-defined field, as given in the definition.
         */
        name?: pulumi.Input<string>;
        /**
         * Offset of the first byte of the field (in network byte order) relative to 'base'.
         */
        offset?: pulumi.Input<number>;
        /**
         * Size of the field in bytes. Valid values: 1-4.
         */
        size?: pulumi.Input<number>;
    }

    export interface RegionUrlMapDefaultRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see
         * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
         * As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
         * Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
         * timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
         * Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
         * The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
         * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
         * If not specified, this field uses the largest timeout among all backend services associated with the route.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, before forwarding the request to the matched service.
         * urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
         * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
         * After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapDefaultRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
         * Default is false.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapDefaultRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapDefaultRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface RegionUrlMapDefaultRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the RegionBackendService resource being mirrored to.
         * The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
         * Serverless NEG backends are not currently supported as a mirrored backend service.
         */
        backendService?: pulumi.Input<string>;
    }

    export interface RegionUrlMapDefaultRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specifies one or more conditions when this retry policy applies.
         * Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
         * - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
         * - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
         * - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
         * - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
         * - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
         * - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
         * - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
         * - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
         * - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapDefaultRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface RegionUrlMapDefaultRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface RegionUrlMapDefaultRouteActionUrlRewrite {
        /**
         * Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
         * The value must be from 1 to 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
         * The value must be from 1 to 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapDefaultRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
         */
        backendService?: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
         * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
         * The value must be from 0 to 1000.
         */
        weight?: pulumi.Input<number>;
    }

    export interface RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request before forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response before sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response before sending the response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapDefaultUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set to
         * false, the URL scheme of the redirected request will remain the same as that of the
         * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
         * true for TargetHttpsProxy is not permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. pathRedirect cannot be supplied together with
         * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
         * original request will be used for the redirect. The value must be between 1 and 1024
         * characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
         * neither. If neither is supplied, the path of the original request will be used for
         * the redirect. The value must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior
         * to redirecting the request. If set to false, the query portion of the original URL is
         * retained.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapHostRule {
        /**
         * An optional description of this HostRule. Provide this property
         * when you create the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * The list of host patterns to match. They must be valid
         * hostnames, except * will match any string of ([a-z0-9-.]*). In
         * that case, * must be the first character and must be followed in
         * the pattern by either - or ..
         */
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the PathMatcher to use to match the path portion of
         * the URL if the hostRule matches the URL's host portion.
         */
        pathMatcher: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcher {
        /**
         * A reference to a RegionBackendService resource. This will be used if
         * none of the pathRules defined by this PathMatcher is matched by
         * the URL's path portion.
         */
        defaultService?: pulumi.Input<string>;
        /**
         * When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         */
        defaultUrlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherDefaultUrlRedirect>;
        /**
         * An optional description of this resource.
         */
        description?: pulumi.Input<string>;
        /**
         * The name to which this PathMatcher is referred by the HostRule.
         */
        name: pulumi.Input<string>;
        /**
         * The list of path rules. Use this list instead of routeRules when routing based
         * on simple path matching is all that's required. The order by which path rules
         * are specified does not matter. Matches are always done on the longest-path-first
         * basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
         * irrespective of the order in which those paths appear in this list. Within a
         * given pathMatcher, only one of pathRules or routeRules must be set.
         * Structure is documented below.
         */
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRule>[]>;
        /**
         * The list of ordered HTTP route rules. Use this list instead of pathRules when
         * advanced route matching and routing actions are desired. The order of specifying
         * routeRules matters: the first rule that matches will cause its specified routing
         * action to take effect. Within a given pathMatcher, only one of pathRules or
         * routeRules must be set. routeRules are not supported in UrlMaps intended for
         * External load balancers.
         * Structure is documented below.
         */
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRule>[]>;
    }

    export interface RegionUrlMapPathMatcherDefaultUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set to
         * false, the URL scheme of the redirected request will remain the same as that of the
         * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
         * true for TargetHttpsProxy is not permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. pathRedirect cannot be supplied together with
         * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
         * original request will be used for the redirect. The value must be between 1 and 1024
         * characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
         * neither. If neither is supplied, the path of the original request will be used for
         * the redirect. The value must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior
         * to redirecting the request. If set to false, the query portion of the original URL is
         * retained.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRule {
        /**
         * The list of path patterns to match. Each must start with / and the only place a
         * \* is allowed is at the end following a /. The string fed to the path matcher
         * does not include any text after the first ? or #, and those chars are not
         * allowed here.
         */
        paths: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * In response to a matching path, the load balancer performs advanced routing
         * actions like URL rewrites, header transformations, etc. prior to forwarding the
         * request to the selected backend. If routeAction specifies any
         * weightedBackendServices, service must not be set. Conversely if service is set,
         * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
         * or urlRedirect must be set.
         * Structure is documented below.
         */
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction>;
        /**
         * The region backend service resource to which traffic is
         * directed if this rule is matched. If routeAction is additionally specified,
         * advanced routing actions like URL Rewrites, etc. take effect prior to sending
         * the request to the backend. However, if service is specified, routeAction cannot
         * contain any weightedBackendService s. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified. Only one of urlRedirect,
         * service or routeAction.weightedBackendService must be set.
         */
        service?: pulumi.Input<string>;
        /**
         * When a path pattern is matched, the request is redirected to a URL specified
         * by urlRedirect. If urlRedirect is specified, service or routeAction must not
         * be set.
         * Structure is documented below.
         */
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see W3C
         * Recommendation for Cross Origin Resource Sharing
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the
         * resiliency of clients to backend service failure. As part of fault injection,
         * when clients send requests to a backend service, delays can be introduced by
         * Loadbalancer on a percentage of requests before sending those request to the
         * backend service. Similarly requests from clients can be aborted by the
         * Loadbalancer for a percentage of requests. timeout and retryPolicy will be
         * ignored by clients that are configured with a fault_injection_policy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the policy on how requests intended for the route's backends are
         * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
         * responses from the shadow service. Prior to sending traffic to the shadow
         * service, the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time
         * the request is has been fully processed (i.e. end-of-stream) up until the
         * response has been completely processed. Timeout includes all retries. If not
         * specified, the default value is 15 seconds.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to
         * the matched service
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match
         * occurs. The weights determine the fraction of traffic that flows to their
         * corresponding backend service. If all traffic needs to go to a single backend
         * service, there must be one  weightedBackendService with weight set to a non 0
         * number. Once a backendService is identified and before forwarding the request to
         * the backend service, advanced routing actions like Url rewrites and header
         * transformations are applied depending on additional settings specified in this
         * HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
         * Default is false.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
         */
        disabled: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the RegionBackendService resource being mirrored to.
         * The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
         * Serverless NEG backends are not currently supported as a mirrored backend service.
         */
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specifies one or more conditions when this retry policy applies.
         * Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
         * - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
         * - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
         * - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
         * - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
         * - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
         * - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
         * - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
         * - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
         * - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        /**
         * Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
         * The value must be from 1 to 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
         * The value must be from 1 to 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
         */
        backendService: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
         * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
         * The value must be from 0 to 1000.
         */
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request before forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response before sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response before sending the response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one
         * that was supplied in the request. The value must be between 1 and 255
         * characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https.
         * If set to false, the URL scheme of the redirected request will remain the
         * same as that of the request. This must only be set for UrlMaps used in
         * TargetHttpProxys. Setting this true for TargetHttpsProxy is not
         * permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one
         * that was supplied in the request. pathRedirect cannot be supplied
         * together with prefixRedirect. Supply one alone or neither. If neither is
         * supplied, the path of the original request will be used for the redirect.
         * The value must be between 1 and 1024 characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the
         * HttpRouteRuleMatch, retaining the remaining portion of the URL before
         * redirecting the request. prefixRedirect cannot be supplied together with
         * pathRedirect. Supply one alone or neither. If neither is supplied, the
         * path of the original request will be used for the redirect. The value
         * must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed
         * prior to redirecting the request. If set to false, the query portion of the
         * original URL is retained.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService. The headerAction specified here are applied before
         * the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
         * outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction>;
        /**
         * The rules for determining a match.
         * Structure is documented below.
         */
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule>[]>;
        /**
         * For routeRules within a given pathMatcher, priority determines the order
         * in which load balancer will interpret routeRules. RouteRules are evaluated
         * in order of priority, from the lowest to highest number. The priority of
         * a rule decreases as its number increases (1, 2, 3, N+1). The first rule
         * that matches the request is applied.
         * You cannot configure two or more routeRules with the same priority.
         * Priority for each rule must be set to a number between 0 and
         * 2147483647 inclusive.
         * Priority numbers can have gaps, which enable you to add or remove rules
         * in the future without affecting the rest of the rules. For example,
         * 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
         * you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
         * future without any impact on existing rules.
         */
        priority: pulumi.Input<number>;
        /**
         * In response to a matching matchRule, the load balancer performs advanced routing
         * actions like URL rewrites, header transformations, etc. prior to forwarding the
         * request to the selected backend. If  routeAction specifies any
         * weightedBackendServices, service must not be set. Conversely if service is set,
         * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
         * or urlRedirect must be set.
         * Structure is documented below.
         */
        routeAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction>;
        /**
         * The region backend service resource to which traffic is
         * directed if this rule is matched. If routeAction is additionally specified,
         * advanced routing actions like URL Rewrites, etc. take effect prior to sending
         * the request to the backend. However, if service is specified, routeAction cannot
         * contain any weightedBackendService s. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified. Only one of urlRedirect,
         * service or routeAction.weightedBackendService must be set.
         */
        service?: pulumi.Input<string>;
        /**
         * When this rule is matched, the request is redirected to a URL specified by
         * urlRedirect. If urlRedirect is specified, service or routeAction must not be
         * set.
         * Structure is documented below.
         */
        urlRedirect?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        /**
         * Headers to add to a matching request before forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response before sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response before sending the response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        /**
         * For satisfying the matchRule condition, the path of the request must exactly
         * match the value specified in fullPathMatch after removing any query parameters
         * and anchor that may be part of the original URL. FullPathMatch must be between 1
         * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
         * be specified.
         */
        fullPathMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of header match criteria, all of which must match corresponding
         * headers in the request.
         * Structure is documented below.
         */
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        /**
         * Specifies that prefixMatch and fullPathMatch matches are case sensitive.
         * Defaults to false.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * Opaque filter criteria used by Loadbalancer to restrict routing configuration to
         * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
         * clients present node metadata. If a match takes place, the relevant routing
         * configuration is made available to those proxies. For each metadataFilter in
         * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
         * filterLabels must match the corresponding label provided in the metadata. If its
         * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
         * with corresponding labels in the provided metadata. metadataFilters specified
         * here can be overrides those specified in ForwardingRule that refers to this
         * UrlMap. metadataFilters only applies to Loadbalancers that have their
         * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
         * Structure is documented below.
         */
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        /**
         * For satisfying the matchRule condition, the path of the request
         * must match the wildcard pattern specified in pathTemplateMatch
         * after removing any query parameters and anchor that may be part
         * of the original URL.
         * pathTemplateMatch must be between 1 and 255 characters
         * (inclusive).  The pattern specified by pathTemplateMatch may
         * have at most 5 wildcard operators and at most 5 variable
         * captures in total.
         */
        pathTemplateMatch?: pulumi.Input<string>;
        /**
         * For satisfying the matchRule condition, the request's path must begin with the
         * specified prefixMatch. prefixMatch must begin with a /. The value must be
         * between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
         * regexMatch must be specified.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of query parameter match criteria, all of which must match
         * corresponding query parameters in the request.
         * Structure is documented below.
         */
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        /**
         * For satisfying the matchRule condition, the path of the request must satisfy the
         * regular expression specified in regexMatch after removing any query parameters
         * and anchor supplied with the original URL. For regular expression grammar please
         * see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
         * fullPathMatch or regexMatch must be specified.
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        /**
         * The value should exactly match contents of exactMatch. Only one of exactMatch,
         * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the HTTP header to match. For matching against the HTTP request's
         * authority, use a headerMatch with the header name ":authority". For matching a
         * request's method, use the headerName ":method".
         */
        headerName: pulumi.Input<string>;
        /**
         * If set to false, the headerMatch is considered a match if the match criteria
         * above are met. If set to true, the headerMatch is considered a match if the
         * match criteria above are NOT met. Defaults to false.
         */
        invertMatch?: pulumi.Input<boolean>;
        /**
         * The value of the header must start with the contents of prefixMatch. Only one of
         * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
         * must be set.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * A header with the contents of headerName must exist. The match takes place
         * whether or not the request's header has a value or not. Only one of exactMatch,
         * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The header value must be an integer and its value must be in the range specified
         * in rangeMatch. If the header does not contain an integer, number or is empty,
         * the match fails. For example for a range [-5, 0]
         * * -3 will match
         * * 0 will not match
         * * 0.25 will not match
         * * -3someString will not match.
         * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
         * rangeMatch must be set.
         * Structure is documented below.
         */
        rangeMatch?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        /**
         * The value of the header must match the regular expression specified in
         * regexMatch. For regular expression grammar, please see:
         * en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
         * specified in the HTTP request, use a headerMatch with headerName set to PORT and
         * a regular expression that satisfies the RFC2616 Host header's port specifier.
         * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
         * rangeMatch must be set.
         */
        regexMatch?: pulumi.Input<string>;
        /**
         * The value of the header must end with the contents of suffixMatch. Only one of
         * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
         * must be set.
         */
        suffixMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        /**
         * The end of the range (exclusive).
         */
        rangeEnd: pulumi.Input<number>;
        /**
         * The start of the range (inclusive).
         */
        rangeStart: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        /**
         * The list of label value pairs that must match labels in the provided metadata
         * based on filterMatchCriteria  This list must not be empty and can have at the
         * most 64 entries.
         * Structure is documented below.
         */
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        /**
         * Specifies how individual filterLabel matches within the list of filterLabels
         * contribute towards the overall metadataFilter match. Supported values are:
         * * MATCH_ANY: At least one of the filterLabels must have a matching label in the
         * provided metadata.
         * * MATCH_ALL: All filterLabels must have matching labels in
         * the provided metadata.
         * Possible values are: `MATCH_ALL`, `MATCH_ANY`.
         */
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        /**
         * Name of metadata label. The name can have a maximum length of 1024 characters
         * and must be at least 1 character long.
         */
        name: pulumi.Input<string>;
        /**
         * The value of the label must match the specified value. value can have a maximum
         * length of 1024 characters.
         */
        value: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        /**
         * The queryParameterMatch matches if the value of the parameter exactly matches
         * the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
         * must be set.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the query parameter to match. The query parameter must exist in the
         * request, in the absence of which the request match fails.
         */
        name: pulumi.Input<string>;
        /**
         * Specifies that the queryParameterMatch matches if the request contains the query
         * parameter, irrespective of whether the parameter has a value or not. Only one of
         * presentMatch, exactMatch and regexMatch must be set.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The queryParameterMatch matches if the value of the parameter matches the
         * regular expression specified by regexMatch. For the regular expression grammar,
         * please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
         * exactMatch and regexMatch must be set.
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see W3C
         * Recommendation for Cross Origin Resource Sharing
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the
         * resiliency of clients to backend service failure. As part of fault injection,
         * when clients send requests to a backend service, delays can be introduced by
         * Loadbalancer on a percentage of requests before sending those request to the
         * backend service. Similarly requests from clients can be aborted by the
         * Loadbalancer for a percentage of requests. timeout and retryPolicy will be
         * ignored by clients that are configured with a fault_injection_policy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the policy on how requests intended for the route's backends are
         * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
         * responses from the shadow service. Prior to sending traffic to the shadow
         * service, the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time
         * the request is has been fully processed (i.e. end-of-stream) up until the
         * response has been completely processed. Timeout includes all retries. If not
         * specified, the default value is 15 seconds.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to
         * the matched service
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match
         * occurs. The weights determine the fraction of traffic that flows to their
         * corresponding backend service. If all traffic needs to go to a single backend
         * service, there must be one  weightedBackendService with weight set to a non 0
         * number. Once a backendService is identified and before forwarding the request to
         * the backend service, advanced routing actions like Url rewrites and header
         * transformations are applied depending on additional settings specified in this
         * HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
         * Default is false.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the RegionBackendService resource being mirrored to.
         * The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map.
         * Serverless NEG backends are not currently supported as a mirrored backend service.
         */
        backendService: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specifies one or more conditions when this retry policy applies.
         * Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
         * - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
         * - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
         * - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
         * - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
         * - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
         * - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
         * - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
         * - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
         * - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        /**
         * Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
         * The value must be from 1 to 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
         * The value must be from 1 to 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected origin, if the
         * request matched a pathTemplateMatch, the matching portion of the
         * request's path is replaced re-written using the pattern specified
         * by pathTemplateRewrite.
         * pathTemplateRewrite must be between 1 and 255 characters
         * (inclusive), must start with a '/', and must only use variables
         * captured by the route's pathTemplate matchers.
         * pathTemplateRewrite may only be used when all of a route's
         * MatchRules specify pathTemplate.
         * Only one of pathPrefixRewrite and pathTemplateRewrite may be
         * specified.
         */
        pathTemplateRewrite?: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
         */
        backendService: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
         * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
         * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
         * The value must be from 0 to 1000.
         */
        weight: pulumi.Input<number>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request before forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response before sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response before sending the response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
         * The default value is false.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one
         * that was supplied in the request. The value must be between 1 and 255
         * characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https.
         * If set to false, the URL scheme of the redirected request will remain the
         * same as that of the request. This must only be set for UrlMaps used in
         * TargetHttpProxys. Setting this true for TargetHttpsProxy is not
         * permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one
         * that was supplied in the request. pathRedirect cannot be supplied
         * together with prefixRedirect. Supply one alone or neither. If neither is
         * supplied, the path of the original request will be used for the redirect.
         * The value must be between 1 and 1024 characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the
         * HttpRouteRuleMatch, retaining the remaining portion of the URL before
         * redirecting the request. prefixRedirect cannot be supplied together with
         * pathRedirect. Supply one alone or neither. If neither is supplied, the
         * path of the original request will be used for the redirect. The value
         * must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed
         * prior to redirecting the request. If set to false, the query portion of the
         * original URL is retained.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface RegionUrlMapTest {
        /**
         * Description of this test case.
         */
        description?: pulumi.Input<string>;
        /**
         * Host portion of the URL.
         */
        host: pulumi.Input<string>;
        /**
         * Path portion of the URL.
         */
        path: pulumi.Input<string>;
        /**
         * A reference to expected RegionBackendService resource the given URL should be mapped to.
         */
        service: pulumi.Input<string>;
    }

    export interface ReservationShareSettings {
        /**
         * A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
         * Structure is documented below.
         */
        projectMaps?: pulumi.Input<pulumi.Input<inputs.compute.ReservationShareSettingsProjectMap>[]>;
        /**
         * Type of sharing for this shared-reservation
         * Possible values are: `LOCAL`, `SPECIFIC_PROJECTS`.
         */
        shareType?: pulumi.Input<string>;
    }

    export interface ReservationShareSettingsProjectMap {
        /**
         * The identifier for this object. Format specified above.
         */
        id: pulumi.Input<string>;
        /**
         * The project id/number, should be same as the key of this project config in the project map.
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservation {
        /**
         * The number of resources that are allocated.
         */
        count: pulumi.Input<number>;
        /**
         * (Output)
         * How many instances are in use.
         */
        inUseCount?: pulumi.Input<number>;
        /**
         * The instance properties for the reservation.
         * Structure is documented below.
         */
        instanceProperties: pulumi.Input<inputs.compute.ReservationSpecificReservationInstanceProperties>;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        /**
         * Guest accelerator type and count.
         * Structure is documented below.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator>[]>;
        /**
         * The amount of local ssd to reserve with each instance. This
         * reserves disks of type `local-ssd`.
         * Structure is documented below.
         */
        localSsds?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd>[]>;
        /**
         * The name of the machine type to reserve.
         */
        machineType: pulumi.Input<string>;
        /**
         * The minimum CPU platform for the reservation. For example,
         * `"Intel Skylake"`. See
         * the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
         * for information on available CPU platforms.
         */
        minCpuPlatform?: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to
         * this instance.
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The full or partial URL of the accelerator type to
         * attach to this instance. For example:
         * `projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100`
         * If you are creating an instance template, specify only the accelerator name.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        /**
         * The size of the disk in base-2 GB.
         *
         * - - -
         */
        diskSizeGb: pulumi.Input<number>;
        /**
         * The disk interface to use for attaching this disk.
         * Default value is `SCSI`.
         * Possible values are: `SCSI`, `NVME`.
         */
        interface?: pulumi.Input<string>;
    }

    export interface ResizeRequestRequestedRunDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 600 to 604800 inclusive. Note: minimum and maximum allowed range for requestedRunDuration is 10 minutes (600 seconds) and 7 days(604800 seconds) correspondingly.
         */
        seconds: pulumi.Input<string>;
    }

    export interface ResizeRequestStatus {
        /**
         * (Output)
         * Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusError>[]>;
        /**
         * (Output)
         * Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.
         * Structure is documented below.
         */
        lastAttempts?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttempt>[]>;
    }

    export interface ResizeRequestStatusError {
        /**
         * (Output)
         * The array of errors encountered while processing this operation.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorError>[]>;
    }

    export interface ResizeRequestStatusErrorError {
        /**
         * (Output)
         * The error type identifier for this error.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
         * Structure is documented below.
         */
        errorDetails?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetail>[]>;
        /**
         * (Output)
         * Indicates the field in the request that caused the error. This property is optional.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetail {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        errorInfos?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetailErrorInfo>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        helps?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetailHelp>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        localizedMessages?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        quotaInfos?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetailQuotaInfo>[]>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetailErrorInfo {
        /**
         * (Output)
         * The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
         */
        domain?: pulumi.Input<string>;
        /**
         * (Output)
         * Additional structured details about this error.
         */
        metadatas?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
         */
        reason?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetailHelp {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        links?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusErrorErrorErrorDetailHelpLink>[]>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetailHelpLink {
        /**
         * An optional description of this resize-request.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL of the link.
         */
        url?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetailLocalizedMessage {
        /**
         * (Output)
         * The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
         */
        locale?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusErrorErrorErrorDetailQuotaInfo {
        /**
         * (Output)
         * The map holding related quota dimensions
         */
        dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
         */
        futureLimit?: pulumi.Input<number>;
        /**
         * (Output)
         * Current effective quota limit. The limit's unit depends on the quota type or metric.
         */
        limit?: pulumi.Input<number>;
        /**
         * (Output)
         * The name of the quota limit.
         */
        limitName?: pulumi.Input<string>;
        /**
         * (Output)
         * The Compute Engine quota metric name.
         */
        metricName?: pulumi.Input<string>;
        /**
         * (Output)
         * Rollout status of the future quota limit.
         */
        rolloutStatus?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusLastAttempt {
        /**
         * (Output)
         * Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptError>[]>;
    }

    export interface ResizeRequestStatusLastAttemptError {
        /**
         * (Output)
         * The array of errors encountered while processing this operation.
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorError>[]>;
    }

    export interface ResizeRequestStatusLastAttemptErrorError {
        /**
         * (Output)
         * The error type identifier for this error.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * An array of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
         * Structure is documented below.
         */
        errorDetails?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetail>[]>;
        /**
         * (Output)
         * Indicates the field in the request that caused the error. This property is optional.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetail {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        errorInfos?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        helps?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        localizedMessages?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage>[]>;
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        quotaInfos?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo>[]>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetailErrorInfo {
        /**
         * (Output)
         * The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com".
         */
        domain?: pulumi.Input<string>;
        /**
         * (Output)
         * Additional structured details about this error.
         */
        metadatas?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors.
         */
        reason?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelp {
        /**
         * (Output)
         * A nested object resource.
         * Structure is documented below.
         */
        links?: pulumi.Input<pulumi.Input<inputs.compute.ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink>[]>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetailHelpLink {
        /**
         * An optional description of this resize-request.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL of the link.
         */
        url?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetailLocalizedMessage {
        /**
         * (Output)
         * The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
         */
        locale?: pulumi.Input<string>;
        /**
         * (Output)
         * The localized error message in the above locale.
         */
        message?: pulumi.Input<string>;
    }

    export interface ResizeRequestStatusLastAttemptErrorErrorErrorDetailQuotaInfo {
        /**
         * (Output)
         * The map holding related quota dimensions
         */
        dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
         */
        futureLimit?: pulumi.Input<number>;
        /**
         * (Output)
         * Current effective quota limit. The limit's unit depends on the quota type or metric.
         */
        limit?: pulumi.Input<number>;
        /**
         * (Output)
         * The name of the quota limit.
         */
        limitName?: pulumi.Input<string>;
        /**
         * (Output)
         * The Compute Engine quota metric name.
         */
        metricName?: pulumi.Input<string>;
        /**
         * (Output)
         * Rollout status of the future quota limit.
         */
        rolloutStatus?: pulumi.Input<string>;
    }

    export interface ResourcePolicyDiskConsistencyGroupPolicy {
        /**
         * Enable disk consistency on the resource policy.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ResourcePolicyGroupPlacementPolicy {
        /**
         * The number of availability domains instances will be spread across. If two instances are in different
         * availability domain, they will not be put in the same low latency network
         */
        availabilityDomainCount?: pulumi.Input<number>;
        /**
         * Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
         * Specify `COLLOCATED` to enable collocation. Can only be specified with `vmCount`. If compute instances are created
         * with a COLLOCATED policy, then exactly `vmCount` instances must be created at the same time with the resource policy
         * attached.
         * Possible values are: `COLLOCATED`.
         */
        collocation?: pulumi.Input<string>;
        /**
         * Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.
         */
        gpuTopology?: pulumi.Input<string>;
        /**
         * Specifies the number of max logical switches.
         */
        maxDistance?: pulumi.Input<number>;
        /**
         * Specifies the shape of the TPU slice.
         */
        tpuTopology?: pulumi.Input<string>;
        /**
         * Number of VMs in this placement group. Google does not recommend that you use this field
         * unless you use a compact policy and you want your policy to work only if it contains this
         * exact number of VMs.
         */
        vmCount?: pulumi.Input<number>;
    }

    export interface ResourcePolicyInstanceSchedulePolicy {
        /**
         * The expiration time of the schedule. The timestamp is an RFC3339 string.
         */
        expirationTime?: pulumi.Input<string>;
        /**
         * The start time of the schedule. The timestamp is an RFC3339 string.
         */
        startTime?: pulumi.Input<string>;
        /**
         * Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
         * from the tz database: http://en.wikipedia.org/wiki/Tz_database.
         */
        timeZone: pulumi.Input<string>;
        /**
         * Specifies the schedule for starting instances.
         * Structure is documented below.
         */
        vmStartSchedule?: pulumi.Input<inputs.compute.ResourcePolicyInstanceSchedulePolicyVmStartSchedule>;
        /**
         * Specifies the schedule for stopping instances.
         * Structure is documented below.
         */
        vmStopSchedule?: pulumi.Input<inputs.compute.ResourcePolicyInstanceSchedulePolicyVmStopSchedule>;
    }

    export interface ResourcePolicyInstanceSchedulePolicyVmStartSchedule {
        /**
         * Specifies the frequency for the operation, using the unix-cron format.
         */
        schedule: pulumi.Input<string>;
    }

    export interface ResourcePolicyInstanceSchedulePolicyVmStopSchedule {
        /**
         * Specifies the frequency for the operation, using the unix-cron format.
         */
        schedule: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        /**
         * Retention policy applied to snapshots created by this resource policy.
         * Structure is documented below.
         */
        retentionPolicy?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy>;
        /**
         * Contains one of an `hourlySchedule`, `dailySchedule`, or `weeklySchedule`.
         * Structure is documented below.
         */
        schedule: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySchedule>;
        /**
         * Properties with which the snapshots are created, such as labels.
         * Structure is documented below.
         */
        snapshotProperties?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        /**
         * Maximum age of the snapshot that is allowed to be kept.
         */
        maxRetentionDays: pulumi.Input<number>;
        /**
         * Specifies the behavior to apply to scheduled snapshots when
         * the source disk is deleted.
         * Default value is `KEEP_AUTO_SNAPSHOTS`.
         * Possible values are: `KEEP_AUTO_SNAPSHOTS`, `APPLY_RETENTION_POLICY`.
         */
        onSourceDiskDelete?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        /**
         * The policy will execute every nth day at the specified time.
         * Structure is documented below.
         */
        dailySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule>;
        /**
         * The policy will execute every nth hour starting at the specified time.
         * Structure is documented below.
         */
        hourlySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule>;
        /**
         * Allows specifying a snapshot time for each day of the week.
         * Structure is documented below.
         */
        weeklySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        /**
         * Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
         */
        daysInCycle: pulumi.Input<number>;
        /**
         * This must be in UTC format that resolves to one of
         * 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
         * both 13:00-5 and 08:00 are valid.
         */
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        /**
         * The number of hours between snapshots.
         */
        hoursInCycle: pulumi.Input<number>;
        /**
         * Time within the window to start the operations.
         * It must be in an hourly format "HH:MM",
         * where HH : [00-23] and MM : [00] GMT. eg: 21:00
         */
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        /**
         * May contain up to seven (one for each day of the week) snapshot times.
         * Structure is documented below.
         */
        dayOfWeeks: pulumi.Input<pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek>[]>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        /**
         * The day of the week to create the snapshot. e.g. MONDAY
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * Time within the window to start the operations.
         * It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
         */
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        /**
         * Creates the new snapshot in the snapshot chain labeled with the
         * specified name. The chain name must be 1-63 characters long and comply
         * with RFC1035.
         */
        chainName?: pulumi.Input<string>;
        /**
         * Whether to perform a 'guest aware' snapshot.
         */
        guestFlush?: pulumi.Input<boolean>;
        /**
         * A set of key-value pairs.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Cloud Storage bucket location to store the auto snapshot
         * (regional or multi-regional)
         */
        storageLocations?: pulumi.Input<string>;
    }

    export interface ResourcePolicyWorkloadPolicy {
        /**
         * The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
         * and cannot be set if max topology distance is set.
         */
        acceleratorTopology?: pulumi.Input<string>;
        /**
         * The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
         * and cannot be set if accelerator topology is set.
         * Possible values are: `BLOCK`, `CLUSTER`, `SUBBLOCK`.
         */
        maxTopologyDistance?: pulumi.Input<string>;
        /**
         * The type of workload policy.
         * Possible values are: `HIGH_AVAILABILITY`, `HIGH_THROUGHPUT`.
         */
        type: pulumi.Input<string>;
    }

    export interface RouteAsPath {
        /**
         * (Output)
         * The AS numbers of the AS Path.
         */
        asLists?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * (Output)
         * The type of the AS Path, which can be one of the following values:
         * - 'AS_SET': unordered set of autonomous systems that the route in has traversed
         * - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed
         * - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed
         * - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed
         */
        pathSegmentType?: pulumi.Input<string>;
    }

    export interface RouteWarning {
        /**
         * (Output)
         * A warning code, if applicable. For example, Compute Engine returns
         * NO_RESULTS_ON_PAGE if there are no results in the response.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * Metadata about this warning in key: value format. For example:
         * "data":   {  "key": "scope",  "value": "zones/us-east1-d"  }
         * Structure is [documented below.
         */
        datas?: pulumi.Input<pulumi.Input<inputs.compute.RouteWarningData>[]>;
        /**
         * (Output)
         * A human-readable description of the warning code.
         */
        message?: pulumi.Input<string>;
    }

    export interface RouteWarningData {
        /**
         * (Output)
         * A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
         */
        key?: pulumi.Input<string>;
        /**
         * (Output)
         * A warning data value corresponding to the key.
         */
        value?: pulumi.Input<string>;
    }

    export interface RouterBgp {
        /**
         * User-specified flag to indicate which mode to use for advertisement.
         * Default value is `DEFAULT`.
         * Possible values are: `DEFAULT`, `CUSTOM`.
         */
        advertiseMode?: pulumi.Input<string>;
        /**
         * User-specified list of prefix groups to advertise in custom mode.
         * This field can only be populated if advertiseMode is CUSTOM and
         * is advertised to all peers of the router. These groups will be
         * advertised in addition to any specified prefixes. Leave this field
         * blank to advertise no custom groups.
         * This enum field has the one valid value: ALL_SUBNETS
         */
        advertisedGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * User-specified list of individual IP ranges to advertise in
         * custom mode. This field can only be populated if advertiseMode
         * is CUSTOM and is advertised to all peers of the router. These IP
         * ranges will be advertised in addition to any specified groups.
         * Leave this field blank to advertise no custom IP ranges.
         * Structure is documented below.
         */
        advertisedIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.RouterBgpAdvertisedIpRange>[]>;
        /**
         * Local BGP Autonomous System Number (ASN). Must be an RFC6996
         * private ASN, either 16-bit or 32-bit. The value will be fixed for
         * this router resource. All VPN tunnels that link to this router
         * will have the same local ASN.
         */
        asn: pulumi.Input<number>;
        /**
         * Explicitly specifies a range of valid BGP Identifiers for this Router.
         * It is provided as a link-local IPv4 range (from 169.254.0.0/16), of
         * size at least /30, even if the BGP sessions are over IPv6. It must
         * not overlap with any IPv4 BGP session ranges. Other vendors commonly
         * call this router ID.
         */
        identifierRange?: pulumi.Input<string>;
        /**
         * The interval in seconds between BGP keepalive messages that are sent
         * to the peer. Hold time is three times the interval at which keepalive
         * messages are sent, and the hold time is the maximum number of seconds
         * allowed to elapse between successive keepalive messages that BGP
         * receives from a peer.
         * BGP will use the smaller of either the local hold time value or the
         * peer's hold time value as the hold time for the BGP connection
         * between the two peers. If set, this value must be between 20 and 60.
         * The default is 20.
         */
        keepaliveInterval?: pulumi.Input<number>;
    }

    export interface RouterBgpAdvertisedIpRange {
        /**
         * User-specified description for the IP range.
         *
         * <a name="nestedMd5AuthenticationKeys"></a>The `md5AuthenticationKeys` block supports:
         */
        description?: pulumi.Input<string>;
        /**
         * The IP range to advertise. The value must be a
         * CIDR-formatted string.
         */
        range: pulumi.Input<string>;
    }

    export interface RouterMd5AuthenticationKeys {
        /**
         * Value of the key used for MD5 authentication.
         */
        key: pulumi.Input<string>;
        /**
         * Name of the resource. The name must be 1-63 characters long, and
         * comply with RFC1035. Specifically, the name must be 1-63 characters
         * long and match the regular expression `a-z?`
         * which means the first character must be a lowercase letter, and all
         * following characters must be a dash, lowercase letter, or digit,
         * except the last character, which cannot be a dash.
         */
        name: pulumi.Input<string>;
    }

    export interface RouterNatLogConfig {
        /**
         * Indicates whether or not to export logs.
         */
        enable: pulumi.Input<boolean>;
        /**
         * Specifies the desired filtering of logs on this NAT.
         * Possible values are: `ERRORS_ONLY`, `TRANSLATIONS_ONLY`, `ALL`.
         */
        filter: pulumi.Input<string>;
    }

    export interface RouterNatRule {
        /**
         * The action to be enforced for traffic that matches this rule.
         * Structure is documented below.
         */
        action?: pulumi.Input<inputs.compute.RouterNatRuleAction>;
        /**
         * An optional description of this rule.
         */
        description?: pulumi.Input<string>;
        /**
         * CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
         * If it evaluates to true, the corresponding action is enforced.
         * The following examples are valid match expressions for public NAT:
         * "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"
         * "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"
         * The following example is a valid match expression for private NAT:
         * "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'"
         */
        match: pulumi.Input<string>;
        /**
         * An integer uniquely identifying a rule in the list.
         * The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
         */
        ruleNumber: pulumi.Input<number>;
    }

    export interface RouterNatRuleAction {
        /**
         * A list of URLs of the IP resources used for this NAT rule.
         * These IP addresses must be valid static external IP addresses assigned to the project.
         * This field is used for public NAT.
         */
        sourceNatActiveIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of URLs of the subnetworks used as source ranges for this NAT Rule.
         * These subnetworks must have purpose set to PRIVATE_NAT.
         * This field is used for private NAT.
         */
        sourceNatActiveRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of URLs of the IP resources to be drained.
         * These IPs must be valid static external IPs that have been assigned to the NAT.
         * These IPs should be used for updating/patching a NAT rule only.
         * This field is used for public NAT.
         */
        sourceNatDrainIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of URLs of subnetworks representing source ranges to be drained.
         * This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule.
         * This field is used for private NAT.
         */
        sourceNatDrainRanges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouterNatSubnetwork {
        /**
         * Self-link of subnetwork to NAT
         */
        name: pulumi.Input<string>;
        /**
         * List of the secondary ranges of the subnetwork that are allowed
         * to use NAT. This can be populated only if
         * `LIST_OF_SECONDARY_IP_RANGES` is one of the values in
         * sourceIpRangesToNat
         */
        secondaryIpRangeNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of options for which source IPs in the subnetwork
         * should have NAT enabled. Supported values include:
         * `ALL_IP_RANGES`, `LIST_OF_SECONDARY_IP_RANGES`,
         * `PRIMARY_IP_RANGE`.
         */
        sourceIpRangesToNats: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouterPeerAdvertisedIpRange {
        /**
         * User-specified description for the IP range.
         */
        description?: pulumi.Input<string>;
        /**
         * The IP range to advertise. The value must be a
         * CIDR-formatted string.
         */
        range: pulumi.Input<string>;
    }

    export interface RouterPeerBfd {
        /**
         * The minimum interval, in milliseconds, between BFD control packets
         * received from the peer router. The actual value is negotiated
         * between the two routers and is equal to the greater of this value
         * and the transmit interval of the other router. If set, this value
         * must be between 1000 and 30000.
         */
        minReceiveInterval?: pulumi.Input<number>;
        /**
         * The minimum interval, in milliseconds, between BFD control packets
         * transmitted to the peer router. The actual value is negotiated
         * between the two routers and is equal to the greater of this value
         * and the corresponding receive interval of the other router. If set,
         * this value must be between 1000 and 30000.
         */
        minTransmitInterval?: pulumi.Input<number>;
        /**
         * The number of consecutive BFD packets that must be missed before
         * BFD declares that a peer is unavailable. If set, the value must
         * be a value between 5 and 16.
         *
         * <a name="nestedMd5AuthenticationKey"></a>The `md5AuthenticationKey` block supports:
         */
        multiplier?: pulumi.Input<number>;
        /**
         * The BFD session initialization mode for this BGP peer.
         * If set to `ACTIVE`, the Cloud Router will initiate the BFD session
         * for this BGP peer. If set to `PASSIVE`, the Cloud Router will wait
         * for the peer router to initiate the BFD session for this BGP peer.
         * If set to `DISABLED`, BFD is disabled for this BGP peer.
         * Possible values are: `ACTIVE`, `DISABLED`, `PASSIVE`.
         */
        sessionInitializationMode: pulumi.Input<string>;
    }

    export interface RouterPeerCustomLearnedIpRange {
        /**
         * The IP range to learn. The value must be a
         * CIDR-formatted string.
         */
        range: pulumi.Input<string>;
    }

    export interface RouterPeerMd5AuthenticationKey {
        /**
         * Value of the key.
         */
        key: pulumi.Input<string>;
        /**
         * Name of this BGP peer. The name must be 1-63 characters long,
         * and comply with RFC1035. Specifically, the name must be 1-63 characters
         * long and match the regular expression `a-z?` which
         * means the first character must be a lowercase letter, and all
         * following characters must be a dash, lowercase letter, or digit,
         * except the last character, which cannot be a dash.
         */
        name: pulumi.Input<string>;
    }

    export interface RouterRoutePolicyTerm {
        /**
         * 'CEL expressions to evaluate to modify a route when this term matches.'\
         * Structure is documented below.
         */
        actions?: pulumi.Input<pulumi.Input<inputs.compute.RouterRoutePolicyTermAction>[]>;
        /**
         * CEL expression evaluated against a route to determine if this term applies (see Policy Language). When not set, the term applies to all routes.
         * Structure is documented below.
         */
        match?: pulumi.Input<inputs.compute.RouterRoutePolicyTermMatch>;
        /**
         * The evaluation priority for this term, which must be between 0 (inclusive) and 231 (exclusive), and unique within the list.
         */
        priority: pulumi.Input<number>;
    }

    export interface RouterRoutePolicyTermAction {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression
         * Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error
         * reporting, e.g. a file name and a position in the file
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its
         * purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface RouterRoutePolicyTermMatch {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface SecurityPolicyAdaptiveProtectionConfig {
        /**
         * Configuration for [Automatically deploy Adaptive Protection suggested rules](https://cloud.google.com/armor/docs/adaptive-protection-auto-deploy?hl=en). Structure is documented below.
         *
         * <a name="nestedLayer7DdosDefenseConfig"></a>The `layer7DdosDefenseConfig` block supports:
         */
        autoDeployConfig?: pulumi.Input<inputs.compute.SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig>;
        /**
         * Configuration for [Google Cloud Armor Adaptive Protection Layer 7 DDoS Defense](https://cloud.google.com/armor/docs/adaptive-protection-overview?hl=en). Structure is documented below.
         */
        layer7DdosDefenseConfig?: pulumi.Input<inputs.compute.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig>;
    }

    export interface SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig {
        /**
         * Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
         */
        confidenceThreshold?: pulumi.Input<number>;
        /**
         * Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
         */
        expirationSec?: pulumi.Input<number>;
        /**
         * Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
         */
        impactedBaselineThreshold?: pulumi.Input<number>;
        /**
         * Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
         */
        loadThreshold?: pulumi.Input<number>;
    }

    export interface SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig {
        /**
         * If set to true, enables CAAP for L7 DDoS detection.
         */
        enable?: pulumi.Input<boolean>;
        /**
         * Rule visibility. Supported values include: "STANDARD", "PREMIUM".
         */
        ruleVisibility?: pulumi.Input<string>;
        /**
         * Configuration options for layer7 adaptive protection for various customizable thresholds.
         */
        thresholdConfigs?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig>[]>;
    }

    export interface SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig {
        /**
         * Confidence threshold above which Adaptive Protection's auto-deploy takes actions.
         */
        autoDeployConfidenceThreshold?: pulumi.Input<number>;
        /**
         * Duration over which Adaptive Protection's auto-deployed actions last.
         */
        autoDeployExpirationSec?: pulumi.Input<number>;
        /**
         * Impacted baseline threshold below which Adaptive Protection's auto-deploy takes actions.
         */
        autoDeployImpactedBaselineThreshold?: pulumi.Input<number>;
        /**
         * Load threshold above which Adaptive Protection automatically deploy threshold based on the backend load threshold and detect a new rule during an alerted attack.
         */
        autoDeployLoadThreshold?: pulumi.Input<number>;
        /**
         * Detection threshold based on absolute QPS.
         */
        detectionAbsoluteQps?: pulumi.Input<number>;
        /**
         * Detection threshold based on the backend service's load.
         */
        detectionLoadThreshold?: pulumi.Input<number>;
        /**
         * Detection threshold based on QPS relative to the average of baseline traffic.
         */
        detectionRelativeToBaselineQps?: pulumi.Input<number>;
        /**
         * The name of config. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the security policy.
         */
        name: pulumi.Input<string>;
        /**
         * Configuration options for enabling Adaptive Protection to work on the specified service granularity. Structure is documented below.
         */
        trafficGranularityConfigs?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig>[]>;
    }

    export interface SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig {
        /**
         * If enabled, traffic matching each unique value for the specified type constitutes a separate traffic unit. It can only be set to true if value is empty.
         */
        enableEachUniqueValue?: pulumi.Input<boolean>;
        /**
         * The type of this configuration, a granular traffic unit can be one of the following:
         * * `HTTP_HEADER_HOST`
         * * `HTTP_PATH`
         */
        type: pulumi.Input<string>;
        /**
         * Requests that match this value constitute a granular traffic unit.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityPolicyAdvancedOptionsConfig {
        /**
         * Custom configuration to apply the JSON parsing. Only applicable when
         * `jsonParsing` is set to `STANDARD`. Structure is documented below.
         */
        jsonCustomConfig?: pulumi.Input<inputs.compute.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig>;
        /**
         * Whether or not to JSON parse the payload body. Defaults to `DISABLED`.
         * * `DISABLED` - Don't parse JSON payloads in POST bodies.
         * * `STANDARD` - Parse JSON payloads in POST bodies.
         * * `STANDARD_WITH_GRAPHQL` - Parse JSON and GraphQL payloads in POST bodies.
         */
        jsonParsing?: pulumi.Input<string>;
        /**
         * Log level to use. Defaults to `NORMAL`.
         * * `NORMAL` - Normal log level.
         * * `VERBOSE` - Verbose log level.
         */
        logLevel?: pulumi.Input<string>;
        /**
         * An optional list of case-insensitive request header names to use for resolving the callers client IP address.
         */
        userIpRequestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
        /**
         * A list of custom Content-Type header values to apply the JSON parsing. The
         * format of the Content-Type header values is defined in
         * [RFC 1341](https://www.ietf.org/rfc/rfc1341.txt). When configuring a custom Content-Type header
         * value, only the type/subtype needs to be specified, and the parameters should be excluded.
         */
        contentTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyRecaptchaOptionsConfig {
        /**
         * A field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of `GOOGLE_RECAPTCHA` under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used.
         */
        redirectSiteKey: pulumi.Input<string>;
    }

    export interface SecurityPolicyRule {
        /**
         * Action to take when `match` matches the request. Valid values:
         */
        action: pulumi.Input<string>;
        /**
         * An optional description of this rule. Max size is 64.
         */
        description?: pulumi.Input<string>;
        /**
         * Additional actions that are performed on headers. Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.SecurityPolicyRuleHeaderAction>;
        /**
         * A match condition that incoming traffic is evaluated against.
         * If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
         */
        match: pulumi.Input<inputs.compute.SecurityPolicyRuleMatch>;
        /**
         * Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if `evaluatePreconfiguredWaf()` is not used, this field will have no effect. Structure is documented below.
         */
        preconfiguredWafConfig?: pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfig>;
        /**
         * When set to true, the `action` specified above is not enforced.
         * Stackdriver logs for requests that trigger a preview action are annotated as such.
         */
        preview?: pulumi.Input<boolean>;
        /**
         * An unique positive integer indicating the priority of evaluation for a rule.
         * Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
         */
        priority: pulumi.Input<number>;
        /**
         * Must be specified if the `action` is `rateBasedBan` or `throttle`. Cannot be specified for other actions. Structure is documented below.
         */
        rateLimitOptions?: pulumi.Input<inputs.compute.SecurityPolicyRuleRateLimitOptions>;
        /**
         * Can be specified if the `action` is `redirect`. Cannot be specified for other actions. Structure is documented below.
         */
        redirectOptions?: pulumi.Input<inputs.compute.SecurityPolicyRuleRedirectOptions>;
    }

    export interface SecurityPolicyRuleHeaderAction {
        /**
         * The list of request headers to add or overwrite if they're already present.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRuleHeaderActionRequestHeadersToAdd>[]>;
    }

    export interface SecurityPolicyRuleHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to set.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value to set the named header to.
         */
        headerValue?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatch {
        /**
         * The configuration options available when specifying versionedExpr.
         * This field must be specified if versionedExpr is specified and cannot be specified if versionedExpr is not specified.
         * Structure is documented below.
         */
        config?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchConfig>;
        /**
         * User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
         * Structure is documented below.
         */
        expr?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchExpr>;
        /**
         * The configuration options available when specifying a user defined CEVAL expression (i.e., 'expr').
         * Structure is documented below.
         */
        exprOptions?: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchExprOptions>;
        /**
         * Preconfigured versioned expression. If this field is specified, config must also be specified.
         * Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding srcIpRange field in config.
         * Possible values are: `SRC_IPS_V1`.
         */
        versionedExpr?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatchConfig {
        /**
         * CIDR IP address range. Maximum number of srcIpRanges allowed is 10.
         */
        srcIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyRuleMatchExpr {
        /**
         * Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
         */
        expression: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatchExprOptions {
        /**
         * reCAPTCHA configuration options to be applied for the rule. If the rule does not evaluate reCAPTCHA tokens, this field has no effect.
         * Structure is documented below.
         */
        recaptchaOptions: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchExprOptionsRecaptchaOptions>;
    }

    export interface SecurityPolicyRuleMatchExprOptionsRecaptchaOptions {
        /**
         * A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
         */
        actionTokenSiteKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
         */
        sessionTokenSiteKeys?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfig {
        /**
         * An exclusion to apply during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        exclusions?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfigExclusion>[]>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfigExclusion {
        /**
         * Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        requestCookies?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky>[]>;
        /**
         * Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Structure is documented below.
         */
        requestHeaders?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader>[]>;
        /**
         * Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.
         * Note that the parameter can be in the query string or in the POST body.
         * Structure is documented below.
         */
        requestQueryParams?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam>[]>;
        /**
         * Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation.
         * When specifying this field, the query or fragment part should be excluded.
         * Structure is documented below.
         */
        requestUris?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri>[]>;
        /**
         * A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion.
         * If omitted, it refers to all the rule IDs under the WAF rule set.
         */
        targetRuleIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Target WAF rule set to apply the preconfigured WAF exclusion.
         */
        targetRuleSet: pulumi.Input<string>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfigExclusionRequestCooky {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfigExclusionRequestHeader {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfigExclusionRequestQueryParam {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRulePreconfiguredWafConfigExclusionRequestUri {
        /**
         * You can specify an exact match or a partial match by using a field operator and a field value.
         * Available options:
         * EQUALS: The operator matches if the field value equals the specified value.
         * STARTS_WITH: The operator matches if the field value starts with the specified value.
         * ENDS_WITH: The operator matches if the field value ends with the specified value.
         * CONTAINS: The operator matches if the field value contains the specified value.
         * EQUALS_ANY: The operator matches if the field value is any value.
         */
        operator: pulumi.Input<string>;
        /**
         * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation.
         * The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
         */
        value?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleRateLimitOptions {
        /**
         * Can only be specified if the action for the rule is "rateBasedBan".
         * If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
         */
        banDurationSec?: pulumi.Input<number>;
        /**
         * Can only be specified if the action for the rule is "rateBasedBan".
         * If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
         * Structure is documented below.
         */
        banThreshold?: pulumi.Input<inputs.compute.SecurityPolicyRuleRateLimitOptionsBanThreshold>;
        /**
         * Action to take for requests that are under the configured rate limit threshold.
         * Valid option is "allow" only.
         */
        conformAction?: pulumi.Input<string>;
        /**
         * Determines the key to enforce the rateLimitThreshold on. Possible values are:
         * * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured.
         * * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
         * * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
         * * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
         * * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
         * * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
         * * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
         * * REGION_CODE: The country/region from which the request originates.
         * * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
         * * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
         * Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `USER_IP`.
         */
        enforceOnKey?: pulumi.Input<string>;
        /**
         * If specified, any combination of values of enforceOnKeyType/enforceOnKeyName is treated as the key on which ratelimit threshold/action is enforced.
         * You can specify up to 3 enforceOnKeyConfigs.
         * If enforceOnKeyConfigs is specified, enforceOnKey must not be specified.
         * Structure is documented below.
         */
        enforceOnKeyConfigs?: pulumi.Input<pulumi.Input<inputs.compute.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig>[]>;
        /**
         * Rate limit key name applicable only for the following key types:
         * HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
         * HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
         */
        enforceOnKeyName?: pulumi.Input<string>;
        /**
         * Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint.
         * Valid options are deny(STATUS), where valid values for STATUS are 403, 404, 429, and 502.
         */
        exceedAction?: pulumi.Input<string>;
        /**
         * Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
         * Structure is documented below.
         */
        exceedRedirectOptions?: pulumi.Input<inputs.compute.SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions>;
        /**
         * Threshold at which to begin ratelimiting.
         * Structure is documented below.
         */
        rateLimitThreshold?: pulumi.Input<inputs.compute.SecurityPolicyRuleRateLimitOptionsRateLimitThreshold>;
    }

    export interface SecurityPolicyRuleRateLimitOptionsBanThreshold {
        /**
         * Number of HTTP(S) requests for calculating the threshold.
         */
        count?: pulumi.Input<number>;
        /**
         * Interval over which the threshold is computed.
         */
        intervalSec?: pulumi.Input<number>;
    }

    export interface SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
        /**
         * Rate limit key name applicable only for the following key types:
         * HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value.
         * HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
         */
        enforceOnKeyName?: pulumi.Input<string>;
        /**
         * Determines the key to enforce the rateLimitThreshold on. Possible values are:
         * * ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured.
         * * IP: The source IP address of the request is the key. Each IP has this limit enforced separately.
         * * HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL.
         * * XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP.
         * * HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL.
         * * HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes.
         * * SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session.
         * * REGION_CODE: The country/region from which the request originates.
         * * TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
         * * USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP.
         * Possible values are: `ALL`, `IP`, `HTTP_HEADER`, `XFF_IP`, `HTTP_COOKIE`, `HTTP_PATH`, `SNI`, `REGION_CODE`, `TLS_JA3_FINGERPRINT`, `USER_IP`.
         */
        enforceOnKeyType?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleRateLimitOptionsExceedRedirectOptions {
        /**
         * Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
         */
        target?: pulumi.Input<string>;
        /**
         * Type of the redirect action.
         */
        type?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleRateLimitOptionsRateLimitThreshold {
        /**
         * Number of HTTP(S) requests for calculating the threshold.
         */
        count?: pulumi.Input<number>;
        /**
         * Interval over which the threshold is computed.
         */
        intervalSec?: pulumi.Input<number>;
    }

    export interface SecurityPolicyRuleRedirectOptions {
        /**
         * Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
         */
        target?: pulumi.Input<string>;
        /**
         * Type of the redirect action.
         */
        type?: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthentication {
        /**
         * Describes authentication configuration that uses a custom account.
         * Structure is documented below.
         */
        customAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationCustomAccount>;
        /**
         * Describes authentication configuration that uses a Google account.
         * Structure is documented below.
         */
        googleAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationGoogleAccount>;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        /**
         * The login form URL of the website.
         */
        loginUrl: pulumi.Input<string>;
        /**
         * The password of the custom account. The credential is stored encrypted
         * in GCP.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * The user name of the custom account.
         */
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        /**
         * The password of the Google account. The credential is stored encrypted
         * in GCP.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * The user name of the Google account.
         */
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigSchedule {
        /**
         * The duration of time between executions in days
         */
        intervalDurationDays: pulumi.Input<number>;
        /**
         * A timestamp indicates when the next run will be scheduled. The value is refreshed
         * by the server after each run. If unspecified, it will default to current server time,
         * which means the scan will be scheduled to start immediately.
         */
        scheduleTime?: pulumi.Input<string>;
    }

    export interface ServiceAttachmentConnectedEndpoint {
        /**
         * (Output)
         * The url of the consumer network.
         */
        consumerNetwork?: pulumi.Input<string>;
        /**
         * (Output)
         * The URL of the consumer forwarding rule.
         */
        endpoint?: pulumi.Input<string>;
        /**
         * (Output)
         * The number of consumer Network Connectivity Center spokes that the connected Private Service Connect endpoint has propagated to.
         */
        propagatedConnectionCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The PSC connection id of the connected endpoint.
         */
        pscConnectionId?: pulumi.Input<string>;
        /**
         * (Output)
         * The status of the connection from the consumer forwarding rule to
         * this service attachment.
         */
        status?: pulumi.Input<string>;
    }

    export interface ServiceAttachmentConsumerAcceptList {
        /**
         * The number of consumer forwarding rules the consumer project can
         * create.
         */
        connectionLimit: pulumi.Input<number>;
        /**
         * The network that is allowed to connect to this service attachment.
         * Only one of projectIdOrNum and networkUrl may be set.
         */
        networkUrl?: pulumi.Input<string>;
        /**
         * A project that is allowed to connect to this service attachment.
         * Only one of projectIdOrNum and networkUrl may be set.
         */
        projectIdOrNum?: pulumi.Input<string>;
    }

    export interface SnapshotIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SnapshotIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SnapshotSnapshotEncryptionKey {
        /**
         * The name of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an encryption key stored in Google Cloud KMS, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
         * encryption key that protects this resource.
         */
        sha256?: pulumi.Input<string>;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        /**
         * The name of the encryption key that is stored in Google Cloud KMS.
         */
        kmsKeySelfLink?: pulumi.Input<string>;
        /**
         * The service account used for the encryption request for the given KMS key.
         * If absent, the Compute Engine Service Agent service account is used.
         */
        kmsKeyServiceAccount?: pulumi.Input<string>;
        /**
         * Specifies a 256-bit customer-supplied encryption key, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rawKey?: pulumi.Input<string>;
        /**
         * Specifies an encryption key stored in Google Cloud KMS, encoded in
         * RFC 4648 base64 to either encrypt or decrypt this resource.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rsaEncryptedKey?: pulumi.Input<string>;
    }

    export interface StoragePoolIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface StoragePoolIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface StoragePoolResourceStatus {
        /**
         * (Output)
         * Number of disks used.
         */
        diskCount?: pulumi.Input<string>;
        /**
         * (Output)
         * Timestamp of the last successful resize in RFC3339 text format.
         */
        lastResizeTimestamp?: pulumi.Input<string>;
        /**
         * (Output)
         * Maximum allowed aggregate disk size in gigabytes.
         */
        maxTotalProvisionedDiskCapacityGb?: pulumi.Input<string>;
        /**
         * (Output)
         * Space used by data stored in disks within the storage pool (in bytes).
         * This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
         */
        poolUsedCapacityBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
         */
        poolUsedIops?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned throughput in MB/s.
         */
        poolUsedThroughput?: pulumi.Input<string>;
        /**
         * (Output)
         * Amount of data written into the pool, before it is compacted.
         */
        poolUserWrittenBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the capacity provisioned in disks in this storage pool.
         * A disk's provisioned capacity is the same as its total capacity.
         */
        totalProvisionedDiskCapacityGb?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned IOPS.
         */
        totalProvisionedDiskIops?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned throughput in MB/s,
         * minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
         */
        totalProvisionedDiskThroughput?: pulumi.Input<string>;
    }

    export interface StoragePoolStatus {
        /**
         * (Output)
         * Number of disks used.
         */
        diskCount?: pulumi.Input<string>;
        /**
         * (Output)
         * Timestamp of the last successful resize in RFC3339 text format.
         */
        lastResizeTimestamp?: pulumi.Input<string>;
        /**
         * (Output)
         * Maximum allowed aggregate disk size in gigabytes.
         */
        maxTotalProvisionedDiskCapacityGb?: pulumi.Input<string>;
        /**
         * (Output)
         * Space used by data stored in disks within the storage pool (in bytes).
         * This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.
         */
        poolUsedCapacityBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.
         */
        poolUsedIops?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned throughput in MB/s.
         */
        poolUsedThroughput?: pulumi.Input<string>;
        /**
         * (Output)
         * Amount of data written into the pool, before it is compacted.
         */
        poolUserWrittenBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the capacity provisioned in disks in this storage pool.
         * A disk's provisioned capacity is the same as its total capacity.
         */
        totalProvisionedDiskCapacityGb?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned IOPS.
         */
        totalProvisionedDiskIops?: pulumi.Input<string>;
        /**
         * (Output)
         * Sum of all the disks' provisioned throughput in MB/s,
         * minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.
         */
        totalProvisionedDiskThroughput?: pulumi.Input<string>;
    }

    export interface SubnetworkIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SubnetworkIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SubnetworkLogConfig {
        /**
         * Can only be specified if VPC flow logging for this subnetwork is enabled.
         * Toggles the aggregation interval for collecting flow logs. Increasing the
         * interval time will reduce the amount of generated flow logs for long
         * lasting connections. Default is an interval of 5 seconds per connection.
         * Default value is `INTERVAL_5_SEC`.
         * Possible values are: `INTERVAL_5_SEC`, `INTERVAL_30_SEC`, `INTERVAL_1_MIN`, `INTERVAL_5_MIN`, `INTERVAL_10_MIN`, `INTERVAL_15_MIN`.
         */
        aggregationInterval?: pulumi.Input<string>;
        /**
         * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
         * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
         * The default value is 'true', which evaluates to include everything.
         */
        filterExpr?: pulumi.Input<string>;
        /**
         * Can only be specified if VPC flow logging for this subnetwork is enabled.
         * The value of the field must be in [0, 1]. Set the sampling rate of VPC
         * flow logs within the subnetwork where 1.0 means all collected logs are
         * reported and 0.0 means no logs are reported. Default is 0.5 which means
         * half of all collected logs are reported.
         */
        flowSampling?: pulumi.Input<number>;
        /**
         * Can only be specified if VPC flow logging for this subnetwork is enabled.
         * Configures whether metadata fields should be added to the reported VPC
         * flow logs.
         * Default value is `INCLUDE_ALL_METADATA`.
         * Possible values are: `EXCLUDE_ALL_METADATA`, `INCLUDE_ALL_METADATA`, `CUSTOM_METADATA`.
         */
        metadata?: pulumi.Input<string>;
        /**
         * List of metadata fields that should be added to reported logs.
         * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
         */
        metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SubnetworkSecondaryIpRange {
        /**
         * The range of IP addresses belonging to this subnetwork secondary
         * range. Provide this property when you create the subnetwork.
         * Ranges must be unique and non-overlapping with all primary and
         * secondary IP ranges within a network. Only IPv4 is supported.
         * Field is optional when `reservedInternalRange` is defined, otherwise required.
         */
        ipCidrRange?: pulumi.Input<string>;
        /**
         * The name associated with this subnetwork secondary range, used
         * when adding an alias IP range to a VM instance. The name must
         * be 1-63 characters long, and comply with RFC1035. The name
         * must be unique within the subnetwork.
         */
        rangeName: pulumi.Input<string>;
        /**
         * The ID of the reserved internal range. Must be prefixed with `networkconnectivity.googleapis.com`
         * E.g. `networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}`
         */
        reservedInternalRange?: pulumi.Input<string>;
    }

    export interface URLMapDefaultCustomErrorResponsePolicy {
        /**
         * Specifies rules for returning error responses.
         * In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
         * For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
         * If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
         * Structure is documented below.
         */
        errorResponseRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapDefaultCustomErrorResponsePolicyErrorResponseRule>[]>;
        /**
         * The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
         * https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * global/backendBuckets/myBackendBucket
         * If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
         * If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
         */
        errorService?: pulumi.Input<string>;
    }

    export interface URLMapDefaultCustomErrorResponsePolicyErrorResponseRule {
        /**
         * Valid values include:
         * - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
         * - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
         * - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
         * Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
         */
        matchResponseCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP status code returned with the response containing the custom error content.
         * If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
         */
        overrideResponseCode?: pulumi.Input<number>;
        /**
         * The full path to a file within backendBucket. For example: /errors/defaultError.html
         * path must start with a leading slash. path cannot have trailing slashes.
         * If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
         * The value must be from 1 to 1024 characters.
         */
        path?: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see
         * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
         * As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
         * percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
         * by the Loadbalancer for a percentage of requests.
         * timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the maximum duration (timeout) for streams on the selected route.
         * Unlike the `Timeout` field where the timeout duration starts from the time the request
         * has been fully processed (known as end-of-stream), the duration in this field
         * is computed from the beginning of the stream until the response has been processed,
         * including all retries. A stream that does not complete in this duration is closed.
         * Structure is documented below.
         */
        maxStreamDuration?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionMaxStreamDuration>;
        /**
         * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
         * Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
         * the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time the request has been
         * fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
         * If not specified, will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to the matched service.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match occurs.
         * The weights determine the fraction of traffic that flows to their corresponding backend service.
         * If all traffic needs to go to a single backend service, there must be one weightedBackendService
         * with weight set to a non 0 number.
         * Once a backendService is identified and before forwarding the request to the backend service,
         * advanced routing actions like Url rewrites and header transformations are applied depending on
         * additional settings specified in this HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapDefaultRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapDefaultRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         * This translates to the Access-Control-Allow-Credentials header.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regular expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapDefaultRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapDefaultRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapDefaultRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionMaxStreamDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the BackendService resource being mirrored to.
         */
        backendService: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specfies one or more conditions when this retry rule applies. Valid values are:
         * * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
         * or if the backend service does not respond at all, example: disconnects, reset, read timeout,
         * * connection failure, and refused streams.
         * * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * * connect-failure: Loadbalancer will retry on failures connecting to backend services,
         * for example due to connection timeouts.
         * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
         * Currently the only retriable error supported is 409.
         * * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
         * This reset type indicates that it is safe to retry.
         * * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
         * * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
         * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
         * * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapDefaultRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected service, the request's host header is replaced
         * with contents of hostRewrite.
         * The value must be between 1 and 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected backend service, the matching portion of the
         * request's path is replaced by pathPrefixRewrite.
         * The value must be between 1 and 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapDefaultRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the
         * request to backendService, the loadbalancer applies any relevant headerActions
         * specified as part of this backendServiceWeight.
         */
        backendService?: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing
         * HttpRouteRule, PathMatcher and UrlMap.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapDefaultRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to backendService, computed as
         * weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request
         * has been directed to a backendService, subsequent requests will be sent to the same backendService
         * as determined by the BackendService's session affinity policy.
         * The value must be between 0 and 1000
         */
        weight?: pulumi.Input<number>;
    }

    export interface URLMapDefaultRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface URLMapDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface URLMapDefaultUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set to
         * false, the URL scheme of the redirected request will remain the same as that of the
         * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
         * true for TargetHttpsProxy is not permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. pathRedirect cannot be supplied together with
         * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
         * original request will be used for the redirect. The value must be between 1 and 1024
         * characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
         * neither. If neither is supplied, the path of the original request will be used for
         * the redirect. The value must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior
         * to redirecting the request. If set to false, the query portion of the original URL is
         * retained. The default is set to false.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface URLMapHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapHostRule {
        /**
         * An optional description of this resource. Provide this property when you create
         * the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * The list of host patterns to match. They must be valid hostnames, except * will
         * match any string of ([a-z0-9-.]*). In that case, * must be the first character
         * and must be followed in the pattern by either - or ..
         */
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the PathMatcher to use to match the path portion of the URL if the
         * hostRule matches the URL's host portion.
         */
        pathMatcher: pulumi.Input<string>;
    }

    export interface URLMapPathMatcher {
        /**
         * defaultCustomErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
         * This policy takes effect at the PathMatcher level and applies only when no policy has been defined for the error code at lower levels like RouteRule and PathRule within this PathMatcher. If an error code does not have a policy defined in defaultCustomErrorResponsePolicy, then a policy defined for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * For example, consider a UrlMap with the following configuration:
         * UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx and 4xx errors
         * A RouteRule for /coming_soon/ is configured for the error code 404.
         * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in RouteRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * When used in conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take precedence. Only once all retries are exhausted, the defaultCustomErrorResponsePolicy is applied. While attempting a retry, if load balancer is successful in reaching the service, the defaultCustomErrorResponsePolicy is ignored and the response from the service is returned to the client.
         * defaultCustomErrorResponsePolicy is supported only for global external Application Load Balancers.
         * Structure is documented below.
         */
        defaultCustomErrorResponsePolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultCustomErrorResponsePolicy>;
        /**
         * defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
         * advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
         * to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
         * Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
         * Only one of defaultRouteAction or defaultUrlRedirect must be set.
         * Structure is documented below.
         */
        defaultRouteAction?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteAction>;
        /**
         * The backend service or backend bucket to use when none of the given paths match.
         */
        defaultService?: pulumi.Input<string>;
        /**
         * When none of the specified hostRules match, the request is redirected to a URL specified
         * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
         * defaultRouteAction must not be set.
         * Structure is documented below.
         */
        defaultUrlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultUrlRedirect>;
        /**
         * An optional description of this resource. Provide this property when you create
         * the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService. HeaderAction specified here are applied after the
         * matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherHeaderAction>;
        /**
         * The name to which this PathMatcher is referred by the HostRule.
         */
        name: pulumi.Input<string>;
        /**
         * The list of path rules. Use this list instead of routeRules when routing based
         * on simple path matching is all that's required. The order by which path rules
         * are specified does not matter. Matches are always done on the longest-path-first
         * basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
         * irrespective of the order in which those paths appear in this list. Within a
         * given pathMatcher, only one of pathRules or routeRules must be set.
         * Structure is documented below.
         */
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRule>[]>;
        /**
         * The list of ordered HTTP route rules. Use this list instead of pathRules when
         * advanced route matching and routing actions are desired. The order of specifying
         * routeRules matters: the first rule that matches will cause its specified routing
         * action to take effect. Within a given pathMatcher, only one of pathRules or
         * routeRules must be set. routeRules are not supported in UrlMaps intended for
         * External load balancers.
         * Structure is documented below.
         */
        routeRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRule>[]>;
    }

    export interface URLMapPathMatcherDefaultCustomErrorResponsePolicy {
        /**
         * Specifies rules for returning error responses.
         * In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
         * For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
         * If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
         * Structure is documented below.
         */
        errorResponseRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule>[]>;
        /**
         * The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
         * https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * global/backendBuckets/myBackendBucket
         * If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
         * If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
         */
        errorService?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultCustomErrorResponsePolicyErrorResponseRule {
        /**
         * Valid values include:
         * - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
         * - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
         * - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
         * Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
         */
        matchResponseCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP status code returned with the response containing the custom error content.
         * If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
         */
        overrideResponseCode?: pulumi.Input<number>;
        /**
         * The full path to a file within backendBucket. For example: /errors/defaultError.html
         * path must start with a leading slash. path cannot have trailing slashes.
         * If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
         * The value must be from 1 to 1024 characters.
         */
        path?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see
         * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/)
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
         * As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
         * percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
         * by the Loadbalancer for a percentage of requests.
         * timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the maximum duration (timeout) for streams on the selected route.
         * Unlike the `Timeout` field where the timeout duration starts from the time the request
         * has been fully processed (known as end-of-stream), the duration in this field
         * is computed from the beginning of the stream until the response has been processed,
         * including all retries. A stream that does not complete in this duration is closed.
         * Structure is documented below.
         */
        maxStreamDuration?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionMaxStreamDuration>;
        /**
         * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
         * Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
         * the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time the request has been
         * fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
         * If not specified, will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to the matched service.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match occurs.
         * The weights determine the fraction of traffic that flows to their corresponding backend service.
         * If all traffic needs to go to a single backend service, there must be one weightedBackendService
         * with weight set to a non 0 number.
         * Once a backendService is identified and before forwarding the request to the backend service,
         * advanced routing actions like Url rewrites and header transformations are applied depending on
         * additional settings specified in this HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherDefaultRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         * This translates to the Access-Control-Allow-Credentials header.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regular expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherDefaultRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionMaxStreamDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the BackendService resource being mirrored to.
         */
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specfies one or more conditions when this retry rule applies. Valid values are:
         * * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
         * or if the backend service does not respond at all, example: disconnects, reset, read timeout,
         * * connection failure, and refused streams.
         * * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * * connect-failure: Loadbalancer will retry on failures connecting to backend services,
         * for example due to connection timeouts.
         * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
         * Currently the only retriable error supported is 409.
         * * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
         * This reset type indicates that it is safe to retry.
         * * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
         * * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
         * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
         * * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected service, the request's host header is replaced
         * with contents of hostRewrite.
         * The value must be between 1 and 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected backend service, the matching portion of the
         * request's path is replaced by pathPrefixRewrite.
         * The value must be between 1 and 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherDefaultRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the
         * request to backendService, the loadbalancer applies any relevant headerActions
         * specified as part of this backendServiceWeight.
         */
        backendService?: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing
         * HttpRouteRule, PathMatcher and UrlMap.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to backendService, computed as
         * weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request
         * has been directed to a backendService, subsequent requests will be sent to the same backendService
         * as determined by the BackendService's session affinity policy.
         * The value must be between 0 and 1000
         */
        weight?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherDefaultRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName?: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue?: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherDefaultUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set to
         * false, the URL scheme of the redirected request will remain the same as that of the
         * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
         * true for TargetHttpsProxy is not permitted. The default is set to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. pathRedirect cannot be supplied together with
         * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
         * original request will be used for the redirect. The value must be between 1 and 1024
         * characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
         * neither. If neither is supplied, the path of the original request will be used for
         * the redirect. The value must be between 1 and 1024 characters.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
         * will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
         * the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior
         * to redirecting the request. If set to false, the query portion of the original URL is
         * retained. The default is set to false.
         * This field is required to ensure an empty block is not set. The normal default value is false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRule {
        /**
         * customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
         * If a policy for an error code is not configured for the PathRule, a policy for the error code configured in pathMatcher.defaultCustomErrorResponsePolicy is applied. If one is not specified in pathMatcher.defaultCustomErrorResponsePolicy, the policy configured in UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * For example, consider a UrlMap with the following configuration:
         * UrlMap.defaultCustomErrorResponsePolicy are configured with policies for 5xx and 4xx errors
         * A PathRule for /coming_soon/ is configured for the error code 404.
         * If the request is for www.myotherdomain.com and a 404 is encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404 response is encountered for the request www.example.com/current_events/, the pathMatcher's policy takes effect. If however, the request for www.example.com/coming_soon/ encounters a 404, the policy in PathRule.customErrorResponsePolicy takes effect. If any of the requests in this example encounter a 500 error code, the policy at UrlMap.defaultCustomErrorResponsePolicy takes effect.
         * customErrorResponsePolicy is supported only for global external Application Load Balancers.
         * Structure is documented below.
         */
        customErrorResponsePolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleCustomErrorResponsePolicy>;
        /**
         * The list of path patterns to match. Each must start with / and the only place a
         * \* is allowed is at the end following a /. The string fed to the path matcher
         * does not include any text after the first ? or #, and those chars are not
         * allowed here.
         */
        paths: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * In response to a matching path, the load balancer performs advanced routing
         * actions like URL rewrites, header transformations, etc. prior to forwarding the
         * request to the selected backend. If routeAction specifies any
         * weightedBackendServices, service must not be set. Conversely if service is set,
         * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
         * or urlRedirect must be set.
         * Structure is documented below.
         */
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteAction>;
        /**
         * The backend service or backend bucket to use if any of the given paths match.
         */
        service?: pulumi.Input<string>;
        /**
         * When a path pattern is matched, the request is redirected to a URL specified
         * by urlRedirect. If urlRedirect is specified, service or routeAction must not
         * be set.
         * Structure is documented below.
         */
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherPathRuleCustomErrorResponsePolicy {
        /**
         * Specifies rules for returning error responses.
         * In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
         * For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
         * If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
         * Structure is documented below.
         */
        errorResponseRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule>[]>;
        /**
         * The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
         * https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * global/backendBuckets/myBackendBucket
         * If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
         * If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
         */
        errorService?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleCustomErrorResponsePolicyErrorResponseRule {
        /**
         * Valid values include:
         * - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
         * - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
         * - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
         * Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
         */
        matchResponseCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP status code returned with the response containing the custom error content.
         * If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
         */
        overrideResponseCode?: pulumi.Input<number>;
        /**
         * The full path to a file within backendBucket. For example: /errors/defaultError.html
         * path must start with a leading slash. path cannot have trailing slashes.
         * If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
         * The value must be from 1 to 1024 characters.
         */
        path?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see W3C
         * Recommendation for Cross Origin Resource Sharing
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the
         * resiliency of clients to backend service failure. As part of fault injection,
         * when clients send requests to a backend service, delays can be introduced by
         * Loadbalancer on a percentage of requests before sending those request to the
         * backend service. Similarly requests from clients can be aborted by the
         * Loadbalancer for a percentage of requests. timeout and retryPolicy will be
         * ignored by clients that are configured with a fault_injection_policy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the maximum duration (timeout) for streams on the selected route.
         * Unlike the `Timeout` field where the timeout duration starts from the time the request
         * has been fully processed (known as end-of-stream), the duration in this field
         * is computed from the beginning of the stream until the response has been processed,
         * including all retries. A stream that does not complete in this duration is closed.
         * Structure is documented below.
         */
        maxStreamDuration?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionMaxStreamDuration>;
        /**
         * Specifies the policy on how requests intended for the route's backends are
         * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
         * responses from the shadow service. Prior to sending traffic to the shadow
         * service, the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time
         * the request is has been fully processed (i.e. end-of-stream) up until the
         * response has been completely processed. Timeout includes all retries. If not
         * specified, the default value is 15 seconds.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to
         * the matched service
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match
         * occurs. The weights determine the fraction of traffic that flows to their
         * corresponding backend service. If all traffic needs to go to a single backend
         * service, there must be one  weightedBackendService with weight set to a non 0
         * number. Once a backendService is identified and before forwarding the request to
         * the backend service, advanced routing actions like Url rewrites and header
         * transformations are applied depending on additional settings specified in this
         * HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         * This translates to the Access-Control-Allow-Credentials header.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regular expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         */
        disabled: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionMaxStreamDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the BackendService resource being mirrored to.
         */
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specfies one or more conditions when this retry rule applies. Valid values are:
         * * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
         * or if the backend service does not respond at all, example: disconnects, reset, read timeout,
         * * connection failure, and refused streams.
         * * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * * connect-failure: Loadbalancer will retry on failures connecting to backend services,
         * for example due to connection timeouts.
         * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
         * Currently the only retriable error supported is 409.
         * * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
         * This reset type indicates that it is safe to retry.
         * * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
         * * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
         * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
         * * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected service, the request's host header is replaced
         * with contents of hostRewrite.
         * The value must be between 1 and 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected backend service, the matching portion of the
         * request's path is replaced by pathPrefixRewrite.
         * The value must be between 1 and 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the
         * request to backendService, the loadbalancer applies any relevant headerActions
         * specified as part of this backendServiceWeight.
         */
        backendService: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing
         * HttpRouteRule, PathMatcher and UrlMap.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to backendService, computed as
         * weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request
         * has been directed to a backendService, subsequent requests will be sent to the same backendService
         * as determined by the BackendService's session affinity policy.
         * The value must be between 0 and 1000
         */
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set
         * to false, the URL scheme of the redirected request will remain the same as that
         * of the request. This must only be set for UrlMaps used in TargetHttpProxys.
         * Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. Only one of pathRedirect or prefixRedirect must be
         * specified. The value must be between 1 and 1024 characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed
         * prior to redirecting the request. If set to false, the query portion of the
         * original URL is retained. Defaults to false.
         */
        stripQuery: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRule {
        /**
         * customErrorResponsePolicy specifies how the Load Balancer returns error responses when BackendService or BackendBucket responds with an error.
         * Structure is documented below.
         */
        customErrorResponsePolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleCustomErrorResponsePolicy>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService. The headerAction specified here are applied before
         * the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
         * outeAction.weightedBackendService.backendServiceWeightAction[].headerAction
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderAction>;
        /**
         * The rules for determining a match.
         * Structure is documented below.
         */
        matchRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRule>[]>;
        /**
         * For routeRules within a given pathMatcher, priority determines the order
         * in which load balancer will interpret routeRules. RouteRules are evaluated
         * in order of priority, from the lowest to highest number. The priority of
         * a rule decreases as its number increases (1, 2, 3, N+1). The first rule
         * that matches the request is applied.
         * You cannot configure two or more routeRules with the same priority.
         * Priority for each rule must be set to a number between 0 and
         * 2147483647 inclusive.
         * Priority numbers can have gaps, which enable you to add or remove rules
         * in the future without affecting the rest of the rules. For example,
         * 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
         * you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
         * future without any impact on existing rules.
         */
        priority: pulumi.Input<number>;
        /**
         * In response to a matching matchRule, the load balancer performs advanced routing
         * actions like URL rewrites, header transformations, etc. prior to forwarding the
         * request to the selected backend. If  routeAction specifies any
         * weightedBackendServices, service must not be set. Conversely if service is set,
         * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
         * or urlRedirect must be set.
         * Structure is documented below.
         */
        routeAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteAction>;
        /**
         * The backend service resource to which traffic is
         * directed if this rule is matched. If routeAction is additionally specified,
         * advanced routing actions like URL Rewrites, etc. take effect prior to sending
         * the request to the backend. However, if service is specified, routeAction cannot
         * contain any weightedBackendService s. Conversely, if routeAction specifies any
         * weightedBackendServices, service must not be specified. Only one of urlRedirect,
         * service or routeAction.weightedBackendService must be set.
         */
        service?: pulumi.Input<string>;
        /**
         * When this rule is matched, the request is redirected to a URL specified by
         * urlRedirect. If urlRedirect is specified, service or routeAction must not be
         * set.
         * Structure is documented below.
         */
        urlRedirect?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleUrlRedirect>;
    }

    export interface URLMapPathMatcherRouteRuleCustomErrorResponsePolicy {
        /**
         * Specifies rules for returning error responses.
         * In a given policy, if you specify rules for both a range of error codes as well as rules for specific error codes then rules with specific error codes have a higher priority.
         * For example, assume that you configure a rule for 401 (Un-authorized) code, and another for all 4 series error codes (4XX).
         * If the backend service returns a 401, then the rule for 401 will be applied. However if the backend service returns a 403, the rule for 4xx takes effect.
         * Structure is documented below.
         */
        errorResponseRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule>[]>;
        /**
         * The full or partial URL to the BackendBucket resource that contains the custom error content. Examples are:
         * https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * compute/v1/projects/project/global/backendBuckets/myBackendBucket
         * global/backendBuckets/myBackendBucket
         * If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService.
         * If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured).
         */
        errorService?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleCustomErrorResponsePolicyErrorResponseRule {
        /**
         * Valid values include:
         * - A number between 400 and 599: For example 401 or 503, in which case the load balancer applies the policy if the error code exactly matches this value.
         * - 5xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 500 to 599.
         * - 4xx: Load Balancer will apply the policy if the backend service responds with any response code in the range of 400 to 499.
         * Values must be unique within matchResponseCodes and across all errorResponseRules of CustomErrorResponsePolicy.
         */
        matchResponseCodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP status code returned with the response containing the custom error content.
         * If overrideResponseCode is not supplied, the same response code returned by the original backend bucket or backend service is returned to the client.
         */
        overrideResponseCode?: pulumi.Input<number>;
        /**
         * The full path to a file within backendBucket. For example: /errors/defaultError.html
         * path must start with a leading slash. path cannot have trailing slashes.
         * If the file is not available in backendBucket or the load balancer cannot reach the BackendBucket, a simple Not Found Error is returned to the client.
         * The value must be from 1 to 1024 characters.
         */
        path?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        /**
         * For satisfying the matchRule condition, the path of the request must exactly
         * match the value specified in fullPathMatch after removing any query parameters
         * and anchor that may be part of the original URL. FullPathMatch must be between 1
         * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
         * be specified.
         */
        fullPathMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of header match criteria, all of which must match corresponding
         * headers in the request.
         * Structure is documented below.
         */
        headerMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        /**
         * Specifies that prefixMatch and fullPathMatch matches are case sensitive.
         * Defaults to false.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * Opaque filter criteria used by Loadbalancer to restrict routing configuration to
         * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
         * clients present node metadata. If a match takes place, the relevant routing
         * configuration is made available to those proxies. For each metadataFilter in
         * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
         * filterLabels must match the corresponding label provided in the metadata. If its
         * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
         * with corresponding labels in the provided metadata. metadataFilters specified
         * here can be overrides those specified in ForwardingRule that refers to this
         * UrlMap. metadataFilters only applies to Loadbalancers that have their
         * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
         * Structure is documented below.
         */
        metadataFilters?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter>[]>;
        /**
         * For satisfying the matchRule condition, the path of the request
         * must match the wildcard pattern specified in pathTemplateMatch
         * after removing any query parameters and anchor that may be part
         * of the original URL.
         * pathTemplateMatch must be between 1 and 255 characters
         * (inclusive).  The pattern specified by pathTemplateMatch may
         * have at most 5 wildcard operators and at most 5 variable
         * captures in total.
         */
        pathTemplateMatch?: pulumi.Input<string>;
        /**
         * For satisfying the matchRule condition, the request's path must begin with the
         * specified prefixMatch. prefixMatch must begin with a /. The value must be
         * between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
         * regexMatch must be specified.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of query parameter match criteria, all of which must match
         * corresponding query parameters in the request.
         * Structure is documented below.
         */
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
        /**
         * For satisfying the matchRule condition, the path of the request must satisfy the
         * regular expression specified in regexMatch after removing any query parameters
         * and anchor supplied with the original URL. For regular expression grammar please
         * see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
         * fullPathMatch or regexMatch must be specified.
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        /**
         * The value should exactly match contents of exactMatch. Only one of exactMatch,
         * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the HTTP header to match. For matching against the HTTP request's
         * authority, use a headerMatch with the header name ":authority". For matching a
         * request's method, use the headerName ":method".
         */
        headerName: pulumi.Input<string>;
        /**
         * If set to false, the headerMatch is considered a match if the match criteria
         * above are met. If set to true, the headerMatch is considered a match if the
         * match criteria above are NOT met. Defaults to false.
         */
        invertMatch?: pulumi.Input<boolean>;
        /**
         * The value of the header must start with the contents of prefixMatch. Only one of
         * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
         * must be set.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * A header with the contents of headerName must exist. The match takes place
         * whether or not the request's header has a value or not. Only one of exactMatch,
         * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The header value must be an integer and its value must be in the range specified
         * in rangeMatch. If the header does not contain an integer, number or is empty,
         * the match fails. For example for a range [-5, 0]   - -3 will match.  - 0 will
         * not match.  - 0.25 will not match.  - -3someString will not match.   Only one of
         * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
         * must be set.
         * Structure is documented below.
         */
        rangeMatch?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch>;
        /**
         * The value of the header must match the regular expression specified in
         * regexMatch. For regular expression grammar, please see:
         * en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
         * specified in the HTTP request, use a headerMatch with headerName set to PORT and
         * a regular expression that satisfies the RFC2616 Host header's port specifier.
         * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
         * rangeMatch must be set.
         */
        regexMatch?: pulumi.Input<string>;
        /**
         * The value of the header must end with the contents of suffixMatch. Only one of
         * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
         * must be set.
         */
        suffixMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        /**
         * The end of the range (exclusive).
         */
        rangeEnd: pulumi.Input<number>;
        /**
         * The start of the range (inclusive).
         */
        rangeStart: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        /**
         * The list of label value pairs that must match labels in the provided metadata
         * based on filterMatchCriteria  This list must not be empty and can have at the
         * most 64 entries.
         * Structure is documented below.
         */
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel>[]>;
        /**
         * Specifies how individual filterLabel matches within the list of filterLabels
         * contribute towards the overall metadataFilter match. Supported values are:
         * - MATCH_ANY: At least one of the filterLabels must have a matching label in the
         * provided metadata.
         * - MATCH_ALL: All filterLabels must have matching labels in
         * the provided metadata.
         * Possible values are: `MATCH_ALL`, `MATCH_ANY`.
         */
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        /**
         * Name of metadata label. The name can have a maximum length of 1024 characters
         * and must be at least 1 character long.
         */
        name: pulumi.Input<string>;
        /**
         * The value of the label must match the specified value. value can have a maximum
         * length of 1024 characters.
         */
        value: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        /**
         * The queryParameterMatch matches if the value of the parameter exactly matches
         * the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
         * must be set.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the query parameter to match. The query parameter must exist in the
         * request, in the absence of which the request match fails.
         */
        name: pulumi.Input<string>;
        /**
         * Specifies that the queryParameterMatch matches if the request contains the query
         * parameter, irrespective of whether the parameter has a value or not. Only one of
         * presentMatch, exactMatch and regexMatch must be set.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The queryParameterMatch matches if the value of the parameter matches the
         * regular expression specified by regexMatch. For the regular expression grammar,
         * please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
         * exactMatch and regexMatch must be set.
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        /**
         * The specification for allowing client side cross-origin requests. Please see W3C
         * Recommendation for Cross Origin Resource Sharing
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy>;
        /**
         * The specification for fault injection introduced into traffic to test the
         * resiliency of clients to backend service failure. As part of fault injection,
         * when clients send requests to a backend service, delays can be introduced by
         * Loadbalancer on a percentage of requests before sending those request to the
         * backend service. Similarly requests from clients can be aborted by the
         * Loadbalancer for a percentage of requests. timeout and retryPolicy will be
         * ignored by clients that are configured with a fault_injection_policy.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy>;
        /**
         * Specifies the maximum duration (timeout) for streams on the selected route.
         * Unlike the `Timeout` field where the timeout duration starts from the time the request
         * has been fully processed (known as end-of-stream), the duration in this field
         * is computed from the beginning of the stream until the response has been processed,
         * including all retries. A stream that does not complete in this duration is closed.
         * Structure is documented below.
         */
        maxStreamDuration?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration>;
        /**
         * Specifies the policy on how requests intended for the route's backends are
         * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
         * responses from the shadow service. Prior to sending traffic to the shadow
         * service, the host / authority header is suffixed with -shadow.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy>;
        /**
         * Specifies the timeout for the selected route. Timeout is computed from the time
         * the request is has been fully processed (i.e. end-of-stream) up until the
         * response has been completely processed. Timeout includes all retries. If not
         * specified, the default value is 15 seconds.
         * Structure is documented below.
         */
        timeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout>;
        /**
         * The spec to modify the URL of the request, prior to forwarding the request to
         * the matched service
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite>;
        /**
         * A list of weighted backend services to send traffic to when a route match
         * occurs. The weights determine the fraction of traffic that flows to their
         * corresponding backend service. If all traffic needs to go to a single backend
         * service, there must be one  weightedBackendService with weight set to a non 0
         * number. Once a backendService is identified and before forwarding the request to
         * the backend service, advanced routing actions like Url rewrites and header
         * transformations are applied depending on additional settings specified in this
         * HttpRouteAction.
         * Structure is documented below.
         */
        weightedBackendServices?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         * This translates to the Access-Control-Allow-Credentials header.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regular expression patterns that match allowed origins. For regular expression grammar
         * please see en.cppreference.com/w/cpp/regex/ecmascript
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached in seconds.
         * This translates to the Access-Control-Max-Age header.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        /**
         * The specification for how client requests are aborted as part of fault injection.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort>;
        /**
         * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         * The value must be between 200 and 599 inclusive.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        /**
         * Specifies the value of the fixed delay interval.
         * Structure is documented below.
         */
        fixedDelay?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay>;
        /**
         * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
         * The value must be between 0.0 and 100.0 inclusive.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionMaxStreamDuration {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        /**
         * The full or partial URL to the BackendService resource being mirrored to.
         */
        backendService: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        /**
         * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
         */
        numRetries: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt.
         * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
         * will use the largest timeout among all backend services associated with the route.
         * Structure is documented below.
         */
        perTryTimeout?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout>;
        /**
         * Specfies one or more conditions when this retry rule applies. Valid values are:
         * * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
         * or if the backend service does not respond at all, example: disconnects, reset, read timeout,
         * * connection failure, and refused streams.
         * * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
         * * connect-failure: Loadbalancer will retry on failures connecting to backend services,
         * for example due to connection timeouts.
         * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
         * Currently the only retriable error supported is 409.
         * * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
         * This reset type indicates that it is safe to retry.
         * * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
         * * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
         * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
         * * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
         * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        /**
         * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
         * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
         * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
         */
        seconds: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected service, the request's host header is replaced
         * with contents of hostRewrite.
         * The value must be between 1 and 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected backend service, the matching portion of the
         * request's path is replaced by pathPrefixRewrite.
         * The value must be between 1 and 1024 characters.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected origin, if the
         * request matched a pathTemplateMatch, the matching portion of the
         * request's path is replaced re-written using the pattern specified
         * by pathTemplateRewrite.
         * pathTemplateRewrite must be between 1 and 255 characters
         * (inclusive), must start with a '/', and must only use variables
         * captured by the route's pathTemplate matchers.
         * pathTemplateRewrite may only be used when all of a route's
         * MatchRules specify pathTemplate.
         * Only one of pathPrefixRewrite and pathTemplateRewrite may be
         * specified.
         */
        pathTemplateRewrite?: pulumi.Input<string>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        /**
         * The full or partial URL to the default BackendService resource. Before forwarding the
         * request to backendService, the loadbalancer applies any relevant headerActions
         * specified as part of this backendServiceWeight.
         */
        backendService: pulumi.Input<string>;
        /**
         * Specifies changes to request and response headers that need to take effect for
         * the selected backendService.
         * headerAction specified here take effect before headerAction in the enclosing
         * HttpRouteRule, PathMatcher and UrlMap.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction>;
        /**
         * Specifies the fraction of traffic sent to backendService, computed as
         * weight / (sum of all weightedBackendService weights in routeAction) .
         * The selection of a backend service is determined only for new traffic. Once a user's request
         * has been directed to a backendService, subsequent requests will be sent to the same backendService
         * as determined by the BackendService's session affinity policy.
         * The value must be between 0 and 1000
         */
        weight: pulumi.Input<number>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        /**
         * Headers to add to a matching request prior to forwarding the request to the backendService.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to
         * forwarding the request to the backendService.
         */
        requestHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Headers to add the response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the response prior to sending the
         * response back to the client.
         */
        responseHeadersToRemoves?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * If false, headerValue is appended to any values that already exist for the header.
         * If true, headerValue is set for the header, discarding any values that were set for that header.
         */
        replace: pulumi.Input<boolean>;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was
         * supplied in the request. The value must be between 1 and 255 characters.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set
         * to false, the URL scheme of the redirected request will remain the same as that
         * of the request. This must only be set for UrlMaps used in TargetHttpProxys.
         * Setting this true for TargetHttpsProxy is not permitted. Defaults to false.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was
         * supplied in the request. Only one of pathRedirect or prefixRedirect must be
         * specified. The value must be between 1 and 1024 characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
         * retaining the remaining portion of the URL before redirecting the request.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction. Supported values are:
         * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
         * * FOUND, which corresponds to 302.
         * * SEE_OTHER which corresponds to 303.
         * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained.
         * * PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed
         * prior to redirecting the request. If set to false, the query portion of the
         * original URL is retained. Defaults to false.
         */
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface URLMapTest {
        /**
         * Description of this test case.
         */
        description?: pulumi.Input<string>;
        /**
         * Host portion of the URL.
         */
        host: pulumi.Input<string>;
        /**
         * Path portion of the URL.
         */
        path: pulumi.Input<string>;
        /**
         * The backend service or backend bucket link that should be matched by this test.
         */
        service: pulumi.Input<string>;
    }
}

export namespace config {
}

export namespace container {
    export interface AttachedClusterAuthorization {
        /**
         * Groups that can perform operations as a cluster admin. A managed
         * ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
         * to the groups. Up to ten admin groups can be provided.
         * For more info on RBAC, see
         * https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Users that can perform operations as a cluster admin. A managed
         * ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole
         * to the users. Up to ten admin users can be provided.
         * For more info on RBAC, see
         * https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminUsers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AttachedClusterBinaryAuthorization {
        /**
         * Configure Binary Authorization evaluation mode.
         * Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
         */
        evaluationMode?: pulumi.Input<string>;
    }

    export interface AttachedClusterError {
        /**
         * Human-friendly description of the error.
         */
        message?: pulumi.Input<string>;
    }

    export interface AttachedClusterFleet {
        /**
         * (Output)
         * The name of the managed Hub Membership resource associated to this
         * cluster. Membership names are formatted as
         * projects/<project-number>/locations/global/membership/<cluster-id>.
         */
        membership?: pulumi.Input<string>;
        /**
         * The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         */
        project: pulumi.Input<string>;
    }

    export interface AttachedClusterLoggingConfig {
        /**
         * The configuration of the logging components
         * Structure is documented below.
         */
        componentConfig?: pulumi.Input<inputs.container.AttachedClusterLoggingConfigComponentConfig>;
    }

    export interface AttachedClusterLoggingConfigComponentConfig {
        /**
         * The components to be enabled.
         * Each value may be one of: `SYSTEM_COMPONENTS`, `WORKLOADS`.
         */
        enableComponents?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AttachedClusterMonitoringConfig {
        /**
         * Enable Google Cloud Managed Service for Prometheus in the cluster.
         * Structure is documented below.
         */
        managedPrometheusConfig?: pulumi.Input<inputs.container.AttachedClusterMonitoringConfigManagedPrometheusConfig>;
    }

    export interface AttachedClusterMonitoringConfigManagedPrometheusConfig {
        /**
         * Enable Managed Collection.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface AttachedClusterOidcConfig {
        /**
         * A JSON Web Token (JWT) issuer URI. `issuer` must start with `https://`
         */
        issuerUrl: pulumi.Input<string>;
        /**
         * OIDC verification keys in JWKS format (RFC 7517).
         */
        jwks?: pulumi.Input<string>;
    }

    export interface AttachedClusterProxyConfig {
        /**
         * The Kubernetes Secret resource that contains the HTTP(S) proxy configuration.
         * Structure is documented below.
         */
        kubernetesSecret?: pulumi.Input<inputs.container.AttachedClusterProxyConfigKubernetesSecret>;
    }

    export interface AttachedClusterProxyConfigKubernetesSecret {
        /**
         * Name of the kubernetes secret containing the proxy config.
         */
        name: pulumi.Input<string>;
        /**
         * Namespace of the kubernetes secret containing the proxy config.
         */
        namespace: pulumi.Input<string>;
    }

    export interface AttachedClusterSecurityPostureConfig {
        /**
         * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning.
         * Possible values are: `VULNERABILITY_DISABLED`, `VULNERABILITY_ENTERPRISE`.
         */
        vulnerabilityMode: pulumi.Input<string>;
    }

    export interface AttachedClusterWorkloadIdentityConfig {
        /**
         * The ID of the OIDC Identity Provider (IdP) associated to
         * the Workload Identity Pool.
         */
        identityProvider?: pulumi.Input<string>;
        /**
         * The OIDC issuer URL for this cluster.
         */
        issuerUri?: pulumi.Input<string>;
        /**
         * The Workload Identity Pool associated to the cluster.
         */
        workloadPool?: pulumi.Input<string>;
    }

    export interface AwsClusterAuthorization {
        /**
         * Groups of users that can perform operations as a cluster admin. A managed ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole to the groups. Up to ten admin groups can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminGroups?: pulumi.Input<pulumi.Input<inputs.container.AwsClusterAuthorizationAdminGroup>[]>;
        /**
         * Users to perform operations as a cluster admin. A managed ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole to the users. Up to ten admin users can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminUsers: pulumi.Input<pulumi.Input<inputs.container.AwsClusterAuthorizationAdminUser>[]>;
    }

    export interface AwsClusterAuthorizationAdminGroup {
        /**
         * The name of the group, e.g. `my-group@domain.com`.
         */
        group: pulumi.Input<string>;
    }

    export interface AwsClusterAuthorizationAdminUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface AwsClusterBinaryAuthorization {
        /**
         * Mode of operation for Binary Authorization policy evaluation. Possible values: DISABLED, PROJECT_SINGLETON_POLICY_ENFORCE
         */
        evaluationMode?: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlane {
        /**
         * Authentication configuration for management of AWS resources.
         */
        awsServicesAuthentication: pulumi.Input<inputs.container.AwsClusterControlPlaneAwsServicesAuthentication>;
        /**
         * The ARN of the AWS KMS key used to encrypt cluster configuration.
         */
        configEncryption: pulumi.Input<inputs.container.AwsClusterControlPlaneConfigEncryption>;
        /**
         * The ARN of the AWS KMS key used to encrypt cluster secrets.
         */
        databaseEncryption: pulumi.Input<inputs.container.AwsClusterControlPlaneDatabaseEncryption>;
        /**
         * The name of the AWS IAM instance pofile to assign to each control plane replica.
         */
        iamInstanceProfile: pulumi.Input<string>;
        /**
         * Details of placement information for an instance.
         */
        instancePlacement?: pulumi.Input<inputs.container.AwsClusterControlPlaneInstancePlacement>;
        /**
         * Optional. The AWS instance type. When unspecified, it defaults to `m5.large`.
         */
        instanceType?: pulumi.Input<string>;
        /**
         * Optional. Configuration related to the main volume provisioned for each control plane replica. The main volume is in charge of storing all of the cluster's etcd state. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 8 GiB with the GP2 volume type.
         */
        mainVolume?: pulumi.Input<inputs.container.AwsClusterControlPlaneMainVolume>;
        /**
         * Proxy configuration for outbound HTTP(S) traffic.
         */
        proxyConfig?: pulumi.Input<inputs.container.AwsClusterControlPlaneProxyConfig>;
        /**
         * Optional. Configuration related to the root volume provisioned for each control plane replica. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
         */
        rootVolume?: pulumi.Input<inputs.container.AwsClusterControlPlaneRootVolume>;
        /**
         * Optional. The IDs of additional security groups to add to control plane replicas. The Anthos Multi-Cloud API will automatically create and manage security groups with the minimum rules needed for a functioning cluster.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. SSH configuration for how to access the underlying control plane machines.
         */
        sshConfig?: pulumi.Input<inputs.container.AwsClusterControlPlaneSshConfig>;
        /**
         * The list of subnets where control plane replicas will run. A replica will be provisioned on each subnet and up to three values can be provided. Each subnet must be in a different AWS Availability Zone (AZ).
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. A set of AWS resource tags to propagate to all underlying managed AWS resources. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
         */
        tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Kubernetes version to run on control plane replicas (e.g. `1.19.10-gke.1000`). You can list all supported versions on a given Google Cloud region by calling .
         */
        version: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneAwsServicesAuthentication {
        /**
         * The Amazon Resource Name (ARN) of the role that the Anthos Multi-Cloud API will assume when managing AWS resources on your account.
         */
        roleArn: pulumi.Input<string>;
        /**
         * Optional. An identifier for the assumed role session. When unspecified, it defaults to `multicloud-service-agent`.
         */
        roleSessionName?: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneConfigEncryption {
        /**
         * The ARN of the AWS KMS key used to encrypt cluster configuration.
         */
        kmsKeyArn: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneDatabaseEncryption {
        /**
         * The ARN of the AWS KMS key used to encrypt cluster secrets.
         */
        kmsKeyArn: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneInstancePlacement {
        /**
         * The tenancy for the instance. Possible values: TENANCY_UNSPECIFIED, DEFAULT, DEDICATED, HOST
         */
        tenancy?: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneMainVolume {
        /**
         * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
         */
        iops?: pulumi.Input<number>;
        /**
         * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
        /**
         * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3. If volume type is gp3 and throughput is not specified, the throughput will defaults to 125.
         */
        throughput?: pulumi.Input<number>;
        /**
         * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
         */
        volumeType?: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneProxyConfig {
        /**
         * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
         */
        secretArn: pulumi.Input<string>;
        /**
         * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneRootVolume {
        /**
         * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
         */
        iops?: pulumi.Input<number>;
        /**
         * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
        /**
         * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3. If volume type is gp3 and throughput is not specified, the throughput will defaults to 125.
         */
        throughput?: pulumi.Input<number>;
        /**
         * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
         */
        volumeType?: pulumi.Input<string>;
    }

    export interface AwsClusterControlPlaneSshConfig {
        /**
         * The name of the EC2 key pair used to login into cluster machines.
         */
        ec2KeyPair: pulumi.Input<string>;
    }

    export interface AwsClusterFleet {
        /**
         * The name of the managed Hub Membership resource associated to this cluster. Membership names are formatted as projects/<project-number>/locations/global/membership/<cluster-id>.
         */
        membership?: pulumi.Input<string>;
        /**
         * The number of the Fleet host project where this cluster will be registered.
         */
        project?: pulumi.Input<string>;
    }

    export interface AwsClusterLoggingConfig {
        /**
         * Configuration of the logging components.
         */
        componentConfig?: pulumi.Input<inputs.container.AwsClusterLoggingConfigComponentConfig>;
    }

    export interface AwsClusterLoggingConfigComponentConfig {
        /**
         * Components of the logging configuration to be enabled.
         */
        enableComponents?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsClusterNetworking {
        /**
         * Disable the per node pool subnet security group rules on the control plane security group. When set to true, you must also provide one or more security groups that ensure node pools are able to send requests to the control plane on TCP/443 and TCP/8132. Failure to do so may result in unavailable node pools.
         */
        perNodePoolSgRulesDisabled?: pulumi.Input<boolean>;
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The VPC associated with the cluster. All component clusters (i.e. control plane and node pools) run on a single VPC. This field cannot be changed after creation.
         *
         * - - -
         */
        vpcId: pulumi.Input<string>;
    }

    export interface AwsClusterWorkloadIdentityConfig {
        /**
         * The ID of the OIDC Identity Provider (IdP) associated to the Workload Identity Pool.
         */
        identityProvider?: pulumi.Input<string>;
        /**
         * The OIDC issuer URL for this cluster.
         */
        issuerUri?: pulumi.Input<string>;
        /**
         * The Workload Identity Pool associated to the cluster.
         */
        workloadPool?: pulumi.Input<string>;
    }

    export interface AwsNodePoolAutoscaling {
        /**
         * Maximum number of nodes in the NodePool. Must be >= min_node_count.
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * Minimum number of nodes in the NodePool. Must be >= 1 and <= max_node_count.
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface AwsNodePoolConfig {
        /**
         * Optional. Configuration related to CloudWatch metrics collection on the Auto Scaling group of the node pool. When unspecified, metrics collection is disabled.
         */
        autoscalingMetricsCollection?: pulumi.Input<inputs.container.AwsNodePoolConfigAutoscalingMetricsCollection>;
        /**
         * The ARN of the AWS KMS key used to encrypt node pool configuration.
         */
        configEncryption: pulumi.Input<inputs.container.AwsNodePoolConfigConfigEncryption>;
        /**
         * The name of the AWS IAM role assigned to nodes in the pool.
         */
        iamInstanceProfile: pulumi.Input<string>;
        /**
         * The OS image type to use on node pool instances.
         */
        imageType?: pulumi.Input<string>;
        /**
         * Details of placement information for an instance.
         */
        instancePlacement?: pulumi.Input<inputs.container.AwsNodePoolConfigInstancePlacement>;
        /**
         * Optional. The AWS instance type. When unspecified, it defaults to `m5.large`.
         */
        instanceType?: pulumi.Input<string>;
        /**
         * Optional. The initial labels assigned to nodes of this node pool. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Proxy configuration for outbound HTTP(S) traffic.
         */
        proxyConfig?: pulumi.Input<inputs.container.AwsNodePoolConfigProxyConfig>;
        /**
         * Optional. Template for the root volume provisioned for node pool nodes. Volumes will be provisioned in the availability zone assigned to the node pool subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
         */
        rootVolume?: pulumi.Input<inputs.container.AwsNodePoolConfigRootVolume>;
        /**
         * Optional. The IDs of additional security groups to add to nodes in this pool. The manager will automatically create security groups with minimum rules needed for a functioning cluster.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. When specified, the node pool will provision Spot instances from the set of spot_config.instance_types. This field is mutually exclusive with `instanceType`
         */
        spotConfig?: pulumi.Input<inputs.container.AwsNodePoolConfigSpotConfig>;
        /**
         * Optional. The SSH configuration.
         */
        sshConfig?: pulumi.Input<inputs.container.AwsNodePoolConfigSshConfig>;
        /**
         * Optional. Key/value metadata to assign to each underlying AWS resource. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
         */
        tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Optional. The initial taints assigned to nodes of this node pool.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.AwsNodePoolConfigTaint>[]>;
    }

    export interface AwsNodePoolConfigAutoscalingMetricsCollection {
        /**
         * The frequency at which EC2 Auto Scaling sends aggregated data to AWS CloudWatch. The only valid value is "1Minute".
         */
        granularity: pulumi.Input<string>;
        /**
         * The metrics to enable. For a list of valid metrics, see https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html. If you specify granularity and don't specify any metrics, all metrics are enabled.
         */
        metrics?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsNodePoolConfigConfigEncryption {
        /**
         * The ARN of the AWS KMS key used to encrypt node pool configuration.
         */
        kmsKeyArn: pulumi.Input<string>;
    }

    export interface AwsNodePoolConfigInstancePlacement {
        /**
         * The tenancy for the instance. Possible values: TENANCY_UNSPECIFIED, DEFAULT, DEDICATED, HOST
         */
        tenancy?: pulumi.Input<string>;
    }

    export interface AwsNodePoolConfigProxyConfig {
        /**
         * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
         */
        secretArn: pulumi.Input<string>;
        /**
         * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface AwsNodePoolConfigRootVolume {
        /**
         * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
         */
        iops?: pulumi.Input<number>;
        /**
         * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
        /**
         * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3. If volume type is gp3 and throughput is not specified, the throughput will defaults to 125.
         */
        throughput?: pulumi.Input<number>;
        /**
         * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
         */
        volumeType?: pulumi.Input<string>;
    }

    export interface AwsNodePoolConfigSpotConfig {
        /**
         * List of AWS EC2 instance types for creating a spot node pool's nodes. The specified instance types must have the same number of CPUs and memory. You can use the Amazon EC2 Instance Selector tool (https://github.com/aws/amazon-ec2-instance-selector) to choose instance types with matching CPU and memory
         */
        instanceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsNodePoolConfigSshConfig {
        /**
         * The name of the EC2 key pair used to login into cluster machines.
         */
        ec2KeyPair: pulumi.Input<string>;
    }

    export interface AwsNodePoolConfigTaint {
        /**
         * The taint effect. Possible values: EFFECT_UNSPECIFIED, NO_SCHEDULE, PREFER_NO_SCHEDULE, NO_EXECUTE
         */
        effect: pulumi.Input<string>;
        /**
         * Key for the taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for the taint.
         */
        value: pulumi.Input<string>;
    }

    export interface AwsNodePoolKubeletConfig {
        /**
         * Whether or not to enable CPU CFS quota. Defaults to true.
         */
        cpuCfsQuota?: pulumi.Input<boolean>;
        /**
         * Optional. The CPU CFS quota period to use for the node. Defaults to "100ms".
         */
        cpuCfsQuotaPeriod?: pulumi.Input<string>;
        /**
         * The CpuManagerPolicy to use for the node. Defaults to "none".
         */
        cpuManagerPolicy?: pulumi.Input<string>;
        /**
         * Optional. The maximum number of PIDs in each pod running on the node. The limit scales automatically based on underlying machine size if left unset.
         */
        podPidsLimit?: pulumi.Input<number>;
    }

    export interface AwsNodePoolManagement {
        /**
         * Optional. Whether or not the nodes will be automatically repaired.
         */
        autoRepair?: pulumi.Input<boolean>;
    }

    export interface AwsNodePoolMaxPodsConstraint {
        /**
         * The maximum number of pods to schedule on a single node.
         *
         * - - -
         */
        maxPodsPerNode: pulumi.Input<number>;
    }

    export interface AwsNodePoolUpdateSettings {
        /**
         * Optional. Settings for surge update.
         */
        surgeSettings?: pulumi.Input<inputs.container.AwsNodePoolUpdateSettingsSurgeSettings>;
    }

    export interface AwsNodePoolUpdateSettingsSurgeSettings {
        /**
         * Optional. The maximum number of nodes that can be created beyond the current size of the node pool during the update process.
         */
        maxSurge?: pulumi.Input<number>;
        /**
         * Optional. The maximum number of nodes that can be simultaneously unavailable during the update process. A node is considered unavailable if its status is not Ready.
         */
        maxUnavailable?: pulumi.Input<number>;
    }

    export interface AzureClusterAuthorization {
        /**
         * Groups of users that can perform operations as a cluster admin. A managed ClusterRoleBinding will be created to grant the `cluster-admin` ClusterRole to the groups. Up to ten admin groups can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminGroups?: pulumi.Input<pulumi.Input<inputs.container.AzureClusterAuthorizationAdminGroup>[]>;
        /**
         * Users that can perform operations as a cluster admin. A new ClusterRoleBinding will be created to grant the cluster-admin ClusterRole to the users. Up to ten admin users can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
         */
        adminUsers: pulumi.Input<pulumi.Input<inputs.container.AzureClusterAuthorizationAdminUser>[]>;
    }

    export interface AzureClusterAuthorizationAdminGroup {
        /**
         * The name of the group, e.g. `my-group@domain.com`.
         */
        group: pulumi.Input<string>;
    }

    export interface AzureClusterAuthorizationAdminUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface AzureClusterAzureServicesAuthentication {
        /**
         * The Azure Active Directory Application ID for Authentication configuration.
         */
        applicationId: pulumi.Input<string>;
        /**
         * The Azure Active Directory Tenant ID for Authentication configuration.
         */
        tenantId: pulumi.Input<string>;
    }

    export interface AzureClusterControlPlane {
        /**
         * Optional. Configuration related to application-layer secrets encryption.
         */
        databaseEncryption?: pulumi.Input<inputs.container.AzureClusterControlPlaneDatabaseEncryption>;
        /**
         * Optional. Configuration related to the main volume provisioned for each control plane replica. The main volume is in charge of storing all of the cluster's etcd state. When unspecified, it defaults to a 8-GiB Azure Disk.
         */
        mainVolume?: pulumi.Input<inputs.container.AzureClusterControlPlaneMainVolume>;
        /**
         * Proxy configuration for outbound HTTP(S) traffic.
         */
        proxyConfig?: pulumi.Input<inputs.container.AzureClusterControlPlaneProxyConfig>;
        /**
         * Configuration for where to place the control plane replicas. Up to three replica placement instances can be specified. If replicaPlacements is set, the replica placement instances will be applied to the three control plane replicas as evenly as possible.
         */
        replicaPlacements?: pulumi.Input<pulumi.Input<inputs.container.AzureClusterControlPlaneReplicaPlacement>[]>;
        /**
         * Optional. Configuration related to the root volume provisioned for each control plane replica. When unspecified, it defaults to 32-GiB Azure Disk.
         */
        rootVolume?: pulumi.Input<inputs.container.AzureClusterControlPlaneRootVolume>;
        /**
         * SSH configuration for how to access the underlying control plane machines.
         */
        sshConfig: pulumi.Input<inputs.container.AzureClusterControlPlaneSshConfig>;
        /**
         * The ARM ID of the subnet where the control plane VMs are deployed. Example: `/subscriptions//resourceGroups//providers/Microsoft.Network/virtualNetworks//subnets/default`.
         */
        subnetId: pulumi.Input<string>;
        /**
         * Optional. A set of tags to apply to all underlying control plane Azure resources.
         */
        tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Kubernetes version to run on control plane replicas (e.g. `1.19.10-gke.1000`). You can list all supported versions on a given Google Cloud region by calling GetAzureServerConfig.
         */
        version: pulumi.Input<string>;
        /**
         * Optional. The Azure VM size name. Example: `Standard_DS2_v2`. For available VM sizes, see https://docs.microsoft.com/en-us/azure/virtual-machines/vm-naming-conventions. When unspecified, it defaults to `Standard_DS2_v2`.
         */
        vmSize?: pulumi.Input<string>;
    }

    export interface AzureClusterControlPlaneDatabaseEncryption {
        /**
         * The ARM ID of the Azure Key Vault key to encrypt / decrypt data. For example: `/subscriptions/<subscription-id>/resourceGroups/<resource-group-id>/providers/Microsoft.KeyVault/vaults/<key-vault-id>/keys/<key-name>` Encryption will always take the latest version of the key and hence specific version is not supported.
         */
        keyId: pulumi.Input<string>;
    }

    export interface AzureClusterControlPlaneMainVolume {
        /**
         * Optional. The size of the disk, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
    }

    export interface AzureClusterControlPlaneProxyConfig {
        /**
         * The ARM ID the of the resource group containing proxy keyvault. Resource group ids are formatted as `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`
         */
        resourceGroupId: pulumi.Input<string>;
        /**
         * The URL the of the proxy setting secret with its version. Secret ids are formatted as `https:<key-vault-name>.vault.azure.net/secrets/<secret-name>/<secret-version>`.
         */
        secretId: pulumi.Input<string>;
    }

    export interface AzureClusterControlPlaneReplicaPlacement {
        /**
         * For a given replica, the Azure availability zone where to provision the control plane VM and the ETCD disk.
         */
        azureAvailabilityZone: pulumi.Input<string>;
        /**
         * For a given replica, the ARM ID of the subnet where the control plane VM is deployed. Make sure it's a subnet under the virtual network in the cluster configuration.
         */
        subnetId: pulumi.Input<string>;
    }

    export interface AzureClusterControlPlaneRootVolume {
        /**
         * Optional. The size of the disk, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
    }

    export interface AzureClusterControlPlaneSshConfig {
        /**
         * The SSH public key data for VMs managed by Anthos. This accepts the authorizedKeys file format used in OpenSSH according to the sshd(8) manual page.
         */
        authorizedKey: pulumi.Input<string>;
    }

    export interface AzureClusterFleet {
        /**
         * The name of the managed Hub Membership resource associated to this cluster. Membership names are formatted as projects/<project-number>/locations/global/membership/<cluster-id>.
         */
        membership?: pulumi.Input<string>;
        /**
         * The number of the Fleet host project where this cluster will be registered.
         */
        project?: pulumi.Input<string>;
    }

    export interface AzureClusterLoggingConfig {
        /**
         * Configuration of the logging components.
         */
        componentConfig?: pulumi.Input<inputs.container.AzureClusterLoggingConfigComponentConfig>;
    }

    export interface AzureClusterLoggingConfigComponentConfig {
        /**
         * Components of the logging configuration to be enabled.
         */
        enableComponents?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AzureClusterNetworking {
        /**
         * The IP address range of the pods in this cluster, in CIDR notation (e.g. `10.96.0.0/14`). All pods in the cluster get assigned a unique RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP address range for services in this cluster, in CIDR notation (e.g. `10.96.0.0/14`). All services in the cluster get assigned a unique RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creating a cluster.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Azure Resource Manager (ARM) ID of the VNet associated with your cluster. All components in the cluster (i.e. control plane and node pools) run on a single VNet. Example: `/subscriptions/*&#47;resourceGroups/*&#47;providers/Microsoft.Network/virtualNetworks/*` This field cannot be changed after creation.
         *
         * - - -
         */
        virtualNetworkId: pulumi.Input<string>;
    }

    export interface AzureClusterWorkloadIdentityConfig {
        /**
         * The ID of the OIDC Identity Provider (IdP) associated to the Workload Identity Pool.
         */
        identityProvider?: pulumi.Input<string>;
        /**
         * The OIDC issuer URL for this cluster.
         */
        issuerUri?: pulumi.Input<string>;
        /**
         * The Workload Identity Pool associated to the cluster.
         */
        workloadPool?: pulumi.Input<string>;
    }

    export interface AzureNodePoolAutoscaling {
        /**
         * Maximum number of nodes in the node pool. Must be >= min_node_count.
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * Minimum number of nodes in the node pool. Must be >= 1 and <= max_node_count.
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface AzureNodePoolConfig {
        /**
         * The OS image type to use on node pool instances.
         */
        imageType?: pulumi.Input<string>;
        /**
         * Optional. The initial labels assigned to nodes of this node pool. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Proxy configuration for outbound HTTP(S) traffic.
         */
        proxyConfig?: pulumi.Input<inputs.container.AzureNodePoolConfigProxyConfig>;
        /**
         * Optional. Configuration related to the root volume provisioned for each node pool machine. When unspecified, it defaults to a 32-GiB Azure Disk.
         */
        rootVolume?: pulumi.Input<inputs.container.AzureNodePoolConfigRootVolume>;
        /**
         * SSH configuration for how to access the node pool machines.
         */
        sshConfig: pulumi.Input<inputs.container.AzureNodePoolConfigSshConfig>;
        /**
         * Optional. A set of tags to apply to all underlying Azure resources for this node pool. This currently only includes Virtual Machine Scale Sets. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
         */
        tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Optional. The Azure VM size name. Example: `Standard_DS2_v2`. See (/anthos/clusters/docs/azure/reference/supported-vms) for options. When unspecified, it defaults to `Standard_DS2_v2`.
         */
        vmSize?: pulumi.Input<string>;
    }

    export interface AzureNodePoolConfigProxyConfig {
        /**
         * The ARM ID the of the resource group containing proxy keyvault. Resource group ids are formatted as `/subscriptions/<subscription-id>/resourceGroups/<resource-group-name>`
         */
        resourceGroupId: pulumi.Input<string>;
        /**
         * The URL the of the proxy setting secret with its version. Secret ids are formatted as `https:<key-vault-name>.vault.azure.net/secrets/<secret-name>/<secret-version>`.
         */
        secretId: pulumi.Input<string>;
    }

    export interface AzureNodePoolConfigRootVolume {
        /**
         * Optional. The size of the disk, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
         */
        sizeGib?: pulumi.Input<number>;
    }

    export interface AzureNodePoolConfigSshConfig {
        /**
         * The SSH public key data for VMs managed by Anthos. This accepts the authorizedKeys file format used in OpenSSH according to the sshd(8) manual page.
         */
        authorizedKey: pulumi.Input<string>;
    }

    export interface AzureNodePoolManagement {
        /**
         * Optional. Whether or not the nodes will be automatically repaired.
         */
        autoRepair?: pulumi.Input<boolean>;
    }

    export interface AzureNodePoolMaxPodsConstraint {
        /**
         * The maximum number of pods to schedule on a single node.
         *
         * - - -
         */
        maxPodsPerNode: pulumi.Input<number>;
    }

    export interface ClusterAddonsConfig {
        /**
         * . Structure is documented below.
         */
        cloudrunConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigCloudrunConfig>;
        /**
         * .
         * The status of the ConfigConnector addon. It is disabled by default; Set `enabled = true` to enable.
         */
        configConnectorConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigConfigConnectorConfig>;
        /**
         * .
         * The status of the NodeLocal DNSCache addon. It is disabled by default.
         * Set `enabled = true` to enable.
         *
         * **Enabling/Disabling NodeLocal DNSCache in an existing cluster is a disruptive operation.
         * All cluster nodes running GKE 1.15 and higher are recreated.**
         */
        dnsCacheConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigDnsCacheConfig>;
        /**
         * .
         * Whether this cluster should enable the Google Compute Engine Persistent Disk Container Storage Interface (CSI) Driver. Set `enabled = true` to enable.
         *
         * **Note:** The Compute Engine persistent disk CSI Driver is enabled by default on newly created clusters for the following versions: Linux clusters: GKE version 1.18.10-gke.2100 or later, or 1.19.3-gke.2100 or later.
         */
        gcePersistentDiskCsiDriverConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigGcePersistentDiskCsiDriverConfig>;
        /**
         * The status of the Filestore CSI driver addon,
         * which allows the usage of filestore instance as volumes.
         * It is disabled by default; set `enabled = true` to enable.
         */
        gcpFilestoreCsiDriverConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigGcpFilestoreCsiDriverConfig>;
        /**
         * The status of the GCSFuse CSI driver addon,
         * which allows the usage of a gcs bucket as volumes.
         * It is disabled by default for Standard clusters; set `enabled = true` to enable.
         * It is enabled by default for Autopilot clusters with version 1.24 or later; set `enabled = true` to enable it explicitly.
         * See [Enable the Cloud Storage FUSE CSI driver](https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/cloud-storage-fuse-csi-driver#enable) for more information.
         */
        gcsFuseCsiDriverConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigGcsFuseCsiDriverConfig>;
        /**
         * .
         * The status of the Backup for GKE agent addon. It is disabled by default; Set `enabled = true` to enable.
         */
        gkeBackupAgentConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigGkeBackupAgentConfig>;
        /**
         * The status of the Horizontal Pod Autoscaling
         * addon, which increases or decreases the number of replica pods a replication controller
         * has based on the resource usage of the existing pods.
         * It is enabled by default;
         * set `disabled = true` to disable.
         */
        horizontalPodAutoscaling?: pulumi.Input<inputs.container.ClusterAddonsConfigHorizontalPodAutoscaling>;
        /**
         * The status of the HTTP (L7) load balancing
         * controller addon, which makes it easy to set up HTTP load balancers for services in a
         * cluster. It is enabled by default; set `disabled = true` to disable.
         */
        httpLoadBalancing?: pulumi.Input<inputs.container.ClusterAddonsConfigHttpLoadBalancing>;
        /**
         * .
         * Structure is documented below.
         */
        istioConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigIstioConfig>;
        /**
         * .
         * Configuration for the KALM addon, which manages the lifecycle of k8s. It is disabled by default; Set `enabled = true` to enable.
         */
        kalmConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigKalmConfig>;
        /**
         * Whether we should enable the network policy addon
         * for the master.  This must be enabled in order to enable network policy for the nodes.
         * To enable this, you must also define a `networkPolicy` block,
         * otherwise nothing will happen.
         * It can only be disabled if the nodes already do not have network policies enabled.
         * Defaults to disabled; set `disabled = false` to enable.
         */
        networkPolicyConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigNetworkPolicyConfig>;
        /**
         * The status of the Parallelstore CSI driver addon,
         * which allows the usage of a Parallelstore instances as volumes.
         * It is disabled by default for Standard clusters; set `enabled = true` to enable.
         * It is enabled by default for Autopilot clusters with version 1.29 or later; set `enabled = true` to enable it explicitly.
         * See [Enable the Parallelstore CSI driver](https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/parallelstore-csi-new-volume#enable) for more information.
         *
         * This example `addonsConfig` disables two addons:
         */
        parallelstoreCsiDriverConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigParallelstoreCsiDriverConfig>;
        /**
         * . The status of the [Ray Operator
         * addon](https://cloud.google.com/kubernetes-engine/docs/add-on/ray-on-gke/concepts/overview).
         * It is disabled by default. Set `enabled = true` to enable. The minimum
         * cluster version to enable Ray is 1.30.0-gke.1747000.
         *
         * Ray Operator config has optional subfields
         * `ray_cluster_logging_config.enabled` and
         * `ray_cluster_monitoring_config.enabled` which control Ray Cluster logging
         * and monitoring respectively. See [Collect and view logs and metrics for Ray
         * clusters on
         * GKE](https://cloud.google.com/kubernetes-engine/docs/add-on/ray-on-gke/how-to/collect-view-logs-metrics)
         * for more information.
         */
        rayOperatorConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterAddonsConfigRayOperatorConfig>[]>;
        /**
         * .
         * The status of the Stateful HA addon, which provides automatic configurable failover for stateful applications.
         * It is disabled by default for Standard clusters. Set `enabled = true` to enable.
         */
        statefulHaConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigStatefulHaConfig>;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        /**
         * The status of the CloudRun addon. It is disabled by default. Set `disabled=false` to enable.
         */
        disabled: pulumi.Input<boolean>;
        /**
         * The load balancer type of CloudRun ingress service. It is external load balancer by default.
         * Set `load_balancer_type=LOAD_BALANCER_TYPE_INTERNAL` to configure it as internal load balancer.
         */
        loadBalancerType?: pulumi.Input<string>;
    }

    export interface ClusterAddonsConfigConfigConnectorConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigDnsCacheConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigGcePersistentDiskCsiDriverConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigGcpFilestoreCsiDriverConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigGcsFuseCsiDriverConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigGkeBackupAgentConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigIstioConfig {
        /**
         * The authentication type between services in Istio. Available options include `AUTH_MUTUAL_TLS`.
         */
        auth?: pulumi.Input<string>;
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigKalmConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigParallelstoreCsiDriverConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigRayOperatorConfig {
        enabled: pulumi.Input<boolean>;
        /**
         * The status of Ray Logging, which scrapes Ray cluster logs to Cloud Logging. Defaults to disabled; set enabled = true to enable.
         */
        rayClusterLoggingConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig>;
        /**
         * The status of Ray Cluster monitoring, which shows Ray cluster metrics in Cloud Console. Defaults to disabled; set enabled = true to enable.
         */
        rayClusterMonitoringConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig>;
    }

    export interface ClusterAddonsConfigRayOperatorConfigRayClusterLoggingConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigRayOperatorConfigRayClusterMonitoringConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigStatefulHaConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        /**
         * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format `gke-security-groups@yourdomain.com`.
         */
        securityGroup: pulumi.Input<string>;
    }

    export interface ClusterBinaryAuthorization {
        /**
         * Enable Binary Authorization for this cluster.
         *
         * @deprecated Deprecated in favor of evaluation_mode.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Mode of operation for Binary Authorization policy evaluation.
         */
        evaluationMode?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscaling {
        /**
         * Contains defaults for a node pool created by NAP. A subset of fields also apply to
         * GKE Autopilot clusters.
         * Structure is documented below.
         */
        autoProvisioningDefaults?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults>;
        /**
         * The list of Google Compute Engine
         * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
         * NodePool's nodes can be created by NAP.
         */
        autoProvisioningLocations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration
         * options for the [Autoscaling profile](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#autoscaling_profiles)
         * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
         * when deciding to remove nodes from a cluster. Can be `BALANCED` or `OPTIMIZE_UTILIZATION`. Defaults to `BALANCED`.
         */
        autoscalingProfile?: pulumi.Input<string>;
        /**
         * Whether node auto-provisioning is enabled. Must be supplied for GKE Standard clusters, `true` is implied
         * for autopilot clusters. Resource limits for `cpu` and `memory` must be defined to enable node auto-provisioning for GKE Standard.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Global constraints for machine resources in the
         * cluster. Configuring the `cpu` and `memory` types is required if node
         * auto-provisioning is enabled. These limits will apply to node pool autoscaling
         * in addition to node auto-provisioning. Structure is documented below.
         */
        resourceLimits?: pulumi.Input<pulumi.Input<inputs.container.ClusterClusterAutoscalingResourceLimit>[]>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. Defaults to `100`
         */
        diskSize?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd', 'pd-balanced', or 'hyperdisk-balanced'). Defaults to `hyperdisk-balanced` if `hyperdisk-balanced` is supported and `pd-balanced` is not supported for the machine type; otherwise defaults to `pd-balanced`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * The default image type used by NAP once a new node pool is being created. Please note that according to the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning#default-image-type) the value must be one of the [COS_CONTAINERD, COS, UBUNTU_CONTAINERD, UBUNTU]. __NOTE__ : COS AND UBUNTU are deprecated as of `GKE 1.24`
         */
        imageType?: pulumi.Input<string>;
        /**
         * NodeManagement configuration for this NodePool. Structure is documented below.
         */
        management?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsManagement>;
        /**
         * Minimum CPU platform to be used for NAP created node pools. The instance may be scheduled on the
         * specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such
         * as "Intel Haswell" or "Intel Sandy Bridge".
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Scopes that are used by NAP and GKE Autopilot when creating node pools. Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set `serviceAccount` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         *
         * > `monitoring.write` is always enabled regardless of user input.  `monitoring` and `logging.write` may also be enabled depending on the values for `monitoringService` and `loggingService`.
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Google Cloud Platform Service Account to be used by the node VMs created by GKE Autopilot or NAP.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig>;
        /**
         * Specifies the upgrade settings for NAP created node pools
         */
        upgradeSettings?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsManagement {
        /**
         * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
         *
         * This block also contains several computed attributes, documented below.
         */
        autoRepair?: pulumi.Input<boolean>;
        /**
         * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
         */
        autoUpgrade?: pulumi.Input<boolean>;
        /**
         * Specifies the [Auto Upgrade knobs](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/NodeManagement#AutoUpgradeOptions) for the node pool.
         */
        upgradeOptions?: pulumi.Input<pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOption>[]>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsManagementUpgradeOption {
        /**
         * This field is set when upgrades are about to commence with the approximate start time for the upgrades, in RFC3339 text format.
         */
        autoUpgradeStartTime?: pulumi.Input<string>;
        /**
         * Description of the cluster.
         */
        description?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         *
         * Enables monitoring and attestation of the boot integrity of the instance. The attestation is performed against the integrity policy baseline. This baseline is initially derived from the implicitly trusted boot image when the instance is created.  Defaults to `true`.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines if the instance has Secure Boot enabled.
         *
         * Secure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails.  Defaults to `false`.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettings {
        /**
         * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
         */
        blueGreenSettings?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings>;
        /**
         * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
         */
        maxSurge?: pulumi.Input<number>;
        /**
         * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
         */
        maxUnavailable?: pulumi.Input<number>;
        /**
         * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
         */
        strategy?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettings {
        /**
         * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        nodePoolSoakDuration?: pulumi.Input<string>;
        /**
         * Standard policy for the blue-green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
         */
        standardRolloutPolicy?: pulumi.Input<inputs.container.ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>;
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaultsUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
        /**
         * Number of blue nodes to drain in a batch. Only one of the batchPercentage or batchNodeCount can be specified.
         */
        batchNodeCount?: pulumi.Input<number>;
        /**
         * Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batchPercentage or batchNodeCount can be specified.
         */
        batchPercentage?: pulumi.Input<number>;
        /**
         * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
         */
        batchSoakDuration?: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        /**
         * Maximum amount of the resource in the cluster.
         */
        maximum: pulumi.Input<number>;
        /**
         * Minimum amount of the resource in the cluster.
         */
        minimum?: pulumi.Input<number>;
        /**
         * The type of the resource. For example, `cpu` and
         * `memory`.  See the [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
         * for a list of types.
         */
        resourceType: pulumi.Input<string>;
    }

    export interface ClusterClusterTelemetry {
        /**
         * Telemetry integration for the cluster. Supported values (`ENABLED, DISABLED, SYSTEM_ONLY`);
         * `SYSTEM_ONLY` (Only system components are monitored and logged) is only available in GKE versions 1.15 and later.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterConfidentialNodes {
        /**
         * Enable Confidential GKE Nodes for this cluster, to
         * enforce encryption of data in-use.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterControlPlaneEndpointsConfig {
        /**
         * DNS endpoint configuration.
         */
        dnsEndpointConfig?: pulumi.Input<inputs.container.ClusterControlPlaneEndpointsConfigDnsEndpointConfig>;
        /**
         * IP endpoint configuration.
         */
        ipEndpointsConfig?: pulumi.Input<inputs.container.ClusterControlPlaneEndpointsConfigIpEndpointsConfig>;
    }

    export interface ClusterControlPlaneEndpointsConfigDnsEndpointConfig {
        /**
         * Controls whether user traffic is allowed over this endpoint. Note that GCP-managed services may still use the endpoint even if this is false.
         */
        allowExternalTraffic?: pulumi.Input<boolean>;
        /**
         * The cluster's DNS endpoint.
         */
        endpoint?: pulumi.Input<string>;
    }

    export interface ClusterControlPlaneEndpointsConfigIpEndpointsConfig {
        /**
         * Controls whether to allow direct IP access. Defaults to `true`.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ClusterCostManagementConfig {
        /**
         * Whether to enable the [cost allocation](https://cloud.google.com/kubernetes-engine/docs/how-to/cost-allocations) feature.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterDatabaseEncryption {
        /**
         * the key to use to encrypt/decrypt secrets.  See the [DatabaseEncryption definition](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#Cluster.DatabaseEncryption) for more information.
         *
         * <a name="nestedEnableK8sBetaApis"></a>The `enableK8sBetaApis` block supports:
         */
        keyName?: pulumi.Input<string>;
        /**
         * `ENCRYPTED` or `DECRYPTED`
         */
        state: pulumi.Input<string>;
    }

    export interface ClusterDefaultSnatStatus {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterDnsConfig {
        /**
         * This will enable Cloud DNS additive VPC scope. Must provide a domain name that is unique within the VPC. For this to work `clusterDns = "CLOUD_DNS"` and `clusterDnsScope = "CLUSTER_SCOPE"` must both be set as well.
         */
        additiveVpcScopeDnsDomain?: pulumi.Input<string>;
        /**
         * Which in-cluster DNS provider should be used. `PROVIDER_UNSPECIFIED` (default) or `PLATFORM_DEFAULT` or `CLOUD_DNS`.
         */
        clusterDns?: pulumi.Input<string>;
        /**
         * The suffix used for all cluster service records.
         */
        clusterDnsDomain?: pulumi.Input<string>;
        /**
         * The scope of access to cluster DNS records. `DNS_SCOPE_UNSPECIFIED` or `CLUSTER_SCOPE` or `VPC_SCOPE`. If the `clusterDns` field is set to `CLOUD_DNS`, `DNS_SCOPE_UNSPECIFIED` and empty/null behave like `CLUSTER_SCOPE`.
         */
        clusterDnsScope?: pulumi.Input<string>;
    }

    export interface ClusterEnableK8sBetaApis {
        /**
         * Enabled Kubernetes Beta APIs.
         */
        enabledApis: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterEnterpriseConfig {
        /**
         * The effective tier of the cluster.
         */
        clusterTier?: pulumi.Input<string>;
        /**
         * Sets the tier of the cluster. Available options include `STANDARD` and `ENTERPRISE`.
         */
        desiredTier?: pulumi.Input<string>;
    }

    export interface ClusterFleet {
        /**
         * The resource name of the fleet Membership resource associated to this cluster with format `//gkehub.googleapis.com/projects/{{project}}/locations/{{location}}/memberships/{{name}}`. See the official doc for [fleet management](https://cloud.google.com/kubernetes-engine/docs/fleets-overview).
         */
        membership?: pulumi.Input<string>;
        /**
         * The short name of the fleet membership, extracted from `fleet.0.membership`. You can use this field to configure `membershipId` under google_gkehub_feature_membership.
         */
        membershipId?: pulumi.Input<string>;
        /**
         * The location of the fleet membership,  extracted from `fleet.0.membership`. You can use this field to configure `membershipLocation` under google_gkehub_feature_membership.
         */
        membershipLocation?: pulumi.Input<string>;
        /**
         * Whether the cluster has been registered via the fleet API.
         */
        preRegistered?: pulumi.Input<boolean>;
        /**
         * The name of the Fleet host project where this cluster will be registered.
         */
        project?: pulumi.Input<string>;
    }

    export interface ClusterGatewayApiConfig {
        /**
         * Which Gateway Api channel should be used. `CHANNEL_DISABLED`, `CHANNEL_EXPERIMENTAL` or `CHANNEL_STANDARD`.
         */
        channel: pulumi.Input<string>;
    }

    export interface ClusterIdentityServiceConfig {
        /**
         * Whether to enable the Identity Service component. It is disabled by default. Set `enabled=true` to enable.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ClusterIpAllocationPolicy {
        /**
         * The configuration for additional pod secondary ranges at
         * the cluster level. Used for Autopilot clusters and Standard clusters with which control of the
         * secondary Pod IP address assignment to node pools isn't needed. Structure is documented below.
         */
        additionalPodRangesConfig?: pulumi.Input<inputs.container.ClusterIpAllocationPolicyAdditionalPodRangesConfig>;
        /**
         * The IP address range for the cluster pod IPs.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the existing secondary
         * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
         * `clusterIpv4CidrBlock` can be used to automatically create a GKE-managed one.
         */
        clusterSecondaryRangeName?: pulumi.Input<string>;
        /**
         * Configuration for cluster level pod cidr overprovision. Default is disabled=false.
         */
        podCidrOverprovisionConfig?: pulumi.Input<inputs.container.ClusterIpAllocationPolicyPodCidrOverprovisionConfig>;
        /**
         * The IP address range of the services IPs in this cluster.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the existing
         * secondary range in the cluster's subnetwork to use for service `ClusterIP`s.
         * Alternatively, `servicesIpv4CidrBlock` can be used to automatically create a
         * GKE-managed one.
         */
        servicesSecondaryRangeName?: pulumi.Input<string>;
        /**
         * The IP Stack Type of the cluster.
         * Default value is `IPV4`.
         * Possible values are `IPV4` and `IPV4_IPV6`.
         */
        stackType?: pulumi.Input<string>;
    }

    export interface ClusterIpAllocationPolicyAdditionalPodRangesConfig {
        /**
         * The names of the Pod ranges to add to the cluster.
         */
        podRangeNames: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterIpAllocationPolicyPodCidrOverprovisionConfig {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterLoggingConfig {
        /**
         * The GKE components exposing logs. Supported values include:
         * `SYSTEM_COMPONENTS`, `APISERVER`, `CONTROLLER_MANAGER`, `SCHEDULER`, and `WORKLOADS`.
         */
        enableComponents: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterMaintenancePolicy {
        /**
         * Time window specified for daily maintenance operations.
         * Specify `startTime` in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format "HH:MM,
         * where HH : \[00-23\] and MM : \[00-59\] GMT. For example:
         *
         * Examples:
         */
        dailyMaintenanceWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow>;
        /**
         * Exceptions to maintenance window. Non-emergency maintenance should not occur in these windows. A cluster can have up to 20 maintenance exclusions at a time [Maintenance Window and Exclusions](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions)
         */
        maintenanceExclusions?: pulumi.Input<pulumi.Input<inputs.container.ClusterMaintenancePolicyMaintenanceExclusion>[]>;
        /**
         * Time window for recurring maintenance operations.
         *
         * Specify `startTime` and `endTime` in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) "Zulu" date format.  The start time's date is
         * the initial date that the window starts, and the end time is used for calculating duration.  Specify `recurrence` in
         * [RFC5545](https://tools.ietf.org/html/rfc5545#section-3.8.5.3) RRULE format, to specify when this recurs.
         * Note that GKE may accept other formats, but will return values in UTC, causing a permanent diff.
         *
         * Examples:
         * ```
         * maintenance_policy {
         * recurring_window {
         * start_time = "2019-08-01T02:00:00Z"
         * end_time = "2019-08-01T06:00:00Z"
         * recurrence = "FREQ=DAILY"
         * }
         * }
         * ```
         *
         * ```
         * maintenance_policy {
         * recurring_window {
         * start_time = "2019-01-01T09:00:00Z"
         * end_time = "2019-01-01T17:00:00Z"
         * recurrence = "FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR"
         * }
         * }
         * ```
         */
        recurringWindow?: pulumi.Input<inputs.container.ClusterMaintenancePolicyRecurringWindow>;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        /**
         * Duration of the time window, automatically chosen to be
         * smallest possible in the given scenario.
         * Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format "PTnHnMnS".
         */
        duration?: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyMaintenanceExclusion {
        endTime: pulumi.Input<string>;
        exclusionName: pulumi.Input<string>;
        /**
         * MaintenanceExclusionOptions provides maintenance exclusion related options.
         */
        exclusionOptions?: pulumi.Input<inputs.container.ClusterMaintenancePolicyMaintenanceExclusionExclusionOptions>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyMaintenanceExclusionExclusionOptions {
        /**
         * The scope of automatic upgrades to restrict in the exclusion window. One of: **NO_UPGRADES | NO_MINOR_UPGRADES | NO_MINOR_OR_NODE_UPGRADES**
         *
         * Specify `startTime` and `endTime` in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) "Zulu" date format.  The start time's date is
         * the initial date that the window starts, and the end time is used for calculating duration.Specify `recurrence` in
         * [RFC5545](https://tools.ietf.org/html/rfc5545#section-3.8.5.3) RRULE format, to specify when this recurs.
         * Note that GKE may accept other formats, but will return values in UTC, causing a permanent diff.
         *
         * Examples:
         *
         * ```
         * maintenance_policy {
         * recurring_window {
         * start_time = "2019-01-01T00:00:00Z"
         * end_time = "2019-01-02T00:00:00Z"
         * recurrence = "FREQ=DAILY"
         * }
         * maintenance_exclusion{
         * exclusion_name = "batch job"
         * start_time = "2019-01-01T00:00:00Z"
         * end_time = "2019-01-02T00:00:00Z"
         * exclusion_options {
         * scope = "NO_UPGRADES"
         * }
         * }
         * maintenance_exclusion{
         * exclusion_name = "holiday data load"
         * start_time = "2019-05-01T00:00:00Z"
         * end_time = "2019-05-02T00:00:00Z"
         * exclusion_options {
         * scope = "NO_MINOR_UPGRADES"
         * }
         * }
         * }
         * ```
         */
        scope: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: pulumi.Input<string>;
        recurrence: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMasterAuth {
        /**
         * Base64 encoded public certificate
         * used by clients to authenticate to the cluster endpoint.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * Whether client certificate authorization is enabled for this cluster.  For example:
         */
        clientCertificateConfig: pulumi.Input<inputs.container.ClusterMasterAuthClientCertificateConfig>;
        /**
         * Base64 encoded private key used by clients
         * to authenticate to the cluster endpoint.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * Base64 encoded public certificate
         * that is the root certificate of the cluster.
         */
        clusterCaCertificate?: pulumi.Input<string>;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        /**
         * Whether client certificate authorization is enabled for this cluster.
         */
        issueClientCertificate: pulumi.Input<boolean>;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        /**
         * External networks that can access the
         * Kubernetes cluster master through HTTPS.
         */
        cidrBlocks?: pulumi.Input<pulumi.Input<inputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock>[]>;
        /**
         * Whether Kubernetes master is
         * accessible via Google Compute Engine Public IPs.
         */
        gcpPublicCidrsAccessEnabled?: pulumi.Input<boolean>;
        /**
         * Whether authorized networks is enforced on the private endpoint or not.
         */
        privateEndpointEnforcementEnabled?: pulumi.Input<boolean>;
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        /**
         * External network that can access Kubernetes master through HTTPS.
         * Must be specified in CIDR notation.
         */
        cidrBlock: pulumi.Input<string>;
        /**
         * Field for users to identify CIDR blocks.
         */
        displayName?: pulumi.Input<string>;
    }

    export interface ClusterMeshCertificates {
        /**
         * Controls the issuance of workload mTLS certificates. It is enabled by default. Workload Identity is required, see workload_config.
         */
        enableCertificates: pulumi.Input<boolean>;
    }

    export interface ClusterMonitoringConfig {
        /**
         * Configuration for Advanced Datapath Monitoring. Structure is documented below.
         */
        advancedDatapathObservabilityConfig?: pulumi.Input<inputs.container.ClusterMonitoringConfigAdvancedDatapathObservabilityConfig>;
        /**
         * The GKE components exposing metrics. Supported values include: `SYSTEM_COMPONENTS`, `APISERVER`, `SCHEDULER`, `CONTROLLER_MANAGER`, `STORAGE`, `HPA`, `POD`, `DAEMONSET`, `DEPLOYMENT`, `STATEFULSET`, `KUBELET`, `CADVISOR`, `DCGM` and `JOBSET`. In beta provider, `WORKLOADS` is supported on top of those 12 values. (`WORKLOADS` is deprecated and removed in GKE 1.24.) `KUBELET` and `CADVISOR` are only supported in GKE 1.29.3-gke.1093000 and above. `JOBSET` is only supported in GKE 1.32.1-gke.1357001 and above.
         */
        enableComponents?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration for Managed Service for Prometheus. Structure is documented below.
         */
        managedPrometheus?: pulumi.Input<inputs.container.ClusterMonitoringConfigManagedPrometheus>;
    }

    export interface ClusterMonitoringConfigAdvancedDatapathObservabilityConfig {
        /**
         * Whether or not to enable advanced datapath metrics.
         */
        enableMetrics: pulumi.Input<boolean>;
        /**
         * Whether or not Relay is enabled.
         */
        enableRelay: pulumi.Input<boolean>;
    }

    export interface ClusterMonitoringConfigManagedPrometheus {
        /**
         * Configuration options for GKE Auto-Monitoring.
         */
        autoMonitoringConfig?: pulumi.Input<inputs.container.ClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig>;
        /**
         * Whether or not the managed collection is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterMonitoringConfigManagedPrometheusAutoMonitoringConfig {
        /**
         * Whether or not to enable GKE Auto-Monitoring. Supported values include: `ALL`, `NONE`.
         */
        scope: pulumi.Input<string>;
    }

    export interface ClusterNetworkPolicy {
        /**
         * Whether network policy is enabled on the cluster.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
         */
        provider?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfig {
        /**
         * Specifies options for controlling
         * advanced machine features. Structure is documented below.
         */
        advancedMachineFeatures?: pulumi.Input<inputs.container.ClusterNodeConfigAdvancedMachineFeatures>;
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Configuration for Confidential Nodes feature. Structure is documented below.
         */
        confidentialNodes?: pulumi.Input<inputs.container.ClusterNodeConfigConfidentialNodes>;
        /**
         * Parameters to customize containerd runtime. Structure is documented below.
         */
        containerdConfig?: pulumi.Input<inputs.container.ClusterNodeConfigContainerdConfig>;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType?: pulumi.Input<string>;
        /**
         * List of kubernetes taints applied to each node. Structure is documented above.
         */
        effectiveTaints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigEffectiveTaint>[]>;
        /**
         * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
         */
        enableConfidentialStorage?: pulumi.Input<boolean>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         */
        ephemeralStorageConfig?: pulumi.Input<inputs.container.ClusterNodeConfigEphemeralStorageConfig>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         */
        ephemeralStorageLocalSsdConfig?: pulumi.Input<inputs.container.ClusterNodeConfigEphemeralStorageLocalSsdConfig>;
        /**
         * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
         * Node Pool must enable gvnic.
         * GKE version 1.25.2-gke.1700 or later.
         * Structure is documented below.
         */
        fastSocket?: pulumi.Input<inputs.container.ClusterNodeConfigFastSocket>;
        /**
         * ) Enables Flex Start provisioning model for the node pool.
         */
        flexStart?: pulumi.Input<boolean>;
        /**
         * Parameters for the Google Container Filesystem (GCFS).
         * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion` from GKE versions 1.19 or later to use it.
         * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum `nodeVersion` would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
         * A `machineType` that has more than 16 GiB of memory is also recommended.
         * GCFS must be enabled in order to use [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming).
         * Structure is documented below.
         */
        gcfsConfig?: pulumi.Input<inputs.container.ClusterNodeConfigGcfsConfig>;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigGuestAccelerator>[]>;
        /**
         * Google Virtual NIC (gVNIC) is a virtual network interface.
         * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
         * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
         * GKE node version 1.15.11-gke.15 or later
         * Structure is documented below.
         */
        gvnic?: pulumi.Input<inputs.container.ClusterNodeConfigGvnic>;
        /**
         * The maintenance policy for the hosts on which the GKE VMs run on.
         */
        hostMaintenancePolicy?: pulumi.Input<inputs.container.ClusterNodeConfigHostMaintenancePolicy>;
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType?: pulumi.Input<string>;
        /**
         * Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Structure is documented below.
         *
         * ```
         * kubelet_config {
         * cpu_manager_policy   = "static"
         * cpu_cfs_quota        = true
         * cpu_cfs_quota_period = "100us"
         * pod_pids_limit       = 1024
         * }
         * ```
         */
        kubeletConfig?: pulumi.Input<inputs.container.ClusterNodeConfigKubeletConfig>;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
         * reserved by Kubernetes Core components and cannot be specified.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Parameters that can be configured on Linux nodes. Structure is documented below.
         */
        linuxNodeConfig?: pulumi.Input<inputs.container.ClusterNodeConfigLinuxNodeConfig>;
        /**
         * Parameters for the local NVMe SSDs. Structure is documented below.
         */
        localNvmeSsdBlockConfig?: pulumi.Input<inputs.container.ClusterNodeConfigLocalNvmeSsdBlockConfig>;
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * Possible Local SSD encryption modes:
         * Accepted values are:
         * * `STANDARD_ENCRYPTION`: The given node will be encrypted using keys managed by Google infrastructure and the keys wll be deleted when the node is deleted.
         * * `EPHEMERAL_KEY_ENCRYPTION`: The given node will opt-in for using ephemeral key for encrypting Local SSDs. The Local SSDs will not be able to recover data in case of node crash.
         */
        localSsdEncryptionMode?: pulumi.Input<string>;
        /**
         * Parameter for specifying the type of logging agent used in a node pool. This will override any cluster-wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
         */
        loggingVariant?: pulumi.Input<string>;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
         */
        maxRunDuration?: pulumi.Input<string>;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         */
        nodeGroup?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account.
         * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set `serviceAccount` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         *
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/access-scopes) for information on migrating off of legacy access scopes.
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
         */
        reservationAffinity?: pulumi.Input<inputs.container.ClusterNodeConfigReservationAffinity>;
        /**
         * The GCP labels (key/value pairs) to be applied to each node. Refer [here](https://cloud.google.com/kubernetes-engine/docs/how-to/creating-managing-labels)
         * for how these labels are applied to clusters, node pools and nodes.
         */
        resourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found [here](https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications). A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}` 2. `{org_id}/{tag_key_name}={tag_value_name}` 3. `{project_id}/{tag_key_name}={tag_value_name}`.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Sandbox configuration for this node.
         */
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodeConfigSandboxConfig>;
        /**
         * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. `gcfsConfig` must be `enabled=true` for this feature to work. `minMasterVersion` must also be set to use GKE 1.28.3-gke.106700 or later versions.
         */
        secondaryBootDisks?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigSecondaryBootDisk>[]>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodeConfigShieldedInstanceConfig>;
        /**
         * Allows specifying multiple [node affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity) useful for running workloads on [sole tenant nodes](https://cloud.google.com/kubernetes-engine/docs/how-to/sole-tenancy). `nodeAffinity` structure is documented below.
         */
        soleTenantConfig?: pulumi.Input<inputs.container.ClusterNodeConfigSoleTenantConfig>;
        /**
         * A boolean that represents whether the underlying node VMs are spot.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
         * for more information. Defaults to false.
         */
        spot?: pulumi.Input<boolean>;
        /**
         * The list of Storage Pools where boot disks are provisioned.
         */
        storagePools?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigTaint>[]>;
        /**
         * Windows node configuration, currently supporting OSVersion [attribute](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/NodeConfig#osversion). The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
         */
        windowsNodeConfig?: pulumi.Input<inputs.container.ClusterNodeConfigWindowsNodeConfig>;
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodeConfigAdvancedMachineFeatures {
        /**
         * Defines whether the instance should have nested virtualization enabled. Defaults to false.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
         */
        threadsPerCore: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigConfidentialNodes {
        /**
         * Enable Confidential GKE Nodes for this cluster, to
         * enforce encryption of data in-use.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigContainerdConfig {
        /**
         * Configuration for private container registries. There are two fields in this config:
         */
        privateRegistryAccessConfig?: pulumi.Input<inputs.container.ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig>;
    }

    export interface ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfig {
        /**
         * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See [how to configure for private container registries](https://cloud.google.com/kubernetes-engine/docs/how-to/access-private-registries-private-certificates) for more detail. Example:
         */
        certificateAuthorityDomainConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>[]>;
        /**
         * Enables private registry config. If set to false, all other fields in this object must not be set.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
        /**
         * List of fully-qualified-domain-names. IPv4s and port specification are supported.
         */
        fqdns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters for configuring a certificate hosted in GCP SecretManager.
         */
        gcpSecretManagerCertificateConfig: pulumi.Input<inputs.container.ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>;
    }

    export interface ClusterNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
        /**
         * URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.
         */
        secretUri: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigEffectiveTaint {
        /**
         * Effect for taint.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key?: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigEphemeralStorageConfig {
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigEphemeralStorageLocalSsdConfig {
        /**
         * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
         */
        dataCacheCount?: pulumi.Input<number>;
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigFastSocket {
        /**
         * Whether or not the NCCL Fast Socket is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigGcfsConfig {
        /**
         * Whether or not the Google Container Filesystem (GCFS) is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * Configuration for auto installation of GPU driver. Structure is documented below.
         */
        gpuDriverInstallationConfig?: pulumi.Input<inputs.container.ClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig>;
        /**
         * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig [user guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
         */
        gpuPartitionSize?: pulumi.Input<string>;
        /**
         * Configuration for GPU sharing. Structure is documented below.
         */
        gpuSharingConfig?: pulumi.Input<inputs.container.ClusterNodeConfigGuestAcceleratorGpuSharingConfig>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
        /**
         * Mode for how the GPU driver is installed.
         * Accepted values are:
         * * `"GPU_DRIVER_VERSION_UNSPECIFIED"`: Default value is to install the "Default" GPU driver. Before GKE `1.30.1-gke.1156000`, the default value is to not install any GPU driver.
         * * `"INSTALLATION_DISABLED"`: Disable GPU driver auto installation and needs manual installation.
         * * `"DEFAULT"`: "Default" GPU driver in COS and Ubuntu.
         * * `"LATEST"`: "Latest" GPU driver in COS.
         */
        gpuDriverVersion: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigGuestAcceleratorGpuSharingConfig {
        /**
         * The type of GPU sharing strategy to enable on the GPU node.
         * Accepted values are:
         * * `"TIME_SHARING"`: Allow multiple containers to have [time-shared](https://cloud.google.com/kubernetes-engine/docs/concepts/timesharing-gpus) access to a single GPU device.
         * * `"MPS"`: Enable co-operative multi-process CUDA workloads to run concurrently on a single GPU device with [MPS](https://cloud.google.com/kubernetes-engine/docs/how-to/nvidia-mps-gpus)
         */
        gpuSharingStrategy: pulumi.Input<string>;
        /**
         * The maximum number of containers that can share a GPU.
         */
        maxSharedClientsPerGpu: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigGvnic {
        /**
         * Whether or not the Google Virtual NIC (gVNIC) is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigHostMaintenancePolicy {
        /**
         * .
         */
        maintenanceInterval: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigKubeletConfig {
        /**
         * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are `kernel.shm*`, `kernel.msg*`, `kernel.sem`, `fs.mqueue.*`, and `net.*`.
         */
        allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
         */
        containerLogMaxFiles?: pulumi.Input<number>;
        /**
         * Defines the maximum size of the
         * container log file before it is rotated. Specified as a positive number and a
         * unit suffix, such as `"100Ki"`, `"10Mi"`. Valid units are "Ki", "Mi", "Gi".
         * The value must be between `"10Mi"` and `"500Mi"`, inclusive. And the total container log size
         * (`containerLogMaxSize` * `containerLogMaxFiles`) cannot exceed 1% of the total storage of the node.
         */
        containerLogMaxSize?: pulumi.Input<string>;
        /**
         * If true, enables CPU CFS quota enforcement for
         * containers that specify CPU limits.
         */
        cpuCfsQuota?: pulumi.Input<boolean>;
        /**
         * The CPU CFS quota period value. Specified
         * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
         * such as `"300ms"`. Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
         * "h". The value must be a positive duration.
         */
        cpuCfsQuotaPeriod?: pulumi.Input<string>;
        /**
         * The CPU management policy on the node. See
         * [K8S CPU Management Policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/).
         * One of `"none"` or `"static"`. If unset (or set to the empty string `""`), the API will treat the field as if set to "none".
         * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
         * is setting the empty string `""`, which will function identically to not setting this field.
         */
        cpuManagerPolicy?: pulumi.Input<string>;
        /**
         * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
         */
        imageGcHighThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
         */
        imageGcLowThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as `"300s"`, `"1.5m"`, and `"2h45m"`. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
         */
        imageMaximumGcAge?: pulumi.Input<string>;
        /**
         * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as `"300s"`, `"1.5m"`. The value cannot be greater than "2m".
         */
        imageMinimumGcAge?: pulumi.Input<string>;
        /**
         * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         */
        insecureKubeletReadonlyPortEnabled?: pulumi.Input<string>;
        /**
         * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
         */
        podPidsLimit?: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigLinuxNodeConfig {
        /**
         * Possible cgroup modes that can be used.
         * Accepted values are:
         * * `CGROUP_MODE_UNSPECIFIED`: CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used. The default for the GKE node OS image will be used.
         * * `CGROUP_MODE_V1`: CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on the node image.
         * * `CGROUP_MODE_V2`: CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on the node image.
         */
        cgroupMode?: pulumi.Input<string>;
        /**
         * Amounts for 2M and 1G hugepages. Structure is documented below.
         */
        hugepagesConfig?: pulumi.Input<inputs.container.ClusterNodeConfigLinuxNodeConfigHugepagesConfig>;
        /**
         * The Linux kernel parameters to be applied to the nodes
         * and all pods running on the nodes. Specified as a map from the key, such as
         * `net.core.wmem_max`, to a string value. Currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Note that validations happen all server side. All attributes are optional.
         */
        sysctls?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ClusterNodeConfigLinuxNodeConfigHugepagesConfig {
        /**
         * Amount of 1G hugepages.
         */
        hugepageSize1g?: pulumi.Input<number>;
        /**
         * Amount of 2M hugepages.
         */
        hugepageSize2m?: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigLocalNvmeSsdBlockConfig {
        /**
         * Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. If zero, it means no raw-block local NVMe SSD disks to be attached to the node.
         * > Note: Local NVMe SSD storage available in GKE versions v1.25.3-gke.1800 and later.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodeConfigReservationAffinity {
        /**
         * The type of reservation consumption
         * Accepted values are:
         *
         * * `"UNSPECIFIED"`: Default value. This should not be used.
         * * `"NO_RESERVATION"`: Do not consume from any reserved capacity.
         * * `"ANY_RESERVATION"`: Consume any reservation available.
         * * `"SPECIFIC_RESERVATION"`: Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
         */
        consumeReservationType: pulumi.Input<string>;
        /**
         * The label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify "compute.googleapis.com/reservation-name" as the key and specify the name of your reservation as its value.
         */
        key?: pulumi.Input<string>;
        /**
         * The list of label values of reservation resources. For example: the name of the specific reservation when using a key of "compute.googleapis.com/reservation-name"
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         *
         * * `"gvisor"`: Pods run within a gVisor sandbox.
         */
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigSecondaryBootDisk {
        /**
         * Path to disk image to create the secondary boot disk from. After using the [gke-disk-image-builder](https://github.com/GoogleCloudPlatform/ai-on-gke/tree/main/tools/gke-disk-image-builder), this argument should be `global/images/DISK_IMAGE_NAME`.
         */
        diskImage: pulumi.Input<string>;
        /**
         * Mode for how the secondary boot disk is used. An example mode is `CONTAINER_IMAGE_CACHE`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         *
         * Enables monitoring and attestation of the boot integrity of the instance. The attestation is performed against the integrity policy baseline. This baseline is initially derived from the implicitly trusted boot image when the instance is created.  Defaults to `true`.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines if the instance has Secure Boot enabled.
         *
         * Secure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails.  Defaults to `false`.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodeConfigSoleTenantConfig {
        /**
         * .
         */
        nodeAffinities: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigSoleTenantConfigNodeAffinity>[]>;
    }

    export interface ClusterNodeConfigSoleTenantConfigNodeAffinity {
        /**
         * The default or custom node affinity label key name.
         */
        key: pulumi.Input<string>;
        /**
         * Specifies affinity or anti-affinity. Accepted values are `"IN"` or `"NOT_IN"`
         */
        operator: pulumi.Input<string>;
        /**
         * List of node affinity label values as strings.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigWindowsNodeConfig {
        /**
         * The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022
         */
        osversion?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * GCE_METADATA: Expose all Compute Engine metadata to pods.
         * * GKE_METADATA: Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) is enabled at the cluster level.
         */
        mode: pulumi.Input<string>;
    }

    export interface ClusterNodePool {
        /**
         * Configuration required by cluster autoscaler to adjust the size of the node pool to the current cluster usage.
         */
        autoscaling?: pulumi.Input<inputs.container.ClusterNodePoolAutoscaling>;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount?: pulumi.Input<number>;
        /**
         * The resource URLs of the managed instance groups associated with this node pool.
         */
        instanceGroupUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of instance group URLs which have been assigned to this node pool.
         */
        managedInstanceGroupUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Node management configuration, wherein auto-repair and auto-upgrade is configured.
         */
        management?: pulumi.Input<inputs.container.ClusterNodePoolManagement>;
        /**
         * The maximum number of pods per node in this node pool. Note that this does not work on node pools which are "route-based" - that is, node pools belonging to clusters that do not have IP Aliasing enabled.
         */
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the cluster, unique within the project and
         * location.
         *
         * - - -
         */
        name?: pulumi.Input<string>;
        /**
         * Creates a unique name for the node pool beginning with the specified prefix. Conflicts with name.
         */
        namePrefix?: pulumi.Input<string>;
        /**
         * Configuration for
         * [Adding Pod IP address ranges](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-pod-cidr)) to the node pool. Structure is documented below
         */
        networkConfig?: pulumi.Input<inputs.container.ClusterNodePoolNetworkConfig>;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used.
         * Structure is documented below.
         */
        nodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfig>;
        /**
         * The number of nodes per instance group. This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling.
         */
        nodeCount?: pulumi.Input<number>;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         *
         * > A "multi-zonal" cluster is a zonal cluster with at least one additional zone
         * defined; in a multi-zonal cluster, the cluster master is only present in a
         * single zone while nodes are present in each of the primary zone and the node
         * locations. In contrast, in a regional cluster, cluster master nodes are present
         * in multiple zones in the region. For that reason, regional clusters should be
         * preferred.
         */
        nodeLocations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the node placement policy
         */
        placementPolicy?: pulumi.Input<inputs.container.ClusterNodePoolPlacementPolicy>;
        /**
         * Specifies the configuration of queued provisioning
         */
        queuedProvisioning?: pulumi.Input<inputs.container.ClusterNodePoolQueuedProvisioning>;
        /**
         * Specify node upgrade settings to change how many nodes GKE attempts to upgrade at once. The number of nodes upgraded simultaneously is the sum of maxSurge and max_unavailable. The maximum number of nodes upgraded simultaneously is limited to 20.
         */
        upgradeSettings?: pulumi.Input<inputs.container.ClusterNodePoolUpgradeSettings>;
        version?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoConfig {
        /**
         * Linux system configuration for the cluster's automatically provisioned node pools. Only `cgroupMode` field is supported in `nodePoolAutoConfig`. Structure is documented below.
         */
        linuxNodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolAutoConfigLinuxNodeConfig>;
        /**
         * The network tag config for the cluster's automatically provisioned node pools. Structure is documented below.
         */
        networkTags?: pulumi.Input<inputs.container.ClusterNodePoolAutoConfigNetworkTags>;
        /**
         * Kubelet configuration for Autopilot clusters. Currently, only `insecureKubeletReadonlyPortEnabled` is supported here.
         * Structure is documented below.
         */
        nodeKubeletConfig?: pulumi.Input<inputs.container.ClusterNodePoolAutoConfigNodeKubeletConfig>;
        /**
         * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found [here](https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications). A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}` 2. `{org_id}/{tag_key_name}={tag_value_name}` 3. `{project_id}/{tag_key_name}={tag_value_name}`.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ClusterNodePoolAutoConfigLinuxNodeConfig {
        /**
         * Possible cgroup modes that can be used.
         * Accepted values are:
         * * `CGROUP_MODE_UNSPECIFIED`: CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used. The default for the GKE node OS image will be used.
         * * `CGROUP_MODE_V1`: CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on the node image.
         * * `CGROUP_MODE_V2`: CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on the node image.
         */
        cgroupMode?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoConfigNetworkTags {
        /**
         * List of network tags applied to auto-provisioned node pools.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterNodePoolAutoConfigNodeKubeletConfig {
        /**
         * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         */
        insecureKubeletReadonlyPortEnabled?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoscaling {
        /**
         * Location policy specifies the algorithm used when scaling-up the node pool. "BALANCED" - Is a best effort policy that aims to balance the sizes of available zones. "ANY" - Instructs the cluster autoscaler to prioritize utilization of unused reservations, and reduces preemption risk for Spot VMs.
         */
        locationPolicy?: pulumi.Input<string>;
        /**
         * Maximum number of nodes per zone in the node pool. Must be >= min_node_count. Cannot be used with total limits.
         */
        maxNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of nodes per zone in the node pool. Must be >=0 and <= max_node_count. Cannot be used with total limits.
         */
        minNodeCount?: pulumi.Input<number>;
        /**
         * Maximum number of all nodes in the node pool. Must be >= total_min_node_count. Cannot be used with per zone limits.
         */
        totalMaxNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of all nodes in the node pool. Must be >=0 and <= total_max_node_count. Cannot be used with per zone limits.
         */
        totalMinNodeCount?: pulumi.Input<number>;
    }

    export interface ClusterNodePoolDefaults {
        /**
         * Subset of NodeConfig message that has defaults.
         */
        nodeConfigDefaults?: pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaults>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaults {
        /**
         * Parameters for containerd configuration.
         */
        containerdConfig?: pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig>;
        /**
         * The default Google Container Filesystem (GCFS) configuration at the cluster level. e.g. enable [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming) across all the node pools within the cluster. Structure is documented below.
         */
        gcfsConfig?: pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig>;
        /**
         * Controls whether the kubelet read-only port is enabled for newly created node pools in the cluster. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         */
        insecureKubeletReadonlyPortEnabled?: pulumi.Input<string>;
        /**
         * The type of logging agent that is deployed by default for newly created node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
         */
        loggingVariant?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfig {
        /**
         * Configuration for private container registries. There are two fields in this config:
         */
        privateRegistryAccessConfig?: pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfig {
        /**
         * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See [how to configure for private container registries](https://cloud.google.com/kubernetes-engine/docs/how-to/access-private-registries-private-certificates) for more detail. Example:
         */
        certificateAuthorityDomainConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>[]>;
        /**
         * Enables private registry config. If set to false, all other fields in this object must not be set.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
        /**
         * List of fully-qualified-domain-names. IPv4s and port specification are supported.
         */
        fqdns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters for configuring a certificate hosted in GCP SecretManager.
         */
        gcpSecretManagerCertificateConfig: pulumi.Input<inputs.container.ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaultsContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
        /**
         * URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.
         */
        secretUri: pulumi.Input<string>;
    }

    export interface ClusterNodePoolDefaultsNodeConfigDefaultsGcfsConfig {
        /**
         * Whether or not the Google Container Filesystem (GCFS) is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolManagement {
        /**
         * Specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.
         *
         * This block also contains several computed attributes, documented below.
         */
        autoRepair?: pulumi.Input<boolean>;
        /**
         * Specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.
         */
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNetworkConfig {
        /**
         * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface
         */
        additionalNodeNetworkConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNetworkConfigAdditionalNodeNetworkConfig>[]>;
        /**
         * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node
         */
        additionalPodNetworkConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNetworkConfigAdditionalPodNetworkConfig>[]>;
        /**
         * Whether to create a new range for pod IPs in this node pool. Defaults are provided for `podRange` and `podIpv4CidrBlock` if they are not specified.
         */
        createPodRange?: pulumi.Input<boolean>;
        /**
         * Whether nodes have internal IP addresses only.
         */
        enablePrivateNodes?: pulumi.Input<boolean>;
        /**
         * Network bandwidth tier configuration.
         */
        networkPerformanceConfig?: pulumi.Input<inputs.container.ClusterNodePoolNetworkConfigNetworkPerformanceConfig>;
        /**
         * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited
         */
        podCidrOverprovisionConfig?: pulumi.Input<inputs.container.ClusterNodePoolNetworkConfigPodCidrOverprovisionConfig>;
        /**
         * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
         */
        podIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The ID of the secondary range for pod IPs. If `createPodRange` is true, this ID is used for the new range. If `createPodRange` is false, uses an existing secondary range with this ID.
         */
        podRange?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNetworkConfigAdditionalNodeNetworkConfig {
        /**
         * The name or selfLink of the Google Compute Engine
         * network to which the cluster is connected. For Shared VPC, set this to the self link of the
         * shared network.
         */
        network?: pulumi.Input<string>;
        /**
         * The name or selfLink of the Google Compute Engine
         * subnetwork in which the cluster's instances are launched.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNetworkConfigAdditionalPodNetworkConfig {
        /**
         * The maximum number of pods per node which use this pod network.
         */
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the secondary range on the subnet which provides IP address for this pod range.
         */
        secondaryPodRange?: pulumi.Input<string>;
        /**
         * The name or selfLink of the Google Compute Engine
         * subnetwork in which the cluster's instances are launched.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNetworkConfigNetworkPerformanceConfig {
        /**
         * Specifies the total network bandwidth tier for the NodePool.
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNetworkConfigPodCidrOverprovisionConfig {
        /**
         * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules will be disabled when defaultSnatStatus is disabled.When disabled is set to false, default IP masquerade rules will be applied to the nodes to prevent sNAT on cluster internal traffic
         *
         * <a name="nestedClusterTelemetry"></a>The `clusterTelemetry` block supports
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfig {
        /**
         * Specifies options for controlling
         * advanced machine features. Structure is documented below.
         */
        advancedMachineFeatures?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigAdvancedMachineFeatures>;
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Configuration for Confidential Nodes feature. Structure is documented below.
         */
        confidentialNodes?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigConfidentialNodes>;
        /**
         * Parameters to customize containerd runtime. Structure is documented below.
         */
        containerdConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigContainerdConfig>;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard', 'pd-balanced' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType?: pulumi.Input<string>;
        /**
         * List of kubernetes taints applied to each node. Structure is documented above.
         */
        effectiveTaints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigEffectiveTaint>[]>;
        /**
         * Enabling Confidential Storage will create boot disk with confidential mode. It is disabled by default.
         */
        enableConfidentialStorage?: pulumi.Input<boolean>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         */
        ephemeralStorageConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigEphemeralStorageConfig>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
         */
        ephemeralStorageLocalSsdConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig>;
        /**
         * Parameters for the NCCL Fast Socket feature. If unspecified, NCCL Fast Socket will not be enabled on the node pool.
         * Node Pool must enable gvnic.
         * GKE version 1.25.2-gke.1700 or later.
         * Structure is documented below.
         */
        fastSocket?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigFastSocket>;
        /**
         * ) Enables Flex Start provisioning model for the node pool.
         */
        flexStart?: pulumi.Input<boolean>;
        /**
         * Parameters for the Google Container Filesystem (GCFS).
         * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion` from GKE versions 1.19 or later to use it.
         * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum `nodeVersion` would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
         * A `machineType` that has more than 16 GiB of memory is also recommended.
         * GCFS must be enabled in order to use [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming).
         * Structure is documented below.
         */
        gcfsConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGcfsConfig>;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAccelerator>[]>;
        /**
         * Google Virtual NIC (gVNIC) is a virtual network interface.
         * Installing the gVNIC driver allows for more efficient traffic transmission across the Google network infrastructure.
         * gVNIC is an alternative to the virtIO-based ethernet driver. GKE nodes must use a Container-Optimized OS node image.
         * GKE node version 1.15.11-gke.15 or later
         * Structure is documented below.
         */
        gvnic?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGvnic>;
        /**
         * The maintenance policy for the hosts on which the GKE VMs run on.
         */
        hostMaintenancePolicy?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigHostMaintenancePolicy>;
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType?: pulumi.Input<string>;
        /**
         * Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Structure is documented below.
         *
         * ```
         * kubelet_config {
         * cpu_manager_policy   = "static"
         * cpu_cfs_quota        = true
         * cpu_cfs_quota_period = "100us"
         * pod_pids_limit       = 1024
         * }
         * ```
         */
        kubeletConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigKubeletConfig>;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
         * reserved by Kubernetes Core components and cannot be specified.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Parameters that can be configured on Linux nodes. Structure is documented below.
         */
        linuxNodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigLinuxNodeConfig>;
        /**
         * Parameters for the local NVMe SSDs. Structure is documented below.
         */
        localNvmeSsdBlockConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig>;
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * Possible Local SSD encryption modes:
         * Accepted values are:
         * * `STANDARD_ENCRYPTION`: The given node will be encrypted using keys managed by Google infrastructure and the keys wll be deleted when the node is deleted.
         * * `EPHEMERAL_KEY_ENCRYPTION`: The given node will opt-in for using ephemeral key for encrypting Local SSDs. The Local SSDs will not be able to recover data in case of node crash.
         */
        localSsdEncryptionMode?: pulumi.Input<string>;
        /**
         * Parameter for specifying the type of logging agent used in a node pool. This will override any cluster-wide default value. Valid values include DEFAULT and MAX_THROUGHPUT. See [Increasing logging agent throughput](https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs#throughput) for more information.
         */
        loggingVariant?: pulumi.Input<string>;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
         */
        maxRunDuration?: pulumi.Input<string>;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         */
        nodeGroup?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account.
         * Use the "https://www.googleapis.com/auth/cloud-platform" scope to grant access to all APIs. It is recommended that you set `serviceAccount` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
         *
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/access-scopes) for information on migrating off of legacy access scopes.
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * The configuration of the desired reservation which instances could take capacity from. Structure is documented below.
         */
        reservationAffinity?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigReservationAffinity>;
        /**
         * The GCP labels (key/value pairs) to be applied to each node. Refer [here](https://cloud.google.com/kubernetes-engine/docs/how-to/creating-managing-labels)
         * for how these labels are applied to clusters, node pools and nodes.
         */
        resourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A map of resource manager tag keys and values to be attached to the nodes for managing Compute Engine firewalls using Network Firewall Policies. Tags must be according to specifications found [here](https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications). A maximum of 5 tag key-value pairs can be specified. Existing tags will be replaced with new values. Tags must be in one of the following formats ([KEY]=[VALUE]) 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}` 2. `{org_id}/{tag_key_name}={tag_value_name}` 3. `{project_id}/{tag_key_name}={tag_value_name}`.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Sandbox configuration for this node.
         */
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSandboxConfig>;
        /**
         * Parameters for secondary boot disks to preload container images and data on new nodes. Structure is documented below. `gcfsConfig` must be `enabled=true` for this feature to work. `minMasterVersion` must also be set to use GKE 1.28.3-gke.106700 or later versions.
         */
        secondaryBootDisks?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSecondaryBootDisk>[]>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig>;
        /**
         * Allows specifying multiple [node affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity) useful for running workloads on [sole tenant nodes](https://cloud.google.com/kubernetes-engine/docs/how-to/sole-tenancy). `nodeAffinity` structure is documented below.
         */
        soleTenantConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSoleTenantConfig>;
        /**
         * A boolean that represents whether the underlying node VMs are spot.
         * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
         * for more information. Defaults to false.
         */
        spot?: pulumi.Input<boolean>;
        /**
         * The list of Storage Pools where boot disks are provisioned.
         */
        storagePools?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigTaint>[]>;
        /**
         * Windows node configuration, currently supporting OSVersion [attribute](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/NodeConfig#osversion). The value must be one of [OS_VERSION_UNSPECIFIED, OS_VERSION_LTSC2019, OS_VERSION_LTSC2022]. For example:
         */
        windowsNodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigWindowsNodeConfig>;
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodePoolNodeConfigAdvancedMachineFeatures {
        /**
         * Defines whether the instance should have nested virtualization enabled. Defaults to false.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
         */
        threadsPerCore: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigConfidentialNodes {
        /**
         * Enable Confidential GKE Nodes for this cluster, to
         * enforce encryption of data in-use.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigContainerdConfig {
        /**
         * Configuration for private container registries. There are two fields in this config:
         */
        privateRegistryAccessConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig>;
    }

    export interface ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig {
        /**
         * List of configuration objects for CA and domains. Each object identifies a certificate and its assigned domains. See [how to configure for private container registries](https://cloud.google.com/kubernetes-engine/docs/how-to/access-private-registries-private-certificates) for more detail. Example:
         */
        certificateAuthorityDomainConfigs?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>[]>;
        /**
         * Enables private registry config. If set to false, all other fields in this object must not be set.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
        /**
         * List of fully-qualified-domain-names. IPv4s and port specification are supported.
         */
        fqdns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters for configuring a certificate hosted in GCP SecretManager.
         */
        gcpSecretManagerCertificateConfig: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>;
    }

    export interface ClusterNodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
        /**
         * URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.
         */
        secretUri: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigEffectiveTaint {
        /**
         * Effect for taint.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key?: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigEphemeralStorageConfig {
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigEphemeralStorageLocalSsdConfig {
        /**
         * Number of raw-block local NVMe SSD disks to be attached to the node utilized for GKE Data Cache. If zero, then GKE Data Cache will not be enabled in the nodes.
         */
        dataCacheCount?: pulumi.Input<number>;
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigFastSocket {
        /**
         * Whether or not the NCCL Fast Socket is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigGcfsConfig {
        /**
         * Whether or not the Google Container Filesystem (GCFS) is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: pulumi.Input<number>;
        /**
         * Configuration for auto installation of GPU driver. Structure is documented below.
         */
        gpuDriverInstallationConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig>;
        /**
         * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig [user guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
         */
        gpuPartitionSize?: pulumi.Input<string>;
        /**
         * Configuration for GPU sharing. Structure is documented below.
         */
        gpuSharingConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig>;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
        /**
         * Mode for how the GPU driver is installed.
         * Accepted values are:
         * * `"GPU_DRIVER_VERSION_UNSPECIFIED"`: Default value is to install the "Default" GPU driver. Before GKE `1.30.1-gke.1156000`, the default value is to not install any GPU driver.
         * * `"INSTALLATION_DISABLED"`: Disable GPU driver auto installation and needs manual installation.
         * * `"DEFAULT"`: "Default" GPU driver in COS and Ubuntu.
         * * `"LATEST"`: "Latest" GPU driver in COS.
         */
        gpuDriverVersion: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigGuestAcceleratorGpuSharingConfig {
        /**
         * The type of GPU sharing strategy to enable on the GPU node.
         * Accepted values are:
         * * `"TIME_SHARING"`: Allow multiple containers to have [time-shared](https://cloud.google.com/kubernetes-engine/docs/concepts/timesharing-gpus) access to a single GPU device.
         * * `"MPS"`: Enable co-operative multi-process CUDA workloads to run concurrently on a single GPU device with [MPS](https://cloud.google.com/kubernetes-engine/docs/how-to/nvidia-mps-gpus)
         */
        gpuSharingStrategy: pulumi.Input<string>;
        /**
         * The maximum number of containers that can share a GPU.
         */
        maxSharedClientsPerGpu: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigGvnic {
        /**
         * Whether or not the Google Virtual NIC (gVNIC) is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigHostMaintenancePolicy {
        /**
         * .
         */
        maintenanceInterval: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigKubeletConfig {
        /**
         * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods. The allowed sysctl groups are `kernel.shm*`, `kernel.msg*`, `kernel.sem`, `fs.mqueue.*`, and `net.*`.
         */
        allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Defines the maximum number of container log files that can be present for a container. The integer must be between 2 and 10, inclusive.
         */
        containerLogMaxFiles?: pulumi.Input<number>;
        /**
         * Defines the maximum size of the
         * container log file before it is rotated. Specified as a positive number and a
         * unit suffix, such as `"100Ki"`, `"10Mi"`. Valid units are "Ki", "Mi", "Gi".
         * The value must be between `"10Mi"` and `"500Mi"`, inclusive. And the total container log size
         * (`containerLogMaxSize` * `containerLogMaxFiles`) cannot exceed 1% of the total storage of the node.
         */
        containerLogMaxSize?: pulumi.Input<string>;
        /**
         * If true, enables CPU CFS quota enforcement for
         * containers that specify CPU limits.
         */
        cpuCfsQuota?: pulumi.Input<boolean>;
        /**
         * The CPU CFS quota period value. Specified
         * as a sequence of decimal numbers, each with optional fraction and a unit suffix,
         * such as `"300ms"`. Valid time units are "ns", "us" (or "s"), "ms", "s", "m",
         * "h". The value must be a positive duration.
         */
        cpuCfsQuotaPeriod?: pulumi.Input<string>;
        /**
         * The CPU management policy on the node. See
         * [K8S CPU Management Policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/).
         * One of `"none"` or `"static"`. If unset (or set to the empty string `""`), the API will treat the field as if set to "none".
         * Prior to the 6.4.0 this field was marked as required. The workaround for the required field
         * is setting the empty string `""`, which will function identically to not setting this field.
         */
        cpuManagerPolicy?: pulumi.Input<string>;
        /**
         * Defines the percent of disk usage after which image garbage collection is always run. The integer must be between 10 and 85, inclusive.
         */
        imageGcHighThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to. The integer must be between 10 and 85, inclusive.
         */
        imageGcLowThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the maximum age an image can be unused before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as `"300s"`, `"1.5m"`, and `"2h45m"`. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h". The value must be a positive duration.
         */
        imageMaximumGcAge?: pulumi.Input<string>;
        /**
         * Defines the minimum age for an unused image before it is garbage collected. Specified as a sequence of decimal numbers, each with optional fraction and a unit suffix, such as `"300s"`, `"1.5m"`. The value cannot be greater than "2m".
         */
        imageMinimumGcAge?: pulumi.Input<string>;
        /**
         * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         */
        insecureKubeletReadonlyPortEnabled?: pulumi.Input<string>;
        /**
         * Controls the maximum number of processes allowed to run in a pod. The value must be greater than or equal to 1024 and less than 4194304.
         */
        podPidsLimit?: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigLinuxNodeConfig {
        /**
         * Possible cgroup modes that can be used.
         * Accepted values are:
         * * `CGROUP_MODE_UNSPECIFIED`: CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used. The default for the GKE node OS image will be used.
         * * `CGROUP_MODE_V1`: CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on the node image.
         * * `CGROUP_MODE_V2`: CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on the node image.
         */
        cgroupMode?: pulumi.Input<string>;
        /**
         * Amounts for 2M and 1G hugepages. Structure is documented below.
         */
        hugepagesConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig>;
        /**
         * The Linux kernel parameters to be applied to the nodes
         * and all pods running on the nodes. Specified as a map from the key, such as
         * `net.core.wmem_max`, to a string value. Currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
         * Note that validations happen all server side. All attributes are optional.
         */
        sysctls?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ClusterNodePoolNodeConfigLinuxNodeConfigHugepagesConfig {
        /**
         * Amount of 1G hugepages.
         */
        hugepageSize1g?: pulumi.Input<number>;
        /**
         * Amount of 2M hugepages.
         */
        hugepageSize2m?: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigLocalNvmeSsdBlockConfig {
        /**
         * Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size. If zero, it means no raw-block local NVMe SSD disks to be attached to the node.
         * > Note: Local NVMe SSD storage available in GKE versions v1.25.3-gke.1800 and later.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolNodeConfigReservationAffinity {
        /**
         * The type of reservation consumption
         * Accepted values are:
         *
         * * `"UNSPECIFIED"`: Default value. This should not be used.
         * * `"NO_RESERVATION"`: Do not consume from any reserved capacity.
         * * `"ANY_RESERVATION"`: Consume any reservation available.
         * * `"SPECIFIC_RESERVATION"`: Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
         */
        consumeReservationType: pulumi.Input<string>;
        /**
         * The label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify "compute.googleapis.com/reservation-name" as the key and specify the name of your reservation as its value.
         */
        key?: pulumi.Input<string>;
        /**
         * The list of label values of reservation resources. For example: the name of the specific reservation when using a key of "compute.googleapis.com/reservation-name"
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         *
         * * `"gvisor"`: Pods run within a gVisor sandbox.
         */
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigSecondaryBootDisk {
        /**
         * Path to disk image to create the secondary boot disk from. After using the [gke-disk-image-builder](https://github.com/GoogleCloudPlatform/ai-on-gke/tree/main/tools/gke-disk-image-builder), this argument should be `global/images/DISK_IMAGE_NAME`.
         */
        diskImage: pulumi.Input<string>;
        /**
         * Mode for how the secondary boot disk is used. An example mode is `CONTAINER_IMAGE_CACHE`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         *
         * Enables monitoring and attestation of the boot integrity of the instance. The attestation is performed against the integrity policy baseline. This baseline is initially derived from the implicitly trusted boot image when the instance is created.  Defaults to `true`.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines if the instance has Secure Boot enabled.
         *
         * Secure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails.  Defaults to `false`.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfigSoleTenantConfig {
        /**
         * .
         */
        nodeAffinities: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity>[]>;
    }

    export interface ClusterNodePoolNodeConfigSoleTenantConfigNodeAffinity {
        /**
         * The default or custom node affinity label key name.
         */
        key: pulumi.Input<string>;
        /**
         * Specifies affinity or anti-affinity. Accepted values are `"IN"` or `"NOT_IN"`
         */
        operator: pulumi.Input<string>;
        /**
         * List of node affinity label values as strings.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigWindowsNodeConfig {
        /**
         * The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022
         */
        osversion?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * GCE_METADATA: Expose all Compute Engine metadata to pods.
         * * GKE_METADATA: Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) is enabled at the cluster level.
         */
        mode: pulumi.Input<string>;
    }

    export interface ClusterNodePoolPlacementPolicy {
        /**
         * If set, refers to the name of a custom resource policy supplied by the user. The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned.
         */
        policyName?: pulumi.Input<string>;
        /**
         * TPU placement topology for pod slice node pool. https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies
         */
        tpuTopology?: pulumi.Input<string>;
        /**
         * Telemetry integration for the cluster. Supported values (`ENABLED, DISABLED, SYSTEM_ONLY`);
         * `SYSTEM_ONLY` (Only system components are monitored and logged) is only available in GKE versions 1.15 and later.
         */
        type: pulumi.Input<string>;
    }

    export interface ClusterNodePoolQueuedProvisioning {
        /**
         * Whether nodes in this node pool are obtainable solely through the ProvisioningRequest API
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolUpgradeSettings {
        /**
         * Settings for blue-green upgrade strategy. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
         */
        blueGreenSettings?: pulumi.Input<inputs.container.ClusterNodePoolUpgradeSettingsBlueGreenSettings>;
        /**
         * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
         */
        maxSurge?: pulumi.Input<number>;
        /**
         * The maximum number of nodes that can be simultaneously unavailable during the upgrade process. To be used when strategy is set to SURGE. Default is 0.
         */
        maxUnavailable?: pulumi.Input<number>;
        /**
         * Strategy used for node pool update. Strategy can only be one of BLUE_GREEN or SURGE. The default is value is SURGE.
         */
        strategy?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolUpgradeSettingsBlueGreenSettings {
        /**
         * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        nodePoolSoakDuration?: pulumi.Input<string>;
        /**
         * Standard policy for the blue-green upgrade. To be specified when strategy is set to BLUE_GREEN. Structure is documented below.
         */
        standardRolloutPolicy: pulumi.Input<inputs.container.ClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>;
    }

    export interface ClusterNodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
        /**
         * Number of blue nodes to drain in a batch. Only one of the batchPercentage or batchNodeCount can be specified.
         */
        batchNodeCount?: pulumi.Input<number>;
        /**
         * Percentage of the bool pool nodes to drain in a batch. The range of this field should be (0.0, 1.0). Only one of the batchPercentage or batchNodeCount can be specified.
         */
        batchPercentage?: pulumi.Input<number>;
        /**
         * Soak time after each batch gets drained. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`.
         */
        batchSoakDuration?: pulumi.Input<string>;
    }

    export interface ClusterNotificationConfig {
        /**
         * The pubsub config for the cluster's upgrade notifications.
         */
        pubsub: pulumi.Input<inputs.container.ClusterNotificationConfigPubsub>;
    }

    export interface ClusterNotificationConfigPubsub {
        /**
         * Whether or not the notification config is enabled
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Choose what type of notifications you want to receive. If no filters are applied, you'll receive all notification types. Structure is documented below.
         */
        filter?: pulumi.Input<inputs.container.ClusterNotificationConfigPubsubFilter>;
        /**
         * The pubsub topic to push upgrade notifications to. Must be in the same project as the cluster. Must be in the format: `projects/{project}/topics/{topic}`.
         */
        topic?: pulumi.Input<string>;
    }

    export interface ClusterNotificationConfigPubsubFilter {
        /**
         * Can be used to filter what notifications are sent. Accepted values are `UPGRADE_AVAILABLE_EVENT`, `UPGRADE_EVENT`, `SECURITY_BULLETIN_EVENT` and `UPGRADE_INFO_EVENT`. See [Filtering notifications](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-notifications#filtering) for more details.
         */
        eventTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterPodAutoscaling {
        /**
         * Enable the Horizontal Pod Autoscaling profile for this cluster.
         * Acceptable values are:
         * * `"NONE"`: Customers explicitly opt-out of HPA profiles.
         * * `"PERFORMANCE"`: PERFORMANCE is used when customers opt-in to the performance HPA profile. In this profile we support a higher number of HPAs per cluster and faster metrics collection for workload autoscaling.
         * See [HPAProfile](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#hpaprofile) for more details.
         */
        hpaProfile: pulumi.Input<string>;
    }

    export interface ClusterPodSecurityPolicyConfig {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterPrivateClusterConfig {
        /**
         * When `true`, the cluster's private
         * endpoint is used as the cluster endpoint and access through the public endpoint
         * is disabled. When `false`, either endpoint can be used. This field only applies
         * to private clusters, when `enablePrivateNodes` is `true`.
         */
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        /**
         * Enables the private cluster feature,
         * creating a private endpoint on the cluster. In a private cluster, nodes only
         * have RFC 1918 private addresses and communicate with the master's private
         * endpoint via private networking.
         */
        enablePrivateNodes?: pulumi.Input<boolean>;
        /**
         * Controls cluster master global
         * access settings. If unset, the provider will no longer manage this field and will
         * not modify the previously-set value. Structure is documented below.
         */
        masterGlobalAccessConfig?: pulumi.Input<inputs.container.ClusterPrivateClusterConfigMasterGlobalAccessConfig>;
        /**
         * The IP range in CIDR notation to use for
         * the hosted master network. This range will be used for assigning private IP
         * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
         * with any other ranges in use within the cluster's network, and it must be a /28
         * subnet. See [Private Cluster Limitations](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#req_res_lim)
         * for more details. This field only applies to private clusters, when
         * `enablePrivateNodes` is `true`.
         */
        masterIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The name of the peering between this cluster and the Google owned VPC.
         */
        peeringName?: pulumi.Input<string>;
        /**
         * The internal IP address of this cluster's master endpoint.
         */
        privateEndpoint?: pulumi.Input<string>;
        /**
         * Subnetwork in cluster's network where master's endpoint will be provisioned.
         */
        privateEndpointSubnetwork?: pulumi.Input<string>;
        /**
         * The external IP address of this cluster's master endpoint.
         *
         * !> The Google provider is unable to validate certain configurations of
         * `privateClusterConfig` when `enablePrivateNodes` is `false`. It's
         * recommended that you omit the block entirely if the field is not set to `true`.
         */
        publicEndpoint?: pulumi.Input<string>;
    }

    export interface ClusterPrivateClusterConfigMasterGlobalAccessConfig {
        /**
         * Whether the cluster master is accessible globally or
         * not.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterProtectConfig {
        /**
         * WorkloadConfig defines which actions are enabled for a cluster's workload configurations. Structure is documented below
         */
        workloadConfig?: pulumi.Input<inputs.container.ClusterProtectConfigWorkloadConfig>;
        /**
         * Sets which mode to use for Protect workload vulnerability scanning feature. Accepted values are DISABLED, BASIC.
         */
        workloadVulnerabilityMode?: pulumi.Input<string>;
    }

    export interface ClusterProtectConfigWorkloadConfig {
        /**
         * Sets which mode of auditing should be used for the cluster's workloads. Accepted values are DISABLED, BASIC.
         */
        auditMode: pulumi.Input<string>;
    }

    export interface ClusterReleaseChannel {
        /**
         * The selected release channel.
         * Accepted values are:
         * * UNSPECIFIED: Not set.
         * * RAPID: Weekly upgrade cadence; Early testers and developers who requires new features.
         * * REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel.
         * * STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky.
         * * EXTENDED: GKE provides extended support for Kubernetes minor versions through the Extended channel. With this channel, you can stay on a minor version for up to 24 months.
         */
        channel: pulumi.Input<string>;
    }

    export interface ClusterResourceUsageExportConfig {
        /**
         * Parameters for using BigQuery as the destination of resource usage export.
         *
         * * `bigquery_destination.dataset_id` (Required) - The ID of a BigQuery Dataset. For Example:
         */
        bigqueryDestination: pulumi.Input<inputs.container.ClusterResourceUsageExportConfigBigqueryDestination>;
        /**
         * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
         * in the cluster to meter network egress traffic.
         */
        enableNetworkEgressMetering?: pulumi.Input<boolean>;
        /**
         * Whether to enable resource
         * consumption metering on this cluster. When enabled, a table will be created in
         * the resource export BigQuery dataset to store resource consumption data. The
         * resulting table can be joined with the resource usage table or with BigQuery
         * billing export. Defaults to `true`.
         */
        enableResourceConsumptionMetering?: pulumi.Input<boolean>;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        /**
         * The ID of a BigQuery Dataset.
         */
        datasetId: pulumi.Input<string>;
    }

    export interface ClusterSecretManagerConfig {
        /**
         * Enable the Secret Manager add-on for this cluster.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterSecurityPostureConfig {
        /**
         * Sets the mode of the Kubernetes security posture API's off-cluster features. Available options include `DISABLED`, `BASIC`, and `ENTERPRISE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Sets the mode of the Kubernetes security posture API's workload vulnerability scanning. Available options include `VULNERABILITY_DISABLED`, `VULNERABILITY_BASIC` and `VULNERABILITY_ENTERPRISE`.
         */
        vulnerabilityMode?: pulumi.Input<string>;
    }

    export interface ClusterServiceExternalIpsConfig {
        /**
         * Controls whether external ips specified by a service will be allowed. It is enabled by default.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterTpuConfig {
        /**
         * Whether Cloud TPU integration is enabled or not
         */
        enabled: pulumi.Input<boolean>;
        /**
         * IPv4 CIDR block reserved for Cloud TPU in the VPC.
         */
        ipv4CidrBlock?: pulumi.Input<string>;
        /**
         * Whether to use service networking for Cloud TPU or not
         */
        useServiceNetworking?: pulumi.Input<boolean>;
    }

    export interface ClusterUserManagedKeysConfig {
        /**
         * The Certificate Authority Service caPool to use for the aggreation CA in this cluster.
         */
        aggregationCa?: pulumi.Input<string>;
        /**
         * The Certificate Authority Service caPool to use for the cluster CA in this cluster.
         */
        clusterCa?: pulumi.Input<string>;
        /**
         * The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control plane nodes.
         */
        controlPlaneDiskEncryptionKey?: pulumi.Input<string>;
        /**
         * The Certificate Authority Service caPool to use for the etcd API CA in this cluster.
         */
        etcdApiCa?: pulumi.Input<string>;
        /**
         * The Certificate Authority Service caPool to use for the etcd peer CA in this cluster.
         */
        etcdPeerCa?: pulumi.Input<string>;
        /**
         * Resource path of the Cloud KMS cryptoKey to use for encryption of internal etcd backups.
         */
        gkeopsEtcdBackupEncryptionKey?: pulumi.Input<string>;
        /**
         * The Cloud KMS cryptoKeyVersions to use for signing service account JWTs issued by this cluster.
         */
        serviceAccountSigningKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs issued by this cluster.
         */
        serviceAccountVerificationKeys?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterVerticalPodAutoscaling {
        /**
         * Enables vertical pod autoscaling
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterWorkloadAltsConfig {
        /**
         * Whether the alts handshaker should be enabled or not for direct-path. Requires Workload Identity (workloadPool) must be non-empty).
         */
        enableAlts: pulumi.Input<boolean>;
    }

    export interface ClusterWorkloadIdentityConfig {
        /**
         * The workload pool to attach all Kubernetes service accounts to.
         */
        workloadPool?: pulumi.Input<string>;
    }

    export interface NodePoolAutoscaling {
        /**
         * Location policy specifies the algorithm used when
         * scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.
         * * "BALANCED" - Is a best effort policy that aims to balance the sizes of available zones.
         * * "ANY" - Instructs the cluster autoscaler to prioritize utilization of unused reservations,
         * and reduce preemption risk for Spot VMs.
         */
        locationPolicy?: pulumi.Input<string>;
        /**
         * Maximum number of nodes per zone in the NodePool.
         * Must be >= min_node_count. Cannot be used with total limits.
         */
        maxNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of nodes per zone in the NodePool.
         * Must be >=0 and <= `maxNodeCount`. Cannot be used with total limits.
         */
        minNodeCount?: pulumi.Input<number>;
        /**
         * Total maximum number of nodes in the NodePool.
         * Must be >= total_min_node_count. Cannot be used with per zone limits.
         * Total size limits are supported only in 1.24.1+ clusters.
         */
        totalMaxNodeCount?: pulumi.Input<number>;
        /**
         * Total minimum number of nodes in the NodePool.
         * Must be >=0 and <= `totalMaxNodeCount`. Cannot be used with per zone limits.
         * Total size limits are supported only in 1.24.1+ clusters.
         */
        totalMinNodeCount?: pulumi.Input<number>;
    }

    export interface NodePoolManagement {
        /**
         * Whether the nodes will be automatically repaired. Enabled by default.
         */
        autoRepair?: pulumi.Input<boolean>;
        /**
         * Whether the nodes will be automatically upgraded. Enabled by default.
         */
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface NodePoolNetworkConfig {
        /**
         * We specify the additional node networks for this node pool using this list. Each node network corresponds to an additional interface.
         * Structure is documented below
         */
        additionalNodeNetworkConfigs?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNetworkConfigAdditionalNodeNetworkConfig>[]>;
        /**
         * We specify the additional pod networks for this node pool using this list. Each pod network corresponds to an additional alias IP range for the node.
         * Structure is documented below
         */
        additionalPodNetworkConfigs?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNetworkConfigAdditionalPodNetworkConfig>[]>;
        /**
         * Whether to create a new range for pod IPs in this node pool. Defaults are provided for `podRange` and `podIpv4CidrBlock` if they are not specified.
         */
        createPodRange?: pulumi.Input<boolean>;
        /**
         * Whether nodes have internal IP addresses only.
         */
        enablePrivateNodes?: pulumi.Input<boolean>;
        /**
         * Network bandwidth tier configuration. Structure is documented below.
         */
        networkPerformanceConfig?: pulumi.Input<inputs.container.NodePoolNetworkConfigNetworkPerformanceConfig>;
        /**
         * Configuration for node-pool level pod cidr overprovision. If not set, the cluster level setting will be inherited. Structure is documented below.
         */
        podCidrOverprovisionConfig?: pulumi.Input<inputs.container.NodePoolNetworkConfigPodCidrOverprovisionConfig>;
        /**
         * The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.
         */
        podIpv4CidrBlock?: pulumi.Input<string>;
        /**
         * The ID of the secondary range for pod IPs. If `createPodRange` is true, this ID is used for the new range. If `createPodRange` is false, uses an existing secondary range with this ID.
         */
        podRange?: pulumi.Input<string>;
    }

    export interface NodePoolNetworkConfigAdditionalNodeNetworkConfig {
        /**
         * Name of the VPC where the additional interface belongs.
         */
        network?: pulumi.Input<string>;
        /**
         * Name of the subnetwork where the additional interface belongs.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface NodePoolNetworkConfigAdditionalPodNetworkConfig {
        /**
         * The maximum number of pods per node which use this pod network.
         */
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the secondary range on the subnet which provides IP address for this pod range.
         */
        secondaryPodRange?: pulumi.Input<string>;
        /**
         * Name of the subnetwork where the additional pod network belongs.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface NodePoolNetworkConfigNetworkPerformanceConfig {
        /**
         * Specifies the total network bandwidth tier for the NodePool.
         */
        totalEgressBandwidthTier: pulumi.Input<string>;
    }

    export interface NodePoolNetworkConfigPodCidrOverprovisionConfig {
        /**
         * Whether pod cidr overprovision is disabled.
         */
        disabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfig {
        /**
         * Specifies options for controlling advanced machine features.
         */
        advancedMachineFeatures?: pulumi.Input<inputs.container.NodePoolNodeConfigAdvancedMachineFeatures>;
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool.
         */
        bootDiskKmsKey?: pulumi.Input<string>;
        /**
         * Configuration for the confidential nodes feature, which makes nodes run on confidential VMs.
         */
        confidentialNodes?: pulumi.Input<inputs.container.NodePoolNodeConfigConfidentialNodes>;
        /**
         * Parameters for containerd configuration.
         */
        containerdConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigContainerdConfig>;
        /**
         * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the disk attached to each node. Such as pd-standard, pd-balanced or pd-ssd
         */
        diskType?: pulumi.Input<string>;
        /**
         * List of kubernetes taints applied to each node.
         */
        effectiveTaints?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigEffectiveTaint>[]>;
        /**
         * If enabled boot disks are configured with confidential mode.
         */
        enableConfidentialStorage?: pulumi.Input<boolean>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk.
         */
        ephemeralStorageConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigEphemeralStorageConfig>;
        /**
         * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk.
         */
        ephemeralStorageLocalSsdConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigEphemeralStorageLocalSsdConfig>;
        /**
         * Enable or disable NCCL Fast Socket in the node pool.
         */
        fastSocket?: pulumi.Input<inputs.container.NodePoolNodeConfigFastSocket>;
        /**
         * Enables Flex Start provisioning model for the node pool
         */
        flexStart?: pulumi.Input<boolean>;
        /**
         * GCFS configuration for this node.
         */
        gcfsConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigGcfsConfig>;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         */
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigGuestAccelerator>[]>;
        /**
         * Enable or disable gvnic in the node pool.
         */
        gvnic?: pulumi.Input<inputs.container.NodePoolNodeConfigGvnic>;
        /**
         * The maintenance policy for the hosts on which the GKE VMs run on.
         */
        hostMaintenancePolicy?: pulumi.Input<inputs.container.NodePoolNodeConfigHostMaintenancePolicy>;
        /**
         * The image type to use for this node. Note that for a given image type, the latest version of it will be used.
         */
        imageType?: pulumi.Input<string>;
        /**
         * Node kubelet configs.
         */
        kubeletConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigKubeletConfig>;
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Parameters that can be configured on Linux nodes.
         */
        linuxNodeConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigLinuxNodeConfig>;
        /**
         * Parameters for raw-block local NVMe SSDs.
         */
        localNvmeSsdBlockConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigLocalNvmeSsdBlockConfig>;
        /**
         * The number of local SSD disks to be attached to the node.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * LocalSsdEncryptionMode specified the method used for encrypting the local SSDs attached to the node.
         */
        localSsdEncryptionMode?: pulumi.Input<string>;
        /**
         * Type of logging agent that is used as the default value for node pools in the cluster. Valid values include DEFAULT and MAX_THROUGHPUT.
         */
        loggingVariant?: pulumi.Input<string>;
        /**
         * The name of a Google Compute Engine machine type.
         */
        machineType?: pulumi.Input<string>;
        /**
         * The runtime of each node in the node pool in seconds, terminated by 's'. Example: "3600s".
         */
        maxRunDuration?: pulumi.Input<string>;
        /**
         * The metadata key/value pairs assigned to instances in the cluster.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on sole tenant nodes.
         */
        nodeGroup?: pulumi.Input<string>;
        /**
         * The set of Google API scopes to be made available on all of the node VMs.
         */
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether the nodes are created as preemptible VM instances.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * The configuration of the desired reservation which instances could take capacity from.
         * Structure is documented below.
         *
         * <a name="nestedAutoscaling"></a>The `autoscaling` block supports (either total or per zone limits are required):
         */
        reservationAffinity?: pulumi.Input<inputs.container.NodePoolNodeConfigReservationAffinity>;
        /**
         * The GCE resource labels (a map of key/value pairs) to be applied to the node pool.
         */
        resourceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
         */
        resourceManagerTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Sandbox configuration for this node.
         */
        sandboxConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigSandboxConfig>;
        /**
         * Secondary boot disks for preloading data or container images.
         */
        secondaryBootDisks?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigSecondaryBootDisk>[]>;
        /**
         * The Google Cloud Platform Service Account to be used by the node VMs.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Shielded Instance options.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigShieldedInstanceConfig>;
        /**
         * Node affinity options for sole tenant node pools.
         */
        soleTenantConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigSoleTenantConfig>;
        /**
         * Whether the nodes are created as spot VM instances.
         */
        spot?: pulumi.Input<boolean>;
        /**
         * The list of Storage Pools where boot disks are provisioned.
         */
        storagePools?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of instance tags applied to all nodes.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of Kubernetes taints to be applied to each node.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigTaint>[]>;
        /**
         * Parameters that can be configured on Windows nodes.
         */
        windowsNodeConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigWindowsNodeConfig>;
        /**
         * The workload metadata configuration for this node.
         */
        workloadMetadataConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface NodePoolNodeConfigAdvancedMachineFeatures {
        /**
         * Whether the node should have nested virtualization enabled.
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
         */
        threadsPerCore: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigConfidentialNodes {
        /**
         * Whether Confidential Nodes feature is enabled for all nodes in this pool.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigContainerdConfig {
        /**
         * Parameters for private container registries configuration.
         */
        privateRegistryAccessConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig>;
    }

    export interface NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfig {
        /**
         * Parameters for configuring CA certificate and domains.
         */
        certificateAuthorityDomainConfigs?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig>[]>;
        /**
         * Whether or not private registries are configured.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfig {
        /**
         * List of fully-qualified-domain-names. IPv4s and port specification are supported.
         */
        fqdns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Parameters for configuring a certificate hosted in GCP SecretManager.
         */
        gcpSecretManagerCertificateConfig: pulumi.Input<inputs.container.NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig>;
    }

    export interface NodePoolNodeConfigContainerdConfigPrivateRegistryAccessConfigCertificateAuthorityDomainConfigGcpSecretManagerCertificateConfig {
        /**
         * URI for the secret that hosts a certificate. Must be in the format 'projects/PROJECT_NUM/secrets/SECRET_NAME/versions/VERSION_OR_LATEST'.
         */
        secretUri: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigEffectiveTaint {
        /**
         * Effect for taint.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key?: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigEphemeralStorageConfig {
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigEphemeralStorageLocalSsdConfig {
        /**
         * Number of local SSDs to be utilized for GKE Data Cache. Uses NVMe interfaces.
         */
        dataCacheCount?: pulumi.Input<number>;
        /**
         * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD must be 375 or 3000 GB in size, and all local SSDs must share the same size.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigFastSocket {
        /**
         * Whether or not NCCL Fast Socket is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigGcfsConfig {
        /**
         * Whether or not GCFS is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        /**
         * The number of the accelerator cards exposed to an instance.
         */
        count: pulumi.Input<number>;
        /**
         * Configuration for auto installation of GPU driver.
         */
        gpuDriverInstallationConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig>;
        /**
         * Size of partitions to create on the GPU. Valid values are described in the NVIDIA mig user guide (https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning)
         */
        gpuPartitionSize?: pulumi.Input<string>;
        /**
         * Configuration for GPU sharing.
         */
        gpuSharingConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigGuestAcceleratorGpuSharingConfig>;
        /**
         * The accelerator type resource name.
         */
        type: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigGuestAcceleratorGpuDriverInstallationConfig {
        /**
         * Mode for how the GPU driver is installed.
         */
        gpuDriverVersion: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigGuestAcceleratorGpuSharingConfig {
        /**
         * The type of GPU sharing strategy to enable on the GPU node. Possible values are described in the API package (https://pkg.go.dev/google.golang.org/api/container/v1#GPUSharingConfig)
         */
        gpuSharingStrategy: pulumi.Input<string>;
        /**
         * The maximum number of containers that can share a GPU.
         */
        maxSharedClientsPerGpu: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigGvnic {
        /**
         * Whether or not gvnic is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigHostMaintenancePolicy {
        /**
         * .
         */
        maintenanceInterval: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigKubeletConfig {
        /**
         * Defines a comma-separated allowlist of unsafe sysctls or sysctl patterns which can be set on the Pods.
         */
        allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Defines the maximum number of container log files that can be present for a container.
         */
        containerLogMaxFiles?: pulumi.Input<number>;
        /**
         * Defines the maximum size of the container log file before it is rotated.
         */
        containerLogMaxSize?: pulumi.Input<string>;
        /**
         * Enable CPU CFS quota enforcement for containers that specify CPU limits.
         */
        cpuCfsQuota?: pulumi.Input<boolean>;
        /**
         * Set the CPU CFS quota period value 'cpu.cfs_period_us'.
         */
        cpuCfsQuotaPeriod?: pulumi.Input<string>;
        /**
         * Control the CPU management policy on the node.
         */
        cpuManagerPolicy?: pulumi.Input<string>;
        /**
         * Defines the percent of disk usage after which image garbage collection is always run.
         */
        imageGcHighThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.
         */
        imageGcLowThresholdPercent?: pulumi.Input<number>;
        /**
         * Defines the maximum age an image can be unused before it is garbage collected.
         */
        imageMaximumGcAge?: pulumi.Input<string>;
        /**
         * Defines the minimum age for an unused image before it is garbage collected.
         */
        imageMinimumGcAge?: pulumi.Input<string>;
        /**
         * Controls whether the kubelet read-only port is enabled. It is strongly recommended to set this to `FALSE`. Possible values: `TRUE`, `FALSE`.
         */
        insecureKubeletReadonlyPortEnabled?: pulumi.Input<string>;
        /**
         * Controls the maximum number of processes allowed to run in a pod.
         */
        podPidsLimit?: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigLinuxNodeConfig {
        /**
         * cgroupMode specifies the cgroup mode to be used on the node.
         */
        cgroupMode?: pulumi.Input<string>;
        /**
         * Amounts for 2M and 1G hugepages.
         */
        hugepagesConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigLinuxNodeConfigHugepagesConfig>;
        /**
         * The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
         */
        sysctls?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface NodePoolNodeConfigLinuxNodeConfigHugepagesConfig {
        /**
         * Amount of 1G hugepages.
         */
        hugepageSize1g?: pulumi.Input<number>;
        /**
         * Amount of 2M hugepages.
         */
        hugepageSize2m?: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigLocalNvmeSsdBlockConfig {
        /**
         * Number of raw-block local NVMe SSD disks to be attached to the node. Each local SSD is 375 GB in size.
         */
        localSsdCount: pulumi.Input<number>;
    }

    export interface NodePoolNodeConfigReservationAffinity {
        /**
         * The type of reservation consumption
         * Accepted values are:
         *
         * * `"UNSPECIFIED"`: Default value. This should not be used.
         * * `"NO_RESERVATION"`: Do not consume from any reserved capacity.
         * * `"ANY_RESERVATION"`: Consume any reservation available.
         * * `"SPECIFIC_RESERVATION"`: Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
         */
        consumeReservationType: pulumi.Input<string>;
        /**
         * The label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify "compute.googleapis.com/reservation-name" as the key and specify the name of your reservation as its value.
         */
        key?: pulumi.Input<string>;
        /**
         * The list of label values of reservation resources. For example: the name of the specific reservation when using a key of "compute.googleapis.com/reservation-name"
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        /**
         * Type of the sandbox to use for the node (e.g. 'gvisor')
         */
        sandboxType: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigSecondaryBootDisk {
        /**
         * Disk image to create the secondary boot disk from
         */
        diskImage: pulumi.Input<string>;
        /**
         * Mode for how the secondary boot disk is used.
         */
        mode?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        /**
         * Defines whether the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines whether the instance has Secure Boot enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfigSoleTenantConfig {
        /**
         * .
         */
        nodeAffinities: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigSoleTenantConfigNodeAffinity>[]>;
    }

    export interface NodePoolNodeConfigSoleTenantConfigNodeAffinity {
        /**
         * .
         */
        key: pulumi.Input<string>;
        /**
         * .
         */
        operator: pulumi.Input<string>;
        /**
         * .
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NodePoolNodeConfigTaint {
        /**
         * Effect for taint.
         */
        effect: pulumi.Input<string>;
        /**
         * Key for taint.
         */
        key: pulumi.Input<string>;
        /**
         * Value for taint.
         */
        value: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigWindowsNodeConfig {
        /**
         * The OS Version of the windows nodepool.Values are OS_VERSION_UNSPECIFIED,OS_VERSION_LTSC2019 and OS_VERSION_LTSC2022
         */
        osversion?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        /**
         * Mode is the configuration for how to expose metadata to workloads running on the node.
         */
        mode: pulumi.Input<string>;
    }

    export interface NodePoolPlacementPolicy {
        /**
         * If set, refers to the name of a custom resource policy supplied by the user.
         * The resource policy must be in the same project and region as the node pool.
         * If not found, InvalidArgument error is returned.
         */
        policyName?: pulumi.Input<string>;
        /**
         * The [TPU placement topology](https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies) for pod slice node pool.
         */
        tpuTopology?: pulumi.Input<string>;
        /**
         * The type of the policy. Supports a single value: COMPACT.
         * Specifying COMPACT placement policy type places node pool's nodes in a closer
         * physical proximity in order to reduce network latency between nodes.
         */
        type: pulumi.Input<string>;
    }

    export interface NodePoolQueuedProvisioning {
        /**
         * Makes nodes obtainable through the [ProvisioningRequest API](https://cloud.google.com/kubernetes-engine/docs/how-to/provisioningrequest) exclusively.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface NodePoolUpgradeSettings {
        /**
         * The settings to adjust [blue green upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies#blue-green-upgrade-strategy).
         * Structure is documented below
         */
        blueGreenSettings?: pulumi.Input<inputs.container.NodePoolUpgradeSettingsBlueGreenSettings>;
        /**
         * The number of additional nodes that can be added to the node pool during
         * an upgrade. Increasing `maxSurge` raises the number of nodes that can be upgraded simultaneously.
         * Can be set to 0 or greater.
         */
        maxSurge?: pulumi.Input<number>;
        /**
         * The number of nodes that can be simultaneously unavailable during
         * an upgrade. Increasing `maxUnavailable` raises the number of nodes that can be upgraded in
         * parallel. Can be set to 0 or greater.
         *
         * `maxSurge` and `maxUnavailable` must not be negative and at least one of them must be greater than zero.
         */
        maxUnavailable?: pulumi.Input<number>;
        /**
         * The upgrade strategy to be used for upgrading the nodes.
         */
        strategy?: pulumi.Input<string>;
    }

    export interface NodePoolUpgradeSettingsBlueGreenSettings {
        /**
         * Time needed after draining the entire blue pool.
         * After this period, the blue pool will be cleaned up.
         */
        nodePoolSoakDuration?: pulumi.Input<string>;
        /**
         * Specifies the standard policy settings for blue-green upgrades.
         */
        standardRolloutPolicy: pulumi.Input<inputs.container.NodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy>;
    }

    export interface NodePoolUpgradeSettingsBlueGreenSettingsStandardRolloutPolicy {
        /**
         * Number of blue nodes to drain in a batch.
         */
        batchNodeCount?: pulumi.Input<number>;
        /**
         * Percentage of the blue pool nodes to drain in a batch.
         */
        batchPercentage?: pulumi.Input<number>;
        /**
         * Soak time after each batch gets drained.
         */
        batchSoakDuration?: pulumi.Input<string>;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        /**
         * This submessage provides human-readable hints about the purpose of
         * the AttestationAuthority. Because the name of a Note acts as its
         * resource reference, it is important to disambiguate the canonical
         * name of the Note (which might be a UUID for security purposes)
         * from "readable" names more suitable for debug output. Note that
         * these hints should NOT be used to look up AttestationAuthorities
         * in security sensitive contexts, such as when looking up
         * Attestations to verify.
         * Structure is documented below.
         */
        hint: pulumi.Input<inputs.containeranalysis.NoteAttestationAuthorityHint>;
    }

    export interface NoteAttestationAuthorityHint {
        /**
         * The human readable name of this Attestation Authority, for
         * example "qa".
         *
         * - - -
         */
        humanReadableName: pulumi.Input<string>;
    }

    export interface NoteIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface NoteIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface NoteRelatedUrl {
        /**
         * Label to describe usage of the URL
         */
        label?: pulumi.Input<string>;
        /**
         * Specific URL associated with the resource.
         */
        url: pulumi.Input<string>;
    }

    export interface OccurenceAttestation {
        /**
         * The serialized payload that is verified by one or
         * more signatures. A base64-encoded string.
         */
        serializedPayload: pulumi.Input<string>;
        /**
         * One or more signatures over serializedPayload.
         * Verifier implementations should consider this attestation
         * message verified if at least one signature verifies
         * serializedPayload. See Signature in common.proto for more
         * details on signature structure and verification.
         * Structure is documented below.
         */
        signatures: pulumi.Input<pulumi.Input<inputs.containeranalysis.OccurenceAttestationSignature>[]>;
    }

    export interface OccurenceAttestationSignature {
        /**
         * The identifier for the public key that verifies this
         * signature. MUST be an RFC3986 conformant
         * URI. * When possible, the key id should be an
         * immutable reference, such as a cryptographic digest.
         * Examples of valid values:
         * * OpenPGP V4 public key fingerprint. See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr
         * for more details on this scheme.
         * * `openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA`
         * * RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization):
         * * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
         *
         * - - -
         */
        publicKeyId: pulumi.Input<string>;
        /**
         * The content of the signature, an opaque bytestring.
         * The payload that this signature verifies MUST be
         * unambiguously provided with the Signature during
         * verification. A wrapper message might provide the
         * payload explicitly. Alternatively, a message might
         * have a canonical serialization that can always be
         * unambiguously computed to derive the payload.
         */
        signature?: pulumi.Input<string>;
    }
}

export namespace databasemigrationservice {
    export interface ConnectionProfileAlloydb {
        /**
         * Required. The AlloyDB cluster ID that this connection profile is associated with.
         */
        clusterId: pulumi.Input<string>;
        /**
         * Immutable. Metadata used to create the destination AlloyDB cluster.
         * Structure is documented below.
         */
        settings?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileAlloydbSettings>;
    }

    export interface ConnectionProfileAlloydbSettings {
        /**
         * Required. Input only. Initial user to setup during cluster creation.
         * Structure is documented below.
         */
        initialUser: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileAlloydbSettingsInitialUser>;
        /**
         * Labels for the AlloyDB cluster created by DMS.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Settings for the cluster's primary instance
         * Structure is documented below.
         */
        primaryInstanceSettings?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileAlloydbSettingsPrimaryInstanceSettings>;
        /**
         * Required. The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
         * It is specified in the form: 'projects/{project_number}/global/networks/{network_id}'. This is required to create a cluster.
         */
        vpcNetwork: pulumi.Input<string>;
    }

    export interface ConnectionProfileAlloydbSettingsInitialUser {
        /**
         * The initial password for the user.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Indicates if the initialUser.password field has been set.
         */
        passwordSet?: pulumi.Input<boolean>;
        /**
         * The database username.
         */
        user: pulumi.Input<string>;
    }

    export interface ConnectionProfileAlloydbSettingsPrimaryInstanceSettings {
        /**
         * Database flags to pass to AlloyDB when DMS is creating the AlloyDB cluster and instances. See the AlloyDB documentation for how these can be used.
         */
        databaseFlags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The database username.
         */
        id: pulumi.Input<string>;
        /**
         * Labels for the AlloyDB primary instance created by DMS.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Configuration for the machines that host the underlying database engine.
         * Structure is documented below.
         */
        machineConfig: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileAlloydbSettingsPrimaryInstanceSettingsMachineConfig>;
        /**
         * (Output)
         * Output only. The private IP address for the Instance. This is the connection endpoint for an end-user application.
         */
        privateIp?: pulumi.Input<string>;
    }

    export interface ConnectionProfileAlloydbSettingsPrimaryInstanceSettingsMachineConfig {
        /**
         * The number of CPU's in the VM instance.
         */
        cpuCount: pulumi.Input<number>;
    }

    export interface ConnectionProfileCloudsql {
        /**
         * (Output)
         * Output only. The Cloud SQL instance ID that this connection profile is associated with.
         */
        cloudSqlId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The Cloud SQL database instance's private IP.
         */
        privateIp?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The Cloud SQL database instance's public IP.
         */
        publicIp?: pulumi.Input<string>;
        /**
         * Immutable. Metadata used to create the destination Cloud SQL database.
         * Structure is documented below.
         */
        settings?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileCloudsqlSettings>;
    }

    export interface ConnectionProfileCloudsqlSettings {
        /**
         * The activation policy specifies when the instance is activated; it is applicable only when the instance state is 'RUNNABLE'.
         * Possible values are: `ALWAYS`, `NEVER`.
         */
        activationPolicy?: pulumi.Input<string>;
        /**
         * If you enable this setting, Cloud SQL checks your available storage every 30 seconds. If the available storage falls below a threshold size, Cloud SQL automatically adds additional storage capacity.
         * If the available storage repeatedly falls below the threshold size, Cloud SQL continues to add storage until it reaches the maximum of 30 TB.
         */
        autoStorageIncrease?: pulumi.Input<boolean>;
        /**
         * The KMS key name used for the csql instance.
         */
        cmekKeyName?: pulumi.Input<string>;
        /**
         * The Cloud SQL default instance level collation.
         */
        collation?: pulumi.Input<string>;
        /**
         * The storage capacity available to the database, in GB. The minimum (and default) size is 10GB.
         */
        dataDiskSizeGb?: pulumi.Input<string>;
        /**
         * The type of storage.
         * Possible values are: `PD_SSD`, `PD_HDD`.
         */
        dataDiskType?: pulumi.Input<string>;
        /**
         * The database flags passed to the Cloud SQL instance at startup.
         */
        databaseFlags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The database engine type and version.
         * Currently supported values located at https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.connectionProfiles#sqldatabaseversion
         */
        databaseVersion?: pulumi.Input<string>;
        /**
         * The edition of the given Cloud SQL instance.
         * Possible values are: `ENTERPRISE`, `ENTERPRISE_PLUS`.
         */
        edition?: pulumi.Input<string>;
        /**
         * The settings for IP Management. This allows to enable or disable the instance IP and manage which external networks can connect to the instance. The IPv4 address cannot be disabled.
         * Structure is documented below.
         */
        ipConfig?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileCloudsqlSettingsIpConfig>;
        /**
         * Input only. Initial root password.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        rootPassword?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Indicates If this connection profile root password is stored.
         */
        rootPasswordSet?: pulumi.Input<boolean>;
        /**
         * The Database Migration Service source connection profile ID, in the format: projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID
         */
        sourceId: pulumi.Input<string>;
        /**
         * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
         */
        storageAutoResizeLimit?: pulumi.Input<string>;
        /**
         * The tier (or machine type) for this instance, for example: db-n1-standard-1 (MySQL instances) or db-custom-1-3840 (PostgreSQL instances).
         * For more information, see https://cloud.google.com/sql/docs/mysql/instance-settings
         */
        tier?: pulumi.Input<string>;
        /**
         * The resource labels for a Cloud SQL instance to use to annotate any related underlying resources such as Compute Engine VMs.
         */
        userLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Google Cloud Platform zone where your Cloud SQL datdabse instance is located.
         */
        zone?: pulumi.Input<string>;
    }

    export interface ConnectionProfileCloudsqlSettingsIpConfig {
        /**
         * The list of external networks that are allowed to connect to the instance using the IP.
         * Structure is documented below.
         */
        authorizedNetworks?: pulumi.Input<pulumi.Input<inputs.databasemigrationservice.ConnectionProfileCloudsqlSettingsIpConfigAuthorizedNetwork>[]>;
        /**
         * Whether the instance should be assigned an IPv4 address or not.
         */
        enableIpv4?: pulumi.Input<boolean>;
        /**
         * The resource link for the VPC network from which the Cloud SQL instance is accessible for private IP. For example, projects/myProject/global/networks/default.
         * This setting can be updated, but it cannot be removed after it is set.
         */
        privateNetwork?: pulumi.Input<string>;
        /**
         * Whether SSL connections over IP should be enforced or not.
         */
        requireSsl?: pulumi.Input<boolean>;
    }

    export interface ConnectionProfileCloudsqlSettingsIpConfigAuthorizedNetwork {
        /**
         * The time when this access control entry expires in RFC 3339 format.
         */
        expireTime?: pulumi.Input<string>;
        /**
         * A label to identify this entry.
         */
        label?: pulumi.Input<string>;
        /**
         * Input only. The time-to-leave of this access control entry.
         */
        ttl?: pulumi.Input<string>;
        /**
         * The allowlisted value for the access control list.
         */
        value: pulumi.Input<string>;
    }

    export interface ConnectionProfileError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
    }

    export interface ConnectionProfileMysql {
        /**
         * If the source is a Cloud SQL database, use this field to provide the Cloud SQL instance ID of the source.
         */
        cloudSqlId?: pulumi.Input<string>;
        /**
         * The IP or hostname of the source MySQL database.
         */
        host?: pulumi.Input<string>;
        /**
         * Input only. The password for the user that Database Migration Service will be using to connect to the database.
         * This field is not returned on request, and the value is encrypted when stored in Database Migration Service.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Indicates If this connection profile password is stored.
         */
        passwordSet?: pulumi.Input<boolean>;
        /**
         * The network port of the source MySQL database.
         */
        port?: pulumi.Input<number>;
        /**
         * SSL configuration for the destination to connect to the source database.
         * Structure is documented below.
         */
        ssl?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileMysqlSsl>;
        /**
         * The username that Database Migration Service will use to connect to the database. The value is encrypted when stored in Database Migration Service.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionProfileMysqlSsl {
        /**
         * Input only. The x509 PEM-encoded certificate of the CA that signed the source database server's certificate.
         * The replica will use this certificate to verify it's connecting to the right host.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * Input only. The x509 PEM-encoded certificate that will be used by the replica to authenticate against the source database server.
         * If this field is used then the 'clientKey' field is mandatory
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key associated with the Client Certificate.
         * If this field is used then the 'clientCertificate' field is mandatory.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The current connection profile state.
         */
        type?: pulumi.Input<string>;
    }

    export interface ConnectionProfileOracle {
        /**
         * Required. Database service for the Oracle connection.
         */
        databaseService: pulumi.Input<string>;
        /**
         * SSL configuration for the destination to connect to the source database.
         * Structure is documented below.
         */
        forwardSshConnectivity?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileOracleForwardSshConnectivity>;
        /**
         * Required. The IP or hostname of the source Oracle database.
         */
        host: pulumi.Input<string>;
        /**
         * Required. Input only. The password for the user that Database Migration Service will be using to connect to the database.
         * This field is not returned on request, and the value is encrypted when stored in Database Migration Service.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Indicates If this connection profile password is stored.
         */
        passwordSet?: pulumi.Input<boolean>;
        /**
         * Required. The network port of the source Oracle database.
         */
        port: pulumi.Input<number>;
        /**
         * Configuration for using a private network to communicate with the source database
         * Structure is documented below.
         */
        privateConnectivity?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileOraclePrivateConnectivity>;
        /**
         * SSL configuration for the destination to connect to the source database.
         * Structure is documented below.
         */
        ssl?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileOracleSsl>;
        /**
         * This object has no nested fields.
         * Static IP address connectivity configured on service project.
         */
        staticServiceIpConnectivity?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfileOracleStaticServiceIpConnectivity>;
        /**
         * Required. The username that Database Migration Service will use to connect to the database. The value is encrypted when stored in Database Migration Service.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfileOracleForwardSshConnectivity {
        /**
         * Required. Hostname for the SSH tunnel.
         */
        hostname: pulumi.Input<string>;
        /**
         * Input only. SSH password. Only one of `password` and `privateKey` can be configured.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the SSH tunnel, default value is 22.
         */
        port: pulumi.Input<number>;
        /**
         * Input only. SSH private key. Only one of `password` and `privateKey` can be configured.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        privateKey?: pulumi.Input<string>;
        /**
         * Required. Username for the SSH tunnel.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfileOraclePrivateConnectivity {
        /**
         * Required. The resource name (URI) of the private connection.
         */
        privateConnection: pulumi.Input<string>;
    }

    export interface ConnectionProfileOracleSsl {
        /**
         * Input only. The x509 PEM-encoded certificate of the CA that signed the source database server's certificate.
         * The replica will use this certificate to verify it's connecting to the right host.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * Input only. The x509 PEM-encoded certificate that will be used by the replica to authenticate against the source database server.
         * If this field is used then the 'clientKey' field is mandatory
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key associated with the Client Certificate.
         * If this field is used then the 'clientCertificate' field is mandatory.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The current connection profile state.
         */
        type?: pulumi.Input<string>;
    }

    export interface ConnectionProfileOracleStaticServiceIpConnectivity {
    }

    export interface ConnectionProfilePostgresql {
        /**
         * If the connected database is an AlloyDB instance, use this field to provide the AlloyDB cluster ID.
         */
        alloydbClusterId?: pulumi.Input<string>;
        /**
         * If the source is a Cloud SQL database, use this field to provide the Cloud SQL instance ID of the source.
         */
        cloudSqlId?: pulumi.Input<string>;
        /**
         * The IP or hostname of the source MySQL database.
         */
        host?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. If the source is a Cloud SQL database, this field indicates the network architecture it's associated with.
         */
        networkArchitecture?: pulumi.Input<string>;
        /**
         * Input only. The password for the user that Database Migration Service will be using to connect to the database.
         * This field is not returned on request, and the value is encrypted when stored in Database Migration Service.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Indicates If this connection profile password is stored.
         */
        passwordSet?: pulumi.Input<boolean>;
        /**
         * The network port of the source MySQL database.
         */
        port?: pulumi.Input<number>;
        /**
         * SSL configuration for the destination to connect to the source database.
         * Structure is documented below.
         */
        ssl?: pulumi.Input<inputs.databasemigrationservice.ConnectionProfilePostgresqlSsl>;
        /**
         * The username that Database Migration Service will use to connect to the database. The value is encrypted when stored in Database Migration Service.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionProfilePostgresqlSsl {
        /**
         * Input only. The x509 PEM-encoded certificate of the CA that signed the source database server's certificate.
         * The replica will use this certificate to verify it's connecting to the right host.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * Input only. The x509 PEM-encoded certificate that will be used by the replica to authenticate against the source database server.
         * If this field is used then the 'clientKey' field is mandatory
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key associated with the Client Certificate.
         * If this field is used then the 'clientCertificate' field is mandatory.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The current connection profile state.
         */
        type?: pulumi.Input<string>;
    }

    export interface MigrationJobDumpFlags {
        /**
         * A list of dump flags
         * Structure is documented below.
         */
        dumpFlags?: pulumi.Input<pulumi.Input<inputs.databasemigrationservice.MigrationJobDumpFlagsDumpFlag>[]>;
    }

    export interface MigrationJobDumpFlagsDumpFlag {
        /**
         * The name of the flag
         */
        name?: pulumi.Input<string>;
        /**
         * The vale of the flag
         */
        value?: pulumi.Input<string>;
    }

    export interface MigrationJobError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
    }

    export interface MigrationJobPerformanceConfig {
        /**
         * Initial dump parallelism level.
         * Possible values are: `MIN`, `OPTIMAL`, `MAX`.
         */
        dumpParallelLevel?: pulumi.Input<string>;
    }

    export interface MigrationJobReverseSshConnectivity {
        /**
         * The name of the virtual machine (Compute Engine) used as the bastion server
         * for the SSH tunnel.
         */
        vm?: pulumi.Input<string>;
        /**
         * The IP of the virtual machine (Compute Engine) used as the bastion server
         * for the SSH tunnel.
         */
        vmIp?: pulumi.Input<string>;
        /**
         * The forwarding port of the virtual machine (Compute Engine) used as the
         * bastion server for the SSH tunnel.
         */
        vmPort?: pulumi.Input<number>;
        /**
         * The name of the VPC to peer with the Cloud SQL private network.
         */
        vpc?: pulumi.Input<string>;
    }

    export interface MigrationJobStaticIpConnectivity {
    }

    export interface MigrationJobVpcPeeringConnectivity {
        /**
         * The name of the VPC network to peer with the Cloud SQL private network.
         */
        vpc?: pulumi.Input<string>;
    }

    export interface PrivateConnectionError {
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A message containing more information about the error that occurred.
         */
        message?: pulumi.Input<string>;
    }

    export interface PrivateConnectionVpcPeeringConfig {
        /**
         * A free subnet for peering. (CIDR of /29)
         *
         * - - -
         */
        subnet: pulumi.Input<string>;
        /**
         * Fully qualified name of the VPC that Database Migration Service will peer to.
         * Format: projects/{project}/global/{networks}/{name}
         */
        vpcName: pulumi.Input<string>;
    }
}

export namespace datacatalog {
    export interface EntryBigqueryDateShardedSpec {
        /**
         * (Output)
         * The Data Catalog resource name of the dataset entry the current table belongs to, for example,
         * projects/{project_id}/locations/{location}/entrygroups/{entryGroupId}/entries/{entryId}
         */
        dataset?: pulumi.Input<string>;
        /**
         * (Output)
         * Total number of shards.
         */
        shardCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The table name prefix of the shards. The name of any given shard is [tablePrefix]YYYYMMDD,
         * for example, for shard MyTable20180101, the tablePrefix is MyTable.
         */
        tablePrefix?: pulumi.Input<string>;
    }

    export interface EntryBigqueryTableSpec {
        /**
         * (Output)
         * The table source type.
         */
        tableSourceType?: pulumi.Input<string>;
        /**
         * (Output)
         * Spec of a BigQuery table. This field should only be populated if tableSourceType is BIGQUERY_TABLE.
         * Structure is documented below.
         */
        tableSpecs?: pulumi.Input<pulumi.Input<inputs.datacatalog.EntryBigqueryTableSpecTableSpec>[]>;
        /**
         * (Output)
         * Table view specification. This field should only be populated if tableSourceType is BIGQUERY_VIEW.
         * Structure is documented below.
         */
        viewSpecs?: pulumi.Input<pulumi.Input<inputs.datacatalog.EntryBigqueryTableSpecViewSpec>[]>;
    }

    export interface EntryBigqueryTableSpecTableSpec {
        /**
         * (Output)
         * If the table is a dated shard, i.e., with name pattern [prefix]YYYYMMDD, groupedEntry is the
         * Data Catalog resource name of the date sharded grouped entry, for example,
         * projects/{project_id}/locations/{location}/entrygroups/{entryGroupId}/entries/{entryId}.
         * Otherwise, groupedEntry is empty.
         */
        groupedEntry?: pulumi.Input<string>;
    }

    export interface EntryBigqueryTableSpecViewSpec {
        /**
         * (Output)
         * The query that defines the table view.
         */
        viewQuery?: pulumi.Input<string>;
    }

    export interface EntryGcsFilesetSpec {
        /**
         * Patterns to identify a set of files in Google Cloud Storage.
         * See [Cloud Storage documentation](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames)
         * for more information. Note that bucket wildcards are currently not supported. Examples of valid filePatterns:
         * * gs://bucket_name/dir/*: matches all files within bucket_name/dir directory.
         * * gs://bucket_name/dir/**: matches all files in bucket_name/dir spanning all subdirectories.
         * * gs://bucket_name/file*: matches files prefixed by file in bucketName
         * * gs://bucket_name/??.txt: matches files with two characters followed by .txt in bucketName
         * * gs://bucket_name/[aeiou].txt: matches files that contain a single vowel character followed by .txt in bucketName
         * * gs://bucket_name/[a-m].txt: matches files that contain a, b, ... or m followed by .txt in bucketName
         * * gs://bucket_name/a/*&#47;b: matches all files in bucketName that match a/*&#47;b pattern, such as a/c/b, a/d/b
         * * gs://another_bucket/a.txt: matches gs://another_bucket/a.txt
         */
        filePatterns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Sample files contained in this fileset, not all files contained in this fileset are represented here.
         * Structure is documented below.
         *
         *
         * <a name="nestedGcsFilesetSpecSampleGcsFileSpecs"></a>The `sampleGcsFileSpecs` block contains:
         */
        sampleGcsFileSpecs?: pulumi.Input<pulumi.Input<inputs.datacatalog.EntryGcsFilesetSpecSampleGcsFileSpec>[]>;
    }

    export interface EntryGcsFilesetSpecSampleGcsFileSpec {
        /**
         * The full file path
         */
        filePath?: pulumi.Input<string>;
        /**
         * The size of the file, in bytes.
         */
        sizeBytes?: pulumi.Input<number>;
    }

    export interface EntryGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface PolicyTagIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface PolicyTagIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TagField {
        /**
         * Holds the value for a tag field with boolean type.
         */
        boolValue?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The display name of this field
         */
        displayName?: pulumi.Input<string>;
        /**
         * Holds the value for a tag field with double type.
         */
        doubleValue?: pulumi.Input<number>;
        /**
         * Holds the value for a tag field with enum type. This value must be one of the allowed values in the definition of this enum.
         *
         * - - -
         */
        enumValue?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        fieldName: pulumi.Input<string>;
        /**
         * (Output)
         * The order of this field with respect to other fields in this tag. For example, a higher value can indicate
         * a more important field. The value can be negative. Multiple fields can have the same order, and field orders
         * within a tag do not have to be sequential.
         */
        order?: pulumi.Input<number>;
        /**
         * Holds the value for a tag field with string type.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Holds the value for a tag field with timestamp type.
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface TagTemplateField {
        /**
         * A description for this field.
         */
        description?: pulumi.Input<string>;
        /**
         * The display name for this field.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        fieldId: pulumi.Input<string>;
        /**
         * Whether this is a required field. Defaults to false.
         */
        isRequired?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The resource name of the tag template field in URL format. Example: projects/{project_id}/locations/{location}/tagTemplates/{tagTemplateId}/fields/{field}
         */
        name?: pulumi.Input<string>;
        /**
         * The order of this field with respect to other fields in this tag template.
         * A higher value indicates a more important field. The value can be negative.
         * Multiple fields can have the same order, and field orders within a tag do not have to be sequential.
         */
        order?: pulumi.Input<number>;
        /**
         * The type of value this tag field can contain.
         * Structure is documented below.
         */
        type: pulumi.Input<inputs.datacatalog.TagTemplateFieldType>;
    }

    export interface TagTemplateFieldType {
        /**
         * Represents an enum type.
         * Exactly one of `primitiveType` or `enumType` must be set
         * Structure is documented below.
         */
        enumType?: pulumi.Input<inputs.datacatalog.TagTemplateFieldTypeEnumType>;
        /**
         * Represents primitive types - string, bool etc.
         * Exactly one of `primitiveType` or `enumType` must be set
         * Possible values are: `DOUBLE`, `STRING`, `BOOL`, `TIMESTAMP`.
         */
        primitiveType?: pulumi.Input<string>;
    }

    export interface TagTemplateFieldTypeEnumType {
        /**
         * The set of allowed values for this enum. The display names of the
         * values must be case-insensitively unique within this set. Currently,
         * enum values can only be added to the list of allowed values. Deletion
         * and renaming of enum values are not supported.
         * Can have up to 500 allowed values.
         * Structure is documented below.
         */
        allowedValues: pulumi.Input<pulumi.Input<inputs.datacatalog.TagTemplateFieldTypeEnumTypeAllowedValue>[]>;
    }

    export interface TagTemplateFieldTypeEnumTypeAllowedValue {
        /**
         * The display name for this template.
         */
        displayName: pulumi.Input<string>;
    }

    export interface TagTemplateIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TagTemplateIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TaxonomyIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TaxonomyIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace dataflow {
    export interface PipelineScheduleInfo {
        /**
         * (Output)
         * When the next Scheduler job is going to run.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        nextJobTime?: pulumi.Input<string>;
        /**
         * Unix-cron format of the schedule. This information is retrieved from the linked Cloud Scheduler.
         */
        schedule?: pulumi.Input<string>;
        /**
         * Timezone ID. This matches the timezone IDs used by the Cloud Scheduler API. If empty, UTC time is assumed.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface PipelineWorkload {
        /**
         * Template information and additional parameters needed to launch a Dataflow job using the flex launch API.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#launchflextemplaterequest
         * Structure is documented below.
         */
        dataflowFlexTemplateRequest?: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowFlexTemplateRequest>;
        /**
         * Template information and additional parameters needed to launch a Dataflow job using the standard launch API.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#launchtemplaterequest
         * Structure is documented below.
         */
        dataflowLaunchTemplateRequest?: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowLaunchTemplateRequest>;
    }

    export interface PipelineWorkloadDataflowFlexTemplateRequest {
        /**
         * Parameter to launch a job from a Flex Template.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#launchflextemplateparameter
         * Structure is documented below.
         */
        launchParameter: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowFlexTemplateRequestLaunchParameter>;
        /**
         * The regional endpoint to which to direct the request. For example, us-central1, us-west1.
         */
        location: pulumi.Input<string>;
        /**
         * The ID of the Cloud Platform project that the job belongs to.
         */
        projectId: pulumi.Input<string>;
        /**
         * If true, the request is validated but not actually executed. Defaults to false.
         */
        validateOnly?: pulumi.Input<boolean>;
    }

    export interface PipelineWorkloadDataflowFlexTemplateRequestLaunchParameter {
        /**
         * Cloud Storage path to a file with a JSON-serialized ContainerSpec as content.
         */
        containerSpecGcsPath?: pulumi.Input<string>;
        /**
         * The runtime environment for the Flex Template job.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#FlexTemplateRuntimeEnvironment
         * Structure is documented below.
         */
        environment?: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowFlexTemplateRequestLaunchParameterEnvironment>;
        /**
         * The job name to use for the created job. For an update job request, the job name should be the same as the existing running job.
         */
        jobName: pulumi.Input<string>;
        /**
         * Launch options for this Flex Template job. This is a common set of options across languages and templates. This should not be used to pass job parameters.
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        launchOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * 'The parameters for the Flex Template. Example: {"numWorkers":"5"}'
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * 'Use this to pass transform name mappings for streaming update jobs. Example: {"oldTransformName":"newTransformName",...}'
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        transformNameMappings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Set this to true if you are sending a request to update a running streaming job. When set, the job name should be the same as the running job.
         */
        update?: pulumi.Input<boolean>;
    }

    export interface PipelineWorkloadDataflowFlexTemplateRequestLaunchParameterEnvironment {
        /**
         * Additional experiment flags for the job.
         */
        additionalExperiments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Additional user labels to be specified for the job. Keys and values should follow the restrictions specified in the labeling restrictions page. An object containing a list of key/value pairs.
         * 'Example: { "name": "wrench", "mass": "1kg", "count": "3" }.'
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        additionalUserLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Whether to enable Streaming Engine for the job.
         */
        enableStreamingEngine?: pulumi.Input<boolean>;
        /**
         * Set FlexRS goal for the job. https://cloud.google.com/dataflow/docs/guides/flexrs
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#FlexResourceSchedulingGoal
         * Possible values are: `FLEXRS_UNSPECIFIED`, `FLEXRS_SPEED_OPTIMIZED`, `FLEXRS_COST_OPTIMIZED`.
         */
        flexrsGoal?: pulumi.Input<string>;
        /**
         * Configuration for VM IPs.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#WorkerIPAddressConfiguration
         * Possible values are: `WORKER_IP_UNSPECIFIED`, `WORKER_IP_PUBLIC`, `WORKER_IP_PRIVATE`.
         */
        ipConfiguration?: pulumi.Input<string>;
        /**
         * 'Name for the Cloud KMS key for the job. The key format is: projects//locations//keyRings//cryptoKeys/'
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * The machine type to use for the job. Defaults to the value from the template if not specified.
         */
        machineType?: pulumi.Input<string>;
        /**
         * The maximum number of Compute Engine instances to be made available to your pipeline during execution, from 1 to 1000.
         */
        maxWorkers?: pulumi.Input<number>;
        /**
         * Network to which VMs will be assigned. If empty or unspecified, the service will use the network "default".
         */
        network?: pulumi.Input<string>;
        /**
         * The initial number of Compute Engine instances for the job.
         */
        numWorkers?: pulumi.Input<number>;
        /**
         * The email address of the service account to run the job as.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * Subnetwork to which VMs will be assigned, if desired. You can specify a subnetwork using either a complete URL or an abbreviated path. Expected to be of the form "https://www.googleapis.com/compute/v1/projects/HOST_PROJECT_ID/regions/REGION/subnetworks/SUBNETWORK" or "regions/REGION/subnetworks/SUBNETWORK". If the subnetwork is located in a Shared VPC network, you must use the complete URL.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The Cloud Storage path to use for temporary files. Must be a valid Cloud Storage URL, beginning with gs://.
         */
        tempLocation?: pulumi.Input<string>;
        /**
         * The Compute Engine region (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. "us-west1". Mutually exclusive with workerZone. If neither workerRegion nor workerZone is specified, default to the control plane's region.
         */
        workerRegion?: pulumi.Input<string>;
        /**
         * The Compute Engine zone (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. "us-west1-a". Mutually exclusive with workerRegion. If neither workerRegion nor workerZone is specified, a zone in the control plane's region is chosen based on available capacity. If both workerZone and zone are set, workerZone takes precedence.
         */
        workerZone?: pulumi.Input<string>;
        /**
         * The Compute Engine availability zone for launching worker instances to run your pipeline. In the future, workerZone will take precedence.
         */
        zone?: pulumi.Input<string>;
    }

    export interface PipelineWorkloadDataflowLaunchTemplateRequest {
        /**
         * A Cloud Storage path to the template from which to create the job. Must be a valid Cloud Storage URL, beginning with 'gs://'.
         */
        gcsPath?: pulumi.Input<string>;
        /**
         * The parameters of the template to launch. This should be part of the body of the POST request.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#launchtemplateparameters
         * Structure is documented below.
         */
        launchParameters?: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowLaunchTemplateRequestLaunchParameters>;
        /**
         * The regional endpoint to which to direct the request.
         */
        location?: pulumi.Input<string>;
        /**
         * The ID of the Cloud Platform project that the job belongs to.
         */
        projectId: pulumi.Input<string>;
        /**
         * (Optional)
         */
        validateOnly?: pulumi.Input<boolean>;
    }

    export interface PipelineWorkloadDataflowLaunchTemplateRequestLaunchParameters {
        /**
         * The runtime environment for the job.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#RuntimeEnvironment
         * Structure is documented below.
         */
        environment?: pulumi.Input<inputs.dataflow.PipelineWorkloadDataflowLaunchTemplateRequestLaunchParametersEnvironment>;
        /**
         * The job name to use for the created job.
         */
        jobName: pulumi.Input<string>;
        /**
         * The runtime parameters to pass to the job.
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Map of transform name prefixes of the job to be replaced to the corresponding name prefixes of the new job. Only applicable when updating a pipeline.
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        transformNameMapping?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * If set, replace the existing pipeline with the name specified by jobName with this pipeline, preserving state.
         */
        update?: pulumi.Input<boolean>;
    }

    export interface PipelineWorkloadDataflowLaunchTemplateRequestLaunchParametersEnvironment {
        /**
         * Additional experiment flags for the job.
         */
        additionalExperiments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Additional user labels to be specified for the job. Keys and values should follow the restrictions specified in the labeling restrictions page. An object containing a list of key/value pairs.
         * 'Example: { "name": "wrench", "mass": "1kg", "count": "3" }.'
         * 'An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.'
         */
        additionalUserLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Whether to bypass the safety checks for the job's temporary directory. Use with caution.
         */
        bypassTempDirValidation?: pulumi.Input<boolean>;
        /**
         * Whether to enable Streaming Engine for the job.
         */
        enableStreamingEngine?: pulumi.Input<boolean>;
        /**
         * Configuration for VM IPs.
         * https://cloud.google.com/dataflow/docs/reference/data-pipelines/rest/v1/projects.locations.pipelines#WorkerIPAddressConfiguration
         * Possible values are: `WORKER_IP_UNSPECIFIED`, `WORKER_IP_PUBLIC`, `WORKER_IP_PRIVATE`.
         */
        ipConfiguration?: pulumi.Input<string>;
        /**
         * 'Name for the Cloud KMS key for the job. The key format is: projects//locations//keyRings//cryptoKeys/'
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * The machine type to use for the job. Defaults to the value from the template if not specified.
         */
        machineType?: pulumi.Input<string>;
        /**
         * The maximum number of Compute Engine instances to be made available to your pipeline during execution, from 1 to 1000.
         */
        maxWorkers?: pulumi.Input<number>;
        /**
         * Network to which VMs will be assigned. If empty or unspecified, the service will use the network "default".
         */
        network?: pulumi.Input<string>;
        /**
         * The initial number of Compute Engine instances for the job.
         */
        numWorkers?: pulumi.Input<number>;
        /**
         * The email address of the service account to run the job as.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * Subnetwork to which VMs will be assigned, if desired. You can specify a subnetwork using either a complete URL or an abbreviated path. Expected to be of the form "https://www.googleapis.com/compute/v1/projects/HOST_PROJECT_ID/regions/REGION/subnetworks/SUBNETWORK" or "regions/REGION/subnetworks/SUBNETWORK". If the subnetwork is located in a Shared VPC network, you must use the complete URL.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The Cloud Storage path to use for temporary files. Must be a valid Cloud Storage URL, beginning with gs://.
         */
        tempLocation?: pulumi.Input<string>;
        /**
         * The Compute Engine region (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. "us-west1". Mutually exclusive with workerZone. If neither workerRegion nor workerZone is specified, default to the control plane's region.
         */
        workerRegion?: pulumi.Input<string>;
        /**
         * The Compute Engine zone (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in which worker processing should occur, e.g. "us-west1-a". Mutually exclusive with workerRegion. If neither workerRegion nor workerZone is specified, a zone in the control plane's region is chosen based on available capacity. If both workerZone and zone are set, workerZone takes precedence.
         */
        workerZone?: pulumi.Input<string>;
        /**
         * The Compute Engine availability zone for launching worker instances to run your pipeline. In the future, workerZone will take precedence.
         */
        zone?: pulumi.Input<string>;
    }
}

export namespace dataform {
    export interface RepositoryGitRemoteSettings {
        /**
         * The name of the Secret Manager secret version to use as an authentication token for Git operations. This secret is for assigning with HTTPS only(for SSH use `sshAuthenticationConfig`). Must be in the format projects/*&#47;secrets/*&#47;versions/*.
         */
        authenticationTokenSecretVersion?: pulumi.Input<string>;
        /**
         * The Git remote's default branch name.
         */
        defaultBranch: pulumi.Input<string>;
        /**
         * Authentication fields for remote uris using SSH protocol.
         * Structure is documented below.
         */
        sshAuthenticationConfig?: pulumi.Input<inputs.dataform.RepositoryGitRemoteSettingsSshAuthenticationConfig>;
        /**
         * (Output)
         * Indicates the status of the Git access token. https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories#TokenStatus
         */
        tokenStatus?: pulumi.Input<string>;
        /**
         * The Git remote's URL.
         */
        url: pulumi.Input<string>;
    }

    export interface RepositoryGitRemoteSettingsSshAuthenticationConfig {
        /**
         * Content of a public SSH key to verify an identity of a remote Git host.
         */
        hostPublicKey: pulumi.Input<string>;
        /**
         * The name of the Secret Manager secret version to use as a ssh private key for Git operations. Must be in the format projects/*&#47;secrets/*&#47;versions/*.
         */
        userPrivateKeySecretVersion: pulumi.Input<string>;
    }

    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryReleaseConfigCodeCompilationConfig {
        /**
         * Optional. The default schema (BigQuery dataset ID) for assertions.
         */
        assertionSchema?: pulumi.Input<string>;
        /**
         * Optional. The suffix that should be appended to all database (Google Cloud project ID) names.
         */
        databaseSuffix?: pulumi.Input<string>;
        /**
         * Optional. The default database (Google Cloud project ID).
         */
        defaultDatabase?: pulumi.Input<string>;
        /**
         * Optional. The default BigQuery location to use. Defaults to "US".
         * See the BigQuery docs for a full list of locations: https://cloud.google.com/bigquery/docs/locations.
         */
        defaultLocation?: pulumi.Input<string>;
        /**
         * Optional. The default schema (BigQuery dataset ID).
         */
        defaultSchema?: pulumi.Input<string>;
        /**
         * Optional. The suffix that should be appended to all schema (BigQuery dataset ID) names.
         */
        schemaSuffix?: pulumi.Input<string>;
        /**
         * Optional. The prefix that should be prepended to all table names.
         */
        tablePrefix?: pulumi.Input<string>;
        /**
         * Optional. User-defined variables that are made available to project code during compilation.
         * An object containing a list of "key": value pairs.
         * Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        vars?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RepositoryReleaseConfigRecentScheduledReleaseRecord {
        /**
         * (Output)
         * The name of the created compilation result, if one was successfully created. Must be in the format projects/*&#47;locations/*&#47;repositories/*&#47;compilationResults/*.
         */
        compilationResult?: pulumi.Input<string>;
        /**
         * (Output)
         * The error status encountered upon this attempt to create the compilation result, if the attempt was unsuccessful.
         * Structure is documented below.
         */
        errorStatuses?: pulumi.Input<pulumi.Input<inputs.dataform.RepositoryReleaseConfigRecentScheduledReleaseRecordErrorStatus>[]>;
        /**
         * (Output)
         * The timestamp of this release attempt.
         */
        releaseTime?: pulumi.Input<string>;
    }

    export interface RepositoryReleaseConfigRecentScheduledReleaseRecordErrorStatus {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface RepositoryWorkflowConfigInvocationConfig {
        /**
         * Optional. When set to true, any incremental tables will be fully refreshed.
         */
        fullyRefreshIncrementalTablesEnabled?: pulumi.Input<boolean>;
        /**
         * Optional. The set of tags to include.
         */
        includedTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. The set of action identifiers to include.
         * Structure is documented below.
         */
        includedTargets?: pulumi.Input<pulumi.Input<inputs.dataform.RepositoryWorkflowConfigInvocationConfigIncludedTarget>[]>;
        /**
         * Optional. The service account to run workflow invocations under.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Optional. When set to true, transitive dependencies of included actions will be executed.
         */
        transitiveDependenciesIncluded?: pulumi.Input<boolean>;
        /**
         * Optional. When set to true, transitive dependents of included actions will be executed.
         */
        transitiveDependentsIncluded?: pulumi.Input<boolean>;
    }

    export interface RepositoryWorkflowConfigInvocationConfigIncludedTarget {
        /**
         * The action's database (Google Cloud project ID).
         */
        database?: pulumi.Input<string>;
        /**
         * The action's name, within database and schema.
         */
        name?: pulumi.Input<string>;
        /**
         * The action's schema (BigQuery dataset ID), within database.
         */
        schema?: pulumi.Input<string>;
    }

    export interface RepositoryWorkflowConfigRecentScheduledExecutionRecord {
        /**
         * (Output)
         * The error status encountered upon this attempt to create the workflow invocation, if the attempt was unsuccessful.
         * Structure is documented below.
         */
        errorStatuses?: pulumi.Input<pulumi.Input<inputs.dataform.RepositoryWorkflowConfigRecentScheduledExecutionRecordErrorStatus>[]>;
        /**
         * (Output)
         * The timestamp of this workflow attempt.
         */
        executionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The name of the created workflow invocation, if one was successfully created. In the format projects/*&#47;locations/*&#47;repositories/*&#47;workflowInvocations/*.
         */
        workflowInvocation?: pulumi.Input<string>;
    }

    export interface RepositoryWorkflowConfigRecentScheduledExecutionRecordErrorStatus {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface RepositoryWorkspaceCompilationOverrides {
        /**
         * The default database (Google Cloud project ID).
         */
        defaultDatabase?: pulumi.Input<string>;
        /**
         * The suffix that should be appended to all schema (BigQuery dataset ID) names.
         */
        schemaSuffix?: pulumi.Input<string>;
        /**
         * The prefix that should be prepended to all table names.
         */
        tablePrefix?: pulumi.Input<string>;
    }
}

export namespace datafusion {
    export interface InstanceAccelerator {
        /**
         * The type of an accelator for a CDF instance.
         * Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
         */
        acceleratorType: pulumi.Input<string>;
        /**
         * The type of an accelator for a CDF instance.
         * Possible values are: `ENABLED`, `DISABLED`.
         */
        state: pulumi.Input<string>;
    }

    export interface InstanceCryptoKeyConfig {
        /**
         * The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         */
        keyReference: pulumi.Input<string>;
    }

    export interface InstanceEventPublishConfig {
        /**
         * Option to enable Event Publishing.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
         */
        topic: pulumi.Input<string>;
    }

    export interface InstanceNetworkConfig {
        /**
         * Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
         * the corresponding tenant project from a predefined list of available connection modes.
         * If this field is unspecified for a private instance, VPC peering is used.
         * Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
         */
        connectionType?: pulumi.Input<string>;
        /**
         * The IP range in CIDR notation to use for the managed Data Fusion instance
         * nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
         */
        ipAllocation?: pulumi.Input<string>;
        /**
         * Name of the network in the project with which the tenant project
         * will be peered for executing pipelines. In case of shared VPC where the network resides in another host
         * project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
         */
        network?: pulumi.Input<string>;
        /**
         * Optional. Configuration for Private Service Connect.
         * This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
         * Structure is documented below.
         */
        privateServiceConnectConfig?: pulumi.Input<inputs.datafusion.InstanceNetworkConfigPrivateServiceConnectConfig>;
    }

    export interface InstanceNetworkConfigPrivateServiceConnectConfig {
        /**
         * (Output)
         * Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
         * The size of this block is /25. The format of this field is governed by RFC 4632.
         */
        effectiveUnreachableCidrBlock?: pulumi.Input<string>;
        /**
         * Optional. The reference to the network attachment used to establish private connectivity.
         * It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
         * This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
         */
        networkAttachment?: pulumi.Input<string>;
        /**
         * Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
         * The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
         * This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
         * If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
         */
        unreachableCidrBlock?: pulumi.Input<string>;
    }
}

export namespace dataloss {
    export interface PreventionDeidentifyTemplateDeidentifyConfig {
        /**
         * Treat the dataset as an image and redact.
         * Structure is documented below.
         */
        imageTransformations?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformations>;
        /**
         * Treat the dataset as free-form text and apply the same free text transformation everywhere
         * Structure is documented below.
         */
        infoTypeTransformations?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformations>;
        /**
         * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
         * Structure is documented below.
         */
        recordTransformations?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformations>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformations {
        /**
         * For determination of how redaction of images should occur.
         * Structure is documented below.
         */
        transforms: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransform>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransform {
        /**
         * Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
         */
        allInfoTypes?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypes>;
        /**
         * Apply transformation to all text that doesn't match an infoType.
         */
        allText?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllText>;
        /**
         * The color to use when redacting content from an image. If not specified, the default is black.
         * Structure is documented below.
         */
        redactionColor?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColor>;
        /**
         * Apply transformation to the selected infoTypes.
         * Structure is documented below.
         */
        selectedInfoTypes?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypes>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypes {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllText {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColor {
        /**
         * The amount of blue in the color as a value in the interval [0, 1].
         */
        blue?: pulumi.Input<number>;
        /**
         * The amount of green in the color as a value in the interval [0, 1].
         */
        green?: pulumi.Input<number>;
        /**
         * The amount of red in the color as a value in the interval [0, 1].
         */
        red?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypes {
        /**
         * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
         * all findings that correspond to infoTypes that were requested in InspectConfig.
         * Structure is documented below.
         */
        infoTypes: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoType>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoType {
        /**
         * Name of the information type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformations {
        /**
         * Transformation for each infoType. Cannot specify more than one for a given infoType.
         * Structure is documented below.
         */
        transformations: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformation>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformation {
        /**
         * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
         * all findings that correspond to infoTypes that were requested in InspectConfig.
         * Structure is documented below.
         */
        infoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoType>[]>;
        /**
         * Apply the transformation to the entire field.
         * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
         * Structure is documented below.
         */
        primitiveTransformation: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformation>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoType {
        /**
         * Name of the information type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformation {
        /**
         * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
         * This can be used on data of type: number, long, string, timestamp.
         * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        bucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfig>;
        /**
         * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
         * Structure is documented below.
         */
        characterMaskConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfig>;
        /**
         * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
         * Structure is documented below.
         */
        cryptoDeterministicConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfig>;
        /**
         * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
         * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
         * Currently, only string and integer values can be hashed.
         * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
         * Structure is documented below.
         */
        cryptoHashConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfig>;
        /**
         * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
         * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
         * Structure is documented below.
         */
        cryptoReplaceFfxFpeConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig>;
        /**
         * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
         * Structure is documented below.
         */
        dateShiftConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfig>;
        /**
         * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
         * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lowerBound = 10 and upperBound = 20, all values that are within this bucket will be replaced with "10-20".
         * This can be used on data of type: double, long.
         * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        fixedSizeBucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfig>;
        /**
         * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
         */
        redactConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfig>;
        /**
         * Replace each input value with a given value.
         * Structure is documented below.
         */
        replaceConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfig>;
        /**
         * Replace with a value randomly drawn (with replacement) from a dictionary.
         * Structure is documented below.
         */
        replaceDictionaryConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfig>;
        /**
         * Replace each matching finding with the name of the info type.
         */
        replaceWithInfoTypeConfig?: pulumi.Input<boolean>;
        /**
         * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
         * Structure is documented below.
         */
        timePartConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfig>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfig {
        /**
         * Set of buckets. Ranges must be non-overlapping.
         * Bucket is represented as a range, along with replacement values.
         * Structure is documented below.
         */
        buckets?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucket>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucket {
        /**
         * Upper bound of the range, exclusive; type must match min.
         * The `max` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        max?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMax>;
        /**
         * Lower bound of the range, inclusive. Type should be the same as max if used.
         * The `min` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        min?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMin>;
        /**
         * Replacement value for this bucket.
         * The `replacementValue` block must only contain one argument.
         * Structure is documented below.
         */
        replacementValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMax {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMin {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfig {
        /**
         * Characters to skip when doing de-identification of a value. These will be left alone and skipped.
         * Structure is documented below.
         */
        charactersToIgnores?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>[]>;
        /**
         * Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
         * such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
         * strings, and 0 for digits.
         */
        maskingCharacter?: pulumi.Input<string>;
        /**
         * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
         * If numberToMask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
         */
        numberToMask?: pulumi.Input<number>;
        /**
         * Mask characters in reverse order. For example, if maskingCharacter is 0, numberToMask is 14, and reverseOrder is `false`, then the
         * input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
         */
        reverseOrder?: pulumi.Input<boolean>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
        /**
         * Characters to not transform when masking. Only one of this or `commonCharactersToIgnore` must be specified.
         */
        charactersToSkip?: pulumi.Input<string>;
        /**
         * Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `charactersToSkip` must be specified.
         * Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
         */
        commonCharactersToIgnore?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfig {
        /**
         * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
         * If the context is not set, plaintext would be used as is for encryption. If the context is set but:
         * 1. there is no record present when transforming a given value or
         * 2. the field is not present when transforming a given value,
         * plaintext would be used as is for encryption.
         * Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContext>;
        /**
         * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey>;
        /**
         * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
         * For example, if the name of custom info type is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
         * Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
         * In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
         * *   reverse a surrogate that does not correspond to an actual identifier
         * *   be unable to parse the surrogate and result in an error
         * Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE.
         * Structure is documented below.
         */
        surrogateInfoType?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContext {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name?: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfig {
        /**
         * The key used by the encryption function.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKey>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig {
        /**
         * Common alphabets. Only one of this, `customAlphabet` or `radix` must be specified.
         * Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
         */
        commonAlphabet?: pulumi.Input<string>;
        /**
         * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
         * If the context is set but:
         * 1.  there is no record present when transforming a given value or
         * 2.  the field is not present when transforming a given value,
         * a default tweak will be used.
         * Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
         * The tweak is constructed as a sequence of bytes in big endian byte order such that:
         * *   a 64 bit integer is encoded followed by a single byte of value 1
         * *   a string is encoded in UTF-8 format followed by a single byte of value 2
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>;
        /**
         * The key used by the encryption algorithm.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>;
        /**
         * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \[2, 95\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
         * ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `commonAlphabet` or `radix` must be specified.
         */
        customAlphabet?: pulumi.Input<string>;
        /**
         * The native way to select the alphabet. Must be in the range \[2, 95\]. Only one of this, `customAlphabet` or `commonAlphabet` must be specified.
         */
        radix?: pulumi.Input<number>;
        /**
         * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\_type\_name(surrogate\_character\_count):surrogate
         * For example, if the name of custom infoType is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
         * In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE
         * Structure is documented below.
         */
        surrogateInfoType?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name?: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfig {
        /**
         * Points to the field that contains the context, for example, an entity id.
         * If set, must also set cryptoKey. If set, shift will be consistent for the given context.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContext>;
        /**
         * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKey>;
        /**
         * For example, -5 means shift date to at most 5 days back in the past.
         */
        lowerBoundDays: pulumi.Input<number>;
        /**
         * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
         * For example, 3 means shift date to at most 3 days into the future.
         */
        upperBoundDays: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContext {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfig {
        /**
         * Size of each bucket (except for minimum and maximum buckets).
         * So if lowerBound = 10, upperBound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
         * Precision up to 2 decimals works.
         */
        bucketSize: pulumi.Input<number>;
        /**
         * Lower bound value of buckets.
         * All values less than lowerBound are grouped together into a single bucket; for example if lowerBound = 10, then all values less than 10 are replaced with the value "-10".
         * The `lowerBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        lowerBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound>;
        /**
         * Upper bound value of buckets.
         * All values greater than upperBound are grouped together into a single bucket; for example if upperBound = 89, then all values greater than 89 are replaced with the value "89+".
         * The `upperBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        upperBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfig {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfig {
        /**
         * Replace each input value with a given value.
         * The `newValue` block must only contain one argument. For example when replacing the contents of a string-type field, only `stringValue` should be set.
         * Structure is documented below.
         */
        newValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<number>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfig {
        /**
         * A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
         * Structure is documented below.
         */
        wordList: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordList>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfig {
        /**
         * The part of the time to keep.
         * Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
         */
        partToExtract?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformations {
        /**
         * Transform the record by applying various field transformations.
         * Structure is documented below.
         */
        fieldTransformations?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformation>[]>;
        /**
         * Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
         * Structure is documented below.
         */
        recordSuppressions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppression>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformation {
        /**
         * Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
         * Example Use Cases:
         * - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
         * - Redact a field if the date of birth field is greater than 85.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationCondition>;
        /**
         * Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
         * FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
         * Structure is documented below.
         */
        fields: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationField>[]>;
        /**
         * Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         */
        infoTypeTransformations?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformations>;
        /**
         * Apply the transformation to the entire field.
         * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
         * Only one of `primitiveTransformation` or `infoTypeTransformations` must be specified.
         * Structure is documented below.
         */
        primitiveTransformation?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformation>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationCondition {
        /**
         * An expression, consisting of an operator and conditions.
         * Structure is documented below.
         */
        expressions?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressions>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressions {
        /**
         * Conditions to apply to the expression.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditions>;
        /**
         * The operator to apply to the result of conditions. Default and currently only supported value is AND.
         * Default value is `AND`.
         * Possible values are: `AND`.
         */
        logicalOperator?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditions {
        /**
         * A collection of conditions.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsCondition>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsCondition {
        /**
         * Field within the record this condition is evaluated against.
         * Structure is documented below.
         */
        field: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionField>;
        /**
         * Operator used to compare the field or infoType to the value.
         * Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
         */
        operator: pulumi.Input<string>;
        /**
         * Value to compare against. [Mandatory, except for EXISTS tests.]
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionField {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationField {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformations {
        /**
         * Transformation for each infoType. Cannot specify more than one for a given infoType.
         * Structure is documented below.
         */
        transformations: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformation>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformation {
        /**
         * InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
         * all findings that correspond to infoTypes that were requested in InspectConfig.
         * Structure is documented below.
         */
        infoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoType>[]>;
        /**
         * Apply the transformation to the entire field.
         * The `primitiveTransformation` block must only contain one argument, corresponding to the type of transformation.
         * Structure is documented below.
         */
        primitiveTransformation: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformation>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoType {
        /**
         * Name of the information type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformation {
        /**
         * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
         * This can be used on data of type: number, long, string, timestamp.
         * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        bucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfig>;
        /**
         * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
         * Structure is documented below.
         */
        characterMaskConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfig>;
        /**
         * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
         * Structure is documented below.
         */
        cryptoDeterministicConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfig>;
        /**
         * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
         * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
         * Currently, only string and integer values can be hashed.
         * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
         * Structure is documented below.
         */
        cryptoHashConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfig>;
        /**
         * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
         * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
         * Structure is documented below.
         */
        cryptoReplaceFfxFpeConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig>;
        /**
         * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
         * Structure is documented below.
         */
        dateShiftConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfig>;
        /**
         * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
         * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lowerBound = 10 and upperBound = 20, all values that are within this bucket will be replaced with "10-20".
         * This can be used on data of type: double, long.
         * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        fixedSizeBucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfig>;
        /**
         * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
         */
        redactConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfig>;
        /**
         * Replace each input value with a given value.
         * Structure is documented below.
         */
        replaceConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfig>;
        /**
         * Replace with a value randomly drawn (with replacement) from a dictionary.
         * Structure is documented below.
         */
        replaceDictionaryConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfig>;
        /**
         * Replace each matching finding with the name of the info type.
         */
        replaceWithInfoTypeConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfig>;
        /**
         * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
         * Structure is documented below.
         */
        timePartConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfig>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfig {
        /**
         * Set of buckets. Ranges must be non-overlapping.
         * Bucket is represented as a range, along with replacement values.
         * Structure is documented below.
         */
        buckets: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucket>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucket {
        /**
         * Upper bound of the range, exclusive; type must match min.
         * The `max` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        max?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMax>;
        /**
         * Lower bound of the range, inclusive. Type should be the same as max if used.
         * The `min` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        min?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMin>;
        /**
         * Replacement value for this bucket.
         * The `replacementValue` block must only contain one argument.
         * Structure is documented below.
         */
        replacementValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMax {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMin {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue {
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfig {
        /**
         * Characters to skip when doing de-identification of a value. These will be left alone and skipped.
         * Structure is documented below.
         */
        charactersToIgnores?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>[]>;
        /**
         * Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
         * such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
         * strings, and 0 for digits.
         */
        maskingCharacter?: pulumi.Input<string>;
        /**
         * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
         * If numberToMask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
         */
        numberToMask?: pulumi.Input<number>;
        /**
         * Mask characters in reverse order. For example, if maskingCharacter is 0, numberToMask is 14, and reverseOrder is `false`, then the
         * input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
         */
        reverseOrder?: pulumi.Input<boolean>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
        /**
         * Characters to not transform when masking. Only one of this or `commonCharactersToIgnore` must be specified.
         */
        charactersToSkip?: pulumi.Input<string>;
        /**
         * Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `charactersToSkip` must be specified.
         * Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
         */
        commonCharactersToIgnore?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfig {
        /**
         * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
         * If the context is not set, plaintext would be used as is for encryption. If the context is set but:
         * 1. there is no record present when transforming a given value or
         * 2. the field is not present when transforming a given value,
         * plaintext would be used as is for encryption.
         * Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContext>;
        /**
         * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
         * Structure is documented below.
         */
        cryptoKey: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey>;
        /**
         * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
         * For example, if the name of custom info type is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
         * Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
         * In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
         * *   reverse a surrogate that does not correspond to an actual identifier
         * *   be unable to parse the surrogate and result in an error
         * Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE.
         * Structure is documented below.
         */
        surrogateInfoType: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContext {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfig {
        /**
         * The key used by the encryption function.
         * Structure is documented below.
         */
        cryptoKey: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKey>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig {
        /**
         * Common alphabets. Only one of this, `customAlphabet` or `radix` must be specified.
         * Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
         */
        commonAlphabet?: pulumi.Input<string>;
        /**
         * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
         * If the context is set but:
         * 1.  there is no record present when transforming a given value or
         * 2.  the field is not present when transforming a given value,
         * a default tweak will be used.
         * Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
         * The tweak is constructed as a sequence of bytes in big endian byte order such that:
         * *   a 64 bit integer is encoded followed by a single byte of value 1
         * *   a string is encoded in UTF-8 format followed by a single byte of value 2
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>;
        /**
         * The key used by the encryption algorithm.
         * Structure is documented below.
         */
        cryptoKey: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>;
        /**
         * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \[2, 95\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
         * ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `commonAlphabet` or `radix` must be specified.
         */
        customAlphabet?: pulumi.Input<string>;
        /**
         * The native way to select the alphabet. Must be in the range \[2, 95\]. Only one of this, `customAlphabet` or `commonAlphabet` must be specified.
         */
        radix?: pulumi.Input<number>;
        /**
         * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\_type\_name(surrogate\_character\_count):surrogate
         * For example, if the name of custom infoType is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
         * In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE
         * Structure is documented below.
         */
        surrogateInfoType?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfig {
        /**
         * Points to the field that contains the context, for example, an entity id.
         * If set, must also set cryptoKey. If set, shift will be consistent for the given context.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContext>;
        /**
         * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKey>;
        /**
         * For example, -5 means shift date to at most 5 days back in the past.
         */
        lowerBoundDays: pulumi.Input<number>;
        /**
         * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
         * For example, 3 means shift date to at most 3 days into the future.
         */
        upperBoundDays: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContext {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfig {
        /**
         * Size of each bucket (except for minimum and maximum buckets).
         * So if lowerBound = 10, upperBound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
         * Precision up to 2 decimals works.
         */
        bucketSize: pulumi.Input<number>;
        /**
         * Lower bound value of buckets.
         * All values less than lowerBound are grouped together into a single bucket; for example if lowerBound = 10, then all values less than 10 are replaced with the value "-10".
         * The `lowerBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        lowerBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound>;
        /**
         * Upper bound value of buckets.
         * All values greater than upperBound are grouped together into a single bucket; for example if upperBound = 89, then all values greater than 89 are replaced with the value "89+".
         * The `upperBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        upperBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfig {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfig {
        /**
         * Replace each input value with a given value.
         * The `newValue` block must only contain one argument. For example when replacing the contents of a string-type field, only `stringValue` should be set.
         * Structure is documented below.
         */
        newValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfig {
        /**
         * A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
         * Structure is documented below.
         */
        wordList: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordList>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfig {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfig {
        /**
         * The part of the time to keep.
         * Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
         */
        partToExtract: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformation {
        /**
         * Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
         * This can be used on data of type: number, long, string, timestamp.
         * If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        bucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfig>;
        /**
         * Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
         * Structure is documented below.
         */
        characterMaskConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfig>;
        /**
         * Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
         * Structure is documented below.
         */
        cryptoDeterministicConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfig>;
        /**
         * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
         * Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
         * Currently, only string and integer values can be hashed.
         * See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
         * Structure is documented below.
         */
        cryptoHashConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfig>;
        /**
         * Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
         * Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
         * Structure is documented below.
         */
        cryptoReplaceFfxFpeConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig>;
        /**
         * Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
         * Structure is documented below.
         */
        dateShiftConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfig>;
        /**
         * Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
         * The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lowerBound = 10 and upperBound = 20, all values that are within this bucket will be replaced with "10-20".
         * This can be used on data of type: double, long.
         * If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
         * See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
         * Structure is documented below.
         */
        fixedSizeBucketingConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfig>;
        /**
         * Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
         */
        redactConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfig>;
        /**
         * Replace each input value with a given value.
         * Structure is documented below.
         */
        replaceConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfig>;
        /**
         * Replace with a value randomly drawn (with replacement) from a dictionary.
         * Structure is documented below.
         */
        replaceDictionaryConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfig>;
        /**
         * For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
         * Structure is documented below.
         */
        timePartConfig?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfig>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfig {
        /**
         * Set of buckets. Ranges must be non-overlapping.
         * Bucket is represented as a range, along with replacement values.
         * Structure is documented below.
         */
        buckets?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucket>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucket {
        /**
         * Upper bound of the range, exclusive; type must match min.
         * The `max` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        max?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMax>;
        /**
         * Lower bound of the range, inclusive. Type should be the same as max if used.
         * The `min` block must only contain one argument. See the `bucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        min?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMin>;
        /**
         * Replacement value for this bucket.
         * The `replacementValue` block must only contain one argument.
         * Structure is documented below.
         */
        replacementValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMax {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMin {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfig {
        /**
         * Characters to skip when doing de-identification of a value. These will be left alone and skipped.
         * Structure is documented below.
         */
        charactersToIgnores?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore>[]>;
        /**
         * Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
         * such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
         * strings, and 0 for digits.
         */
        maskingCharacter?: pulumi.Input<string>;
        /**
         * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
         * If numberToMask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
         */
        numberToMask?: pulumi.Input<number>;
        /**
         * Mask characters in reverse order. For example, if maskingCharacter is 0, numberToMask is 14, and reverseOrder is `false`, then the
         * input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
         */
        reverseOrder?: pulumi.Input<boolean>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
        /**
         * Characters to not transform when masking. Only one of this or `commonCharactersToIgnore` must be specified.
         */
        charactersToSkip?: pulumi.Input<string>;
        /**
         * Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `charactersToSkip` must be specified.
         * Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
         */
        commonCharactersToIgnore?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfig {
        /**
         * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
         * If the context is not set, plaintext would be used as is for encryption. If the context is set but:
         * 1. there is no record present when transforming a given value or
         * 2. the field is not present when transforming a given value,
         * plaintext would be used as is for encryption.
         * Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContext>;
        /**
         * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey>;
        /**
         * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
         * For example, if the name of custom info type is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
         * Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
         * In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
         * *   reverse a surrogate that does not correspond to an actual identifier
         * *   be unable to parse the surrogate and result in an error
         * Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE.
         * Structure is documented below.
         */
        surrogateInfoType?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContext {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name?: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfig {
        /**
         * The key used by the encryption function.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKey>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfig {
        /**
         * Common alphabets. Only one of this, `customAlphabet` or `radix` must be specified.
         * Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
         */
        commonAlphabet?: pulumi.Input<string>;
        /**
         * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
         * If the context is set but:
         * 1.  there is no record present when transforming a given value or
         * 2.  the field is not present when transforming a given value,
         * a default tweak will be used.
         * Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
         * The tweak is constructed as a sequence of bytes in big endian byte order such that:
         * *   a 64 bit integer is encoded followed by a single byte of value 1
         * *   a string is encoded in UTF-8 format followed by a single byte of value 2
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext>;
        /**
         * The key used by the encryption algorithm.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey>;
        /**
         * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \[2, 95\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
         * ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `commonAlphabet` or `radix` must be specified.
         */
        customAlphabet?: pulumi.Input<string>;
        /**
         * The native way to select the alphabet. Must be in the range \[2, 95\]. Only one of this, `customAlphabet` or `commonAlphabet` must be specified.
         */
        radix?: pulumi.Input<number>;
        /**
         * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\_type\_name(surrogate\_character\_count):surrogate
         * For example, if the name of custom infoType is 'MY\_TOKEN\_INFO\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\_TOKEN\_INFO\_TYPE(3):abc'
         * This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
         * In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\_TOKEN\_TYPE
         * Structure is documented below.
         */
        surrogateInfoType?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
         */
        name?: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore>;
        /**
         * Optional version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfig {
        /**
         * Points to the field that contains the context, for example, an entity id.
         * If set, must also set cryptoKey. If set, shift will be consistent for the given context.
         * Structure is documented below.
         */
        context?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContext>;
        /**
         * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
         * Structure is documented below.
         */
        cryptoKey?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKey>;
        /**
         * For example, -5 means shift date to at most 5 days back in the past.
         */
        lowerBoundDays: pulumi.Input<number>;
        /**
         * Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
         * For example, 3 means shift date to at most 3 days into the future.
         */
        upperBoundDays: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContext {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKey {
        /**
         * KMS wrapped key.
         * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
         * For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
         * Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
         * Structure is documented below.
         */
        kmsWrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped>;
        /**
         * Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        transient?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient>;
        /**
         * Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kmsWrapped` must be specified.
         * Structure is documented below.
         */
        unwrapped?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
        /**
         * The resource name of the KMS CryptoKey to use for unwrapping.
         */
        cryptoKeyName: pulumi.Input<string>;
        /**
         * The wrapped data crypto key.
         * A base64-encoded string.
         */
        wrappedKey: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
        /**
         * Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
        /**
         * A 128/192/256 bit key.
         * A base64-encoded string.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        key: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfig {
        /**
         * Size of each bucket (except for minimum and maximum buckets).
         * So if lowerBound = 10, upperBound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
         * Precision up to 2 decimals works.
         */
        bucketSize: pulumi.Input<number>;
        /**
         * Lower bound value of buckets.
         * All values less than lowerBound are grouped together into a single bucket; for example if lowerBound = 10, then all values less than 10 are replaced with the value "-10".
         * The `lowerBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        lowerBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound>;
        /**
         * Upper bound value of buckets.
         * All values greater than upperBound are grouped together into a single bucket; for example if upperBound = 89, then all values greater than 89 are replaced with the value "89+".
         * The `upperBound` block must only contain one argument. See the `fixedSizeBucketingConfig` block description for more information about choosing a data type.
         * Structure is documented below.
         */
        upperBound: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfig {
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfig {
        /**
         * Replace each input value with a given value.
         * The `newValue` block must only contain one argument. For example when replacing the contents of a string-type field, only `stringValue` should be set.
         * Structure is documented below.
         */
        newValue: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfig {
        /**
         * A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordList>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfig {
        /**
         * The part of the time to keep.
         * Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
         */
        partToExtract?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppression {
        /**
         * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionCondition>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionCondition {
        /**
         * An expression, consisting of an operator and conditions.
         * Structure is documented below.
         */
        expressions?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressions>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressions {
        /**
         * Conditions to apply to the expression.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditions>;
        /**
         * The operator to apply to the result of conditions. Default and currently only supported value is AND.
         * Default value is `AND`.
         * Possible values are: `AND`.
         */
        logicalOperator?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditions {
        /**
         * A collection of conditions.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsCondition>[]>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsCondition {
        /**
         * Field within the record this condition is evaluated against.
         * Structure is documented below.
         */
        field: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionField>;
        /**
         * Operator used to compare the field or infoType to the value.
         * Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
         */
        operator: pulumi.Input<string>;
        /**
         * Value to compare against. [Mandatory, except for EXISTS tests.]
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValue>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionField {
        /**
         * Name describing the field.
         */
        name?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValue {
        /**
         * A boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Represents a whole or partial calendar date.
         * Structure is documented below.
         */
        dateValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValue>;
        /**
         * Represents a day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeekValue?: pulumi.Input<string>;
        /**
         * A float value.
         */
        floatValue?: pulumi.Input<number>;
        /**
         * An integer value (int64 format)
         */
        integerValue?: pulumi.Input<string>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
        /**
         * Represents a time of day.
         * Structure is documented below.
         */
        timeValue?: pulumi.Input<inputs.dataloss.PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValue>;
        /**
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        timestampValue?: pulumi.Input<string>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValue {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
         *
         * - - -
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValue {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PreventionDiscoveryConfigAction {
        /**
         * Export data profiles into a provided location
         * Structure is documented below.
         */
        exportData?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionExportData>;
        /**
         * Publish a message into the Pub/Sub topic.
         * Structure is documented below.
         */
        pubSubNotification?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionPubSubNotification>;
        /**
         * Publish a message into the Pub/Sub topic.
         * Structure is documented below.
         */
        tagResources?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionTagResources>;
    }

    export interface PreventionDiscoveryConfigActionExportData {
        /**
         * Store all table and column profiles in an existing table or a new table in an existing dataset. Each re-generation will result in a new row in BigQuery
         * Structure is documented below.
         */
        profileTable?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionExportDataProfileTable>;
    }

    export interface PreventionDiscoveryConfigActionExportDataProfileTable {
        /**
         * Dataset Id of the table
         */
        datasetId?: pulumi.Input<string>;
        /**
         * The Google Cloud Platform project ID of the project containing the table. If omitted, the project ID is inferred from the API call.
         */
        projectId?: pulumi.Input<string>;
        /**
         * Name of the table
         */
        tableId?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigActionPubSubNotification {
        /**
         * How much data to include in the pub/sub message.
         * Possible values are: `TABLE_PROFILE`, `RESOURCE_NAME`.
         */
        detailOfMessage?: pulumi.Input<string>;
        /**
         * The type of event that triggers a Pub/Sub. At most one PubSubNotification per EventType is permitted.
         * Possible values are: `NEW_PROFILE`, `CHANGED_PROFILE`, `SCORE_INCREASED`, `ERROR_CHANGED`.
         */
        event?: pulumi.Input<string>;
        /**
         * Conditions for triggering pubsub
         * Structure is documented below.
         */
        pubsubCondition?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionPubSubNotificationPubsubCondition>;
        /**
         * Cloud Pub/Sub topic to send notifications to. Format is projects/{project}/topics/{topic}.
         */
        topic?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigActionPubSubNotificationPubsubCondition {
        /**
         * An expression
         * Structure is documented below.
         */
        expressions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressions>;
    }

    export interface PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressions {
        /**
         * Conditions to apply to the expression
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsCondition>[]>;
        /**
         * The operator to apply to the collection of conditions
         * Possible values are: `OR`, `AND`.
         */
        logicalOperator?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsCondition {
        /**
         * The minimum data risk score that triggers the condition.
         * Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
         */
        minimumRiskScore?: pulumi.Input<string>;
        /**
         * The minimum sensitivity level that triggers the condition.
         * Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
         */
        minimumSensitivityScore?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigActionTagResources {
        /**
         * Whether applying a tag to a resource should lower the risk of the profile for that resource. For example, in conjunction with an [IAM deny policy](https://cloud.google.com/iam/docs/deny-overview), you can deny all principals a permission if a tag value is present, mitigating the risk of the resource. This also lowers the data risk of resources at the lower levels of the resource hierarchy. For example, reducing the data risk of a table data profile also reduces the data risk of the constituent column data profiles.
         */
        lowerDataRiskToLow?: pulumi.Input<boolean>;
        /**
         * The profile generations for which the tag should be attached to resources. If you attach a tag to only new profiles, then if the sensitivity score of a profile subsequently changes, its tag doesn't change. By default, this field includes only new profiles. To include both new and updated profiles for tagging, this field should explicitly include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
         * Each value may be one of: `PROFILE_GENERATION_NEW`, `PROFILE_GENERATION_UPDATE`.
         */
        profileGenerationsToTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The tags to associate with different conditions.
         * Structure is documented below.
         */
        tagConditions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionTagResourcesTagCondition>[]>;
    }

    export interface PreventionDiscoveryConfigActionTagResourcesTagCondition {
        /**
         * Conditions attaching the tag to a resource on its profile having this sensitivity score.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScore>;
        /**
         * The tag value to attach to resources.
         * Structure is documented below.
         */
        tag?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigActionTagResourcesTagConditionTag>;
    }

    export interface PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigActionTagResourcesTagConditionTag {
        /**
         * The namespaced name for the tag value to attach to resources. Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for example, "123456/environment/prod".
         */
        namespacedValue?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigError {
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigErrorDetails>;
        /**
         * The times the error occurred. List includes the oldest timestamp and the last 9 timestamps.
         */
        timestamp?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigErrorDetails {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigOrgConfig {
        /**
         * The data to scan folder org or project
         * Structure is documented below.
         */
        location?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigOrgConfigLocation>;
        /**
         * The project that will run the scan. The DLP service account that exists within this project must have access to all resources that are profiled, and the cloud DLP API must be enabled.
         */
        projectId?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigOrgConfigLocation {
        /**
         * The ID for the folder within an organization to scan
         */
        folderId?: pulumi.Input<string>;
        /**
         * The ID of an organization to scan
         */
        organizationId?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTarget {
        /**
         * BigQuery target for Discovery. The first target to match a table will be the one applied.
         * Structure is documented below.
         */
        bigQueryTarget?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTarget>;
        /**
         * Cloud SQL target for Discovery. The first target to match a table will be the one applied.
         * Structure is documented below.
         */
        cloudSqlTarget?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTarget>;
        /**
         * Cloud Storage target for Discovery. The first target to match a bucket will be the one applied.
         * Structure is documented below.
         */
        cloudStorageTarget?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTarget>;
        /**
         * Discovery target that looks for credentials and secrets stored in cloud resource metadata and reports them as vulnerabilities to Security Command Center. Only one target of this type is allowed.
         */
        secretsTarget?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetSecretsTarget>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTarget {
        /**
         * How often and when to update profiles. New tables that match both the fiter and conditions are scanned as quickly as possible depending on system capacity.
         * Structure is documented below.
         */
        cadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetCadence>;
        /**
         * In addition to matching the filter, these conditions must be true before a profile is generated
         * Structure is documented below.
         */
        conditions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetConditions>;
        /**
         * Tables that match this filter will not have profiles created.
         */
        disabled?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetDisabled>;
        /**
         * Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table
         * Structure is documented below.
         */
        filter?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilter>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetCadence {
        /**
         * Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
         * Structure is documented below.
         */
        inspectTemplateModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadence>;
        /**
         * Governs when to update data profiles when a schema is modified
         * Structure is documented below.
         */
        schemaModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadence>;
        /**
         * Governs when to update profile when a table is modified.
         * Structure is documented below.
         */
        tableModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadence>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadence {
        /**
         * How frequently data profiles can be updated when the template is modified. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadence {
        /**
         * Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency?: pulumi.Input<string>;
        /**
         * The types of schema modifications to consider. Defaults to NEW_COLUMNS.
         * Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadence {
        /**
         * How frequently data profiles can be updated when tables are modified. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency?: pulumi.Input<string>;
        /**
         * The type of events to consider when deciding if the table has been modified and should have the profile updated. Defaults to MODIFIED_TIMESTAMP
         * Each value may be one of: `TABLE_MODIFIED_TIMESTAMP`.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetConditions {
        /**
         * File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
         */
        createdAfter?: pulumi.Input<string>;
        /**
         * At least one of the conditions must be true for a table to be scanned.
         * Structure is documented below.
         */
        orConditions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditions>;
        /**
         * Restrict discovery to categories of table types. Currently view, materialized view, snapshot and non-biglake external tables are supported.
         * Possible values are: `BIG_QUERY_COLLECTION_ALL_TYPES`, `BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES`.
         */
        typeCollection?: pulumi.Input<string>;
        /**
         * Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
         * Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
         */
        types?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypes>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditions {
        /**
         * Duration format. The minimum age a table must have before Cloud DLP can profile it. Value greater than 1.
         */
        minAge?: pulumi.Input<string>;
        /**
         * Minimum number of rows that should be present before Cloud DLP profiles as a table.
         */
        minRowCount?: pulumi.Input<number>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypes {
        /**
         * A set of BiqQuery table types
         * Each value may be one of: `BIG_QUERY_TABLE_TYPE_TABLE`, `BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE`.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetDisabled {
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilter {
        /**
         * Catch-all. This should always be the last filter in the list because anything above it will apply first.
         */
        otherTables?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTables>;
        /**
         * The table to scan. Discovery configurations including this can only include one DiscoveryTarget (the DiscoveryTarget with this TableReference).
         * Structure is documented below.
         */
        tableReference?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReference>;
        /**
         * A specific set of tables for this filter to apply to. A table collection must be specified in only one filter per config.
         * Structure is documented below.
         */
        tables?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilterTables>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTables {
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReference {
        /**
         * Dataset ID of the table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * Name of the table.
         */
        tableId: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilterTables {
        /**
         * A collection of regular expressions to match a BQ table against.
         * Structure is documented below.
         */
        includeRegexes?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexes>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexes {
        /**
         * The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
         * Structure is documented below.
         */
        patterns?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPattern>[]>;
    }

    export interface PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPattern {
        /**
         * if unset, this property matches all datasets
         */
        datasetIdRegex?: pulumi.Input<string>;
        /**
         * For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
         */
        projectIdRegex?: pulumi.Input<string>;
        /**
         * if unset, this property matches all tables
         */
        tableIdRegex?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTarget {
        /**
         * In addition to matching the filter, these conditions must be true before a profile is generated.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetConditions>;
        /**
         * Disable profiling for database resources that match this filter.
         */
        disabled?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetDisabled>;
        /**
         * Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table.
         * Structure is documented below.
         */
        filter: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilter>;
        /**
         * How often and when to update profiles. New tables that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
         * Structure is documented below.
         */
        generationCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadence>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetConditions {
        /**
         * Database engines that should be profiled. Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
         * Each value may be one of: `ALL_SUPPORTED_DATABASE_ENGINES`, `MYSQL`, `POSTGRES`.
         */
        databaseEngines?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
         * Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetDisabled {
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilter {
        /**
         * A specific set of buckets for this filter to apply to.
         * Structure is documented below.
         */
        collection?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollection>;
        /**
         * The database resource to scan. Targets including this can only include one target (the target with this database resource reference).
         * Structure is documented below.
         */
        databaseResourceReference?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReference>;
        /**
         * Match discovery resources not covered by any other filter.
         */
        others?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthers>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollection {
        /**
         * A collection of regular expressions to match a file store against.
         * Structure is documented below.
         */
        includeRegexes?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexes>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexes {
        /**
         * The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
         * Structure is documented below.
         */
        patterns?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPattern>[]>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPattern {
        /**
         * Regex to test the database name against. If empty, all databases match.
         */
        databaseRegex?: pulumi.Input<string>;
        /**
         * Regex to test the database resource's name against. An example of a database resource name is a table's name. Other database resource names like view names could be included in the future. If empty, all database resources match.'
         */
        databaseResourceNameRegex?: pulumi.Input<string>;
        /**
         * Regex to test the instance name against. If empty, all instances match.
         */
        instanceRegex?: pulumi.Input<string>;
        /**
         * For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
         */
        projectIdRegex?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReference {
        /**
         * Required. Name of a database within the instance.
         */
        database: pulumi.Input<string>;
        /**
         * Required. Name of a database resource, for example, a table within the database.
         */
        databaseResource: pulumi.Input<string>;
        /**
         * Required. The instance where this resource is located. For example: Cloud SQL instance ID.
         */
        instance: pulumi.Input<string>;
        /**
         * Required. If within a project-level config, then this must match the config's project ID.
         */
        projectId: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthers {
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadence {
        /**
         * Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
         * Structure is documented below.
         */
        inspectTemplateModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadence>;
        /**
         * Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        refreshFrequency?: pulumi.Input<string>;
        /**
         * Governs when to update data profiles when a schema is modified
         * Structure is documented below.
         */
        schemaModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadence>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadence {
        /**
         * How frequently data profiles can be updated when the template is modified. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadence {
        /**
         * Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency?: pulumi.Input<string>;
        /**
         * The types of schema modifications to consider. Defaults to NEW_COLUMNS.
         * Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTarget {
        /**
         * In addition to matching the filter, these conditions must be true before a profile is generated.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetConditions>;
        /**
         * Disable profiling for buckets that match this filter.
         */
        disabled?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetDisabled>;
        /**
         * The buckets the generationCadence applies to. The first target with a matching filter will be the one to apply to a bucket.
         * Structure is documented below.
         */
        filter: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilter>;
        /**
         * How often and when to update profiles. New buckets that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
         * Structure is documented below.
         */
        generationCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadence>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetConditions {
        /**
         * Cloud Storage conditions.
         * Structure is documented below.
         */
        cloudStorageConditions?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditions>;
        /**
         * File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
         */
        createdAfter?: pulumi.Input<string>;
        /**
         * Duration format. Minimum age a file store must have. If set, the value must be 1 hour or greater.
         */
        minAge?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditions {
        /**
         * Only objects with the specified attributes will be scanned. Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
         * Each value may be one of: `ALL_SUPPORTED_BUCKETS`, `AUTOCLASS_DISABLED`, `AUTOCLASS_ENABLED`.
         */
        includedBucketAttributes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only objects with the specified attributes will be scanned. If an object has one of the specified attributes but is inside an excluded bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A profile will be created even if no objects match the included_object_attributes.
         * Each value may be one of: `ALL_SUPPORTED_OBJECTS`, `STANDARD`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `REGIONAL`, `MULTI_REGIONAL`, `DURABLE_REDUCED_AVAILABILITY`.
         */
        includedObjectAttributes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetDisabled {
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilter {
        /**
         * The bucket to scan. Targets including this can only include one target (the target with this bucket). This enables profiling the contents of a single bucket, while the other options allow for easy profiling of many buckets within a project or an organization.
         * Structure is documented below.
         */
        cloudStorageResourceReference?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReference>;
        /**
         * A specific set of buckets for this filter to apply to.
         * Structure is documented below.
         */
        collection?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollection>;
        /**
         * Match discovery resources not covered by any other filter.
         */
        others?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthers>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReference {
        /**
         * The bucket to scan.
         */
        bucketName?: pulumi.Input<string>;
        /**
         * If within a project-level config, then this must match the config's project id.
         */
        projectId?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollection {
        /**
         * A collection of regular expressions to match a file store against.
         * Structure is documented below.
         */
        includeRegexes?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexes>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexes {
        /**
         * The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
         * Structure is documented below.
         */
        patterns?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPattern>[]>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPattern {
        /**
         * Regex for Cloud Storage.
         * Structure is documented below.
         */
        cloudStorageRegex?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegex>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegex {
        /**
         * Regex to test the bucket name against. If empty, all buckets match. Example: "marketing2021" or "(marketing)\d{4}" will both match the bucket gs://marketing2021
         */
        bucketNameRegex?: pulumi.Input<string>;
        /**
         * For organizations, if unset, will match all projects.
         */
        projectIdRegex?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthers {
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadence {
        /**
         * Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
         * Structure is documented below.
         */
        inspectTemplateModifiedCadence?: pulumi.Input<inputs.dataloss.PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadence>;
        /**
         * Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        refreshFrequency?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadence {
        /**
         * How frequently data profiles can be updated when the template is modified. Defaults to never.
         * Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
         */
        frequency?: pulumi.Input<string>;
    }

    export interface PreventionDiscoveryConfigTargetSecretsTarget {
    }

    export interface PreventionInspectTemplateInspectConfig {
        /**
         * List of options defining data content to scan. If empty, text, images, and other content will be included.
         * Each value may be one of: `CONTENT_TEXT`, `CONTENT_IMAGE`.
         */
        contentOptions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
         * Structure is documented below.
         */
        customInfoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoType>[]>;
        /**
         * When true, excludes type information of the findings.
         */
        excludeInfoTypes?: pulumi.Input<boolean>;
        /**
         * When true, a contextual quote from the data that triggered a finding is included in the response.
         */
        includeQuote?: pulumi.Input<boolean>;
        /**
         * Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
         * or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
         * When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
         * By default this may be all types, but may change over time as detectors are updated.
         * Structure is documented below.
         */
        infoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigInfoType>[]>;
        /**
         * Configuration to control the number of findings returned.
         * Structure is documented below.
         */
        limits?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigLimits>;
        /**
         * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
         * Default value is `POSSIBLE`.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        minLikelihood?: pulumi.Input<string>;
        /**
         * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
         * other rules are executed in the order they are specified for each info type.
         * Structure is documented below.
         */
        ruleSets?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSet>[]>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoType {
        /**
         * Dictionary which defines the rule.
         * Structure is documented below.
         */
        dictionary?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeDictionary>;
        /**
         * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
         * Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
         */
        exclusionType?: pulumi.Input<string>;
        /**
         * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
         * infoTypes and that infoType is specified in `infoTypes` field. Specifying the latter adds findings to the
         * one detected by the system. If built-in info type is not specified in `infoTypes` list then the name is
         * treated as a custom info type.
         * Structure is documented below.
         */
        infoType: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeInfoType>;
        /**
         * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
         * specified by the rule.
         * Default value is `VERY_LIKELY`.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        likelihood?: pulumi.Input<string>;
        /**
         * Regular expression which defines the rule.
         * Structure is documented below.
         */
        regex?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeRegex>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScore>;
        /**
         * A reference to a StoredInfoType to use with scanning.
         * Structure is documented below.
         */
        storedType?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeStoredType>;
        /**
         * Message for detecting output from deidentification transformations that support reversing.
         */
        surrogateType?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateType>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeDictionary {
        /**
         * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
         * Structure is documented below.
         */
        cloudStoragePath?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePath>;
        /**
         * List of words or phrases to search for.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordList>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one
         * phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
         * listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeRegex {
        /**
         * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression.
         * Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeStoredType {
        /**
         * Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
         * or `projects/project-id/storedInfoTypes/432452342`.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateType {
    }

    export interface PreventionInspectTemplateInspectConfigInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigLimits {
        /**
         * Configuration of findings limit given for specified infoTypes.
         * Structure is documented below.
         */
        maxFindingsPerInfoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoType>[]>;
        /**
         * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
         */
        maxFindingsPerItem: pulumi.Input<number>;
        /**
         * Max number of findings that will be returned per request/job. The maximum returned is 2000.
         */
        maxFindingsPerRequest: pulumi.Input<number>;
    }

    export interface PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoType {
        /**
         * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
         * not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
         * specified in another InfoTypeLimit.
         * Structure is documented below.
         */
        infoType?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>;
        /**
         * Max findings limit for the given infoType.
         */
        maxFindings: pulumi.Input<number>;
    }

    export interface PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
         * listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSet {
        /**
         * List of infoTypes this rule set is applied to.
         * Structure is documented below.
         */
        infoTypes: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetInfoType>[]>;
        /**
         * Set of rules to be applied to infoTypes. The rules are applied in order.
         * Structure is documented below.
         */
        rules: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRule>[]>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRule {
        /**
         * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
         * Structure is documented below.
         */
        exclusionRule?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRule>;
        /**
         * Hotword-based detection rule.
         * Structure is documented below.
         */
        hotwordRule?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRule>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRule {
        /**
         * Dictionary which defines the rule.
         * Structure is documented below.
         */
        dictionary?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionary>;
        /**
         * Drop if the hotword rule is contained in the proximate context.
         * For tabular data, the context includes the column name.
         * Structure is documented below.
         */
        excludeByHotword?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotword>;
        /**
         * Set of infoTypes for which findings would affect this rule.
         * Structure is documented below.
         */
        excludeInfoTypes?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypes>;
        /**
         * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
         * Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
         */
        matchingType: pulumi.Input<string>;
        /**
         * Regular expression which defines the rule.
         * Structure is documented below.
         */
        regex?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegex>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionary {
        /**
         * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
         * Structure is documented below.
         */
        cloudStoragePath?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePath>;
        /**
         * List of words or phrases to search for.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordList>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one
         * phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotword {
        /**
         * Regular expression pattern defining what qualifies as a hotword.
         * Structure is documented below.
         */
        hotwordRegex: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegex>;
        /**
         * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
         * exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
         * used to match substrings of the finding itself. For example, the certainty of a phone number regex
         * `(\d{3}) \d{3}-\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
         * office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
         * Structure is documented below.
         */
        proximity: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximity>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegex {
        /**
         * The index of the submatch to extract as findings. When not specified,
         * the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression. Its syntax
         * (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximity {
        /**
         * Number of characters after the finding to consider.
         */
        windowAfter?: pulumi.Input<number>;
        /**
         * Number of characters before the finding to consider.
         */
        windowBefore?: pulumi.Input<number>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypes {
        /**
         * If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
         * Structure is documented below.
         */
        infoTypes: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoType>[]>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScore>;
        /**
         * Version name for this InfoType.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegex {
        /**
         * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression.
         * Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRule {
        /**
         * Regular expression pattern defining what qualifies as a hotword.
         * Structure is documented below.
         */
        hotwordRegex: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegex>;
        /**
         * Likelihood adjustment to apply to all matching findings.
         * Structure is documented below.
         */
        likelihoodAdjustment: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustment>;
        /**
         * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
         * exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
         * used to match substrings of the finding itself. For example, the certainty of a phone number regex
         * `(\d{3}) \d{3}-\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
         * office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
         * Structure is documented below.
         */
        proximity: pulumi.Input<inputs.dataloss.PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximity>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegex {
        /**
         * The index of the submatch to extract as findings. When not specified,
         * the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression. Its syntax
         * (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustment {
        /**
         * Set the likelihood of a finding to a fixed value. Either this or relativeLikelihood can be set.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        fixedLikelihood?: pulumi.Input<string>;
        /**
         * Increase or decrease the likelihood by the specified number of levels. For example,
         * if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
         * then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
         * Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
         * adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
         * will result in a final likelihood of LIKELY. Either this or fixedLikelihood can be set.
         */
        relativeLikelihood?: pulumi.Input<number>;
    }

    export interface PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximity {
        /**
         * Number of characters after the finding to consider.
         */
        windowAfter?: pulumi.Input<number>;
        /**
         * Number of characters before the finding to consider.
         */
        windowBefore?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJob {
        /**
         * Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
         * Structure is documented below.
         */
        actions?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobAction>[]>;
        /**
         * The core content of the template.
         * Structure is documented below.
         */
        inspectConfig?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfig>;
        /**
         * The name of the template to run when this job is triggered.
         */
        inspectTemplateName?: pulumi.Input<string>;
        /**
         * Information on where to inspect
         * Structure is documented below.
         */
        storageConfig: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfig>;
    }

    export interface PreventionJobTriggerInspectJobAction {
        /**
         * Create a de-identified copy of the requested table or files.
         * Structure is documented below.
         */
        deidentify?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionDeidentify>;
        /**
         * Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
         */
        jobNotificationEmails?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionJobNotificationEmails>;
        /**
         * Publish a message into a given Pub/Sub topic when the job completes.
         * Structure is documented below.
         */
        pubSub?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionPubSub>;
        /**
         * Publish findings of a DlpJob to Data Catalog.
         */
        publishFindingsToCloudDataCatalog?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalog>;
        /**
         * Publish the result summary of a DlpJob to the Cloud Security Command Center.
         */
        publishSummaryToCscc?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionPublishSummaryToCscc>;
        /**
         * Enable Stackdriver metric dlp.googleapis.com/findingCount.
         */
        publishToStackdriver?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionPublishToStackdriver>;
        /**
         * If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
         * Structure is documented below.
         */
        saveFindings?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionSaveFindings>;
    }

    export interface PreventionJobTriggerInspectJobActionDeidentify {
        /**
         * User settable Cloud Storage bucket and folders to store de-identified files.
         * This field must be set for cloud storage deidentification.
         * The output Cloud Storage bucket must be different from the input bucket.
         * De-identified files will overwrite files in the output path.
         * Form of: gs://bucket/folder/ or gs://bucket
         */
        cloudStorageOutput: pulumi.Input<string>;
        /**
         * List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
         * If empty, all supported files will be transformed. Supported types may be automatically added over time.
         * If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
         * Each value may be one of: `IMAGE`, `TEXT_FILE`, `CSV`, `TSV`.
         */
        fileTypesToTransforms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * User specified deidentify templates and configs for structured, unstructured, and image files.
         * Structure is documented below.
         */
        transformationConfig?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionDeidentifyTransformationConfig>;
        /**
         * Config for storing transformation details.
         * Structure is documented below.
         */
        transformationDetailsStorageConfig?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfig>;
    }

    export interface PreventionJobTriggerInspectJobActionDeidentifyTransformationConfig {
        /**
         * If this template is specified, it will serve as the default de-identify template.
         */
        deidentifyTemplate?: pulumi.Input<string>;
        /**
         * If this template is specified, it will serve as the de-identify template for images.
         */
        imageRedactTemplate?: pulumi.Input<string>;
        /**
         * If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
         */
        structuredDeidentifyTemplate?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfig {
        /**
         * The BigQuery table in which to store the output.
         * Structure is documented below.
         */
        table: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTable>;
    }

    export interface PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The ID of the table. The ID must contain only letters (a-z,
         * A-Z), numbers (0-9), or underscores (_). The maximum length
         * is 1,024 characters.
         */
        tableId?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobActionJobNotificationEmails {
    }

    export interface PreventionJobTriggerInspectJobActionPubSub {
        /**
         * Cloud Pub/Sub topic to send notifications to.
         */
        topic: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalog {
    }

    export interface PreventionJobTriggerInspectJobActionPublishSummaryToCscc {
    }

    export interface PreventionJobTriggerInspectJobActionPublishToStackdriver {
    }

    export interface PreventionJobTriggerInspectJobActionSaveFindings {
        /**
         * Information on where to store output
         * Structure is documented below.
         */
        outputConfig: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionSaveFindingsOutputConfig>;
    }

    export interface PreventionJobTriggerInspectJobActionSaveFindingsOutputConfig {
        /**
         * Schema used for writing the findings for Inspect jobs. This field is only used for
         * Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
         * object. If appending to an existing table, any columns from the predefined schema
         * that are missing will be added. No columns in the existing table will be deleted.
         * If unspecified, then all available columns will be used for a new table or an (existing)
         * table with no schema, and no changes will be made to an existing table that has a schema.
         * Only for use with external storage.
         * Possible values are: `BASIC_COLUMNS`, `GCS_COLUMNS`, `DATASTORE_COLUMNS`, `BIG_QUERY_COLUMNS`, `ALL_COLUMNS`.
         */
        outputSchema?: pulumi.Input<string>;
        /**
         * Information on the location of the target BigQuery Table.
         * Structure is documented below.
         */
        table: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTable>;
    }

    export interface PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTable {
        /**
         * The ID of the dataset containing this table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The ID of the project containing this table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The ID of the table. The ID must contain only letters (a-z,
         * A-Z), numbers (0-9), or underscores (_). The maximum length
         * is 1,024 characters.
         */
        tableId?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfig {
        /**
         * Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
         * Structure is documented below.
         */
        customInfoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoType>[]>;
        /**
         * When true, excludes type information of the findings.
         */
        excludeInfoTypes?: pulumi.Input<boolean>;
        /**
         * When true, a contextual quote from the data that triggered a finding is included in the response.
         */
        includeQuote?: pulumi.Input<boolean>;
        /**
         * Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
         * or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
         * When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
         * By default this may be all types, but may change over time as detectors are updated.
         * Structure is documented below.
         */
        infoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigInfoType>[]>;
        /**
         * Configuration to control the number of findings returned.
         * Structure is documented below.
         */
        limits?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigLimits>;
        /**
         * Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
         * Default value is `POSSIBLE`.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        minLikelihood?: pulumi.Input<string>;
        /**
         * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
         * other rules are executed in the order they are specified for each info type.
         * Structure is documented below.
         */
        ruleSets?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSet>[]>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoType {
        /**
         * Dictionary which defines the rule.
         * Structure is documented below.
         */
        dictionary?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionary>;
        /**
         * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
         * Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
         */
        exclusionType?: pulumi.Input<string>;
        /**
         * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
         * infoTypes and that infoType is specified in `infoTypes` field. Specifying the latter adds findings to the
         * one detected by the system. If built-in info type is not specified in `infoTypes` list then the name is
         * treated as a custom info type.
         * Structure is documented below.
         */
        infoType: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoType>;
        /**
         * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
         * specified by the rule.
         * Default value is `VERY_LIKELY`.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        likelihood?: pulumi.Input<string>;
        /**
         * Regular expression which defines the rule.
         * Structure is documented below.
         */
        regex?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegex>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScore>;
        /**
         * A reference to a StoredInfoType to use with scanning.
         * Structure is documented below.
         */
        storedType?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredType>;
        /**
         * Message for detecting output from deidentification transformations that support reversing.
         */
        surrogateType?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateType>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionary {
        /**
         * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
         * Structure is documented below.
         */
        cloudStoragePath?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePath>;
        /**
         * List of words or phrases to search for.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordList>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one
         * phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
         * listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScore>;
        /**
         * Version of the information type to use. By default, the version is set to stable.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegex {
        /**
         * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression.
         * Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredType {
        /**
         * (Output)
         * The creation timestamp of an inspectTemplate. Set by the server.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
         * or `projects/project-id/storedInfoTypes/432452342`.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateType {
    }

    export interface PreventionJobTriggerInspectJobInspectConfigInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScore>;
        /**
         * Version of the information type to use. By default, the version is set to stable.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigLimits {
        /**
         * Configuration of findings limit given for specified infoTypes.
         * Structure is documented below.
         */
        maxFindingsPerInfoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoType>[]>;
        /**
         * Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
         */
        maxFindingsPerItem?: pulumi.Input<number>;
        /**
         * Max number of findings that will be returned per request/job. The maximum returned is 2000.
         */
        maxFindingsPerRequest?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
        /**
         * Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
         * not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
         * specified in another InfoTypeLimit.
         * Structure is documented below.
         */
        infoType?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType>;
        /**
         * Max findings limit for the given infoType.
         */
        maxFindings?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
         * listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore>;
        /**
         * Version of the information type to use. By default, the version is set to stable.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSet {
        /**
         * List of infoTypes this rule set is applied to.
         * Structure is documented below.
         */
        infoTypes?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetInfoType>[]>;
        /**
         * Set of rules to be applied to infoTypes. The rules are applied in order.
         * Structure is documented below.
         */
        rules: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRule>[]>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScore>;
        /**
         * Version of the information type to use. By default, the version is set to stable.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRule {
        /**
         * The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
         * Structure is documented below.
         */
        exclusionRule?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRule>;
        /**
         * Hotword-based detection rule.
         * Structure is documented below.
         */
        hotwordRule?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRule>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRule {
        /**
         * Dictionary which defines the rule.
         * Structure is documented below.
         */
        dictionary?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionary>;
        /**
         * Drop if the hotword rule is contained in the proximate context.
         * Structure is documented below.
         */
        excludeByHotword?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotword>;
        /**
         * Set of infoTypes for which findings would affect this rule.
         * Structure is documented below.
         */
        excludeInfoTypes?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypes>;
        /**
         * How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
         * Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
         */
        matchingType: pulumi.Input<string>;
        /**
         * Regular expression which defines the rule.
         * Structure is documented below.
         */
        regex?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegex>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionary {
        /**
         * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
         * Structure is documented below.
         */
        cloudStoragePath?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePath>;
        /**
         * List of words or phrases to search for.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordList>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one
         * phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotword {
        /**
         * Regular expression pattern defining what qualifies as a hotword.
         * Structure is documented below.
         */
        hotwordRegex?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegex>;
        /**
         * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
         * exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
         * used to match substrings of the finding itself. For example, the certainty of a phone number regex
         * `(\d{3}) \d{3}-\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
         * office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
         * Structure is documented below.
         */
        proximity?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximity>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegex {
        /**
         * The index of the submatch to extract as findings. When not specified,
         * the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression. Its syntax
         * (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximity {
        /**
         * Number of characters after the finding to consider. Either this or windowBefore must be specified
         */
        windowAfter?: pulumi.Input<number>;
        /**
         * Number of characters before the finding to consider. Either this or windowAfter must be specified
         */
        windowBefore?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypes {
        /**
         * If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
         * Structure is documented below.
         */
        infoTypes: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoType>[]>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoType {
        /**
         * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
         * at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
         */
        name: pulumi.Input<string>;
        /**
         * Optional custom sensitivity for this InfoType. This only applies to data profiling.
         * Structure is documented below.
         */
        sensitivityScore?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScore>;
        /**
         * Version of the information type to use. By default, the version is set to stable.
         */
        version?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScore {
        /**
         * The sensitivity score applied to the resource.
         * Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
         */
        score: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegex {
        /**
         * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression.
         * Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRule {
        /**
         * Regular expression pattern defining what qualifies as a hotword.
         * Structure is documented below.
         */
        hotwordRegex?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegex>;
        /**
         * Likelihood adjustment to apply to all matching findings.
         * Structure is documented below.
         */
        likelihoodAdjustment?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustment>;
        /**
         * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
         * exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
         * used to match substrings of the finding itself. For example, the certainty of a phone number regex
         * `(\d{3}) \d{3}-\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
         * office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
         * Structure is documented below.
         */
        proximity?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximity>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegex {
        /**
         * The index of the submatch to extract as findings. When not specified,
         * the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression. Its syntax
         * (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustment {
        /**
         * Set the likelihood of a finding to a fixed value. Either this or relativeLikelihood can be set.
         * Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
         */
        fixedLikelihood?: pulumi.Input<string>;
        /**
         * Increase or decrease the likelihood by the specified number of levels. For example,
         * if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
         * then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
         * Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
         * adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
         * will result in a final likelihood of LIKELY. Either this or fixedLikelihood can be set.
         */
        relativeLikelihood?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximity {
        /**
         * Number of characters after the finding to consider. Either this or windowBefore must be specified
         */
        windowAfter?: pulumi.Input<number>;
        /**
         * Number of characters before the finding to consider. Either this or windowAfter must be specified
         */
        windowBefore?: pulumi.Input<number>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfig {
        /**
         * Options defining BigQuery table and row identifiers.
         * Structure is documented below.
         */
        bigQueryOptions?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigBigQueryOptions>;
        /**
         * Options defining a file or a set of files within a Google Cloud Storage bucket.
         * Structure is documented below.
         */
        cloudStorageOptions?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigCloudStorageOptions>;
        /**
         * Options defining a data set within Google Cloud Datastore.
         * Structure is documented below.
         */
        datastoreOptions?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigDatastoreOptions>;
        /**
         * Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
         * Structure is documented below.
         */
        hybridOptions?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigHybridOptions>;
        /**
         * Configuration of the timespan of the items to include in scanning
         * Structure is documented below.
         */
        timespanConfig?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigTimespanConfig>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigBigQueryOptions {
        /**
         * References to fields excluded from scanning.
         * This allows you to skip inspection of entire columns which you know have no findings.
         * Structure is documented below.
         */
        excludedFields?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedField>[]>;
        /**
         * Specifies the BigQuery fields that will be returned with findings.
         * If not specified, no identifying fields will be returned for findings.
         * Structure is documented below.
         */
        identifyingFields?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingField>[]>;
        /**
         * Limit scanning only to these fields.
         * Structure is documented below.
         */
        includedFields?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedField>[]>;
        /**
         * Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
         * If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
         * specified. Cannot be used in conjunction with TimespanConfig.
         */
        rowsLimit?: pulumi.Input<number>;
        /**
         * Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
         * Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
         * rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
         */
        rowsLimitPercent?: pulumi.Input<number>;
        /**
         * How to sample rows if not all rows are scanned. Meaningful only when used in conjunction with either
         * rowsLimit or rowsLimitPercent. If not specified, rows are scanned in the order BigQuery reads them.
         * If TimespanConfig is set, set this to an empty string to avoid using the default value.
         * Default value is `TOP`.
         * Possible values are: `TOP`, `RANDOM_START`.
         */
        sampleMethod?: pulumi.Input<string>;
        /**
         * Set of files to scan.
         * Structure is documented below.
         */
        tableReference: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReference>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedField {
        /**
         * Name describing the field excluded from scanning.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingField {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedField {
        /**
         * Name describing the field to which scanning is limited.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReference {
        /**
         * The dataset ID of the table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The Google Cloud Platform project ID of the project containing the table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The name of the table.
         */
        tableId: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigCloudStorageOptions {
        /**
         * Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
         * then the rest of the bytes are omitted.
         */
        bytesLimitPerFile?: pulumi.Input<number>;
        /**
         * Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
         * Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
         */
        bytesLimitPerFilePercent?: pulumi.Input<number>;
        /**
         * Set of files to scan.
         * Structure is documented below.
         */
        fileSet: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSet>;
        /**
         * List of file type groups to include in the scan. If empty, all files are scanned and available data
         * format processors are applied. In addition, the binary content of the selected files is always scanned as well.
         * Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
         * Each value may be one of: `BINARY_FILE`, `TEXT_FILE`, `IMAGE`, `WORD`, `PDF`, `AVRO`, `CSV`, `TSV`, `POWERPOINT`, `EXCEL`.
         */
        fileTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
         * Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
         */
        filesLimitPercent?: pulumi.Input<number>;
        /**
         * How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
         * If not specified, scanning would start from the top.
         * Possible values are: `TOP`, `RANDOM_START`.
         */
        sampleMethod?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSet {
        /**
         * The regex-filtered set of files to scan.
         * Structure is documented below.
         */
        regexFileSet?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet>;
        /**
         * The Cloud Storage url of the file(s) to scan, in the format `gs://<bucket>/<path>`. Trailing wildcard
         * in the path is allowed.
         * If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
         * non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is
         * equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`.
         */
        url?: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
        /**
         * The name of a Cloud Storage bucket.
         */
        bucketName: pulumi.Input<string>;
        /**
         * A list of regular expressions matching file paths to exclude. All files in the bucket that match at
         * least one of these regular expressions will be excluded from the scan.
         */
        excludeRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of regular expressions matching file paths to include. All files in the bucket
         * that match at least one of these regular expressions will be included in the set of files,
         * except for those that also match an item in excludeRegex. Leaving this field empty will
         * match all files by default (this is equivalent to including .* in the list)
         */
        includeRegexes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigDatastoreOptions {
        /**
         * A representation of a Datastore kind.
         * Structure is documented below.
         */
        kind: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKind>;
        /**
         * Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
         * is always by project and namespace, however the namespace ID may be empty.
         * Structure is documented below.
         */
        partitionId: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionId>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKind {
        /**
         * The name of the Datastore kind.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionId {
        /**
         * If not empty, the ID of the namespace to which the entities belong.
         */
        namespaceId?: pulumi.Input<string>;
        /**
         * The ID of the project to which the entities belong.
         */
        projectId: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigHybridOptions {
        /**
         * A short description of where the data is coming from. Will be stored once in the job. 256 max length.
         */
        description?: pulumi.Input<string>;
        /**
         * To organize findings, these labels will be added to each finding.
         * Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
         * Label values must be between 0 and 63 characters long and must conform to the regular expression `(a-z?)?`.
         * No more than 10 labels can be associated with a given finding.
         * Examples:
         * * `"environment" : "production"`
         * * `"pipeline" : "etl"`
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * These are labels that each inspection request must include within their 'finding_labels' map. Request
         * may contain others, but any missing one of these will be rejected.
         * Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
         * No more than 10 keys can be required.
         */
        requiredFindingLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
         * Structure is documented below.
         */
        tableOptions?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptions>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptions {
        /**
         * The columns that are the primary keys for table objects included in ContentItem. A copy of this
         * cell's value will stored alongside alongside each finding so that the finding can be traced to
         * the specific row it came from. No more than 3 may be provided.
         * Structure is documented below.
         */
        identifyingFields?: pulumi.Input<pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingField>[]>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingField {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigTimespanConfig {
        /**
         * When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
         * scanning files that have not been modified since the last time the JobTrigger executed. This will
         * be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
         * used in the last run of the JobTrigger.
         */
        enableAutoPopulationOfTimespanConfig?: pulumi.Input<boolean>;
        /**
         * Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
         */
        endTime?: pulumi.Input<string>;
        /**
         * Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
         */
        startTime?: pulumi.Input<string>;
        /**
         * Specification of the field containing the timestamp of scanned items.
         * Structure is documented below.
         */
        timestampField?: pulumi.Input<inputs.dataloss.PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampField>;
    }

    export interface PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampField {
        /**
         * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
         * For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
         * modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
         * field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
         * For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
         * timestamp property does not exist or its value is empty or invalid.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionJobTriggerTrigger {
        /**
         * For use with hybrid jobs. Jobs must be manually created and finished.
         */
        manual?: pulumi.Input<inputs.dataloss.PreventionJobTriggerTriggerManual>;
        /**
         * Schedule for triggered jobs
         * Structure is documented below.
         */
        schedule?: pulumi.Input<inputs.dataloss.PreventionJobTriggerTriggerSchedule>;
    }

    export interface PreventionJobTriggerTriggerManual {
    }

    export interface PreventionJobTriggerTriggerSchedule {
        /**
         * With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
         * A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
         * This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         *
         * - - -
         */
        recurrencePeriodDuration?: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeDictionary {
        /**
         * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
         * Structure is documented below.
         */
        cloudStoragePath?: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeDictionaryCloudStoragePath>;
        /**
         * List of words or phrases to search for.
         * Structure is documented below.
         */
        wordList?: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeDictionaryWordList>;
    }

    export interface PreventionStoredInfoTypeDictionaryCloudStoragePath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeDictionaryWordList {
        /**
         * Words or phrases defining the dictionary. The dictionary must contain at least one
         * phrase and every phrase must contain at least 2 characters that are letters or digits.
         */
        words: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionary {
        /**
         * Field in a BigQuery table where each cell represents a dictionary phrase.
         * Structure is documented below.
         */
        bigQueryField?: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeLargeCustomDictionaryBigQueryField>;
        /**
         * Set of files containing newline-delimited lists of dictionary phrases.
         * Structure is documented below.
         */
        cloudStorageFileSet?: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSet>;
        /**
         * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API.
         * If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
         * Structure is documented below.
         */
        outputPath: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeLargeCustomDictionaryOutputPath>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionaryBigQueryField {
        /**
         * Designated field in the BigQuery table.
         * Structure is documented below.
         */
        field: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldField>;
        /**
         * Field in a BigQuery table where each cell represents a dictionary phrase.
         * Structure is documented below.
         */
        table: pulumi.Input<inputs.dataloss.PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTable>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldField {
        /**
         * Name describing the field.
         */
        name: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTable {
        /**
         * The dataset ID of the table.
         */
        datasetId: pulumi.Input<string>;
        /**
         * The Google Cloud Platform project ID of the project containing the table.
         */
        projectId: pulumi.Input<string>;
        /**
         * The name of the table.
         */
        tableId: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSet {
        /**
         * The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
         */
        url: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeLargeCustomDictionaryOutputPath {
        /**
         * A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
         */
        path: pulumi.Input<string>;
    }

    export interface PreventionStoredInfoTypeRegex {
        /**
         * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
         */
        groupIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Pattern defining the regular expression.
         * Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
         */
        pattern: pulumi.Input<string>;
    }
}

export namespace dataplex {
    export interface AspectTypeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AspectTypeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AssetDiscoverySpec {
        /**
         * Optional. Configuration for CSV data.
         */
        csvOptions?: pulumi.Input<inputs.dataplex.AssetDiscoverySpecCsvOptions>;
        /**
         * Required. Whether discovery is enabled.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
         */
        excludePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
         */
        includePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Configuration for Json data.
         */
        jsonOptions?: pulumi.Input<inputs.dataplex.AssetDiscoverySpecJsonOptions>;
        /**
         * Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
         */
        schedule?: pulumi.Input<string>;
    }

    export interface AssetDiscoverySpecCsvOptions {
        /**
         * Optional. The delimiter being used to separate values. This defaults to ','.
         */
        delimiter?: pulumi.Input<string>;
        /**
         * Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
         */
        disableTypeInference?: pulumi.Input<boolean>;
        /**
         * Optional. The character encoding of the data. The default is UTF-8.
         */
        encoding?: pulumi.Input<string>;
        /**
         * Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
         */
        headerRows?: pulumi.Input<number>;
    }

    export interface AssetDiscoverySpecJsonOptions {
        /**
         * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
         */
        disableTypeInference?: pulumi.Input<boolean>;
        /**
         * Optional. The character encoding of the data. The default is UTF-8.
         */
        encoding?: pulumi.Input<string>;
    }

    export interface AssetDiscoveryStatus {
        /**
         * The duration of the last discovery run.
         */
        lastRunDuration?: pulumi.Input<string>;
        /**
         * The start time of the last discovery run.
         */
        lastRunTime?: pulumi.Input<string>;
        /**
         * Additional information about the current state.
         */
        message?: pulumi.Input<string>;
        /**
         * Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
         */
        state?: pulumi.Input<string>;
        /**
         * Data Stats of the asset reported by discovery.
         */
        stats?: pulumi.Input<pulumi.Input<inputs.dataplex.AssetDiscoveryStatusStat>[]>;
        /**
         * Output only. The time when the asset was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface AssetDiscoveryStatusStat {
        /**
         * The count of data items within the referenced resource.
         */
        dataItems?: pulumi.Input<number>;
        /**
         * The number of stored data bytes within the referenced resource.
         */
        dataSize?: pulumi.Input<number>;
        /**
         * The count of fileset entities within the referenced resource.
         */
        filesets?: pulumi.Input<number>;
        /**
         * The count of table entities within the referenced resource.
         */
        tables?: pulumi.Input<number>;
    }

    export interface AssetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AssetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AssetResourceSpec {
        /**
         * Immutable. Relative name of the cloud resource that contains the data that is being managed within a lake. For example: `projects/{project_number}/buckets/{bucket_id}` `projects/{project_number}/datasets/{dataset_id}`
         */
        name?: pulumi.Input<string>;
        /**
         * Optional. Determines how read permissions are handled for each asset and their associated tables. Only available to storage buckets assets. Possible values: DIRECT, MANAGED
         */
        readAccessMode?: pulumi.Input<string>;
        /**
         * Required. Immutable. Type of resource. Possible values: STORAGE_BUCKET, BIGQUERY_DATASET
         *
         * - - -
         */
        type: pulumi.Input<string>;
    }

    export interface AssetResourceStatus {
        /**
         * Additional information about the current state.
         */
        message?: pulumi.Input<string>;
        /**
         * Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
         */
        state?: pulumi.Input<string>;
        /**
         * Output only. The time when the asset was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface AssetSecurityStatus {
        /**
         * Additional information about the current state.
         */
        message?: pulumi.Input<string>;
        /**
         * Output only. Current state of the asset. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
         */
        state?: pulumi.Input<string>;
        /**
         * Output only. The time when the asset was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface DatascanData {
        /**
         * The Dataplex entity that represents the data source(e.g. BigQuery table) for Datascan.
         */
        entity?: pulumi.Input<string>;
        /**
         * The service-qualified full resource name of the cloud resource for a DataScan job to scan against. The field could be:
         * (Cloud Storage bucket for DataDiscoveryScan)BigQuery table of type "TABLE" for DataProfileScan/DataQualityScan.
         */
        resource?: pulumi.Input<string>;
    }

    export interface DatascanDataProfileSpec {
        /**
         * The fields to exclude from data profile.
         * If specified, the fields will be excluded from data profile, regardless of `includeFields` value.
         * Structure is documented below.
         */
        excludeFields?: pulumi.Input<inputs.dataplex.DatascanDataProfileSpecExcludeFields>;
        /**
         * The fields to include in data profile.
         * If not specified, all fields at the time of profile scan job execution are included, except for ones listed in `excludeFields`.
         * Structure is documented below.
         */
        includeFields?: pulumi.Input<inputs.dataplex.DatascanDataProfileSpecIncludeFields>;
        /**
         * Actions to take upon job completion.
         * Structure is documented below.
         */
        postScanActions?: pulumi.Input<inputs.dataplex.DatascanDataProfileSpecPostScanActions>;
        /**
         * A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
         */
        rowFilter?: pulumi.Input<string>;
        /**
         * The percentage of the records to be selected from the dataset for DataScan.
         * Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
         * Sampling is not applied if `samplingPercent` is not specified, 0 or 100.
         */
        samplingPercent?: pulumi.Input<number>;
    }

    export interface DatascanDataProfileSpecExcludeFields {
        /**
         * Expected input is a list of fully qualified names of fields as in the schema.
         * Only top-level field names for nested fields are supported.
         * For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
         */
        fieldNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatascanDataProfileSpecIncludeFields {
        /**
         * Expected input is a list of fully qualified names of fields as in the schema.
         * Only top-level field names for nested fields are supported.
         * For instance, if 'x' is of nested field type, listing 'x' is supported but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of 'x'.
         */
        fieldNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatascanDataProfileSpecPostScanActions {
        /**
         * If set, results will be exported to the provided BigQuery table.
         * Structure is documented below.
         */
        bigqueryExport?: pulumi.Input<inputs.dataplex.DatascanDataProfileSpecPostScanActionsBigqueryExport>;
    }

    export interface DatascanDataProfileSpecPostScanActionsBigqueryExport {
        /**
         * The BigQuery table to export DataProfileScan results to.
         * Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
         */
        resultsTable?: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpec {
        /**
         * Actions to take upon job completion.
         * Structure is documented below.
         */
        postScanActions?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActions>;
        /**
         * A filter applied to all rows in a single DataScan job. The filter needs to be a valid SQL expression for a WHERE clause in BigQuery standard SQL syntax. Example: col1 >= 0 AND col2 < 10
         */
        rowFilter?: pulumi.Input<string>;
        /**
         * The list of rules to evaluate against a data source. At least one rule is required.
         * Structure is documented below.
         */
        rules?: pulumi.Input<pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRule>[]>;
        /**
         * The percentage of the records to be selected from the dataset for DataScan.
         * Value can range between 0.0 and 100.0 with up to 3 significant decimal digits.
         * Sampling is not applied if `samplingPercent` is not specified, 0 or 100.
         */
        samplingPercent?: pulumi.Input<number>;
    }

    export interface DatascanDataQualitySpecPostScanActions {
        /**
         * If set, results will be exported to the provided BigQuery table.
         * Structure is documented below.
         */
        bigqueryExport?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsBigqueryExport>;
        /**
         * The configuration of notification report post scan action.
         * Structure is documented below.
         */
        notificationReport?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsNotificationReport>;
    }

    export interface DatascanDataQualitySpecPostScanActionsBigqueryExport {
        /**
         * The BigQuery table to export DataProfileScan results to.
         * Format://bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
         */
        resultsTable?: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpecPostScanActionsNotificationReport {
        /**
         * This trigger is triggered whenever a scan job run ends, regardless of the result.
         */
        jobEndTrigger?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger>;
        /**
         * This trigger is triggered when the scan job itself fails, regardless of the result.
         */
        jobFailureTrigger?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger>;
        /**
         * The individuals or groups who are designated to receive notifications upon triggers.
         * Structure is documented below.
         */
        recipients: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsNotificationReportRecipients>;
        /**
         * This trigger is triggered when the DQ score in the job result is less than a specified input score.
         * Structure is documented below.
         */
        scoreThresholdTrigger?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger>;
    }

    export interface DatascanDataQualitySpecPostScanActionsNotificationReportJobEndTrigger {
    }

    export interface DatascanDataQualitySpecPostScanActionsNotificationReportJobFailureTrigger {
    }

    export interface DatascanDataQualitySpecPostScanActionsNotificationReportRecipients {
        /**
         * The email recipients who will receive the DataQualityScan results report.
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatascanDataQualitySpecPostScanActionsNotificationReportScoreThresholdTrigger {
        /**
         * The score range is in [0,100].
         */
        scoreThreshold?: pulumi.Input<number>;
    }

    export interface DatascanDataQualitySpecRule {
        /**
         * The unnested column which this rule is evaluated against.
         */
        column?: pulumi.Input<string>;
        /**
         * Description of the rule.
         * The maximum length is 1,024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * The dimension a rule belongs to. Results are also aggregated at the dimension level. Supported dimensions are ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]
         */
        dimension: pulumi.Input<string>;
        /**
         * Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
         */
        ignoreNull?: pulumi.Input<boolean>;
        /**
         * A mutable name for the rule.
         * The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
         * The maximum length is 63 characters.
         * Must start with a letter.
         * Must end with a number or a letter.
         */
        name?: pulumi.Input<string>;
        /**
         * ColumnMap rule which evaluates whether each column value is null.
         */
        nonNullExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleNonNullExpectation>;
        /**
         * ColumnMap rule which evaluates whether each column value lies between a specified range.
         * Structure is documented below.
         */
        rangeExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleRangeExpectation>;
        /**
         * ColumnMap rule which evaluates whether each column value matches a specified regex.
         * Structure is documented below.
         */
        regexExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleRegexExpectation>;
        /**
         * Table rule which evaluates whether each row passes the specified condition.
         * Structure is documented below.
         */
        rowConditionExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleRowConditionExpectation>;
        /**
         * ColumnMap rule which evaluates whether each column value is contained by a specified set.
         * Structure is documented below.
         */
        setExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleSetExpectation>;
        /**
         * Table rule which evaluates whether any row matches invalid state.
         * Structure is documented below.
         */
        sqlAssertion?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleSqlAssertion>;
        /**
         * ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
         * Structure is documented below.
         */
        statisticRangeExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleStatisticRangeExpectation>;
        /**
         * Table rule which evaluates whether the provided expression is true.
         * Structure is documented below.
         */
        tableConditionExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleTableConditionExpectation>;
        /**
         * The minimum ratio of passingRows / totalRows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0).
         */
        threshold?: pulumi.Input<number>;
        /**
         * Row-level rule which evaluates whether each column value is unique.
         */
        uniquenessExpectation?: pulumi.Input<inputs.dataplex.DatascanDataQualitySpecRuleUniquenessExpectation>;
    }

    export interface DatascanDataQualitySpecRuleNonNullExpectation {
    }

    export interface DatascanDataQualitySpecRuleRangeExpectation {
        /**
         * The maximum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
         */
        maxValue?: pulumi.Input<string>;
        /**
         * The minimum column value allowed for a row to pass this validation. At least one of minValue and maxValue need to be provided.
         */
        minValue?: pulumi.Input<string>;
        /**
         * Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
         * Only relevant if a maxValue has been defined. Default = false.
         */
        strictMaxEnabled?: pulumi.Input<boolean>;
        /**
         * Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.
         * Only relevant if a minValue has been defined. Default = false.
         */
        strictMinEnabled?: pulumi.Input<boolean>;
    }

    export interface DatascanDataQualitySpecRuleRegexExpectation {
        /**
         * A regular expression the column value is expected to match.
         */
        regex: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpecRuleRowConditionExpectation {
        /**
         * The SQL expression.
         */
        sqlExpression: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpecRuleSetExpectation {
        /**
         * Expected values for the column value.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatascanDataQualitySpecRuleSqlAssertion {
        /**
         * The SQL statement.
         */
        sqlStatement: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpecRuleStatisticRangeExpectation {
        /**
         * The maximum column statistic value allowed for a row to pass this validation.
         * At least one of minValue and maxValue need to be provided.
         */
        maxValue?: pulumi.Input<string>;
        /**
         * The minimum column statistic value allowed for a row to pass this validation.
         * At least one of minValue and maxValue need to be provided.
         */
        minValue?: pulumi.Input<string>;
        /**
         * column statistics.
         * Possible values are: `STATISTIC_UNDEFINED`, `MEAN`, `MIN`, `MAX`.
         */
        statistic: pulumi.Input<string>;
        /**
         * Whether column statistic needs to be strictly lesser than ('<') the maximum, or if equality is allowed.
         * Only relevant if a maxValue has been defined. Default = false.
         */
        strictMaxEnabled?: pulumi.Input<boolean>;
        /**
         * Whether column statistic needs to be strictly greater than ('>') the minimum, or if equality is allowed.
         * Only relevant if a minValue has been defined. Default = false.
         */
        strictMinEnabled?: pulumi.Input<boolean>;
    }

    export interface DatascanDataQualitySpecRuleTableConditionExpectation {
        /**
         * The SQL expression.
         */
        sqlExpression: pulumi.Input<string>;
    }

    export interface DatascanDataQualitySpecRuleUniquenessExpectation {
    }

    export interface DatascanExecutionSpec {
        /**
         * The unnested field (of type Date or Timestamp) that contains values which monotonically increase over time. If not specified, a data scan will run for all data in the table.
         */
        field?: pulumi.Input<string>;
        /**
         * Spec related to how often and when a scan should be triggered.
         * Structure is documented below.
         */
        trigger: pulumi.Input<inputs.dataplex.DatascanExecutionSpecTrigger>;
    }

    export interface DatascanExecutionSpecTrigger {
        /**
         * The scan runs once via dataScans.run API.
         */
        onDemand?: pulumi.Input<inputs.dataplex.DatascanExecutionSpecTriggerOnDemand>;
        /**
         * The scan is scheduled to run periodically.
         * Structure is documented below.
         */
        schedule?: pulumi.Input<inputs.dataplex.DatascanExecutionSpecTriggerSchedule>;
    }

    export interface DatascanExecutionSpecTriggerOnDemand {
    }

    export interface DatascanExecutionSpecTriggerSchedule {
        /**
         * Cron schedule for running scans periodically. This field is required for Schedule scans.
         *
         * - - -
         */
        cron: pulumi.Input<string>;
    }

    export interface DatascanExecutionStatus {
        /**
         * (Output)
         * The time when the latest DataScanJob started.
         */
        latestJobEndTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the latest DataScanJob ended.
         */
        latestJobStartTime?: pulumi.Input<string>;
    }

    export interface DatascanIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatascanIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryTypeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryTypeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface EntryTypeRequiredAspect {
        /**
         * Required aspect type for the entry type.
         */
        type?: pulumi.Input<string>;
    }

    export interface GlossaryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface GlossaryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface LakeAssetStatus {
        /**
         * Number of active assets.
         */
        activeAssets?: pulumi.Input<number>;
        /**
         * Number of assets that are in process of updating the security policy on attached resources.
         */
        securityPolicyApplyingAssets?: pulumi.Input<number>;
        /**
         * Output only. The time when the lake was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface LakeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface LakeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface LakeMetastore {
        /**
         * Optional. A relative reference to the Dataproc Metastore (https://cloud.google.com/dataproc-metastore/docs) service associated with the lake: `projects/{project_id}/locations/{location_id}/services/{service_id}`
         */
        service?: pulumi.Input<string>;
    }

    export interface LakeMetastoreStatus {
        /**
         * The URI of the endpoint used to access the Metastore service.
         */
        endpoint?: pulumi.Input<string>;
        /**
         * Additional information about the current status.
         */
        message?: pulumi.Input<string>;
        /**
         * Output only. Current state of the lake. Possible values: STATE_UNSPECIFIED, ACTIVE, CREATING, DELETING, ACTION_REQUIRED
         */
        state?: pulumi.Input<string>;
        /**
         * Output only. The time when the lake was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface TaskExecutionSpec {
        /**
         * The arguments to pass to the task. The args can use placeholders of the format ${placeholder} as part of key/value string. These will be interpolated before passing the args to the driver. Currently supported placeholders: - ${taskId} - ${job_time} To pass positional args, set the key as TASK_ARGS. The value should be a comma-separated string of all the positional arguments. To use a delimiter other than comma, refer to https://cloud.google.com/sdk/gcloud/reference/topic/escaping. In case of other keys being present in the args, then TASK_ARGS will be passed as the last argument. An object containing a list of 'key': value pairs. Example: { 'name': 'wrench', 'mass': '1.3kg', 'count': '3' }.
         */
        args?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Cloud KMS key to use for encryption, of the form: projects/{project_number}/locations/{locationId}/keyRings/{key-ring-name}/cryptoKeys/{key-name}.
         *
         * - - -
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * The maximum duration after which the job execution is expired. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'.
         */
        maxJobExecutionLifetime?: pulumi.Input<string>;
        /**
         * The ID of the project in which the resource belongs.
         * If it is not provided, the provider project is used.
         */
        project?: pulumi.Input<string>;
        /**
         * Service account to use to execute a task. If not provided, the default Compute service account for the project is used.
         */
        serviceAccount: pulumi.Input<string>;
    }

    export interface TaskExecutionStatus {
        /**
         * (Output)
         * latest job execution.
         * Structure is documented below.
         */
        latestJobs?: pulumi.Input<pulumi.Input<inputs.dataplex.TaskExecutionStatusLatestJob>[]>;
        /**
         * (Output)
         * Last update time of the status.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface TaskExecutionStatusLatestJob {
        /**
         * (Output)
         * The time when the job ended.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Additional information about the current state.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * The relative resource name of the job, of the form: projects/{project_number}/locations/{locationId}/lakes/{lakeId}/tasks/{taskId}/jobs/{jobId}.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * The number of times the job has been retried (excluding the initial attempt).
         */
        retryCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The underlying service running a job.
         */
        service?: pulumi.Input<string>;
        /**
         * (Output)
         * The full resource name for the job run under a particular service.
         */
        serviceJob?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the job was started.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Execution state for the job.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * System generated globally unique ID for the job.
         */
        uid?: pulumi.Input<string>;
    }

    export interface TaskIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TaskIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TaskNotebook {
        /**
         * Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Cloud Storage URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Infrastructure specification for the execution.
         * Structure is documented below.
         */
        infrastructureSpec?: pulumi.Input<inputs.dataplex.TaskNotebookInfrastructureSpec>;
        /**
         * Path to input notebook. This can be the Cloud Storage URI of the notebook file or the path to a Notebook Content. The execution args are accessible as environment variables (TASK_key=value).
         */
        notebook: pulumi.Input<string>;
    }

    export interface TaskNotebookInfrastructureSpec {
        /**
         * Compute resources needed for a Task when using Dataproc Serverless.
         * Structure is documented below.
         */
        batch?: pulumi.Input<inputs.dataplex.TaskNotebookInfrastructureSpecBatch>;
        /**
         * Container Image Runtime Configuration.
         * Structure is documented below.
         */
        containerImage?: pulumi.Input<inputs.dataplex.TaskNotebookInfrastructureSpecContainerImage>;
        /**
         * Vpc network.
         * Structure is documented below.
         */
        vpcNetwork?: pulumi.Input<inputs.dataplex.TaskNotebookInfrastructureSpecVpcNetwork>;
    }

    export interface TaskNotebookInfrastructureSpecBatch {
        /**
         * Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
         */
        executorsCount?: pulumi.Input<number>;
        /**
         * Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
         */
        maxExecutorsCount?: pulumi.Input<number>;
    }

    export interface TaskNotebookInfrastructureSpecContainerImage {
        /**
         * Container image to use.
         */
        image?: pulumi.Input<string>;
        /**
         * A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
         */
        javaJars?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
         */
        pythonPackages?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TaskNotebookInfrastructureSpecVpcNetwork {
        /**
         * The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
         */
        network?: pulumi.Input<string>;
        /**
         * List of network tags to apply to the job.
         */
        networkTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Cloud VPC sub-network in which the job is run.
         */
        subNetwork?: pulumi.Input<string>;
    }

    export interface TaskSpark {
        /**
         * Cloud Storage URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Cloud Storage URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Infrastructure specification for the execution.
         * Structure is documented below.
         */
        infrastructureSpec?: pulumi.Input<inputs.dataplex.TaskSparkInfrastructureSpec>;
        /**
         * The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in jar_file_uris. The execution args are passed in as a sequence of named process arguments (--key=value).
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the jar file that contains the main class. The execution args are passed in as a sequence of named process arguments (--key=value).
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * The Gcloud Storage URI of the main Python file to use as the driver. Must be a .py file. The execution args are passed in as a sequence of named process arguments (--key=value).
         */
        pythonScriptFile?: pulumi.Input<string>;
        /**
         * The query text. The execution args are used to declare a set of script variables (set key='value';).
         */
        sqlScript?: pulumi.Input<string>;
        /**
         * A reference to a query file. This can be the Cloud Storage URI of the query file or it can the path to a SqlScript Content. The execution args are used to declare a set of script variables (set key='value';).
         */
        sqlScriptFile?: pulumi.Input<string>;
    }

    export interface TaskSparkInfrastructureSpec {
        /**
         * Compute resources needed for a Task when using Dataproc Serverless.
         * Structure is documented below.
         */
        batch?: pulumi.Input<inputs.dataplex.TaskSparkInfrastructureSpecBatch>;
        /**
         * Container Image Runtime Configuration.
         * Structure is documented below.
         */
        containerImage?: pulumi.Input<inputs.dataplex.TaskSparkInfrastructureSpecContainerImage>;
        /**
         * Vpc network.
         * Structure is documented below.
         */
        vpcNetwork?: pulumi.Input<inputs.dataplex.TaskSparkInfrastructureSpecVpcNetwork>;
    }

    export interface TaskSparkInfrastructureSpecBatch {
        /**
         * Total number of job executors. Executor Count should be between 2 and 100. [Default=2]
         */
        executorsCount?: pulumi.Input<number>;
        /**
         * Max configurable executors. If maxExecutorsCount > executorsCount, then auto-scaling is enabled. Max Executor Count should be between 2 and 1000. [Default=1000]
         */
        maxExecutorsCount?: pulumi.Input<number>;
    }

    export interface TaskSparkInfrastructureSpecContainerImage {
        /**
         * Container image to use.
         */
        image?: pulumi.Input<string>;
        /**
         * A list of Java JARS to add to the classpath. Valid input includes Cloud Storage URIs to Jar binaries. For example, gs://bucket-name/my/path/to/file.jar
         */
        javaJars?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Override to common configuration of open source components installed on the Dataproc cluster. The properties to set on daemon config files. Property keys are specified in prefix:property format, for example core:hadoop.tmp.dir. For more information, see Cluster properties.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of python packages to be installed. Valid formats include Cloud Storage URI to a PIP installable library. For example, gs://bucket-name/my/path/to/lib.tar.gz
         */
        pythonPackages?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TaskSparkInfrastructureSpecVpcNetwork {
        /**
         * The Cloud VPC network in which the job is run. By default, the Cloud VPC network named Default within the project is used.
         */
        network?: pulumi.Input<string>;
        /**
         * List of network tags to apply to the job.
         */
        networkTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Cloud VPC sub-network in which the job is run.
         */
        subNetwork?: pulumi.Input<string>;
    }

    export interface TaskTriggerSpec {
        /**
         * Prevent the task from executing. This does not cancel already running tasks. It is intended to temporarily disable RECURRING tasks.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Number of retry attempts before aborting. Set to zero to never attempt to retry a failed task.
         */
        maxRetries?: pulumi.Input<number>;
        /**
         * Cron schedule (https://en.wikipedia.org/wiki/Cron) for running tasks periodically. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: 'CRON_TZ=${IANA_TIME_ZONE}' or 'TZ=${IANA_TIME_ZONE}'. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, CRON_TZ=America/New_York 1 * * * *, or TZ=America/New_York 1 * * * *. This field is required for RECURRING tasks.
         */
        schedule?: pulumi.Input<string>;
        /**
         * The first run of the task will be after this time. If not specified, the task will run shortly after being submitted if ON_DEMAND and based on the schedule if RECURRING.
         */
        startTime?: pulumi.Input<string>;
        /**
         * Trigger type of the user-specified Task
         * Possible values are: `ON_DEMAND`, `RECURRING`.
         */
        type: pulumi.Input<string>;
    }

    export interface ZoneAssetStatus {
        /**
         * Number of active assets.
         */
        activeAssets?: pulumi.Input<number>;
        /**
         * Number of assets that are in process of updating the security policy on attached resources.
         */
        securityPolicyApplyingAssets?: pulumi.Input<number>;
        /**
         * Output only. The time when the zone was last updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface ZoneDiscoverySpec {
        /**
         * Optional. Configuration for CSV data.
         */
        csvOptions?: pulumi.Input<inputs.dataplex.ZoneDiscoverySpecCsvOptions>;
        /**
         * Required. Whether discovery is enabled.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Optional. The list of patterns to apply for selecting data to exclude during discovery. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
         */
        excludePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. The list of patterns to apply for selecting data to include during discovery if only a subset of the data should considered. For Cloud Storage bucket assets, these are interpreted as glob patterns used to match object names. For BigQuery dataset assets, these are interpreted as patterns to match table names.
         */
        includePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Configuration for Json data.
         */
        jsonOptions?: pulumi.Input<inputs.dataplex.ZoneDiscoverySpecJsonOptions>;
        /**
         * Optional. Cron schedule (https://en.wikipedia.org/wiki/Cron) for running discovery periodically. Successive discovery runs must be scheduled at least 60 minutes apart. The default value is to run discovery every 60 minutes. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
         */
        schedule?: pulumi.Input<string>;
    }

    export interface ZoneDiscoverySpecCsvOptions {
        /**
         * Optional. The delimiter being used to separate values. This defaults to ','.
         */
        delimiter?: pulumi.Input<string>;
        /**
         * Optional. Whether to disable the inference of data type for CSV data. If true, all columns will be registered as strings.
         */
        disableTypeInference?: pulumi.Input<boolean>;
        /**
         * Optional. The character encoding of the data. The default is UTF-8.
         */
        encoding?: pulumi.Input<string>;
        /**
         * Optional. The number of rows to interpret as header rows that should be skipped when reading data rows.
         */
        headerRows?: pulumi.Input<number>;
    }

    export interface ZoneDiscoverySpecJsonOptions {
        /**
         * Optional. Whether to disable the inference of data type for Json data. If true, all columns will be registered as their primitive types (strings, number or boolean).
         */
        disableTypeInference?: pulumi.Input<boolean>;
        /**
         * Optional. The character encoding of the data. The default is UTF-8.
         */
        encoding?: pulumi.Input<string>;
    }

    export interface ZoneIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ZoneIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ZoneResourceSpec {
        /**
         * Required. Immutable. The location type of the resources that are allowed to be attached to the assets within this zone. Possible values: LOCATION_TYPE_UNSPECIFIED, SINGLE_REGION, MULTI_REGION
         *
         * - - -
         */
        locationType: pulumi.Input<string>;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        /**
         * Duration between scaling events. A scaling period starts after the
         * update operation from the previous event has completed.
         * Bounds: [2m, 1d]. Default: 2m.
         */
        cooldownPeriod?: pulumi.Input<string>;
        /**
         * YARN autoscaling configuration.
         * Structure is documented below.
         */
        yarnConfig: pulumi.Input<inputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig>;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        /**
         * Timeout for YARN graceful decommissioning of Node Managers. Specifies the
         * duration to wait for jobs to complete before forcefully removing workers
         * (and potentially interrupting jobs). Only applicable to downscaling operations.
         * Bounds: [0s, 1d].
         */
        gracefulDecommissionTimeout: pulumi.Input<string>;
        /**
         * Fraction of average pending memory in the last cooldown period for which to
         * remove workers. A scale-down factor of 1 will result in scaling down so that there
         * is no available memory remaining after the update (more aggressive scaling).
         * A scale-down factor of 0 disables removing workers, which can be beneficial for
         * autoscaling a single job.
         * Bounds: [0.0, 1.0].
         */
        scaleDownFactor: pulumi.Input<number>;
        /**
         * Minimum scale-down threshold as a fraction of total cluster size before scaling occurs.
         * For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must
         * recommend at least a 2 worker scale-down for the cluster to scale. A threshold of 0
         * means the autoscaler will scale down on any recommended change.
         * Bounds: [0.0, 1.0]. Default: 0.0.
         */
        scaleDownMinWorkerFraction?: pulumi.Input<number>;
        /**
         * Fraction of average pending memory in the last cooldown period for which to
         * add workers. A scale-up factor of 1.0 will result in scaling up so that there
         * is no pending memory remaining after the update (more aggressive scaling).
         * A scale-up factor closer to 0 will result in a smaller magnitude of scaling up
         * (less aggressive scaling).
         * Bounds: [0.0, 1.0].
         */
        scaleUpFactor: pulumi.Input<number>;
        /**
         * Minimum scale-up threshold as a fraction of total cluster size before scaling
         * occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler
         * must recommend at least a 2-worker scale-up for the cluster to scale. A threshold of
         * 0 means the autoscaler will scale up on any recommended change.
         * Bounds: [0.0, 1.0]. Default: 0.0.
         */
        scaleUpMinWorkerFraction?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicyIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AutoscalingPolicyIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        /**
         * Maximum number of instances for this group. Note that by default, clusters will not use
         * secondary workers. Required for secondary workers if the minimum secondary instances is set.
         * Bounds: [minInstances, ). Defaults to 0.
         */
        maxInstances?: pulumi.Input<number>;
        /**
         * Minimum number of instances for this group. Bounds: [0, maxInstances]. Defaults to 0.
         */
        minInstances?: pulumi.Input<number>;
        /**
         * Weight for the instance group, which is used to determine the fraction of total workers
         * in the cluster from this instance group. For example, if primary workers have weight 2,
         * and secondary workers have weight 1, the cluster will have approximately 2 primary workers
         * for each secondary worker.
         * The cluster may not reach the specified balance if constrained by min/max bounds or other
         * autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
         * primary workers will be added. The cluster can also be out of balance when created.
         * If weight is not set on any instance group, the cluster will default to equal weight for
         * all groups: the cluster will attempt to maintain an equal number of workers in each group
         * within the configured size bounds for each group. If weight is set for one group only,
         * the cluster will default to zero weight on the unset group. For example if weight is set
         * only on primary workers, the cluster will use primary workers only and no secondary workers.
         */
        weight?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicyWorkerConfig {
        /**
         * Maximum number of instances for this group.
         */
        maxInstances: pulumi.Input<number>;
        /**
         * Minimum number of instances for this group. Bounds: [2, maxInstances]. Defaults to 2.
         */
        minInstances?: pulumi.Input<number>;
        /**
         * Weight for the instance group, which is used to determine the fraction of total workers
         * in the cluster from this instance group. For example, if primary workers have weight 2,
         * and secondary workers have weight 1, the cluster will have approximately 2 primary workers
         * for each secondary worker.
         * The cluster may not reach the specified balance if constrained by min/max bounds or other
         * autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
         * primary workers will be added. The cluster can also be out of balance when created.
         * If weight is not set on any instance group, the cluster will default to equal weight for
         * all groups: the cluster will attempt to maintain an equal number of workers in each group
         * within the configured size bounds for each group. If weight is set for one group only,
         * the cluster will default to zero weight on the unset group. For example if weight is set
         * only on primary workers, the cluster will use primary workers only and no secondary workers.
         */
        weight?: pulumi.Input<number>;
    }

    export interface BatchEnvironmentConfig {
        /**
         * Execution configuration for a workload.
         * Structure is documented below.
         */
        executionConfig?: pulumi.Input<inputs.dataproc.BatchEnvironmentConfigExecutionConfig>;
        /**
         * Peripherals configuration that workload has access to.
         * Structure is documented below.
         */
        peripheralsConfig?: pulumi.Input<inputs.dataproc.BatchEnvironmentConfigPeripheralsConfig>;
    }

    export interface BatchEnvironmentConfigExecutionConfig {
        /**
         * The Cloud KMS key to use for encryption.
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * Tags used for network traffic control.
         */
        networkTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network configuration for workload execution.
         */
        networkUri?: pulumi.Input<string>;
        /**
         * Service account that used to execute workload.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * A Cloud Storage bucket used to stage workload dependencies, config files, and store
         * workload output and other ephemeral data, such as Spark history files. If you do not specify a staging bucket,
         * Cloud Dataproc will determine a Cloud Storage location according to the region where your workload is running,
         * and then create and manage project-level, per-location staging and temporary buckets.
         * This field requires a Cloud Storage bucket name, not a gs://... URI to a Cloud Storage bucket.
         */
        stagingBucket?: pulumi.Input<string>;
        /**
         * Subnetwork configuration for workload execution.
         */
        subnetworkUri?: pulumi.Input<string>;
        /**
         * The duration after which the workload will be terminated.
         * When the workload exceeds this duration, it will be unconditionally terminated without waiting for ongoing
         * work to finish. If ttl is not specified for a batch workload, the workload will be allowed to run until it
         * exits naturally (or run forever without exiting). If ttl is not specified for an interactive session,
         * it defaults to 24 hours. If ttl is not specified for a batch that uses 2.1+ runtime version, it defaults to 4 hours.
         * Minimum value is 10 minutes; maximum value is 14 days. If both ttl and idleTtl are specified (for an interactive session),
         * the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idleTtl or
         * when ttl has been exceeded, whichever occurs first.
         */
        ttl?: pulumi.Input<string>;
    }

    export interface BatchEnvironmentConfigPeripheralsConfig {
        /**
         * Resource name of an existing Dataproc Metastore service.
         */
        metastoreService?: pulumi.Input<string>;
        /**
         * The Spark History Server configuration for the workload.
         * Structure is documented below.
         */
        sparkHistoryServerConfig?: pulumi.Input<inputs.dataproc.BatchEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig>;
    }

    export interface BatchEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig {
        /**
         * Resource name of an existing Dataproc Cluster to act as a Spark History Server for the workload.
         */
        dataprocCluster?: pulumi.Input<string>;
    }

    export interface BatchPysparkBatch {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor.
         * Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments that can be set as batch
         * properties, such as --conf, since a collision can occur that causes an incorrect batch submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the classpath of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the main Python file to use as the Spark driver. Must be a .py file.
         */
        mainPythonFileUri?: pulumi.Input<string>;
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework.
         * Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BatchRuntimeConfig {
        /**
         * Optional. Autotuning configuration of the workload.
         * Structure is documented below.
         */
        autotuningConfig?: pulumi.Input<inputs.dataproc.BatchRuntimeConfigAutotuningConfig>;
        /**
         * Optional. Cohort identifier. Identifies families of the workloads having the same shape, e.g. daily ETL jobs.
         */
        cohort?: pulumi.Input<string>;
        /**
         * Optional custom container image for the job runtime environment. If not specified, a default container image will be used.
         */
        containerImage?: pulumi.Input<string>;
        /**
         * (Output)
         * A mapping of property names to values, which are used to configure workload execution.
         */
        effectiveProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A mapping of property names to values, which are used to configure workload execution.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Version of the batch runtime.
         */
        version?: pulumi.Input<string>;
    }

    export interface BatchRuntimeConfigAutotuningConfig {
        /**
         * Optional. Scenarios for which tunings are applied.
         * Each value may be one of: `SCALING`, `BROADCAST_HASH_JOIN`, `MEMORY`.
         */
        scenarios?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BatchRuntimeInfo {
        /**
         * (Output)
         * Approximate workload resource usage, calculated when the workload completes(see [Dataproc Serverless pricing](https://cloud.google.com/dataproc-serverless/pricing))
         * Structure is documented below.
         */
        approximateUsages?: pulumi.Input<pulumi.Input<inputs.dataproc.BatchRuntimeInfoApproximateUsage>[]>;
        /**
         * (Output)
         * Snapshot of current workload resource usage(see [Dataproc Serverless pricing](https://cloud.google.com/dataproc-serverless/pricing))
         * Structure is documented below.
         */
        currentUsages?: pulumi.Input<pulumi.Input<inputs.dataproc.BatchRuntimeInfoCurrentUsage>[]>;
        /**
         * (Output)
         * A URI pointing to the location of the diagnostics tarball.
         */
        diagnosticOutputUri?: pulumi.Input<string>;
        /**
         * (Output)
         * Map of remote access endpoints (such as web interfaces and APIs) to their URIs.
         */
        endpoints?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * A URI pointing to the location of the stdout and stderr of the workload.
         */
        outputUri?: pulumi.Input<string>;
    }

    export interface BatchRuntimeInfoApproximateUsage {
        /**
         * (Output)
         * Accelerator type being used, if any.
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * (Output)
         * Accelerator usage in (milliAccelerator x seconds)
         */
        milliAcceleratorSeconds?: pulumi.Input<string>;
        /**
         * (Output)
         * DCU (Dataproc Compute Units) usage in (milliDCU x seconds)
         */
        milliDcuSeconds?: pulumi.Input<string>;
        /**
         * (Output)
         * Shuffle storage usage in (GB x seconds)
         */
        shuffleStorageGbSeconds?: pulumi.Input<string>;
    }

    export interface BatchRuntimeInfoCurrentUsage {
        /**
         * (Output)
         * Accelerator type being used, if any.
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * (Output)
         * Milli (one-thousandth) accelerator..
         */
        milliAccelerator?: pulumi.Input<string>;
        /**
         * (Output)
         * Milli (one-thousandth) Dataproc Compute Units (DCUs).
         */
        milliDcu?: pulumi.Input<string>;
        /**
         * (Output)
         * Milli (one-thousandth) Dataproc Compute Units (DCUs) charged at premium tier.
         */
        milliDcuPremium?: pulumi.Input<string>;
        /**
         * (Output)
         * Shuffle Storage in gigabytes (GB).
         */
        shuffleStorageGb?: pulumi.Input<string>;
        /**
         * (Output)
         * Shuffle Storage in gigabytes (GB) charged at premium tier.
         */
        shuffleStorageGbPremium?: pulumi.Input<string>;
        /**
         * (Output)
         * The timestamp of the usage snapshot.
         */
        snapshotTime?: pulumi.Input<string>;
    }

    export interface BatchSparkBatch {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor.
         * Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments that can be set as batch
         * properties, such as --conf, since a collision can occur that causes an incorrect batch submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the classpath of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the driver main class. The jar file that contains the class must be in the
         * classpath or specified in jarFileUris.
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file that contains the main class.
         */
        mainJarFileUri?: pulumi.Input<string>;
    }

    export interface BatchSparkRBatch {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor.
         * Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments that can be set as batch
         * properties, such as --conf, since a collision can occur that causes an incorrect batch submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the main R file to use as the driver. Must be a .R or .r file.
         */
        mainRFileUri?: pulumi.Input<string>;
    }

    export interface BatchSparkSqlBatch {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the script that contains Spark SQL queries to execute.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: SET name="value";).
         */
        queryVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface BatchStateHistory {
        /**
         * (Output)
         * The state of the batch at this point in history. For possible values, see the [API documentation](https://cloud.google.com/dataproc-serverless/docs/reference/rest/v1/projects.locations.batches#State).
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Details about the state at this point in history.
         */
        stateMessage?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the batch entered the historical state.
         */
        stateStartTime?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfig {
        /**
         * The autoscaling policy config associated with the cluster.
         * Note that once set, if `autoscalingConfig` is the only field set in `clusterConfig`, it can
         * only be removed by setting `policyUri = ""`, rather than removing the whole block.
         * Structure defined below.
         */
        autoscalingConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAutoscalingConfig>;
        /**
         * A Dataproc NodeGroup resource is a group of Dataproc cluster nodes that execute an assigned role. 
         * Structure defined below.
         */
        auxiliaryNodeGroups?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigAuxiliaryNodeGroup>[]>;
        /**
         * The name of the cloud storage bucket ultimately used to house the staging data
         * for the cluster. If `stagingBucket` is specified, it will contain this value, otherwise
         * it will be the auto generated name.
         */
        bucket?: pulumi.Input<string>;
        /**
         * The Compute Engine accelerator (GPU) configuration for these instances. Can be specified multiple times.
         * Structure defined below.
         */
        dataprocMetricConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigDataprocMetricConfig>;
        /**
         * The Customer managed encryption keys settings for the cluster.
         * Structure defined below.
         */
        encryptionConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigEncryptionConfig>;
        /**
         * The config settings for port access on the cluster.
         * Structure defined below.
         */
        endpointConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigEndpointConfig>;
        /**
         * Common config settings for resources of Google Compute Engine cluster
         * instances, applicable to all instances in the cluster. Structure defined below.
         */
        gceClusterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfig>;
        /**
         * Commands to execute on each node after config is completed.
         * You can specify multiple versions of these. Structure defined below.
         */
        initializationActions?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigInitializationAction>[]>;
        /**
         * The settings for auto deletion cluster schedule.
         * Structure defined below.
         */
        lifecycleConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigLifecycleConfig>;
        /**
         * The Google Compute Engine config settings for the master instances
         * in a cluster. Structure defined below.
         */
        masterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfig>;
        /**
         * The config setting for metastore service with the cluster.
         * Structure defined below.
         * - - -
         */
        metastoreConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMetastoreConfig>;
        /**
         * The Google Compute Engine config settings for the additional
         * instances in a cluster. Structure defined below.
         * * **NOTE** : `preemptibleWorkerConfig` is
         * an alias for the api's [secondaryWorkerConfig](https://cloud.google.com/dataproc/docs/reference/rest/v1/ClusterConfig#InstanceGroupConfig). The name doesn't necessarily mean it is preemptible and is named as
         * such for legacy/compatibility reasons.
         */
        preemptibleWorkerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig>;
        /**
         * Security related configuration. Structure defined below.
         */
        securityConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfig>;
        /**
         * The config settings for software inside the cluster.
         * Structure defined below.
         */
        softwareConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSoftwareConfig>;
        /**
         * The Cloud Storage staging bucket used to stage files,
         * such as Hadoop jars, between client machines and the cluster.
         * Note: If you don't explicitly specify a `stagingBucket`
         * then GCP will auto create / assign one for you. However, you are not guaranteed
         * an auto generated bucket which is solely dedicated to your cluster; it may be shared
         * with other clusters in the same region/zone also choosing to use the auto generation
         * option.
         */
        stagingBucket?: pulumi.Input<string>;
        /**
         * The Cloud Storage temp bucket used to store ephemeral cluster
         * and jobs data, such as Spark and MapReduce history files.
         * Note: If you don't explicitly specify a `tempBucket` then GCP will auto create / assign one for you.
         */
        tempBucket?: pulumi.Input<string>;
        /**
         * The Google Compute Engine config settings for the worker instances
         * in a cluster. Structure defined below.
         */
        workerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfig>;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        /**
         * The autoscaling policy used by the cluster.
         *
         * Only resource names including projectid and location (region) are valid. Examples:
         *
         * `https://www.googleapis.com/compute/v1/projects/[projectId]/locations/[dataprocRegion]/autoscalingPolicies/[policyId]`
         * `projects/[projectId]/locations/[dataprocRegion]/autoscalingPolicies/[policyId]`
         * Note that the policy must be in the same project and Cloud Dataproc region.
         *
         * - - -
         */
        policyUri: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigAuxiliaryNodeGroup {
        /**
         * A node group ID. Generated if not specified. The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of from 3 to 33 characters.
         */
        nodeGroupId?: pulumi.Input<string>;
        /**
         * Node group configuration.
         */
        nodeGroups: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigAuxiliaryNodeGroupNodeGroup>[]>;
    }

    export interface ClusterClusterConfigAuxiliaryNodeGroupNodeGroup {
        /**
         * The Node group resource name.
         */
        name?: pulumi.Input<string>;
        /**
         * The node group instance group configuration.
         */
        nodeGroupConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfig>;
        /**
         * Node group roles. 
         * One of `"DRIVER"`.
         */
        roles: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfig {
        /**
         * The Compute Engine accelerator (GPU) configuration for these instances. Can be specified 
         * multiple times.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfigAccelerator>[]>;
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfigDiskConfig>;
        /**
         * List of auxiliary node group instance names which have been assigned to the cluster.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of a Google Compute Engine machine type
         * to create for the node group. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The name of a minimum generation of CPU family
         * for the node group. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Specifies the number of master nodes to create.
         * Please set a number greater than 0. Node Group must have at least 1 instance.
         */
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         *
         *
         * - - -
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigAuxiliaryNodeGroupNodeGroupNodeGroupConfigDiskConfig {
        /**
         * Size of the primary disk attached to each node, specified
         * in GB. The primary disk contains the boot volume and system libraries, and the
         * smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Interface type of local SSDs (default is "scsi"). Valid values: "scsi" (Small Computer System Interface), "nvme" (Non-Volatile Memory Express).
         */
        localSsdInterface?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be attached to each master cluster node. 
         * Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigDataprocMetricConfig {
        /**
         * Metrics sources to enable.
         */
        metrics: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigDataprocMetricConfigMetric>[]>;
    }

    export interface ClusterClusterConfigDataprocMetricConfigMetric {
        /**
         * One or more [available OSS metrics] (https://cloud.google.com/dataproc/docs/guides/monitoring#available_oss_metrics) to collect for the metric course.
         *
         * - - -
         */
        metricOverrides?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A source for the collection of Dataproc OSS metrics (see [available OSS metrics](https://cloud.google.com//dataproc/docs/guides/monitoring#available_oss_metrics)).
         */
        metricSource: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        /**
         * The Cloud KMS key name to use for PD disk encryption for
         * all instances in the cluster.
         *
         * - - -
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigEndpointConfig {
        /**
         * The flag to enable http access to specific ports
         * on the cluster from external sources (aka Component Gateway). Defaults to false.
         */
        enableHttpPortAccess: pulumi.Input<boolean>;
        /**
         * The map of port descriptions to URLs. Will only be populated if
         * `enableHttpPortAccess` is true.
         */
        httpPorts?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        /**
         * Confidential Instance Config for clusters using [Confidential VMs](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/confidential-compute)
         */
        confidentialInstanceConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfigConfidentialInstanceConfig>;
        /**
         * By default, clusters are not restricted to internal IP addresses,
         * and will have ephemeral external IP addresses assigned to each instance. If set to true, all
         * instances in the cluster will only have internal IP addresses. Note: Private Google Access
         * (also known as `privateIpGoogleAccess`) must be enabled on the subnetwork that the cluster
         * will be launched in.
         */
        internalIpOnly?: pulumi.Input<boolean>;
        /**
         * A map of the Compute Engine metadata entries to add to all instances
         * (see [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The name or selfLink of the Google Compute Engine
         * network to the cluster will be part of. Conflicts with `subnetwork`.
         * If neither is specified, this defaults to the "default" network.
         */
        network?: pulumi.Input<string>;
        /**
         * Node Group Affinity for sole-tenant clusters.
         */
        nodeGroupAffinity?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfigNodeGroupAffinity>;
        /**
         * Reservation Affinity for consuming zonal reservation.
         */
        reservationAffinity?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfigReservationAffinity>;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The set of Google API scopes
         * to be made available on all of the node VMs under the `serviceAccount`
         * specified. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         */
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Shielded Instance Config for clusters using [Compute Engine Shielded VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm).
         *
         * - - -
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfigShieldedInstanceConfig>;
        /**
         * The name or selfLink of the Google Compute Engine
         * subnetwork the cluster will be part of. Conflicts with `network`.
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The list of instance tags applied to instances in the cluster.
         * Tags are used to identify valid sources or targets for network firewalls.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The GCP zone where your data is stored and used (i.e. where
         * the master and the worker nodes will be created in). If `region` is set to 'global' (default)
         * then `zone` is mandatory, otherwise GCP is able to make use of [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/auto-zone)
         * to determine this automatically for you.
         * Note: This setting additionally determines and restricts
         * which computing resources are available for use with other configs such as
         * `cluster_config.master_config.machine_type` and `cluster_config.worker_config.machine_type`.
         */
        zone?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigGceClusterConfigConfidentialInstanceConfig {
        /**
         * Defines whether the instance should have confidential compute enabled.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface ClusterClusterConfigGceClusterConfigNodeGroupAffinity {
        /**
         * The URI of a sole-tenant node group resource that the cluster will be created on.
         */
        nodeGroupUri: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigGceClusterConfigReservationAffinity {
        /**
         * Corresponds to the type of reservation consumption.
         */
        consumeReservationType?: pulumi.Input<string>;
        /**
         * Corresponds to the label key of reservation resource.
         */
        key?: pulumi.Input<string>;
        /**
         * Corresponds to the label values of reservation resource.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterClusterConfigGceClusterConfigShieldedInstanceConfig {
        /**
         * Defines whether instances have integrity monitoring enabled.
         *
         * - - -
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines whether instances have Secure Boot enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Defines whether instances have the [vTPM](https://cloud.google.com/security/shielded-cloud/shielded-vm#vtpm) enabled.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface ClusterClusterConfigInitializationAction {
        /**
         * The script to be executed during initialization of the cluster.
         * The script must be a GCS file with a gs:// prefix.
         */
        script: pulumi.Input<string>;
        /**
         * The maximum duration (in seconds) which `script` is
         * allowed to take to execute its action. GCP will default to a predetermined
         * computed value if not set (currently 300).
         *
         * - - -
         */
        timeoutSec?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        /**
         * The time when cluster will be auto-deleted.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
         * Example: "2014-10-02T15:01:23.045123456Z".
         *
         * - - -
         */
        autoDeleteTime?: pulumi.Input<string>;
        /**
         * The duration to keep the cluster alive while idling
         * (no jobs running). After this TTL, the cluster will be deleted. Valid range: [10m, 14d].
         */
        idleDeleteTtl?: pulumi.Input<string>;
        /**
         * Time when the cluster became idle
         * (most recent job finished) and became eligible for deletion due to idleness.
         */
        idleStartTime?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfig {
        /**
         * The Compute Engine accelerator (GPU) configuration for these instances. Can be specified multiple times.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigAccelerator>[]>;
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig>;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri?: pulumi.Input<string>;
        /**
         * List of master instance names which
         * have been assigned to the cluster.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of a Google Compute Engine machine type
         * to create for the master. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Specifies the number of master nodes to create.
         * If not specified, GCP will default to a predetermined computed value (currently 1).
         */
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         *
         * > The Cloud Dataproc API can return unintuitive error messages when using accelerators; even when you have defined an accelerator, Auto Zone Placement does not exclusively select
         * zones that have that accelerator available. If you get a 400 error that the accelerator can't be found, this is a likely cause. Make sure you check [accelerator availability by zone](https://cloud.google.com/compute/docs/reference/rest/v1/acceleratorTypes/list)
         * if you are trying to use accelerators in a given zone.
         *
         * - - -
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        /**
         * Size of the primary disk attached to each node, specified
         * in GB. The primary disk contains the boot volume and system libraries, and the
         * smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Optional. Interface type of local SSDs (default is "scsi").
         * Valid values: "scsi" (Small Computer System Interface), "nvme" (Non-Volatile
         * Memory Express). See
         * [local SSD performance](https://cloud.google.com/compute/docs/disks/local-ssd#performance).
         */
        localSsdInterface?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each master cluster node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMetastoreConfig {
        /**
         * Resource name of an existing Dataproc Metastore service.
         *
         * Only resource names including projectid and location (region) are valid. Examples:
         *
         * `projects/[projectId]/locations/[dataprocRegion]/services/[service-name]`
         */
        dataprocMetastoreService: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig>;
        /**
         * Instance flexibility Policy allowing a mixture of VM shapes and provisioning models.
         */
        instanceFlexibilityPolicy?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicy>;
        /**
         * List of preemptible instance names which have been assigned
         * to the cluster.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the number of preemptible nodes to create.
         * Defaults to 0.
         */
        numInstances?: pulumi.Input<number>;
        /**
         * Specifies the preemptibility of the secondary workers. The default value is `PREEMPTIBLE`
         * Accepted values are:
         * * PREEMPTIBILITY_UNSPECIFIED
         * * NON_PREEMPTIBLE
         * * PREEMPTIBLE
         */
        preemptibility?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Interface type of local SSDs (default is "scsi"). Valid values: "scsi" (Small Computer System Interface), "nvme" (Non-Volatile Memory Express).
         */
        localSsdInterface?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicy {
        /**
         * List of instance selection options that the group will use when creating new VMs.
         */
        instanceSelectionLists?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyInstanceSelectionList>[]>;
        /**
         * A list of instance selection results in the group.
         */
        instanceSelectionResults?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyInstanceSelectionResult>[]>;
        /**
         * Defines how the Group selects the provisioning model to ensure required reliability.
         */
        provisioningModelMix?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyProvisioningModelMix>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyInstanceSelectionList {
        /**
         * Full machine-type names, e.g. `"n1-standard-16"`.
         */
        machineTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Preference of this instance selection. A lower number means higher preference. Dataproc will first try to create a VM based on the machine-type with priority rank and fallback to next rank based on availability. Machine types and instance selections with the same priority have the same preference.
         */
        rank?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyInstanceSelectionResult {
        /**
         * Full machine-type names, e.g. "n1-standard-16".
         */
        machineType?: pulumi.Input<string>;
        /**
         * Number of VM provisioned with the machine_type.
         */
        vmCount?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigInstanceFlexibilityPolicyProvisioningModelMix {
        /**
         * The base capacity that will always use Standard VMs to avoid risk of more preemption than the minimum capacity you need. Dataproc will create only standard VMs until it reaches standardCapacityBase, then it will start using standardCapacityPercentAboveBase to mix Spot with Standard VMs. eg. If 15 instances are requested and standardCapacityBase is 5, Dataproc will create 5 standard VMs and then start mixing spot and standard VMs for remaining 10 instances.
         */
        standardCapacityBase?: pulumi.Input<number>;
        /**
         * The percentage of target capacity that should use Standard VM. The remaining percentage will use Spot VMs. The percentage applies only to the capacity above standardCapacityBase. eg. If 15 instances are requested and standardCapacityBase is 5 and standardCapacityPercentAboveBase is 30, Dataproc will create 5 standard VMs and then start mixing spot and standard VMs for remaining 10 instances. The mix will be 30% standard and 70% spot.
         * - - -
         */
        standardCapacityPercentAboveBase?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigSecurityConfig {
        /**
         * Kerberos Configuration
         */
        kerberosConfig: pulumi.Input<inputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig>;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        /**
         * The admin server (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustAdminServer?: pulumi.Input<string>;
        /**
         * The KDC (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustKdc?: pulumi.Input<string>;
        /**
         * The remote realm the Dataproc on-cluster KDC will
         * trust, should the user enable cross realm trust.
         */
        crossRealmTrustRealm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS
         * encrypted file containing the shared password between the on-cluster Kerberos realm
         * and the remote trusted realm, in a cross realm trust relationship.
         */
        crossRealmTrustSharedPasswordUri?: pulumi.Input<string>;
        /**
         * Flag to indicate whether to Kerberize the cluster.
         */
        enableKerberos?: pulumi.Input<boolean>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the master key of the KDC database.
         */
        kdcDbKeyUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided key. For the self-signed certificate, this password
         * is generated by Dataproc.
         */
        keyPasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided keystore. For the self-signed certificated, the password
         * is generated by Dataproc.
         */
        keystorePasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the keystore file used for SSL encryption.
         * If not provided, Dataproc will provide a self-signed certificate.
         */
        keystoreUri?: pulumi.Input<string>;
        /**
         * The URI of the KMS key used to encrypt various sensitive files.
         */
        kmsKeyUri: pulumi.Input<string>;
        /**
         * The name of the on-cluster Kerberos realm. If not specified, the
         * uppercased domain of hostnames will be the realm.
         */
        realm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the root principal password.
         */
        rootPrincipalPasswordUri: pulumi.Input<string>;
        /**
         * The lifetime of the ticket granting ticket, in hours.
         */
        tgtLifetimeHours?: pulumi.Input<number>;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the password to the user provided truststore. For the self-signed
         * certificate, this password is generated by Dataproc.
         */
        truststorePasswordUri?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the truststore file used for
         * SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
         *
         * - - -
         */
        truststoreUri?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        /**
         * The Cloud Dataproc image version to use
         * for the cluster - this controls the sets of software versions
         * installed onto the nodes when you create clusters. If not specified, defaults to the
         * latest version. For a list of valid versions see
         * [Cloud Dataproc versions](https://cloud.google.com/dataproc/docs/concepts/dataproc-versions)
         */
        imageVersion?: pulumi.Input<string>;
        /**
         * The set of optional components to activate on the cluster. See [Available Optional Components](https://cloud.google.com/dataproc/docs/concepts/components/overview#available_optional_components).
         *
         * - - -
         */
        optionalComponents?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of override and additional properties (key/value pairs)
         * used to modify various aspects of the common configuration files used when creating
         * a cluster. For a list of valid properties please see
         * [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties)
         */
        overrideProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A list of the properties used to set the daemon config files.
         * This will include any values supplied by the user via `cluster_config.software_config.override_properties`
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ClusterClusterConfigWorkerConfig {
        /**
         * The Compute Engine accelerator configuration for these instances. Can be specified multiple times.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator>[]>;
        /**
         * Disk Config
         */
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig>;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri?: pulumi.Input<string>;
        /**
         * List of worker instance names which have been assigned
         * to the cluster.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of a Google Compute Engine machine type
         * to create for the worker nodes. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType?: pulumi.Input<string>;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * The minimum number of primary worker instances to create.  If `minNumInstances` is set, cluster creation will succeed if the number of primary workers created is at least equal to the `minNumInstances` number.
         */
        minNumInstances?: pulumi.Input<number>;
        /**
         * Specifies the number of worker nodes to create.
         * If not specified, GCP will default to a predetermined computed value (currently 2).
         * There is currently a beta feature which allows you to run a
         * [Single Node Cluster](https://cloud.google.com/dataproc/docs/concepts/single-node-clusters).
         * In order to take advantage of this you need to set
         * `"dataproc:dataproc.allow.zero.workers" = "true"` in
         * `cluster_config.software_config.properties`
         */
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         *
         * > The Cloud Dataproc API can return unintuitive error messages when using accelerators; even when you have defined an accelerator, Auto Zone Placement does not exclusively select
         * zones that have that accelerator available. If you get a 400 error that the accelerator can't be found, this is a likely cause. Make sure you check [accelerator availability by zone](https://cloud.google.com/compute/docs/reference/rest/v1/acceleratorTypes/list)
         * if you are trying to use accelerators in a given zone.
         *
         * - - -
         */
        acceleratorCount: pulumi.Input<number>;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The disk type of the primary disk attached to each node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Interface type of local SSDs (default is "scsi"). Valid values: "scsi" (Small Computer System Interface), "nvme" (Non-Volatile Memory Express).
         */
        localSsdInterface?: pulumi.Input<string>;
        /**
         * The amount of local SSD disks that will be
         * attached to each worker cluster node. Defaults to 0.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ClusterIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ClusterVirtualClusterConfig {
        /**
         * Configuration of auxiliary services used by this cluster. 
         * Structure defined below.
         */
        auxiliaryServicesConfig?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigAuxiliaryServicesConfig>;
        /**
         * The configuration for running the Dataproc cluster on Kubernetes.
         * Structure defined below.
         * - - -
         */
        kubernetesClusterConfig?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfig>;
        /**
         * The Cloud Storage staging bucket used to stage files,
         * such as Hadoop jars, between client machines and the cluster.
         * Note: If you don't explicitly specify a `stagingBucket`
         * then GCP will auto create / assign one for you. However, you are not guaranteed
         * an auto generated bucket which is solely dedicated to your cluster; it may be shared
         * with other clusters in the same region/zone also choosing to use the auto generation
         * option.
         */
        stagingBucket?: pulumi.Input<string>;
    }

    export interface ClusterVirtualClusterConfigAuxiliaryServicesConfig {
        /**
         * The Hive Metastore configuration for this workload.
         */
        metastoreConfig?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigAuxiliaryServicesConfigMetastoreConfig>;
        /**
         * The Spark History Server configuration for the workload.
         */
        sparkHistoryServerConfig?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigAuxiliaryServicesConfigSparkHistoryServerConfig>;
    }

    export interface ClusterVirtualClusterConfigAuxiliaryServicesConfigMetastoreConfig {
        /**
         * Resource name of an existing Dataproc Metastore service.
         */
        dataprocMetastoreService?: pulumi.Input<string>;
    }

    export interface ClusterVirtualClusterConfigAuxiliaryServicesConfigSparkHistoryServerConfig {
        /**
         * Resource name of an existing Dataproc Cluster to act as a Spark History Server for the workload.
         * - - -
         */
        dataprocCluster?: pulumi.Input<string>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfig {
        /**
         * The configuration for running the Dataproc cluster on GKE.
         */
        gkeClusterConfig: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfig>;
        /**
         * A namespace within the Kubernetes cluster to deploy into. 
         * If this namespace does not exist, it is created.
         * If it  exists, Dataproc verifies that another Dataproc VirtualCluster is not installed into it.
         * If not specified, the name of the Dataproc Cluster is used.
         */
        kubernetesNamespace?: pulumi.Input<string>;
        /**
         * The software configuration for this Dataproc cluster running on Kubernetes.
         */
        kubernetesSoftwareConfig: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigKubernetesSoftwareConfig>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfig {
        /**
         * A target GKE cluster to deploy to. It must be in the same project and region as the Dataproc cluster 
         * (the GKE cluster can be zonal or regional)
         */
        gkeClusterTarget?: pulumi.Input<string>;
        /**
         * GKE node pools where workloads will be scheduled. At least one node pool must be assigned the `DEFAULT` 
         * GkeNodePoolTarget.Role. If a GkeNodePoolTarget is not specified, Dataproc constructs a `DEFAULT` GkeNodePoolTarget.
         * Each role can be given to only one GkeNodePoolTarget. All node pools must have the same location settings.
         */
        nodePoolTargets?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTarget>[]>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTarget {
        /**
         * The target GKE node pool.
         */
        nodePool: pulumi.Input<string>;
        /**
         * The configuration for the GKE node pool. 
         * If specified, Dataproc attempts to create a node pool with the specified shape.
         * If one with the same name already exists, it is verified against all specified fields.
         * If a field differs, the virtual cluster creation will fail.
         */
        nodePoolConfig?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfig>;
        /**
         * The roles associated with the GKE node pool. 
         * One of `"DEFAULT"`, `"CONTROLLER"`, `"SPARK_DRIVER"` or `"SPARK_EXECUTOR"`.
         */
        roles: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfig {
        /**
         * The autoscaler configuration for this node pool. 
         * The autoscaler is enabled only when a valid configuration is present.
         */
        autoscaling?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfigAutoscaling>;
        /**
         * The node pool configuration.
         */
        config?: pulumi.Input<inputs.dataproc.ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfigConfig>;
        /**
         * The list of Compute Engine zones where node pool nodes associated 
         * with a Dataproc on GKE virtual cluster will be located.
         * - - -
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfigAutoscaling {
        /**
         * The maximum number of nodes in the node pool. Must be >= minNodeCount, and must be > 0.
         */
        maxNodeCount?: pulumi.Input<number>;
        /**
         * The minimum number of nodes in the node pool. Must be >= 0 and <= maxNodeCount.
         */
        minNodeCount?: pulumi.Input<number>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigGkeClusterConfigNodePoolTargetNodePoolConfigConfig {
        /**
         * The number of local SSD disks to attach to the node, 
         * which is limited by the maximum number of disks allowable per zone.
         */
        localSsdCount?: pulumi.Input<number>;
        /**
         * The name of a Compute Engine machine type.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Minimum CPU platform to be used by this instance. 
         * The instance may be scheduled on the specified or a newer CPU platform.
         * Specify the friendly names of CPU platforms, such as "Intel Haswell" or "Intel Sandy Bridge".
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Whether the nodes are created as preemptible VM instances. 
         * Preemptible nodes cannot be used in a node pool with the CONTROLLER role or in the DEFAULT node pool if the
         * CONTROLLER role is not assigned (the DEFAULT node pool will assume the CONTROLLER role).
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
         */
        spot?: pulumi.Input<boolean>;
    }

    export interface ClusterVirtualClusterConfigKubernetesClusterConfigKubernetesSoftwareConfig {
        /**
         * The components that should be installed in this Dataproc cluster. The key must be a string from the   
         * KubernetesComponent enumeration. The value is the version of the software to be installed. At least one entry must be specified.
         * * **NOTE** : `component_version[SPARK]` is mandatory to set, or the creation of the cluster will fail.
         */
        componentVersion: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The properties to set on daemon config files. Property keys are specified in prefix:property format, 
         * for example spark:spark.kubernetes.container.image.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GdcApplicationEnvironmentSparkApplicationEnvironmentConfig {
        /**
         * A map of default Spark properties to apply to workloads in this application environment. These defaults may be overridden by per-application properties.
         */
        defaultProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default Dataproc version to use for applications submitted to this application environment
         */
        defaultVersion?: pulumi.Input<string>;
    }

    export interface GdcServiceInstanceGdceCluster {
        /**
         * Gdce cluster resource id.
         */
        gdceCluster: pulumi.Input<string>;
    }

    export interface GdcServiceInstanceSparkServiceInstanceConfig {
    }

    export interface GdcSparkApplicationPysparkApplicationConfig {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver.  Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Python driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the main Python file to use as the driver. Must be a .py file.
         */
        mainPythonFileUri: pulumi.Input<string>;
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GdcSparkApplicationSparkApplicationConfig {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments that can be set as application properties, such as `--conf`, since a collision can occur that causes an incorrect application submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the classpath of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the driver main class. The jar file that contains the class must be in the classpath or specified in `jarFileUris`.
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file that contains the main class.
         */
        mainJarFileUri?: pulumi.Input<string>;
    }

    export interface GdcSparkApplicationSparkRApplicationConfig {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver.  Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the main R file to use as the driver. Must be a .R file.
         */
        mainRFileUri: pulumi.Input<string>;
    }

    export interface GdcSparkApplicationSparkSqlApplicationConfig {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * Represents a list of queries.
         * Structure is documented below.
         */
        queryList?: pulumi.Input<inputs.dataproc.GdcSparkApplicationSparkSqlApplicationConfigQueryList>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: SET `name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GdcSparkApplicationSparkSqlApplicationConfigQueryList {
        /**
         * The queries to run.
         */
        queries: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobHadoopConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobHadoopConfigLoggingConfig>;
        /**
         * The name of the driver's main class. The jar file containing the class must be in the default CLASSPATH or specified in `jarFileUris`. Conflicts with `mainJarFileUri`
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'. Conflicts with `mainClass`
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Hadoop. Properties that conflict with values set by the Cloud Dataproc API may be overwritten. Can include properties set in `/etc/hadoop/conf/*-site` and classes in user code..
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHadoopConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHiveConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATH of the Hive server and Hadoop MapReduce (MR) tasks. Can contain Hive SerDes and UDFs.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A mapping of property names and values, used to configure Hive. Properties that conflict with values set by the Cloud Dataproc API may be overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`, `/etc/hive/conf/hive-site.xml`, and classes in user code..
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * HCFS URI of file containing Hive script to execute as the job.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * The list of Hive queries or statements to execute as part of the job.
         * Conflicts with `queryFileUri`
         */
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Hive command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface JobPigConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATH of the Pig Client and Hadoop MapReduce (MR) tasks. Can contain Pig UDFs.
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPigConfigLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Pig. Properties that conflict with values set by the Cloud Dataproc API may be overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`, `/etc/pig/conf/pig.properties`, and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * HCFS URI of file containing Hive script to execute as the job.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * The list of Hive queries or statements to execute as part of the job.
         * Conflicts with `queryFileUri`
         */
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Pig command: `name=[value]`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPigConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPlacement {
        /**
         * The name of the cluster where the job will be submitted
         */
        clusterName: pulumi.Input<string>;
        /**
         * Output-only. A cluster UUID generated by the Cloud Dataproc service when the job is submitted
         */
        clusterUuid?: pulumi.Input<string>;
    }

    export interface JobPrestoConfig {
        /**
         * Presto client tags to attach to this query.
         */
        clientTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to continue executing queries if a query fails. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPrestoConfigLoggingConfig>;
        /**
         * The format in which query output will be displayed. See the Presto documentation for supported output formats.
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        outputFormat?: pulumi.Input<string>;
        /**
         * A mapping of property names to values. Used to set Presto session properties Equivalent to using the --session flag in the Presto CLI.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * The list of SQL queries or statements to execute as part of the job.
         * Conflicts with `queryFileUri`
         */
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobPrestoConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPysparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Python drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Python driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPysparkConfigLoggingConfig>;
        /**
         * The HCFS URI of the main Python file to use as the driver. Must be a .py file.
         */
        mainPythonFileUri: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure PySpark. Properties that conflict with values set by the Cloud Dataproc API may be overwritten. Can include properties set in `/etc/spark/conf/spark-defaults.conf` and classes in user code.
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobPysparkConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobReference {
        /**
         * The job ID, which must be unique within the project. The job ID is generated by the server upon job submission or provided by the user as a means to perform retries without creating duplicate jobs
         */
        jobId?: pulumi.Input<string>;
    }

    export interface JobScheduling {
        /**
         * Maximum number of times per hour a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed.
         */
        maxFailuresPerHour: pulumi.Input<number>;
        /**
         * Maximum number of times in total a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed.
         */
        maxFailuresTotal: pulumi.Input<number>;
    }

    export interface JobSparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be copied to the working directory of Spark drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparkConfigLoggingConfig>;
        /**
         * The class containing the main method of the driver. Must be in a
         * provided jar or jar that is already on the classpath. Conflicts with `mainJarFileUri`
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of jar file containing
         * the driver jar. Conflicts with `mainClass`
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Spark. Properties that conflict with values set by the Cloud Dataproc API may be overwritten. Can include properties set in `/etc/spark/conf/spark-defaults.conf` and classes in user code.
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparkConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfig {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         *
         * * `logging_config.driver_log_levels`- (Required) The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime logging config of the job
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparksqlConfigLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * The list of SQL queries or statements to execute as part of the job.
         * Conflicts with `queryFileUri`
         */
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfigLoggingConfig {
        /**
         * Optional. The per-package log levels for the driver. This may include 'root' package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'.
         */
        driverLogLevels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobStatus {
        /**
         * Optional job state details, such as an error description if the state is ERROR.
         */
        details?: pulumi.Input<string>;
        /**
         * A state message specifying the overall job state.
         */
        state?: pulumi.Input<string>;
        /**
         * The time when this state was entered.
         */
        stateStartTime?: pulumi.Input<string>;
        /**
         * Additional state information, which includes status reported by the agent.
         */
        substate?: pulumi.Input<string>;
    }

    export interface MetastoreDatabaseIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreDatabaseIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreFederationBackendMetastore {
        /**
         * The type of the backend metastore.
         * Possible values are: `METASTORE_TYPE_UNSPECIFIED`, `DATAPROC_METASTORE`, `BIGQUERY`.
         *
         * - - -
         */
        metastoreType: pulumi.Input<string>;
        /**
         * The relative resource name of the metastore that is being federated. The formats of the relative resource names for the currently supported metastores are listed below: Dataplex: projects/{projectId}/locations/{location}/lakes/{lake_id} BigQuery: projects/{projectId} Dataproc Metastore: projects/{projectId}/locations/{location}/services/{serviceId}
         */
        name: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        rank: pulumi.Input<string>;
    }

    export interface MetastoreFederationIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreFederationIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreServiceEncryptionConfig {
        /**
         * The fully qualified customer provided Cloud KMS key name to use for customer data encryption.
         * Use the following format: `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`
         */
        kmsKey: pulumi.Input<string>;
    }

    export interface MetastoreServiceHiveMetastoreConfig {
        /**
         * A mapping of Hive metastore version to the auxiliary version configuration.
         * When specified, a secondary Hive metastore service is created along with the primary service.
         * All auxiliary versions must be less than the service's primary version.
         * The key is the auxiliary service name and it must match the regular expression a-z?.
         * This means that the first character must be a lowercase letter, and all the following characters must be hyphens, lowercase letters, or digits, except the last character, which cannot be a hyphen.
         * Structure is documented below.
         */
        auxiliaryVersions?: pulumi.Input<pulumi.Input<inputs.dataproc.MetastoreServiceHiveMetastoreConfigAuxiliaryVersion>[]>;
        /**
         * A mapping of Hive metastore configuration key-value pairs to apply to the Hive metastore (configured in hive-site.xml).
         * The mappings override system defaults (some keys cannot be overridden)
         */
        configOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The protocol to use for the metastore service endpoint. If unspecified, defaults to `THRIFT`.
         * Default value is `THRIFT`.
         * Possible values are: `THRIFT`, `GRPC`.
         */
        endpointProtocol?: pulumi.Input<string>;
        /**
         * Information used to configure the Hive metastore service as a service principal in a Kerberos realm.
         * Structure is documented below.
         */
        kerberosConfig?: pulumi.Input<inputs.dataproc.MetastoreServiceHiveMetastoreConfigKerberosConfig>;
        /**
         * The Hive metastore schema version.
         */
        version: pulumi.Input<string>;
    }

    export interface MetastoreServiceHiveMetastoreConfigAuxiliaryVersion {
        /**
         * A mapping of Hive metastore configuration key-value pairs to apply to the auxiliary Hive metastore (configured in hive-site.xml) in addition to the primary version's overrides.
         * If keys are present in both the auxiliary version's overrides and the primary version's overrides, the value from the auxiliary version's overrides takes precedence.
         */
        configOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The identifier for this object. Format specified above.
         */
        key: pulumi.Input<string>;
        /**
         * The Hive metastore version of the auxiliary service. It must be less than the primary Hive metastore service's version.
         */
        version: pulumi.Input<string>;
    }

    export interface MetastoreServiceHiveMetastoreConfigKerberosConfig {
        /**
         * A Kerberos keytab file that can be used to authenticate a service principal with a Kerberos Key Distribution Center (KDC).
         * Structure is documented below.
         */
        keytab: pulumi.Input<inputs.dataproc.MetastoreServiceHiveMetastoreConfigKerberosConfigKeytab>;
        /**
         * A Cloud Storage URI that specifies the path to a krb5.conf file. It is of the form gs://{bucket_name}/path/to/krb5.conf, although the file does not need to be named krb5.conf explicitly.
         */
        krb5ConfigGcsUri: pulumi.Input<string>;
        /**
         * A Kerberos principal that exists in the both the keytab the KDC to authenticate as. A typical principal is of the form "primary/instance@REALM", but there is no exact format.
         */
        principal: pulumi.Input<string>;
    }

    export interface MetastoreServiceHiveMetastoreConfigKerberosConfigKeytab {
        /**
         * The relative resource name of a Secret Manager secret version, in the following form:
         * "projects/{projectNumber}/secrets/{secret_id}/versions/{version_id}".
         */
        cloudSecret: pulumi.Input<string>;
    }

    export interface MetastoreServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreServiceMaintenanceWindow {
        /**
         * The day of week, when the window starts.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeek: pulumi.Input<string>;
        /**
         * The hour of day (0-23) when the window starts.
         */
        hourOfDay: pulumi.Input<number>;
    }

    export interface MetastoreServiceMetadataIntegration {
        /**
         * The integration config for the Data Catalog service.
         * Structure is documented below.
         */
        dataCatalogConfig: pulumi.Input<inputs.dataproc.MetastoreServiceMetadataIntegrationDataCatalogConfig>;
    }

    export interface MetastoreServiceMetadataIntegrationDataCatalogConfig {
        /**
         * Defines whether the metastore metadata should be synced to Data Catalog. The default value is to disable syncing metastore metadata to Data Catalog.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface MetastoreServiceNetworkConfig {
        /**
         * The consumer-side network configuration for the Dataproc Metastore instance.
         * Structure is documented below.
         */
        consumers: pulumi.Input<pulumi.Input<inputs.dataproc.MetastoreServiceNetworkConfigConsumer>[]>;
        /**
         * Enables custom routes to be imported and exported for the Dataproc Metastore service's peered VPC network.
         */
        customRoutesEnabled?: pulumi.Input<boolean>;
    }

    export interface MetastoreServiceNetworkConfigConsumer {
        /**
         * (Output)
         * The URI of the endpoint used to access the metastore service.
         */
        endpointUri?: pulumi.Input<string>;
        /**
         * The subnetwork of the customer project from which an IP address is reserved and used as the Dataproc Metastore service's endpoint.
         * It is accessible to hosts in the subnet and to all hosts in a subnet in the same region and same network.
         * There must be at least one IP address available in the subnet's primary range. The subnet is specified in the following form:
         * `projects/{projectNumber}/regions/{region_id}/subnetworks/{subnetwork_id}
         */
        subnetwork: pulumi.Input<string>;
    }

    export interface MetastoreServiceScalingConfig {
        /**
         * Represents the autoscaling configuration of a metastore service.
         * Structure is documented below.
         */
        autoscalingConfig?: pulumi.Input<inputs.dataproc.MetastoreServiceScalingConfigAutoscalingConfig>;
        /**
         * Metastore instance sizes.
         * Possible values are: `EXTRA_SMALL`, `SMALL`, `MEDIUM`, `LARGE`, `EXTRA_LARGE`.
         */
        instanceSize?: pulumi.Input<string>;
        /**
         * Scaling factor, in increments of 0.1 for values less than 1.0, and increments of 1.0 for values greater than 1.0.
         */
        scalingFactor?: pulumi.Input<number>;
    }

    export interface MetastoreServiceScalingConfigAutoscalingConfig {
        /**
         * Defines whether autoscaling is enabled. The default value is false.
         */
        autoscalingEnabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Output only. The scaling factor of a service with autoscaling enabled.
         */
        autoscalingFactor?: pulumi.Input<number>;
        /**
         * Represents the limit configuration of a metastore service.
         * Structure is documented below.
         */
        limitConfig?: pulumi.Input<inputs.dataproc.MetastoreServiceScalingConfigAutoscalingConfigLimitConfig>;
    }

    export interface MetastoreServiceScalingConfigAutoscalingConfigLimitConfig {
        /**
         * The maximum scaling factor that the service will autoscale to. The default value is 6.0.
         */
        maxScalingFactor?: pulumi.Input<number>;
        /**
         * The minimum scaling factor that the service will autoscale to. The default value is 0.1.
         */
        minScalingFactor?: pulumi.Input<number>;
    }

    export interface MetastoreServiceScheduledBackup {
        /**
         * A Cloud Storage URI of a folder, in the format gs://<bucket_name>/<path_inside_bucket>. A sub-folder <backup_folder> containing backup files will be stored below it.
         */
        backupLocation: pulumi.Input<string>;
        /**
         * The scheduled interval in Cron format, see https://en.wikipedia.org/wiki/Cron The default is empty: scheduled backup is not enabled. Must be specified to enable scheduled backups.
         */
        cronSchedule?: pulumi.Input<string>;
        /**
         * Defines whether the scheduled backup is enabled. The default value is false.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Specifies the time zone to be used when interpreting cronSchedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones), e.g. America/Los_Angeles or Africa/Abidjan. If left unspecified, the default is UTC.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface MetastoreServiceTelemetryConfig {
        /**
         * The output format of the Dataproc Metastore service's logs.
         * Default value is `JSON`.
         * Possible values are: `LEGACY`, `JSON`.
         */
        logFormat?: pulumi.Input<string>;
    }

    export interface MetastoreTableIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MetastoreTableIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WorkflowTemplateEncryptionConfig {
        /**
         * Optional. The Cloud KMS key name to use for encryption.
         */
        kmsKey?: pulumi.Input<string>;
    }

    export interface WorkflowTemplateJob {
        /**
         * Job is a Hadoop job.
         */
        hadoopJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobHadoopJob>;
        /**
         * Job is a Hive job.
         */
        hiveJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobHiveJob>;
        /**
         * The labels to associate with this job. Label keys must be between 1 and 63 characters long, and must conform to the following regular expression: {0,63} No more than 32 labels can be associated with a given job.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Job is a Pig job.
         */
        pigJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPigJob>;
        /**
         * The optional list of prerequisite job step_ids. If not specified, the job will start at the beginning of workflow.
         */
        prerequisiteStepIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Job is a Presto job.
         */
        prestoJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPrestoJob>;
        /**
         * Job is a PySpark job.
         */
        pysparkJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPysparkJob>;
        /**
         * Job scheduling configuration.
         */
        scheduling?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobScheduling>;
        /**
         * Job is a Spark job.
         */
        sparkJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkJob>;
        /**
         * Job is a SparkR job.
         */
        sparkRJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkRJob>;
        /**
         * Job is a SparkSql job.
         */
        sparkSqlJob?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkSqlJob>;
        /**
         * Required. The step id. The id must be unique among all jobs within the template. The step id is used as prefix for job id, as job `goog-dataproc-workflow-step-id` label, and in field from other steps. The id must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). Cannot begin or end with underscore or hyphen. Must consist of between 3 and 50 characters.
         */
        stepId: pulumi.Input<string>;
    }

    export interface WorkflowTemplateJobHadoopJob {
        /**
         * HCFS URIs of archives to be extracted in the working directory of Hadoop drivers and tasks. Supported file types: .jar, .tar, .tar.gz, .tgz, or .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as `-libjars` or `-Dfoo=bar`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS (Hadoop Compatible Filesystem) URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Jar file URIs to add to the CLASSPATHs of the Hadoop driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobHadoopJobLoggingConfig>;
        /**
         * The name of the driver's main class. The jar file containing the class must be in the default CLASSPATH or specified in `jarFileUris`.
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Hadoop. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobHadoopJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobHiveJob {
        /**
         * Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATH of the Hive server and Hadoop MapReduce (MR) tasks. Can contain Hive SerDes and UDFs.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A mapping of property names and values, used to configure Hive. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site.xml, /etc/hive/conf/hive-site.xml, and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains Hive queries.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * A list of queries.
         */
        queryList?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobHiveJobQueryList>;
        /**
         * Mapping of query variable names to values (equivalent to the Hive command: `SET name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobHiveJobQueryList {
        /**
         * Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: "hiveJob": { "queryList": { "queries": } }
         */
        queries: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateJobPigJob {
        /**
         * Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATH of the Pig Client and Hadoop MapReduce (MR) tasks. Can contain Pig UDFs.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPigJobLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Pig. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/hadoop/conf/*-site.xml, /etc/pig/conf/pig.properties, and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains the Pig queries.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * A list of queries.
         */
        queryList?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPigJobQueryList>;
        /**
         * Mapping of query variable names to values (equivalent to the Pig command: `name=`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobPigJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobPigJobQueryList {
        /**
         * Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: "hiveJob": { "queryList": { "queries": } }
         */
        queries: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateJobPrestoJob {
        /**
         * Presto client tags to attach to this query
         */
        clientTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to continue executing queries if a query fails. The default value is `false`. Setting to `true` can be useful when executing independent parallel queries.
         */
        continueOnFailure?: pulumi.Input<boolean>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPrestoJobLoggingConfig>;
        /**
         * The format in which query output will be displayed. See the Presto documentation for supported output formats
         */
        outputFormat?: pulumi.Input<string>;
        /**
         * A mapping of property names to values. Used to set Presto (https://prestodb.io/docs/current/sql/set-session.html) Equivalent to using the --session flag in the Presto CLI
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * A list of queries.
         */
        queryList?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPrestoJobQueryList>;
    }

    export interface WorkflowTemplateJobPrestoJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobPrestoJobQueryList {
        /**
         * Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: "hiveJob": { "queryList": { "queries": } }
         */
        queries: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateJobPysparkJob {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Python driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobPysparkJobLoggingConfig>;
        /**
         * Required. The HCFS URI of the main Python file to use as the driver. Must be a .py file.
         */
        mainPythonFileUri: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure PySpark. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateJobPysparkJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobScheduling {
        /**
         * Maximum number of times per hour a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed. A job may be reported as thrashing if driver exits with non-zero code 4 times within 10 minute window. Maximum value is 10.
         */
        maxFailuresPerHour?: pulumi.Input<number>;
        /**
         * Maximum number of times in total a driver may be restarted as a result of driver exiting with non-zero code before job is reported failed. Maximum value is 240
         */
        maxFailuresTotal?: pulumi.Input<number>;
    }

    export interface WorkflowTemplateJobSparkJob {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of jar files to add to the CLASSPATHs of the Spark driver and tasks.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkJobLoggingConfig>;
        /**
         * The name of the driver's main class. The jar file that contains the class must be in the default CLASSPATH or specified in `jarFileUris`.
         */
        mainClass?: pulumi.Input<string>;
        /**
         * The HCFS URI of the jar file that contains the main class.
         */
        mainJarFileUri?: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure Spark. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkRJob {
        /**
         * HCFS URIs of archives to be extracted into the working directory of each executor. Supported file types: .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The arguments to pass to the driver. Do not include arguments, such as `--conf`, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * HCFS URIs of files to be placed in the working directory of each executor. Useful for naively parallel tasks.
         */
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkRJobLoggingConfig>;
        /**
         * Required. The HCFS URI of the main R file to use as the driver. Must be a .R file.
         */
        mainRFileUri: pulumi.Input<string>;
        /**
         * A mapping of property names to values, used to configure SparkR. Properties that conflict with values set by the Dataproc API may be overwritten. Can include properties set in /etc/spark/conf/spark-defaults.conf and classes in user code.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkRJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkSqlJob {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The runtime log config for job execution.
         */
        loggingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkSqlJobLoggingConfig>;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Dataproc API may be overwritten.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The HCFS URI of the script that contains SQL queries.
         */
        queryFileUri?: pulumi.Input<string>;
        /**
         * A list of queries.
         */
        queryList?: pulumi.Input<inputs.dataproc.WorkflowTemplateJobSparkSqlJobQueryList>;
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: SET `name="value";`).
         */
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkSqlJobLoggingConfig {
        /**
         * The per-package log levels for the driver. This may include "root" package name to configure rootLogger. Examples: 'com.google = FATAL', 'root = INFO', 'org.apache = DEBUG'
         */
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplateJobSparkSqlJobQueryList {
        /**
         * Required. The queries to execute. You do not need to end a query expression with a semicolon. Multiple queries can be specified in one string by separating each with a semicolon. Here is an example of a Dataproc API snippet that uses a QueryList to specify a HiveJob: "hiveJob": { "queryList": { "queries": } }
         */
        queries: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateParameter {
        /**
         * Brief description of the parameter. Must not exceed 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * Required. Paths to all fields that the parameter replaces. A field is allowed to appear in at most one parameter's list of field paths. A field path is similar in syntax to a .sparkJob.args
         */
        fields: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. Parameter name. The parameter name is used as the key, and paired with the parameter value, which are passed to the template when the template is instantiated. The name must contain only capital letters (A-Z), numbers (0-9), and underscores (_), and must not start with a number. The maximum length is 40 characters.
         */
        name: pulumi.Input<string>;
        /**
         * Validation rules to be applied to this parameter's value.
         */
        validation?: pulumi.Input<inputs.dataproc.WorkflowTemplateParameterValidation>;
    }

    export interface WorkflowTemplateParameterValidation {
        /**
         * Validation based on regular expressions.
         */
        regex?: pulumi.Input<inputs.dataproc.WorkflowTemplateParameterValidationRegex>;
        /**
         * Validation based on a list of allowed values.
         */
        values?: pulumi.Input<inputs.dataproc.WorkflowTemplateParameterValidationValues>;
    }

    export interface WorkflowTemplateParameterValidationRegex {
        /**
         * Required. RE2 regular expressions used to validate the parameter's value. The value must match the regex in its entirety (substring matches are not sufficient).
         */
        regexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplateParameterValidationValues {
        /**
         * Required. List of allowed values for the parameter.
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplatePlacement {
        /**
         * A selector that chooses target cluster for jobs based on metadata. The selector is evaluated at the time each job is submitted.
         */
        clusterSelector?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementClusterSelector>;
        /**
         * A cluster that is managed by the workflow.
         */
        managedCluster?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedCluster>;
    }

    export interface WorkflowTemplatePlacementClusterSelector {
        /**
         * Required. The cluster labels. Cluster must have all labels to match.
         */
        clusterLabels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The zone where workflow process executes. This parameter does not affect the selection of the cluster. If unspecified, the zone of the first cluster matching the selector is used.
         */
        zone?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedCluster {
        /**
         * Required. The cluster name prefix. A unique cluster name will be formed by appending a random suffix. The name must contain only lower-case letters (a-z), numbers (0-9), and hyphens (-). Must begin with a letter. Cannot begin or end with hyphen. Must consist of between 2 and 35 characters.
         */
        clusterName: pulumi.Input<string>;
        /**
         * Required. The cluster configuration.
         */
        config: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfig>;
        /**
         * The labels to associate with this cluster. Label keys must be between 1 and 63 characters long, and must conform to the following PCRE regular expression: {0,63} No more than 32 labels can be associated with a given cluster.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfig {
        /**
         * Autoscaling config for the policy associated with the cluster. Cluster does not autoscale if this field is unset.
         */
        autoscalingConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigAutoscalingConfig>;
        /**
         * Encryption settings for the cluster.
         */
        encryptionConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigEncryptionConfig>;
        /**
         * Port/endpoint configuration for this cluster
         */
        endpointConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigEndpointConfig>;
        /**
         * The shared Compute Engine config settings for all instances in a cluster.
         */
        gceClusterConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGceClusterConfig>;
        /**
         * The Kubernetes Engine config for Dataproc clusters deployed to Kubernetes. Setting this is considered mutually exclusive with Compute Engine-based options such as `gceClusterConfig`, `masterConfig`, `workerConfig`, `secondaryWorkerConfig`, and `autoscalingConfig`.
         */
        gkeClusterConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGkeClusterConfig>;
        /**
         * Commands to execute on each node after config is completed. By default, executables are run on master and all worker nodes. You can test a node's `role` metadata to run an executable on a master or worker node, as shown below using `curl` (you can also use `wget`): ROLE=$(curl -H Metadata-Flavor:Google http://metadata/computeMetadata/v1/instance/attributes/dataproc-role) if ; then ... master specific actions ... else ... worker specific actions ... fi
         */
        initializationActions?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigInitializationAction>[]>;
        /**
         * Lifecycle setting for the cluster.
         */
        lifecycleConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigLifecycleConfig>;
        /**
         * The Compute Engine config settings for additional worker instances in a cluster.
         */
        masterConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigMasterConfig>;
        /**
         * Metastore configuration.
         */
        metastoreConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigMetastoreConfig>;
        /**
         * The Compute Engine config settings for additional worker instances in a cluster.
         */
        secondaryWorkerConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfig>;
        /**
         * Security settings for the cluster.
         */
        securityConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecurityConfig>;
        /**
         * The config settings for software inside the cluster.
         */
        softwareConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSoftwareConfig>;
        /**
         * A Cloud Storage bucket used to stage job dependencies, config files, and job driver console output. If you do not specify a staging bucket, Cloud Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's staging bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket (see [Dataproc staging and temp buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
         */
        stagingBucket?: pulumi.Input<string>;
        /**
         * A Cloud Storage bucket used to store ephemeral cluster and jobs data, such as Spark and MapReduce history files. If you do not specify a temp bucket, Dataproc will determine a Cloud Storage location (US, ASIA, or EU) for your cluster's temp bucket according to the Compute Engine zone where your cluster is deployed, and then create and manage this project-level, per-location bucket. The default bucket has a TTL of 90 days, but you can use any TTL (or none) if you specify a bucket.
         */
        tempBucket?: pulumi.Input<string>;
        /**
         * The Compute Engine config settings for additional worker instances in a cluster.
         *
         * - - -
         */
        workerConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigWorkerConfig>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigAutoscalingConfig {
        /**
         * The autoscaling policy used by the cluster. Only resource names including projectid and location (region) are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/` Note that the policy must be in the same project and Dataproc region.
         */
        policy?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigEncryptionConfig {
        /**
         * The Cloud KMS key name to use for PD disk encryption for all instances in the cluster.
         */
        gcePdKmsKeyName?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigEndpointConfig {
        /**
         * If true, enable http access to specific ports on the cluster from external sources. Defaults to false.
         */
        enableHttpPortAccess?: pulumi.Input<boolean>;
        /**
         * Output only. The map of port descriptions to URLs. Will only be populated if enableHttpPortAccess is true.
         */
        httpPorts?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGceClusterConfig {
        /**
         * If true, all instances in the cluster will only have internal IP addresses. By default, clusters are not restricted to internal IP addresses, and will have ephemeral external IP addresses assigned to each instance. This `internalIpOnly` restriction can only be enabled for subnetwork enabled networks, and all off-cluster dependencies must be configured to be accessible without external IP addresses.
         */
        internalIpOnly?: pulumi.Input<boolean>;
        /**
         * The Compute Engine metadata entries to add to all instances (see [About VM metadata](https://cloud.google.com/compute/docs/metadata/overview)).
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Compute Engine network to be used for machine communications. Cannot be specified with subnetwork_uri. If neither `networkUri` nor `subnetworkUri` is specified, the "default" network of the project is used, if it exists. Cannot be a "Custom Subnet Network" (see /regions/global/default` * `default`
         */
        network?: pulumi.Input<string>;
        /**
         * Node Group Affinity for sole-tenant clusters.
         */
        nodeGroupAffinity?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity>;
        /**
         * The type of IPv6 access for a cluster. Possible values: PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED, INHERIT_FROM_SUBNETWORK, OUTBOUND, BIDIRECTIONAL
         */
        privateIpv6GoogleAccess?: pulumi.Input<string>;
        /**
         * Reservation Affinity for consuming Zonal reservation.
         */
        reservationAffinity?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigReservationAffinity>;
        /**
         * The (https://cloud.google.com/compute/docs/access/service-accounts#default_service_account) is used.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * The URIs of service account scopes to be included in Compute Engine instances. The following base set of scopes is always included: * https://www.googleapis.com/auth/cloud.useraccounts.readonly * https://www.googleapis.com/auth/devstorage.read_write * https://www.googleapis.com/auth/logging.write If no scopes are specified, the following defaults are also provided: * https://www.googleapis.com/auth/bigquery * https://www.googleapis.com/auth/bigtable.admin.table * https://www.googleapis.com/auth/bigtable.data * https://www.googleapis.com/auth/devstorage.full_control
         */
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Shielded Instance Config for clusters using [Compute Engine Shielded VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm). Structure defined below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigShieldedInstanceConfig>;
        /**
         * The Compute Engine subnetwork to be used for machine communications. Cannot be specified with network_uri. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects//regions/us-east1/subnetworks/sub0` * `sub0`
         */
        subnetwork?: pulumi.Input<string>;
        /**
         * The Compute Engine tags to add to all instances (see [Manage tags for resources](https://cloud.google.com/compute/docs/tag-resources)).
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The zone where the Compute Engine cluster will be located. On a create request, it is required in the "global" region. If omitted in a non-global Dataproc region, the service will pick a zone in the corresponding Compute Engine region. On a get request, zone will always be present. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/` * `us-central1-f`
         */
        zone?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigNodeGroupAffinity {
        /**
         * Required. The URI of a sole-tenant /zones/us-central1-a/nodeGroups/node-group-1` * `node-group-1`
         */
        nodeGroup: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigReservationAffinity {
        /**
         * Type of reservation to consume Possible values: TYPE_UNSPECIFIED, NO_RESERVATION, ANY_RESERVATION, SPECIFIC_RESERVATION
         */
        consumeReservationType?: pulumi.Input<string>;
        /**
         * Corresponds to the label key of reservation resource.
         */
        key?: pulumi.Input<string>;
        /**
         * Corresponds to the label values of reservation resource.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGceClusterConfigShieldedInstanceConfig {
        /**
         * Defines whether instances have [Integrity Monitoring](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#integrity-monitoring) enabled.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines whether instances have [Secure Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot) enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Defines whether instances have the [vTPM](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#vtpm) enabled.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGkeClusterConfig {
        /**
         * A target for the deployment.
         */
        namespacedGkeDeploymentTarget?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigGkeClusterConfigNamespacedGkeDeploymentTarget>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigGkeClusterConfigNamespacedGkeDeploymentTarget {
        /**
         * A namespace within the GKE cluster to deploy into.
         */
        clusterNamespace?: pulumi.Input<string>;
        /**
         * The target GKE cluster to deploy to. Format: 'projects/{project}/locations/{location}/clusters/{cluster_id}'
         */
        targetGkeCluster?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigInitializationAction {
        /**
         * Required. Cloud Storage URI of executable file.
         */
        executableFile?: pulumi.Input<string>;
        /**
         * Amount of time executable has to complete. Default is 10 minutes (see JSON representation of [JSON Mapping - Language Guide (proto 3)](https://developers.google.com/protocol-buffers/docs/proto3#json)). Cluster creation fails with an explanatory error message (the name of the executable that caused the error and the exceeded timeout period) if the executable is not completed at end of the timeout period.
         */
        executionTimeout?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigLifecycleConfig {
        /**
         * The time when cluster will be auto-deleted (see JSON representation of [JSON Mapping - Language Guide (proto 3)](https://developers.google.com/protocol-buffers/docs/proto3#json)).
         */
        autoDeleteTime?: pulumi.Input<string>;
        /**
         * The lifetime duration of cluster. The cluster will be auto-deleted at the end of this period. Minimum value is 10 minutes; maximum value is 14 days (see JSON representation of [JSON Mapping - Language Guide (proto 3)](https://developers.google.com/protocol-buffers/docs/proto3#json)).
         */
        autoDeleteTtl?: pulumi.Input<string>;
        /**
         * The duration to keep the cluster alive while idling (when no jobs are running). Passing this threshold will cause the cluster to be deleted. Minimum value is 5 minutes; maximum value is 14 days (see JSON representation of [JSON Mapping - Language Guide (proto 3)](https://developers.google.com/protocol-buffers/docs/proto3#json).
         */
        idleDeleteTtl?: pulumi.Input<string>;
        /**
         * Output only. The time when cluster became idle (most recent job finished) and became eligible for deletion due to idleness (see JSON representation of [JSON Mapping - Language Guide (proto 3)](https://developers.google.com/protocol-buffers/docs/proto3#json)).
         */
        idleStartTime?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigMasterConfig {
        /**
         * The Compute Engine accelerator configuration for these instances.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigMasterConfigAccelerator>[]>;
        /**
         * Disk option config settings.
         */
        diskConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigMasterConfigDiskConfig>;
        /**
         * The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.
         */
        image?: pulumi.Input<string>;
        /**
         * Output only. The list of instance names. Dataproc derives the names from `clusterName`, `numInstances`, and the instance group.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Output only. Specifies that this instance group contains preemptible instances.
         */
        isPreemptible?: pulumi.Input<boolean>;
        /**
         * The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/(https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.
         */
        managedGroupConfigs?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigMasterConfigManagedGroupConfig>[]>;
        /**
         * Specifies the minimum cpu platform for the Instance Group. See [Minimum CPU platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * The number of VM instances in the instance group. For master instance groups, must be set to 1.
         */
        numInstances?: pulumi.Input<number>;
        /**
         * Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE
         */
        preemptibility?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigMasterConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.
         */
        acceleratorType?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigMasterConfigDiskConfig {
        /**
         * Size in GB of the boot disk (default is 500GB).
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the boot disk (default is "pd-standard"). Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or "pd-standard" (Persistent Disk Hard Disk Drive).
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and (https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigMasterConfigManagedGroupConfig {
        /**
         * Output only. The name of the Instance Group Manager for this group.
         */
        instanceGroupManagerName?: pulumi.Input<string>;
        /**
         * Output only. The name of the Instance Template used for the Managed Instance Group.
         */
        instanceTemplateName?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigMetastoreConfig {
        /**
         * Required. Resource name of an existing Dataproc Metastore service. Example: * `projects/`
         */
        dataprocMetastoreService: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfig {
        /**
         * Optional. The Compute Engine accelerator configuration for these instances.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigAccelerator>[]>;
        /**
         * Optional. Disk option config settings.
         */
        diskConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig>;
        /**
         * Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[projectId]/global/images/[image-id]` * `projects/[projectId]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[projectId]/global/images/family/[custom-image-family-name]` * `projects/[projectId]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.
         */
        image?: pulumi.Input<string>;
        /**
         * Output only. The list of instance names. Dataproc derives the names from `clusterName`, `numInstances`, and the instance group.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Output only. Specifies that this instance group contains preemptible instances.
         */
        isPreemptible?: pulumi.Input<boolean>;
        /**
         * Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[projectId]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[projectId]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.
         */
        managedGroupConfigs?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigManagedGroupConfig>[]>;
        /**
         * Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc > Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Optional. The number of VM instances in the instance group. For [HA cluster](https://www.terraform.io/dataproc/docs/concepts/configuring-clusters/high-availability) masterConfig groups, **must be set to 3**. For standard cluster masterConfig groups, **must be set to 1**.
         */
        numInstances?: pulumi.Input<number>;
        /**
         * Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE
         */
        preemptibility?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.
         */
        acceleratorType?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigDiskConfig {
        /**
         * Size in GB of the boot disk (default is 500GB).
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the boot disk (default is "pd-standard"). Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or "pd-standard" (Persistent Disk Hard Disk Drive).
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and (https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecondaryWorkerConfigManagedGroupConfig {
        /**
         * Output only. The name of the Instance Group Manager for this group.
         */
        instanceGroupManagerName?: pulumi.Input<string>;
        /**
         * Output only. The name of the Instance Template used for the Managed Instance Group.
         */
        instanceTemplateName?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecurityConfig {
        /**
         * Kerberos related configuration.
         */
        kerberosConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigSecurityConfigKerberosConfig>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSecurityConfigKerberosConfig {
        /**
         * The admin server (IP or hostname) for the remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustAdminServer?: pulumi.Input<string>;
        /**
         * The KDC (IP or hostname) for the remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustKdc?: pulumi.Input<string>;
        /**
         * The remote realm the Dataproc on-cluster KDC will trust, should the user enable cross realm trust.
         */
        crossRealmTrustRealm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the shared password between the on-cluster Kerberos realm and the remote trusted realm, in a cross realm trust relationship.
         */
        crossRealmTrustSharedPassword?: pulumi.Input<string>;
        /**
         * Flag to indicate whether to Kerberize the cluster (default: false). Set this field to true to enable Kerberos on a cluster.
         */
        enableKerberos?: pulumi.Input<boolean>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the master key of the KDC database.
         */
        kdcDbKey?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the password to the user provided key. For the self-signed certificate, this password is generated by Dataproc.
         */
        keyPassword?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of the keystore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
         */
        keystore?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the password to the user provided keystore. For the self-signed certificate, this password is generated by Dataproc.
         */
        keystorePassword?: pulumi.Input<string>;
        /**
         * The uri of the KMS key used to encrypt various sensitive files.
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * The name of the on-cluster Kerberos realm. If not specified, the uppercased domain of hostnames will be the realm.
         */
        realm?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the root principal password.
         */
        rootPrincipalPassword?: pulumi.Input<string>;
        /**
         * The lifetime of the ticket granting ticket, in hours. If not specified, or user specifies 0, then default value 10 will be used.
         */
        tgtLifetimeHours?: pulumi.Input<number>;
        /**
         * The Cloud Storage URI of the truststore file used for SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
         */
        truststore?: pulumi.Input<string>;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing the password to the user provided truststore. For the self-signed certificate, this password is generated by Dataproc.
         */
        truststorePassword?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigSoftwareConfig {
        /**
         * The version of software inside the cluster. It must be one of the supported [Dataproc Versions](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#supported_dataproc_versions), such as "1.2" (including a subminor version, such as "1.2.29"), or the ["preview" version](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#other_versions). If unspecified, it defaults to the latest Debian version.
         */
        imageVersion?: pulumi.Input<string>;
        /**
         * The set of components to activate on the cluster.
         */
        optionalComponents?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The properties to set on daemon config files.
         *
         * Property keys are specified in `prefix:property` format, for example `core:hadoop.tmp.dir`. The following are supported prefixes and their mappings:
         *
         * * capacity-scheduler: `capacity-scheduler.xml`
         * * core: `core-site.xml`
         * * distcp: `distcp-default.xml`
         * * hdfs: `hdfs-site.xml`
         * * hive: `hive-site.xml`
         * * mapred: `mapred-site.xml`
         * * pig: `pig.properties`
         * * spark: `spark-defaults.conf`
         * * yarn: `yarn-site.xml`
         *
         *
         * For more information, see [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigWorkerConfig {
        /**
         * Optional. The Compute Engine accelerator configuration for these instances.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigWorkerConfigAccelerator>[]>;
        /**
         * Optional. Disk option config settings.
         */
        diskConfig?: pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigWorkerConfigDiskConfig>;
        /**
         * Optional. The Compute Engine image resource used for cluster instances. The URI can represent an image or image family. Image examples: * `https://www.googleapis.com/compute/beta/projects/[projectId]/global/images/[image-id]` * `projects/[projectId]/global/images/[image-id]` * `image-id` Image family examples. Dataproc will use the most recent image from the family: * `https://www.googleapis.com/compute/beta/projects/[projectId]/global/images/family/[custom-image-family-name]` * `projects/[projectId]/global/images/family/[custom-image-family-name]` If the URI is unspecified, it will be inferred from `SoftwareConfig.image_version` or the system default.
         */
        image?: pulumi.Input<string>;
        /**
         * Output only. The list of instance names. Dataproc derives the names from `clusterName`, `numInstances`, and the instance group.
         */
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Output only. Specifies that this instance group contains preemptible instances.
         */
        isPreemptible?: pulumi.Input<boolean>;
        /**
         * Optional. The Compute Engine machine type used for cluster instances. A full URL, partial URI, or short name are valid. Examples: * `https://www.googleapis.com/compute/v1/projects/[projectId]/zones/us-east1-a/machineTypes/n1-standard-2` * `projects/[projectId]/zones/us-east1-a/machineTypes/n1-standard-2` * `n1-standard-2` **Auto Zone Exception**: If you are using the Dataproc [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, `n1-standard-2`.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Output only. The config for Compute Engine Instance Group Manager that manages this group. This is only used for preemptible instance groups.
         */
        managedGroupConfigs?: pulumi.Input<pulumi.Input<inputs.dataproc.WorkflowTemplatePlacementManagedClusterConfigWorkerConfigManagedGroupConfig>[]>;
        /**
         * Optional. Specifies the minimum cpu platform for the Instance Group. See [Dataproc > Minimum CPU Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).
         */
        minCpuPlatform?: pulumi.Input<string>;
        /**
         * Optional. The number of VM instances in the instance group. For [HA cluster](https://www.terraform.io/dataproc/docs/concepts/configuring-clusters/high-availability) masterConfig groups, **must be set to 3**. For standard cluster masterConfig groups, **must be set to 1**.
         */
        numInstances?: pulumi.Input<number>;
        /**
         * Optional. Specifies the preemptibility of the instance group. The default value for master and worker groups is `NON_PREEMPTIBLE`. This default cannot be changed. The default value for secondary instances is `PREEMPTIBLE`. Possible values: PREEMPTIBILITY_UNSPECIFIED, NON_PREEMPTIBLE, PREEMPTIBLE
         */
        preemptibility?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigWorkerConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * Full URL, partial URI, or short name of the accelerator type resource to expose to this instance. See (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the accelerator type resource, for example, `nvidia-tesla-k80`.
         */
        acceleratorType?: pulumi.Input<string>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigWorkerConfigDiskConfig {
        /**
         * Size in GB of the boot disk (default is 500GB).
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * Type of the boot disk (default is "pd-standard"). Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or "pd-standard" (Persistent Disk Hard Disk Drive).
         */
        bootDiskType?: pulumi.Input<string>;
        /**
         * Number of attached SSDs, from 0 to 4 (default is 0). If SSDs are not attached, the boot disk is used to store runtime logs and (https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data. If one or more SSDs are attached, this runtime bulk data is spread across them, and the boot disk contains only basic config and installed binaries.
         */
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface WorkflowTemplatePlacementManagedClusterConfigWorkerConfigManagedGroupConfig {
        /**
         * Output only. The name of the Instance Group Manager for this group.
         */
        instanceGroupManagerName?: pulumi.Input<string>;
        /**
         * Output only. The name of the Instance Template used for the Managed Instance Group.
         */
        instanceTemplateName?: pulumi.Input<string>;
    }
}

export namespace datastream {
    export interface ConnectionProfileBigqueryProfile {
    }

    export interface ConnectionProfileForwardSshConnectivity {
        /**
         * Hostname for the SSH tunnel.
         */
        hostname: pulumi.Input<string>;
        /**
         * SSH password.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the SSH tunnel.
         */
        port?: pulumi.Input<number>;
        /**
         * SSH private key.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        privateKey?: pulumi.Input<string>;
        /**
         * Username for the SSH tunnel.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfileGcsProfile {
        /**
         * The Cloud Storage bucket name.
         */
        bucket: pulumi.Input<string>;
        /**
         * The root path inside the Cloud Storage bucket.
         */
        rootPath?: pulumi.Input<string>;
    }

    export interface ConnectionProfileMysqlProfile {
        /**
         * Hostname for the MySQL connection.
         */
        hostname: pulumi.Input<string>;
        /**
         * Password for the MySQL connection.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the MySQL connection.
         */
        port?: pulumi.Input<number>;
        /**
         * A reference to a Secret Manager resource name storing the user's password.
         */
        secretManagerStoredPassword?: pulumi.Input<string>;
        /**
         * SSL configuration for the MySQL connection.
         * Structure is documented below.
         */
        sslConfig?: pulumi.Input<inputs.datastream.ConnectionProfileMysqlProfileSslConfig>;
        /**
         * Username for the MySQL connection.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfileMysqlProfileSslConfig {
        /**
         * PEM-encoded certificate of the CA that signed the source database
         * server's certificate.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates whether the clientKey field is set.
         */
        caCertificateSet?: pulumi.Input<boolean>;
        /**
         * PEM-encoded certificate that will be used by the replica to
         * authenticate against the source database server. If this field
         * is used then the 'clientKey' and the 'caCertificate' fields are
         * mandatory.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates whether the clientCertificate field is set.
         */
        clientCertificateSet?: pulumi.Input<boolean>;
        /**
         * PEM-encoded private key associated with the Client Certificate.
         * If this field is used then the 'client_certificate' and the
         * 'ca_certificate' fields are mandatory.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates whether the clientKey field is set.
         */
        clientKeySet?: pulumi.Input<boolean>;
    }

    export interface ConnectionProfileOracleProfile {
        /**
         * Connection string attributes
         */
        connectionAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Database for the Oracle connection.
         */
        databaseService: pulumi.Input<string>;
        /**
         * Hostname for the Oracle connection.
         */
        hostname: pulumi.Input<string>;
        /**
         * Password for the Oracle connection.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the Oracle connection.
         */
        port?: pulumi.Input<number>;
        /**
         * A reference to a Secret Manager resource name storing the user's password.
         */
        secretManagerStoredPassword?: pulumi.Input<string>;
        /**
         * Username for the Oracle connection.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfilePostgresqlProfile {
        /**
         * Database for the PostgreSQL connection.
         */
        database: pulumi.Input<string>;
        /**
         * Hostname for the PostgreSQL connection.
         */
        hostname: pulumi.Input<string>;
        /**
         * Password for the PostgreSQL connection.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the PostgreSQL connection.
         */
        port?: pulumi.Input<number>;
        /**
         * A reference to a Secret Manager resource name storing the user's password.
         */
        secretManagerStoredPassword?: pulumi.Input<string>;
        /**
         * Username for the PostgreSQL connection.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionProfilePrivateConnectivity {
        /**
         * A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
         */
        privateConnection: pulumi.Input<string>;
    }

    export interface ConnectionProfileSalesforceProfile {
        /**
         * Domain for the Salesforce Org.
         */
        domain: pulumi.Input<string>;
        /**
         * OAuth credentials to use for Salesforce authentication.
         * Structure is documented below.
         */
        oauth2ClientCredentials?: pulumi.Input<inputs.datastream.ConnectionProfileSalesforceProfileOauth2ClientCredentials>;
        /**
         * User credentials to use for Salesforce authentication.
         * Structure is documented below.
         */
        userCredentials?: pulumi.Input<inputs.datastream.ConnectionProfileSalesforceProfileUserCredentials>;
    }

    export interface ConnectionProfileSalesforceProfileOauth2ClientCredentials {
        /**
         * Client ID to use for authentication.
         */
        clientId?: pulumi.Input<string>;
        /**
         * Client secret to use for authentication.
         */
        clientSecret?: pulumi.Input<string>;
        /**
         * A reference to a Secret Manager resource name storing the client secret.
         */
        secretManagerStoredClientSecret?: pulumi.Input<string>;
    }

    export interface ConnectionProfileSalesforceProfileUserCredentials {
        /**
         * Password of the user.
         */
        password?: pulumi.Input<string>;
        /**
         * A reference to a Secret Manager resource name storing the user's password.
         */
        secretManagerStoredPassword?: pulumi.Input<string>;
        /**
         * A reference to a Secret Manager resource name storing the user's security token.
         *
         * <a name="nestedSalesforceProfileOauth2ClientCredentials"></a>The `oauth2ClientCredentials` block supports:
         */
        secretManagerStoredSecurityToken?: pulumi.Input<string>;
        /**
         * Security token of the user.
         */
        securityToken?: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionProfileSqlServerProfile {
        /**
         * Database for the SQL Server connection.
         */
        database: pulumi.Input<string>;
        /**
         * Hostname for the SQL Server connection.
         */
        hostname: pulumi.Input<string>;
        /**
         * Password for the SQL Server connection.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * Port for the SQL Server connection.
         */
        port?: pulumi.Input<number>;
        /**
         * A reference to a Secret Manager resource name storing the user's password.
         */
        secretManagerStoredPassword?: pulumi.Input<string>;
        /**
         * Username for the SQL Server connection.
         */
        username: pulumi.Input<string>;
    }

    export interface PrivateConnectionError {
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A message containing more information about the error that occurred.
         */
        message?: pulumi.Input<string>;
    }

    export interface PrivateConnectionVpcPeeringConfig {
        /**
         * A free subnet for peering. (CIDR of /29)
         *
         * - - -
         */
        subnet: pulumi.Input<string>;
        /**
         * Fully qualified name of the VPC that Datastream will peer to.
         * Format: projects/{project}/global/{networks}/{name}
         */
        vpc: pulumi.Input<string>;
    }

    export interface StreamBackfillAll {
        /**
         * MySQL data source objects to avoid backfilling.
         * Structure is documented below.
         */
        mysqlExcludedObjects?: pulumi.Input<inputs.datastream.StreamBackfillAllMysqlExcludedObjects>;
        /**
         * PostgreSQL data source objects to avoid backfilling.
         * Structure is documented below.
         */
        oracleExcludedObjects?: pulumi.Input<inputs.datastream.StreamBackfillAllOracleExcludedObjects>;
        /**
         * PostgreSQL data source objects to avoid backfilling.
         * Structure is documented below.
         */
        postgresqlExcludedObjects?: pulumi.Input<inputs.datastream.StreamBackfillAllPostgresqlExcludedObjects>;
        /**
         * Salesforce objects to avoid backfilling.
         * Structure is documented below.
         */
        salesforceExcludedObjects?: pulumi.Input<inputs.datastream.StreamBackfillAllSalesforceExcludedObjects>;
        /**
         * SQL Server data source objects to avoid backfilling.
         * Structure is documented below.
         */
        sqlServerExcludedObjects?: pulumi.Input<inputs.datastream.StreamBackfillAllSqlServerExcludedObjects>;
    }

    export interface StreamBackfillAllMysqlExcludedObjects {
        /**
         * MySQL databases on the server
         * Structure is documented below.
         */
        mysqlDatabases: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllMysqlExcludedObjectsMysqlDatabase>[]>;
    }

    export interface StreamBackfillAllMysqlExcludedObjectsMysqlDatabase {
        /**
         * Database name.
         */
        database: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        mysqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable>[]>;
    }

    export interface StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable {
        /**
         * MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        mysqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn {
        /**
         * Column collation.
         */
        collation?: pulumi.Input<string>;
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The MySQL data type. Full data types list can be found here:
         * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
    }

    export interface StreamBackfillAllOracleExcludedObjects {
        /**
         * Oracle schemas/databases in the database server
         * Structure is documented below.
         */
        oracleSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllOracleExcludedObjectsOracleSchema>[]>;
    }

    export interface StreamBackfillAllOracleExcludedObjectsOracleSchema {
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        oracleTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable>[]>;
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable {
        /**
         * Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        oracleColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The Oracle data type. Full data types list can be found here:
         * https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column encoding.
         */
        encoding?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamBackfillAllPostgresqlExcludedObjects {
        /**
         * PostgreSQL schemas on the server
         * Structure is documented below.
         */
        postgresqlSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema>[]>;
    }

    export interface StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema {
        /**
         * Tables in the schema.
         * Structure is documented below.
         */
        postgresqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable>[]>;
        /**
         * Database name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable {
        /**
         * PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        postgresqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The PostgreSQL data type. Full data types list can be found here:
         * https://www.postgresql.org/docs/current/datatype.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamBackfillAllSalesforceExcludedObjects {
        /**
         * Salesforce objects in Salesforce Org.
         * Structure is documented below.
         */
        objects: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllSalesforceExcludedObjectsObject>[]>;
    }

    export interface StreamBackfillAllSalesforceExcludedObjectsObject {
        /**
         * Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
         * Structure is documented below.
         */
        fields?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllSalesforceExcludedObjectsObjectField>[]>;
        /**
         * Name of object in Salesforce Org.
         */
        objectName?: pulumi.Input<string>;
    }

    export interface StreamBackfillAllSalesforceExcludedObjectsObjectField {
        /**
         * Field name.
         */
        name?: pulumi.Input<string>;
    }

    export interface StreamBackfillAllSqlServerExcludedObjects {
        /**
         * SQL Server schemas/databases in the database server
         * Structure is documented below.
         */
        schemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllSqlServerExcludedObjectsSchema>[]>;
    }

    export interface StreamBackfillAllSqlServerExcludedObjectsSchema {
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        tables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllSqlServerExcludedObjectsSchemaTable>[]>;
    }

    export interface StreamBackfillAllSqlServerExcludedObjectsSchemaTable {
        /**
         * SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        columns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The SQL Server data type. Full data types list can be found here:
         * https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamBackfillNone {
    }

    export interface StreamDestinationConfig {
        /**
         * A configuration for how data should be loaded to Google BigQuery.
         * Structure is documented below.
         */
        bigqueryDestinationConfig?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfig>;
        /**
         * Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
         */
        destinationConnectionProfile: pulumi.Input<string>;
        /**
         * A configuration for how data should be loaded to Cloud Storage.
         * Structure is documented below.
         */
        gcsDestinationConfig?: pulumi.Input<inputs.datastream.StreamDestinationConfigGcsDestinationConfig>;
    }

    export interface StreamDestinationConfigBigqueryDestinationConfig {
        /**
         * AppendOnly mode defines that the stream of changes (INSERT, UPDATE-INSERT, UPDATE-DELETE and DELETE
         * events) to a source table will be written to the destination Google BigQuery table, retaining the
         * historical state of the data.
         */
        appendOnly?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigAppendOnly>;
        /**
         * BigLake Managed Tables configuration for BigQuery streams.
         * Structure is documented below.
         */
        blmtConfig?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigBlmtConfig>;
        /**
         * The guaranteed data freshness (in seconds) when querying tables created by the stream.
         * Editing this field will only affect new tables created in the future, but existing tables
         * will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
         */
        dataFreshness?: pulumi.Input<string>;
        /**
         * Merge mode defines that all changes to a table will be merged at the destination Google BigQuery
         * table. This is the default write mode. When selected, BigQuery reflects the way the data is stored
         * in the source database. With Merge mode, no historical record of the change events is kept.
         */
        merge?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigMerge>;
        /**
         * A single target dataset to which all data will be streamed.
         * Structure is documented below.
         */
        singleTargetDataset?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset>;
        /**
         * Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
         * Structure is documented below.
         */
        sourceHierarchyDatasets?: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets>;
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigAppendOnly {
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigBlmtConfig {
        /**
         * The Cloud Storage bucket name.
         */
        bucket: pulumi.Input<string>;
        /**
         * The bigquery connection. Format: `{project}.{location}.{name}`
         */
        connectionName: pulumi.Input<string>;
        /**
         * The file format.
         */
        fileFormat: pulumi.Input<string>;
        /**
         * The root path inside the Cloud Storage bucket.
         *
         * - - -
         */
        rootPath?: pulumi.Input<string>;
        /**
         * The table format.
         */
        tableFormat: pulumi.Input<string>;
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigMerge {
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset {
        /**
         * Dataset ID in the format projects/{project}/datasets/{dataset_id} or
         * {project}:{dataset_id}
         */
        datasetId: pulumi.Input<string>;
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets {
        /**
         * Dataset template used for dynamic dataset creation.
         * Structure is documented below.
         */
        datasetTemplate: pulumi.Input<inputs.datastream.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate>;
    }

    export interface StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate {
        /**
         * If supplied, every created dataset will have its name prefixed by the provided value.
         * The prefix and name will be separated by an underscore. i.e. _.
         */
        datasetIdPrefix?: pulumi.Input<string>;
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
         * table. The BigQuery Service Account associated with your project requires access to this
         * encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
         * See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * The geographic location where the dataset should reside.
         * See https://cloud.google.com/bigquery/docs/locations for supported locations.
         */
        location: pulumi.Input<string>;
    }

    export interface StreamDestinationConfigGcsDestinationConfig {
        /**
         * AVRO file format configuration.
         */
        avroFileFormat?: pulumi.Input<inputs.datastream.StreamDestinationConfigGcsDestinationConfigAvroFileFormat>;
        /**
         * The maximum duration for which new events are added before a file is closed and a new file is created.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
         */
        fileRotationInterval?: pulumi.Input<string>;
        /**
         * The maximum file size to be saved in the bucket.
         */
        fileRotationMb?: pulumi.Input<number>;
        /**
         * JSON file format configuration.
         * Structure is documented below.
         */
        jsonFileFormat?: pulumi.Input<inputs.datastream.StreamDestinationConfigGcsDestinationConfigJsonFileFormat>;
        /**
         * Path inside the Cloud Storage bucket to write data to.
         */
        path?: pulumi.Input<string>;
    }

    export interface StreamDestinationConfigGcsDestinationConfigAvroFileFormat {
    }

    export interface StreamDestinationConfigGcsDestinationConfigJsonFileFormat {
        /**
         * Compression of the loaded JSON file.
         * Possible values are: `NO_COMPRESSION`, `GZIP`.
         */
        compression?: pulumi.Input<string>;
        /**
         * The schema file format along JSON data files.
         * Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
         */
        schemaFileFormat?: pulumi.Input<string>;
    }

    export interface StreamSourceConfig {
        /**
         * MySQL data source configuration.
         * Structure is documented below.
         */
        mysqlSourceConfig?: pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfig>;
        /**
         * MySQL data source configuration.
         * Structure is documented below.
         */
        oracleSourceConfig?: pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfig>;
        /**
         * PostgreSQL data source configuration.
         * Structure is documented below.
         */
        postgresqlSourceConfig?: pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfig>;
        /**
         * Salesforce data source configuration.
         * Structure is documented below.
         */
        salesforceSourceConfig?: pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfig>;
        /**
         * Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
         */
        sourceConnectionProfile: pulumi.Input<string>;
        /**
         * SQL Server data source configuration.
         * Structure is documented below.
         */
        sqlServerSourceConfig?: pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfig>;
    }

    export interface StreamSourceConfigMysqlSourceConfig {
        /**
         * CDC reader reads from binary logs replication cdc method.
         */
        binaryLogPosition?: pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigBinaryLogPosition>;
        /**
         * MySQL objects to exclude from the stream.
         * Structure is documented below.
         */
        excludeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigExcludeObjects>;
        /**
         * CDC reader reads from gtid based replication.
         */
        gtid?: pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigGtid>;
        /**
         * MySQL objects to retrieve from the source.
         * Structure is documented below.
         */
        includeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigIncludeObjects>;
        /**
         * Maximum number of concurrent backfill tasks. The number should be non negative.
         * If not set (or set to 0), the system's default value will be used.
         */
        maxConcurrentBackfillTasks?: pulumi.Input<number>;
        /**
         * Maximum number of concurrent CDC tasks. The number should be non negative.
         * If not set (or set to 0), the system's default value will be used.
         */
        maxConcurrentCdcTasks?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigMysqlSourceConfigBinaryLogPosition {
    }

    export interface StreamSourceConfigMysqlSourceConfigExcludeObjects {
        /**
         * MySQL databases on the server
         * Structure is documented below.
         */
        mysqlDatabases: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase>[]>;
    }

    export interface StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase {
        /**
         * Database name.
         */
        database: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        mysqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable>[]>;
    }

    export interface StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable {
        /**
         * MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        mysqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn {
        /**
         * Column collation.
         */
        collation?: pulumi.Input<string>;
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The MySQL data type. Full data types list can be found here:
         * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
    }

    export interface StreamSourceConfigMysqlSourceConfigGtid {
    }

    export interface StreamSourceConfigMysqlSourceConfigIncludeObjects {
        /**
         * MySQL databases on the server
         * Structure is documented below.
         */
        mysqlDatabases: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase>[]>;
    }

    export interface StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase {
        /**
         * Database name.
         */
        database: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        mysqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable>[]>;
    }

    export interface StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable {
        /**
         * MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        mysqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn {
        /**
         * Column collation.
         */
        collation?: pulumi.Input<string>;
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The MySQL data type. Full data types list can be found here:
         * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
    }

    export interface StreamSourceConfigOracleSourceConfig {
        /**
         * Configuration to drop large object values.
         */
        dropLargeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigDropLargeObjects>;
        /**
         * Oracle objects to exclude from the stream.
         * Structure is documented below.
         */
        excludeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigExcludeObjects>;
        /**
         * Oracle objects to retrieve from the source.
         * Structure is documented below.
         */
        includeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigIncludeObjects>;
        /**
         * Maximum number of concurrent backfill tasks. The number should be non negative.
         * If not set (or set to 0), the system's default value will be used.
         */
        maxConcurrentBackfillTasks?: pulumi.Input<number>;
        /**
         * Maximum number of concurrent CDC tasks. The number should be non negative.
         * If not set (or set to 0), the system's default value will be used.
         */
        maxConcurrentCdcTasks?: pulumi.Input<number>;
        /**
         * Configuration to drop large object values.
         */
        streamLargeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigStreamLargeObjects>;
    }

    export interface StreamSourceConfigOracleSourceConfigDropLargeObjects {
    }

    export interface StreamSourceConfigOracleSourceConfigExcludeObjects {
        /**
         * Oracle schemas/databases in the database server
         * Structure is documented below.
         */
        oracleSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema>[]>;
    }

    export interface StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema {
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        oracleTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable>[]>;
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable {
        /**
         * Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        oracleColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The Oracle data type. Full data types list can be found here:
         * https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column encoding.
         */
        encoding?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigOracleSourceConfigIncludeObjects {
        /**
         * Oracle schemas/databases in the database server
         * Structure is documented below.
         */
        oracleSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema>[]>;
    }

    export interface StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema {
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        oracleTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable>[]>;
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable {
        /**
         * Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        oracleColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The Oracle data type. Full data types list can be found here:
         * https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column encoding.
         */
        encoding?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigOracleSourceConfigStreamLargeObjects {
    }

    export interface StreamSourceConfigPostgresqlSourceConfig {
        /**
         * PostgreSQL objects to exclude from the stream.
         * Structure is documented below.
         */
        excludeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigExcludeObjects>;
        /**
         * PostgreSQL objects to retrieve from the source.
         * Structure is documented below.
         */
        includeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigIncludeObjects>;
        /**
         * Maximum number of concurrent backfill tasks. The number should be non
         * negative. If not set (or set to 0), the system's default value will be used.
         */
        maxConcurrentBackfillTasks?: pulumi.Input<number>;
        /**
         * The name of the publication that includes the set of all tables
         * that are defined in the stream's include_objects.
         */
        publication: pulumi.Input<string>;
        /**
         * The name of the logical replication slot that's configured with
         * the pgoutput plugin.
         */
        replicationSlot: pulumi.Input<string>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigExcludeObjects {
        /**
         * PostgreSQL schemas on the server
         * Structure is documented below.
         */
        postgresqlSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema>[]>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema {
        /**
         * Tables in the schema.
         * Structure is documented below.
         */
        postgresqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable>[]>;
        /**
         * Database name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable {
        /**
         * PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        postgresqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The PostgreSQL data type. Full data types list can be found here:
         * https://www.postgresql.org/docs/current/datatype.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigIncludeObjects {
        /**
         * PostgreSQL schemas on the server
         * Structure is documented below.
         */
        postgresqlSchemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema>[]>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema {
        /**
         * Tables in the schema.
         * Structure is documented below.
         */
        postgresqlTables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable>[]>;
        /**
         * Database name.
         */
        schema: pulumi.Input<string>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable {
        /**
         * PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        postgresqlColumns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The PostgreSQL data type. Full data types list can be found here:
         * https://www.postgresql.org/docs/current/datatype.html
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigSalesforceSourceConfig {
        /**
         * Salesforce objects to exclude from the stream.
         * Structure is documented below.
         */
        excludeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigExcludeObjects>;
        /**
         * Salesforce objects to retrieve from the source.
         * Structure is documented below.
         */
        includeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigIncludeObjects>;
        /**
         * Salesforce objects polling interval. The interval at which new changes will be polled for each object. The duration must be between 5 minutes and 24 hours.
         */
        pollingInterval: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigExcludeObjects {
        /**
         * Salesforce objects in data source.
         * Structure is documented below.
         */
        objects: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject>[]>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject {
        /**
         * Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
         * Structure is documented below.
         */
        fields?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField>[]>;
        /**
         * Name of object in Salesforce Org.
         */
        objectName?: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField {
        /**
         * Field name.
         */
        name?: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigIncludeObjects {
        /**
         * Salesforce objects in Salesforce Org.
         * Structure is documented below.
         */
        objects: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject>[]>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject {
        /**
         * Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
         * Structure is documented below.
         */
        fields?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField>[]>;
        /**
         * Name of object in Salesforce Org.
         */
        objectName?: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField {
        /**
         * Field name.
         */
        name?: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSqlServerSourceConfig {
        /**
         * CDC reader reads from change tables.
         */
        changeTables?: pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigChangeTables>;
        /**
         * SQL Server objects to exclude from the stream.
         * Structure is documented below.
         */
        excludeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigExcludeObjects>;
        /**
         * SQL Server objects to retrieve from the source.
         * Structure is documented below.
         */
        includeObjects?: pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigIncludeObjects>;
        /**
         * Max concurrent backfill tasks.
         */
        maxConcurrentBackfillTasks?: pulumi.Input<number>;
        /**
         * Max concurrent CDC tasks.
         */
        maxConcurrentCdcTasks?: pulumi.Input<number>;
        /**
         * CDC reader reads from transaction logs.
         */
        transactionLogs?: pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigTransactionLogs>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigChangeTables {
    }

    export interface StreamSourceConfigSqlServerSourceConfigExcludeObjects {
        /**
         * SQL Server schemas/databases in the database server
         * Structure is documented below.
         */
        schemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema>[]>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema {
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        tables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable>[]>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable {
        /**
         * SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        columns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The SQL Server data type. Full data types list can be found here:
         * https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigIncludeObjects {
        /**
         * SQL Server schemas/databases in the database server
         * Structure is documented below.
         */
        schemas: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema>[]>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema {
        /**
         * Schema name.
         */
        schema: pulumi.Input<string>;
        /**
         * Tables in the database.
         * Structure is documented below.
         */
        tables?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable>[]>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable {
        /**
         * SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
         * Structure is documented below.
         */
        columns?: pulumi.Input<pulumi.Input<inputs.datastream.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn>[]>;
        /**
         * Table name.
         */
        table: pulumi.Input<string>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn {
        /**
         * Column name.
         */
        column?: pulumi.Input<string>;
        /**
         * The SQL Server data type. Full data types list can be found here:
         * https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
         */
        dataType?: pulumi.Input<string>;
        /**
         * (Output)
         * Column length.
         */
        length?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column can accept a null value.
         */
        nullable?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ordinal position of the column in the table.
         */
        ordinalPosition?: pulumi.Input<number>;
        /**
         * (Output)
         * Column precision.
         */
        precision?: pulumi.Input<number>;
        /**
         * (Output)
         * Whether or not the column represents a primary key.
         */
        primaryKey?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Column scale.
         */
        scale?: pulumi.Input<number>;
    }

    export interface StreamSourceConfigSqlServerSourceConfigTransactionLogs {
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        /**
         * Key for label.
         */
        key?: pulumi.Input<string>;
        /**
         * Value of label.
         */
        value?: pulumi.Input<string>;
    }

    export interface DeploymentTarget {
        /**
         * The root configuration file to use for this deployment.
         * Structure is documented below.
         */
        config: pulumi.Input<inputs.deploymentmanager.DeploymentTargetConfig>;
        /**
         * Specifies import files for this configuration. This can be
         * used to import templates or other files. For example, you might
         * import a text file in order to use the file in a template.
         * Structure is documented below.
         */
        imports?: pulumi.Input<pulumi.Input<inputs.deploymentmanager.DeploymentTargetImport>[]>;
    }

    export interface DeploymentTargetConfig {
        /**
         * The full YAML contents of your configuration file.
         */
        content: pulumi.Input<string>;
    }

    export interface DeploymentTargetImport {
        /**
         * The full contents of the template that you want to import.
         */
        content?: pulumi.Input<string>;
        /**
         * The name of the template to import, as declared in the YAML
         * configuration.
         *
         * - - -
         */
        name?: pulumi.Input<string>;
    }
}

export namespace developerconnect {
    export interface AccountConnectorProviderOauthConfig {
        /**
         * Required. User selected scopes to apply to the Oauth config
         * In the event of changing scopes, user records under AccountConnector will
         * be deleted and users will re-auth again.
         */
        scopes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of providers that are owned by Developer Connect.
         * Possible values:
         * GITHUB
         * GITLAB
         * GOOGLE
         * SENTRY
         * ROVO
         * NEW_RELIC
         * DATASTAX
         */
        systemProviderId?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketCloudConfig {
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionBitbucketCloudConfigAuthorizerCredential>;
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionBitbucketCloudConfigReadAuthorizerCredential>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook
         * events, formatted as `projects/*&#47;secrets/*&#47;versions/*`. This is used to
         * validate and create webhooks.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
        /**
         * Required. The Bitbucket Cloud Workspace ID to be connected to Google Cloud Platform.
         */
        workspace: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketCloudConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketCloudConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfig {
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionBitbucketDataCenterConfigAuthorizerCredential>;
        /**
         * Required. The URI of the Bitbucket Data Center host this connection is for.
         */
        hostUri: pulumi.Input<string>;
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionBitbucketDataCenterConfigReadAuthorizerCredential>;
        /**
         * (Output)
         * Output only. Version of the Bitbucket Data Center server running on the `hostUri`.
         */
        serverVersion?: pulumi.Input<string>;
        /**
         * ServiceDirectoryConfig represents Service Directory configuration for a
         * connection.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.developerconnect.ConnectionBitbucketDataCenterConfigServiceDirectoryConfig>;
        /**
         * Optional. SSL certificate authority to trust when making requests to Bitbucket Data
         * Center.
         */
        sslCaCertificate?: pulumi.Input<string>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook
         * events, formatted as `projects/*&#47;secrets/*&#47;versions/*`. This is used to
         * validate webhooks.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionBitbucketDataCenterConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name.
         * Format:
         * projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionCryptoKeyConfig {
        /**
         * Required. The name of the key which is used to encrypt/decrypt customer data. For key
         * in Cloud KMS, the key should be in the format of
         * `projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*`.
         */
        keyReference: pulumi.Input<string>;
    }

    export interface ConnectionGithubConfig {
        /**
         * Optional. GitHub App installation id.
         */
        appInstallationId?: pulumi.Input<string>;
        /**
         * Represents an OAuth token of the account that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        authorizerCredential?: pulumi.Input<inputs.developerconnect.ConnectionGithubConfigAuthorizerCredential>;
        /**
         * Required. Immutable. The GitHub Application that was installed to the GitHub user or
         * organization.
         * Possible values:
         * GIT_HUB_APP_UNSPECIFIED
         * DEVELOPER_CONNECT
         * FIREBASE
         */
        githubApp: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The URI to navigate to in order to manage the installation associated
         * with this GitHubConfig.
         */
        installationUri?: pulumi.Input<string>;
    }

    export interface ConnectionGithubConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the OAuth token that authorizes
         * the connection. Format: `projects/*&#47;secrets/*&#47;versions/*`.
         */
        oauthTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGithubEnterpriseConfig {
        /**
         * Optional. ID of the GitHub App created from the manifest.
         */
        appId?: pulumi.Input<string>;
        /**
         * Optional. ID of the installation of the GitHub App.
         */
        appInstallationId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The URL-friendly name of the GitHub App.
         */
        appSlug?: pulumi.Input<string>;
        /**
         * Required. The URI of the GitHub Enterprise host this connection is for.
         */
        hostUri: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The URI to navigate to in order to manage the installation associated
         * with this GitHubEnterpriseConfig.
         */
        installationUri?: pulumi.Input<string>;
        /**
         * Optional. SecretManager resource containing the private key of the GitHub App,
         * formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        privateKeySecretVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. GitHub Enterprise version installed at the host_uri.
         */
        serverVersion?: pulumi.Input<string>;
        /**
         * ServiceDirectoryConfig represents Service Directory configuration for a
         * connection.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.developerconnect.ConnectionGithubEnterpriseConfigServiceDirectoryConfig>;
        /**
         * Optional. SSL certificate to use for requests to GitHub Enterprise.
         */
        sslCaCertificate?: pulumi.Input<string>;
        /**
         * Optional. SecretManager resource containing the webhook secret of the GitHub App,
         * formatted as `projects/*&#47;secrets/*&#47;versions/*`.
         */
        webhookSecretSecretVersion?: pulumi.Input<string>;
    }

    export interface ConnectionGithubEnterpriseConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name.
         * Format:
         * projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfig {
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionGitlabConfigAuthorizerCredential>;
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionGitlabConfigReadAuthorizerCredential>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret of a GitLab project,
         * formatted as `projects/*&#47;secrets/*&#47;versions/*`. This is used to validate
         * webhooks.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabEnterpriseConfig {
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        authorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionGitlabEnterpriseConfigAuthorizerCredential>;
        /**
         * Required. The URI of the GitLab Enterprise host this connection is for.
         */
        hostUri: pulumi.Input<string>;
        /**
         * Represents a personal access token that authorized the Connection,
         * and associated metadata.
         * Structure is documented below.
         */
        readAuthorizerCredential: pulumi.Input<inputs.developerconnect.ConnectionGitlabEnterpriseConfigReadAuthorizerCredential>;
        /**
         * (Output)
         * Output only. Version of the GitLab Enterprise server running on the `hostUri`.
         */
        serverVersion?: pulumi.Input<string>;
        /**
         * ServiceDirectoryConfig represents Service Directory configuration for a
         * connection.
         * Structure is documented below.
         */
        serviceDirectoryConfig?: pulumi.Input<inputs.developerconnect.ConnectionGitlabEnterpriseConfigServiceDirectoryConfig>;
        /**
         * Optional. SSL Certificate Authority certificate to use for requests to GitLab
         * Enterprise instance.
         */
        sslCaCertificate?: pulumi.Input<string>;
        /**
         * Required. Immutable. SecretManager resource containing the webhook secret of a GitLab project,
         * formatted as `projects/*&#47;secrets/*&#47;versions/*`. This is used to validate
         * webhooks.
         */
        webhookSecretSecretVersion: pulumi.Input<string>;
    }

    export interface ConnectionGitlabEnterpriseConfigAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabEnterpriseConfigReadAuthorizerCredential {
        /**
         * Required. A SecretManager resource containing the user token that authorizes
         * the Developer Connect connection. Format:
         * `projects/*&#47;secrets/*&#47;versions/*`.
         */
        userTokenSecretVersion: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The username associated with this token.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionGitlabEnterpriseConfigServiceDirectoryConfig {
        /**
         * Required. The Service Directory service name.
         * Format:
         * projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
         */
        service: pulumi.Input<string>;
    }

    export interface ConnectionInstallationState {
        /**
         * Output only. Link to follow for next action. Empty string if the installation is already
         * complete.
         */
        actionUri?: pulumi.Input<string>;
        /**
         * Output only. Message of what the user should do next to continue the installation.
         * Empty string if the installation is already complete.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Current step of the installation process.
         * Possible values:
         * STAGE_UNSPECIFIED
         * PENDING_CREATE_APP
         * PENDING_USER_OAUTH
         * PENDING_INSTALL_APP
         * COMPLETE
         */
        stage?: pulumi.Input<string>;
    }
}

export namespace diagflow {
    export interface CxAgentAdvancedSettings {
        /**
         * If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * Structure is documented below.
         */
        audioExportGcsDestination?: pulumi.Input<inputs.diagflow.CxAgentAdvancedSettingsAudioExportGcsDestination>;
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxAgentAdvancedSettingsDtmfSettings>;
        /**
         * Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
         * * Agent level
         * Structure is documented below.
         */
        loggingSettings?: pulumi.Input<inputs.diagflow.CxAgentAdvancedSettingsLoggingSettings>;
        /**
         * Settings for speech to text detection. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        speechSettings?: pulumi.Input<inputs.diagflow.CxAgentAdvancedSettingsSpeechSettings>;
    }

    export interface CxAgentAdvancedSettingsAudioExportGcsDestination {
        /**
         * The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
         * Format: gs://bucket/object-name-or-prefix
         */
        uri?: pulumi.Input<string>;
    }

    export interface CxAgentAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxAgentAdvancedSettingsLoggingSettings {
        /**
         * Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
         */
        enableConsentBasedRedaction?: pulumi.Input<boolean>;
        /**
         * Enables DF Interaction logging.
         */
        enableInteractionLogging?: pulumi.Input<boolean>;
        /**
         * Enables Google Cloud Logging.
         */
        enableStackdriverLogging?: pulumi.Input<boolean>;
    }

    export interface CxAgentAdvancedSettingsSpeechSettings {
        /**
         * Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
         */
        endpointerSensitivity?: pulumi.Input<number>;
        /**
         * Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
         * An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
         */
        models?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Timeout before detecting no speech.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        noSpeechTimeout?: pulumi.Input<string>;
        /**
         * Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
         */
        useTimeoutBasedEndpointing?: pulumi.Input<boolean>;
    }

    export interface CxAgentGenAppBuilderSettings {
        /**
         * The full name of the Gen App Builder engine related to this agent if there is one.
         * Format: projects/{Project ID}/locations/{Location ID}/collections/{Collection ID}/engines/{Engine ID}
         */
        engine: pulumi.Input<string>;
    }

    export interface CxAgentGitIntegrationSettings {
        /**
         * Settings of integration with GitHub.
         * Structure is documented below.
         */
        githubSettings?: pulumi.Input<inputs.diagflow.CxAgentGitIntegrationSettingsGithubSettings>;
    }

    export interface CxAgentGitIntegrationSettingsGithubSettings {
        /**
         * The access token used to authenticate the access to the GitHub repository.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * A list of branches configured to be used from Dialogflow.
         */
        branches?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The unique repository display name for the GitHub repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The GitHub repository URI related to the agent.
         */
        repositoryUri?: pulumi.Input<string>;
        /**
         * The branch of the GitHub repository tracked for this agent.
         */
        trackingBranch?: pulumi.Input<string>;
    }

    export interface CxAgentSpeechToTextSettings {
        /**
         * Whether to use speech adaptation for speech recognition.
         */
        enableSpeechAdaptation?: pulumi.Input<boolean>;
    }

    export interface CxAgentTextToSpeechSettings {
        /**
         * Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
         * These settings affect:
         * * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
         * * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
         */
        synthesizeSpeechConfigs?: pulumi.Input<string>;
    }

    export interface CxEntityTypeEntity {
        /**
         * A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
         * For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
         *
         * - - -
         */
        synonyms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
         * For KIND_MAP entity types: A canonical value to be used in place of synonyms.
         * For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
         */
        value?: pulumi.Input<string>;
    }

    export interface CxEntityTypeExcludedPhrase {
        /**
         * The word or phrase to be excluded.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxEnvironmentVersionConfig {
        /**
         * Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
         *
         * - - -
         */
        version: pulumi.Input<string>;
    }

    export interface CxFlowAdvancedSettings {
        /**
         * If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * Structure is documented below.
         */
        audioExportGcsDestination?: pulumi.Input<inputs.diagflow.CxFlowAdvancedSettingsAudioExportGcsDestination>;
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxFlowAdvancedSettingsDtmfSettings>;
        /**
         * Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
         * * Agent level
         * Structure is documented below.
         */
        loggingSettings?: pulumi.Input<inputs.diagflow.CxFlowAdvancedSettingsLoggingSettings>;
        /**
         * Settings for speech to text detection. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        speechSettings?: pulumi.Input<inputs.diagflow.CxFlowAdvancedSettingsSpeechSettings>;
    }

    export interface CxFlowAdvancedSettingsAudioExportGcsDestination {
        /**
         * The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
         * Format: gs://bucket/object-name-or-prefix
         */
        uri?: pulumi.Input<string>;
    }

    export interface CxFlowAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxFlowAdvancedSettingsLoggingSettings {
        /**
         * Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
         */
        enableConsentBasedRedaction?: pulumi.Input<boolean>;
        /**
         * Enables DF Interaction logging.
         */
        enableInteractionLogging?: pulumi.Input<boolean>;
        /**
         * Enables Google Cloud Logging.
         */
        enableStackdriverLogging?: pulumi.Input<boolean>;
    }

    export interface CxFlowAdvancedSettingsSpeechSettings {
        /**
         * Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
         */
        endpointerSensitivity?: pulumi.Input<number>;
        /**
         * Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
         * An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
         */
        models?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Timeout before detecting no speech.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        noSpeechTimeout?: pulumi.Input<string>;
        /**
         * Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
         */
        useTimeoutBasedEndpointing?: pulumi.Input<boolean>;
    }

    export interface CxFlowEventHandler {
        /**
         * The name of the event to handle.
         */
        event?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier of this event handler.
         */
        name?: pulumi.Input<string>;
        /**
         * The target flow to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillment>;
    }

    export interface CxFlowEventHandlerTriggerFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentConditionalCase>[]>;
        /**
         * If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
         */
        enableGenerativeFallback?: pulumi.Input<boolean>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxFlowEventHandlerTriggerFulfillmentMessageText>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxFlowEventHandlerTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettings {
        /**
         * Optional. List of related data store connections.
         * Structure is documented below.
         */
        dataStoreConnections?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsDataStoreConnection>[]>;
        /**
         * Whether Knowledge Connector is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
         * This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
         * The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
         * This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to be triggered.
         * When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillment>;
    }

    export interface CxFlowKnowledgeConnectorSettingsDataStoreConnection {
        /**
         * The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
         */
        dataStore?: pulumi.Input<string>;
        /**
         * The type of the connected data store.
         * * PUBLIC_WEB: A data store that contains public web content.
         * * UNSTRUCTURED: A data store that contains unstructured private data.
         * * STRUCTURED: A data store that contains structured data (for example FAQ).
         * Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
         */
        dataStoreType?: pulumi.Input<string>;
        /**
         * The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
         * * DOCUMENTS: Documents are processed as documents.
         * * CHUNKS: Documents are converted to chunks.
         * Possible values are: `DOCUMENTS`, `CHUNKS`.
         */
        documentProcessingMode?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillment {
        /**
         * Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
         * DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
         * Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
         * Structure is documented below.
         */
        advancedSettings?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettings>;
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCase>[]>;
        /**
         * If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
         */
        enableGenerativeFallback?: pulumi.Input<boolean>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettings {
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettings>;
        /**
         * Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
         * * Agent level
         * Structure is documented below.
         */
        loggingSettings?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettings>;
        /**
         * Settings for speech to text detection. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        speechSettings?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettings>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Endpoint timeout setting for matching dtmf input to regex.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        endpointingTimeoutDuration?: pulumi.Input<string>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Interdigit timeout setting for matching dtmf input to regex.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        interdigitTimeoutDuration?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettings {
        /**
         * Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
         */
        enableConsentBasedRedaction?: pulumi.Input<boolean>;
        /**
         * Enables DF Interaction logging.
         */
        enableInteractionLogging?: pulumi.Input<boolean>;
        /**
         * Enables Google Cloud Logging.
         */
        enableStackdriverLogging?: pulumi.Input<boolean>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettings {
        /**
         * Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
         */
        endpointerSensitivity?: pulumi.Input<number>;
        /**
         * Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
         * An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
         */
        models?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Timeout before detecting no speech.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        noSpeechTimeout?: pulumi.Input<string>;
        /**
         * Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
         */
        useTimeoutBasedEndpointing?: pulumi.Input<boolean>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccess>;
        /**
         * (Output)
         * This type has no fields.
         * Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        endInteractions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteraction>[]>;
        /**
         * This type has no fields.
         * Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
         * Otherwise, the info card response is skipped.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        knowledgeInfoCard?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCard>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * (Output)
         * Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        mixedAudios?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudio>[]>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageText>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteraction {
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCard {
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudio {
        /**
         * Segments this audio response is composed of.
         */
        segments?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegment>[]>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegment {
        /**
         * (Output)
         * Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
         * A base64-encoded string.
         * This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
         */
        audio?: pulumi.Input<string>;
        /**
         * Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
         * This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
         */
        uri?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxFlowNluSettings {
        /**
         * To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
         * If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
         */
        classificationThreshold?: pulumi.Input<number>;
        /**
         * Indicates NLU model training mode.
         * * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
         * * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
         * Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
         */
        modelTrainingMode?: pulumi.Input<string>;
        /**
         * Indicates the type of NLU model.
         * * MODEL_TYPE_STANDARD: Use standard NLU model.
         * * MODEL_TYPE_ADVANCED: Use advanced NLU model.
         * Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
         */
        modelType?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRoute {
        /**
         * The condition to evaluate against form parameters or session parameters.
         * At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
         */
        condition?: pulumi.Input<string>;
        /**
         * The unique identifier of an Intent.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
         */
        intent?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier of this transition route.
         */
        name?: pulumi.Input<string>;
        /**
         * The target flow to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillment>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxFlowTransitionRouteTriggerFulfillmentMessageText>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxFlowTransitionRouteTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxIntentParameter {
        /**
         * The entity type of the parameter.
         * Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
         */
        entityType: pulumi.Input<string>;
        /**
         * The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
         */
        id: pulumi.Input<string>;
        /**
         * Indicates whether the parameter represents a list of values.
         */
        isList?: pulumi.Input<boolean>;
        /**
         * Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
         * Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
         */
        redact?: pulumi.Input<boolean>;
    }

    export interface CxIntentTrainingPhrase {
        /**
         * (Output)
         * The unique identifier of the training phrase.
         */
        id?: pulumi.Input<string>;
        /**
         * The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
         * Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
         * Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
         * If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
         * If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
         * Part.text is set to a part of the phrase that has no parameters.
         * Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
         * Structure is documented below.
         */
        parts: pulumi.Input<pulumi.Input<inputs.diagflow.CxIntentTrainingPhrasePart>[]>;
        /**
         * Indicates how many times this example was added to the intent.
         */
        repeatCount?: pulumi.Input<number>;
    }

    export interface CxIntentTrainingPhrasePart {
        /**
         * The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
         */
        parameterId?: pulumi.Input<string>;
        /**
         * The text for this part.
         */
        text: pulumi.Input<string>;
    }

    export interface CxPageAdvancedSettings {
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxPageAdvancedSettingsDtmfSettings>;
    }

    export interface CxPageAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxPageEntryFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageEntryFulfillmentMessageText>;
    }

    export interface CxPageEntryFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageEntryFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageEntryFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxPageEventHandler {
        /**
         * The name of the event to handle.
         */
        event?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier of this event handler.
         */
        name?: pulumi.Input<string>;
        /**
         * The target flow to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillment>;
    }

    export interface CxPageEventHandlerTriggerFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageEventHandlerTriggerFulfillmentMessageText>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageEventHandlerTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxPageForm {
        /**
         * Parameters to collect from the user.
         * Structure is documented below.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameter>[]>;
    }

    export interface CxPageFormParameter {
        /**
         * Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
         * Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
         * Structure is documented below.
         */
        advancedSettings?: pulumi.Input<inputs.diagflow.CxPageFormParameterAdvancedSettings>;
        /**
         * The default value of an optional parameter. If the parameter is required, the default value will be ignored.
         */
        defaultValue?: pulumi.Input<string>;
        /**
         * The human-readable name of the parameter, unique within the form.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The entity type of the parameter.
         * Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
         */
        entityType?: pulumi.Input<string>;
        /**
         * Defines fill behavior for the parameter.
         * Structure is documented below.
         */
        fillBehavior?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehavior>;
        /**
         * Indicates whether the parameter represents a list of values.
         */
        isList?: pulumi.Input<boolean>;
        /**
         * Indicates whether the parameter content should be redacted in log.
         * If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
         */
        redact?: pulumi.Input<boolean>;
        /**
         * Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
         * Required parameters must be filled before form filling concludes.
         */
        required?: pulumi.Input<boolean>;
    }

    export interface CxPageFormParameterAdvancedSettings {
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxPageFormParameterAdvancedSettingsDtmfSettings>;
    }

    export interface CxPageFormParameterAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxPageFormParameterFillBehavior {
        /**
         * The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
         * Structure is documented below.
         */
        initialPromptFulfillment?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillment>;
        /**
         * The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
         * * sys.no-match-<N>, where N can be from 1 to 6
         * * sys.no-match-default
         * * sys.no-input-<N>, where N can be from 1 to 6
         * * sys.no-input-default
         * * sys.invalid-parameter
         * [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
         * If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
         * A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
         * A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
         * If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
         * Structure is documented below.
         */
        repromptEventHandlers?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandler>[]>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandler {
        /**
         * The name of the event to handle.
         */
        event?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier of this event handler.
         */
        name?: pulumi.Input<string>;
        /**
         * The target flow to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettings {
        /**
         * Optional. List of related data store connections.
         * Structure is documented below.
         */
        dataStoreConnections?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsDataStoreConnection>[]>;
        /**
         * Whether Knowledge Connector is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
         * This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
         * The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
         * This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to be triggered.
         * When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillment>;
    }

    export interface CxPageKnowledgeConnectorSettingsDataStoreConnection {
        /**
         * The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
         */
        dataStore?: pulumi.Input<string>;
        /**
         * The type of the connected data store.
         * * PUBLIC_WEB: A data store that contains public web content.
         * * UNSTRUCTURED: A data store that contains unstructured private data.
         * * STRUCTURED: A data store that contains structured data (for example FAQ).
         * Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
         */
        dataStoreType?: pulumi.Input<string>;
        /**
         * The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
         * * DOCUMENTS: Documents are processed as documents.
         * * CHUNKS: Documents are converted to chunks.
         * Possible values are: `DOCUMENTS`, `CHUNKS`.
         */
        documentProcessingMode?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillment {
        /**
         * Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
         * DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
         * Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
         * Structure is documented below.
         */
        advancedSettings?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettings>;
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCase>[]>;
        /**
         * If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
         */
        enableGenerativeFallback?: pulumi.Input<boolean>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettings {
        /**
         * Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        dtmfSettings?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettings>;
        /**
         * Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
         * * Agent level
         * Structure is documented below.
         */
        loggingSettings?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettings>;
        /**
         * Settings for speech to text detection. Exposed at the following levels:
         * * Agent level
         * * Flow level
         * * Page level
         * * Parameter level
         * Structure is documented below.
         */
        speechSettings?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettings>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettings {
        /**
         * If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Endpoint timeout setting for matching dtmf input to regex.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        endpointingTimeoutDuration?: pulumi.Input<string>;
        /**
         * The digit that terminates a DTMF digit sequence.
         */
        finishDigit?: pulumi.Input<string>;
        /**
         * Interdigit timeout setting for matching dtmf input to regex.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        interdigitTimeoutDuration?: pulumi.Input<string>;
        /**
         * Max length of DTMF digits.
         */
        maxDigits?: pulumi.Input<number>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettings {
        /**
         * Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
         */
        enableConsentBasedRedaction?: pulumi.Input<boolean>;
        /**
         * Enables DF Interaction logging.
         */
        enableInteractionLogging?: pulumi.Input<boolean>;
        /**
         * Enables Google Cloud Logging.
         */
        enableStackdriverLogging?: pulumi.Input<boolean>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettings {
        /**
         * Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
         */
        endpointerSensitivity?: pulumi.Input<number>;
        /**
         * Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
         * An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
         */
        models?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Timeout before detecting no speech.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
         */
        noSpeechTimeout?: pulumi.Input<string>;
        /**
         * Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
         */
        useTimeoutBasedEndpointing?: pulumi.Input<boolean>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccess>;
        /**
         * (Output)
         * This type has no fields.
         * Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        endInteractions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteraction>[]>;
        /**
         * This type has no fields.
         * Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
         * Otherwise, the info card response is skipped.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        knowledgeInfoCard?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCard>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * (Output)
         * Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        mixedAudios?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudio>[]>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageText>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteraction {
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCard {
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudio {
        /**
         * Segments this audio response is composed of.
         */
        segments?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegment>[]>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegment {
        /**
         * (Output)
         * Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
         * A base64-encoded string.
         * This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
         */
        audio?: pulumi.Input<string>;
        /**
         * Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
         * This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
         */
        uri?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRoute {
        /**
         * The condition to evaluate against form parameters or session parameters.
         * At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
         */
        condition?: pulumi.Input<string>;
        /**
         * The unique identifier of an Intent.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
         */
        intent?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier of this transition route.
         */
        name?: pulumi.Input<string>;
        /**
         * The target flow to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         */
        targetFlow?: pulumi.Input<string>;
        /**
         * The target page to transition to.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        targetPage?: pulumi.Input<string>;
        /**
         * The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
         * Structure is documented below.
         */
        triggerFulfillment?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillment>;
    }

    export interface CxPageTransitionRouteTriggerFulfillment {
        /**
         * Conditional cases for this fulfillment.
         * Structure is documented below.
         */
        conditionalCases?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentConditionalCase>[]>;
        /**
         * The list of rich message responses to present to the user.
         * Structure is documented below.
         */
        messages?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessage>[]>;
        /**
         * Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
         */
        returnPartialResponses?: pulumi.Input<boolean>;
        /**
         * Set parameter values before executing the webhook.
         * Structure is documented below.
         */
        setParameterActions?: pulumi.Input<pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentSetParameterAction>[]>;
        /**
         * The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
         */
        tag?: pulumi.Input<string>;
        /**
         * The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
         */
        webhook?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentConditionalCase {
        /**
         * A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
         * See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
         */
        cases?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessage {
        /**
         * The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
         */
        channel?: pulumi.Input<string>;
        /**
         * Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
         * Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
         * * In a webhook response when you determine that you handled the customer issue.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        conversationSuccess?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess>;
        /**
         * Indicates that the conversation should be handed off to a live agent.
         * Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
         * You may set this, for example:
         * * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
         * * In a webhook response when you determine that the customer issue can only be handled by a human.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        liveAgentHandoff?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff>;
        /**
         * A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        outputAudioText?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText>;
        /**
         * Returns a response containing a custom, platform-specific payload.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         */
        payload?: pulumi.Input<string>;
        /**
         * Specifies an audio clip to be played by the client as part of the response.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        playAudio?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio>;
        /**
         * Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        telephonyTransferCall?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall>;
        /**
         * The text response message.
         * This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxPageTransitionRouteTriggerFulfillmentMessageText>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff {
        /**
         * Custom metadata. Dialogflow doesn't impose any structure on this.
         */
        metadata?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * The SSML text to be synthesized. For more information, see SSML.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        ssml?: pulumi.Input<string>;
        /**
         * The raw text to be synthesized.
         * This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
         */
        text?: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         *
         * <a name="nestedKnowledgeConnectorSettingsTriggerFulfillmentMessagesMessagesMixedAudio"></a>The `mixedAudio` block contains:
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
         */
        audioUri: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall {
        /**
         * Transfer the call to a phone number in E.164 format.
         */
        phoneNumber: pulumi.Input<string>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentMessageText {
        /**
         * (Output)
         * Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
         */
        allowPlaybackInterruption?: pulumi.Input<boolean>;
        /**
         * A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
         * required: true
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxPageTransitionRouteTriggerFulfillmentSetParameterAction {
        /**
         * Display name of the parameter.
         */
        parameter?: pulumi.Input<string>;
        /**
         * The new JSON-encoded value of the parameter. A null value clears the parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface CxSecuritySettingsAudioExportSettings {
        /**
         * Filename pattern for exported audio.
         */
        audioExportPattern?: pulumi.Input<string>;
        /**
         * File format for exported audio file. Currently only in telephony recordings.
         * * MULAW: G.711 mu-law PCM with 8kHz sample rate.
         * * MP3: MP3 file format.
         * * OGG: OGG Vorbis.
         * Possible values are: `MULAW`, `MP3`, `OGG`.
         */
        audioFormat?: pulumi.Input<string>;
        /**
         * Enable audio redaction if it is true.
         */
        enableAudioRedaction?: pulumi.Input<boolean>;
        /**
         * Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
         */
        gcsBucket?: pulumi.Input<string>;
    }

    export interface CxSecuritySettingsInsightsExportSettings {
        /**
         * If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
         */
        enableInsightsExport: pulumi.Input<boolean>;
    }

    export interface CxTestCaseLastTestResult {
        /**
         * The conversation turns uttered during the test case replay in chronological order.
         * Structure is documented below.
         */
        conversationTurns?: pulumi.Input<pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurn>[]>;
        /**
         * Environment where the test was run. If not set, it indicates the draft environment.
         */
        environment?: pulumi.Input<string>;
        /**
         * The unique identifier of the page.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        name?: pulumi.Input<string>;
        /**
         * Whether the test case passed in the agent environment.
         * * PASSED: The test passed.
         * * FAILED: The test did not pass.
         * Possible values are: `PASSED`, `FAILED`.
         */
        testResult?: pulumi.Input<string>;
        /**
         * The time that the test was run. A timestamp in RFC3339 text format.
         */
        testTime?: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurn {
        /**
         * The user input.
         * Structure is documented below.
         */
        userInput?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnUserInput>;
        /**
         * The virtual agent output.
         * Structure is documented below.
         */
        virtualAgentOutput?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutput>;
    }

    export interface CxTestCaseLastTestResultConversationTurnUserInput {
        /**
         * Whether sentiment analysis is enabled.
         */
        enableSentimentAnalysis?: pulumi.Input<boolean>;
        /**
         * Parameters that need to be injected into the conversation during intent detection.
         */
        injectedParameters?: pulumi.Input<string>;
        /**
         * User input. Supports text input, event input, dtmf input in the test case.
         * Structure is documented below.
         */
        input?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnUserInputInput>;
        /**
         * If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
         */
        isWebhookEnabled?: pulumi.Input<boolean>;
    }

    export interface CxTestCaseLastTestResultConversationTurnUserInputInput {
        /**
         * The DTMF event to be handled.
         * Structure is documented below.
         */
        dtmf?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnUserInputInputDtmf>;
        /**
         * The event to be triggered.
         * Structure is documented below.
         */
        event?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnUserInputInputEvent>;
        /**
         * The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
         * Note that queries in the same session do not necessarily need to specify the same language.
         */
        languageCode?: pulumi.Input<string>;
        /**
         * The natural language text to be processed.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnUserInputInputText>;
    }

    export interface CxTestCaseLastTestResultConversationTurnUserInputInputDtmf {
        /**
         * The dtmf digits.
         */
        digits?: pulumi.Input<string>;
        /**
         * The finish digit (if any).
         */
        finishDigit?: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnUserInputInputEvent {
        /**
         * Name of the event.
         */
        event: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnUserInputInputText {
        /**
         * The natural language text to be processed. Text length must not exceed 256 characters.
         */
        text: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutput {
        /**
         * The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
         * Structure is documented below.
         */
        currentPage?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage>;
        /**
         * The list of differences between the original run and the replay for this output, if any.
         * Structure is documented below.
         */
        differences?: pulumi.Input<pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference>[]>;
        /**
         * The session parameters available to the bot at this point.
         */
        sessionParameters?: pulumi.Input<string>;
        /**
         * Response error from the agent in the test result. If set, other output is empty.
         * Structure is documented below.
         */
        status?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus>;
        /**
         * The text responses from the agent for the turn.
         * Structure is documented below.
         */
        textResponses?: pulumi.Input<pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse>[]>;
        /**
         * The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
         * Structure is documented below.
         */
        triggeredIntent?: pulumi.Input<inputs.diagflow.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage {
        /**
         * (Output)
         * The human-readable name of the page, unique within the flow.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The unique identifier of the page.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        name?: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference {
        /**
         * A human readable description of the diff, showing the actual output vs expected output.
         */
        description?: pulumi.Input<string>;
        /**
         * The type of diff.
         * * INTENT: The intent.
         * * PAGE: The page.
         * * PARAMETERS: The parameters.
         * * UTTERANCE: The message utterance.
         * * FLOW: The flow.
         * Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
         */
        type?: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A JSON encoded list of messages that carry the error details.
         */
        details?: pulumi.Input<string>;
        /**
         * A developer-facing error message.
         */
        message?: pulumi.Input<string>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse {
        /**
         * A collection of text responses.
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent {
        /**
         * (Output)
         * The human-readable name of the intent, unique within the agent.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The unique identifier of the intent.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
         */
        name?: pulumi.Input<string>;
    }

    export interface CxTestCaseTestCaseConversationTurn {
        /**
         * The user input.
         * Structure is documented below.
         */
        userInput?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnUserInput>;
        /**
         * The virtual agent output.
         * Structure is documented below.
         */
        virtualAgentOutput?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnVirtualAgentOutput>;
    }

    export interface CxTestCaseTestCaseConversationTurnUserInput {
        /**
         * Whether sentiment analysis is enabled.
         */
        enableSentimentAnalysis?: pulumi.Input<boolean>;
        /**
         * Parameters that need to be injected into the conversation during intent detection.
         */
        injectedParameters?: pulumi.Input<string>;
        /**
         * User input. Supports text input, event input, dtmf input in the test case.
         * Structure is documented below.
         */
        input?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnUserInputInput>;
        /**
         * If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
         */
        isWebhookEnabled?: pulumi.Input<boolean>;
    }

    export interface CxTestCaseTestCaseConversationTurnUserInputInput {
        /**
         * The DTMF event to be handled.
         * Structure is documented below.
         */
        dtmf?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnUserInputInputDtmf>;
        /**
         * The event to be triggered.
         * Structure is documented below.
         */
        event?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnUserInputInputEvent>;
        /**
         * The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
         * Note that queries in the same session do not necessarily need to specify the same language.
         */
        languageCode?: pulumi.Input<string>;
        /**
         * The natural language text to be processed.
         * Structure is documented below.
         */
        text?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnUserInputInputText>;
    }

    export interface CxTestCaseTestCaseConversationTurnUserInputInputDtmf {
        /**
         * The dtmf digits.
         */
        digits?: pulumi.Input<string>;
        /**
         * The finish digit (if any).
         */
        finishDigit?: pulumi.Input<string>;
    }

    export interface CxTestCaseTestCaseConversationTurnUserInputInputEvent {
        /**
         * Name of the event.
         */
        event: pulumi.Input<string>;
    }

    export interface CxTestCaseTestCaseConversationTurnUserInputInputText {
        /**
         * The natural language text to be processed. Text length must not exceed 256 characters.
         */
        text: pulumi.Input<string>;
    }

    export interface CxTestCaseTestCaseConversationTurnVirtualAgentOutput {
        /**
         * The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
         * Structure is documented below.
         */
        currentPage?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage>;
        /**
         * The session parameters available to the bot at this point.
         */
        sessionParameters?: pulumi.Input<string>;
        /**
         * The text responses from the agent for the turn.
         * Structure is documented below.
         */
        textResponses?: pulumi.Input<pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse>[]>;
        /**
         * The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
         * Structure is documented below.
         */
        triggeredIntent?: pulumi.Input<inputs.diagflow.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent>;
    }

    export interface CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage {
        /**
         * (Output)
         * The human-readable name of the page, unique within the flow.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The unique identifier of the page.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         */
        name?: pulumi.Input<string>;
    }

    export interface CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse {
        /**
         * A collection of text responses.
         */
        texts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent {
        /**
         * (Output)
         * The human-readable name of the intent, unique within the agent.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The unique identifier of the intent.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
         */
        name?: pulumi.Input<string>;
    }

    export interface CxTestCaseTestConfig {
        /**
         * Flow name to start the test case with.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
         * Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
         */
        flow?: pulumi.Input<string>;
        /**
         * The page to start the test case with.
         * Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
         * Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
         */
        page?: pulumi.Input<string>;
        /**
         * Session parameters to be compared when calculating differences.
         */
        trackingParameters?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CxVersionNluSetting {
        /**
         * To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
         * The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
         */
        classificationThreshold?: pulumi.Input<number>;
        /**
         * Indicates NLU model training mode.
         * * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
         * * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
         * Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
         */
        modelTrainingMode?: pulumi.Input<string>;
        /**
         * Indicates the type of NLU model.
         * * MODEL_TYPE_STANDARD: Use standard NLU model.
         * * MODEL_TYPE_ADVANCED: Use advanced NLU model.
         * Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
         */
        modelType?: pulumi.Input<string>;
    }

    export interface CxWebhookGenericWebService {
        /**
         * Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
         */
        allowedCaCerts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP request headers to send together with webhook requests.
         */
        requestHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Whether to use speech adaptation for speech recognition.
         */
        uri: pulumi.Input<string>;
    }

    export interface CxWebhookServiceDirectory {
        /**
         * The name of Service Directory service.
         * Structure is documented below.
         */
        genericWebService: pulumi.Input<inputs.diagflow.CxWebhookServiceDirectoryGenericWebService>;
        /**
         * The name of Service Directory service.
         */
        service: pulumi.Input<string>;
    }

    export interface CxWebhookServiceDirectoryGenericWebService {
        /**
         * Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
         */
        allowedCaCerts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The HTTP request headers to send together with webhook requests.
         */
        requestHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Whether to use speech adaptation for speech recognition.
         */
        uri: pulumi.Input<string>;
    }

    export interface EntityTypeEntity {
        /**
         * A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
         * could be green onions.
         * For KIND_LIST entity types:
         * * This collection must contain exactly one synonym equal to value.
         */
        synonyms: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
         * could be scallions.
         * For KIND_MAP entity types:
         * * A reference value to be used in place of synonyms.
         * For KIND_LIST entity types:
         * * A string that can contain references to other entity types (with or without aliases).
         */
        value: pulumi.Input<string>;
    }

    export interface FulfillmentFeature {
        /**
         * The type of the feature that enabled for fulfillment.
         * * SMALLTALK: Fulfillment is enabled for SmallTalk.
         * Possible values are: `SMALLTALK`.
         */
        type: pulumi.Input<string>;
    }

    export interface FulfillmentGenericWebService {
        /**
         * The password for HTTP Basic authentication.
         */
        password?: pulumi.Input<string>;
        /**
         * The HTTP request headers to send together with fulfillment requests.
         */
        requestHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The fulfillment URI for receiving POST requests. It must use https protocol.
         */
        uri: pulumi.Input<string>;
        /**
         * The user name for HTTP Basic authentication.
         */
        username?: pulumi.Input<string>;
    }

    export interface IntentFollowupIntentInfo {
        /**
         * The unique identifier of the followup intent.
         * Format: projects/<Project ID>/agent/intents/<Intent ID>.
         */
        followupIntentName?: pulumi.Input<string>;
        /**
         * The unique identifier of the parent intent in the chain of followup intents.
         * Format: projects/<Project ID>/agent/intents/<Intent ID>.
         */
        parentFollowupIntentName?: pulumi.Input<string>;
    }
}

export namespace discoveryengine {
    export interface ChatEngineChatEngineConfig {
        /**
         * The configuration to generate the Dialogflow agent that is associated to this Engine.
         * Exactly one of `agentCreationConfig` or `dialogflowAgentToLink` must be set.
         * Structure is documented below.
         */
        agentCreationConfig?: pulumi.Input<inputs.discoveryengine.ChatEngineChatEngineConfigAgentCreationConfig>;
        /**
         * If the flag set to true, we allow the agent and engine are in
         * different locations, otherwise the agent and engine are required to be
         * in the same location. The flag is set to false by default.
         * Note that the `allowCrossRegion` are one-time consumed by and passed
         * to EngineService.CreateEngine. It means they cannot be retrieved using
         * EngineService.GetEngine or EngineService.ListEngines API after engine
         * creation.
         */
        allowCrossRegion?: pulumi.Input<boolean>;
        /**
         * The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
         * Exactly one of `agentCreationConfig` or `dialogflowAgentToLink` must be set.
         */
        dialogflowAgentToLink?: pulumi.Input<string>;
    }

    export interface ChatEngineChatEngineConfigAgentCreationConfig {
        /**
         * Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
         */
        business?: pulumi.Input<string>;
        /**
         * The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
         */
        defaultLanguageCode: pulumi.Input<string>;
        /**
         * Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
         */
        timeZone: pulumi.Input<string>;
    }

    export interface ChatEngineChatEngineMetadata {
        /**
         * (Output)
         * The resource name of a Dialogflow agent, that this Chat Engine refers to.
         */
        dialogflowAgent?: pulumi.Input<string>;
    }

    export interface ChatEngineCommonConfig {
        /**
         * The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
         */
        companyName?: pulumi.Input<string>;
    }

    export interface DataStoreAdvancedSiteSearchConfig {
        /**
         * If set true, automatic refresh is disabled for the DataStore.
         */
        disableAutomaticRefresh?: pulumi.Input<boolean>;
        /**
         * If set true, initial indexing is disabled for the DataStore.
         */
        disableInitialIndex?: pulumi.Input<boolean>;
    }

    export interface DataStoreDocumentProcessingConfig {
        /**
         * Whether chunking mode is enabled.
         * Structure is documented below.
         */
        chunkingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigChunkingConfig>;
        /**
         * Configurations for default Document parser. If not specified, this resource
         * will be configured to use a default DigitalParsingConfig, and the default parsing
         * config will be applied to all file types for Document parsing.
         * Structure is documented below.
         */
        defaultParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigDefaultParsingConfig>;
        /**
         * (Output)
         * The full resource name of the Document Processing Config. Format:
         * `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
         */
        name?: pulumi.Input<string>;
        /**
         * Map from file type to override the default parsing configuration based on the file type. Supported keys:
         */
        parsingConfigOverrides?: pulumi.Input<pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigParsingConfigOverride>[]>;
    }

    export interface DataStoreDocumentProcessingConfigChunkingConfig {
        /**
         * Configuration for the layout based chunking.
         * Structure is documented below.
         */
        layoutBasedChunkingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig>;
    }

    export interface DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig {
        /**
         * The token size limit for each chunk.
         * Supported values: 100-500 (inclusive). Default value: 500.
         */
        chunkSize?: pulumi.Input<number>;
        /**
         * Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
         * Default value: False.
         */
        includeAncestorHeadings?: pulumi.Input<boolean>;
    }

    export interface DataStoreDocumentProcessingConfigDefaultParsingConfig {
        /**
         * Configurations applied to digital parser.
         */
        digitalParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig>;
        /**
         * Configurations applied to layout parser.
         */
        layoutParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig>;
        /**
         * Configurations applied to OCR parser. Currently it only applies to PDFs.
         * Structure is documented below.
         */
        ocrParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig>;
    }

    export interface DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig {
    }

    export interface DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig {
    }

    export interface DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig {
        /**
         * If true, will use native text instead of OCR text on pages containing native text.
         */
        useNativeText?: pulumi.Input<boolean>;
    }

    export interface DataStoreDocumentProcessingConfigParsingConfigOverride {
        /**
         * Configurations applied to digital parser.
         */
        digitalParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig>;
        /**
         * The identifier for this object. Format specified above.
         */
        fileType: pulumi.Input<string>;
        /**
         * Configurations applied to layout parser.
         */
        layoutParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig>;
        /**
         * Configurations applied to OCR parser. Currently it only applies to PDFs.
         * Structure is documented below.
         */
        ocrParsingConfig?: pulumi.Input<inputs.discoveryengine.DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig>;
    }

    export interface DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig {
    }

    export interface DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig {
    }

    export interface DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig {
        /**
         * If true, will use native text instead of OCR text on pages containing native text.
         */
        useNativeText?: pulumi.Input<boolean>;
    }

    export interface SearchEngineCommonConfig {
        /**
         * The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
         */
        companyName?: pulumi.Input<string>;
    }

    export interface SearchEngineSearchEngineConfig {
        /**
         * The add-on that this search engine enables.
         * Each value may be one of: `SEARCH_ADD_ON_LLM`.
         *
         * - - -
         */
        searchAddOns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
         * Default value is `SEARCH_TIER_STANDARD`.
         * Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
         */
        searchTier?: pulumi.Input<string>;
    }

    export interface TargetSiteFailureReason {
        /**
         * Site verification state indicating the ownership and validity.
         * Structure is documented below.
         */
        quotaFailure?: pulumi.Input<inputs.discoveryengine.TargetSiteFailureReasonQuotaFailure>;
    }

    export interface TargetSiteFailureReasonQuotaFailure {
        /**
         * This number is an estimation on how much total quota this project
         * needs to successfully complete indexing.
         */
        totalRequiredQuota?: pulumi.Input<number>;
    }

    export interface TargetSiteSiteVerificationInfo {
        /**
         * Site verification state indicating the ownership and validity.
         * Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
         */
        siteVerificationState?: pulumi.Input<string>;
        /**
         * Latest site verification time.
         */
        verifyTime?: pulumi.Input<string>;
    }
}

export namespace dns {
    export interface DnsManagedZoneIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DnsManagedZoneIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ManagedZoneCloudLoggingConfig {
        /**
         * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
         */
        enableLogging: pulumi.Input<boolean>;
    }

    export interface ManagedZoneDnssecConfig {
        /**
         * Specifies parameters that will be used for generating initial DnsKeys
         * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
         * you must also provide one for the other.
         * defaultKeySpecs can only be updated when the state is `off`.
         * Structure is documented below.
         */
        defaultKeySpecs?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneDnssecConfigDefaultKeySpec>[]>;
        /**
         * Identifies what kind of resource this is
         */
        kind?: pulumi.Input<string>;
        /**
         * Specifies the mechanism used to provide authenticated denial-of-existence responses.
         * nonExistence can only be updated when the state is `off`.
         * Possible values are: `nsec`, `nsec3`.
         */
        nonExistence?: pulumi.Input<string>;
        /**
         * Specifies whether DNSSEC is enabled, and what mode it is in
         * Possible values are: `off`, `on`, `transfer`.
         */
        state?: pulumi.Input<string>;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        /**
         * String mnemonic specifying the DNSSEC algorithm of this key
         * Possible values are: `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, `rsasha512`.
         */
        algorithm?: pulumi.Input<string>;
        /**
         * Length of the keys in bits
         */
        keyLength?: pulumi.Input<number>;
        /**
         * Specifies whether this is a key signing key (KSK) or a zone
         * signing key (ZSK). Key signing keys have the Secure Entry
         * Point flag set and, when active, will only be used to sign
         * resource record sets of type DNSKEY. Zone signing keys do
         * not have the Secure Entry Point flag set and will be used
         * to sign all other types of resource record sets.
         * Possible values are: `keySigning`, `zoneSigning`.
         */
        keyType?: pulumi.Input<string>;
        /**
         * Identifies what kind of resource this is
         */
        kind?: pulumi.Input<string>;
    }

    export interface ManagedZoneForwardingConfig {
        /**
         * List of target name servers to forward to. Cloud DNS will
         * select the best available name server if more than
         * one target is given.
         * Structure is documented below.
         */
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneForwardingConfigTargetNameServer>[]>;
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        /**
         * Fully qualified domain name for the forwarding target.
         */
        domainName?: pulumi.Input<string>;
        /**
         * Forwarding path for this TargetNameServer. If unset or `default` Cloud DNS will make forwarding
         * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
         * to the Internet. When set to `private`, Cloud DNS will always send queries through VPC for this target
         * Possible values are: `default`, `private`.
         */
        forwardingPath?: pulumi.Input<string>;
        /**
         * IPv4 address of a target name server.
         */
        ipv4Address?: pulumi.Input<string>;
    }

    export interface ManagedZonePeeringConfig {
        /**
         * The network with which to peer.
         * Structure is documented below.
         */
        targetNetwork: pulumi.Input<inputs.dns.ManagedZonePeeringConfigTargetNetwork>;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        /**
         * The id or fully qualified URL of the VPC network to forward queries to.
         * This should be formatted like `projects/{project}/global/networks/{network}` or
         * `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
         */
        networkUrl: pulumi.Input<string>;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        /**
         * The list of Google Kubernetes Engine clusters that can see this zone.
         * Structure is documented below.
         */
        gkeClusters?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZonePrivateVisibilityConfigGkeCluster>[]>;
        networks?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZonePrivateVisibilityConfigNetwork>[]>;
    }

    export interface ManagedZonePrivateVisibilityConfigGkeCluster {
        /**
         * The resource name of the cluster to bind this ManagedZone to.
         * This should be specified in the format like
         * `projects/*&#47;locations/*&#47;clusters/*`
         */
        gkeClusterName: pulumi.Input<string>;
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        /**
         * The id or fully qualified URL of the VPC network to bind to.
         * This should be formatted like `projects/{project}/global/networks/{network}` or
         * `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
         */
        networkUrl: pulumi.Input<string>;
    }

    export interface ManagedZoneServiceDirectoryConfig {
        /**
         * The namespace associated with the zone.
         * Structure is documented below.
         */
        namespace: pulumi.Input<inputs.dns.ManagedZoneServiceDirectoryConfigNamespace>;
    }

    export interface ManagedZoneServiceDirectoryConfigNamespace {
        /**
         * The fully qualified or partial URL of the service directory namespace that should be
         * associated with the zone. This should be formatted like
         * `https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace_id}`
         * or simply `projects/{project}/locations/{location}/namespaces/{namespace_id}`
         * Ignored for `public` visibility zones.
         */
        namespaceUrl: pulumi.Input<string>;
    }

    export interface PolicyAlternativeNameServerConfig {
        /**
         * Sets an alternative name server for the associated networks. When specified,
         * all DNS queries are forwarded to a name server that you choose. Names such as .internal
         * are not available when an alternative name server is specified.
         * Structure is documented below.
         */
        targetNameServers: pulumi.Input<pulumi.Input<inputs.dns.PolicyAlternativeNameServerConfigTargetNameServer>[]>;
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        /**
         * Forwarding path for this TargetNameServer. If unset or `default` Cloud DNS will make forwarding
         * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
         * to the Internet. When set to `private`, Cloud DNS will always send queries through VPC for this target
         * Possible values are: `default`, `private`.
         */
        forwardingPath?: pulumi.Input<string>;
        /**
         * IPv4 address to forward to.
         */
        ipv4Address: pulumi.Input<string>;
    }

    export interface PolicyNetwork {
        /**
         * The id or fully qualified URL of the VPC network to forward queries to.
         * This should be formatted like `projects/{project}/global/networks/{network}` or
         * `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
         */
        networkUrl: pulumi.Input<string>;
    }

    export interface RecordSetRoutingPolicy {
        /**
         * Specifies whether to enable fencing for geo queries.
         */
        enableGeoFencing?: pulumi.Input<boolean>;
        /**
         * The configuration for Geolocation based routing policy.
         * Structure is documented below.
         */
        geos?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyGeo>[]>;
        /**
         * Specifies the health check (used with external endpoints).
         */
        healthCheck?: pulumi.Input<string>;
        /**
         * The configuration for a failover policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy.
         * Structure is documented below.
         */
        primaryBackup?: pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackup>;
        /**
         * The configuration for Weighted Round Robin based routing policy.
         * Structure is documented below.
         */
        wrrs?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyWrr>[]>;
    }

    export interface RecordSetRoutingPolicyGeo {
        /**
         * For A and AAAA types only. The list of targets to be health checked. These can be specified along with `rrdatas` within this item.
         * Structure is documented below.
         */
        healthCheckedTargets?: pulumi.Input<inputs.dns.RecordSetRoutingPolicyGeoHealthCheckedTargets>;
        /**
         * The location name defined in Google Cloud.
         */
        location: pulumi.Input<string>;
        /**
         * Same as `rrdatas` above.
         */
        rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RecordSetRoutingPolicyGeoHealthCheckedTargets {
        /**
         * The list of external endpoint addresses to health check.
         */
        externalEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of internal load balancers to health check.
         * Structure is documented below.
         */
        internalLoadBalancers?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancer>[]>;
    }

    export interface RecordSetRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancer {
        /**
         * The frontend IP address of the load balancer.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
         */
        loadBalancerType?: pulumi.Input<string>;
        /**
         * The fully qualified url of the network in which the load balancer belongs. This should be formatted like `projects/{project}/global/networks/{network}` or `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
         */
        networkUrl: pulumi.Input<string>;
        /**
         * The configured port of the load balancer.
         */
        port: pulumi.Input<string>;
        /**
         * The ID of the project in which the load balancer belongs.
         */
        project: pulumi.Input<string>;
        /**
         * The region of the load balancer. Only needed for regional load balancers.
         */
        region?: pulumi.Input<string>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackup {
        /**
         * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets.
         * Structure is document above.
         */
        backupGeos: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackupBackupGeo>[]>;
        /**
         * Specifies whether to enable fencing for backup geo queries.
         */
        enableGeoFencingForBackups?: pulumi.Input<boolean>;
        /**
         * The list of global primary targets to be health checked.
         * Structure is documented below.
         */
        primary: pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackupPrimary>;
        /**
         * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
         */
        trickleRatio?: pulumi.Input<number>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackupBackupGeo {
        /**
         * For A and AAAA types only. The list of targets to be health checked. These can be specified along with `rrdatas` within this item.
         */
        healthCheckedTargets?: pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets>;
        /**
         * The location name defined in Google Cloud.
         */
        location: pulumi.Input<string>;
        rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
        /**
         * The list of external endpoint addresses to health check.
         */
        externalEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of internal load balancers to health check.
         * Structure is documented below.
         */
        internalLoadBalancers?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancer>[]>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancer {
        /**
         * The frontend IP address of the load balancer.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
         */
        loadBalancerType?: pulumi.Input<string>;
        /**
         * The fully qualified url of the network in which the load balancer belongs. This should be formatted like `projects/{project}/global/networks/{network}` or `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
         */
        networkUrl: pulumi.Input<string>;
        /**
         * The configured port of the load balancer.
         */
        port: pulumi.Input<string>;
        /**
         * The ID of the project in which the load balancer belongs.
         */
        project: pulumi.Input<string>;
        /**
         * The region of the load balancer. Only needed for regional load balancers.
         */
        region?: pulumi.Input<string>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackupPrimary {
        /**
         * The Internet IP addresses to be health checked.
         */
        externalEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of internal load balancers to health check.
         */
        internalLoadBalancers?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancer>[]>;
    }

    export interface RecordSetRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancer {
        /**
         * The frontend IP address of the load balancer.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
         */
        loadBalancerType?: pulumi.Input<string>;
        /**
         * The fully qualified url of the network in which the load balancer belongs. This should be formatted like `projects/{project}/global/networks/{network}` or `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
         */
        networkUrl: pulumi.Input<string>;
        /**
         * The configured port of the load balancer.
         */
        port: pulumi.Input<string>;
        /**
         * The ID of the project in which the load balancer belongs.
         */
        project: pulumi.Input<string>;
        /**
         * The region of the load balancer. Only needed for regional load balancers.
         */
        region?: pulumi.Input<string>;
    }

    export interface RecordSetRoutingPolicyWrr {
        /**
         * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of `rrdatas` or `healthCheckedTargets` can be set.
         * Structure is documented below.
         */
        healthCheckedTargets?: pulumi.Input<inputs.dns.RecordSetRoutingPolicyWrrHealthCheckedTargets>;
        /**
         * Same as `rrdatas` above.
         */
        rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ratio of traffic routed to the target.
         */
        weight: pulumi.Input<number>;
    }

    export interface RecordSetRoutingPolicyWrrHealthCheckedTargets {
        /**
         * The list of external endpoint addresses to health check.
         */
        externalEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of internal load balancers to health check.
         * Structure is documented below.
         */
        internalLoadBalancers?: pulumi.Input<pulumi.Input<inputs.dns.RecordSetRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancer>[]>;
    }

    export interface RecordSetRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancer {
        /**
         * The frontend IP address of the load balancer.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
         */
        ipProtocol: pulumi.Input<string>;
        /**
         * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb", "regionalL7ilb", "globalL7ilb"]
         */
        loadBalancerType?: pulumi.Input<string>;
        /**
         * The fully qualified url of the network in which the load balancer belongs. This should be formatted like `projects/{project}/global/networks/{network}` or `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
         */
        networkUrl: pulumi.Input<string>;
        /**
         * The configured port of the load balancer.
         */
        port: pulumi.Input<string>;
        /**
         * The ID of the project in which the load balancer belongs.
         */
        project: pulumi.Input<string>;
        /**
         * The region of the load balancer. Only needed for regional load balancers.
         */
        region?: pulumi.Input<string>;
    }

    export interface ResponsePolicyGkeCluster {
        /**
         * The resource name of the cluster to bind this ManagedZone to.
         * This should be specified in the format like
         * `projects/*&#47;locations/*&#47;clusters/*`
         */
        gkeClusterName: pulumi.Input<string>;
    }

    export interface ResponsePolicyNetwork {
        /**
         * The fully qualified URL of the VPC network to bind to.
         * This should be formatted like
         * `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
         */
        networkUrl: pulumi.Input<string>;
    }

    export interface ResponsePolicyRuleLocalData {
        /**
         * All resource record sets for this selector, one per resource record type. The name must match the dns_name.
         * Structure is documented below.
         */
        localDatas: pulumi.Input<pulumi.Input<inputs.dns.ResponsePolicyRuleLocalDataLocalData>[]>;
    }

    export interface ResponsePolicyRuleLocalDataLocalData {
        /**
         * For example, www.example.com.
         */
        name: pulumi.Input<string>;
        /**
         * As defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1)
         */
        rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of seconds that this ResourceRecordSet can be cached by
         * resolvers.
         */
        ttl?: pulumi.Input<number>;
        /**
         * One of valid DNS resource types.
         * Possible values are: `A`, `AAAA`, `CAA`, `CNAME`, `DNSKEY`, `DS`, `HTTPS`, `IPSECVPNKEY`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV`, `SSHFP`, `SVCB`, `TLSA`, `TXT`.
         */
        type: pulumi.Input<string>;
    }
}

export namespace edgecontainer {
    export interface ClusterAuthorization {
        /**
         * User that will be granted the cluster-admin role on the cluster, providing
         * full access to the cluster. Currently, this is a singular field, but will
         * be expanded to allow multiple admins in the future.
         * Structure is documented below.
         */
        adminUsers: pulumi.Input<inputs.edgecontainer.ClusterAuthorizationAdminUsers>;
    }

    export interface ClusterAuthorizationAdminUsers {
        /**
         * An active Google username.
         *
         * - - -
         */
        username: pulumi.Input<string>;
    }

    export interface ClusterControlPlane {
        /**
         * Local control plane configuration.
         * Structure is documented below.
         */
        local?: pulumi.Input<inputs.edgecontainer.ClusterControlPlaneLocal>;
        /**
         * Remote control plane configuration.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.edgecontainer.ClusterControlPlaneRemote>;
    }

    export interface ClusterControlPlaneEncryption {
        /**
         * The Cloud KMS CryptoKey e.g.
         * projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
         * to use for protecting control plane disks. If not specified, a
         * Google-managed key will be used instead.
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The Cloud KMS CryptoKeyVersion currently in use for protecting control
         * plane disks. Only applicable if kmsKey is set.
         */
        kmsKeyActiveVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Availability of the Cloud KMS CryptoKey. If not `KEY_AVAILABLE`, then
         * nodes may go offline as they cannot access their local data. This can be
         * caused by a lack of permissions to use the key, or if the key is disabled
         * or deleted.
         */
        kmsKeyState?: pulumi.Input<string>;
        /**
         * (Output)
         * Error status returned by Cloud KMS when using this key. This field may be
         * populated only if `kmsKeyState` is not `KMS_KEY_STATE_KEY_AVAILABLE`.
         * If populated, this field contains the error status reported by Cloud KMS.
         * Structure is documented below.
         *
         *
         * <a name="nestedControlPlaneEncryptionKmsStatus"></a>The `kmsStatus` block contains:
         */
        kmsStatuses?: pulumi.Input<pulumi.Input<inputs.edgecontainer.ClusterControlPlaneEncryptionKmsStatus>[]>;
    }

    export interface ClusterControlPlaneEncryptionKmsStatus {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface ClusterControlPlaneLocal {
        /**
         * Only machines matching this filter will be allowed to host control
         * plane nodes. The filtering language accepts strings like "name=<name>",
         * and is documented here: [AIP-160](https://google.aip.dev/160).
         */
        machineFilter?: pulumi.Input<string>;
        /**
         * The number of nodes to serve as replicas of the Control Plane.
         * Only 1 and 3 are supported.
         */
        nodeCount?: pulumi.Input<number>;
        /**
         * Name of the Google Distributed Cloud Edge zones where this node pool
         * will be created. For example: `us-central1-edge-customer-a`.
         */
        nodeLocation?: pulumi.Input<string>;
        /**
         * Policy configuration about how user applications are deployed.
         * Possible values are: `SHARED_DEPLOYMENT_POLICY_UNSPECIFIED`, `ALLOWED`, `DISALLOWED`.
         */
        sharedDeploymentPolicy?: pulumi.Input<string>;
    }

    export interface ClusterControlPlaneRemote {
        /**
         * Name of the Google Distributed Cloud Edge zones where this node pool
         * will be created. For example: `us-central1-edge-customer-a`.
         */
        nodeLocation?: pulumi.Input<string>;
    }

    export interface ClusterFleet {
        /**
         * (Output)
         * The name of the managed Hub Membership resource associated to this cluster.
         * Membership names are formatted as
         * `projects/<project-number>/locations/global/membership/<cluster-id>`.
         */
        membership?: pulumi.Input<string>;
        /**
         * The name of the Fleet host project where this cluster will be registered.
         * Project names are formatted as
         * `projects/<project-number>`.
         */
        project: pulumi.Input<string>;
    }

    export interface ClusterMaintenanceEvent {
        /**
         * (Output)
         * The time when the maintenance event request was created.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the maintenance event ended, either successfully or not. If
         * the maintenance event is split into multiple maintenance windows,
         * endTime is only updated when the whole flow ends.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The operation for running the maintenance event. Specified in the format
         * projects/*&#47;locations/*&#47;operations/*. If the maintenance event is split
         * into multiple operations (e.g. due to maintenance windows), the latest
         * one is recorded.
         */
        operation?: pulumi.Input<string>;
        /**
         * (Output)
         * The schedule of the maintenance event.
         */
        schedule?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the maintenance event started.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates the maintenance event state.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * The target version of the cluster.
         */
        targetVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates the maintenance event type.
         */
        type?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the maintenance event message was updated.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * (Output)
         * UUID of the maintenance event.
         */
        uuid?: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicy {
        /**
         * Exclusions to automatic maintenance. Non-emergency maintenance should not occur
         * in these windows. Each exclusion has a unique name and may be active or expired.
         * The max number of maintenance exclusions allowed at a given time is 3.
         * Structure is documented below.
         */
        maintenanceExclusions?: pulumi.Input<pulumi.Input<inputs.edgecontainer.ClusterMaintenancePolicyMaintenanceExclusion>[]>;
        /**
         * Specifies the maintenance window in which maintenance may be performed.
         * Structure is documented below.
         */
        window: pulumi.Input<inputs.edgecontainer.ClusterMaintenancePolicyWindow>;
    }

    export interface ClusterMaintenancePolicyMaintenanceExclusion {
        /**
         * A unique (per cluster) id for the window.
         */
        id?: pulumi.Input<string>;
        /**
         * Represents an arbitrary window of time.
         * Structure is documented below.
         */
        window?: pulumi.Input<inputs.edgecontainer.ClusterMaintenancePolicyMaintenanceExclusionWindow>;
    }

    export interface ClusterMaintenancePolicyMaintenanceExclusionWindow {
        /**
         * The time that the window ends. The end time must take place after the
         * start time.
         */
        endTime?: pulumi.Input<string>;
        /**
         * The time that the window first starts.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface ClusterMaintenancePolicyWindow {
        /**
         * Represents an arbitrary window of time that recurs.
         * Structure is documented below.
         */
        recurringWindow: pulumi.Input<inputs.edgecontainer.ClusterMaintenancePolicyWindowRecurringWindow>;
    }

    export interface ClusterMaintenancePolicyWindowRecurringWindow {
        /**
         * An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how
         * this window recurs. They go on for the span of time between the start and
         * end time.
         */
        recurrence?: pulumi.Input<string>;
        /**
         * Represents an arbitrary window of time.
         * Structure is documented below.
         */
        window?: pulumi.Input<inputs.edgecontainer.ClusterMaintenancePolicyWindowRecurringWindowWindow>;
    }

    export interface ClusterMaintenancePolicyWindowRecurringWindowWindow {
        /**
         * The time that the window ends. The end time must take place after the
         * start time.
         */
        endTime?: pulumi.Input<string>;
        /**
         * The time that the window first starts.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface ClusterNetworking {
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these
         * blocks. Only a single block is supported. This field cannot be changed
         * after creation.
         */
        clusterIpv4CidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If specified, dual stack mode is enabled and all pods in the cluster are
         * assigned an IPv6 address from these blocks alongside from an IPv4
         * address. Only a single block is supported. This field cannot be changed
         * after creation.
         */
        clusterIpv6CidrBlocks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * IP addressing type of this cluster i.e. SINGLESTACK_V4 vs DUALSTACK_V4_V6.
         */
        networkType?: pulumi.Input<string>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address from these
         * blocks. Only a single block is supported. This field cannot be changed
         * after creation.
         */
        servicesIpv4CidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If specified, dual stack mode is enabled and all services in the cluster are
         * assigned an IPv6 address from these blocks alongside from an IPv4
         * address. Only a single block is supported. This field cannot be changed
         * after creation.
         */
        servicesIpv6CidrBlocks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterSystemAddonsConfig {
        /**
         * Config for the Ingress add-on which allows customers to create an Ingress
         * object to manage external access to the servers in a cluster. The add-on
         * consists of istiod and istio-ingress.
         * Structure is documented below.
         */
        ingress?: pulumi.Input<inputs.edgecontainer.ClusterSystemAddonsConfigIngress>;
    }

    export interface ClusterSystemAddonsConfigIngress {
        /**
         * Whether Ingress is disabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Ingress VIP.
         */
        ipv4Vip?: pulumi.Input<string>;
    }

    export interface NodePoolLocalDiskEncryption {
        /**
         * The Cloud KMS CryptoKey e.g. projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey} to use for protecting node local disks.
         * If not specified, a Google-managed key will be used instead.
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * (Output)
         * The Cloud KMS CryptoKeyVersion currently in use for protecting node local disks. Only applicable if kmsKey is set.
         */
        kmsKeyActiveVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Availability of the Cloud KMS CryptoKey. If not KEY_AVAILABLE, then nodes may go offline as they cannot access their local data.
         * This can be caused by a lack of permissions to use the key, or if the key is disabled or deleted.
         */
        kmsKeyState?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfig {
        /**
         * "The Kubernetes node labels"
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface VpnConnectionDetail {
        /**
         * (Output)
         * The Cloud Router info.
         * Structure is documented below.
         */
        cloudRouters?: pulumi.Input<pulumi.Input<inputs.edgecontainer.VpnConnectionDetailCloudRouter>[]>;
        /**
         * (Output)
         * Each connection has multiple Cloud VPN gateways.
         * Structure is documented below.
         */
        cloudVpns?: pulumi.Input<pulumi.Input<inputs.edgecontainer.VpnConnectionDetailCloudVpn>[]>;
        /**
         * (Output)
         * The error message. This is only populated when state=ERROR.
         */
        error?: pulumi.Input<string>;
        /**
         * (Output)
         * The current connection state.
         */
        state?: pulumi.Input<string>;
    }

    export interface VpnConnectionDetailCloudRouter {
        /**
         * The resource name of VPN connection
         */
        name?: pulumi.Input<string>;
    }

    export interface VpnConnectionDetailCloudVpn {
        /**
         * (Output)
         * The created Cloud VPN gateway name.
         */
        gateway?: pulumi.Input<string>;
    }

    export interface VpnConnectionVpcProject {
        /**
         * The project of the VPC to connect to. If not specified, it is the same as the cluster project.
         */
        projectId?: pulumi.Input<string>;
    }
}

export namespace endpoints {
    export interface ConsumersIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConsumersIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceApi {
        /**
         * A list of Method objects; structure is documented below.
         */
        methods?: pulumi.Input<pulumi.Input<inputs.endpoints.ServiceApiMethod>[]>;
        /**
         * The simple name of the endpoint as described in the config.
         */
        name?: pulumi.Input<string>;
        /**
         * `SYNTAX_PROTO2` or `SYNTAX_PROTO3`.
         */
        syntax?: pulumi.Input<string>;
        /**
         * A version string for this api. If specified, will have the form major-version.minor-version, e.g. `1.10`.
         */
        version?: pulumi.Input<string>;
    }

    export interface ServiceApiMethod {
        /**
         * The simple name of the endpoint as described in the config.
         */
        name?: pulumi.Input<string>;
        /**
         * The type URL for the request to this API.
         */
        requestType?: pulumi.Input<string>;
        /**
         * The type URL for the response from this API.
         */
        responseType?: pulumi.Input<string>;
        /**
         * `SYNTAX_PROTO2` or `SYNTAX_PROTO3`.
         */
        syntax?: pulumi.Input<string>;
    }

    export interface ServiceEndpoint {
        /**
         * The FQDN of the endpoint as described in the config.
         */
        address?: pulumi.Input<string>;
        /**
         * The simple name of the endpoint as described in the config.
         */
        name?: pulumi.Input<string>;
    }

    export interface ServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace essentialcontacts {
    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinition {
        /**
         * Date time property. Not supported by CMEK compliant deployment.
         */
        dateTimeTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionDateTimeTypeOptions>;
        /**
         * The display-name for the property, used for front-end.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Enum/categorical property.
         * Structure is documented below.
         */
        enumTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionEnumTypeOptions>;
        /**
         * Float property.
         */
        floatTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionFloatTypeOptions>;
        /**
         * Integer property.
         */
        integerTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionIntegerTypeOptions>;
        /**
         * Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.
         */
        isFilterable?: pulumi.Input<boolean>;
        /**
         * Whether the property is user supplied metadata.
         */
        isMetadata?: pulumi.Input<boolean>;
        /**
         * Whether the property can have multiple values.
         */
        isRepeatable?: pulumi.Input<boolean>;
        /**
         * Whether the property is mandatory.
         */
        isRequired?: pulumi.Input<boolean>;
        /**
         * Indicates that the property should be included in a global search.
         */
        isSearchable?: pulumi.Input<boolean>;
        /**
         * Map property.
         */
        mapTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionMapTypeOptions>;
        /**
         * The name of the metadata property.
         */
        name: pulumi.Input<string>;
        /**
         * Nested structured data property.
         * Structure is documented below.
         */
        propertyTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptions>;
        /**
         * Stores the retrieval importance.
         * Possible values are: `HIGHEST`, `HIGHER`, `HIGH`, `MEDIUM`, `LOW`, `LOWEST`.
         */
        retrievalImportance?: pulumi.Input<string>;
        /**
         * The schema source information.
         * Structure is documented below.
         */
        schemaSources?: pulumi.Input<pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionSchemaSource>[]>;
        /**
         * Text property.
         */
        textTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionTextTypeOptions>;
        /**
         * Timestamp property. Not supported by CMEK compliant deployment.
         */
        timestampTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionTimestampTypeOptions>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionDateTimeTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionEnumTypeOptions {
        /**
         * List of possible enum values.
         */
        possibleValues: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Make sure the enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.
         *
         * - - -
         */
        validationCheckDisabled?: pulumi.Input<boolean>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionFloatTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionIntegerTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionMapTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptions {
        /**
         * Defines the metadata for a schema property.
         * Structure is documented below.
         */
        propertyDefinitions: pulumi.Input<pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinition>[]>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinition {
        /**
         * Date time property. Not supported by CMEK compliant deployment.
         */
        dateTimeTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionDateTimeTypeOptions>;
        /**
         * The display-name for the property, used for front-end.
         */
        displayName?: pulumi.Input<string>;
        /**
         * Enum/categorical property.
         * Structure is documented below.
         */
        enumTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionEnumTypeOptions>;
        /**
         * Float property.
         */
        floatTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionFloatTypeOptions>;
        /**
         * Integer property.
         */
        integerTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionIntegerTypeOptions>;
        /**
         * Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.
         */
        isFilterable?: pulumi.Input<boolean>;
        /**
         * Whether the property is user supplied metadata.
         */
        isMetadata?: pulumi.Input<boolean>;
        /**
         * Whether the property can have multiple values.
         */
        isRepeatable?: pulumi.Input<boolean>;
        /**
         * Whether the property is mandatory.
         */
        isRequired?: pulumi.Input<boolean>;
        /**
         * Indicates that the property should be included in a global search.
         */
        isSearchable?: pulumi.Input<boolean>;
        /**
         * Map property.
         */
        mapTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionMapTypeOptions>;
        /**
         * The name of the metadata property.
         */
        name: pulumi.Input<string>;
        /**
         * Stores the retrieval importance.
         * Possible values are: `HIGHEST`, `HIGHER`, `HIGH`, `MEDIUM`, `LOW`, `LOWEST`.
         */
        retrievalImportance?: pulumi.Input<string>;
        /**
         * The schema source information.
         * Structure is documented below.
         */
        schemaSources?: pulumi.Input<pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionSchemaSource>[]>;
        /**
         * Text property.
         */
        textTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionTextTypeOptions>;
        /**
         * Timestamp property. Not supported by CMEK compliant deployment.
         */
        timestampTypeOptions?: pulumi.Input<inputs.essentialcontacts.DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionTimestampTypeOptions>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionDateTimeTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionEnumTypeOptions {
        /**
         * List of possible enum values.
         */
        possibleValues: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Make sure the enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.
         *
         * - - -
         */
        validationCheckDisabled?: pulumi.Input<boolean>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionFloatTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionIntegerTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionMapTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionSchemaSource {
        /**
         * The schema name in the source.
         */
        name?: pulumi.Input<string>;
        /**
         * The Doc AI processor type name.
         */
        processorType?: pulumi.Input<string>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionTextTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionPropertyTypeOptionsPropertyDefinitionTimestampTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionSchemaSource {
        /**
         * The schema name in the source.
         */
        name?: pulumi.Input<string>;
        /**
         * The Doc AI processor type name.
         */
        processorType?: pulumi.Input<string>;
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionTextTypeOptions {
    }

    export interface DocumentAiWarehouseDocumentSchemaPropertyDefinitionTimestampTypeOptions {
    }
}

export namespace eventarc {
    export interface GoogleApiSourceLoggingConfig {
        /**
         * The minimum severity of logs that will be sent to Stackdriver/Platform
         * Telemetry. Logs at severitiy  this value will be sent, unless it is NONE.
         * Possible values are: `NONE`, `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`.
         */
        logSeverity?: pulumi.Input<string>;
    }

    export interface MessageBusLoggingConfig {
        /**
         * Optional. The minimum severity of logs that will be sent to Stackdriver/Platform
         * Telemetry. Logs at severitiy  this value will be sent, unless it is NONE.
         * Possible values are: `NONE`, `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`.
         */
        logSeverity?: pulumi.Input<string>;
    }

    export interface PipelineDestination {
        /**
         * Represents a config used to authenticate message requests.
         * Structure is documented below.
         */
        authenticationConfig?: pulumi.Input<inputs.eventarc.PipelineDestinationAuthenticationConfig>;
        /**
         * Represents a HTTP endpoint destination.
         * Structure is documented below.
         */
        httpEndpoint?: pulumi.Input<inputs.eventarc.PipelineDestinationHttpEndpoint>;
        /**
         * The resource name of the Message Bus to which events should be
         * published. The Message Bus resource should exist in the same project as
         * the Pipeline. Format:
         * `projects/{project}/locations/{location}/messageBuses/{message_bus}`
         */
        messageBus?: pulumi.Input<string>;
        /**
         * Represents a network config to be used for destination resolution and
         * connectivity.
         * Structure is documented below.
         */
        networkConfig?: pulumi.Input<inputs.eventarc.PipelineDestinationNetworkConfig>;
        /**
         * Represents the format of message data.
         * Structure is documented below.
         */
        outputPayloadFormat?: pulumi.Input<inputs.eventarc.PipelineDestinationOutputPayloadFormat>;
        /**
         * The resource name of the Pub/Sub topic to which events should be
         * published. Format:
         * `projects/{project}/locations/{location}/topics/{topic}`
         */
        topic?: pulumi.Input<string>;
        /**
         * The resource name of the Workflow whose Executions are triggered by
         * the events. The Workflow resource should be deployed in the same
         * project as the Pipeline. Format:
         * `projects/{project}/locations/{location}/workflows/{workflow}`
         */
        workflow?: pulumi.Input<string>;
    }

    export interface PipelineDestinationAuthenticationConfig {
        /**
         * Represents a config used to authenticate with a Google OIDC token using
         * a GCP service account. Use this authentication method to invoke your
         * Cloud Run and Cloud Functions destinations or HTTP endpoints that
         * support Google OIDC.
         * Structure is documented below.
         */
        googleOidc?: pulumi.Input<inputs.eventarc.PipelineDestinationAuthenticationConfigGoogleOidc>;
        /**
         * Contains information needed for generating an
         * [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
         * This type of authorization should generally only be used when calling
         * Google APIs hosted on *.googleapis.com.
         * Structure is documented below.
         */
        oauthToken?: pulumi.Input<inputs.eventarc.PipelineDestinationAuthenticationConfigOauthToken>;
    }

    export interface PipelineDestinationAuthenticationConfigGoogleOidc {
        /**
         * Audience to be used to generate the OIDC Token. The audience claim
         * identifies the recipient that the JWT is intended for. If
         * unspecified, the destination URI will be used.
         */
        audience?: pulumi.Input<string>;
        /**
         * Service account email used to generate the OIDC Token.
         * The principal who calls this API must have
         * iam.serviceAccounts.actAs permission in the service account. See
         * https://cloud.google.com/iam/docs/understanding-service-accounts
         * for more information. Eventarc service agents must have
         * roles/roles/iam.serviceAccountTokenCreator role to allow the
         * Pipeline to create OpenID tokens for authenticated requests.
         */
        serviceAccount: pulumi.Input<string>;
    }

    export interface PipelineDestinationAuthenticationConfigOauthToken {
        /**
         * OAuth scope to be used for generating OAuth access token. If not
         * specified, "https://www.googleapis.com/auth/cloud-platform" will be
         * used.
         */
        scope?: pulumi.Input<string>;
        /**
         * Service account email used to generate the [OAuth
         * token](https://developers.google.com/identity/protocols/OAuth2).
         * The principal who calls this API must have
         * iam.serviceAccounts.actAs permission in the service account. See
         * https://cloud.google.com/iam/docs/understanding-service-accounts
         * for more information. Eventarc service agents must have
         * roles/roles/iam.serviceAccountTokenCreator role to allow Pipeline
         * to create OAuth2 tokens for authenticated requests.
         */
        serviceAccount: pulumi.Input<string>;
    }

    export interface PipelineDestinationHttpEndpoint {
        /**
         * The CEL expression used to modify how the destination-bound HTTP
         * request is constructed.
         * If a binding expression is not specified here, the message
         * is treated as a CloudEvent and is mapped to the HTTP request according
         * to the CloudEvent HTTP Protocol Binding Binary Content Mode
         * (https://github.com/cloudevents/spec/blob/main/cloudevents/bindings/http-protocol-binding.md#31-binary-content-mode).
         * In this representation, all fields except the `data` and
         * `datacontenttype` field on the message are mapped to HTTP request
         * headers with a prefix of `ce-`.
         * To construct the HTTP request payload and the value of the content-type
         * HTTP header, the payload format is defined as follows:
         * 1) Use the outputPayloadFormatType on the Pipeline.Destination if it
         * is set, else:
         * 2) Use the inputPayloadFormatType on the Pipeline if it is set,
         * else:
         * 3) Treat the payload as opaque binary data.
         * The `data` field of the message is converted to the payload format or
         * left as-is for case 3) and then attached as the payload of the HTTP
         * request. The `content-type` header on the HTTP request is set to the
         * payload format type or left empty for case 3). However, if a mediation
         * has updated the `datacontenttype` field on the message so that it is
         * not the same as the payload format type but it is still a prefix of the
         * payload format type, then the `content-type` header on the HTTP request
         * is set to this `datacontenttype` value. For example, if the
         * `datacontenttype` is "application/json" and the payload format type is
         * "application/json; charset=utf-8", then the `content-type` header on
         * the HTTP request is set to "application/json; charset=utf-8".
         * If a non-empty binding expression is specified then this expression is
         * used to modify the default CloudEvent HTTP Protocol Binding Binary
         * Content representation.
         * The result of the CEL expression must be a map of key/value pairs
         * which is used as follows:
         * - If a map named `headers` exists on the result of the expression,
         * then its key/value pairs are directly mapped to the HTTP request
         * headers. The headers values are constructed from the corresponding
         * value type's canonical representation. If the `headers` field doesn't
         * exist then the resulting HTTP request will be the headers of the
         * CloudEvent HTTP Binding Binary Content Mode representation of the final
         * message. Note: If the specified binding expression, has updated the
         * `datacontenttype` field on the message so that it is not the same as
         * the payload format type but it is still a prefix of the payload format
         * type, then the `content-type` header in the `headers` map is set to
         * this `datacontenttype` value.
         * - If a field named `body` exists on the result of the expression then
         * its value is directly mapped to the body of the request. If the value
         * of the `body` field is of type bytes or string then it is used for
         * the HTTP request body as-is, with no conversion. If the body field is
         * of any other type then it is converted to a JSON string. If the body
         * field does not exist then the resulting payload of the HTTP request
         * will be data value of the CloudEvent HTTP Binding Binary Content Mode
         * representation of the final message as described earlier.
         * - Any other fields in the resulting expression will be ignored.
         * The CEL expression may access the incoming CloudEvent message in its
         * definition, as follows:
         * - The `data` field of the incoming CloudEvent message can be accessed
         * using the `message.data` value. Subfields of `message.data` may also be
         * accessed if an inputPayloadFormat has been specified on the Pipeline.
         * - Each attribute of the incoming CloudEvent message can be accessed
         * using the `message.` value, where  is replaced with the
         * name of the attribute.
         * - Existing headers can be accessed in the CEL expression using the
         * `headers` variable. The `headers` variable defines a map of key/value
         * pairs corresponding to the HTTP headers of the CloudEvent HTTP Binding
         * Binary Content Mode representation of the final message as described
         * earlier. For example, the following CEL expression can be used to
         * construct an HTTP request by adding an additional header to the HTTP
         * headers of the CloudEvent HTTP Binding Binary Content Mode
         * representation of the final message and by overwriting the body of the
         * request:
         * ```
         * {
         * "headers": headers.merge({"new-header-key": "new-header-value"}),
         * "body": "new-body"
         * }
         * ```
         * - The default binding for the message payload can be accessed using the
         * `body` variable. It conatins a string representation of the message
         * payload in the format specified by the `outputPayloadFormat` field.
         * If the `inputPayloadFormat` field is not set, the `body`
         * variable contains the same message payload bytes that were published.
         * Additionally, the following CEL extension functions are provided for
         * use in this CEL expression:
         * - toBase64Url:
         * map.toBase64Url() > string
         * - Converts a CelValue to a base64url encoded string
         * - toJsonString: map.toJsonString() > string
         * - Converts a CelValue to a JSON string
         * - merge:
         * map1.merge(map2) > map3
         * - Merges the passed CEL map with the existing CEL map the
         * function is applied to.
         * - If the same key exists in both maps, if the key's value is type
         * map both maps are merged else the value from the passed map is
         * used.
         * - denormalize:
         * map.denormalize() > map
         * - Denormalizes a CEL map such that every value of type map or key
         * in the map is expanded to return a single level map.
         * - The resulting keys are "." separated indices of the map keys.
         * - For example:
         * {
         * "a": 1,
         * "b": {
         * "c": 2,
         * "d": 3
         * }
         * "e": [4, 5]
         * }
         * .denormalize()
         * > {
         * "a": 1,
         * "b.c": 2,
         * "b.d": 3,
         * "e.0": 4,
         * "e.1": 5
         * }
         * - setField:
         * map.setField(key, value) > message
         * - Sets the field of the message with the given key to the
         * given value.
         * - If the field is not present it will be added.
         * - If the field is present it will be overwritten.
         * - The key can be a dot separated path to set a field in a nested
         * message.
         * - Key must be of type string.
         * - Value may be any valid type.
         * - removeFields:
         * map.removeFields([key1, key2, ...]) > message
         * - Removes the fields of the map with the given keys.
         * - The keys can be a dot separated path to remove a field in a
         * nested message.
         * - If a key is not found it will be ignored.
         * - Keys must be of type string.
         * - toMap:
         * [map1, map2, ...].toMap() > map
         * - Converts a CEL list of CEL maps to a single CEL map
         * - toCloudEventJsonWithPayloadFormat:
         * message.toCloudEventJsonWithPayloadFormat() > map
         * - Converts a message to the corresponding structure of JSON
         * format for CloudEvents.
         * - It converts `data` to destination payload format
         * specified in `outputPayloadFormat`. If `outputPayloadFormat` is
         * not set, the data will remain unchanged.
         * - It also sets the corresponding datacontenttype of
         * the CloudEvent, as indicated by
         * `outputPayloadFormat`. If no
         * `outputPayloadFormat` is set it will use the value of the
         * "datacontenttype" attribute on the CloudEvent if present, else
         * remove "datacontenttype" attribute.
         * - This function expects that the content of the message will
         * adhere to the standard CloudEvent format. If it doesn't then this
         * function will fail.
         * - The result is a CEL map that corresponds to the JSON
         * representation of the CloudEvent. To convert that data to a JSON
         * string it can be chained with the toJsonString function.
         * The Pipeline expects that the message it receives adheres to the
         * standard CloudEvent format. If it doesn't then the outgoing message
         * request may fail with a persistent error.
         *
         * - - -
         */
        messageBindingTemplate?: pulumi.Input<string>;
        /**
         * The URI of the HTTP enpdoint.
         * The value must be a RFC2396 URI string.
         * Examples: `https://svc.us-central1.p.local:8080/route`.
         * Only the HTTPS protocol is supported.
         */
        uri: pulumi.Input<string>;
    }

    export interface PipelineDestinationNetworkConfig {
        /**
         * Name of the NetworkAttachment that allows access to the consumer VPC.
         * Format:
         * `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
         */
        networkAttachment: pulumi.Input<string>;
    }

    export interface PipelineDestinationOutputPayloadFormat {
        /**
         * The format of an AVRO message payload.
         * Structure is documented below.
         */
        avro?: pulumi.Input<inputs.eventarc.PipelineDestinationOutputPayloadFormatAvro>;
        /**
         * The format of a JSON message payload.
         */
        json?: pulumi.Input<inputs.eventarc.PipelineDestinationOutputPayloadFormatJson>;
        /**
         * The format of a Protobuf message payload.
         * Structure is documented below.
         */
        protobuf?: pulumi.Input<inputs.eventarc.PipelineDestinationOutputPayloadFormatProtobuf>;
    }

    export interface PipelineDestinationOutputPayloadFormatAvro {
        /**
         * The entire schema definition is stored in this field.
         */
        schemaDefinition?: pulumi.Input<string>;
    }

    export interface PipelineDestinationOutputPayloadFormatJson {
    }

    export interface PipelineDestinationOutputPayloadFormatProtobuf {
        /**
         * The entire schema definition is stored in this field.
         */
        schemaDefinition?: pulumi.Input<string>;
    }

    export interface PipelineInputPayloadFormat {
        /**
         * The format of an AVRO message payload.
         * Structure is documented below.
         */
        avro?: pulumi.Input<inputs.eventarc.PipelineInputPayloadFormatAvro>;
        /**
         * The format of a JSON message payload.
         */
        json?: pulumi.Input<inputs.eventarc.PipelineInputPayloadFormatJson>;
        /**
         * The format of a Protobuf message payload.
         * Structure is documented below.
         */
        protobuf?: pulumi.Input<inputs.eventarc.PipelineInputPayloadFormatProtobuf>;
    }

    export interface PipelineInputPayloadFormatAvro {
        /**
         * The entire schema definition is stored in this field.
         */
        schemaDefinition?: pulumi.Input<string>;
    }

    export interface PipelineInputPayloadFormatJson {
    }

    export interface PipelineInputPayloadFormatProtobuf {
        /**
         * The entire schema definition is stored in this field.
         */
        schemaDefinition?: pulumi.Input<string>;
    }

    export interface PipelineLoggingConfig {
        /**
         * The minimum severity of logs that will be sent to Stackdriver/Platform
         * Telemetry. Logs at severitiy  this value will be sent, unless it is NONE.
         * Possible values are: `NONE`, `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`.
         */
        logSeverity?: pulumi.Input<string>;
    }

    export interface PipelineMediation {
        /**
         * Transformation defines the way to transform an incoming message.
         * Structure is documented below.
         */
        transformation?: pulumi.Input<inputs.eventarc.PipelineMediationTransformation>;
    }

    export interface PipelineMediationTransformation {
        /**
         * The CEL expression template to apply to transform messages.
         * The following CEL extension functions are provided for
         * use in this CEL expression:
         * - merge:
         * map1.merge(map2) > map3
         * - Merges the passed CEL map with the existing CEL map the
         * function is applied to.
         * - If the same key exists in both maps, if the key's value is type
         * map both maps are merged else the value from the passed map is
         * used.
         * - denormalize:
         * map.denormalize() > map
         * - Denormalizes a CEL map such that every value of type map or key
         * in the map is expanded to return a single level map.
         * - The resulting keys are "." separated indices of the map keys.
         * - For example:
         * {
         * "a": 1,
         * "b": {
         * "c": 2,
         * "d": 3
         * }
         * "e": [4, 5]
         * }
         * .denormalize()
         * > {
         * "a": 1,
         * "b.c": 2,
         * "b.d": 3,
         * "e.0": 4,
         * "e.1": 5
         * }
         * - setField:
         * map.setField(key, value) > message
         * - Sets the field of the message with the given key to the
         * given value.
         * - If the field is not present it will be added.
         * - If the field is present it will be overwritten.
         * - The key can be a dot separated path to set a field in a nested
         * message.
         * - Key must be of type string.
         * - Value may be any valid type.
         * - removeFields:
         * map.removeFields([key1, key2, ...]) > message
         * - Removes the fields of the map with the given keys.
         * - The keys can be a dot separated path to remove a field in a
         * nested message.
         * - If a key is not found it will be ignored.
         * - Keys must be of type string.
         * - toMap:
         * [map1, map2, ...].toMap() > map
         * - Converts a CEL list of CEL maps to a single CEL map
         * - toDestinationPayloadFormat():
         * message.data.toDestinationPayloadFormat() > string or bytes
         * - Converts the message data to the destination payload format
         * specified in Pipeline.Destination.output_payload_format
         * - This function is meant to be applied to the message.data field.
         * - If the destination payload format is not set, the function will
         * return the message data unchanged.
         * - toCloudEventJsonWithPayloadFormat:
         * message.toCloudEventJsonWithPayloadFormat() > map
         * - Converts a message to the corresponding structure of JSON
         * format for CloudEvents
         * - This function applies toDestinationPayloadFormat() to the
         * message data. It also sets the corresponding datacontenttype of
         * the CloudEvent, as indicated by
         * Pipeline.Destination.output_payload_format. If no
         * outputPayloadFormat is set it will use the existing
         * datacontenttype on the CloudEvent if present, else leave
         * datacontenttype absent.
         * - This function expects that the content of the message will
         * adhere to the standard CloudEvent format. If it doesn't then this
         * function will fail.
         * - The result is a CEL map that corresponds to the JSON
         * representation of the CloudEvent. To convert that data to a JSON
         * string it can be chained with the toJsonString function.
         */
        transformationTemplate?: pulumi.Input<string>;
    }

    export interface PipelineRetryPolicy {
        /**
         * The maximum number of delivery attempts for any message. The value must
         * be between 1 and 100.
         * The default value for this field is 5.
         */
        maxAttempts?: pulumi.Input<number>;
        /**
         * The maximum amount of seconds to wait between retry attempts. The value
         * must be between 1 and 600.
         * The default value for this field is 60.
         */
        maxRetryDelay?: pulumi.Input<string>;
        /**
         * The minimum amount of seconds to wait between retry attempts. The value
         * must be between 1 and 600.
         * The default value for this field is 5.
         */
        minRetryDelay?: pulumi.Input<string>;
    }

    export interface TriggerDestination {
        /**
         * (Output)
         * The Cloud Function resource name. Only Cloud Functions V2 is supported. Format projects/{project}/locations/{location}/functions/{function} This is a read-only field. [WARNING] Creating Cloud Functions V2 triggers is only supported via the Cloud Functions product. An error will be returned if the user sets this value.
         */
        cloudFunction?: pulumi.Input<string>;
        /**
         * Cloud Run fully-managed service that receives the events. The service should be running in the same project of the trigger.
         * Structure is documented below.
         */
        cloudRunService?: pulumi.Input<inputs.eventarc.TriggerDestinationCloudRunService>;
        /**
         * A GKE service capable of receiving events. The service should be running in the same project as the trigger.
         * Structure is documented below.
         */
        gke?: pulumi.Input<inputs.eventarc.TriggerDestinationGke>;
        /**
         * An HTTP endpoint destination described by an URI.
         * Structure is documented below.
         */
        httpEndpoint?: pulumi.Input<inputs.eventarc.TriggerDestinationHttpEndpoint>;
        /**
         * Optional. Network config is used to configure how Eventarc resolves and connect to a destination. This should only be used with HttpEndpoint destination type.
         * Structure is documented below.
         */
        networkConfig?: pulumi.Input<inputs.eventarc.TriggerDestinationNetworkConfig>;
        /**
         * The resource name of the Workflow whose Executions are triggered by the events. The Workflow resource should be deployed in the same project as the trigger. Format: `projects/{project}/locations/{location}/workflows/{workflow}`
         */
        workflow?: pulumi.Input<string>;
    }

    export interface TriggerDestinationCloudRunService {
        /**
         * Optional. The relative path on the Cloud Run service the events should be sent to. The value must conform to the definition of URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
         */
        path?: pulumi.Input<string>;
        /**
         * Required. The region the Cloud Run service is deployed in.
         */
        region?: pulumi.Input<string>;
        /**
         * Required. The name of the Cloud Run service being addressed. See https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services. Only services located in the same project of the trigger object can be addressed.
         */
        service: pulumi.Input<string>;
    }

    export interface TriggerDestinationGke {
        /**
         * Required. The name of the cluster the GKE service is running in. The cluster must be running in the same project as the trigger being created.
         */
        cluster: pulumi.Input<string>;
        /**
         * Required. The name of the Google Compute Engine in which the cluster resides, which can either be compute zone (for example, us-central1-a) for the zonal clusters or region (for example, us-central1) for regional clusters.
         */
        location: pulumi.Input<string>;
        /**
         * Required. The namespace the GKE service is running in.
         */
        namespace: pulumi.Input<string>;
        /**
         * Optional. The relative path on the GKE service the events should be sent to. The value must conform to the definition of a URI path segment (section 3.3 of RFC2396). Examples: "/route", "route", "route/subroute".
         */
        path?: pulumi.Input<string>;
        /**
         * Required. Name of the GKE service.
         */
        service: pulumi.Input<string>;
    }

    export interface TriggerDestinationHttpEndpoint {
        /**
         * Required. The URI of the HTTP enpdoint. The value must be a RFC2396 URI string. Examples: `http://10.10.10.8:80/route`, `http://svc.us-central1.p.local:8080/`. Only HTTP and HTTPS protocols are supported. The host can be either a static IP addressable from the VPC specified by the network config, or an internal DNS hostname of the service resolvable via Cloud DNS.
         */
        uri: pulumi.Input<string>;
    }

    export interface TriggerDestinationNetworkConfig {
        /**
         * Required. Name of the NetworkAttachment that allows access to the destination VPC. Format: `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
         *
         * - - -
         */
        networkAttachment: pulumi.Input<string>;
    }

    export interface TriggerMatchingCriteria {
        /**
         * Required. The name of a CloudEvents attribute. Currently, only a subset of attributes are supported for filtering. All triggers MUST provide a filter for the 'type' attribute.
         */
        attribute: pulumi.Input<string>;
        /**
         * Optional. The operator used for matching the events with the value of the filter. If not specified, only events that have an exact key-value pair specified in the filter are matched. The only allowed value is `match-path-pattern`.
         */
        operator?: pulumi.Input<string>;
        /**
         * Required. The value for the attribute. See https://cloud.google.com/eventarc/docs/creating-triggers#trigger-gcloud for available values.
         */
        value: pulumi.Input<string>;
    }

    export interface TriggerTransport {
        /**
         * The Pub/Sub topic and subscription used by Eventarc as delivery intermediary.
         * Structure is documented below.
         */
        pubsub?: pulumi.Input<inputs.eventarc.TriggerTransportPubsub>;
    }

    export interface TriggerTransportPubsub {
        /**
         * (Output)
         * Output only. The name of the Pub/Sub subscription created and managed by Eventarc system as a transport for the event delivery. Format: `projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}`.
         */
        subscription?: pulumi.Input<string>;
        /**
         * Optional. The name of the Pub/Sub topic created and managed by Eventarc system as a transport for the event delivery. Format: `projects/{PROJECT_ID}/topics/{TOPIC_NAME}. You may set an existing topic for triggers of the type google.cloud.pubsub.topic.v1.messagePublished` only. The topic you provide here will not be deleted by Eventarc at trigger deletion.
         */
        topic?: pulumi.Input<string>;
    }
}

export namespace filestore {
    export interface InstanceDirectoryServices {
        /**
         * Configuration for LDAP servers.
         * Structure is documented below.
         */
        ldap?: pulumi.Input<inputs.filestore.InstanceDirectoryServicesLdap>;
    }

    export interface InstanceDirectoryServicesLdap {
        /**
         * The LDAP domain name in the format of `my-domain.com`.
         */
        domain: pulumi.Input<string>;
        /**
         * The groups Organizational Unit (OU) is optional. This parameter is a hint
         * to allow faster lookup in the LDAP namespace. In case that this parameter
         * is not provided, Filestore instance will query the whole LDAP namespace.
         */
        groupsOu?: pulumi.Input<string>;
        /**
         * The servers names are used for specifying the LDAP servers names.
         * The LDAP servers names can come with two formats:
         * 1. DNS name, for example: `ldap.example1.com`, `ldap.example2.com`.
         * 2. IP address, for example: `10.0.0.1`, `10.0.0.2`, `10.0.0.3`.
         * All servers names must be in the same format: either all DNS names or all
         * IP addresses.
         */
        servers: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The users Organizational Unit (OU) is optional. This parameter is a hint
         * to allow faster lookup in the LDAP namespace. In case that this parameter
         * is not provided, Filestore instance will query the whole LDAP namespace.
         */
        usersOu?: pulumi.Input<string>;
    }

    export interface InstanceEffectiveReplication {
        /**
         * The replication role.
         * Structure is documented below.
         */
        replicas?: pulumi.Input<pulumi.Input<inputs.filestore.InstanceEffectiveReplicationReplica>[]>;
    }

    export interface InstanceEffectiveReplicationReplica {
        /**
         * (Output)
         * Output only. The timestamp of the latest replication snapshot taken on the active instance and is already replicated safely.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
         */
        lastActiveSyncTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The replica state
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Additional information about the replication state, if available.
         */
        stateReasons?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFileShares {
        /**
         * File share capacity in GiB. This must be at least 1024 GiB
         * for the standard tier, or 2560 GiB for the premium tier.
         */
        capacityGb: pulumi.Input<number>;
        /**
         * The name of the fileshare (16 characters or less)
         */
        name: pulumi.Input<string>;
        /**
         * Nfs Export Options. There is a limit of 10 export options per file share.
         * Structure is documented below.
         */
        nfsExportOptions?: pulumi.Input<pulumi.Input<inputs.filestore.InstanceFileSharesNfsExportOption>[]>;
        /**
         * The resource name of the backup, in the format
         * projects/{projectId}/locations/{locationId}/backups/{backupId},
         * that this file share has been restored from.
         */
        sourceBackup?: pulumi.Input<string>;
    }

    export interface InstanceFileSharesNfsExportOption {
        /**
         * Either READ_ONLY, for allowing only read requests on the exported directory,
         * or READ_WRITE, for allowing both read and write requests. The default is READ_WRITE.
         * Default value is `READ_WRITE`.
         * Possible values are: `READ_ONLY`, `READ_WRITE`.
         */
        accessMode?: pulumi.Input<string>;
        /**
         * An integer representing the anonymous group id with a default value of 65534.
         * Anon_gid may only be set with squashMode of ROOT_SQUASH. An error will be returned
         * if this field is specified for other squashMode settings.
         */
        anonGid?: pulumi.Input<number>;
        /**
         * An integer representing the anonymous user id with a default value of 65534.
         * Anon_uid may only be set with squashMode of ROOT_SQUASH. An error will be returned
         * if this field is specified for other squashMode settings.
         */
        anonUid?: pulumi.Input<number>;
        /**
         * List of either IPv4 addresses, or ranges in CIDR notation which may mount the file share.
         * Overlapping IP ranges are not allowed, both within and across NfsExportOptions. An error will be returned.
         * The limit is 64 IP ranges/addresses for each FileShareConfig among all NfsExportOptions.
         */
        ipRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Either NO_ROOT_SQUASH, for allowing root access on the exported directory, or ROOT_SQUASH,
         * for not allowing root access. The default is NO_ROOT_SQUASH.
         * Default value is `NO_ROOT_SQUASH`.
         * Possible values are: `NO_ROOT_SQUASH`, `ROOT_SQUASH`.
         */
        squashMode?: pulumi.Input<string>;
    }

    export interface InstanceInitialReplication {
        /**
         * The replication role.
         * Structure is documented below.
         */
        replicas?: pulumi.Input<pulumi.Input<inputs.filestore.InstanceInitialReplicationReplica>[]>;
        /**
         * The replication role.
         * Default value is `STANDBY`.
         * Possible values are: `ROLE_UNSPECIFIED`, `ACTIVE`, `STANDBY`.
         */
        role?: pulumi.Input<string>;
    }

    export interface InstanceInitialReplicationReplica {
        /**
         * The peer instance.
         */
        peerInstance: pulumi.Input<string>;
    }

    export interface InstanceNetwork {
        /**
         * The network connect mode of the Filestore instance.
         * If not provided, the connect mode defaults to
         * DIRECT_PEERING.
         * Default value is `DIRECT_PEERING`.
         * Possible values are: `DIRECT_PEERING`, `PRIVATE_SERVICE_ACCESS`.
         *
         * - - -
         */
        connectMode?: pulumi.Input<string>;
        /**
         * (Output)
         * A list of IPv4 or IPv6 addresses.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * IP versions for which the instance has
         * IP addresses assigned.
         * Each value may be one of: `ADDRESS_MODE_UNSPECIFIED`, `MODE_IPV4`, `MODE_IPV6`.
         */
        modes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the GCE VPC network to which the
         * instance is connected.
         */
        network: pulumi.Input<string>;
        /**
         * A /29 CIDR block that identifies the range of IP
         * addresses reserved for this instance.
         */
        reservedIpRange?: pulumi.Input<string>;
    }

    export interface InstancePerformanceConfig {
        /**
         * The instance will have a fixed provisioned IOPS value,
         * which will remain constant regardless of instance
         * capacity.
         * Structure is documented below.
         */
        fixedIops?: pulumi.Input<inputs.filestore.InstancePerformanceConfigFixedIops>;
        /**
         * The instance provisioned IOPS will change dynamically
         * based on the capacity of the instance.
         * Structure is documented below.
         */
        iopsPerTb?: pulumi.Input<inputs.filestore.InstancePerformanceConfigIopsPerTb>;
    }

    export interface InstancePerformanceConfigFixedIops {
        /**
         * The number of IOPS to provision for the instance.
         * maxIops must be in multiple of 1000.
         */
        maxIops?: pulumi.Input<number>;
    }

    export interface InstancePerformanceConfigIopsPerTb {
        /**
         * The instance max IOPS will be calculated by multiplying
         * the capacity of the instance (TB) by max_iops_per_tb,
         * and rounding to the nearest 1000. The instance max IOPS
         * will be changed dynamically based on the instance
         * capacity.
         */
        maxIopsPerTb?: pulumi.Input<number>;
    }
}

export namespace firebase {
    export interface AppHostingBackendCodebase {
        /**
         * The resource name for the Developer Connect
         * [`gitRepositoryLink`](https://cloud.google.com/developer-connect/docs/api/reference/rest/v1/projects.locations.connections.gitRepositoryLinks)
         * connected to this backend, in the format:
         * projects/{project}/locations/{location}/connections/{connection}/gitRepositoryLinks/{repositoryLink}
         */
        repository: pulumi.Input<string>;
        /**
         * If `repository` is provided, the directory relative to the root of the
         * repository to use as the root for the deployed web app.
         */
        rootDirectory?: pulumi.Input<string>;
    }

    export interface AppHostingBackendManagedResource {
        /**
         * (Output)
         * A managed Cloud Run
         * [`service`](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services#resource:-service).
         * Structure is documented below.
         */
        runServices?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingBackendManagedResourceRunService>[]>;
    }

    export interface AppHostingBackendManagedResourceRunService {
        /**
         * (Output)
         * The name of the Cloud Run
         * [`service`](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services#resource:-service),
         * in the format:
         * projects/{project}/locations/{location}/services/{serviceId}
         */
        service?: pulumi.Input<string>;
    }

    export interface AppHostingBuildError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details. There is a common set of
         * message types for APIs to use.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface AppHostingBuildSource {
        /**
         * A codebase source, representing the state of the codebase
         * that the build will be created at.
         * Structure is documented below.
         */
        codebase?: pulumi.Input<inputs.firebase.AppHostingBuildSourceCodebase>;
        /**
         * The URI of an Artifact Registry
         * [container
         * image](https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.dockerImages)
         * to use as the build source.
         * Structure is documented below.
         */
        container?: pulumi.Input<inputs.firebase.AppHostingBuildSourceContainer>;
    }

    export interface AppHostingBuildSourceCodebase {
        /**
         * (Output)
         * Version control metadata for a user associated with a resolved codebase.
         * Currently assumes a Git user.
         * Structure is documented below.
         */
        authors?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingBuildSourceCodebaseAuthor>[]>;
        /**
         * The branch in the codebase to build from, using the latest commit.
         */
        branch?: pulumi.Input<string>;
        /**
         * The commit in the codebase to build from.
         *
         *
         * <a name="nestedSourceCodebaseAuthor"></a>The `author` block contains:
         */
        commit?: pulumi.Input<string>;
        /**
         * (Output)
         * The message of a codebase change.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * (Output)
         * The time the change was made.
         */
        commitTime?: pulumi.Input<string>;
        /**
         * Human-readable name. 63 character limit.
         */
        displayName?: pulumi.Input<string>;
        /**
         * (Output)
         * The full SHA-1 hash of a Git commit, if available.
         */
        hash?: pulumi.Input<string>;
        /**
         * (Output)
         * A URI linking to the codebase on an hosting provider's website. May
         * not be valid if the commit has been rebased or force-pushed out of
         * existence in the linked repository.
         */
        uri?: pulumi.Input<string>;
    }

    export interface AppHostingBuildSourceCodebaseAuthor {
        /**
         * The 'name' field in a Git user's git.config. Required by Git.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The 'email' field in a Git user's git.config, if available.
         */
        email?: pulumi.Input<string>;
        /**
         * The URI of an image file associated with the user's account in an
         * external source control provider, if available.
         */
        imageUri?: pulumi.Input<string>;
    }

    export interface AppHostingBuildSourceContainer {
        /**
         * A URI representing a container for the backend to use.
         */
        image: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatus {
        /**
         * (Output)
         * Possible values:
         * CERT_PREPARING
         * CERT_VALIDATING
         * CERT_PROPAGATING
         * CERT_ACTIVE
         * CERT_EXPIRING_SOON
         * CERT_EXPIRED
         */
        certState?: pulumi.Input<string>;
        /**
         * (Output)
         * Possible values:
         * HOST_UNHOSTED
         * HOST_UNREACHABLE
         * HOST_NON_FAH
         * HOST_CONFLICT
         * HOST_WRONG_SHARD
         * HOST_ACTIVE
         */
        hostState?: pulumi.Input<string>;
        /**
         * (Output)
         * A list of issues with domain configuration. Allows users to self-correct
         * problems with DNS records.
         * Structure is documented below.
         */
        issues?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusIssue>[]>;
        /**
         * (Output)
         * Possible values:
         * OWNERSHIP_MISSING
         * OWNERSHIP_UNREACHABLE
         * OWNERSHIP_MISMATCH
         * OWNERSHIP_CONFLICT
         * OWNERSHIP_PENDING
         * OWNERSHIP_ACTIVE
         */
        ownershipState?: pulumi.Input<string>;
        /**
         * (Output)
         * Lists the records that must added or removed to a custom domain's DNS
         * in order to finish setup and start serving content.
         * Field is present during onboarding. Also present after onboarding if one
         * or more of the above states is not *_ACTIVE, indicating the domain's DNS
         * records are in a bad state.
         * Structure is documented below.
         */
        requiredDnsUpdates?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdate>[]>;
    }

    export interface AppHostingDomainCustomDomainStatusIssue {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdate {
        /**
         * (Output)
         * The last time App Hosting checked your custom domain's DNS records.
         */
        checkTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The set of DNS records App Hosting needs in order to be able to serve
         * secure content on the domain.
         * Structure is documented below.
         */
        desireds?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesired>[]>;
        /**
         * (Output)
         * The set of DNS records App Hosting discovered when inspecting a domain.
         * Structure is documented below.
         */
        discovereds?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscovered>[]>;
        /**
         * (Output)
         * The domain the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesired {
        /**
         * (Output)
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        checkErrors?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesiredCheckError>[]>;
        /**
         * (Output)
         * The domain the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * (Output)
         * Records on the domain.
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesiredRecord>[]>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesiredCheckError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDesiredRecord {
        /**
         * (Output)
         * The domain the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * (Output)
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain. App Hosting
         * uses TXT records to determine which Firebase projects have
         * permission to act on the domain's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * (Output)
         * An enum that indicates which state(s) this DNS record applies to. Populated
         * for all records with an `ADD` or `REMOVE` required action.
         */
        relevantStates?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * An enum that indicates the a required action for this record. Populated
         * when the record is part of a required change in a  `DnsUpdates`
         * `discovered` or `desired` record set.
         * Possible values:
         * NONE
         * ADD
         * REMOVE
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * (Output)
         * The record's type, which determines what data the record contains.
         * Possible values:
         * A
         * CNAME
         * TXT
         * AAAA
         * CAA
         */
        type?: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscovered {
        /**
         * (Output)
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        checkErrors?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscoveredCheckError>[]>;
        /**
         * (Output)
         * The domain the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * (Output)
         * Records on the domain.
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscoveredRecord>[]>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscoveredCheckError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface AppHostingDomainCustomDomainStatusRequiredDnsUpdateDiscoveredRecord {
        /**
         * (Output)
         * The domain the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * (Output)
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain. App Hosting
         * uses TXT records to determine which Firebase projects have
         * permission to act on the domain's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * (Output)
         * An enum that indicates which state(s) this DNS record applies to. Populated
         * for all records with an `ADD` or `REMOVE` required action.
         */
        relevantStates?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * An enum that indicates the a required action for this record. Populated
         * when the record is part of a required change in a  `DnsUpdates`
         * `discovered` or `desired` record set.
         * Possible values:
         * NONE
         * ADD
         * REMOVE
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * (Output)
         * The record's type, which determines what data the record contains.
         * Possible values:
         * A
         * CNAME
         * TXT
         * AAAA
         * CAA
         */
        type?: pulumi.Input<string>;
    }

    export interface AppHostingDomainServe {
        /**
         * Specifies redirect behavior for a domain.
         * Structure is documented below.
         */
        redirect?: pulumi.Input<inputs.firebase.AppHostingDomainServeRedirect>;
    }

    export interface AppHostingDomainServeRedirect {
        /**
         * The status code to use in a redirect response. Must be a valid HTTP 3XX
         * status code. Defaults to 302 if not present.
         */
        status?: pulumi.Input<string>;
        /**
         * The URI of the redirect's intended destination. This URI will be
         * prepended to the original request path. URI without a scheme are
         * assumed to be HTTPS.
         */
        uri: pulumi.Input<string>;
    }

    export interface AppHostingTrafficCurrent {
        /**
         * (Output)
         * A list of traffic splits that together represent where traffic is being routed.
         * Structure is documented below.
         */
        splits?: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingTrafficCurrentSplit>[]>;
    }

    export interface AppHostingTrafficCurrentSplit {
        /**
         * The build that traffic is being routed to.
         */
        build?: pulumi.Input<string>;
        /**
         * The percentage of traffic to send to the build. Currently must be 100 or 0.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AppHostingTrafficRolloutPolicy {
        /**
         * Specifies a branch that triggers a new build to be started with this
         * policy. If not set, no automatic rollouts will happen.
         */
        codebaseBranch?: pulumi.Input<string>;
        /**
         * A flag that, if true, prevents rollouts from being created via this RolloutPolicy.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * If disabled is set, the time at which the rollouts were disabled.
         */
        disabledTime?: pulumi.Input<string>;
    }

    export interface AppHostingTrafficTarget {
        /**
         * A list of traffic splits that together represent where traffic is being routed.
         * Structure is documented below.
         */
        splits: pulumi.Input<pulumi.Input<inputs.firebase.AppHostingTrafficTargetSplit>[]>;
    }

    export interface AppHostingTrafficTargetSplit {
        /**
         * The build that traffic is being routed to.
         */
        build: pulumi.Input<string>;
        /**
         * The percentage of traffic to send to the build. Currently must be 100 or 0.
         */
        percent: pulumi.Input<number>;
    }

    export interface ExtensionsInstanceConfig {
        /**
         * List of extension events selected by consumer that extension is allowed to
         * emit, identified by their types.
         */
        allowedEventTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * The time at which the Extension Instance Config was created.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Fully qualified Eventarc resource name that consumers should use for event triggers.
         */
        eventarcChannel?: pulumi.Input<string>;
        /**
         * The ref of the Extension from the Registry (e.g. publisher-id/awesome-extension)
         */
        extensionRef: pulumi.Input<string>;
        /**
         * The version of the Extension from the Registry (e.g. 1.0.3). If left blank, latest is assumed.
         */
        extensionVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique identifier for this configuration.
         */
        name?: pulumi.Input<string>;
        /**
         * Environment variables that may be configured for the Extension
         */
        params: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * Postinstall instructions to be shown for this Extension, with
         * template strings representing function and parameter values substituted
         * with actual values. These strings include: ${param:FOO},
         * ${function:myFunc.url},
         * ${function:myFunc.name}, and ${function:myFunc.location}
         *
         * - - -
         */
        populatedPostinstallContent?: pulumi.Input<string>;
        /**
         * Params whose values are only available at deployment time.
         * Unlike other params, these will not be set as environment variables on
         * functions. See a full list of system parameters at
         * https://firebase.google.com/docs/extensions/publishers/parameters#system_parameters
         */
        systemParams?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ExtensionsInstanceErrorStatus {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * A developer-facing error message, which should be in English.
         */
        message?: pulumi.Input<string>;
    }

    export interface ExtensionsInstanceRuntimeData {
        /**
         * The fatal error state for the extension instance
         * Structure is documented below.
         */
        fatalError?: pulumi.Input<inputs.firebase.ExtensionsInstanceRuntimeDataFatalError>;
        /**
         * The processing state for the extension instance
         * Structure is documented below.
         */
        processingState?: pulumi.Input<inputs.firebase.ExtensionsInstanceRuntimeDataProcessingState>;
        /**
         * The time of the last state update.
         */
        stateUpdateTime?: pulumi.Input<string>;
    }

    export interface ExtensionsInstanceRuntimeDataFatalError {
        /**
         * The error message. This is set by the extension developer to give
         * more detail on why the extension is unusable and must be re-installed
         * or reconfigured.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface ExtensionsInstanceRuntimeDataProcessingState {
        /**
         * Details about the processing. e.g. This could include the type of
         * processing in progress or it could list errors or failures.
         * This information will be shown in the console on the detail page
         * for the extension instance.
         */
        detailMessage?: pulumi.Input<string>;
        /**
         * The processing state of the extension instance.
         */
        state?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainCert {
        /**
         * The state of the certificate. Only the `CERT_ACTIVE` and
         * `CERT_EXPIRING_SOON` states provide SSL coverage for a domain name. If the
         * state is `PROPAGATING` and Hosting had an active cert for the domain name
         * before, that formerly-active cert provides SSL coverage for the domain name
         * until the current cert propagates.
         */
        state?: pulumi.Input<string>;
        /**
         * The record's type, which determines what data the record contains.
         */
        type?: pulumi.Input<string>;
        /**
         * A set of ACME challenges you can add to your DNS records or existing,
         * non-Hosting hosting provider to allow Hosting to create an SSL certificate
         * for your domain name before you point traffic toward hosting. You can use
         * thse challenges as part of a zero downtime transition from your old
         * provider to Hosting.
         * Structure is documented below.
         */
        verification?: pulumi.Input<inputs.firebase.HostingCustomDomainCertVerification>;
    }

    export interface HostingCustomDomainCertVerification {
        /**
         * A `TXT` record to add to your DNS records that confirms your intent to
         * let Hosting create an SSL cert for your domain name.
         * Structure is documented below.
         */
        dns?: pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationDns>;
        /**
         * A file to add to your existing, non-Hosting hosting service that confirms
         * your intent to let Hosting create an SSL cert for your domain name.
         * Structure is documented below.
         */
        http?: pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationHttp>;
    }

    export interface HostingCustomDomainCertVerificationDns {
        /**
         * (Output)
         * The last time Hosting checked your CustomDomain's DNS records.
         */
        checkTime?: pulumi.Input<string>;
        /**
         * A text string to serve at the path.
         */
        desireds?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationDnsDesired>[]>;
        /**
         * Whether Hosting was able to find the required file contents on the
         * specified path during its last check.
         */
        discovereds?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationDnsDiscovered>[]>;
    }

    export interface HostingCustomDomainCertVerificationDnsDesired {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * Records on the domain
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationDnsDesiredRecord>[]>;
    }

    export interface HostingCustomDomainCertVerificationDnsDesiredRecord {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain name.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain name. Hosting
         * uses TXT records to determine a which Firebase Projects have
         * permission to act on the domain name's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * Indicates the a required action for this record.
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * The record's type, which determines what data the record contains.
         */
        type?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainCertVerificationDnsDiscovered {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * Records on the domain
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainCertVerificationDnsDiscoveredRecord>[]>;
    }

    export interface HostingCustomDomainCertVerificationDnsDiscoveredRecord {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain name.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain name. Hosting
         * uses TXT records to determine a which Firebase Projects have
         * permission to act on the domain name's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * Indicates the a required action for this record.
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * The record's type, which determines what data the record contains.
         */
        type?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainCertVerificationHttp {
        /**
         * A text string to serve at the path.
         */
        desired?: pulumi.Input<string>;
        /**
         * Whether Hosting was able to find the required file contents on the
         * specified path during its last check.
         */
        discovered?: pulumi.Input<string>;
        /**
         * (Output)
         * The last time Hosting systems checked for the file contents.
         */
        lastCheckTime?: pulumi.Input<string>;
        /**
         * The path to the file.
         */
        path?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainIssue {
        /**
         * The status code, which should be an enum value of `google.rpc.Code`
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<string>;
        /**
         * Error message
         */
        message?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainRequiredDnsUpdate {
        /**
         * (Output)
         * The last time Hosting checked your CustomDomain's DNS records.
         */
        checkTime?: pulumi.Input<string>;
        /**
         * A text string to serve at the path.
         */
        desireds?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainRequiredDnsUpdateDesired>[]>;
        /**
         * Whether Hosting was able to find the required file contents on the
         * specified path during its last check.
         */
        discovereds?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainRequiredDnsUpdateDiscovered>[]>;
    }

    export interface HostingCustomDomainRequiredDnsUpdateDesired {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * Records on the domain
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainRequiredDnsUpdateDesiredRecord>[]>;
    }

    export interface HostingCustomDomainRequiredDnsUpdateDesiredRecord {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain name.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain name. Hosting
         * uses TXT records to determine a which Firebase Projects have
         * permission to act on the domain name's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * Indicates the a required action for this record.
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * The record's type, which determines what data the record contains.
         */
        type?: pulumi.Input<string>;
    }

    export interface HostingCustomDomainRequiredDnsUpdateDiscovered {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * Records on the domain
         * Structure is documented below.
         */
        records?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainRequiredDnsUpdateDiscoveredRecord>[]>;
    }

    export interface HostingCustomDomainRequiredDnsUpdateDiscoveredRecord {
        /**
         * The domain name the record pertains to, e.g. `foo.bar.com.`.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The data of the record. The meaning of the value depends on record type:
         * - A and AAAA: IP addresses for the domain name.
         * - CNAME: Another domain to check for records.
         * - TXT: Arbitrary text strings associated with the domain name. Hosting
         * uses TXT records to determine a which Firebase Projects have
         * permission to act on the domain name's behalf.
         * - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
         */
        rdata?: pulumi.Input<string>;
        /**
         * Indicates the a required action for this record.
         */
        requiredAction?: pulumi.Input<string>;
        /**
         * The record's type, which determines what data the record contains.
         */
        type?: pulumi.Input<string>;
    }

    export interface HostingVersionConfig {
        /**
         * An array of objects, where each object specifies a URL pattern that, if matched to the request URL path,
         * triggers Hosting to apply the specified custom response headers.
         * Structure is documented below.
         */
        headers?: pulumi.Input<pulumi.Input<inputs.firebase.HostingVersionConfigHeader>[]>;
        /**
         * An array of objects (called redirect rules), where each rule specifies a URL pattern that, if matched to the request URL path,
         * triggers Hosting to respond with a redirect to the specified destination path.
         * Structure is documented below.
         */
        redirects?: pulumi.Input<pulumi.Input<inputs.firebase.HostingVersionConfigRedirect>[]>;
        /**
         * An array of objects (called rewrite rules), where each rule specifies a URL pattern that, if matched to the
         * request URL path, triggers Hosting to respond as if the service were given the specified destination URL.
         * Structure is documented below.
         */
        rewrites?: pulumi.Input<pulumi.Input<inputs.firebase.HostingVersionConfigRewrite>[]>;
    }

    export interface HostingVersionConfigHeader {
        /**
         * The user-supplied glob to match against the request URL path.
         */
        glob?: pulumi.Input<string>;
        /**
         * The additional headers to add to the response. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        headers: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The user-supplied RE2 regular expression to match against the request URL path.
         */
        regex?: pulumi.Input<string>;
    }

    export interface HostingVersionConfigRedirect {
        /**
         * The user-supplied glob to match against the request URL path.
         */
        glob?: pulumi.Input<string>;
        /**
         * The value to put in the HTTP location header of the response.
         * The location can contain capture group values from the pattern using a : prefix to identify
         * the segment and an optional * to capture the rest of the URL. For example:
         */
        location: pulumi.Input<string>;
        /**
         * The user-supplied RE2 regular expression to match against the request URL path.
         */
        regex?: pulumi.Input<string>;
        /**
         * The status HTTP code to return in the response. It must be a valid 3xx status code.
         */
        statusCode: pulumi.Input<number>;
    }

    export interface HostingVersionConfigRewrite {
        /**
         * The function to proxy requests to. Must match the exported function name exactly.
         */
        function?: pulumi.Input<string>;
        /**
         * The user-supplied glob to match against the request URL path.
         */
        glob?: pulumi.Input<string>;
        /**
         * The URL path to rewrite the request to.
         */
        path?: pulumi.Input<string>;
        /**
         * The user-supplied RE2 regular expression to match against the request URL path.
         */
        regex?: pulumi.Input<string>;
        /**
         * The request will be forwarded to Cloud Run.
         * Structure is documented below.
         */
        run?: pulumi.Input<inputs.firebase.HostingVersionConfigRewriteRun>;
    }

    export interface HostingVersionConfigRewriteRun {
        /**
         * Optional. User-provided region where the Cloud Run service is hosted. Defaults to `us-central1` if not supplied.
         */
        region?: pulumi.Input<string>;
        /**
         * User-defined ID of the Cloud Run service.
         */
        serviceId: pulumi.Input<string>;
    }
}

export namespace firebaserules {
    export interface RulesetMetadata {
        /**
         * Services that this ruleset has declarations for (e.g., "cloud.firestore"). There may be 0+ of these.
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RulesetSource {
        /**
         * `File` set constituting the `Source` bundle.
         */
        files: pulumi.Input<pulumi.Input<inputs.firebaserules.RulesetSourceFile>[]>;
        /**
         * `Language` of the `Source` bundle. If unspecified, the language will default to `FIREBASE_RULES`. Possible values: LANGUAGE_UNSPECIFIED, FIREBASE_RULES, EVENT_FLOW_TRIGGERS
         *
         * - - -
         */
        language?: pulumi.Input<string>;
    }

    export interface RulesetSourceFile {
        /**
         * Textual Content.
         */
        content: pulumi.Input<string>;
        /**
         * Fingerprint (e.g. github sha) associated with the `File`.
         */
        fingerprint?: pulumi.Input<string>;
        /**
         * File name.
         */
        name: pulumi.Input<string>;
    }
}

export namespace firestore {
    export interface BackupScheduleDailyRecurrence {
    }

    export interface BackupScheduleWeeklyRecurrence {
        /**
         * The day of week to run.
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day?: pulumi.Input<string>;
    }

    export interface DatabaseCmekConfig {
        /**
         * (Output)
         * Currently in-use KMS key versions (https://cloud.google.com/kms/docs/resource-hierarchy#key_versions).
         * During key rotation (https://cloud.google.com/kms/docs/key-rotation), there can be
         * multiple in-use key versions.
         * The expected format is
         * `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{key_version}`.
         */
        activeKeyVersions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The resource ID of a Cloud KMS key. If set, the database created will
         * be a Customer-managed Encryption Key (CMEK) database encrypted with
         * this key. This feature is allowlist only in initial launch.
         * Only keys in the same location as this database are allowed to be used
         * for encryption. For Firestore's nam5 multi-region, this corresponds to Cloud KMS
         * multi-region us. For Firestore's eur3 multi-region, this corresponds to
         * Cloud KMS multi-region europe. See https://cloud.google.com/kms/docs/locations.
         * This value should be the KMS key resource ID in the format of
         * `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
         * How to retrieve this resource ID is listed at
         * https://cloud.google.com/kms/docs/getting-resource-ids#getting_the_id_for_a_key_and_version.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface FieldIndexConfig {
        /**
         * The indexes to configure on the field. Order or array contains must be specified.
         * Structure is documented below.
         */
        indexes?: pulumi.Input<pulumi.Input<inputs.firestore.FieldIndexConfigIndex>[]>;
    }

    export interface FieldIndexConfigIndex {
        /**
         * Indicates that this field supports operations on arrayValues. Only one of `order` and `arrayConfig` can
         * be specified.
         * Possible values are: `CONTAINS`.
         */
        arrayConfig?: pulumi.Input<string>;
        /**
         * Indicates that this field supports ordering by the specified order or comparing using =, <, <=, >, >=, !=.
         * Only one of `order` and `arrayConfig` can be specified.
         * Possible values are: `ASCENDING`, `DESCENDING`.
         */
        order?: pulumi.Input<string>;
        /**
         * The scope at which a query is run. Collection scoped queries require you specify
         * the collection at query time. Collection group scope allows queries across all
         * collections with the same id.
         * Default value is `COLLECTION`.
         * Possible values are: `COLLECTION`, `COLLECTION_GROUP`.
         */
        queryScope?: pulumi.Input<string>;
    }

    export interface FieldTtlConfig {
        /**
         * (Output)
         * The state of TTL (time-to-live) configuration for documents that have this Field set.
         */
        state?: pulumi.Input<string>;
    }

    export interface IndexField {
        /**
         * Indicates that this field supports operations on arrayValues. Only one of `order`, `arrayConfig`, and
         * `vectorConfig` can be specified.
         * Possible values are: `CONTAINS`.
         */
        arrayConfig?: pulumi.Input<string>;
        /**
         * Name of the field.
         */
        fieldPath?: pulumi.Input<string>;
        /**
         * Indicates that this field supports ordering by the specified order or comparing using =, <, <=, >, >=.
         * Only one of `order`, `arrayConfig`, and `vectorConfig` can be specified.
         * Possible values are: `ASCENDING`, `DESCENDING`.
         */
        order?: pulumi.Input<string>;
        /**
         * Indicates that this field supports vector search operations. Only one of `order`, `arrayConfig`, and
         * `vectorConfig` can be specified. Vector Fields should come after the field path `__name__`.
         * Structure is documented below.
         */
        vectorConfig?: pulumi.Input<inputs.firestore.IndexFieldVectorConfig>;
    }

    export interface IndexFieldVectorConfig {
        /**
         * The resulting index will only include vectors of this dimension, and can be used for vector search
         * with the same dimension.
         */
        dimension?: pulumi.Input<number>;
        /**
         * Indicates the vector index is a flat index.
         *
         * - - -
         */
        flat?: pulumi.Input<inputs.firestore.IndexFieldVectorConfigFlat>;
    }

    export interface IndexFieldVectorConfigFlat {
    }
}

export namespace folder {
    export interface AccessApprovalSettingsEnrolledService {
        /**
         * The product for which Access Approval will be enrolled. Allowed values are listed (case-sensitive):
         * * all
         * * App Engine
         * * BigQuery
         * * Cloud Bigtable
         * * Cloud Key Management Service
         * * Compute Engine
         * * Cloud Dataflow
         * * Cloud Identity and Access Management
         * * Cloud Pub/Sub
         * * Cloud Storage
         * * Persistent Disk
         * Note: These values are supported as input, but considered a legacy format:
         * * all
         * * appengine.googleapis.com
         * * bigquery.googleapis.com
         * * bigtable.googleapis.com
         * * cloudkms.googleapis.com
         * * compute.googleapis.com
         * * dataflow.googleapis.com
         * * iam.googleapis.com
         * * pubsub.googleapis.com
         * * storage.googleapis.com
         */
        cloudProduct: pulumi.Input<string>;
        /**
         * The enrollment level of the service.
         * Default value is `BLOCK_ALL`.
         * Possible values are: `BLOCK_ALL`.
         *
         * - - -
         */
        enrollmentLevel?: pulumi.Input<string>;
    }

    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IamAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.  The format is the same as that for `members`.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        /**
         * or `deny` - (Optional) One or the other must be set.
         */
        allow?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyAllow>;
        /**
         * One or the other must be set.
         */
        deny?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         *
         * The `allow` or `deny` blocks support:
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace gemini {
    export interface CodeToolsSettingEnabledTool {
        /**
         * Link to the Dev Connect Account Connector that holds the user credentials.
         * projects/{project}/locations/{location}/accountConnectors/{account_connector_id}
         */
        accountConnector?: pulumi.Input<string>;
        /**
         * Configuration parameters for the tool.
         * Structure is documented below.
         */
        configs?: pulumi.Input<pulumi.Input<inputs.gemini.CodeToolsSettingEnabledToolConfig>[]>;
        /**
         * Handle used to invoke the tool.
         */
        handle: pulumi.Input<string>;
        /**
         * Link to the Tool
         */
        tool: pulumi.Input<string>;
        /**
         * Overridden URI, if allowed by Tool.
         */
        uriOverride?: pulumi.Input<string>;
    }

    export interface CodeToolsSettingEnabledToolConfig {
        /**
         * Key of the configuration item.
         */
        key: pulumi.Input<string>;
        /**
         * Value of the configuration item.
         *
         * - - -
         */
        value: pulumi.Input<string>;
    }

    export interface RepositoryGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryGroupRepository {
        /**
         * Required. The Git branch pattern used for indexing in RE2 syntax.
         * See https://github.com/google/re2/wiki/syntax for syntax.
         *
         * - - -
         */
        branchPattern: pulumi.Input<string>;
        /**
         * Required. The DeveloperConnect repository full resource name, relative resource name
         * or resource URL to be indexed.
         */
        resource: pulumi.Input<string>;
    }
}

export namespace gkebackup {
    export interface BackupPlanBackupConfig {
        /**
         * If True, include all namespaced resources.
         */
        allNamespaces?: pulumi.Input<boolean>;
        /**
         * This defines a customer managed encryption key that will be used to encrypt the "config"
         * portion (the Kubernetes resources) of Backups created via this plan.
         * Structure is documented below.
         */
        encryptionKey?: pulumi.Input<inputs.gkebackup.BackupPlanBackupConfigEncryptionKey>;
        /**
         * This flag specifies whether Kubernetes Secret resources should be included
         * when they fall into the scope of Backups.
         */
        includeSecrets?: pulumi.Input<boolean>;
        /**
         * This flag specifies whether volume data should be backed up when PVCs are
         * included in the scope of a Backup.
         */
        includeVolumeData?: pulumi.Input<boolean>;
        /**
         * This flag specifies whether Backups will not fail when
         * Backup for GKE detects Kubernetes configuration that is
         * non-standard or requires additional setup to restore.
         */
        permissiveMode?: pulumi.Input<boolean>;
        /**
         * A list of namespaced Kubernetes Resources.
         * Structure is documented below.
         */
        selectedApplications?: pulumi.Input<inputs.gkebackup.BackupPlanBackupConfigSelectedApplications>;
        /**
         * If set, include just the resources in the listed namespaces.
         * Structure is documented below.
         */
        selectedNamespaces?: pulumi.Input<inputs.gkebackup.BackupPlanBackupConfigSelectedNamespaces>;
    }

    export interface BackupPlanBackupConfigEncryptionKey {
        /**
         * Google Cloud KMS encryption key. Format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*
         */
        gcpKmsEncryptionKey: pulumi.Input<string>;
    }

    export interface BackupPlanBackupConfigSelectedApplications {
        /**
         * A list of namespaced Kubernetes resources.
         * Structure is documented below.
         */
        namespacedNames: pulumi.Input<pulumi.Input<inputs.gkebackup.BackupPlanBackupConfigSelectedApplicationsNamespacedName>[]>;
    }

    export interface BackupPlanBackupConfigSelectedApplicationsNamespacedName {
        /**
         * The name of a Kubernetes Resource.
         */
        name: pulumi.Input<string>;
        /**
         * The namespace of a Kubernetes Resource.
         */
        namespace: pulumi.Input<string>;
    }

    export interface BackupPlanBackupConfigSelectedNamespaces {
        /**
         * A list of Kubernetes Namespaces.
         */
        namespaces: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackupPlanBackupSchedule {
        /**
         * A standard cron string that defines a repeating schedule for
         * creating Backups via this BackupPlan.
         * This is mutually exclusive with the rpoConfig field since at most one
         * schedule can be defined for a BackupPlan.
         * If this is defined, then backupRetainDays must also be defined.
         */
        cronSchedule?: pulumi.Input<string>;
        /**
         * This flag denotes whether automatic Backup creation is paused for this BackupPlan.
         */
        paused?: pulumi.Input<boolean>;
        /**
         * Defines the RPO schedule configuration for this BackupPlan. This is mutually
         * exclusive with the cronSchedule field since at most one schedule can be defined
         * for a BackupPLan. If this is defined, then backupRetainDays must also be defined.
         * Structure is documented below.
         */
        rpoConfig?: pulumi.Input<inputs.gkebackup.BackupPlanBackupScheduleRpoConfig>;
    }

    export interface BackupPlanBackupScheduleRpoConfig {
        /**
         * User specified time windows during which backup can NOT happen for this BackupPlan.
         * Backups should start and finish outside of any given exclusion window. Note: backup
         * jobs will be scheduled to start and finish outside the duration of the window as
         * much as possible, but running jobs will not get canceled when it runs into the window.
         * All the time and date values in exclusionWindows entry in the API are in UTC. We
         * only allow <=1 recurrence (daily or weekly) exclusion window for a BackupPlan while no
         * restriction on number of single occurrence windows.
         * Structure is documented below.
         */
        exclusionWindows?: pulumi.Input<pulumi.Input<inputs.gkebackup.BackupPlanBackupScheduleRpoConfigExclusionWindow>[]>;
        /**
         * Defines the target RPO for the BackupPlan in minutes, which means the target
         * maximum data loss in time that is acceptable for this BackupPlan. This must be
         * at least 60, i.e., 1 hour, and at most 86400, i.e., 60 days.
         */
        targetRpoMinutes: pulumi.Input<number>;
    }

    export interface BackupPlanBackupScheduleRpoConfigExclusionWindow {
        /**
         * The exclusion window occurs every day if set to "True".
         * Specifying this field to "False" is an error.
         * Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
         */
        daily?: pulumi.Input<boolean>;
        /**
         * The exclusion window occurs on these days of each week in UTC.
         * Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
         * Structure is documented below.
         */
        daysOfWeek?: pulumi.Input<inputs.gkebackup.BackupPlanBackupScheduleRpoConfigExclusionWindowDaysOfWeek>;
        /**
         * Specifies duration of the window in seconds with up to nine fractional digits,
         * terminated by 's'. Example: "3.5s". Restrictions for duration based on the
         * recurrence type to allow some time for backup to happen:
         * - single_occurrence_date:  no restriction
         * - daily window: duration < 24 hours
         * - weekly window:
         * - days of week includes all seven days of a week: duration < 24 hours
         * - all other weekly window: duration < 168 hours (i.e., 24 * 7 hours)
         */
        duration: pulumi.Input<string>;
        /**
         * No recurrence. The exclusion window occurs only once and on this date in UTC.
         * Only one of singleOccurrenceDate, daily and daysOfWeek may be set.
         * Structure is documented below.
         */
        singleOccurrenceDate?: pulumi.Input<inputs.gkebackup.BackupPlanBackupScheduleRpoConfigExclusionWindowSingleOccurrenceDate>;
        /**
         * Specifies the start time of the window using time of the day in UTC.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.gkebackup.BackupPlanBackupScheduleRpoConfigExclusionWindowStartTime>;
    }

    export interface BackupPlanBackupScheduleRpoConfigExclusionWindowDaysOfWeek {
        /**
         * A list of days of week.
         * Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        daysOfWeeks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackupPlanBackupScheduleRpoConfigExclusionWindowSingleOccurrenceDate {
        /**
         * Day of a month.
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date.
         */
        year?: pulumi.Input<number>;
    }

    export interface BackupPlanBackupScheduleRpoConfigExclusionWindowStartTime {
        /**
         * Hours of day in 24 hour format.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface BackupPlanIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BackupPlanIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface BackupPlanRetentionPolicy {
        /**
         * Minimum age for a Backup created via this BackupPlan (in days).
         * Must be an integer value between 0-90 (inclusive).
         * A Backup created under this BackupPlan will not be deletable
         * until it reaches Backup's (create time + backup_delete_lock_days).
         * Updating this field of a BackupPlan does not affect existing Backups.
         * Backups created after a successful update will inherit this new value.
         */
        backupDeleteLockDays?: pulumi.Input<number>;
        /**
         * The default maximum age of a Backup created via this BackupPlan.
         * This field MUST be an integer value >= 0 and <= 365. If specified,
         * a Backup created under this BackupPlan will be automatically deleted
         * after its age reaches (createTime + backupRetainDays).
         * If not specified, Backups created under this BackupPlan will NOT be
         * subject to automatic deletion. Updating this field does NOT affect
         * existing Backups under it. Backups created AFTER a successful update
         * will automatically pick up the new value.
         * NOTE: backupRetainDays must be >= backupDeleteLockDays.
         * If cronSchedule is defined, then this must be <= 360 * the creation interval.
         * If rpoConfig is defined, then this must be
         * <= 360 * targetRpoMinutes/(1440minutes/day)
         */
        backupRetainDays?: pulumi.Input<number>;
        /**
         * This flag denotes whether the retention policy of this BackupPlan is locked.
         * If set to True, no further update is allowed on this policy, including
         * the locked field itself.
         */
        locked?: pulumi.Input<boolean>;
    }

    export interface RestorePlanIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RestorePlanIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfig {
        /**
         * If True, restore all namespaced resources in the Backup.
         * Setting this field to False will result in an error.
         */
        allNamespaces?: pulumi.Input<boolean>;
        /**
         * Defines the behavior for handling the situation where cluster-scoped resources
         * being restored already exist in the target cluster.
         * This MUST be set to a value other than `CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED`
         * if `clusterResourceRestoreScope` is anyting other than `noGroupKinds`.
         * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#clusterresourceconflictpolicy
         * for more information on each policy option.
         * Possible values are: `USE_EXISTING_VERSION`, `USE_BACKUP_VERSION`.
         */
        clusterResourceConflictPolicy?: pulumi.Input<string>;
        /**
         * Identifies the cluster-scoped resources to restore from the Backup.
         * Structure is documented below.
         */
        clusterResourceRestoreScope?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigClusterResourceRestoreScope>;
        /**
         * A list of selected namespaces excluded from restoration.
         * All namespaces except those in this list will be restored.
         * Structure is documented below.
         */
        excludedNamespaces?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigExcludedNamespaces>;
        /**
         * Defines the behavior for handling the situation where sets of namespaced resources
         * being restored already exist in the target cluster.
         * This MUST be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
         * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
         * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#namespacedresourcerestoremode
         * for more information on each mode.
         * Possible values are: `DELETE_AND_RESTORE`, `FAIL_ON_CONFLICT`, `MERGE_SKIP_ON_CONFLICT`, `MERGE_REPLACE_VOLUME_ON_CONFLICT`, `MERGE_REPLACE_ON_CONFLICT`.
         */
        namespacedResourceRestoreMode?: pulumi.Input<string>;
        /**
         * Do not restore any namespaced resources if set to "True".
         * Specifying this field to "False" is not allowed.
         */
        noNamespaces?: pulumi.Input<boolean>;
        /**
         * It contains custom ordering to use on a Restore.
         * Structure is documented below.
         */
        restoreOrder?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigRestoreOrder>;
        /**
         * A list of selected ProtectedApplications to restore.
         * The listed ProtectedApplications and all the resources
         * to which they refer will be restored.
         * Structure is documented below.
         */
        selectedApplications?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigSelectedApplications>;
        /**
         * A list of selected namespaces to restore from the Backup.
         * The listed Namespaces and all resources contained in them will be restored.
         * Structure is documented below.
         */
        selectedNamespaces?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigSelectedNamespaces>;
        /**
         * A list of transformation rules to be applied against Kubernetes
         * resources as they are selected for restoration from a Backup.
         * Rules are executed in order defined - this order matters,
         * as changes made by a rule may impact the filtering logic of subsequent
         * rules. An empty list means no transformation will occur.
         * Structure is documented below.
         */
        transformationRules?: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigTransformationRule>[]>;
        /**
         * Specifies the mechanism to be used to restore volume data.
         * This should be set to a value other than `NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED`
         * if the `namespacedResourceRestoreScope` is anything other than `noNamespaces`.
         * If not specified, it will be treated as `NO_VOLUME_DATA_RESTORATION`.
         * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
         * for more information on each policy option.
         * Possible values are: `RESTORE_VOLUME_DATA_FROM_BACKUP`, `REUSE_VOLUME_HANDLE_FROM_BACKUP`, `NO_VOLUME_DATA_RESTORATION`.
         */
        volumeDataRestorePolicy?: pulumi.Input<string>;
        /**
         * A table that binds volumes by their scope to a restore policy. Bindings
         * must have a unique scope. Any volumes not scoped in the bindings are
         * subject to the policy defined in volume_data_restore_policy.
         * Structure is documented below.
         */
        volumeDataRestorePolicyBindings?: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigVolumeDataRestorePolicyBinding>[]>;
    }

    export interface RestorePlanRestoreConfigClusterResourceRestoreScope {
        /**
         * If True, all valid cluster-scoped resources will be restored.
         * Mutually exclusive to any other field in `clusterResourceRestoreScope`.
         */
        allGroupKinds?: pulumi.Input<boolean>;
        /**
         * A list of cluster-scoped resource group kinds to NOT restore from the backup.
         * If specified, all valid cluster-scoped resources will be restored except
         * for those specified in the list.
         * Mutually exclusive to any other field in `clusterResourceRestoreScope`.
         * Structure is documented below.
         */
        excludedGroupKinds?: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKind>[]>;
        /**
         * If True, no cluster-scoped resources will be restored.
         * Mutually exclusive to any other field in `clusterResourceRestoreScope`.
         */
        noGroupKinds?: pulumi.Input<boolean>;
        /**
         * A list of cluster-scoped resource group kinds to restore from the backup.
         * If specified, only the selected resources will be restored.
         * Mutually exclusive to any other field in the `clusterResourceRestoreScope`.
         * Structure is documented below.
         */
        selectedGroupKinds?: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKind>[]>;
    }

    export interface RestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKind {
        /**
         * API Group string of a Kubernetes resource, e.g.
         * "apiextensions.k8s.io", "storage.k8s.io", etc.
         * Use empty string for core group.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * Kind of a Kubernetes resource, e.g.
         * "CustomResourceDefinition", "StorageClass", etc.
         */
        resourceKind?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKind {
        /**
         * API Group string of a Kubernetes resource, e.g.
         * "apiextensions.k8s.io", "storage.k8s.io", etc.
         * Use empty string for core group.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * Kind of a Kubernetes resource, e.g.
         * "CustomResourceDefinition", "StorageClass", etc.
         */
        resourceKind?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigExcludedNamespaces {
        /**
         * A list of Kubernetes Namespaces.
         */
        namespaces: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RestorePlanRestoreConfigRestoreOrder {
        /**
         * A list of group kind dependency pairs
         * that is used by Backup for GKE to
         * generate a group kind restore order.
         * Structure is documented below.
         */
        groupKindDependencies: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigRestoreOrderGroupKindDependency>[]>;
    }

    export interface RestorePlanRestoreConfigRestoreOrderGroupKindDependency {
        /**
         * The requiring group kind requires that the satisfying
         * group kind be restored first.
         * Structure is documented below.
         */
        requiring: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigRestoreOrderGroupKindDependencyRequiring>;
        /**
         * The satisfying group kind must be restored first
         * in order to satisfy the dependency.
         * Structure is documented below.
         */
        satisfying: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigRestoreOrderGroupKindDependencySatisfying>;
    }

    export interface RestorePlanRestoreConfigRestoreOrderGroupKindDependencyRequiring {
        /**
         * API Group of a Kubernetes resource, e.g.
         * "apiextensions.k8s.io", "storage.k8s.io", etc.
         * Use empty string for core group.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * Kind of a Kubernetes resource, e.g.
         * "CustomResourceDefinition", "StorageClass", etc.
         *
         * - - -
         */
        resourceKind?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigRestoreOrderGroupKindDependencySatisfying {
        /**
         * API Group of a Kubernetes resource, e.g.
         * "apiextensions.k8s.io", "storage.k8s.io", etc.
         * Use empty string for core group.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * Kind of a Kubernetes resource, e.g.
         * "CustomResourceDefinition", "StorageClass", etc.
         */
        resourceKind?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigSelectedApplications {
        /**
         * A list of namespaced Kubernetes resources.
         * Structure is documented below.
         */
        namespacedNames: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigSelectedApplicationsNamespacedName>[]>;
    }

    export interface RestorePlanRestoreConfigSelectedApplicationsNamespacedName {
        /**
         * The name of a Kubernetes Resource.
         */
        name: pulumi.Input<string>;
        /**
         * The namespace of a Kubernetes Resource.
         */
        namespace: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigSelectedNamespaces {
        /**
         * A list of Kubernetes Namespaces.
         */
        namespaces: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RestorePlanRestoreConfigTransformationRule {
        /**
         * The description is a user specified string description
         * of the transformation rule.
         */
        description?: pulumi.Input<string>;
        /**
         * A list of transformation rule actions to take against candidate
         * resources. Actions are executed in order defined - this order
         * matters, as they could potentially interfere with each other and
         * the first operation could affect the outcome of the second operation.
         * Structure is documented below.
         */
        fieldActions: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigTransformationRuleFieldAction>[]>;
        /**
         * This field is used to specify a set of fields that should be used to
         * determine which resources in backup should be acted upon by the
         * supplied transformation rule actions, and this will ensure that only
         * specific resources are affected by transformation rule actions.
         * Structure is documented below.
         */
        resourceFilter?: pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigTransformationRuleResourceFilter>;
    }

    export interface RestorePlanRestoreConfigTransformationRuleFieldAction {
        /**
         * A string containing a JSON Pointer value that references the
         * location in the target document to move the value from.
         */
        fromPath?: pulumi.Input<string>;
        /**
         * Specifies the operation to perform.
         * Possible values are: `REMOVE`, `MOVE`, `COPY`, `ADD`, `TEST`, `REPLACE`.
         */
        op: pulumi.Input<string>;
        /**
         * A string containing a JSON-Pointer value that references a
         * location within the target document where the operation is performed.
         */
        path?: pulumi.Input<string>;
        /**
         * A string that specifies the desired value in string format
         * to use for transformation.
         */
        value?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigTransformationRuleResourceFilter {
        /**
         * (Filtering parameter) Any resource subject to transformation must
         * belong to one of the listed "types". If this field is not provided,
         * no type filtering will be performed
         * (all resources of all types matching previous filtering parameters
         * will be candidates for transformation).
         * Structure is documented below.
         */
        groupKinds?: pulumi.Input<pulumi.Input<inputs.gkebackup.RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind>[]>;
        /**
         * This is a JSONPath expression that matches specific fields of
         * candidate resources and it operates as a filtering parameter
         * (resources that are not matched with this expression will not
         * be candidates for transformation).
         */
        jsonPath?: pulumi.Input<string>;
        /**
         * (Filtering parameter) Any resource subject to transformation must
         * be contained within one of the listed Kubernetes Namespace in the
         * Backup. If this field is not provided, no namespace filtering will
         * be performed (all resources in all Namespaces, including all
         * cluster-scoped resources, will be candidates for transformation).
         * To mix cluster-scoped and namespaced resources in the same rule,
         * use an empty string ("") as one of the target namespaces.
         */
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RestorePlanRestoreConfigTransformationRuleResourceFilterGroupKind {
        /**
         * API Group string of a Kubernetes resource, e.g.
         * "apiextensions.k8s.io", "storage.k8s.io", etc.
         * Use empty string for core group.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * Kind of a Kubernetes resource, e.g.
         * "CustomResourceDefinition", "StorageClass", etc.
         */
        resourceKind?: pulumi.Input<string>;
    }

    export interface RestorePlanRestoreConfigVolumeDataRestorePolicyBinding {
        /**
         * Specifies the mechanism to be used to restore this volume data.
         * See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
         * for more information on each policy option.
         * Possible values are: `RESTORE_VOLUME_DATA_FROM_BACKUP`, `REUSE_VOLUME_HANDLE_FROM_BACKUP`, `NO_VOLUME_DATA_RESTORATION`.
         */
        policy: pulumi.Input<string>;
        /**
         * The volume type, as determined by the PVC's
         * bound PV, to apply the policy to.
         * Possible values are: `GCE_PERSISTENT_DISK`.
         */
        volumeType: pulumi.Input<string>;
    }
}

export namespace gkehub {
    export interface FeatureFleetDefaultMemberConfig {
        /**
         * Config Management spec
         * Structure is documented below.
         */
        configmanagement?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigConfigmanagement>;
        /**
         * Service Mesh spec
         * Structure is documented below.
         */
        mesh?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigMesh>;
        /**
         * Policy Controller spec
         * Structure is documented below.
         */
        policycontroller?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontroller>;
    }

    export interface FeatureFleetDefaultMemberConfigConfigmanagement {
        /**
         * ConfigSync configuration for the cluster
         * Structure is documented below.
         */
        configSync?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigConfigmanagementConfigSync>;
        /**
         * Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
         * Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
         */
        management?: pulumi.Input<string>;
        /**
         * Version of Config Sync installed
         */
        version?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigConfigmanagementConfigSync {
        /**
         * Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Git repo configuration for the cluster
         * Structure is documented below.
         */
        git?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGit>;
        /**
         * The Email of the Google Cloud Service Account (GSA) used for exporting Config Sync metrics to Cloud Monitoring. The GSA should have the Monitoring Metric Writer(roles/monitoring.metricWriter) IAM role. The Kubernetes ServiceAccount `default` in the namespace `config-management-monitoring` should be bound to the GSA.
         */
        metricsGcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * OCI repo configuration for the cluster
         * Structure is documented below.
         */
        oci?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOci>;
        /**
         * Set to true to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
         */
        preventDrift?: pulumi.Input<boolean>;
        /**
         * Specifies whether the Config Sync Repo is in hierarchical or unstructured mode
         */
        sourceFormat?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGit {
        /**
         * The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
         */
        gcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * URL for the HTTPS Proxy to be used when communicating with the Git repo
         */
        httpsProxy?: pulumi.Input<string>;
        /**
         * The path within the Git repository that represents the top level of the repo to sync
         */
        policyDir?: pulumi.Input<string>;
        /**
         * Type of secret configured for access to the Git repo
         */
        secretType: pulumi.Input<string>;
        /**
         * The branch of the repository to sync from. Default: master
         */
        syncBranch?: pulumi.Input<string>;
        /**
         * The URL of the Git repository to use as the source of truth
         */
        syncRepo?: pulumi.Input<string>;
        /**
         * Git revision (tag or hash) to check out. Default HEAD
         */
        syncRev?: pulumi.Input<string>;
        /**
         * Period in seconds between consecutive syncs. Default: 15
         */
        syncWaitSecs?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOci {
        /**
         * The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
         */
        gcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * The absolute path of the directory that contains the local resources. Default: the root directory of the image
         */
        policyDir?: pulumi.Input<string>;
        /**
         * Type of secret configured for access to the Git repo
         */
        secretType: pulumi.Input<string>;
        /**
         * The OCI image repository URL for the package to sync from
         */
        syncRepo?: pulumi.Input<string>;
        /**
         * Period in seconds between consecutive syncs. Default: 15
         */
        syncWaitSecs?: pulumi.Input<string>;
        /**
         * (Optional, Deprecated)
         * Version of Config Sync installed
         *
         * > **Warning:** The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.
         *
         * @deprecated The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.
         */
        version?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigMesh {
        /**
         * Whether to automatically manage Service Mesh
         * Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
         */
        management: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontroller {
        /**
         * Configuration of Policy Controller
         * Structure is documented below.
         */
        policyControllerHubConfig: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfig>;
        /**
         * Configures the version of Policy Controller
         */
        version?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfig {
        /**
         * Interval for Policy Controller Audit scans (in seconds). When set to 0, this disables audit functionality altogether.
         */
        auditIntervalSeconds?: pulumi.Input<number>;
        /**
         * The maximum number of audit violations to be stored in a constraint. If not set, the internal default of 20 will be used.
         */
        constraintViolationLimit?: pulumi.Input<number>;
        /**
         * Map of deployment configs to deployments ("admission", "audit", "mutation").
         * Structure is documented below.
         */
        deploymentConfigs?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfig>[]>;
        /**
         * The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
         */
        exemptableNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configures the mode of the Policy Controller installation
         * Possible values are: `INSTALL_SPEC_UNSPECIFIED`, `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED`, `INSTALL_SPEC_DETACHED`.
         */
        installSpec: pulumi.Input<string>;
        /**
         * Logs all denies and dry run failures.
         */
        logDeniesEnabled?: pulumi.Input<boolean>;
        /**
         * Monitoring specifies the configuration of monitoring Policy Controller.
         * Structure is documented below.
         */
        monitoring?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoring>;
        /**
         * Enables the ability to mutate resources using Policy Controller.
         */
        mutationEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies the desired policy content on the cluster.
         * Structure is documented below.
         */
        policyContent?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContent>;
        /**
         * Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
         */
        referentialRulesEnabled?: pulumi.Input<boolean>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfig {
        /**
         * The identifier for this object. Format specified above.
         */
        component: pulumi.Input<string>;
        /**
         * Container resource requirements.
         * Structure is documented below.
         */
        containerResources?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResources>;
        /**
         * Pod affinity configuration.
         * Possible values are: `AFFINITY_UNSPECIFIED`, `NO_AFFINITY`, `ANTI_AFFINITY`.
         */
        podAffinity?: pulumi.Input<string>;
        /**
         * Pod tolerations of node taints.
         * Structure is documented below.
         */
        podTolerations?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodToleration>[]>;
        /**
         * Pod replica count.
         */
        replicaCount?: pulumi.Input<number>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResources {
        /**
         * Limits describes the maximum amount of compute resources allowed for use by the running container.
         * Structure is documented below.
         */
        limits?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimits>;
        /**
         * Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
         * Structure is documented below.
         */
        requests?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequests>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimits {
        /**
         * CPU requirement expressed in Kubernetes resource units.
         */
        cpu?: pulumi.Input<string>;
        /**
         * Memory requirement expressed in Kubernetes resource units.
         */
        memory?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequests {
        /**
         * CPU requirement expressed in Kubernetes resource units.
         */
        cpu?: pulumi.Input<string>;
        /**
         * Memory requirement expressed in Kubernetes resource units.
         */
        memory?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodToleration {
        /**
         * Matches a taint effect.
         */
        effect?: pulumi.Input<string>;
        /**
         * Matches a taint key (not necessarily unique).
         */
        key?: pulumi.Input<string>;
        /**
         * Matches a taint operator.
         */
        operator?: pulumi.Input<string>;
        /**
         * Matches a taint value.
         */
        value?: pulumi.Input<string>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoring {
        /**
         * Specifies the list of backends Policy Controller will export to. An empty list would effectively disable metrics export.
         * Each value may be one of: `MONITORING_BACKEND_UNSPECIFIED`, `PROMETHEUS`, `CLOUD_MONITORING`.
         */
        backends?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContent {
        /**
         * Configures which bundles to install and their corresponding install specs.
         * Structure is documented below.
         */
        bundles?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundle>[]>;
        /**
         * Configures the installation of the Template Library.
         * Structure is documented below.
         */
        templateLibrary?: pulumi.Input<inputs.gkehub.FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibrary>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundle {
        /**
         * The identifier for this object. Format specified above.
         */
        bundle: pulumi.Input<string>;
        /**
         * The set of namespaces to be exempted from the bundle.
         */
        exemptedNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibrary {
        /**
         * Configures the manner in which the template library is installed on the cluster.
         * Possible values are: `INSTALLATION_UNSPECIFIED`, `NOT_INSTALLED`, `ALL`.
         */
        installation?: pulumi.Input<string>;
    }

    export interface FeatureIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FeatureIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagement {
        /**
         * (Optional, Deprecated)
         * Binauthz configuration for the cluster. Structure is documented below.
         * This field will be ignored and should not be set.
         */
        binauthz?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementBinauthz>;
        /**
         * Config Sync configuration for the cluster. Structure is documented below.
         */
        configSync?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementConfigSync>;
        /**
         * Hierarchy Controller configuration for the cluster. Structure is documented below.
         * Configuring Hierarchy Controller through the configmanagement feature is no longer recommended.
         * Use open source Kubernetes [Hierarchical Namespace Controller (HNC)](https://github.com/kubernetes-sigs/hierarchical-namespaces) instead.
         * Follow the [instructions](https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/migrate-hierarchy-controller)
         * to migrate from Hierarchy Controller to HNC.
         */
        hierarchyController?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementHierarchyController>;
        /**
         * Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
         */
        management?: pulumi.Input<string>;
        /**
         * Policy Controller configuration for the cluster. Structure is documented below.
         * Configuring Policy Controller through the configmanagement feature is no longer recommended.
         * Use the policycontroller feature instead.
         */
        policyController?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementPolicyController>;
        /**
         * Version of Config Sync installed.
         */
        version?: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagementBinauthz {
        /**
         * Whether binauthz is enabled in this cluster.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface FeatureMembershipConfigmanagementConfigSync {
        /**
         * The override configurations for the Config Sync Deployments. Structure is documented below. The field is only available on Config Sync version 1.20.1 or later.
         */
        deploymentOverrides?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementConfigSyncDeploymentOverride>[]>;
        /**
         * Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Optional) Structure is documented below.
         */
        git?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementConfigSyncGit>;
        /**
         * Deprecated: If Workload Identity Federation for GKE is enabled, Google Cloud Service Account is no longer needed for exporting Config Sync metrics: https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/monitor-config-sync-cloud-monitoring#custom-monitoring.
         */
        metricsGcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * (Optional) Supported from Config Sync versions 1.12.0 onwards. Structure is documented below.
         *
         * Use either `git` or `oci` config option.
         */
        oci?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementConfigSyncOci>;
        /**
         * Supported from Config Sync versions 1.10.0 onwards. Set to `true` to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
         */
        preventDrift?: pulumi.Input<boolean>;
        /**
         * Specifies whether the Config Sync Repo is in "hierarchical" or "unstructured" mode.
         */
        sourceFormat?: pulumi.Input<string>;
        /**
         * Set to `true` to stop syncing configurations for a single cluster. This field is only available on clusters using Config Sync [auto-upgrades](http://cloud/kubernetes-engine/enterprise/config-sync/docs/how-to/upgrade-config-sync#auto-upgrade-config) or on Config Sync version 1.20.0 or later. Defaults: `false`.
         */
        stopSyncing?: pulumi.Input<boolean>;
    }

    export interface FeatureMembershipConfigmanagementConfigSyncDeploymentOverride {
        /**
         * The override configurations for the containers in the Deployment. Structure is documented below.
         */
        containers?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainer>[]>;
        /**
         * The name of the Deployment.
         */
        deploymentName?: pulumi.Input<string>;
        /**
         * The namespace of the Deployment.
         */
        deploymentNamespace?: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainer {
        /**
         * The name of the container.
         */
        containerName?: pulumi.Input<string>;
        /**
         * The CPU limit of the container.
         */
        cpuLimit?: pulumi.Input<string>;
        /**
         * The CPU request of the container.
         */
        cpuRequest?: pulumi.Input<string>;
        /**
         * The memory limit of the container.
         */
        memoryLimit?: pulumi.Input<string>;
        /**
         * The memory request of the container.
         */
        memoryRequest?: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagementConfigSyncGit {
        /**
         * The GCP Service Account Email used for auth when secretType is gcpServiceAccount.
         */
        gcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * URL for the HTTPS proxy to be used when communicating with the Git repo.
         */
        httpsProxy?: pulumi.Input<string>;
        /**
         * The path within the Git repository that represents the top level of the repo to sync. Default: the root directory of the repository.
         */
        policyDir?: pulumi.Input<string>;
        /**
         * Type of secret configured for access to the Git repo.
         */
        secretType?: pulumi.Input<string>;
        /**
         * The branch of the repository to sync from. Default: master.
         */
        syncBranch?: pulumi.Input<string>;
        /**
         * The URL of the Git repository to use as the source of truth.
         */
        syncRepo?: pulumi.Input<string>;
        /**
         * Git revision (tag or hash) to check out. Default HEAD.
         */
        syncRev?: pulumi.Input<string>;
        /**
         * Period in seconds between consecutive syncs. Default: 15.
         */
        syncWaitSecs?: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagementConfigSyncOci {
        /**
         * The GCP Service Account Email used for auth when secretType is gcpserviceaccount.
         */
        gcpServiceAccountEmail?: pulumi.Input<string>;
        /**
         * The absolute path of the directory that contains the local resources. Default: the root directory of the image.
         */
        policyDir?: pulumi.Input<string>;
        /**
         * Type of secret configured for access to the OCI Image. Must be one of gcenode, gcpserviceaccount or none.
         */
        secretType?: pulumi.Input<string>;
        /**
         * The OCI image repository URL for the package to sync from. e.g. LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME.
         */
        syncRepo?: pulumi.Input<string>;
        /**
         * Period in seconds(int64 format) between consecutive syncs. Default: 15.
         */
        syncWaitSecs?: pulumi.Input<string>;
    }

    export interface FeatureMembershipConfigmanagementHierarchyController {
        /**
         * Whether hierarchical resource quota is enabled in this cluster.
         */
        enableHierarchicalResourceQuota?: pulumi.Input<boolean>;
        /**
         * Whether pod tree labels are enabled in this cluster.
         */
        enablePodTreeLabels?: pulumi.Input<boolean>;
        /**
         * Whether Hierarchy Controller is enabled in this cluster.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface FeatureMembershipConfigmanagementPolicyController {
        /**
         * Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
         */
        auditIntervalSeconds?: pulumi.Input<string>;
        /**
         * Enables the installation of Policy Controller. If false, the rest of PolicyController fields take no effect.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
         */
        exemptableNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Logs all denies and dry run failures.
         */
        logDeniesEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies the backends Policy Controller should export metrics to. For example, to specify metrics should be exported to Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring", "prometheus"]. Default: ["cloudmonitoring", "prometheus"]
         */
        monitoring?: pulumi.Input<inputs.gkehub.FeatureMembershipConfigmanagementPolicyControllerMonitoring>;
        /**
         * Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
         */
        mutationEnabled?: pulumi.Input<boolean>;
        /**
         * Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
         */
        referentialRulesEnabled?: pulumi.Input<boolean>;
        /**
         * Installs the default template library along with Policy Controller.
         */
        templateLibraryInstalled?: pulumi.Input<boolean>;
    }

    export interface FeatureMembershipConfigmanagementPolicyControllerMonitoring {
        /**
         * Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
         */
        backends?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureMembershipMesh {
        /**
         * **DEPRECATED** Whether to automatically manage Service Mesh control planes. Possible values: CONTROL_PLANE_MANAGEMENT_UNSPECIFIED, AUTOMATIC, MANUAL
         *
         * @deprecated Deprecated in favor of the `management` field
         */
        controlPlane?: pulumi.Input<string>;
        /**
         * Whether to automatically manage Service Mesh. Can either be `MANAGEMENT_AUTOMATIC` or `MANAGEMENT_MANUAL`.
         */
        management?: pulumi.Input<string>;
    }

    export interface FeatureMembershipPolicycontroller {
        /**
         * Policy Controller configuration for the cluster. Structure is documented below.
         */
        policyControllerHubConfig: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfig>;
        /**
         * Version of Policy Controller to install. Defaults to the latest version.
         */
        version?: pulumi.Input<string>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfig {
        /**
         * Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
         */
        auditIntervalSeconds?: pulumi.Input<number>;
        /**
         * The maximum number of audit violations to be stored in a constraint. If not set, the  default of 20 will be used.
         */
        constraintViolationLimit?: pulumi.Input<number>;
        /**
         * Map of deployment configs to deployments ("admission", "audit", "mutation").
         */
        deploymentConfigs?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfig>[]>;
        /**
         * The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
         */
        exemptableNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configures the mode of the Policy Controller installation. Must be one of `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED` or `INSTALL_SPEC_DETACHED`.
         */
        installSpec?: pulumi.Input<string>;
        /**
         * Logs all denies and dry run failures.
         */
        logDeniesEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies the backends Policy Controller should export metrics to. Structure is documented below.
         */
        monitoring?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoring>;
        /**
         * Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
         */
        mutationEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies the desired policy content on the cluster. Structure is documented below.
         */
        policyContent?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContent>;
        /**
         * Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
         */
        referentialRulesEnabled?: pulumi.Input<boolean>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfig {
        /**
         * The name of the component. One of `admission` `audit` or `mutation`
         */
        componentName: pulumi.Input<string>;
        /**
         * Container resource requirements.
         */
        containerResources?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResources>;
        /**
         * Pod affinity configuration. Possible values: AFFINITY_UNSPECIFIED, NO_AFFINITY, ANTI_AFFINITY
         */
        podAffinity?: pulumi.Input<string>;
        /**
         * Pod tolerations of node taints.
         */
        podTolerations?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodToleration>[]>;
        /**
         * Pod replica count.
         */
        replicaCount?: pulumi.Input<number>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResources {
        /**
         * Limits describes the maximum amount of compute resources allowed for use by the running container.
         */
        limits?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimits>;
        /**
         * Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
         */
        requests?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequests>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimits {
        /**
         * CPU requirement expressed in Kubernetes resource units.
         */
        cpu?: pulumi.Input<string>;
        /**
         * Memory requirement expressed in Kubernetes resource units.
         */
        memory?: pulumi.Input<string>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequests {
        /**
         * CPU requirement expressed in Kubernetes resource units.
         */
        cpu?: pulumi.Input<string>;
        /**
         * Memory requirement expressed in Kubernetes resource units.
         */
        memory?: pulumi.Input<string>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodToleration {
        /**
         * Matches a taint effect.
         */
        effect?: pulumi.Input<string>;
        /**
         * Matches a taint key (not necessarily unique).
         */
        key?: pulumi.Input<string>;
        /**
         * Matches a taint operator.
         */
        operator?: pulumi.Input<string>;
        /**
         * Matches a taint value.
         */
        value?: pulumi.Input<string>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoring {
        /**
         * Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
         */
        backends?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContent {
        /**
         * map of bundle name to BundleInstallSpec. The bundle name maps to the `bundleName` key in the `policycontroller.gke.io/constraintData` annotation on a constraint.
         */
        bundles?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundle>[]>;
        /**
         * Configures the installation of the Template Library. Structure is documented below.
         */
        templateLibrary?: pulumi.Input<inputs.gkehub.FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibrary>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundle {
        /**
         * The name of the bundle.
         */
        bundleName: pulumi.Input<string>;
        /**
         * The set of namespaces to be exempted from the bundle.
         */
        exemptedNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibrary {
        /**
         * Configures the manner in which the template library is installed on the cluster. Must be one of `ALL`, `NOT_INSTALLED` or `INSTALLATION_UNSPECIFIED`. Defaults to `ALL`.
         */
        installation?: pulumi.Input<string>;
    }

    export interface FeatureResourceState {
        /**
         * (Output)
         * Whether this Feature has outstanding resources that need to be cleaned up before it can be disabled.
         */
        hasResources?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Output only. The "running state" of the Feature in this Hub.
         * Structure is documented below.
         */
        state?: pulumi.Input<string>;
    }

    export interface FeatureSpec {
        /**
         * Clusterupgrade feature spec.
         * Structure is documented below.
         */
        clusterupgrade?: pulumi.Input<inputs.gkehub.FeatureSpecClusterupgrade>;
        /**
         * Fleet Observability feature spec.
         * Structure is documented below.
         */
        fleetobservability?: pulumi.Input<inputs.gkehub.FeatureSpecFleetobservability>;
        /**
         * Multicluster Ingress-specific spec.
         * Structure is documented below.
         */
        multiclusteringress?: pulumi.Input<inputs.gkehub.FeatureSpecMulticlusteringress>;
    }

    export interface FeatureSpecClusterupgrade {
        /**
         * Configuration overrides for individual upgrades.
         * Structure is documented below.
         */
        gkeUpgradeOverrides?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureSpecClusterupgradeGkeUpgradeOverride>[]>;
        /**
         * Post conditions to override for the specified upgrade.
         * Structure is documented below.
         */
        postConditions?: pulumi.Input<inputs.gkehub.FeatureSpecClusterupgradePostConditions>;
        /**
         * Specified if other fleet should be considered as a source of upgrades. Currently, at most one upstream fleet is allowed. The fleet name should be either fleet project number or id.
         */
        upstreamFleets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureSpecClusterupgradeGkeUpgradeOverride {
        /**
         * Post conditions to override for the specified upgrade.
         * Structure is documented below.
         */
        postConditions: pulumi.Input<inputs.gkehub.FeatureSpecClusterupgradeGkeUpgradeOverridePostConditions>;
        /**
         * Which upgrade to override.
         * Structure is documented below.
         */
        upgrade: pulumi.Input<inputs.gkehub.FeatureSpecClusterupgradeGkeUpgradeOverrideUpgrade>;
    }

    export interface FeatureSpecClusterupgradeGkeUpgradeOverridePostConditions {
        /**
         * Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
         */
        soaking: pulumi.Input<string>;
    }

    export interface FeatureSpecClusterupgradeGkeUpgradeOverrideUpgrade {
        /**
         * Name of the upgrade, e.g., "k8sControlPlane". It should be a valid upgrade name. It must not exceet 99 characters.
         */
        name: pulumi.Input<string>;
        /**
         * Version of the upgrade, e.g., "1.22.1-gke.100". It should be a valid version. It must not exceet 99 characters.
         */
        version: pulumi.Input<string>;
    }

    export interface FeatureSpecClusterupgradePostConditions {
        /**
         * Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
         */
        soaking: pulumi.Input<string>;
    }

    export interface FeatureSpecFleetobservability {
        /**
         * Specified if fleet logging feature is enabled for the entire fleet. If UNSPECIFIED, fleet logging feature is disabled for the entire fleet.
         * Structure is documented below.
         */
        loggingConfig?: pulumi.Input<inputs.gkehub.FeatureSpecFleetobservabilityLoggingConfig>;
    }

    export interface FeatureSpecFleetobservabilityLoggingConfig {
        /**
         * Specified if applying the default routing config to logs not specified in other configs.
         * Structure is documented below.
         */
        defaultConfig?: pulumi.Input<inputs.gkehub.FeatureSpecFleetobservabilityLoggingConfigDefaultConfig>;
        /**
         * Specified if applying the routing config to all logs for all fleet scopes.
         * Structure is documented below.
         */
        fleetScopeLogsConfig?: pulumi.Input<inputs.gkehub.FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfig>;
    }

    export interface FeatureSpecFleetobservabilityLoggingConfigDefaultConfig {
        /**
         * Specified if fleet logging feature is enabled.
         * Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfig {
        /**
         * Specified if fleet logging feature is enabled.
         * Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface FeatureSpecMulticlusteringress {
        /**
         * Fully-qualified Membership name which hosts the MultiClusterIngress CRD. Example: `projects/foo-proj/locations/global/memberships/bar`
         */
        configMembership: pulumi.Input<string>;
    }

    export interface FeatureState {
        /**
         * (Output)
         * Output only. The "running state" of the Feature in this Hub.
         * Structure is documented below.
         */
        states?: pulumi.Input<pulumi.Input<inputs.gkehub.FeatureStateState>[]>;
    }

    export interface FeatureStateState {
        /**
         * (Output)
         * The high-level, machine-readable status of this Feature.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * A human-readable description of the current status.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * The time this status and any related Feature-specific details were updated. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface FleetDefaultClusterConfig {
        /**
         * Enable/Disable binary authorization features for the cluster.
         * Structure is documented below.
         */
        binaryAuthorizationConfig?: pulumi.Input<inputs.gkehub.FleetDefaultClusterConfigBinaryAuthorizationConfig>;
        /**
         * Enable/Disable Security Posture features for the cluster.
         * Structure is documented below.
         */
        securityPostureConfig?: pulumi.Input<inputs.gkehub.FleetDefaultClusterConfigSecurityPostureConfig>;
    }

    export interface FleetDefaultClusterConfigBinaryAuthorizationConfig {
        /**
         * Mode of operation for binauthz policy evaluation.
         * Possible values are: `DISABLED`, `POLICY_BINDINGS`.
         */
        evaluationMode?: pulumi.Input<string>;
        /**
         * Binauthz policies that apply to this cluster.
         * Structure is documented below.
         */
        policyBindings?: pulumi.Input<pulumi.Input<inputs.gkehub.FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBinding>[]>;
    }

    export interface FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBinding {
        /**
         * The relative resource name of the binauthz platform policy to audit. GKE
         * platform policies have the following format:
         * `projects/{project_number}/platforms/gke/policies/{policy_id}`.
         */
        name?: pulumi.Input<string>;
    }

    export interface FleetDefaultClusterConfigSecurityPostureConfig {
        /**
         * Sets which mode to use for Security Posture features.
         * Possible values are: `DISABLED`, `BASIC`, `ENTERPRISE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Sets which mode to use for vulnerability scanning.
         * Possible values are: `VULNERABILITY_DISABLED`, `VULNERABILITY_BASIC`, `VULNERABILITY_ENTERPRISE`.
         */
        vulnerabilityMode?: pulumi.Input<string>;
    }

    export interface FleetState {
        /**
         * (Output)
         * Describes the state of a Fleet resource.
         */
        code?: pulumi.Input<string>;
    }

    export interface MembershipAuthority {
        issuer: pulumi.Input<string>;
    }

    export interface MembershipBindingState {
        /**
         * (Output)
         * Code describes the state of a MembershipBinding resource.
         */
        code?: pulumi.Input<string>;
    }

    export interface MembershipEndpoint {
        /**
         * If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource.
         * Structure is documented below.
         */
        gkeCluster?: pulumi.Input<inputs.gkehub.MembershipEndpointGkeCluster>;
    }

    export interface MembershipEndpointGkeCluster {
        resourceLink: pulumi.Input<string>;
    }

    export interface MembershipIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MembershipIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface MembershipRbacRoleBindingRole {
        /**
         * PredefinedRole is an ENUM representation of the default Kubernetes Roles
         * Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`, `ANTHOS_SUPPORT`.
         *
         * - - -
         */
        predefinedRole: pulumi.Input<string>;
    }

    export interface MembershipRbacRoleBindingState {
        /**
         * (Output)
         * Code describes the state of a RBAC Role Binding resource.
         */
        code?: pulumi.Input<string>;
    }

    export interface NamespaceState {
        /**
         * (Output)
         * Code describes the state of a Namespace resource.
         */
        code?: pulumi.Input<string>;
    }

    export interface ScopeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ScopeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ScopeRbacRoleBindingRole {
        /**
         * PredefinedRole is an ENUM representation of the default Kubernetes Roles
         * Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`.
         *
         * - - -
         */
        predefinedRole?: pulumi.Input<string>;
    }

    export interface ScopeRbacRoleBindingState {
        /**
         * (Output)
         * Code describes the state of a RBAC Role Binding resource.
         */
        code?: pulumi.Input<string>;
    }

    export interface ScopeState {
        /**
         * (Output)
         * Code describes the state of a Scope resource.
         */
        code?: pulumi.Input<string>;
    }
}

export namespace gkeonprem {
    export interface BareMetalAdminClusterClusterOperations {
        /**
         * Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
         */
        enableApplicationLogs?: pulumi.Input<boolean>;
    }

    export interface BareMetalAdminClusterControlPlane {
        /**
         * Customizes the default API server args. Only a subset of
         * customized flags are supported. Please refer to the API server
         * documentation below to know the exact format:
         * https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
         * Structure is documented below.
         */
        apiServerArgs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterControlPlaneApiServerArg>[]>;
        /**
         * Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
         * Structure is documented below.
         */
        controlPlaneNodePoolConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig>;
    }

    export interface BareMetalAdminClusterControlPlaneApiServerArg {
        /**
         * The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
         */
        argument: pulumi.Input<string>;
        /**
         * The value of the arg as it will be passed to the API Server command line.
         */
        value: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig {
        /**
         * The generic configuration for a node pool running the control plane.
         * Structure is documented below.
         */
        nodePoolConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig>;
    }

    export interface BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The list of machine addresses in the Bare Metal Node Pool.
         * Structure is documented below.
         */
        nodeConfigs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig>[]>;
        /**
         * Specifies the nodes operating system (default: LINUX).
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint>[]>;
    }

    export interface BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default IPv4 address for SSH access and Kubernetes node.
         * Example: 192.168.0.1
         */
        nodeIp?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint {
        /**
         * Specifies the nodes operating system (default: LINUX).
         * Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key?: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterFleet {
        /**
         * (Output)
         * The name of the managed Hub Membership resource associated to this cluster.
         * Membership names are formatted as
         * `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterLoadBalancer {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        manualLbConfig?: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterLoadBalancerManualLbConfig>;
        /**
         * Specifies the load balancer ports.
         * Structure is documented below.
         */
        portConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterLoadBalancerPortConfig>;
        /**
         * Specified the Bare Metal Load Balancer Config
         * Structure is documented below.
         */
        vipConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterLoadBalancerVipConfig>;
    }

    export interface BareMetalAdminClusterLoadBalancerManualLbConfig {
        /**
         * Whether manual load balancing is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface BareMetalAdminClusterLoadBalancerPortConfig {
        /**
         * The port that control plane hosted load balancers will listen on.
         */
        controlPlaneLoadBalancerPort: pulumi.Input<number>;
    }

    export interface BareMetalAdminClusterLoadBalancerVipConfig {
        /**
         * The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
         */
        controlPlaneVip: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterMaintenanceConfig {
        /**
         * All IPv4 address from these ranges will be placed into maintenance mode.
         * Nodes in maintenance mode will be cordoned and drained. When both of these
         * are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
         * on the node resource.
         */
        maintenanceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BareMetalAdminClusterNetworkConfig {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        islandModeCidr?: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterNetworkConfigIslandModeCidr>;
    }

    export interface BareMetalAdminClusterNetworkConfigIslandModeCidr {
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BareMetalAdminClusterNodeAccessConfig {
        /**
         * LoginUser is the user name used to access node machines.
         * It defaults to "root" if not set.
         */
        loginUser?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterNodeConfig {
        /**
         * The maximum number of pods a node can run. The size of the CIDR range
         * assigned to the node will be derived from this parameter.
         */
        maxPodsPerNode?: pulumi.Input<number>;
    }

    export interface BareMetalAdminClusterProxy {
        /**
         * A list of IPs, hostnames, and domains that should skip the proxy.
         * For example: ["127.0.0.1", "example.com", ".corp", "localhost"].
         */
        noProxies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the address of your proxy server.
         * For Example: http://domain
         * WARNING: Do not provide credentials in the format
         * of http://(username:password@)domain these will be rejected by the server.
         */
        uri: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterSecurityConfig {
        /**
         * Configures user access to the Bare Metal User cluster.
         * Structure is documented below.
         */
        authorization?: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterSecurityConfigAuthorization>;
    }

    export interface BareMetalAdminClusterSecurityConfigAuthorization {
        /**
         * Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
         * Structure is documented below.
         */
        adminUsers: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser>[]>;
    }

    export interface BareMetalAdminClusterSecurityConfigAuthorizationAdminUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the admin cluster
         * controller. The error message can be temporary as the admin cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A human-readable message of the check failure.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterStorage {
        /**
         * Specifies the config for local PersistentVolumes backed
         * by mounted node disks. These disks need to be formatted and mounted by the
         * user, which can be done before or after cluster creation.
         * Structure is documented below.
         */
        lvpNodeMountsConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterStorageLvpNodeMountsConfig>;
        /**
         * Specifies the config for local PersistentVolumes backed by
         * subdirectories in a shared filesystem. These subdirectores are
         * automatically created during cluster creation.
         * Structure is documented below.
         */
        lvpShareConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterStorageLvpShareConfig>;
    }

    export interface BareMetalAdminClusterStorageLvpNodeMountsConfig {
        /**
         * The host machine path.
         */
        path: pulumi.Input<string>;
        /**
         * The StorageClass name that PVs will be created with.
         */
        storageClass: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterStorageLvpShareConfig {
        /**
         * Defines the machine path and storage class for the LVP Share.
         * Structure is documented below.
         */
        lvpConfig: pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterStorageLvpShareConfigLvpConfig>;
        /**
         * The number of subdirectories to create under path.
         */
        sharedPathPvCount?: pulumi.Input<number>;
    }

    export interface BareMetalAdminClusterStorageLvpShareConfigLvpConfig {
        /**
         * The host machine path.
         */
        path: pulumi.Input<string>;
        /**
         * The StorageClass name that PVs will be created with.
         */
        storageClass: pulumi.Input<string>;
    }

    export interface BareMetalAdminClusterValidationCheck {
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * The scenario when the preflight checks were run..
         */
        scenario?: pulumi.Input<string>;
        /**
         * (Output)
         * Specifies the detailed validation check status
         * Structure is documented below.
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterValidationCheckStatus>[]>;
    }

    export interface BareMetalAdminClusterValidationCheckStatus {
        /**
         * (Output)
         * Individual checks which failed as part of the Preflight check execution.
         * Structure is documented below.
         */
        results?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalAdminClusterValidationCheckStatusResult>[]>;
    }

    export interface BareMetalAdminClusterValidationCheckStatusResult {
        /**
         * (Output)
         * The category of the validation.
         */
        category?: pulumi.Input<string>;
        /**
         * A human readable description of this Bare Metal Admin Cluster.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Detailed failure information, which might be unformatted.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * A human-readable message of the check failure.
         */
        reason?: pulumi.Input<string>;
    }

    export interface BareMetalClusterBinaryAuthorization {
        /**
         * Mode of operation for binauthz policy evaluation. If unspecified,
         * defaults to DISABLED.
         * Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
         */
        evaluationMode?: pulumi.Input<string>;
    }

    export interface BareMetalClusterClusterOperations {
        /**
         * Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
         */
        enableApplicationLogs?: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterControlPlane {
        /**
         * Customizes the default API server args. Only a subset of
         * customized flags are supported. Please refer to the API server
         * documentation below to know the exact format:
         * https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
         * Structure is documented below.
         */
        apiServerArgs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterControlPlaneApiServerArg>[]>;
        /**
         * Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
         * Structure is documented below.
         */
        controlPlaneNodePoolConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterControlPlaneControlPlaneNodePoolConfig>;
    }

    export interface BareMetalClusterControlPlaneApiServerArg {
        /**
         * The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
         */
        argument: pulumi.Input<string>;
        /**
         * The value of the arg as it will be passed to the API Server command line.
         */
        value: pulumi.Input<string>;
    }

    export interface BareMetalClusterControlPlaneControlPlaneNodePoolConfig {
        /**
         * The generic configuration for a node pool running the control plane.
         * Structure is documented below.
         */
        nodePoolConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig>;
    }

    export interface BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The list of machine addresses in the Bare Metal Node Pool.
         * Structure is documented below.
         */
        nodeConfigs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig>[]>;
        /**
         * Specifies the nodes operating system (default: LINUX).
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint>[]>;
    }

    export interface BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default IPv4 address for SSH access and Kubernetes node.
         * Example: 192.168.0.1
         */
        nodeIp?: pulumi.Input<string>;
    }

    export interface BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint {
        /**
         * Specifies the nodes operating system (default: LINUX).
         * Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key?: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value?: pulumi.Input<string>;
    }

    export interface BareMetalClusterFleet {
        /**
         * (Output)
         * The name of the managed Hub Membership resource associated to this cluster.
         * Membership names are formatted as
         * `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancer {
        /**
         * Configuration for BGP typed load balancers.
         * Structure is documented below.
         */
        bgpLbConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfig>;
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        manualLbConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerManualLbConfig>;
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        metalLbConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfig>;
        /**
         * Specifies the load balancer ports.
         * Structure is documented below.
         */
        portConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerPortConfig>;
        /**
         * Specified the Bare Metal Load Balancer Config
         * Structure is documented below.
         */
        vipConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerVipConfig>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfig {
        /**
         * AddressPools is a list of non-overlapping IP pools used by load balancer
         * typed services. All addresses must be routable to load balancer nodes.
         * IngressVIP must be included in the pools.
         * Structure is documented below.
         */
        addressPools: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigAddressPool>[]>;
        /**
         * BGP autonomous system number (ASN) of the cluster.
         * This field can be updated after cluster creation.
         */
        asn: pulumi.Input<number>;
        /**
         * The list of BGP peers that the cluster will connect to.
         * At least one peer must be configured for each control plane node.
         * Control plane nodes will connect to these peers to advertise the control
         * plane VIP. The Services load balancer also uses these peers by default.
         * This field can be updated after cluster creation.
         * Structure is documented below.
         */
        bgpPeerConfigs: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig>[]>;
        /**
         * Specifies the node pool running data plane load balancing. L2 connectivity
         * is required among nodes in this pool. If missing, the control plane node
         * pool is used for data plane load balancing.
         * Structure is documented below.
         */
        loadBalancerNodePoolConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigAddressPool {
        /**
         * The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
         */
        addresses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, avoid using IPs ending in .0 or .255.
         * This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
         */
        avoidBuggyIps?: pulumi.Input<boolean>;
        /**
         * If true, prevent IP addresses from being automatically assigned.
         */
        manualAssign?: pulumi.Input<string>;
        /**
         * The name of the address pool.
         */
        pool: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig {
        /**
         * BGP autonomous system number (ASN) for the network that contains the
         * external peer device.
         */
        asn: pulumi.Input<number>;
        /**
         * The IP address of the control plane node that connects to the external
         * peer.
         * If you don't specify any control plane nodes, all control plane nodes
         * can connect to the external peer. If you specify one or more IP addresses,
         * only the nodes specified participate in peering sessions.
         */
        controlPlaneNodes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP address of the external peer device.
         */
        ipAddress: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig {
        /**
         * The generic configuration for a node pool running a load balancer.
         * Structure is documented below.
         */
        nodePoolConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig {
        /**
         * The modifiable kubelet configurations for the baremetal machines.
         * Structure is documented below.
         */
        kubeletConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig>;
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The list of machine addresses in the Bare Metal Node Pool.
         * Structure is documented below.
         */
        nodeConfigs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig>[]>;
        /**
         * Specifies the nodes operating system (default: LINUX).
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint>[]>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig {
        /**
         * The maximum size of bursty pulls, temporarily allows pulls to burst to this
         * number, while still not exceeding registry_pull_qps.
         * The value must not be a negative number.
         * Updating this field may impact scalability by changing the amount of
         * traffic produced by image pulls.
         * Defaults to 10.
         */
        registryBurst?: pulumi.Input<number>;
        /**
         * The limit of registry pulls per second.
         * Setting this value to 0 means no limit.
         * Updating this field may impact scalability by changing the amount of
         * traffic produced by image pulls.
         * Defaults to 5.
         */
        registryPullQps?: pulumi.Input<number>;
        /**
         * Prevents the Kubelet from pulling multiple images at a time.
         * We recommend *not* changing the default value on nodes that run docker
         * daemon with version  < 1.9 or an Another Union File System (Aufs) storage
         * backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
         * more details.
         */
        serializeImagePullsDisabled?: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default IPv4 address for SSH access and Kubernetes node.
         * Example: 192.168.0.1
         */
        nodeIp?: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint {
        /**
         * Specifies the nodes operating system (default: LINUX).
         * Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key?: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value?: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerManualLbConfig {
        /**
         * Whether manual load balancing is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfig {
        /**
         * AddressPools is a list of non-overlapping IP pools used by load balancer
         * typed services. All addresses must be routable to load balancer nodes.
         * IngressVIP must be included in the pools.
         * Structure is documented below.
         */
        addressPools: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfigAddressPool>[]>;
        /**
         * Specifies the load balancer's node pool configuration.
         * Structure is documented below.
         */
        loadBalancerNodePoolConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfigAddressPool {
        /**
         * The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
         */
        addresses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, avoid using IPs ending in .0 or .255.
         * This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
         */
        avoidBuggyIps?: pulumi.Input<boolean>;
        /**
         * If true, prevent IP addresses from being automatically assigned.
         */
        manualAssign?: pulumi.Input<boolean>;
        /**
         * The name of the address pool.
         */
        pool: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig {
        /**
         * The generic configuration for a node pool running a load balancer.
         * Structure is documented below.
         */
        nodePoolConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The list of machine addresses in the Bare Metal Node Pool.
         * Structure is documented below.
         */
        nodeConfigs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig>[]>;
        /**
         * Specifies the nodes operating system (default: LINUX).
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint>[]>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default IPv4 address for SSH access and Kubernetes node.
         * Example: 192.168.0.1
         */
        nodeIp?: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint {
        /**
         * Specifies the nodes operating system (default: LINUX).
         * Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key?: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value?: pulumi.Input<string>;
    }

    export interface BareMetalClusterLoadBalancerPortConfig {
        /**
         * The port that control plane hosted load balancers will listen on.
         */
        controlPlaneLoadBalancerPort: pulumi.Input<number>;
    }

    export interface BareMetalClusterLoadBalancerVipConfig {
        /**
         * The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
         */
        controlPlaneVip: pulumi.Input<string>;
        /**
         * The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
         */
        ingressVip: pulumi.Input<string>;
    }

    export interface BareMetalClusterMaintenanceConfig {
        /**
         * All IPv4 address from these ranges will be placed into maintenance mode.
         * Nodes in maintenance mode will be cordoned and drained. When both of these
         * are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
         * on the node resource.
         */
        maintenanceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BareMetalClusterNetworkConfig {
        /**
         * Enables the use of advanced Anthos networking features, such as Bundled
         * Load Balancing with BGP or the egress NAT gateway.
         * Setting configuration for advanced networking features will automatically
         * set this flag.
         */
        advancedNetworking?: pulumi.Input<boolean>;
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        islandModeCidr?: pulumi.Input<inputs.gkeonprem.BareMetalClusterNetworkConfigIslandModeCidr>;
        /**
         * Configuration for multiple network interfaces.
         * Structure is documented below.
         */
        multipleNetworkInterfacesConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig>;
        /**
         * Configuration for SR-IOV.
         * Structure is documented below.
         */
        srIovConfig?: pulumi.Input<inputs.gkeonprem.BareMetalClusterNetworkConfigSrIovConfig>;
    }

    export interface BareMetalClusterNetworkConfigIslandModeCidr {
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig {
        /**
         * Whether to enable multiple network interfaces for your pods.
         * When set network_config.advanced_networking is automatically
         * set to true.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterNetworkConfigSrIovConfig {
        /**
         * Whether to install the SR-IOV operator.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterNodeAccessConfig {
        /**
         * LoginUser is the user name used to access node machines.
         * It defaults to "root" if not set.
         */
        loginUser?: pulumi.Input<string>;
    }

    export interface BareMetalClusterNodeConfig {
        /**
         * The available runtimes that can be used to run containers in a Bare Metal User Cluster.
         * Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
         */
        containerRuntime?: pulumi.Input<string>;
        /**
         * The maximum number of pods a node can run. The size of the CIDR range
         * assigned to the node will be derived from this parameter.
         */
        maxPodsPerNode?: pulumi.Input<number>;
    }

    export interface BareMetalClusterOsEnvironmentConfig {
        /**
         * Whether the package repo should not be included when initializing
         * bare metal machines.
         */
        packageRepoExcluded: pulumi.Input<boolean>;
    }

    export interface BareMetalClusterProxy {
        /**
         * A list of IPs, hostnames, and domains that should skip the proxy.
         * For example ["127.0.0.1", "example.com", ".corp", "localhost"].
         */
        noProxies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the address of your proxy server.
         * For example: http://domain
         * WARNING: Do not provide credentials in the format
         * of http://(username:password@)domain these will be rejected by the server.
         */
        uri: pulumi.Input<string>;
    }

    export interface BareMetalClusterSecurityConfig {
        /**
         * Configures user access to the Bare Metal User cluster.
         * Structure is documented below.
         */
        authorization?: pulumi.Input<inputs.gkeonprem.BareMetalClusterSecurityConfigAuthorization>;
    }

    export interface BareMetalClusterSecurityConfigAuthorization {
        /**
         * Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
         * Structure is documented below.
         */
        adminUsers: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterSecurityConfigAuthorizationAdminUser>[]>;
    }

    export interface BareMetalClusterSecurityConfigAuthorizationAdminUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface BareMetalClusterStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the user cluster
         * controller. The error message can be temporary as the user cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface BareMetalClusterStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * A human-readable message of the check failure.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface BareMetalClusterStorage {
        /**
         * Specifies the config for local PersistentVolumes backed
         * by mounted node disks. These disks need to be formatted and mounted by the
         * user, which can be done before or after cluster creation.
         * Structure is documented below.
         */
        lvpNodeMountsConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterStorageLvpNodeMountsConfig>;
        /**
         * Specifies the config for local PersistentVolumes backed by
         * subdirectories in a shared filesystem. These subdirectores are
         * automatically created during cluster creation.
         * Structure is documented below.
         */
        lvpShareConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterStorageLvpShareConfig>;
    }

    export interface BareMetalClusterStorageLvpNodeMountsConfig {
        /**
         * The host machine path.
         */
        path: pulumi.Input<string>;
        /**
         * The StorageClass name that PVs will be created with.
         *
         * - - -
         */
        storageClass: pulumi.Input<string>;
    }

    export interface BareMetalClusterStorageLvpShareConfig {
        /**
         * Defines the machine path and storage class for the LVP Share.
         * Structure is documented below.
         */
        lvpConfig: pulumi.Input<inputs.gkeonprem.BareMetalClusterStorageLvpShareConfigLvpConfig>;
        /**
         * The number of subdirectories to create under path.
         */
        sharedPathPvCount?: pulumi.Input<number>;
    }

    export interface BareMetalClusterStorageLvpShareConfigLvpConfig {
        /**
         * The host machine path.
         */
        path: pulumi.Input<string>;
        /**
         * The StorageClass name that PVs will be created with.
         */
        storageClass: pulumi.Input<string>;
    }

    export interface BareMetalClusterUpgradePolicy {
        /**
         * Specifies which upgrade policy to use.
         * Possible values are: `SERIAL`, `CONCURRENT`.
         */
        policy?: pulumi.Input<string>;
    }

    export interface BareMetalClusterValidationCheck {
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * The scenario when the preflight checks were run..
         */
        scenario?: pulumi.Input<string>;
        /**
         * (Output)
         * Specifies the detailed validation check status
         * Structure is documented below.
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterValidationCheckStatus>[]>;
    }

    export interface BareMetalClusterValidationCheckStatus {
        /**
         * (Output)
         * Individual checks which failed as part of the Preflight check execution.
         * Structure is documented below.
         */
        results?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalClusterValidationCheckStatusResult>[]>;
    }

    export interface BareMetalClusterValidationCheckStatusResult {
        /**
         * (Output)
         * The category of the validation.
         */
        category?: pulumi.Input<string>;
        /**
         * (Output)
         * The description of the validation check.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Detailed failure information, which might be unformatted.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * A human-readable message of the check failure.
         */
        reason?: pulumi.Input<string>;
    }

    export interface BareMetalNodePoolNodePoolConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The list of machine addresses in the Bare Metal Node Pool.
         * Structure is documented below.
         */
        nodeConfigs: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalNodePoolNodePoolConfigNodeConfig>[]>;
        /**
         * Specifies the nodes operating system (default: LINUX).
         */
        operatingSystem?: pulumi.Input<string>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalNodePoolNodePoolConfigTaint>[]>;
    }

    export interface BareMetalNodePoolNodePoolConfigNodeConfig {
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to
         * each node. These will added in addition to any default label(s)
         * that Kubernetes may apply to the node. In case of conflict in
         * label keys, the applied set may differ depending on the Kubernetes
         * version -- it's best to assume the behavior is undefined and
         * conflicts should be avoided. For more information, including usage
         * and the valid values, see:
         * - http://kubernetes.io/v1.1/docs/user-guide/labels.html
         * An object containing a list of "key": value pairs.
         * For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The default IPv4 address for SSH access and Kubernetes node.
         * Example: 192.168.0.1
         */
        nodeIp?: pulumi.Input<string>;
    }

    export interface BareMetalNodePoolNodePoolConfigTaint {
        /**
         * Specifies the nodes operating system (default: LINUX).
         * Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         *
         * - - -
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key?: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value?: pulumi.Input<string>;
    }

    export interface BareMetalNodePoolStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.BareMetalNodePoolStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the user cluster
         * controller. The error message can be temporary as the user cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface BareMetalNodePoolStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VMwareClusterAntiAffinityGroups {
        /**
         * Spread nodes across at least three physical hosts (requires at least three
         * hosts).
         * Enabled by default.
         */
        aagConfigDisabled: pulumi.Input<boolean>;
    }

    export interface VMwareClusterAuthorization {
        /**
         * Users that will be granted the cluster-admin role on the cluster, providing
         * full access to the cluster.
         * Structure is documented below.
         */
        adminUsers?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterAuthorizationAdminUser>[]>;
    }

    export interface VMwareClusterAuthorizationAdminUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface VMwareClusterAutoRepairConfig {
        /**
         * Whether auto repair is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VMwareClusterControlPlaneNode {
        /**
         * AutoResizeConfig provides auto resizing configurations.
         * Structure is documented below.
         */
        autoResizeConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterControlPlaneNodeAutoResizeConfig>;
        /**
         * The number of CPUs for each admin cluster node that serve as control planes
         * for this VMware User Cluster. (default: 4 CPUs)
         */
        cpus?: pulumi.Input<number>;
        /**
         * The megabytes of memory for each admin cluster node that serves as a
         * control plane for this VMware User Cluster (default: 8192 MB memory).
         */
        memory?: pulumi.Input<number>;
        /**
         * The number of control plane nodes for this VMware User Cluster.
         * (default: 1 replica).
         */
        replicas?: pulumi.Input<number>;
        /**
         * (Output)
         * Vsphere-specific config.
         * Structure is documented below.
         */
        vsphereConfigs?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterControlPlaneNodeVsphereConfig>[]>;
    }

    export interface VMwareClusterControlPlaneNodeAutoResizeConfig {
        /**
         * Whether to enable control plane node auto resizing.
         *
         * <a name="nestedControlPlaneNodeVsphereConfig"></a>The `vsphereConfig` block contains:
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VMwareClusterControlPlaneNodeVsphereConfig {
        /**
         * The Vsphere datastore used by the Control Plane Node.
         */
        datastore?: pulumi.Input<string>;
        /**
         * The Vsphere storage policy used by the control plane Node.
         */
        storagePolicyName?: pulumi.Input<string>;
    }

    export interface VMwareClusterDataplaneV2 {
        /**
         * Enable advanced networking which requires dataplaneV2Enabled to be set true.
         */
        advancedNetworking?: pulumi.Input<boolean>;
        /**
         * Enables Dataplane V2.
         */
        dataplaneV2Enabled?: pulumi.Input<boolean>;
        /**
         * Enable Dataplane V2 for clusters with Windows nodes.
         */
        windowsDataplaneV2Enabled?: pulumi.Input<boolean>;
    }

    export interface VMwareClusterFleet {
        /**
         * (Output)
         * The name of the managed Hub Membership resource associated to this cluster.
         * Membership names are formatted as
         * `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface VMwareClusterLoadBalancer {
        /**
         * Configuration for F5 Big IP typed load balancers.
         * Structure is documented below.
         */
        f5Config?: pulumi.Input<inputs.gkeonprem.VMwareClusterLoadBalancerF5Config>;
        /**
         * Manually configured load balancers.
         * Structure is documented below.
         */
        manualLbConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterLoadBalancerManualLbConfig>;
        /**
         * Configuration for MetalLB typed load balancers.
         * Structure is documented below.
         */
        metalLbConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterLoadBalancerMetalLbConfig>;
        /**
         * The VIPs used by the load balancer.
         * Structure is documented below.
         */
        vipConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterLoadBalancerVipConfig>;
    }

    export interface VMwareClusterLoadBalancerF5Config {
        /**
         * The load balancer's IP address.
         */
        address?: pulumi.Input<string>;
        /**
         * he preexisting partition to be used by the load balancer. T
         * his partition is usually created for the admin cluster for example:
         * 'my-f5-admin-partition'.
         */
        partition?: pulumi.Input<string>;
        /**
         * The pool name. Only necessary, if using SNAT.
         */
        snatPool?: pulumi.Input<string>;
    }

    export interface VMwareClusterLoadBalancerManualLbConfig {
        /**
         * NodePort for control plane service. The Kubernetes API server in the admin
         * cluster is implemented as a Service of type NodePort (ex. 30968).
         */
        controlPlaneNodePort?: pulumi.Input<number>;
        /**
         * NodePort for ingress service's http. The ingress service in the admin
         * cluster is implemented as a Service of type NodePort (ex. 32527).
         */
        ingressHttpNodePort?: pulumi.Input<number>;
        /**
         * NodePort for ingress service's https. The ingress service in the admin
         * cluster is implemented as a Service of type NodePort (ex. 30139).
         */
        ingressHttpsNodePort?: pulumi.Input<number>;
        /**
         * NodePort for konnectivity server service running as a sidecar in each
         * kube-apiserver pod (ex. 30564).
         */
        konnectivityServerNodePort?: pulumi.Input<number>;
    }

    export interface VMwareClusterLoadBalancerMetalLbConfig {
        /**
         * AddressPools is a list of non-overlapping IP pools used by load balancer
         * typed services. All addresses must be routable to load balancer nodes.
         * IngressVIP must be included in the pools.
         * Structure is documented below.
         */
        addressPools: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterLoadBalancerMetalLbConfigAddressPool>[]>;
    }

    export interface VMwareClusterLoadBalancerMetalLbConfigAddressPool {
        /**
         * The addresses that are part of this pool. Each address
         * must be either in the CIDR form (1.2.3.0/24) or range
         * form (1.2.3.1-1.2.3.5).
         */
        addresses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, avoid using IPs ending in .0 or .255.
         * This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
         * those special IP addresses.
         */
        avoidBuggyIps?: pulumi.Input<boolean>;
        /**
         * If true, prevent IP addresses from being automatically assigned.
         *
         * <a name="nestedDataplaneV2"></a>The `dataplaneV2` block supports:
         */
        manualAssign?: pulumi.Input<boolean>;
        /**
         * The name of the address pool.
         */
        pool: pulumi.Input<string>;
    }

    export interface VMwareClusterLoadBalancerVipConfig {
        /**
         * The VIP which you previously set aside for the Kubernetes API of this cluster.
         */
        controlPlaneVip?: pulumi.Input<string>;
        /**
         * The VIP which you previously set aside for ingress traffic into this cluster.
         *
         * <a name="nestedLoadBalancerF5Config"></a>The `f5Config` block supports:
         */
        ingressVip?: pulumi.Input<string>;
    }

    export interface VMwareClusterNetworkConfig {
        /**
         * Configuration for control plane V2 mode.
         * Structure is documented below.
         */
        controlPlaneV2Config?: pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigControlPlaneV2Config>;
        /**
         * Configuration settings for a DHCP IP configuration.
         * Structure is documented below.
         */
        dhcpIpConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigDhcpIpConfig>;
        /**
         * Represents common network settings irrespective of the host's IP address.
         * Structure is documented below.
         */
        hostConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigHostConfig>;
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
         * Only a single range is supported. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address
         * from these ranges. Only a single range is supported.. This field
         * cannot be changed after creation.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration settings for a static IP configuration.
         * Structure is documented below.
         */
        staticIpConfig?: pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigStaticIpConfig>;
        /**
         * vcenter_network specifies vCenter network name. Inherited from the admin cluster.
         */
        vcenterNetwork?: pulumi.Input<string>;
    }

    export interface VMwareClusterNetworkConfigControlPlaneV2Config {
        /**
         * Static IP addresses for the control plane nodes.
         */
        controlPlaneIpBlock?: pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock>;
    }

    export interface VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock {
        /**
         * The network gateway used by the VMware User Cluster.
         */
        gateway?: pulumi.Input<string>;
        /**
         * The node's network configurations used by the VMware User Cluster.
         * Structure is documented below.
         */
        ips?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp>[]>;
        /**
         * The netmask used by the VMware User Cluster.
         */
        netmask?: pulumi.Input<string>;
    }

    export interface VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp {
        /**
         * Hostname of the machine. VM's name will be used if this field is empty.
         */
        hostname?: pulumi.Input<string>;
        /**
         * IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
         */
        ip?: pulumi.Input<string>;
    }

    export interface VMwareClusterNetworkConfigDhcpIpConfig {
        /**
         * enabled is a flag to mark if DHCP IP allocation is
         * used for VMware user clusters.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VMwareClusterNetworkConfigHostConfig {
        /**
         * DNS search domains.
         *
         * <a name="nestedNetworkConfigControlPlaneV2Config"></a>The `controlPlaneV2Config` block supports:
         */
        dnsSearchDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * DNS servers.
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * NTP servers.
         */
        ntpServers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VMwareClusterNetworkConfigStaticIpConfig {
        /**
         * Represents the configuration values for static IP allocation to nodes.
         * Structure is documented below.
         */
        ipBlocks: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlock>[]>;
    }

    export interface VMwareClusterNetworkConfigStaticIpConfigIpBlock {
        /**
         * The network gateway used by the VMware User Cluster.
         */
        gateway: pulumi.Input<string>;
        /**
         * The node's network configurations used by the VMware User Cluster.
         * Structure is documented below.
         */
        ips: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp>[]>;
        /**
         * The netmask used by the VMware User Cluster.
         */
        netmask: pulumi.Input<string>;
    }

    export interface VMwareClusterNetworkConfigStaticIpConfigIpBlockIp {
        /**
         * Hostname of the machine. VM's name will be used if this field is empty.
         */
        hostname?: pulumi.Input<string>;
        /**
         * IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
         */
        ip: pulumi.Input<string>;
    }

    export interface VMwareClusterStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the user cluster
         * controller. The error message can be temporary as the user cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface VMwareClusterStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VMwareClusterStorage {
        /**
         * Whether or not to deploy vSphere CSI components in the VMware User Cluster.
         * Enabled by default.
         */
        vsphereCsiDisabled: pulumi.Input<boolean>;
    }

    export interface VMwareClusterUpgradePolicy {
        /**
         * Controls whether the upgrade applies to the control plane only.
         */
        controlPlaneOnly?: pulumi.Input<boolean>;
    }

    export interface VMwareClusterValidationCheck {
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * The scenario when the preflight checks were run..
         */
        scenario?: pulumi.Input<string>;
        /**
         * (Output)
         * Specifies the detailed validation check status
         * Structure is documented below.
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterValidationCheckStatus>[]>;
    }

    export interface VMwareClusterValidationCheckStatus {
        /**
         * (Output)
         * Individual checks which failed as part of the Preflight check execution.
         * Structure is documented below.
         */
        results?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareClusterValidationCheckStatusResult>[]>;
    }

    export interface VMwareClusterValidationCheckStatusResult {
        /**
         * (Output)
         * The category of the validation.
         */
        category?: pulumi.Input<string>;
        /**
         * (Output)
         * The description of the validation check.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Detailed failure information, which might be unformatted.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * Options used for the validation check.
         */
        options?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
    }

    export interface VMwareClusterVcenter {
        /**
         * (Output)
         * The vCenter IP address.
         */
        address?: pulumi.Input<string>;
        /**
         * Contains the vCenter CA certificate public key for SSL verification.
         */
        caCertData?: pulumi.Input<string>;
        /**
         * The name of the vCenter cluster for the user cluster.
         */
        cluster?: pulumi.Input<string>;
        /**
         * The name of the vCenter datacenter for the user cluster.
         */
        datacenter?: pulumi.Input<string>;
        /**
         * The name of the vCenter datastore for the user cluster.
         */
        datastore?: pulumi.Input<string>;
        /**
         * The name of the vCenter folder for the user cluster.
         */
        folder?: pulumi.Input<string>;
        /**
         * The name of the vCenter resource pool for the user cluster.
         */
        resourcePool?: pulumi.Input<string>;
        /**
         * The name of the vCenter storage policy for the user cluster.
         */
        storagePolicyName?: pulumi.Input<string>;
    }

    export interface VMwareNodePoolConfig {
        /**
         * VMware disk size to be used during creation.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * The number of CPUs for each node in the node pool.
         */
        cpus?: pulumi.Input<number>;
        /**
         * Allow node pool traffic to be load balanced. Only works for clusters with
         * MetalLB load balancers.
         */
        enableLoadBalancer?: pulumi.Input<boolean>;
        /**
         * The OS image name in vCenter, only valid when using Windows.
         */
        image?: pulumi.Input<string>;
        /**
         * The OS image to be used for each node in a node pool.
         * Currently `cos`, `cosCgv2`, `ubuntu`, `ubuntuCgv2`, `ubuntuContainerd` and `windows` are supported.
         */
        imageType: pulumi.Input<string>;
        /**
         * The map of Kubernetes labels (key/value pairs) to be applied to each node.
         * These will added in addition to any default label(s) that
         * Kubernetes may apply to the node.
         * In case of conflict in label keys, the applied set may differ depending on
         * the Kubernetes version -- it's best to assume the behavior is undefined
         * and conflicts should be avoided.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The megabytes of memory for each node in the node pool.
         */
        memoryMb?: pulumi.Input<number>;
        /**
         * The number of nodes in the node pool.
         */
        replicas?: pulumi.Input<number>;
        /**
         * The initial taints assigned to nodes of this node pool.
         * Structure is documented below.
         */
        taints?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareNodePoolConfigTaint>[]>;
        /**
         * Specifies the vSphere config for node pool.
         * Structure is documented below.
         */
        vsphereConfig?: pulumi.Input<inputs.gkeonprem.VMwareNodePoolConfigVsphereConfig>;
    }

    export interface VMwareNodePoolConfigTaint {
        /**
         * Available taint effects.
         * Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
         */
        effect?: pulumi.Input<string>;
        /**
         * Key associated with the effect.
         */
        key: pulumi.Input<string>;
        /**
         * Value associated with the effect.
         */
        value: pulumi.Input<string>;
    }

    export interface VMwareNodePoolConfigVsphereConfig {
        /**
         * The name of the vCenter datastore. Inherited from the user cluster.
         */
        datastore?: pulumi.Input<string>;
        /**
         * Vsphere host groups to apply to all VMs in the node pool
         */
        hostGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Tags to apply to VMs.
         * Structure is documented below.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareNodePoolConfigVsphereConfigTag>[]>;
    }

    export interface VMwareNodePoolConfigVsphereConfigTag {
        /**
         * The Vsphere tag category.
         */
        category?: pulumi.Input<string>;
        /**
         * The Vsphere tag name.
         *
         * - - -
         */
        tag?: pulumi.Input<string>;
    }

    export interface VMwareNodePoolNodePoolAutoscaling {
        /**
         * Maximum number of replicas in the NodePool.
         */
        maxReplicas: pulumi.Input<number>;
        /**
         * Minimum number of replicas in the NodePool.
         */
        minReplicas: pulumi.Input<number>;
    }

    export interface VMwareNodePoolStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VMwareNodePoolStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the user cluster
         * controller. The error message can be temporary as the user cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface VMwareNodePoolStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterAddonNode {
        /**
         * Specifies auto resize config.
         * Structure is documented below.
         */
        autoResizeConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterAddonNodeAutoResizeConfig>;
    }

    export interface VmwareAdminClusterAddonNodeAutoResizeConfig {
        /**
         * Whether to enable controle plane node auto resizing.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VmwareAdminClusterAntiAffinityGroups {
        /**
         * Spread nodes across at least three physical hosts (requires at least three
         * hosts).
         * Enabled by default.
         */
        aagConfigDisabled: pulumi.Input<boolean>;
    }

    export interface VmwareAdminClusterAuthorization {
        /**
         * Users that will be granted the cluster-admin role on the cluster, providing
         * full access to the cluster.
         * Structure is documented below.
         */
        viewerUsers?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterAuthorizationViewerUser>[]>;
    }

    export interface VmwareAdminClusterAuthorizationViewerUser {
        /**
         * The name of the user, e.g. `my-gcp-id@gmail.com`.
         */
        username: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterAutoRepairConfig {
        /**
         * Whether auto repair is enabled.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VmwareAdminClusterControlPlaneNode {
        /**
         * The number of vCPUs for the control-plane node of the admin cluster.
         */
        cpus?: pulumi.Input<number>;
        /**
         * The number of mebibytes of memory for the control-plane node of the admin cluster.
         */
        memory?: pulumi.Input<number>;
        /**
         * The number of control plane nodes for this VMware admin cluster.
         */
        replicas?: pulumi.Input<number>;
    }

    export interface VmwareAdminClusterFleet {
        /**
         * (Output)
         * The name of the managed Fleet Membership resource associated to this cluster.
         * Membership names are formatted as
         * `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
         */
        membership?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterLoadBalancer {
        /**
         * Configuration for F5 Big IP typed load balancers.
         * Structure is documented below.
         */
        f5Config?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterLoadBalancerF5Config>;
        /**
         * Manually configured load balancers.
         * Structure is documented below.
         */
        manualLbConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterLoadBalancerManualLbConfig>;
        /**
         * Metal LB load balancers.
         * Structure is documented below.
         */
        metalLbConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterLoadBalancerMetalLbConfig>;
        /**
         * Specified the VMware Load Balancer Config
         * Structure is documented below.
         */
        vipConfig: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterLoadBalancerVipConfig>;
    }

    export interface VmwareAdminClusterLoadBalancerF5Config {
        /**
         * The load balancer's IP address.
         */
        address?: pulumi.Input<string>;
        /**
         * he preexisting partition to be used by the load balancer. T
         * his partition is usually created for the admin cluster for example:
         * 'my-f5-admin-partition'.
         */
        partition?: pulumi.Input<string>;
        /**
         * The pool name. Only necessary, if using SNAT.
         */
        snatPool?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterLoadBalancerManualLbConfig {
        /**
         * NodePort for add-ons server in the admin cluster.
         */
        addonsNodePort?: pulumi.Input<number>;
        /**
         * NodePort for control plane service. The Kubernetes API server in the admin
         * cluster is implemented as a Service of type NodePort (ex. 30968).
         */
        controlPlaneNodePort?: pulumi.Input<number>;
        /**
         * NodePort for ingress service's http. The ingress service in the admin
         * cluster is implemented as a Service of type NodePort (ex. 32527).
         */
        ingressHttpNodePort?: pulumi.Input<number>;
        /**
         * NodePort for ingress service's https. The ingress service in the admin
         * cluster is implemented as a Service of type NodePort (ex. 30139).
         */
        ingressHttpsNodePort?: pulumi.Input<number>;
        /**
         * NodePort for konnectivity server service running as a sidecar in each
         * kube-apiserver pod (ex. 30564).
         */
        konnectivityServerNodePort?: pulumi.Input<number>;
    }

    export interface VmwareAdminClusterLoadBalancerMetalLbConfig {
        /**
         * Metal LB is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface VmwareAdminClusterLoadBalancerVipConfig {
        /**
         * The VIP to configure the load balancer for add-ons.
         *
         * <a name="nestedLoadBalancerF5Config"></a>The `f5Config` block supports:
         */
        addonsVip?: pulumi.Input<string>;
        /**
         * The VIP which you previously set aside for the Kubernetes
         * API of this VMware Admin Cluster.
         */
        controlPlaneVip: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterNetworkConfig {
        /**
         * Configuration settings for a DHCP IP configuration.
         * Structure is documented below.
         */
        dhcpIpConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigDhcpIpConfig>;
        /**
         * Configuration for HA admin cluster control plane.
         * Structure is documented below.
         */
        haControlPlaneConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigHaControlPlaneConfig>;
        /**
         * Represents common network settings irrespective of the host's IP address.
         * Structure is documented below.
         */
        hostConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigHostConfig>;
        /**
         * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
         * Only a single range is supported. This field cannot be changed after creation.
         */
        podAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * All services in the cluster are assigned an RFC1918 IPv4 address
         * from these ranges. Only a single range is supported.. This field
         * cannot be changed after creation.
         */
        serviceAddressCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration settings for a static IP configuration.
         * Structure is documented below.
         */
        staticIpConfig?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigStaticIpConfig>;
        /**
         * vcenter_network specifies vCenter network name.
         */
        vcenterNetwork?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterNetworkConfigDhcpIpConfig {
        /**
         * enabled is a flag to mark if DHCP IP allocation is
         * used for VMware admin clusters.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface VmwareAdminClusterNetworkConfigHaControlPlaneConfig {
        /**
         * Static IP addresses for the control plane nodes.
         * Structure is documented below.
         */
        controlPlaneIpBlock?: pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock>;
    }

    export interface VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock {
        /**
         * The network gateway used by the VMware Admin Cluster.
         */
        gateway: pulumi.Input<string>;
        /**
         * The node's network configurations used by the VMware Admin Cluster.
         * Structure is documented below.
         */
        ips: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp>[]>;
        /**
         * The netmask used by the VMware Admin Cluster.
         */
        netmask: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp {
        /**
         * Hostname of the machine. VM's name will be used if this field is empty.
         *
         * - - -
         */
        hostname?: pulumi.Input<string>;
        /**
         * IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
         */
        ip: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterNetworkConfigHostConfig {
        /**
         * DNS search domains.
         */
        dnsSearchDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * DNS servers.
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * NTP servers.
         */
        ntpServers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VmwareAdminClusterNetworkConfigStaticIpConfig {
        /**
         * Represents the configuration values for static IP allocation to nodes.
         * Structure is documented below.
         */
        ipBlocks?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock>[]>;
    }

    export interface VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock {
        /**
         * The network gateway used by the VMware Admin Cluster.
         */
        gateway: pulumi.Input<string>;
        /**
         * The node's network configurations used by the VMware Admin Cluster.
         * Structure is documented below.
         */
        ips: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp>[]>;
        /**
         * The netmask used by the VMware Admin Cluster.
         */
        netmask: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp {
        /**
         * Hostname of the machine. VM's name will be used if this field is empty.
         *
         * - - -
         */
        hostname?: pulumi.Input<string>;
        /**
         * IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
         */
        ip: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterPlatformConfig {
        /**
         * (Output)
         * The list of bundles installed in the admin cluster.
         * Structure is documented below.
         */
        bundles?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterPlatformConfigBundle>[]>;
        /**
         * (Output)
         * The platform version e.g. 1.13.2.
         */
        platformVersion?: pulumi.Input<string>;
        /**
         * The required platform version e.g. 1.13.1.
         * If the current platform version is lower than the target version,
         * the platform version will be updated to the target version.
         * If the target version is not installed in the platform
         * (bundle versions), download the target version bundle.
         */
        requiredPlatformVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * ResourceStatus representing detailed cluster state.
         * Structure is documented below.
         *
         *
         * <a name="nestedPlatformConfigBundlesBundlesStatus"></a>The `status` block contains:
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterPlatformConfigStatus>[]>;
    }

    export interface VmwareAdminClusterPlatformConfigBundle {
        /**
         * ResourceStatus representing detailed cluster state.
         * Structure is documented below.
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterPlatformConfigBundleStatus>[]>;
        /**
         * The version of the bundle.
         */
        version?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterPlatformConfigBundleStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterPlatformConfigBundleStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the admin cluster
         * controller. The error message can be temporary as the admin cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterPlatformConfigBundleStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterPlatformConfigStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterPlatformConfigStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the admin cluster
         * controller. The error message can be temporary as the admin cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterPlatformConfigStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterStatus {
        /**
         * (Output)
         * ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
         * Structure is documented below.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.gkeonprem.VmwareAdminClusterStatusCondition>[]>;
        /**
         * (Output)
         * Human-friendly representation of the error message from the admin cluster
         * controller. The error message can be temporary as the admin cluster
         * controller creates a cluster or node pool. If the error message persists
         * for a longer period of time, it can be used to surface error message to
         * indicate real problems requiring user intervention.
         */
        errorMessage?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterStatusCondition {
        /**
         * (Output)
         * Last time the condition transit from one status to another.
         */
        lastTransitionTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable message indicating details about last transition.
         */
        message?: pulumi.Input<string>;
        /**
         * (Output)
         * Machine-readable message indicating details about last transition.
         */
        reason?: pulumi.Input<string>;
        /**
         * (Output)
         * The lifecycle state of the condition.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the condition.
         * (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
         */
        type?: pulumi.Input<string>;
    }

    export interface VmwareAdminClusterVcenter {
        /**
         * The vCenter IP address.
         */
        address?: pulumi.Input<string>;
        /**
         * Contains the vCenter CA certificate public key for SSL verification.
         */
        caCertData?: pulumi.Input<string>;
        /**
         * The name of the vCenter cluster for the admin cluster.
         */
        cluster?: pulumi.Input<string>;
        /**
         * The name of the virtual machine disk (VMDK) for the admin cluster.
         */
        dataDisk?: pulumi.Input<string>;
        /**
         * The name of the vCenter datacenter for the admin cluster.
         */
        datacenter?: pulumi.Input<string>;
        /**
         * The name of the vCenter datastore for the admin cluster.
         */
        datastore?: pulumi.Input<string>;
        /**
         * The name of the vCenter folder for the admin cluster.
         */
        folder?: pulumi.Input<string>;
        /**
         * The name of the vCenter resource pool for the admin cluster.
         */
        resourcePool?: pulumi.Input<string>;
        /**
         * The name of the vCenter storage policy for the user cluster.
         */
        storagePolicyName?: pulumi.Input<string>;
    }
}

export namespace healthcare {
    export interface ConsentStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConsentStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatasetEncryptionSpec {
        /**
         * KMS encryption key that is used to secure this dataset and its sub-resources. The key used for
         * encryption and the dataset must be in the same location. If empty, the default Google encryption
         * key will be used to secure this dataset. The format is
         * projects/{projectId}/locations/{locationId}/keyRings/{keyRingId}/cryptoKeys/{keyId}.
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface DatasetIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DatasetIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DicomStoreNotificationConfig {
        /**
         * The Cloud Pub/Sub topic that notifications of changes are published on. Supplied by the client.
         * PubsubMessage.Data will contain the resource name. PubsubMessage.MessageId is the ID of this message.
         * It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message
         * was published. Notifications are only sent if the topic is non-empty. Topic names must be scoped to a
         * project. service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com must have publisher permissions on the given
         * Cloud Pub/Sub topic. Not having adequate permissions will cause the calls that send notifications to fail.
         */
        pubsubTopic: pulumi.Input<string>;
        /**
         * Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
         */
        sendForBulkImport?: pulumi.Input<boolean>;
    }

    export interface DicomStoreStreamConfig {
        /**
         * BigQueryDestination to include a fully qualified BigQuery table URI where DICOM instance metadata will be streamed.
         * Structure is documented below.
         */
        bigqueryDestination: pulumi.Input<inputs.healthcare.DicomStoreStreamConfigBigqueryDestination>;
    }

    export interface DicomStoreStreamConfigBigqueryDestination {
        /**
         * a fully qualified BigQuery table URI where DICOM instance metadata will be streamed.
         */
        tableUri: pulumi.Input<string>;
    }

    export interface FhirStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface FhirStoreNotificationConfig {
        /**
         * The Cloud Pub/Sub topic that notifications of changes are published on. Supplied by the client.
         * PubsubMessage.Data will contain the resource name. PubsubMessage.MessageId is the ID of this message.
         * It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message
         * was published. Notifications are only sent if the topic is non-empty. Topic names must be scoped to a
         * project. service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com must have publisher permissions on the given
         * Cloud Pub/Sub topic. Not having adequate permissions will cause the calls that send notifications to fail.
         */
        pubsubTopic: pulumi.Input<string>;
        /**
         * Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation.
         * Note that setting this to true does not guarantee that all resources will be sent in the format of
         * full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be
         * sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether
         * it needs to fetch the full resource as a separate operation.
         */
        sendFullResource?: pulumi.Input<boolean>;
        /**
         * Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to
         * true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a
         * resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always
         * check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous
         * resource as a separate operation.
         */
        sendPreviousResourceOnDelete?: pulumi.Input<boolean>;
    }

    export interface FhirStoreStreamConfig {
        /**
         * The destination BigQuery structure that contains both the dataset location and corresponding schema config.
         * The output is organized in one table per resource type. The server reuses the existing tables (if any) that
         * are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given
         * resource type, the server attempts to create one.
         * See the [streaming config reference](https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores#streamconfig) for more details.
         * Structure is documented below.
         */
        bigqueryDestination: pulumi.Input<inputs.healthcare.FhirStoreStreamConfigBigqueryDestination>;
        /**
         * Supply a FHIR resource type (such as "Patient" or "Observation"). See
         * https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats
         * an empty list as an intent to stream all the supported resource types in this FHIR store.
         */
        resourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FhirStoreStreamConfigBigqueryDestination {
        /**
         * BigQuery URI to a dataset, up to 2000 characters long, in the format bq://projectId.bqDatasetId
         */
        datasetUri: pulumi.Input<string>;
        /**
         * The configuration for the exported BigQuery schema.
         * Structure is documented below.
         */
        schemaConfig: pulumi.Input<inputs.healthcare.FhirStoreStreamConfigBigqueryDestinationSchemaConfig>;
    }

    export interface FhirStoreStreamConfigBigqueryDestinationSchemaConfig {
        /**
         * The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
         * Structure is documented below.
         */
        lastUpdatedPartitionConfig?: pulumi.Input<inputs.healthcare.FhirStoreStreamConfigBigqueryDestinationSchemaConfigLastUpdatedPartitionConfig>;
        /**
         * The depth for all recursive structures in the output analytics schema. For example, concept in the CodeSystem
         * resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called
         * concept.concept but not concept.concept.concept. If not specified or set to 0, the server will use the default
         * value 2. The maximum depth allowed is 5.
         */
        recursiveStructureDepth: pulumi.Input<number>;
        /**
         * Specifies the output schema type.
         * * ANALYTICS: Analytics schema defined by the FHIR community.
         * See https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md.
         * * ANALYTICS_V2: Analytics V2, similar to schema defined by the FHIR community, with added support for extensions with one or more occurrences and contained resources in stringified JSON.
         * * LOSSLESS: A data-driven schema generated from the fields present in the FHIR data being exported, with no additional simplification.
         * Default value is `ANALYTICS`.
         * Possible values are: `ANALYTICS`, `ANALYTICS_V2`, `LOSSLESS`.
         */
        schemaType?: pulumi.Input<string>;
    }

    export interface FhirStoreStreamConfigBigqueryDestinationSchemaConfigLastUpdatedPartitionConfig {
        /**
         * Number of milliseconds for which to keep the storage for a partition.
         */
        expirationMs?: pulumi.Input<string>;
        /**
         * Type of partitioning.
         * Possible values are: `PARTITION_TYPE_UNSPECIFIED`, `HOUR`, `DAY`, `MONTH`, `YEAR`.
         */
        type: pulumi.Input<string>;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface Hl7StoreNotificationConfig {
        /**
         * The Cloud Pub/Sub topic that notifications of changes are published on. Supplied by the client.
         * PubsubMessage.Data will contain the resource name. PubsubMessage.MessageId is the ID of this message.
         * It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message
         * was published. Notifications are only sent if the topic is non-empty. Topic names must be scoped to a
         * project. service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com must have publisher permissions on the given
         * Cloud Pub/Sub topic. Not having adequate permissions will cause the calls that send notifications to fail.
         */
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreNotificationConfigs {
        /**
         * Restricts notifications sent for messages matching a filter. If this is empty, all messages
         * are matched. Syntax: https://cloud.google.com/appengine/docs/standard/python/search/query_strings
         * Fields/functions available for filtering are:
         * * messageType, from the MSH-9.1 field. For example, NOT messageType = "ADT".
         * * sendDate or sendDate, the YYYY-MM-DD date the message was sent in the dataset's timeZone, from the MSH-7 segment. For example, sendDate < "2017-01-02".
         * * sendTime, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, sendTime < "2017-01-02T00:00:00-05:00".
         * * sendFacility, the care center that the message came from, from the MSH-4 segment. For example, sendFacility = "ABC".
         * * PatientId(value, type), which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, PatientId("123456", "MRN").
         * * labels.x, a string value of the label with key x as set using the Message.labels map. For example, labels."priority"="high". The operator :* can be used to assert the existence of a label. For example, labels."priority":*.
         */
        filter?: pulumi.Input<string>;
        /**
         * The Cloud Pub/Sub topic that notifications of changes are published on. Supplied by the client.
         * PubsubMessage.Data will contain the resource name. PubsubMessage.MessageId is the ID of this message.
         * It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message
         * was published. Notifications are only sent if the topic is non-empty. Topic names must be scoped to a
         * project. service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com must have publisher permissions on the given
         * Cloud Pub/Sub topic. Not having adequate permissions will cause the calls that send notifications to fail.
         * If a notification cannot be published to Cloud Pub/Sub, errors will be logged to Stackdriver
         */
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreParserConfig {
        /**
         * Determines whether messages with no header are allowed.
         */
        allowNullHeader?: pulumi.Input<boolean>;
        /**
         * JSON encoded string for schemas used to parse messages in this
         * store if schematized parsing is desired.
         */
        schema?: pulumi.Input<string>;
        /**
         * Byte(s) to be used as the segment terminator. If this is unset, '\r' will be used as segment terminator.
         * A base64-encoded string.
         */
        segmentTerminator?: pulumi.Input<string>;
        /**
         * The version of the unschematized parser to be used when a custom `schema` is not set.
         * Default value is `V1`.
         * Possible values are: `V1`, `V2`, `V3`.
         */
        version?: pulumi.Input<string>;
    }

    export interface PipelineJobBackfillPipelineJob {
        /**
         * Specifies the mapping pipeline job to backfill, the name format
         * should follow: projects/{projectId}/locations/{locationId}/datasets/{datasetId}/pipelineJobs/{pipelineJobId}.
         */
        mappingPipelineJob?: pulumi.Input<string>;
    }

    export interface PipelineJobMappingPipelineJob {
        /**
         * If set, the mapping pipeline will write snapshots to this
         * FHIR store without assigning stable IDs. You must
         * grant your pipeline project's Cloud Healthcare Service
         * Agent serviceaccount healthcare.fhirResources.executeBundle
         * and healthcare.fhirResources.create permissions on the
         * destination store. The destination store must set
         * [disableReferentialIntegrity][FhirStore.disable_referential_integrity]
         * to true. The destination store must use FHIR version R4.
         * Format: project/{projectID}/locations/{locationID}/datasets/{datasetName}/fhirStores/{fhirStoreID}.
         */
        fhirStoreDestination?: pulumi.Input<string>;
        /**
         * A streaming FHIR data source.
         * Structure is documented below.
         */
        fhirStreamingSource?: pulumi.Input<inputs.healthcare.PipelineJobMappingPipelineJobFhirStreamingSource>;
        /**
         * The location of the mapping configuration.
         * Structure is documented below.
         */
        mappingConfig: pulumi.Input<inputs.healthcare.PipelineJobMappingPipelineJobMappingConfig>;
        /**
         * If set to true, a mapping pipeline will send output snapshots
         * to the reconciliation pipeline in its dataset. A reconciliation
         * pipeline must exist in this dataset before a mapping pipeline
         * with a reconciliation destination can be created.
         */
        reconciliationDestination?: pulumi.Input<boolean>;
    }

    export interface PipelineJobMappingPipelineJobFhirStreamingSource {
        /**
         * Describes the streaming FHIR data source.
         */
        description?: pulumi.Input<string>;
        /**
         * The path to the FHIR store in the format projects/{projectId}/locations/{locationId}/datasets/{datasetId}/fhirStores/{fhirStoreId}.
         */
        fhirStore: pulumi.Input<string>;
    }

    export interface PipelineJobMappingPipelineJobMappingConfig {
        /**
         * Describes the mapping configuration.
         */
        description?: pulumi.Input<string>;
        /**
         * Specifies the path to the mapping configuration for harmonization pipeline.
         * Structure is documented below.
         */
        whistleConfigSource?: pulumi.Input<inputs.healthcare.PipelineJobMappingPipelineJobMappingConfigWhistleConfigSource>;
    }

    export interface PipelineJobMappingPipelineJobMappingConfigWhistleConfigSource {
        /**
         * Directory path where all the Whistle files are located.
         * Example: gs://{bucket-id}/{path/to/import-root/dir}
         */
        importUriPrefix: pulumi.Input<string>;
        /**
         * Main configuration file which has the entrypoint or the root function.
         * Example: gs://{bucket-id}/{path/to/import-root/dir}/entrypoint-file-name.wstl.
         */
        uri: pulumi.Input<string>;
    }

    export interface PipelineJobReconciliationPipelineJob {
        /**
         * The harmonized FHIR store to write harmonized FHIR resources to,
         * in the format of: project/{projectID}/locations/{locationID}/datasets/{datasetName}/fhirStores/{id}
         */
        fhirStoreDestination?: pulumi.Input<string>;
        /**
         * Specifies the top level directory of the matching configs used
         * in all mapping pipelines, which extract properties for resources
         * to be matched on.
         * Example: gs://{bucket-id}/{path/to/matching/configs}
         */
        matchingUriPrefix: pulumi.Input<string>;
        /**
         * Specifies the location of the reconciliation configuration.
         * Structure is documented below.
         */
        mergeConfig: pulumi.Input<inputs.healthcare.PipelineJobReconciliationPipelineJobMergeConfig>;
    }

    export interface PipelineJobReconciliationPipelineJobMergeConfig {
        /**
         * Describes the mapping configuration.
         */
        description?: pulumi.Input<string>;
        /**
         * Specifies the path to the mapping configuration for harmonization pipeline.
         * Structure is documented below.
         */
        whistleConfigSource: pulumi.Input<inputs.healthcare.PipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource>;
    }

    export interface PipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource {
        /**
         * Directory path where all the Whistle files are located.
         * Example: gs://{bucket-id}/{path/to/import-root/dir}
         */
        importUriPrefix: pulumi.Input<string>;
        /**
         * Main configuration file which has the entrypoint or the root function.
         * Example: gs://{bucket-id}/{path/to/import-root/dir}/entrypoint-file-name.wstl.
         */
        uri: pulumi.Input<string>;
    }

    export interface WorkspaceSettings {
        /**
         * Project IDs for data projects hosted in a workspace.
         *
         * - - -
         */
        dataProjectIds: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace iam {
    export interface AccessBoundaryPolicyRule {
        /**
         * An access boundary rule in an IAM policy.
         * Structure is documented below.
         */
        accessBoundaryRule?: pulumi.Input<inputs.iam.AccessBoundaryPolicyRuleAccessBoundaryRule>;
        /**
         * The description of the rule.
         */
        description?: pulumi.Input<string>;
    }

    export interface AccessBoundaryPolicyRuleAccessBoundaryRule {
        /**
         * The availability condition further constrains the access allowed by the access boundary rule.
         * Structure is documented below.
         */
        availabilityCondition?: pulumi.Input<inputs.iam.AccessBoundaryPolicyRuleAccessBoundaryRuleAvailabilityCondition>;
        /**
         * A list of permissions that may be allowed for use on the specified resource.
         */
        availablePermissions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The full resource name of a Google Cloud resource entity.
         */
        availableResource?: pulumi.Input<string>;
    }

    export interface AccessBoundaryPolicyRuleAccessBoundaryRuleAvailabilityCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting,
         * e.g. a file name and a position in the file.
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface DenyPolicyRule {
        /**
         * A deny rule in an IAM deny policy.
         * Structure is documented below.
         */
        denyRule?: pulumi.Input<inputs.iam.DenyPolicyRuleDenyRule>;
        /**
         * The description of the rule.
         */
        description?: pulumi.Input<string>;
    }

    export interface DenyPolicyRuleDenyRule {
        /**
         * User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
         * Structure is documented below.
         */
        denialCondition?: pulumi.Input<inputs.iam.DenyPolicyRuleDenyRuleDenialCondition>;
        /**
         * The permissions that are explicitly denied by this rule. Each permission uses the format `{service-fqdn}/{resource}.{verb}`,
         * where `{service-fqdn}` is the fully qualified domain name for the service. For example, `iam.googleapis.com/roles.list`.
         */
        deniedPermissions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The identities that are prevented from using one or more permissions on Google Cloud resources.
         */
        deniedPrincipals?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the permissions that this rule excludes from the set of denied permissions given by deniedPermissions.
         * If a permission appears in deniedPermissions and in exceptionPermissions then it will not be denied.
         * The excluded permissions can be specified using the same syntax as deniedPermissions.
         */
        exceptionPermissions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The identities that are excluded from the deny rule, even if they are listed in the deniedPrincipals.
         * For example, you could add a Google group to the deniedPrincipals, then exclude specific users who belong to that group.
         */
        exceptionPrincipals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DenyPolicyRuleDenyRuleDenialCondition {
        /**
         * Description of the expression. This is a longer text which describes the expression,
         * e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting,
         * e.g. a file name and a position in the file.
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         * This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface FoldersPolicyBindingCondition {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface FoldersPolicyBindingTarget {
        /**
         * Required. Immutable. Full Resource Name of the principal set used for principal access boundary policy bindings.
         * Examples for each one of the following supported principal set types:
         * * Folder: `//cloudresourcemanager.googleapis.com/folders/FOLDER_ID`
         * It must be parent by the policy binding's parent (the folder).
         *
         * - - -
         */
        principalSet?: pulumi.Input<string>;
    }

    export interface OrganizationsPolicyBindingCondition {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface OrganizationsPolicyBindingTarget {
        /**
         * Required. Immutable. Full Resource Name of the principal set used for principal access boundary policy bindings.
         * Examples for each one of the following supported principal set types:
         * * Organization `//cloudresourcemanager.googleapis.com/organizations/ORGANIZATION_ID`
         * * Workforce Identity: `//iam.googleapis.com/locations/global/workforcePools/WORKFORCE_POOL_ID`
         * * Workspace Identity: `//iam.googleapis.com/locations/global/workspace/WORKSPACE_ID`
         * It must be parent by the policy binding's parent (the organization).
         *
         * - - -
         */
        principalSet?: pulumi.Input<string>;
    }

    export interface PrincipalAccessBoundaryPolicyDetails {
        /**
         * The version number that indicates which Google Cloud services
         * are included in the enforcement (e.g. \"latest\", \"1\", ...). If empty, the
         * PAB policy version will be set to the current latest version, and this version
         * won't get updated when new versions are released.
         */
        enforcementVersion?: pulumi.Input<string>;
        /**
         * A list of principal access boundary policy rules. The number of rules in a policy is limited to 500.
         * Structure is documented below.
         */
        rules: pulumi.Input<pulumi.Input<inputs.iam.PrincipalAccessBoundaryPolicyDetailsRule>[]>;
    }

    export interface PrincipalAccessBoundaryPolicyDetailsRule {
        /**
         * The description of the principal access boundary policy rule. Must be less than or equal to 256 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * The access relationship of principals to the resources in this rule.
         * Possible values: ALLOW
         */
        effect: pulumi.Input<string>;
        /**
         * A list of Cloud Resource Manager resources. The resource
         * and all the descendants are included. The number of resources in a policy
         * is limited to 500 across all rules.
         * The following resource types are supported:
         * * Organizations, such as `//cloudresourcemanager.googleapis.com/organizations/123`.
         * * Folders, such as `//cloudresourcemanager.googleapis.com/folders/123`.
         * * Projects, such as `//cloudresourcemanager.googleapis.com/projects/123`
         * or `//cloudresourcemanager.googleapis.com/projects/my-project-id`.
         */
        resources: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ProjectsPolicyBindingCondition {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ProjectsPolicyBindingTarget {
        /**
         * Required. Immutable. Full Resource Name of the principal set used for principal access boundary policy bindings.
         * Examples for each one of the following supported principal set types:
         * * Project:
         * * `//cloudresourcemanager.googleapis.com/projects/PROJECT_NUMBER`
         * * `//cloudresourcemanager.googleapis.com/projects/PROJECT_ID`
         * * Workload Identity Pool: `//iam.googleapis.com/projects/PROJECT_NUMBER/locations/LOCATION/workloadIdentityPools/WORKLOAD_POOL_ID`
         * It must be parent by the policy binding's parent (the project).
         *
         * - - -
         */
        principalSet?: pulumi.Input<string>;
    }

    export interface WorkforcePoolAccessRestrictions {
        /**
         * Services allowed for web sign-in with the workforce pool.
         * If not set by default there are no restrictions.
         * Structure is documented below.
         */
        allowedServices?: pulumi.Input<pulumi.Input<inputs.iam.WorkforcePoolAccessRestrictionsAllowedService>[]>;
        /**
         * Disable programmatic sign-in by disabling token issue via the Security Token API endpoint.
         * See [Security Token Service API](https://cloud.google.com/iam/docs/reference/sts/rest).
         */
        disableProgrammaticSignin?: pulumi.Input<boolean>;
    }

    export interface WorkforcePoolAccessRestrictionsAllowedService {
        /**
         * Domain name of the service.
         * Example: console.cloud.google
         */
        domain?: pulumi.Input<string>;
    }

    export interface WorkforcePoolProviderExtraAttributesOauth2Client {
        /**
         * Represents the IdP and type of claims that should be fetched.
         * * AZURE_AD_GROUPS_MAIL: Used to get the user's group claims from the Azure AD identity provider using configuration provided
         * in ExtraAttributesOAuth2Client and 'mail' property of the 'microsoft.graph.group' object is used for claim mapping.
         * See https://learn.microsoft.com/en-us/graph/api/resources/group?view=graph-rest-1.0#properties for more details on
         * 'microsoft.graph.group' properties. The attributes obtained from idntity provider are mapped to 'assertion.groups'.
         * * AZURE_AD_GROUPS_ID:  Used to get the user's group claims from the Azure AD identity provider
         * using configuration provided in ExtraAttributesOAuth2Client and 'id'
         * property of the 'microsoft.graph.group' object is used for claim mapping. See
         * https://learn.microsoft.com/en-us/graph/api/resources/group?view=graph-rest-1.0#properties
         * for more details on 'microsoft.graph.group' properties. The
         * group IDs obtained from Azure AD are present in 'assertion.groups' for
         * OIDC providers and 'assertion.attributes.groups' for SAML providers for
         * attribute mapping. Possible values: ["AZURE_AD_GROUPS_MAIL", "AZURE_AD_GROUPS_ID"]
         */
        attributesType: pulumi.Input<string>;
        /**
         * The OAuth 2.0 client ID for retrieving extra attributes from the identity provider. Required to get the Access Token using client credentials grant flow.
         */
        clientId: pulumi.Input<string>;
        /**
         * The OAuth 2.0 client secret for retrieving extra attributes from the identity provider. Required to get the Access Token using client credentials grant flow.
         */
        clientSecret: pulumi.Input<inputs.iam.WorkforcePoolProviderExtraAttributesOauth2ClientClientSecret>;
        /**
         * The OIDC identity provider's issuer URI. Must be a valid URI using the 'https' scheme. Required to get the OIDC discovery document.
         */
        issuerUri: pulumi.Input<string>;
        /**
         * Represents the parameters to control which claims are fetched from an IdP.
         */
        queryParameters?: pulumi.Input<inputs.iam.WorkforcePoolProviderExtraAttributesOauth2ClientQueryParameters>;
    }

    export interface WorkforcePoolProviderExtraAttributesOauth2ClientClientSecret {
        /**
         * The value of the client secret.
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.iam.WorkforcePoolProviderExtraAttributesOauth2ClientClientSecretValue>;
    }

    export interface WorkforcePoolProviderExtraAttributesOauth2ClientClientSecretValue {
        /**
         * The plain text of the client secret value.
         */
        plainText: pulumi.Input<string>;
        /**
         * (Output)
         * A thumbprint to represent the current client secret value.
         */
        thumbprint?: pulumi.Input<string>;
    }

    export interface WorkforcePoolProviderExtraAttributesOauth2ClientQueryParameters {
        /**
         * The filter used to request specific records from IdP. In case of attributes type as AZURE_AD_GROUPS_MAIL and AZURE_AD_GROUPS_ID, it represents the
         * filter used to request specific groups for users from IdP. By default, all of the groups associated with the user are fetched. The
         * groups should be security enabled. See https://learn.microsoft.com/en-us/graph/search-query-parameter for more details.
         */
        filter?: pulumi.Input<string>;
    }

    export interface WorkforcePoolProviderOidc {
        /**
         * The client ID. Must match the audience claim of the JWT issued by the identity provider.
         */
        clientId: pulumi.Input<string>;
        /**
         * The optional client secret. Required to enable Authorization Code flow for web sign-in.
         * Structure is documented below.
         */
        clientSecret?: pulumi.Input<inputs.iam.WorkforcePoolProviderOidcClientSecret>;
        /**
         * The OIDC issuer URI. Must be a valid URI using the 'https' scheme.
         */
        issuerUri: pulumi.Input<string>;
        /**
         * OIDC JWKs in JSON String format. For details on definition of a
         * JWK, see https:tools.ietf.org/html/rfc7517. If not set, then we
         * use the `jwksUri` from the discovery document fetched from the
         * .well-known path for the `issuerUri`. Currently, RSA and EC asymmetric
         * keys are supported. The JWK must use following format and include only
         * the following fields:
         * ```
         * {
         * "keys": [
         * {
         * "kty": "RSA/EC",
         * "alg": "<algorithm>",
         * "use": "sig",
         * "kid": "<key-id>",
         * "n": "",
         * "e": "",
         * "x": "",
         * "y": "",
         * "crv": ""
         * }
         * ]
         * }
         * ```
         */
        jwksJson?: pulumi.Input<string>;
        /**
         * Configuration for web single sign-on for the OIDC provider. Here, web sign-in refers to console sign-in and gcloud sign-in through the browser.
         * Structure is documented below.
         */
        webSsoConfig?: pulumi.Input<inputs.iam.WorkforcePoolProviderOidcWebSsoConfig>;
    }

    export interface WorkforcePoolProviderOidcClientSecret {
        /**
         * The value of the client secret.
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.iam.WorkforcePoolProviderOidcClientSecretValue>;
    }

    export interface WorkforcePoolProviderOidcClientSecretValue {
        /**
         * The plain text of the client secret value.
         */
        plainText: pulumi.Input<string>;
        /**
         * (Output)
         * A thumbprint to represent the current client secret value.
         */
        thumbprint?: pulumi.Input<string>;
    }

    export interface WorkforcePoolProviderOidcWebSsoConfig {
        /**
         * Additional scopes to request for in the OIDC authentication request on top of scopes requested by default. By default, the `openid`, `profile` and `email` scopes that are supported by the identity provider are requested.
         * Each additional scope may be at most 256 characters. A maximum of 10 additional scopes may be configured.
         *
         * <a name="nestedExtraAttributesOauth2Client"></a>The `extraAttributesOauth2Client` block supports:
         */
        additionalScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The behavior for how OIDC Claims are included in the `assertion` object used for attribute mapping and attribute condition.
         * * MERGE_USER_INFO_OVER_ID_TOKEN_CLAIMS: Merge the UserInfo Endpoint Claims with ID Token Claims, preferring UserInfo Claim Values for the same Claim Name. This option is available only for the Authorization Code Flow.
         * * ONLY_ID_TOKEN_CLAIMS: Only include ID Token Claims.
         * Possible values are: `MERGE_USER_INFO_OVER_ID_TOKEN_CLAIMS`, `ONLY_ID_TOKEN_CLAIMS`.
         */
        assertionClaimsBehavior: pulumi.Input<string>;
        /**
         * The Response Type to request for in the OIDC Authorization Request for web sign-in.
         * The `CODE` Response Type is recommended to avoid the Implicit Flow, for security reasons.
         * * CODE: The `response_type=code` selection uses the Authorization Code Flow for web sign-in. Requires a configured client secret.
         * * ID_TOKEN: The `response_type=id_token` selection uses the Implicit Flow for web sign-in.
         * Possible values are: `CODE`, `ID_TOKEN`.
         */
        responseType: pulumi.Input<string>;
    }

    export interface WorkforcePoolProviderSaml {
        /**
         * SAML Identity provider configuration metadata xml doc.
         * The xml document should comply with [SAML 2.0 specification](https://docs.oasis-open.org/security/saml/v2.0/saml-metadata-2.0-os.pdf).
         * The max size of the acceptable xml document will be bounded to 128k characters.
         * The metadata xml document should satisfy the following constraints:
         * 1) Must contain an Identity Provider Entity ID.
         * 2) Must contain at least one non-expired signing key certificate.
         * 3) For each signing key:
         * a) Valid from should be no more than 7 days from now.
         * b) Valid to should be no more than 10 years in the future.
         * 4) Up to 3 IdP signing keys are allowed in the metadata xml.
         * When updating the provider's metadata xml, at least one non-expired signing key
         * must overlap with the existing metadata. This requirement is skipped if there are
         * no non-expired signing keys present in the existing metadata.
         */
        idpMetadataXml: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolInlineCertificateIssuanceConfig {
        /**
         * A required mapping of a cloud region to the CA pool resource located in that region used
         * for certificate issuance, adhering to these constraints:
         * * **Key format:** A supported cloud region name equivalent to the location identifier in
         * the corresponding map entry's value.
         * * **Value format:** A valid CA pool resource path format like:
         * `projects/{project}/locations/{location}/caPools/{ca_pool}`
         * * **Region Matching:** Workloads are ONLY issued certificates from CA pools within the
         * same region. Also the CA pool region (in value) must match the workload's region (key).
         */
        caPools: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Key algorithm to use when generating the key pair. This key pair will be used to create
         * the certificate. If unspecified, this will default to `ECDSA_P256`.
         * * `RSA_2048`: Specifies RSA with a 2048-bit modulus.
         * * `RSA_3072`: Specifies RSA with a 3072-bit modulus.
         * * `RSA_4096`: Specifies RSA with a 4096-bit modulus.
         * * `ECDSA_P256`: Specifies ECDSA with curve P256.
         * * `ECDSA_P384`: Specifies ECDSA with curve P384.
         * Possible values are: `RSA_2048`, `RSA_3072`, `RSA_4096`, `ECDSA_P256`, `ECDSA_P384`.
         */
        keyAlgorithm?: pulumi.Input<string>;
        /**
         * Lifetime of the workload certificates issued by the CA pool in seconds. Must be between
         * `86400s` (24 hours) to `2592000s` (30 days), ends in the suffix "`s`" (indicating seconds)
         * and is preceded by the number of seconds. If unspecified, this will be defaulted to
         * `86400s` (24 hours).
         */
        lifetime?: pulumi.Input<string>;
        /**
         * Rotation window percentage indicating when certificate rotation should be initiated based
         * on remaining lifetime. Must be between `50` - `80`. If unspecified, this will be defaulted
         * to `50`.
         */
        rotationWindowPercentage?: pulumi.Input<number>;
    }

    export interface WorkloadIdentityPoolInlineTrustConfig {
        /**
         * Maps specific trust domains (e.g., "example.com") to their corresponding `TrustStore`
         * objects, which contain the trusted root certificates for that domain. There can be a
         * maximum of `10` trust domain entries in this map.
         * Note that a trust domain automatically trusts itself and don't need to be specified here.
         * If however, this `WorkloadIdentityPool`'s trust domain contains any trust anchors in the
         * `additionalTrustBundles` map, those trust anchors will be *appended to* the Trust Bundle
         * automatically derived from your `InlineCertificateIssuanceConfig`'s `caPools`.
         * Structure is documented below.
         */
        additionalTrustBundles?: pulumi.Input<pulumi.Input<inputs.iam.WorkloadIdentityPoolInlineTrustConfigAdditionalTrustBundle>[]>;
    }

    export interface WorkloadIdentityPoolInlineTrustConfigAdditionalTrustBundle {
        /**
         * List of Trust Anchors to be used while performing validation against a given
         * `TrustStore`. The incoming end entity's certificate must be chained up to one of the
         * trust anchors here.
         * Structure is documented below.
         */
        trustAnchors: pulumi.Input<pulumi.Input<inputs.iam.WorkloadIdentityPoolInlineTrustConfigAdditionalTrustBundleTrustAnchor>[]>;
        /**
         * The identifier for this object. Format specified above.
         */
        trustDomain: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolInlineTrustConfigAdditionalTrustBundleTrustAnchor {
        /**
         * PEM certificate of the PKI used for validation. Must only contain one ca
         * certificate(either root or intermediate cert).
         */
        pemCertificate: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolProviderAws {
        /**
         * The AWS account ID.
         */
        accountId: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolProviderOidc {
        /**
         * Acceptable values for the `aud` field (audience) in the OIDC token. Token exchange
         * requests are rejected if the token audience does not match one of the configured
         * values. Each audience may be at most 256 characters. A maximum of 10 audiences may
         * be configured.
         * If this list is empty, the OIDC token audience must be equal to the full canonical
         * resource name of the WorkloadIdentityPoolProvider, with or without the HTTPS prefix.
         * For example:
         * ```
         * //iam.googleapis.com/projects/<project-number>/locations/<location>/workloadIdentityPools/<pool-id>/providers/<provider-id>
         * https://iam.googleapis.com/projects/<project-number>/locations/<location>/workloadIdentityPools/<pool-id>/providers/<provider-id>
         * ```
         */
        allowedAudiences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The OIDC issuer URL.
         */
        issuerUri: pulumi.Input<string>;
        /**
         * OIDC JWKs in JSON String format. For details on definition of a
         * JWK, see https:tools.ietf.org/html/rfc7517. If not set, then we
         * use the `jwksUri` from the discovery document fetched from the
         * .well-known path for the `issuerUri`. Currently, RSA and EC asymmetric
         * keys are supported. The JWK must use following format and include only
         * the following fields:
         * ```
         * {
         * "keys": [
         * {
         * "kty": "RSA/EC",
         * "alg": "<algorithm>",
         * "use": "sig",
         * "kid": "<key-id>",
         * "n": "",
         * "e": "",
         * "x": "",
         * "y": "",
         * "crv": ""
         * }
         * ]
         * }
         * ```
         */
        jwksJson?: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolProviderSaml {
        /**
         * SAML Identity provider configuration metadata xml doc.
         *
         * <a name="nestedX509"></a>The `x509` block supports:
         */
        idpMetadataXml: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolProviderX509 {
        /**
         * A Trust store, use this trust store as a wrapper to config the trust
         * anchor and optional intermediate cas to help build the trust chain for
         * the incoming end entity certificate. Follow the x509 guidelines to
         * define those PEM encoded certs. Only 1 trust store is currently
         * supported.
         */
        trustStore: pulumi.Input<inputs.iam.WorkloadIdentityPoolProviderX509TrustStore>;
    }

    export interface WorkloadIdentityPoolProviderX509TrustStore {
        /**
         * Set of intermediate CA certificates used for building the trust chain to
         * trust anchor.
         * IMPORTANT: Intermediate CAs are only supported when configuring x509 federation.
         * Structure is documented below.
         */
        intermediateCas?: pulumi.Input<pulumi.Input<inputs.iam.WorkloadIdentityPoolProviderX509TrustStoreIntermediateCa>[]>;
        /**
         * List of Trust Anchors to be used while performing validation
         * against a given TrustStore. The incoming end entity's certificate
         * must be chained up to one of the trust anchors here.
         * Structure is documented below.
         */
        trustAnchors: pulumi.Input<pulumi.Input<inputs.iam.WorkloadIdentityPoolProviderX509TrustStoreTrustAnchor>[]>;
    }

    export interface WorkloadIdentityPoolProviderX509TrustStoreIntermediateCa {
        /**
         * PEM certificate of the PKI used for validation. Must only contain one
         * ca certificate(either root or intermediate cert).
         */
        pemCertificate?: pulumi.Input<string>;
    }

    export interface WorkloadIdentityPoolProviderX509TrustStoreTrustAnchor {
        /**
         * PEM certificate of the PKI used for validation. Must only contain one
         * ca certificate(either root or intermediate cert).
         */
        pemCertificate?: pulumi.Input<string>;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface AppEngineVersionIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SettingsAccessSettings {
        /**
         * Settings to configure and enable allowed domains.
         * Structure is documented below.
         */
        allowedDomainsSettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsAllowedDomainsSettings>;
        /**
         * Configuration to allow cross-origin requests via IAP.
         * Structure is documented below.
         */
        corsSettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsCorsSettings>;
        /**
         * GCIP claims and endpoint configurations for 3p identity providers.
         * * Enabling gcipSetting significantly changes the way IAP authenticates users. Identity Platform does not support IAM, so IAP will not enforce any IAM policies for requests to your application.
         * Structure is documented below.
         */
        gcipSettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsGcipSettings>;
        /**
         * Identity sources that IAP can use to authenticate the end user. Only one identity source
         * can be configured. The possible values are:
         * * `WORKFORCE_IDENTITY_FEDERATION`: Use external identities set up on Google Cloud Workforce
         * Identity Federation.
         * Each value may be one of: `WORKFORCE_IDENTITY_FEDERATION`.
         */
        identitySources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Settings to configure IAP's OAuth behavior.
         * Structure is documented below.
         */
        oauthSettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsOauthSettings>;
        /**
         * Settings to configure reauthentication policies in IAP.
         * Structure is documented below.
         */
        reauthSettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsReauthSettings>;
        /**
         * Settings to configure the workforce identity federation, including workforce pools
         * and OAuth 2.0 settings.
         * Structure is documented below.
         */
        workforceIdentitySettings?: pulumi.Input<inputs.iap.SettingsAccessSettingsWorkforceIdentitySettings>;
    }

    export interface SettingsAccessSettingsAllowedDomainsSettings {
        /**
         * List of trusted domains.
         */
        domains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration for customers to opt in for the feature.
         */
        enable?: pulumi.Input<boolean>;
    }

    export interface SettingsAccessSettingsCorsSettings {
        /**
         * Configuration to allow HTTP OPTIONS calls to skip authorization.
         * If undefined, IAP will not apply any special logic to OPTIONS requests.
         */
        allowHttpOptions?: pulumi.Input<boolean>;
    }

    export interface SettingsAccessSettingsGcipSettings {
        /**
         * Login page URI associated with the GCIP tenants. Typically, all resources within
         * the same project share the same login page, though it could be overridden at the
         * sub resource level.
         */
        loginPageUri?: pulumi.Input<string>;
        /**
         * GCIP tenant ids that are linked to the IAP resource. tenantIds could be a string
         * beginning with a number character to indicate authenticating with GCIP tenant flow,
         * or in the format of _ to indicate authenticating with GCIP agent flow. If agent flow
         * is used, tenantIds should only contain one single element, while for tenant flow,
         * tenantIds can contain multiple elements.
         */
        tenantIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingsAccessSettingsOauthSettings {
        /**
         * Domain hint to send as hd=? parameter in OAuth request flow.
         * Enables redirect to primary IDP by skipping Google's login screen.
         * (https://developers.google.com/identity/protocols/OpenIDConnect#hd-param)
         * Note: IAP does not verify that the id token's hd claim matches this value
         * since access behavior is managed by IAM policies.
         * * loginHint setting is not a replacement for access control. Always enforce an appropriate access policy if you want to restrict access to users outside your domain.
         */
        loginHint?: pulumi.Input<string>;
        /**
         * List of client ids allowed to use IAP programmatically.
         */
        programmaticClients?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingsAccessSettingsReauthSettings {
        /**
         * Reauth session lifetime, how long before a user has to reauthenticate again.
         * A duration in seconds with up to nine fractional digits, ending with 's'.
         * Example: "3.5s".
         */
        maxAge: pulumi.Input<string>;
        /**
         * Reauth method requested. The possible values are:
         * * `LOGIN`: Prompts the user to log in again.
         * * `SECURE_KEY`: User must use their secure key 2nd factor device.
         * * `ENROLLED_SECOND_FACTORS`: User can use any enabled 2nd factor.
         * Possible values are: `LOGIN`, `SECURE_KEY`, `ENROLLED_SECOND_FACTORS`.
         */
        method: pulumi.Input<string>;
        /**
         * How IAP determines the effective policy in cases of hierarchical policies.
         * Policies are merged from higher in the hierarchy to lower in the hierarchy.
         * The possible values are:
         * * `MINIMUM`: This policy acts as a minimum to other policies, lower in the hierarchy.
         * Effective policy may only be the same or stricter.
         * * `DEFAULT`: This policy acts as a default if no other reauth policy is set.
         * Possible values are: `MINIMUM`, `DEFAULT`.
         */
        policyType: pulumi.Input<string>;
    }

    export interface SettingsAccessSettingsWorkforceIdentitySettings {
        /**
         * OAuth 2.0 settings for IAP to perform OIDC flow with workforce identity
         * federation services.
         * Structure is documented below.
         *
         *
         * <a name="nestedAccessSettingsWorkforceIdentitySettingsOauth2"></a>The `oauth2` block supports:
         */
        oauth2?: pulumi.Input<inputs.iap.SettingsAccessSettingsWorkforceIdentitySettingsOauth2>;
        /**
         * The workforce pool resources. Only one workforce pool is accepted.
         */
        workforcePools?: pulumi.Input<string>;
    }

    export interface SettingsAccessSettingsWorkforceIdentitySettingsOauth2 {
        /**
         * The OAuth 2.0 client ID registered in the workforce identity
         * federation OAuth 2.0 Server.
         */
        clientId?: pulumi.Input<string>;
        /**
         * Input only. The OAuth 2.0 client secret created while registering
         * the client ID.
         */
        clientSecret?: pulumi.Input<string>;
        /**
         * Output only. SHA256 hash value for the client secret. This field
         * is returned by IAP when the settings are retrieved.
         */
        clientSecretSha256?: pulumi.Input<string>;
    }

    export interface SettingsApplicationSettings {
        /**
         * Customization for Access Denied page. IAP allows customers to define a custom URI
         * to use as the error page when access is denied to users. If IAP prevents access
         * to this page, the default IAP error page will be displayed instead.
         * Structure is documented below.
         */
        accessDeniedPageSettings?: pulumi.Input<inputs.iap.SettingsApplicationSettingsAccessDeniedPageSettings>;
        /**
         * Settings to configure attribute propagation.
         * Structure is documented below.
         */
        attributePropagationSettings?: pulumi.Input<inputs.iap.SettingsApplicationSettingsAttributePropagationSettings>;
        /**
         * The Domain value to set for cookies generated by IAP. This value is not validated by the API,
         * but will be ignored at runtime if invalid.
         */
        cookieDomain?: pulumi.Input<string>;
        /**
         * Settings to configure IAP's behavior for a service mesh.
         * Structure is documented below.
         */
        csmSettings?: pulumi.Input<inputs.iap.SettingsApplicationSettingsCsmSettings>;
    }

    export interface SettingsApplicationSettingsAccessDeniedPageSettings {
        /**
         * The URI to be redirected to when access is denied.
         */
        accessDeniedPageUri?: pulumi.Input<string>;
        /**
         * Whether to generate a troubleshooting URL on access denied events to this application.
         */
        generateTroubleshootingUri?: pulumi.Input<boolean>;
        /**
         * Whether to generate remediation token on access denied events to this application.
         */
        remediationTokenGenerationEnabled?: pulumi.Input<boolean>;
    }

    export interface SettingsApplicationSettingsAttributePropagationSettings {
        /**
         * Whether the provided attribute propagation settings should be evaluated on user requests.
         * If set to true, attributes returned from the expression will be propagated in the set output credentials.
         */
        enable?: pulumi.Input<boolean>;
        /**
         * Raw string CEL expression. Must return a list of attributes. A maximum of 45 attributes can
         * be selected. Expressions can select different attribute types from attributes:
         * attributes.saml_attributes, attributes.iap_attributes.
         */
        expression?: pulumi.Input<string>;
        /**
         * Which output credentials attributes selected by the CEL expression should be propagated in.
         * All attributes will be fully duplicated in each selected output credential.
         * Possible values are:
         * * `HEADER`: Propagate attributes in the headers with "x-goog-iap-attr-" prefix.
         * * `JWT`: Propagate attributes in the JWT of the form:
         * "additionalClaims": { "myAttribute": ["value1", "value2"] }
         * * `RCTOKEN`: Propagate attributes in the RCToken of the form: "
         * additionalClaims": { "myAttribute": ["value1", "value2"] }
         * Each value may be one of: `HEADER`, `JWT`, `RCTOKEN`.
         */
        outputCredentials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingsApplicationSettingsCsmSettings {
        /**
         * Audience claim set in the generated RCToken. This value is not validated by IAP.
         */
        rctokenAud?: pulumi.Input<string>;
    }

    export interface TunnelDestGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelDestGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface TunnelInstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebBackendServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebCloudRunServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebCloudRunServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebRegionBackendServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebRegionBackendServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface WebTypeComputeIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }
}

export namespace identityplatform {
    export interface ConfigBlockingFunctions {
        /**
         * The user credentials to include in the JWT payload that is sent to the registered Blocking Functions.
         * Structure is documented below.
         */
        forwardInboundCredentials?: pulumi.Input<inputs.identityplatform.ConfigBlockingFunctionsForwardInboundCredentials>;
        /**
         * Map of Trigger to event type. Key should be one of the supported event types: "beforeCreate", "beforeSignIn".
         * Structure is documented below.
         */
        triggers: pulumi.Input<pulumi.Input<inputs.identityplatform.ConfigBlockingFunctionsTrigger>[]>;
    }

    export interface ConfigBlockingFunctionsForwardInboundCredentials {
        /**
         * Whether to pass the user's OAuth identity provider's access token.
         */
        accessToken?: pulumi.Input<boolean>;
        /**
         * Whether to pass the user's OIDC identity provider's ID token.
         */
        idToken?: pulumi.Input<boolean>;
        /**
         * Whether to pass the user's OAuth identity provider's refresh token.
         */
        refreshToken?: pulumi.Input<boolean>;
    }

    export interface ConfigBlockingFunctionsTrigger {
        /**
         * The identifier for this object. Format specified above.
         */
        eventType: pulumi.Input<string>;
        /**
         * HTTP URI trigger for the Cloud Function.
         */
        functionUri: pulumi.Input<string>;
        /**
         * (Output)
         * When the trigger was changed.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface ConfigClient {
        /**
         * (Output)
         * API key that can be used when making requests for this project.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        apiKey?: pulumi.Input<string>;
        /**
         * (Output)
         * Firebase subdomain.
         */
        firebaseSubdomain?: pulumi.Input<string>;
        /**
         * Configuration related to restricting a user's ability to affect their account.
         * Structure is documented below.
         */
        permissions?: pulumi.Input<inputs.identityplatform.ConfigClientPermissions>;
    }

    export interface ConfigClientPermissions {
        /**
         * When true, end users cannot delete their account on the associated project through any of our API methods
         */
        disabledUserDeletion?: pulumi.Input<boolean>;
        /**
         * When true, end users cannot sign up for a new account on the associated project through any of our API methods
         */
        disabledUserSignup?: pulumi.Input<boolean>;
    }

    export interface ConfigMfa {
        /**
         * A list of usable second factors for this project.
         * Each value may be one of: `PHONE_SMS`.
         */
        enabledProviders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of usable second factors for this project along with their configurations.
         * This field does not support phone based MFA, for that use the 'enabledProviders' field.
         * Structure is documented below.
         */
        providerConfigs?: pulumi.Input<pulumi.Input<inputs.identityplatform.ConfigMfaProviderConfig>[]>;
        /**
         * Whether MultiFactor Authentication has been enabled for this project.
         * Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
         */
        state?: pulumi.Input<string>;
    }

    export interface ConfigMfaProviderConfig {
        /**
         * Whether MultiFactor Authentication has been enabled for this project.
         * Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
         */
        state?: pulumi.Input<string>;
        /**
         * TOTP MFA provider config for this project.
         * Structure is documented below.
         */
        totpProviderConfig?: pulumi.Input<inputs.identityplatform.ConfigMfaProviderConfigTotpProviderConfig>;
    }

    export interface ConfigMfaProviderConfigTotpProviderConfig {
        /**
         * The allowed number of adjacent intervals that will be used for verification to avoid clock skew.
         */
        adjacentIntervals?: pulumi.Input<number>;
    }

    export interface ConfigMonitoring {
        /**
         * Configuration for logging requests made to this project to Stackdriver Logging
         * Structure is documented below.
         */
        requestLogging?: pulumi.Input<inputs.identityplatform.ConfigMonitoringRequestLogging>;
    }

    export interface ConfigMonitoringRequestLogging {
        /**
         * Whether logging is enabled for this project or not.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ConfigMultiTenant {
        /**
         * Whether this project can have tenants or not.
         */
        allowTenants?: pulumi.Input<boolean>;
        /**
         * The default cloud parent org or folder that the tenant project should be created under.
         * The parent resource name should be in the format of "/", such as "folders/123" or "organizations/456".
         * If the value is not set, the tenant will be created under the same organization or folder as the agent project.
         */
        defaultTenantLocation?: pulumi.Input<string>;
    }

    export interface ConfigQuota {
        /**
         * Quota for the Signup endpoint, if overwritten. Signup quota is measured in sign ups per project per hour per IP. None of quota, startTime, or quotaDuration can be skipped.
         * Structure is documented below.
         */
        signUpQuotaConfig?: pulumi.Input<inputs.identityplatform.ConfigQuotaSignUpQuotaConfig>;
    }

    export interface ConfigQuotaSignUpQuotaConfig {
        /**
         * A sign up APIs quota that customers can override temporarily. Value can be in between 1 and 1000.
         */
        quota?: pulumi.Input<number>;
        /**
         * How long this quota will be active for. It is measurred in seconds, e.g., Example: "9.615s".
         */
        quotaDuration?: pulumi.Input<string>;
        /**
         * When this quota will take affect.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface ConfigSignIn {
        /**
         * Whether to allow more than one account to have the same email.
         */
        allowDuplicateEmails?: pulumi.Input<boolean>;
        /**
         * Configuration options related to authenticating an anonymous user.
         * Structure is documented below.
         */
        anonymous?: pulumi.Input<inputs.identityplatform.ConfigSignInAnonymous>;
        /**
         * Configuration options related to authenticating a user by their email address.
         * Structure is documented below.
         */
        email?: pulumi.Input<inputs.identityplatform.ConfigSignInEmail>;
        /**
         * (Output)
         * Output only. Hash config information.
         * Structure is documented below.
         */
        hashConfigs?: pulumi.Input<pulumi.Input<inputs.identityplatform.ConfigSignInHashConfig>[]>;
        /**
         * Configuration options related to authenticated a user by their phone number.
         * Structure is documented below.
         */
        phoneNumber?: pulumi.Input<inputs.identityplatform.ConfigSignInPhoneNumber>;
    }

    export interface ConfigSignInAnonymous {
        /**
         * Whether anonymous user auth is enabled for the project or not.
         *
         * <a name="nestedSignInHashConfig"></a>The `hashConfig` block contains:
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ConfigSignInEmail {
        /**
         * Whether email auth is enabled for the project or not.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Whether a password is required for email auth or not. If true, both an email and
         * password must be provided to sign in. If false, a user may sign in via either
         * email/password or email link.
         */
        passwordRequired?: pulumi.Input<boolean>;
    }

    export interface ConfigSignInHashConfig {
        /**
         * Different password hash algorithms used in Identity Toolkit.
         */
        algorithm?: pulumi.Input<string>;
        /**
         * Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
         */
        memoryCost?: pulumi.Input<number>;
        /**
         * How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
         */
        rounds?: pulumi.Input<number>;
        /**
         * Non-printable character to be inserted between the salt and plain text password in base64.
         */
        saltSeparator?: pulumi.Input<string>;
        /**
         * Signer key in base64.
         */
        signerKey?: pulumi.Input<string>;
    }

    export interface ConfigSignInPhoneNumber {
        /**
         * Whether phone number auth is enabled for the project or not.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * A map of <test phone number, fake code> that can be used for phone auth testing.
         */
        testPhoneNumbers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ConfigSmsRegionConfig {
        /**
         * A policy of allowing SMS to every region by default and adding disallowed regions to a disallow list.
         * Structure is documented below.
         */
        allowByDefault?: pulumi.Input<inputs.identityplatform.ConfigSmsRegionConfigAllowByDefault>;
        /**
         * A policy of only allowing regions by explicitly adding them to an allowlist.
         * Structure is documented below.
         */
        allowlistOnly?: pulumi.Input<inputs.identityplatform.ConfigSmsRegionConfigAllowlistOnly>;
    }

    export interface ConfigSmsRegionConfigAllowByDefault {
        /**
         * Two letter unicode region codes to disallow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
         */
        disallowedRegions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfigSmsRegionConfigAllowlistOnly {
        /**
         * Two letter unicode region codes to allow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
         */
        allowedRegions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InboundSamlConfigIdpConfig {
        /**
         * The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
         * Structure is documented below.
         */
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate>[]>;
        /**
         * Unique identifier for all SAML entities
         */
        idpEntityId: pulumi.Input<string>;
        /**
         * Indicates if outbounding SAMLRequest should be signed.
         */
        signRequest?: pulumi.Input<boolean>;
        /**
         * URL to send Authentication request to.
         */
        ssoUrl: pulumi.Input<string>;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        /**
         * The IdP's x509 certificate.
         */
        x509Certificate?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfig {
        /**
         * Callback URI where responses from IDP are handled. Must start with `https://`.
         */
        callbackUri?: pulumi.Input<string>;
        /**
         * (Output)
         * The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
         * Structure is documented below.
         *
         *
         * <a name="nestedSpConfigSpCertificates"></a>The `spCertificates` block contains:
         */
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.InboundSamlConfigSpConfigSpCertificate>[]>;
        /**
         * Unique identifier for all SAML entities.
         */
        spEntityId?: pulumi.Input<string>;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        /**
         * The x509 certificate
         */
        x509Certificate?: pulumi.Input<string>;
    }

    export interface OauthIdpConfigResponseType {
        /**
         * If true, authorization code is returned from IdP's authorization endpoint.
         */
        code?: pulumi.Input<boolean>;
        /**
         * If true, ID token is returned from IdP's authorization endpoint.
         */
        idToken?: pulumi.Input<boolean>;
    }

    export interface TenantClient {
        /**
         * Configuration related to restricting a user's ability to affect their account.
         * Structure is documented below.
         */
        permissions?: pulumi.Input<inputs.identityplatform.TenantClientPermissions>;
    }

    export interface TenantClientPermissions {
        /**
         * When true, end users cannot delete their account on the associated project through any of our API methods.
         */
        disabledUserDeletion?: pulumi.Input<boolean>;
        /**
         * When true, end users cannot sign up for a new account on the associated project through any of our API methods.
         */
        disabledUserSignup?: pulumi.Input<boolean>;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        /**
         * The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
         * Structure is documented below.
         */
        idpCertificates: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate>[]>;
        /**
         * Unique identifier for all SAML entities
         */
        idpEntityId: pulumi.Input<string>;
        /**
         * Indicates if outbounding SAMLRequest should be signed.
         */
        signRequest?: pulumi.Input<boolean>;
        /**
         * URL to send Authentication request to.
         */
        ssoUrl: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        /**
         * The x509 certificate
         */
        x509Certificate?: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfig {
        /**
         * Callback URI where responses from IDP are handled. Must start with `https://`.
         */
        callbackUri: pulumi.Input<string>;
        /**
         * (Output)
         * The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
         * Structure is documented below.
         *
         *
         * <a name="nestedSpConfigSpCertificates"></a>The `spCertificates` block contains:
         */
        spCertificates?: pulumi.Input<pulumi.Input<inputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate>[]>;
        /**
         * Unique identifier for all SAML entities.
         */
        spEntityId: pulumi.Input<string>;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        /**
         * The x509 certificate
         */
        x509Certificate?: pulumi.Input<string>;
    }
}

export namespace integrationconnectors {
    export interface ConnectionAuthConfig {
        /**
         * List containing additional auth configs.
         * Structure is documented below.
         */
        additionalVariables?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigAdditionalVariable>[]>;
        /**
         * The type of authentication configured.
         */
        authKey?: pulumi.Input<string>;
        /**
         * authType of the Connection
         * Possible values are: `USER_PASSWORD`.
         */
        authType: pulumi.Input<string>;
        /**
         * Parameters to support Oauth 2.0 Auth Code Grant Authentication.
         * Structure is documented below.
         */
        oauth2AuthCodeFlow?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2AuthCodeFlow>;
        /**
         * OAuth3 Client Credentials for Authentication.
         * Structure is documented below.
         */
        oauth2ClientCredentials?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2ClientCredentials>;
        /**
         * OAuth2 JWT Bearer for Authentication.
         * Structure is documented below.
         */
        oauth2JwtBearer?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2JwtBearer>;
        /**
         * SSH Public Key for Authentication.
         * Structure is documented below.
         */
        sshPublicKey?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigSshPublicKey>;
        /**
         * User password for Authentication.
         * Structure is documented below.
         */
        userPassword?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigUserPassword>;
    }

    export interface ConnectionAuthConfigAdditionalVariable {
        /**
         * Boolean Value of configVariable.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Encryption key value of configVariable.
         * Structure is documented below.
         */
        encryptionKeyValue?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigAdditionalVariableEncryptionKeyValue>;
        /**
         * Integer Value of configVariable.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * Key for the configVariable
         */
        key: pulumi.Input<string>;
        /**
         * Secret value of configVariable
         * Structure is documented below.
         */
        secretValue?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigAdditionalVariableSecretValue>;
        /**
         * String Value of configVariabley.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigAdditionalVariableEncryptionKeyValue {
        /**
         * The [KMS key name] with which the content of the Operation is encrypted. The
         * expected format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         * Will be empty string if google managed.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Type of Encryption Key
         * Possible values are: `GOOGLE_MANAGED`, `CUSTOMER_MANAGED`.
         */
        type: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigAdditionalVariableSecretValue {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigOauth2AuthCodeFlow {
        /**
         * Auth URL for Authorization Code Flow.
         */
        authUri?: pulumi.Input<string>;
        /**
         * Client ID for user-provided OAuth app.
         */
        clientId?: pulumi.Input<string>;
        /**
         * Client secret for user-provided OAuth app.
         */
        clientSecret?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2AuthCodeFlowClientSecret>;
        /**
         * Whether to enable PKCE when the user performs the auth code flow.
         */
        enablePkce?: pulumi.Input<boolean>;
        /**
         * Scopes the connection will request when the user performs the auth code flow.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConnectionAuthConfigOauth2AuthCodeFlowClientSecret {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigOauth2ClientCredentials {
        /**
         * Secret version of Password for Authentication.
         */
        clientId: pulumi.Input<string>;
        /**
         * Secret version reference containing the client secret.
         */
        clientSecret?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2ClientCredentialsClientSecret>;
    }

    export interface ConnectionAuthConfigOauth2ClientCredentialsClientSecret {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigOauth2JwtBearer {
        /**
         * Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate.
         * This private key will be used to sign JWTs used for the jwt-bearer authorization grant.
         * Specified in the form as: projects/*&#47;secrets/*&#47;versions/*.
         */
        clientKey?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2JwtBearerClientKey>;
        /**
         * JwtClaims providers fields to generate the token.
         */
        jwtClaims?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigOauth2JwtBearerJwtClaims>;
    }

    export interface ConnectionAuthConfigOauth2JwtBearerClientKey {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigOauth2JwtBearerJwtClaims {
        /**
         * Value for the "aud" claim.
         *
         * <a name="nestedAuthConfigOauth2ClientCredentials"></a>The `oauth2ClientCredentials` block supports:
         */
        audience?: pulumi.Input<string>;
        /**
         * Value for the "iss" claim.
         */
        issuer?: pulumi.Input<string>;
        /**
         * Value for the "sub" claim.
         */
        subject?: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigSshPublicKey {
        /**
         * Format of SSH Client cert.
         */
        certType?: pulumi.Input<string>;
        /**
         * SSH Client Cert. It should contain both public and private key.
         * Structure is documented below.
         */
        sshClientCert?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigSshPublicKeySshClientCert>;
        /**
         * Password (passphrase) for ssh client certificate if it has one.
         * Structure is documented below.
         */
        sshClientCertPass?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigSshPublicKeySshClientCertPass>;
        /**
         * The user account used to authenticate.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigSshPublicKeySshClientCert {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigSshPublicKeySshClientCertPass {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         *
         * <a name="nestedAuthConfigOauth2AuthCodeFlow"></a>The `oauth2AuthCodeFlow` block supports:
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigUserPassword {
        /**
         * Password for Authentication.
         * Structure is documented below.
         */
        password?: pulumi.Input<inputs.integrationconnectors.ConnectionAuthConfigUserPasswordPassword>;
        /**
         * Username for Authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectionAuthConfigUserPasswordPassword {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionConfigVariable {
        /**
         * Boolean Value of configVariable
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Encryption key value of configVariable.
         * Structure is documented below.
         */
        encryptionKeyValue?: pulumi.Input<inputs.integrationconnectors.ConnectionConfigVariableEncryptionKeyValue>;
        /**
         * Integer Value of configVariable
         */
        integerValue?: pulumi.Input<number>;
        /**
         * Key for the configVariable
         */
        key: pulumi.Input<string>;
        /**
         * Secret value of configVariable.
         * Structure is documented below.
         */
        secretValue?: pulumi.Input<inputs.integrationconnectors.ConnectionConfigVariableSecretValue>;
        /**
         * String Value of configVariabley
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface ConnectionConfigVariableEncryptionKeyValue {
        /**
         * The [KMS key name] with which the content of the Operation is encrypted. The
         * expected format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         * Will be empty string if google managed.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Type of Encryption Key
         * Possible values are: `GOOGLE_MANAGED`, `CUSTOMER_MANAGED`.
         */
        type: pulumi.Input<string>;
    }

    export interface ConnectionConfigVariableSecretValue {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionConnectorVersionInfraConfig {
        /**
         * (Output)
         * Max QPS supported by the connector version before throttling of requests.
         */
        ratelimitThreshold?: pulumi.Input<string>;
    }

    export interface ConnectionDestinationConfig {
        /**
         * The destinations for the key.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionDestinationConfigDestination>[]>;
        /**
         * The key is the destination identifier that is supported by the Connector.
         */
        key: pulumi.Input<string>;
    }

    export interface ConnectionDestinationConfigDestination {
        /**
         * Host
         */
        host?: pulumi.Input<string>;
        /**
         * port number
         */
        port?: pulumi.Input<number>;
        /**
         * Service Attachment
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfig {
        /**
         * List containing additional auth configs.
         * Structure is documented below.
         */
        additionalVariables?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAdditionalVariable>[]>;
        /**
         * authConfig for Eventing Configuration.
         * Structure is documented below.
         */
        authConfig?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfig>;
        /**
         * Enrichment Enabled.
         */
        enrichmentEnabled?: pulumi.Input<boolean>;
        /**
         * registrationDestinationConfig
         * Structure is documented below.
         */
        registrationDestinationConfig: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigRegistrationDestinationConfig>;
    }

    export interface ConnectionEventingConfigAdditionalVariable {
        /**
         * Boolean Value of configVariable.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Encryption key value of configVariable.
         * Structure is documented below.
         */
        encryptionKeyValue?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAdditionalVariableEncryptionKeyValue>;
        /**
         * Integer Value of configVariable.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * Key for the configVariable
         */
        key: pulumi.Input<string>;
        /**
         * Secret value of configVariable
         * Structure is documented below.
         */
        secretValue?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAdditionalVariableSecretValue>;
        /**
         * String Value of configVariabley.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAdditionalVariableEncryptionKeyValue {
        /**
         * The [KMS key name] with which the content of the Operation is encrypted. The
         * expected format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         * Will be empty string if google managed.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Type of Encryption Key
         * Possible values are: `GOOGLE_MANAGED`, `CUSTOMER_MANAGED`.
         */
        type?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAdditionalVariableSecretValue {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAuthConfig {
        /**
         * List containing additional auth configs.
         * Structure is documented below.
         */
        additionalVariables?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfigAdditionalVariable>[]>;
        /**
         * The type of authentication configured.
         */
        authKey?: pulumi.Input<string>;
        /**
         * authType of the Connection
         * Possible values are: `USER_PASSWORD`.
         */
        authType: pulumi.Input<string>;
        /**
         * User password for Authentication.
         * Structure is documented below.
         */
        userPassword: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfigUserPassword>;
    }

    export interface ConnectionEventingConfigAuthConfigAdditionalVariable {
        /**
         * Boolean Value of configVariable.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Encryption key value of configVariable.
         * Structure is documented below.
         */
        encryptionKeyValue?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue>;
        /**
         * Integer Value of configVariable.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * Key for the configVariable
         */
        key: pulumi.Input<string>;
        /**
         * Secret value of configVariable
         * Structure is documented below.
         */
        secretValue?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfigAdditionalVariableSecretValue>;
        /**
         * String Value of configVariabley.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue {
        /**
         * The [KMS key name] with which the content of the Operation is encrypted. The
         * expected format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         * Will be empty string if google managed.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Type of Encryption Key
         * Possible values are: `GOOGLE_MANAGED`, `CUSTOMER_MANAGED`.
         */
        type?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAuthConfigAdditionalVariableSecretValue {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAuthConfigUserPassword {
        /**
         * Password for Authentication.
         * Structure is documented below.
         */
        password?: pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigAuthConfigUserPasswordPassword>;
        /**
         * Username for Authentication.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigAuthConfigUserPasswordPassword {
        /**
         * The resource name of the secret version in the format,
         * format as: projects/*&#47;secrets/*&#47;versions/*.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigRegistrationDestinationConfig {
        /**
         * destinations for the connection
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionEventingConfigRegistrationDestinationConfigDestination>[]>;
        /**
         * Key for the connection
         */
        key?: pulumi.Input<string>;
    }

    export interface ConnectionEventingConfigRegistrationDestinationConfigDestination {
        /**
         * Host
         */
        host?: pulumi.Input<string>;
        /**
         * port number
         */
        port?: pulumi.Input<number>;
        /**
         * Service Attachment
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface ConnectionEventingRuntimeData {
        /**
         * Events listener endpoint. The value will populated after provisioning the events listener.
         */
        eventsListenerEndpoint?: pulumi.Input<string>;
        /**
         * (Output)
         * Current status of eventing.
         * Structure is documented below.
         */
        statuses?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionEventingRuntimeDataStatus>[]>;
    }

    export interface ConnectionEventingRuntimeDataStatus {
        /**
         * An arbitrary description for the Connection.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the Eventing
         */
        state?: pulumi.Input<string>;
    }

    export interface ConnectionLockConfig {
        /**
         * Indicates whether or not the connection is locked.
         */
        locked: pulumi.Input<boolean>;
        /**
         * Describes why a connection is locked.
         */
        reason?: pulumi.Input<string>;
    }

    export interface ConnectionLogConfig {
        /**
         * Enabled represents whether logging is enabled or not for a connection.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface ConnectionNodeConfig {
        /**
         * Minimum number of nodes in the runtime nodes.
         */
        maxNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of nodes in the runtime nodes.
         */
        minNodeCount?: pulumi.Input<number>;
    }

    export interface ConnectionSslConfig {
        /**
         * Additional SSL related field values.
         * Structure is documented below.
         */
        additionalVariables?: pulumi.Input<pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigAdditionalVariable>[]>;
        /**
         * Type of Client Cert (PEM/JKS/.. etc.)
         * Possible values are: `PEM`.
         */
        clientCertType?: pulumi.Input<string>;
        /**
         * Client Certificate
         * Structure is documented below.
         */
        clientCertificate?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigClientCertificate>;
        /**
         * Client Private Key
         * Structure is documented below.
         */
        clientPrivateKey?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigClientPrivateKey>;
        /**
         * Secret containing the passphrase protecting the Client Private Key
         * Structure is documented below.
         */
        clientPrivateKeyPass?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigClientPrivateKeyPass>;
        /**
         * Private Server Certificate. Needs to be specified if trust model is PRIVATE.
         * Structure is documented below.
         */
        privateServerCertificate?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigPrivateServerCertificate>;
        /**
         * Type of Server Cert (PEM/JKS/.. etc.)
         * Possible values are: `PEM`.
         */
        serverCertType?: pulumi.Input<string>;
        /**
         * Enum for Trust Model
         * Possible values are: `PUBLIC`, `PRIVATE`, `INSECURE`.
         */
        trustModel?: pulumi.Input<string>;
        /**
         * Enum for controlling the SSL Type (TLS/MTLS)
         * Possible values are: `TLS`, `MTLS`.
         */
        type: pulumi.Input<string>;
        /**
         * Bool for enabling SSL
         */
        useSsl?: pulumi.Input<boolean>;
    }

    export interface ConnectionSslConfigAdditionalVariable {
        /**
         * Boolean Value of configVariable.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * Encryption key value of configVariable.
         * Structure is documented below.
         */
        encryptionKeyValue?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigAdditionalVariableEncryptionKeyValue>;
        /**
         * Integer Value of configVariable.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * Key for the configVariable
         */
        key: pulumi.Input<string>;
        /**
         * Secret value of configVariable
         * Structure is documented below.
         */
        secretValue?: pulumi.Input<inputs.integrationconnectors.ConnectionSslConfigAdditionalVariableSecretValue>;
        /**
         * String Value of configVariabley.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigAdditionalVariableEncryptionKeyValue {
        /**
         * The [KMS key name] with which the content of the Operation is encrypted. The
         * expected format: projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*.
         * Will be empty string if google managed.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Type of Encryption Key
         * Possible values are: `GOOGLE_MANAGED`, `CUSTOMER_MANAGED`.
         */
        type?: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigAdditionalVariableSecretValue {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigClientCertificate {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigClientPrivateKey {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigClientPrivateKeyPass {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionSslConfigPrivateServerCertificate {
        /**
         * Secret version of Secret Value for Config variable.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface ConnectionStatus {
        /**
         * An arbitrary description for the Connection.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the Eventing
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Current status of eventing.
         * Structure is documented below.
         */
        status?: pulumi.Input<string>;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface CryptoKeyKeyAccessJustificationsPolicy {
        /**
         * The list of allowed reasons for access to this CryptoKey. Zero allowed
         * access reasons means all encrypt, decrypt, and sign operations for
         * this CryptoKey will fail.
         */
        allowedAccessReasons?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CryptoKeyPrimary {
        /**
         * The resource name for the CryptoKey.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the CryptoKeyVersion.
         */
        state?: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionAttestation {
        /**
         * The certificate chains needed to validate the attestation
         * Structure is documented below.
         */
        certChains?: pulumi.Input<inputs.kms.CryptoKeyVersionAttestationCertChains>;
        /**
         * (Output)
         * The attestation data provided by the HSM when the key operation was performed.
         */
        content?: pulumi.Input<string>;
        /**
         * ExternalProtectionLevelOptions stores a group of additional fields for configuring a CryptoKeyVersion that are specific to the EXTERNAL protection level and EXTERNAL_VPC protection levels.
         * Structure is documented below.
         *
         * @deprecated `externalProtectionLevelOptions` is being un-nested from the `attestation` field. Please use the top level `externalProtectionLevelOptions` field instead.
         */
        externalProtectionLevelOptions?: pulumi.Input<inputs.kms.CryptoKeyVersionAttestationExternalProtectionLevelOptions>;
        /**
         * (Output)
         * The format of the attestation data.
         */
        format?: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionAttestationCertChains {
        /**
         * Cavium certificate chain corresponding to the attestation.
         */
        caviumCerts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Google card certificate chain corresponding to the attestation.
         */
        googleCardCerts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Google partition certificate chain corresponding to the attestation.
         */
        googlePartitionCerts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CryptoKeyVersionAttestationExternalProtectionLevelOptions {
        /**
         * The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
         */
        ekmConnectionKeyPath?: pulumi.Input<string>;
        /**
         * The URI for an external resource that this CryptoKeyVersion represents.
         */
        externalKeyUri?: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionExternalProtectionLevelOptions {
        /**
         * The path to the external key material on the EKM when using EkmConnection e.g., "v0/my/key". Set this field instead of externalKeyUri when using an EkmConnection.
         */
        ekmConnectionKeyPath?: pulumi.Input<string>;
        /**
         * The URI for an external resource that this CryptoKeyVersion represents.
         */
        externalKeyUri?: pulumi.Input<string>;
    }

    export interface CryptoKeyVersionTemplate {
        /**
         * The algorithm to use when creating a version based on this template.
         * See the [algorithm reference](https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm) for possible inputs.
         */
        algorithm: pulumi.Input<string>;
        /**
         * The protection level to use when creating a version based on this template. Possible values include "SOFTWARE", "HSM", "EXTERNAL", "EXTERNAL_VPC". Defaults to "SOFTWARE".
         */
        protectionLevel?: pulumi.Input<string>;
    }

    export interface EkmConnectionIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface EkmConnectionIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface EkmConnectionServiceResolver {
        /**
         * Optional. The filter applied to the endpoints of the resolved service. If no filter is specified, all endpoints will be considered. An endpoint will be chosen arbitrarily from the filtered list for each request. For endpoint filter syntax and examples, see https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest.
         */
        endpointFilter?: pulumi.Input<string>;
        /**
         * Required. The hostname of the EKM replica used at TLS and HTTP layers.
         */
        hostname: pulumi.Input<string>;
        /**
         * Required. A list of leaf server certificates used to authenticate HTTPS connections to the EKM replica. Currently, a maximum of 10 Certificate is supported.
         * Structure is documented below.
         */
        serverCertificates: pulumi.Input<pulumi.Input<inputs.kms.EkmConnectionServiceResolverServerCertificate>[]>;
        /**
         * Required. The resource name of the Service Directory service pointing to an EKM replica, in the format projects/*&#47;locations/*&#47;namespaces/*&#47;services/*
         */
        serviceDirectoryService: pulumi.Input<string>;
    }

    export interface EkmConnectionServiceResolverServerCertificate {
        /**
         * (Output)
         * Output only. The issuer distinguished name in RFC 2253 format. Only present if parsed is true.
         */
        issuer?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The certificate is not valid after this time. Only present if parsed is true.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        notAfterTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The certificate is not valid before this time. Only present if parsed is true.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        notBeforeTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. True if the certificate was parsed successfully.
         */
        parsed?: pulumi.Input<boolean>;
        /**
         * Required. The raw certificate bytes in DER format. A base64-encoded string.
         */
        rawDer: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The certificate serial number as a hex string. Only present if parsed is true.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The SHA-256 certificate fingerprint as a hex string. Only present if parsed is true.
         */
        sha256Fingerprint?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The subject distinguished name in RFC 2253 format. Only present if parsed is true.
         */
        subject?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The subject Alternative DNS names. Only present if parsed is true.
         *
         * - - -
         */
        subjectAlternativeDnsNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KeyRingIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface KeyRingIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** The provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface KeyRingImportJobAttestation {
        /**
         * (Output)
         * The attestation data provided by the HSM when the key operation was performed.
         * A base64-encoded string.
         */
        content?: pulumi.Input<string>;
        /**
         * (Output)
         * The format of the attestation data.
         */
        format?: pulumi.Input<string>;
    }

    export interface KeyRingImportJobPublicKey {
        /**
         * (Output)
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections
         * for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem?: pulumi.Input<string>;
    }
}

export namespace logging {
    export interface BillingAccountBucketConfigCmekSettings {
        /**
         * The resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
         * To enable CMEK for the bucket, set this field to a valid kmsKeyName for which the associated service account has the required cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
         * The Cloud KMS key used by the bucket can be updated by changing the kmsKeyName to a new valid key name. Encryption operations that are in progress will be completed with the key that was in use when they started. Decryption operations will be completed using the key that was used at the time of encryption unless access to that key has been revoked.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * The CryptoKeyVersion resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]"
         * For example:
         * "projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"
         * This is a read-only field used to convey the specific configured CryptoKeyVersion of kmsKey that has been configured. It will be populated in cases where the CMEK settings are bound to a single key version.
         */
        kmsKeyVersionName?: pulumi.Input<string>;
        /**
         * The resource name of the bucket. For example: "projects/my-project-id/locations/my-location/buckets/my-bucket-id"
         */
        name?: pulumi.Input<string>;
        /**
         * The service account associated with a project for which CMEK will apply.
         * Before enabling CMEK for a logging bucket, you must first assign the cloudkms.cryptoKeyEncrypterDecrypter role to the service account associated with the project for which CMEK will apply. Use [v2.getCmekSettings](https://cloud.google.com/logging/docs/reference/v2/rest/v2/TopLevel/getCmekSettings#google.logging.v2.ConfigServiceV2.GetCmekSettings) to obtain the service account ID.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        serviceAccountId?: pulumi.Input<string>;
    }

    export interface BillingAccountBucketConfigIndexConfig {
        /**
         * The LogEntry field path to index.
         * Note that some paths are automatically indexed, and other paths are not eligible for indexing. See [indexing documentation](https://cloud.google.com/logging/docs/analyze/custom-index) for details.
         */
        fieldPath: pulumi.Input<string>;
        /**
         * The type of data in this index. Allowed types include `INDEX_TYPE_UNSPECIFIED`, `INDEX_TYPE_STRING` and `INDEX_TYPE_INTEGER`.
         */
        type: pulumi.Input<string>;
    }

    export interface BillingAccountSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables, the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface BillingAccountSinkExclusion {
        /**
         * A description of this exclusion.
         */
        description?: pulumi.Input<string>;
        /**
         * If set to True, then this exclusion is disabled and it does not exclude any log entries.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See [Advanced Log Filters](https://cloud.google.com/logging/docs/view/advanced_filters) for information on how to
         * write a filter.
         */
        filter: pulumi.Input<string>;
        /**
         * A client-assigned identifier, such as `load-balancer-exclusion`. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
         */
        name: pulumi.Input<string>;
    }

    export interface FolderBucketConfigCmekSettings {
        /**
         * The resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
         * To enable CMEK for the bucket, set this field to a valid kmsKeyName for which the associated service account has the required cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
         * The Cloud KMS key used by the bucket can be updated by changing the kmsKeyName to a new valid key name. Encryption operations that are in progress will be completed with the key that was in use when they started. Decryption operations will be completed using the key that was used at the time of encryption unless access to that key has been revoked.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * The CryptoKeyVersion resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]"
         * For example:
         * "projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"
         * This is a read-only field used to convey the specific configured CryptoKeyVersion of kmsKey that has been configured. It will be populated in cases where the CMEK settings are bound to a single key version.
         */
        kmsKeyVersionName?: pulumi.Input<string>;
        /**
         * The resource name of the bucket. For example: "folders/my-folder-id/locations/my-location/buckets/my-bucket-id"
         */
        name?: pulumi.Input<string>;
        /**
         * The service account associated with a project for which CMEK will apply.
         * Before enabling CMEK for a logging bucket, you must first assign the cloudkms.cryptoKeyEncrypterDecrypter role to the service account associated with the project for which CMEK will apply. Use [v2.getCmekSettings](https://cloud.google.com/logging/docs/reference/v2/rest/v2/TopLevel/getCmekSettings#google.logging.v2.ConfigServiceV2.GetCmekSettings) to obtain the service account ID.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        serviceAccountId?: pulumi.Input<string>;
    }

    export interface FolderBucketConfigIndexConfig {
        /**
         * The LogEntry field path to index.
         * Note that some paths are automatically indexed, and other paths are not eligible for indexing. See [indexing documentation](https://cloud.google.com/logging/docs/analyze/custom-index) for details.
         */
        fieldPath: pulumi.Input<string>;
        /**
         * The type of data in this index. Allowed types include `INDEX_TYPE_UNSPECIFIED`, `INDEX_TYPE_STRING` and `INDEX_TYPE_INTEGER`.
         */
        type: pulumi.Input<string>;
    }

    export interface FolderSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables, the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface FolderSinkExclusion {
        /**
         * A description of this exclusion.
         */
        description?: pulumi.Input<string>;
        /**
         * If set to True, then this exclusion is disabled and it does not exclude any log entries.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See [Advanced Log Filters](https://cloud.google.com/logging/docs/view/advanced_filters) for information on how to
         * write a filter.
         */
        filter: pulumi.Input<string>;
        /**
         * A client-assigned identifier, such as `load-balancer-exclusion`. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
         */
        name: pulumi.Input<string>;
    }

    export interface LinkedDatasetBigqueryDataset {
        /**
         * (Output)
         * Output only. The full resource name of the BigQuery dataset. The DATASET_ID will match the ID
         * of the link, so the link must match the naming restrictions of BigQuery datasets
         * (alphanumeric characters and underscores only). The dataset will have a resource path of
         * "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET_ID]"
         */
        datasetId?: pulumi.Input<string>;
    }

    export interface LogViewIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface LogViewIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface MetricBucketOptions {
        /**
         * Specifies a set of buckets with arbitrary widths.
         * Structure is documented below.
         */
        explicitBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExplicitBuckets>;
        /**
         * Specifies an exponential sequence of buckets that have a width that is proportional to the value of
         * the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.
         * Structure is documented below.
         */
        exponentialBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExponentialBuckets>;
        /**
         * Specifies a linear sequence of buckets that all have the same width (except overflow and underflow).
         * Each bucket represents a constant absolute uncertainty on the specific value in the bucket.
         * Structure is documented below.
         */
        linearBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsLinearBuckets>;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        /**
         * The values must be monotonically increasing.
         */
        bounds: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface MetricBucketOptionsExponentialBuckets {
        /**
         * Must be greater than 1.
         */
        growthFactor: pulumi.Input<number>;
        /**
         * Must be greater than 0.
         */
        numFiniteBuckets: pulumi.Input<number>;
        /**
         * Must be greater than 0.
         */
        scale: pulumi.Input<number>;
    }

    export interface MetricBucketOptionsLinearBuckets {
        /**
         * Must be greater than 0.
         */
        numFiniteBuckets: pulumi.Input<number>;
        /**
         * Lower bound of the first bucket.
         */
        offset: pulumi.Input<number>;
        /**
         * Must be greater than 0.
         */
        width: pulumi.Input<number>;
    }

    export interface MetricMetricDescriptor {
        /**
         * A concise name for the metric, which can be displayed in user interfaces. Use sentence case
         * without an ending period, for example "Request count". This field is optional but it is
         * recommended to be set for any metrics associated with user-visible concepts, such as Quota.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The set of labels that can be used to describe a specific instance of this metric type. For
         * example, the appengine.googleapis.com/http/server/response_latencies metric type has a label
         * for the HTTP response code, response_code, so you can look at latencies for successful responses
         * or just for responses that failed.
         * Structure is documented below.
         */
        labels?: pulumi.Input<pulumi.Input<inputs.logging.MetricMetricDescriptorLabel>[]>;
        /**
         * Whether the metric records instantaneous values, changes to a value, etc.
         * Some combinations of metricKind and valueType might not be supported.
         * For counter metrics, set this to DELTA.
         * Possible values are: `DELTA`, `GAUGE`, `CUMULATIVE`.
         */
        metricKind: pulumi.Input<string>;
        /**
         * The unit in which the metric value is reported. It is only applicable if the valueType is
         * `INT64`, `DOUBLE`, or `DISTRIBUTION`. The supported units are a subset of
         * [The Unified Code for Units of Measure](http://unitsofmeasure.org/ucum.html) standard
         */
        unit?: pulumi.Input<string>;
        /**
         * Whether the measurement is an integer, a floating-point number, etc.
         * Some combinations of metricKind and valueType might not be supported.
         * For counter metrics, set this to INT64.
         * Possible values are: `BOOL`, `INT64`, `DOUBLE`, `STRING`, `DISTRIBUTION`, `MONEY`.
         */
        valueType: pulumi.Input<string>;
    }

    export interface MetricMetricDescriptorLabel {
        /**
         * A human-readable description for the label.
         */
        description?: pulumi.Input<string>;
        /**
         * The label key.
         */
        key: pulumi.Input<string>;
        /**
         * The type of data that can be assigned to the label.
         * Default value is `STRING`.
         * Possible values are: `BOOL`, `INT64`, `STRING`.
         */
        valueType?: pulumi.Input<string>;
    }

    export interface OrganizationBucketConfigCmekSettings {
        /**
         * The resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]"
         * To enable CMEK for the bucket, set this field to a valid kmsKeyName for which the associated service account has the required cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
         * The Cloud KMS key used by the bucket can be updated by changing the kmsKeyName to a new valid key name. Encryption operations that are in progress will be completed with the key that was in use when they started. Decryption operations will be completed using the key that was used at the time of encryption unless access to that key has been revoked.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * The CryptoKeyVersion resource name for the configured Cloud KMS key.
         * KMS key name format:
         * "projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]"
         * For example:
         * "projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"
         * This is a read-only field used to convey the specific configured CryptoKeyVersion of kmsKey that has been configured. It will be populated in cases where the CMEK settings are bound to a single key version.
         */
        kmsKeyVersionName?: pulumi.Input<string>;
        /**
         * The resource name of the bucket. For example: "organizations/my-organization-id/locations/my-location/buckets/my-bucket-id"
         */
        name?: pulumi.Input<string>;
        /**
         * The service account associated with a project for which CMEK will apply.
         * Before enabling CMEK for a logging bucket, you must first assign the cloudkms.cryptoKeyEncrypterDecrypter role to the service account associated with the project for which CMEK will apply. Use [v2.getCmekSettings](https://cloud.google.com/logging/docs/reference/v2/rest/v2/TopLevel/getCmekSettings#google.logging.v2.ConfigServiceV2.GetCmekSettings) to obtain the service account ID.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        serviceAccountId?: pulumi.Input<string>;
    }

    export interface OrganizationBucketConfigIndexConfig {
        /**
         * The LogEntry field path to index.
         * Note that some paths are automatically indexed, and other paths are not eligible for indexing. See [indexing documentation](https://cloud.google.com/logging/docs/analyze/custom-index) for details.
         */
        fieldPath: pulumi.Input<string>;
        /**
         * The type of data in this index. Allowed types include `INDEX_TYPE_UNSPECIFIED`, `INDEX_TYPE_STRING` and `INDEX_TYPE_INTEGER`.
         */
        type: pulumi.Input<string>;
    }

    export interface OrganizationSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface OrganizationSinkExclusion {
        /**
         * A description of this exclusion.
         */
        description?: pulumi.Input<string>;
        /**
         * If set to True, then this exclusion is disabled and it does not exclude any log entries.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See [Advanced Log Filters](https://cloud.google.com/logging/docs/view/advanced_filters) for information on how to
         * write a filter.
         */
        filter: pulumi.Input<string>;
        /**
         * A client-assigned identifier, such as `load-balancer-exclusion`. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
         */
        name: pulumi.Input<string>;
    }

    export interface ProjectBucketConfigCmekSettings {
        /**
         * The resource name for the configured Cloud KMS key.
         * KMS key name format:
         * `'projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]'`
         * To enable CMEK for the bucket, set this field to a valid kmsKeyName for which the associated service account has the required cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key.
         * The Cloud KMS key used by the bucket can be updated by changing the kmsKeyName to a new valid key name. Encryption operations that are in progress will be completed with the key that was in use when they started. Decryption operations will be completed using the key that was used at the time of encryption unless access to that key has been revoked.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        kmsKeyName: pulumi.Input<string>;
        /**
         * The CryptoKeyVersion resource name for the configured Cloud KMS key.
         * KMS key name format:
         * `'projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]/cryptoKeyVersions/[VERSION]'`
         * For example:
         * "projects/my-project/locations/us-central1/keyRings/my-ring/cryptoKeys/my-key/cryptoKeyVersions/1"
         * This is a read-only field used to convey the specific configured CryptoKeyVersion of kmsKey that has been configured. It will be populated in cases where the CMEK settings are bound to a single key version.
         */
        kmsKeyVersionName?: pulumi.Input<string>;
        /**
         * The resource name of the CMEK settings.
         */
        name?: pulumi.Input<string>;
        /**
         * The service account associated with a project for which CMEK will apply.
         * Before enabling CMEK for a logging bucket, you must first assign the cloudkms.cryptoKeyEncrypterDecrypter role to the service account associated with the project for which CMEK will apply. Use [v2.getCmekSettings](https://cloud.google.com/logging/docs/reference/v2/rest/v2/TopLevel/getCmekSettings#google.logging.v2.ConfigServiceV2.GetCmekSettings) to obtain the service account ID.
         * See [Enabling CMEK for Logging Buckets](https://cloud.google.com/logging/docs/routing/managed-encryption-storage) for more information.
         */
        serviceAccountId?: pulumi.Input<string>;
    }

    export interface ProjectBucketConfigIndexConfig {
        /**
         * The LogEntry field path to index.
         * Note that some paths are automatically indexed, and other paths are not eligible for indexing. See [indexing documentation](https://cloud.google.com/logging/docs/analyze/custom-index) for details.
         */
        fieldPath: pulumi.Input<string>;
        /**
         * The type of data in this index. Allowed types include `INDEX_TYPE_UNSPECIFIED`, `INDEX_TYPE_STRING` and `INDEX_TYPE_INTEGER`.
         */
        type: pulumi.Input<string>;
    }

    export interface ProjectSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. `syslog20170523`. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: pulumi.Input<boolean>;
    }

    export interface ProjectSinkExclusion {
        /**
         * A description of this exclusion.
         */
        description?: pulumi.Input<string>;
        /**
         * If set to True, then this exclusion is disabled and it does not exclude any log entries.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See [Advanced Log Filters](https://cloud.google.com/logging/docs/view/advanced_filters) for information on how to
         * write a filter.
         */
        filter: pulumi.Input<string>;
        /**
         * A client-assigned identifier, such as `load-balancer-exclusion`. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
         */
        name: pulumi.Input<string>;
    }
}

export namespace looker {
    export interface InstanceAdminSettings {
        allowedEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceCustomDomain {
        /**
         * Domain name
         */
        domain?: pulumi.Input<string>;
        /**
         * (Output)
         * Status of the custom domain.
         */
        state?: pulumi.Input<string>;
    }

    export interface InstanceDenyMaintenancePeriod {
        /**
         * Required. Start date of the deny maintenance period
         * Structure is documented below.
         */
        endDate: pulumi.Input<inputs.looker.InstanceDenyMaintenancePeriodEndDate>;
        /**
         * Required. Start date of the deny maintenance period
         * Structure is documented below.
         */
        startDate: pulumi.Input<inputs.looker.InstanceDenyMaintenancePeriodStartDate>;
        /**
         * Required. Start time of the window in UTC time.
         * Structure is documented below.
         */
        time: pulumi.Input<inputs.looker.InstanceDenyMaintenancePeriodTime>;
    }

    export interface InstanceDenyMaintenancePeriodEndDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
         * to specify a year by itself or a year and month where the day isn't significant.
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a
         * month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without
         * a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface InstanceDenyMaintenancePeriodStartDate {
        /**
         * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
         * to specify a year by itself or a year and month where the day isn't significant.
         */
        day?: pulumi.Input<number>;
        /**
         * Month of a year. Must be from 1 to 12, or 0 to specify a year without a
         * month and day.
         */
        month?: pulumi.Input<number>;
        /**
         * Year of the date. Must be from 1 to 9999, or 0 to specify a date without
         * a year.
         */
        year?: pulumi.Input<number>;
    }

    export interface InstanceDenyMaintenancePeriodTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface InstanceEncryptionConfig {
        /**
         * Name of the customer managed encryption key (CMEK) in KMS.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * (Output)
         * Full name and version of the CMEK key currently in use to encrypt Looker data.
         */
        kmsKeyNameVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Status of the customer managed encryption key (CMEK) in KMS.
         */
        kmsKeyState?: pulumi.Input<string>;
    }

    export interface InstanceMaintenanceWindow {
        /**
         * Required. Day of the week for this MaintenanceWindow (in UTC).
         * - MONDAY: Monday
         * - TUESDAY: Tuesday
         * - WEDNESDAY: Wednesday
         * - THURSDAY: Thursday
         * - FRIDAY: Friday
         * - SATURDAY: Saturday
         * - SUNDAY: Sunday
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeek: pulumi.Input<string>;
        /**
         * Required. Start time of the window in UTC time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.looker.InstanceMaintenanceWindowStartTime>;
    }

    export interface InstanceMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface InstanceOauthConfig {
        /**
         * The client ID for the Oauth config.
         */
        clientId: pulumi.Input<string>;
        /**
         * The client secret for the Oauth config.
         *
         * - - -
         */
        clientSecret: pulumi.Input<string>;
    }

    export interface InstancePscConfig {
        /**
         * List of VPCs that are allowed ingress into the Looker instance.
         */
        allowedVpcs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * URI of the Looker service attachment.
         */
        lookerServiceAttachmentUri?: pulumi.Input<string>;
        /**
         * List of egress service attachment configurations.
         * Structure is documented below.
         */
        serviceAttachments?: pulumi.Input<pulumi.Input<inputs.looker.InstancePscConfigServiceAttachment>[]>;
    }

    export interface InstancePscConfigServiceAttachment {
        /**
         * (Output)
         * Status of the service attachment connection.
         */
        connectionStatus?: pulumi.Input<string>;
        /**
         * Fully qualified domain name that will be used in the private DNS record created for the service attachment.
         */
        localFqdn?: pulumi.Input<string>;
        /**
         * URI of the service attachment to connect to.
         */
        targetServiceAttachmentUri?: pulumi.Input<string>;
    }

    export interface InstanceUserMetadata {
        /**
         * Number of additional Developer Users to allocate to the Looker Instance.
         */
        additionalDeveloperUserCount?: pulumi.Input<number>;
        /**
         * Number of additional Standard Users to allocate to the Looker Instance.
         */
        additionalStandardUserCount?: pulumi.Input<number>;
        /**
         * Number of additional Viewer Users to allocate to the Looker Instance.
         */
        additionalViewerUserCount?: pulumi.Input<number>;
    }
}

export namespace managedkafka {
    export interface ClusterCapacityConfig {
        /**
         * The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
         *
         * - - -
         */
        memoryBytes: pulumi.Input<string>;
        /**
         * The number of vCPUs to provision for the cluster. The minimum is 3.
         */
        vcpuCount: pulumi.Input<string>;
    }

    export interface ClusterGcpConfig {
        /**
         * The configuration of access to the Kafka cluster.
         * Structure is documented below.
         */
        accessConfig: pulumi.Input<inputs.managedkafka.ClusterGcpConfigAccessConfig>;
        /**
         * The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format `projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY`.
         */
        kmsKey?: pulumi.Input<string>;
    }

    export interface ClusterGcpConfigAccessConfig {
        /**
         * Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka cluster are allocated. To make the cluster available in a VPC, you must specify at least one `networkConfigs` block. Max of 10 subnets per cluster. Additional subnets may be specified with additional `networkConfigs` blocks.
         * Structure is documented below.
         */
        networkConfigs: pulumi.Input<pulumi.Input<inputs.managedkafka.ClusterGcpConfigAccessConfigNetworkConfig>[]>;
    }

    export interface ClusterGcpConfigAccessConfigNetworkConfig {
        /**
         * Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. There can only be one subnet per network, and the subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format `projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET`.
         */
        subnet: pulumi.Input<string>;
    }

    export interface ClusterRebalanceConfig {
        /**
         * The rebalance behavior for the cluster. When not specified, defaults to `NO_REBALANCE`. Possible values: `MODE_UNSPECIFIED`, `NO_REBALANCE`, `AUTO_REBALANCE_ON_SCALE_UP`.
         */
        mode?: pulumi.Input<string>;
    }

    export interface ConnectClusterCapacityConfig {
        /**
         * The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB).
         */
        memoryBytes: pulumi.Input<string>;
        /**
         * The number of vCPUs to provision for the cluster. The minimum is 3.
         */
        vcpuCount: pulumi.Input<string>;
    }

    export interface ConnectClusterGcpConfig {
        /**
         * The configuration of access to the Kafka Connect cluster.
         * Structure is documented below.
         */
        accessConfig: pulumi.Input<inputs.managedkafka.ConnectClusterGcpConfigAccessConfig>;
    }

    export interface ConnectClusterGcpConfigAccessConfig {
        /**
         * Virtual Private Cloud (VPC) subnets where IP addresses for the Kafka Connect cluster are allocated. To make the connect cluster available in a VPC, you must specify at least one subnet per network. You must specify between 1 and 10 subnets. Additional subnets may be specified with additional `networkConfigs` blocks.
         * Structure is documented below.
         */
        networkConfigs: pulumi.Input<pulumi.Input<inputs.managedkafka.ConnectClusterGcpConfigAccessConfigNetworkConfig>[]>;
    }

    export interface ConnectClusterGcpConfigAccessConfigNetworkConfig {
        /**
         * Additional subnets may be specified. They may be in another region, but must be in the same VPC network. The Connect workers can communicate with network endpoints in either the primary or additional subnets.
         */
        additionalSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Additional DNS domain names from the subnet's network to be made visible to the Connect Cluster. When using MirrorMaker2, it's necessary to add the bootstrap address's dns domain name of the target cluster to make it visible to the connector. For example: my-kafka-cluster.us-central1.managedkafka.my-project.cloud.goog
         *
         * - - -
         */
        dnsDomainNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * VPC subnet to make available to the Kafka Connect cluster. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}. It is used to create a Private Service Connect (PSC) interface for the Kafka Connect workers. It must be located in the same region as the Kafka Connect cluster. The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918. The primary subnet CIDR range must have a minimum size of /22 (1024 addresses).
         */
        primarySubnet: pulumi.Input<string>;
    }

    export interface ConnectorTaskRestartPolicy {
        /**
         * The maximum amount of time to wait before retrying a failed task. This sets an upper bound for the backoff delay.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maximumBackoff?: pulumi.Input<string>;
        /**
         * The minimum amount of time to wait before retrying a failed task. This sets a lower bound for the backoff delay.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minimumBackoff?: pulumi.Input<string>;
    }
}

export namespace memcache {
    export interface InstanceMaintenancePolicy {
        /**
         * (Output)
         * Output only. The time when the policy was created.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits
         */
        createTime?: pulumi.Input<string>;
        /**
         * Optional. Description of what this policy is for.
         * Create/Update methods return INVALID_ARGUMENT if the
         * length is greater than 512.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The time when the policy was updated.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * Required. Maintenance window that is applied to resources covered by this policy.
         * Minimum 1. For the current version, the maximum number of weeklyMaintenanceWindows
         * is expected to be one.
         * Structure is documented below.
         */
        weeklyMaintenanceWindows: pulumi.Input<pulumi.Input<inputs.memcache.InstanceMaintenancePolicyWeeklyMaintenanceWindow>[]>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindow {
        /**
         * Required. The day of week that maintenance updates occur.
         * - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
         * - MONDAY: Monday
         * - TUESDAY: Tuesday
         * - WEDNESDAY: Wednesday
         * - THURSDAY: Thursday
         * - FRIDAY: Friday
         * - SATURDAY: Saturday
         * - SUNDAY: Sunday
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * Required. The length of the maintenance window, ranging from 3 hours to 8 hours.
         * A duration in seconds with up to nine fractional digits,
         * terminated by 's'. Example: "3.5s".
         */
        duration: pulumi.Input<string>;
        /**
         * Required. Start time of the window in UTC time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.memcache.InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         * An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface InstanceMaintenanceSchedule {
        /**
         * (Output)
         * Output only. The end time of any upcoming scheduled maintenance for this instance.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The deadline that the maintenance schedule start time
         * can not go beyond, including reschedule.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        scheduleDeadlineTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The start time of any upcoming scheduled maintenance for this instance.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface InstanceMemcacheNode {
        /**
         * (Output)
         * Hostname or IP address of the Memcached node used by the clients to connect to the Memcached server on this node.
         */
        host?: pulumi.Input<string>;
        /**
         * (Output)
         * Identifier of the Memcached node. The node id does not include project or location like the Memcached instance name.
         */
        nodeId?: pulumi.Input<string>;
        /**
         * (Output)
         * The port number of the Memcached server on this node.
         */
        port?: pulumi.Input<number>;
        /**
         * (Output)
         * Current state of the Memcached node.
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * Location (GCP Zone) for the Memcached node.
         */
        zone?: pulumi.Input<string>;
    }

    export interface InstanceMemcacheParameters {
        /**
         * (Output)
         * This is a unique ID associated with this set of parameters.
         */
        id?: pulumi.Input<string>;
        /**
         * User-defined set of parameters to use in the memcache process.
         */
        params?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface InstanceNodeConfig {
        /**
         * Number of CPUs per node.
         */
        cpuCount: pulumi.Input<number>;
        /**
         * Memory size in Mebibytes for each memcache node.
         *
         * - - -
         */
        memorySizeMb: pulumi.Input<number>;
    }
}

export namespace memorystore {
    export interface InstanceAutomatedBackupConfig {
        /**
         * Trigger automated backups at a fixed frequency.
         * Structure is documented below.
         */
        fixedFrequencySchedule: pulumi.Input<inputs.memorystore.InstanceAutomatedBackupConfigFixedFrequencySchedule>;
        /**
         * How long to keep automated backups before the backups are deleted.
         * The value should be between 1 day and 365 days. If not specified, the default value is 35 days.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". The defaultValue is "3024000s"
         */
        retention: pulumi.Input<string>;
    }

    export interface InstanceAutomatedBackupConfigFixedFrequencySchedule {
        /**
         * The start time of every automated backup in UTC.
         * It must be set to the start of an hour. This field is required.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.memorystore.InstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime>;
    }

    export interface InstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours: pulumi.Input<number>;
    }

    export interface InstanceCrossInstanceReplicationConfig {
        /**
         * The instance role supports the following values:
         * 1. `INSTANCE_ROLE_UNSPECIFIED`: This is an independent instance that has never participated in cross instance replication. It allows both reads and writes.
         * 2. `NONE`: This is an independent instance that previously participated in cross instance replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
         * 3. `PRIMARY`: This instance serves as the replication source for secondary instance that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
         * 4. `SECONDARY`: This instance replicates data from the primary instance. It allows only reads.
         * Possible values are: `INSTANCE_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.
         */
        instanceRole?: pulumi.Input<string>;
        /**
         * (Output)
         * An output only view of all the member instance participating in cross instance replication. This field is populated for all the member clusters irrespective of their cluster role.
         * Structure is documented below.
         */
        memberships?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceCrossInstanceReplicationConfigMembership>[]>;
        /**
         * This field is only set for a secondary instance. Details of the primary instance that is used as the replication source for this secondary instance. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
         * Structure is documented below.
         */
        primaryInstance?: pulumi.Input<inputs.memorystore.InstanceCrossInstanceReplicationConfigPrimaryInstance>;
        /**
         * List of secondary instances that are replicating from this primary cluster. This is allowed to be set only for instances whose cluster role is of type `PRIMARY`.
         * Structure is documented below.
         */
        secondaryInstances?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceCrossInstanceReplicationConfigSecondaryInstance>[]>;
        /**
         * (Output)
         * The last time cross instance replication config was updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface InstanceCrossInstanceReplicationConfigMembership {
        /**
         * Details of the primary instance that is used as the replication source for all the secondary instances.
         */
        primaryInstances?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceCrossInstanceReplicationConfigMembershipPrimaryInstance>[]>;
        /**
         * List of secondary instances that are replicating from the primary instance.
         */
        secondaryInstances?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceCrossInstanceReplicationConfigMembershipSecondaryInstance>[]>;
    }

    export interface InstanceCrossInstanceReplicationConfigMembershipPrimaryInstance {
        /**
         * The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
         */
        instance?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the primary instance.
         */
        uid?: pulumi.Input<string>;
    }

    export interface InstanceCrossInstanceReplicationConfigMembershipSecondaryInstance {
        /**
         * The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
         */
        instance?: pulumi.Input<string>;
        /**
         * Output only. System assigned, unique identifier for the instance.
         */
        uid?: pulumi.Input<string>;
    }

    export interface InstanceCrossInstanceReplicationConfigPrimaryInstance {
        /**
         * The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
         */
        instance?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the primary instance.
         */
        uid?: pulumi.Input<string>;
    }

    export interface InstanceCrossInstanceReplicationConfigSecondaryInstance {
        /**
         * (Output)
         * The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
         */
        instance?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the secondary instance.
         */
        uid?: pulumi.Input<string>;
    }

    export interface InstanceDesiredPscAutoConnection {
        /**
         * (Output)
         * Output only. The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The consumer projectId where the forwarding rule is created from.
         */
        projectId: pulumi.Input<string>;
    }

    export interface InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpoint {
        /**
         * Structure is documented below.
         */
        connections?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnection>[]>;
    }

    export interface InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnection {
        /**
         * Detailed information of a PSC connection that is created by the customer
         * who owns the cluster.
         * Structure is documented below.
         */
        pscConnection?: pulumi.Input<inputs.memorystore.InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnection>;
    }

    export interface InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnection {
        /**
         * (Output)
         * Output Only. Type of a PSC Connection.
         * Possible values:
         * CONNECTION_TYPE_DISCOVERY
         * CONNECTION_TYPE_PRIMARY
         * CONNECTION_TYPE_READER
         */
        connectionType?: pulumi.Input<string>;
        /**
         * The URI of the consumer side forwarding rule.
         * Format:
         * projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
         */
        forwardingRule: pulumi.Input<string>;
        /**
         * The IP allocated on the consumer network for the PSC forwarding rule.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network: pulumi.Input<string>;
        /**
         * The consumer projectId where the forwarding rule is created from.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The PSC connection id of the forwarding rule connected to the
         * service attachment.
         */
        pscConnectionId: pulumi.Input<string>;
        /**
         * (Output)
         * Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
         * Possible values:
         * ACTIVE
         * NOT_FOUND
         */
        pscConnectionStatus?: pulumi.Input<string>;
        /**
         * The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
         */
        serviceAttachment: pulumi.Input<string>;
    }

    export interface InstanceDiscoveryEndpoint {
        /**
         * (Output)
         * Output only. IP address of the exposed endpoint clients connect to.
         */
        address?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Ports of the exposed endpoint.
         */
        port?: pulumi.Input<number>;
    }

    export interface InstanceEndpoint {
        /**
         * A group of PSC connections. They are created in the same VPC network, one for each service attachment in the cluster.
         * Structure is documented below.
         */
        connections?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceEndpointConnection>[]>;
    }

    export interface InstanceEndpointConnection {
        /**
         * Detailed information of a PSC connection that is created through service connectivity automation.
         * Structure is documented below.
         */
        pscAutoConnection?: pulumi.Input<inputs.memorystore.InstanceEndpointConnectionPscAutoConnection>;
    }

    export interface InstanceEndpointConnectionPscAutoConnection {
        /**
         * (Output)
         * Output Only. Type of a PSC Connection.
         * Possible values:
         * CONNECTION_TYPE_DISCOVERY
         * CONNECTION_TYPE_PRIMARY
         * CONNECTION_TYPE_READER
         */
        connectionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The URI of the consumer side forwarding rule.
         * Format:
         * projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
         */
        forwardingRule?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The IP allocated on the consumer network for the PSC forwarding rule.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Ports of the exposed endpoint.
         */
        port?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. The consumer projectId where the forwarding rule is created from.
         */
        projectId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The PSC connection id of the forwarding rule connected to the
         * service attachment.
         */
        pscConnectionId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface InstanceGcsSource {
        /**
         * URIs of the GCS objects to import.
         * Example: gs://bucket1/object1, gs//bucket2/folder2/object2
         */
        uris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceMaintenancePolicy {
        /**
         * (Output)
         * The time when the policy was created.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the policy was last updated.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * Optional. Maintenance window that is applied to resources covered by this policy.
         * Minimum 1. For the current version, the maximum number
         * of weeklyWindow is expected to be one.
         * Structure is documented below.
         */
        weeklyMaintenanceWindows?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceMaintenancePolicyWeeklyMaintenanceWindow>[]>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindow {
        /**
         * The day of week that maintenance updates occur.
         * - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
         * - MONDAY: Monday
         * - TUESDAY: Tuesday
         * - WEDNESDAY: Wednesday
         * - THURSDAY: Thursday
         * - FRIDAY: Friday
         * - SATURDAY: Saturday
         * - SUNDAY: Sunday
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * (Output)
         * Duration of the maintenance window.
         * The current window is fixed at 1 hour.
         * A duration in seconds with up to nine fractional digits,
         * terminated by 's'. Example: "3.5s".
         */
        duration?: pulumi.Input<string>;
        /**
         * Start time of the window in UTC time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.memorystore.InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         * An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface InstanceMaintenanceSchedule {
        /**
         * (Output)
         * The end time of any upcoming scheduled maintenance for this cluster.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The deadline that the maintenance schedule start time
         * can not go beyond, including reschedule.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        scheduleDeadlineTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The start time of any upcoming scheduled maintenance for this cluster.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface InstanceManagedBackupSource {
        /**
         * Example: //memorystore.googleapis.com/projects/{project}/locations/{location}/backups/{backupId}. In this case, it assumes the backup is under memorystore.googleapis.com.
         */
        backup: pulumi.Input<string>;
    }

    export interface InstanceNodeConfig {
        /**
         * (Output)
         * Output only. Memory size in GB of the node.
         */
        sizeGb?: pulumi.Input<number>;
    }

    export interface InstancePersistenceConfig {
        /**
         * Configuration for AOF based persistence.
         * Structure is documented below.
         */
        aofConfig?: pulumi.Input<inputs.memorystore.InstancePersistenceConfigAofConfig>;
        /**
         * Optional. Current persistence mode.
         * Possible values:
         * DISABLED
         * RDB
         * AOF
         * Possible values are: `DISABLED`, `RDB`, `AOF`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Configuration for RDB based persistence.
         * Structure is documented below.
         */
        rdbConfig?: pulumi.Input<inputs.memorystore.InstancePersistenceConfigRdbConfig>;
    }

    export interface InstancePersistenceConfigAofConfig {
        /**
         * Optional. The fsync mode.
         * Possible values:
         * NEVER
         * EVERY_SEC
         * ALWAYS
         */
        appendFsync?: pulumi.Input<string>;
    }

    export interface InstancePersistenceConfigRdbConfig {
        /**
         * Optional. Period between RDB snapshots.
         * Possible values:
         * ONE_HOUR
         * SIX_HOURS
         * TWELVE_HOURS
         * TWENTY_FOUR_HOURS
         */
        rdbSnapshotPeriod?: pulumi.Input<string>;
        /**
         * Optional. Time that the first snapshot was/will be attempted, and to which future
         * snapshots will be aligned. If not provided, the current time will be
         * used.
         */
        rdbSnapshotStartTime?: pulumi.Input<string>;
    }

    export interface InstancePscAttachmentDetail {
        /**
         * (Output)
         * Output Only. Type of a PSC Connection.
         * Possible values:
         * CONNECTION_TYPE_DISCOVERY
         * CONNECTION_TYPE_PRIMARY
         * CONNECTION_TYPE_READER
         */
        connectionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface InstancePscAutoConnection {
        /**
         * (Output)
         * Output Only. Type of a PSC Connection.
         * Possible values:
         * CONNECTION_TYPE_DISCOVERY
         * CONNECTION_TYPE_PRIMARY
         * CONNECTION_TYPE_READER
         */
        connectionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The URI of the consumer side forwarding rule.
         * Format:
         * projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
         */
        forwardingRule?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The IP allocated on the consumer network for the PSC forwarding rule.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Ports of the exposed endpoint.
         */
        port?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. The consumer projectId where the forwarding rule is created from.
         */
        projectId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The PSC connection id of the forwarding rule connected to the
         * service attachment.
         */
        pscConnectionId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
         * Possible values:
         * ACTIVE
         * NOT_FOUND
         */
        pscConnectionStatus?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface InstanceStateInfo {
        /**
         * (Output)
         * Represents information about instance with state UPDATING.
         * Structure is documented below.
         */
        updateInfos?: pulumi.Input<pulumi.Input<inputs.memorystore.InstanceStateInfoUpdateInfo>[]>;
    }

    export interface InstanceStateInfoUpdateInfo {
        /**
         * (Output)
         * Output only. Target engine version for the instance.
         */
        targetEngineVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Target node type for the instance.
         */
        targetNodeType?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Target number of replica nodes per shard for the instance.
         */
        targetReplicaCount?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Target number of shards for the instance.
         */
        targetShardCount?: pulumi.Input<number>;
    }

    export interface InstanceZoneDistributionConfig {
        /**
         * Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
         * Possible values:
         * MULTI_ZONE
         * SINGLE_ZONE
         * Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
         * Ignored for MULTI_ZONE mode.
         */
        zone?: pulumi.Input<string>;
    }
}

export namespace migrationcenter {
    export interface PreferenceSetVirtualMachinePreferences {
        /**
         * Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `COMMITMENT_PLAN_NONE`, `COMMITMENT_PLAN_ONE_YEAR`, `COMMITMENT_PLAN_THREE_YEARS`
         */
        commitmentPlan?: pulumi.Input<string>;
        /**
         * The user preferences relating to Compute Engine target platform.
         * Structure is documented below.
         */
        computeEnginePreferences?: pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferences>;
        /**
         * The user preferences relating to target regions.
         * Structure is documented below.
         */
        regionPreferences?: pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesRegionPreferences>;
        /**
         * Sizing optimization strategy specifies the preferred strategy used when extrapolating usage data to calculate insights and recommendations for a virtual machine. If you are unsure which value to set, a moderate sizing optimization strategy is often a good value to start with. Possible values: `SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED`, `SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE`, `SIZING_OPTIMIZATION_STRATEGY_MODERATE`, `SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE`
         */
        sizingOptimizationStrategy?: pulumi.Input<string>;
        /**
         * Preferences concerning Sole Tenancy nodes and VMs.
         * Structure is documented below.
         */
        soleTenancyPreferences?: pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferences>;
        /**
         * Target product for assets using this preference set. Specify either target product or business goal, but not both. Possible values: `COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED`, `COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE`, `COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE`, `COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY`
         */
        targetProduct?: pulumi.Input<string>;
        /**
         * The user preferences relating to Google Cloud VMware Engine target platform.
         * Structure is documented below.
         */
        vmwareEnginePreferences?: pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferences>;
    }

    export interface PreferenceSetVirtualMachinePreferencesComputeEnginePreferences {
        /**
         * License type to consider when calculating costs for virtual machine insights and recommendations. If unspecified, costs are calculated based on the default licensing plan. Possible values: `LICENSE_TYPE_UNSPECIFIED`, `LICENSE_TYPE_DEFAULT`, `LICENSE_TYPE_BRING_YOUR_OWN_LICENSE`
         */
        licenseType?: pulumi.Input<string>;
        /**
         * The type of machines to consider when calculating virtual machine migration insights and recommendations. Not all machine types are available in all zones and regions.
         * Structure is documented below.
         */
        machinePreferences?: pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences>;
    }

    export interface PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences {
        /**
         * Compute Engine machine series to consider for insights and recommendations. If empty, no restriction is applied on the machine series.
         * Structure is documented below.
         */
        allowedMachineSeries?: pulumi.Input<pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries>[]>;
    }

    export interface PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries {
        /**
         * Code to identify a Compute Engine machine series. Consult https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison for more details on the available series.
         */
        code?: pulumi.Input<string>;
    }

    export interface PreferenceSetVirtualMachinePreferencesRegionPreferences {
        /**
         * A list of preferred regions, ordered by the most preferred region first. Set only valid Google Cloud region names. See https://cloud.google.com/compute/docs/regions-zones for available regions.
         */
        preferredRegions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PreferenceSetVirtualMachinePreferencesSoleTenancyPreferences {
        /**
         * Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR`, `COMMITMENT_3_YEAR`
         */
        commitmentPlan?: pulumi.Input<string>;
        /**
         * CPU overcommit ratio. Acceptable values are between 1.0 and 2.0 inclusive.
         */
        cpuOvercommitRatio?: pulumi.Input<number>;
        /**
         * Sole Tenancy nodes maintenance policy. Possible values: `HOST_MAINTENANCE_POLICY_UNSPECIFIED`, `HOST_MAINTENANCE_POLICY_DEFAULT`, `HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE`, `HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP`
         */
        hostMaintenancePolicy?: pulumi.Input<string>;
        /**
         * A list of sole tenant node types. An empty list means that all possible node types will be considered.
         * Structure is documented below.
         */
        nodeTypes?: pulumi.Input<pulumi.Input<inputs.migrationcenter.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeType>[]>;
    }

    export interface PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeType {
        /**
         * Name of the Sole Tenant node. Consult https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes
         */
        nodeName?: pulumi.Input<string>;
    }

    export interface PreferenceSetVirtualMachinePreferencesVmwareEnginePreferences {
        /**
         * Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
         */
        commitmentPlan?: pulumi.Input<string>;
        /**
         * CPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
         */
        cpuOvercommitRatio?: pulumi.Input<number>;
        /**
         * Memory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
         */
        memoryOvercommitRatio?: pulumi.Input<number>;
        /**
         * The Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
         */
        storageDeduplicationCompressionRatio?: pulumi.Input<number>;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        /**
         * The name specified for the version when it was created.
         */
        name: pulumi.Input<string>;
    }
}

export namespace monitoring {
    export interface AlertPolicyAlertStrategy {
        /**
         * If an alert policy that was active has no data for this long, any open incidents will close.
         */
        autoClose?: pulumi.Input<string>;
        /**
         * Control over how the notification channels in `notificationChannels`
         * are notified when this alert fires, on a per-channel basis.
         * Structure is documented below.
         */
        notificationChannelStrategies?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyAlertStrategyNotificationChannelStrategy>[]>;
        /**
         * Control when notifications will be sent out.
         * Each value may be one of: `NOTIFICATION_PROMPT_UNSPECIFIED`, `OPENED`, `CLOSED`.
         */
        notificationPrompts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required for alert policies with a LogMatch condition.
         * This limit is not implemented for alert policies that are not log-based.
         * Structure is documented below.
         */
        notificationRateLimit?: pulumi.Input<inputs.monitoring.AlertPolicyAlertStrategyNotificationRateLimit>;
    }

    export interface AlertPolicyAlertStrategyNotificationChannelStrategy {
        /**
         * The notification channels that these settings apply to. Each of these
         * correspond to the name field in one of the NotificationChannel objects
         * referenced in the notificationChannels field of this AlertPolicy. The format is
         * `projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]`
         */
        notificationChannelNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The frequency at which to send reminder notifications for open incidents.
         */
        renotifyInterval?: pulumi.Input<string>;
    }

    export interface AlertPolicyAlertStrategyNotificationRateLimit {
        /**
         * Not more than one notification per period.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
         */
        period?: pulumi.Input<string>;
    }

    export interface AlertPolicyCondition {
        /**
         * A condition that checks that a time series
         * continues to receive new data points.
         * Structure is documented below.
         */
        conditionAbsent?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsent>;
        /**
         * A condition that checks for log messages matching given constraints.
         * If set, no other conditions can be present.
         * Structure is documented below.
         */
        conditionMatchedLog?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionMatchedLog>;
        /**
         * A Monitoring Query Language query that outputs a boolean stream
         * Structure is documented below.
         */
        conditionMonitoringQueryLanguage?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionMonitoringQueryLanguage>;
        /**
         * A condition type that allows alert policies to be defined using
         * Prometheus Query Language (PromQL).
         * The PrometheusQueryLanguageCondition message contains information
         * from a Prometheus alerting rule and its associated rule group.
         * Structure is documented below.
         */
        conditionPrometheusQueryLanguage?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionPrometheusQueryLanguage>;
        /**
         * A condition that allows alerting policies to be defined using GoogleSQL.
         * SQL conditions examine a sliding window of logs using GoogleSQL.
         * Alert policies with SQL conditions may incur additional billing.
         * Structure is documented below.
         */
        conditionSql?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSql>;
        /**
         * A condition that compares a time series against a
         * threshold.
         * Structure is documented below.
         */
        conditionThreshold?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThreshold>;
        /**
         * A short name or phrase used to identify the
         * condition in dashboards, notifications, and
         * incidents. To avoid confusion, don't use the same
         * display name for multiple conditions in the same
         * policy.
         */
        displayName: pulumi.Input<string>;
        /**
         * (Output)
         * The unique resource name for this condition.
         * Its syntax is:
         * projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
         * [CONDITION_ID] is assigned by Stackdriver Monitoring when
         * the condition is created as part of a new or updated alerting
         * policy.
         */
        name?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsent {
        /**
         * Specifies the alignment of data points in
         * individual time series as well as how to
         * combine the retrieved time series together
         * (such as when aggregating multiple streams
         * on each resource to a single stream for each
         * resource or when aggregating streams across
         * all members of a group of resources).
         * Multiple aggregations are applied in the
         * order specified.
         * Structure is documented below.
         */
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentAggregation>[]>;
        /**
         * The amount of time that a time series must
         * fail to report new data to be considered
         * failing. Currently, only values that are a
         * multiple of a minute--e.g. 60s, 120s, or 300s
         * --are supported.
         */
        duration: pulumi.Input<string>;
        /**
         * A filter that identifies which time series
         * should be compared with the threshold.The
         * filter is similar to the one that is
         * specified in the
         * MetricService.ListTimeSeries request (that
         * call is useful to verify the time series
         * that will be retrieved / processed) and must
         * specify the metric type and optionally may
         * contain restrictions on resource type,
         * resource labels, and metric labels. This
         * field may not exceed 2048 Unicode characters
         * in length.
         */
        filter?: pulumi.Input<string>;
        /**
         * The number/percent of time series for which
         * the comparison must hold in order for the
         * condition to trigger. If unspecified, then
         * the condition will trigger if the comparison
         * is true for any of the time series that have
         * been identified by filter and aggregations.
         * Structure is documented below.
         */
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentTrigger>;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        /**
         * The alignment period for per-time
         * series alignment. If present,
         * alignmentPeriod must be at least
         * 60 seconds. After per-time series
         * alignment, each time series will
         * contain data points only on the
         * period boundaries. If
         * perSeriesAligner is not specified
         * or equals ALIGN_NONE, then this
         * field is ignored. If
         * perSeriesAligner is specified and
         * does not equal ALIGN_NONE, then
         * this field must be defined;
         * otherwise an error is returned.
         */
        alignmentPeriod?: pulumi.Input<string>;
        /**
         * The approach to be used to combine
         * time series. Not all reducer
         * functions may be applied to all
         * time series, depending on the
         * metric type and the value type of
         * the original time series.
         * Reduction may change the metric
         * type of value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
         */
        crossSeriesReducer?: pulumi.Input<string>;
        /**
         * The set of fields to preserve when
         * crossSeriesReducer is specified.
         * The groupByFields determine how
         * the time series are partitioned
         * into subsets prior to applying the
         * aggregation function. Each subset
         * contains time series that have the
         * same value for each of the
         * grouping fields. Each individual
         * time series is a member of exactly
         * one subset. The crossSeriesReducer
         * is applied to each subset of time
         * series. It is not possible to
         * reduce across different resource
         * types, so this field implicitly
         * contains resource.type. Fields not
         * specified in groupByFields are
         * aggregated away. If groupByFields
         * is not specified and all the time
         * series have the same resource
         * type, then the time series are
         * aggregated into a single output
         * time series. If crossSeriesReducer
         * is not defined, this field is
         * ignored.
         */
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The approach to be used to align
         * individual time series. Not all
         * alignment functions may be applied
         * to all time series, depending on
         * the metric type and value type of
         * the original time series.
         * Alignment may change the metric
         * type or the value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
         */
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        /**
         * The absolute number of time series
         * that must fail the predicate for the
         * condition to be triggered.
         */
        count?: pulumi.Input<number>;
        /**
         * The percentage of time series that
         * must fail the predicate for the
         * condition to be triggered.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionMatchedLog {
        /**
         * A logs-based filter.
         */
        filter: pulumi.Input<string>;
        /**
         * A map from a label key to an extractor expression, which is used to
         * extract the value for this label key. Each entry in this map is
         * a specification for how data should be extracted from log entries that
         * match filter. Each combination of extracted values is treated as
         * a separate rule for the purposes of triggering notifications.
         * Label keys and corresponding values can be used in notifications
         * generated by this condition.
         */
        labelExtractors?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface AlertPolicyConditionConditionMonitoringQueryLanguage {
        /**
         * The amount of time that a time series must
         * violate the threshold to be considered
         * failing. Currently, only values that are a
         * multiple of a minute--e.g., 0, 60, 120, or
         * 300 seconds--are supported. If an invalid
         * value is given, an error will be returned.
         * When choosing a duration, it is useful to
         * keep in mind the frequency of the underlying
         * time series data (which may also be affected
         * by any alignments specified in the
         * aggregations field); a good duration is long
         * enough so that a single outlier does not
         * generate spurious alerts, but short enough
         * that unhealthy states are detected and
         * alerted on quickly.
         */
        duration: pulumi.Input<string>;
        /**
         * A condition control that determines how
         * metric-threshold conditions are evaluated when
         * data stops arriving.
         * Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
         */
        evaluationMissingData?: pulumi.Input<string>;
        /**
         * Monitoring Query Language query that outputs a boolean stream.
         */
        query: pulumi.Input<string>;
        /**
         * The number/percent of time series for which
         * the comparison must hold in order for the
         * condition to trigger. If unspecified, then
         * the condition will trigger if the comparison
         * is true for any of the time series that have
         * been identified by filter and aggregations,
         * or by the ratio, if denominatorFilter and
         * denominatorAggregations are specified.
         * Structure is documented below.
         */
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionMonitoringQueryLanguageTrigger>;
    }

    export interface AlertPolicyConditionConditionMonitoringQueryLanguageTrigger {
        /**
         * The absolute number of time series
         * that must fail the predicate for the
         * condition to be triggered.
         */
        count?: pulumi.Input<number>;
        /**
         * The percentage of time series that
         * must fail the predicate for the
         * condition to be triggered.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionPrometheusQueryLanguage {
        /**
         * The alerting rule name of this alert in the corresponding Prometheus
         * configuration file.
         * Some external tools may require this field to be populated correctly
         * in order to refer to the original Prometheus configuration file.
         * The rule group name and the alert name are necessary to update the
         * relevant AlertPolicies in case the definition of the rule group changes
         * in the future.
         * This field is optional. If this field is not empty, then it must be a
         * valid Prometheus label name.
         */
        alertRule?: pulumi.Input<string>;
        disableMetricValidation?: pulumi.Input<boolean>;
        /**
         * Alerts are considered firing once their PromQL expression evaluated
         * to be "true" for this long. Alerts whose PromQL expression was not
         * evaluated to be "true" for long enough are considered pending. The
         * default value is zero. Must be zero or positive.
         */
        duration?: pulumi.Input<string>;
        /**
         * How often this rule should be evaluated. Must be a positive multiple
         * of 30 seconds or missing. The default value is 30 seconds. If this
         * PrometheusQueryLanguageCondition was generated from a Prometheus
         * alerting rule, then this value should be taken from the enclosing
         * rule group.
         */
        evaluationInterval?: pulumi.Input<string>;
        /**
         * Labels to add to or overwrite in the PromQL query result. Label names
         * must be valid.
         * Label values can be templatized by using variables. The only available
         * variable names are the names of the labels in the PromQL result,
         * although label names beginning with \_\_ (two "\_") are reserved for
         * internal use. "labels" may be empty. This field is intended to be used
         * for organizing and identifying the AlertPolicy.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The PromQL expression to evaluate. Every evaluation cycle this
         * expression is evaluated at the current time, and all resultant time
         * series become pending/firing alerts. This field must not be empty.
         */
        query: pulumi.Input<string>;
        /**
         * The rule group name of this alert in the corresponding Prometheus
         * configuration file.
         * Some external tools may require this field to be populated correctly
         * in order to refer to the original Prometheus configuration file.
         * The rule group name and the alert name are necessary to update the
         * relevant AlertPolicies in case the definition of the rule group changes
         * in the future. This field is optional.
         */
        ruleGroup?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionSql {
        /**
         * A test that uses an alerting result in a boolean column produced by the SQL query.
         * Structure is documented below.
         */
        booleanTest?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlBooleanTest>;
        /**
         * Used to schedule the query to run every so many days.
         * Structure is documented below.
         */
        daily?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlDaily>;
        /**
         * Used to schedule the query to run every so many hours.
         * Structure is documented below.
         */
        hourly?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlHourly>;
        /**
         * Used to schedule the query to run every so many minutes.
         * Structure is documented below.
         */
        minutes?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlMinutes>;
        /**
         * The Log Analytics SQL query to run, as a string.  The query must
         * conform to the required shape. Specifically, the query must not try to
         * filter the input by time.  A filter will automatically be applied
         * to filter the input so that the query receives all rows received
         * since the last time the query was run.
         */
        query: pulumi.Input<string>;
        /**
         * A test that checks if the number of rows in the result set violates some threshold.
         * Structure is documented below.
         */
        rowCountTest?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlRowCountTest>;
    }

    export interface AlertPolicyConditionConditionSqlBooleanTest {
        /**
         * The name of the column containing the boolean value. If the value in a row is
         * NULL, that row is ignored.
         *
         * - - -
         */
        column: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionSqlDaily {
        /**
         * The time of day (in UTC) at which the query should run. If left
         * unspecified, the server picks an arbitrary time of day and runs
         * the query at the same time each day.
         * Structure is documented below.
         */
        executionTime?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionSqlDailyExecutionTime>;
        /**
         * The number of days between runs. Must be greater than or equal
         * to 1 day and less than or equal to 30 days.
         */
        periodicity: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionSqlDailyExecutionTime {
        /**
         * Hours of a day in 24 hour format. Must be greater than or equal
         * to 0 and typically must be less than or equal to 23. An API may
         * choose to allow the value "24:00:00" for scenarios like business
         * closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of an hour. Must be greater than or equal to 0 and
         * less than or equal to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds, in nanoseconds. Must be greater than or
         * equal to 0 and less than or equal to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of a minute. Must be greater than or equal to 0 and
         * typically must be less than or equal to 59. An API may allow the
         * value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionSqlHourly {
        /**
         * The number of minutes after the hour (in UTC) to run the query.
         * Must be greater than or equal to 0 minutes and less than or equal to
         * 59 minutes.  If left unspecified, then an arbitrary offset is used.
         */
        minuteOffset?: pulumi.Input<number>;
        /**
         * Number of hours between runs. The interval must be greater than or
         * equal to 1 hour and less than or equal to 48 hours.
         */
        periodicity: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionSqlMinutes {
        /**
         * Number of minutes between runs. The interval must be greater than or
         * equal to 5 minutes and less than or equal to 1440 minutes.
         */
        periodicity: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionSqlRowCountTest {
        /**
         * The comparison to apply between the time
         * series (indicated by filter and aggregation)
         * and the threshold (indicated by
         * threshold_value). The comparison is applied
         * on each time series, with the time series on
         * the left-hand side and the threshold on the
         * right-hand side. Only COMPARISON_LT and
         * COMPARISON_GT are supported currently.
         * Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
         */
        comparison: pulumi.Input<string>;
        /**
         * The value against which to compare the row count.
         */
        threshold: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionThreshold {
        /**
         * Specifies the alignment of data points in
         * individual time series as well as how to
         * combine the retrieved time series together
         * (such as when aggregating multiple streams
         * on each resource to a single stream for each
         * resource or when aggregating streams across
         * all members of a group of resources).
         * Multiple aggregations are applied in the
         * order specified.This field is similar to the
         * one in the MetricService.ListTimeSeries
         * request. It is advisable to use the
         * ListTimeSeries method when debugging this
         * field.
         * Structure is documented below.
         */
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdAggregation>[]>;
        /**
         * The comparison to apply between the time
         * series (indicated by filter and aggregation)
         * and the threshold (indicated by
         * threshold_value). The comparison is applied
         * on each time series, with the time series on
         * the left-hand side and the threshold on the
         * right-hand side. Only COMPARISON_LT and
         * COMPARISON_GT are supported currently.
         * Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
         */
        comparison: pulumi.Input<string>;
        /**
         * Specifies the alignment of data points in
         * individual time series selected by
         * denominatorFilter as well as how to combine
         * the retrieved time series together (such as
         * when aggregating multiple streams on each
         * resource to a single stream for each
         * resource or when aggregating streams across
         * all members of a group of resources).When
         * computing ratios, the aggregations and
         * denominatorAggregations fields must use the
         * same alignment period and produce time
         * series that have the same periodicity and
         * labels.This field is similar to the one in
         * the MetricService.ListTimeSeries request. It
         * is advisable to use the ListTimeSeries
         * method when debugging this field.
         * Structure is documented below.
         */
        denominatorAggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation>[]>;
        /**
         * A filter that identifies a time series that
         * should be used as the denominator of a ratio
         * that will be compared with the threshold. If
         * a denominatorFilter is specified, the time
         * series specified by the filter field will be
         * used as the numerator.The filter is similar
         * to the one that is specified in the
         * MetricService.ListTimeSeries request (that
         * call is useful to verify the time series
         * that will be retrieved / processed) and must
         * specify the metric type and optionally may
         * contain restrictions on resource type,
         * resource labels, and metric labels. This
         * field may not exceed 2048 Unicode characters
         * in length.
         */
        denominatorFilter?: pulumi.Input<string>;
        /**
         * The amount of time that a time series must
         * violate the threshold to be considered
         * failing. Currently, only values that are a
         * multiple of a minute--e.g., 0, 60, 120, or
         * 300 seconds--are supported. If an invalid
         * value is given, an error will be returned.
         * When choosing a duration, it is useful to
         * keep in mind the frequency of the underlying
         * time series data (which may also be affected
         * by any alignments specified in the
         * aggregations field); a good duration is long
         * enough so that a single outlier does not
         * generate spurious alerts, but short enough
         * that unhealthy states are detected and
         * alerted on quickly.
         */
        duration: pulumi.Input<string>;
        /**
         * A condition control that determines how
         * metric-threshold conditions are evaluated when
         * data stops arriving.
         * Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
         */
        evaluationMissingData?: pulumi.Input<string>;
        /**
         * A filter that identifies which time series
         * should be compared with the threshold.The
         * filter is similar to the one that is
         * specified in the
         * MetricService.ListTimeSeries request (that
         * call is useful to verify the time series
         * that will be retrieved / processed) and must
         * specify the metric type and optionally may
         * contain restrictions on resource type,
         * resource labels, and metric labels. This
         * field may not exceed 2048 Unicode characters
         * in length.
         */
        filter?: pulumi.Input<string>;
        /**
         * When this field is present, the `MetricThreshold`
         * condition forecasts whether the time series is
         * predicted to violate the threshold within the
         * `forecastHorizon`. When this field is not set, the
         * `MetricThreshold` tests the current value of the
         * timeseries against the threshold.
         * Structure is documented below.
         */
        forecastOptions?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdForecastOptions>;
        /**
         * A value against which to compare the time
         * series.
         */
        thresholdValue?: pulumi.Input<number>;
        /**
         * The number/percent of time series for which
         * the comparison must hold in order for the
         * condition to trigger. If unspecified, then
         * the condition will trigger if the comparison
         * is true for any of the time series that have
         * been identified by filter and aggregations,
         * or by the ratio, if denominatorFilter and
         * denominatorAggregations are specified.
         * Structure is documented below.
         */
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdTrigger>;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        /**
         * The alignment period for per-time
         * series alignment. If present,
         * alignmentPeriod must be at least
         * 60 seconds. After per-time series
         * alignment, each time series will
         * contain data points only on the
         * period boundaries. If
         * perSeriesAligner is not specified
         * or equals ALIGN_NONE, then this
         * field is ignored. If
         * perSeriesAligner is specified and
         * does not equal ALIGN_NONE, then
         * this field must be defined;
         * otherwise an error is returned.
         */
        alignmentPeriod?: pulumi.Input<string>;
        /**
         * The approach to be used to combine
         * time series. Not all reducer
         * functions may be applied to all
         * time series, depending on the
         * metric type and the value type of
         * the original time series.
         * Reduction may change the metric
         * type of value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
         */
        crossSeriesReducer?: pulumi.Input<string>;
        /**
         * The set of fields to preserve when
         * crossSeriesReducer is specified.
         * The groupByFields determine how
         * the time series are partitioned
         * into subsets prior to applying the
         * aggregation function. Each subset
         * contains time series that have the
         * same value for each of the
         * grouping fields. Each individual
         * time series is a member of exactly
         * one subset. The crossSeriesReducer
         * is applied to each subset of time
         * series. It is not possible to
         * reduce across different resource
         * types, so this field implicitly
         * contains resource.type. Fields not
         * specified in groupByFields are
         * aggregated away. If groupByFields
         * is not specified and all the time
         * series have the same resource
         * type, then the time series are
         * aggregated into a single output
         * time series. If crossSeriesReducer
         * is not defined, this field is
         * ignored.
         */
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The approach to be used to align
         * individual time series. Not all
         * alignment functions may be applied
         * to all time series, depending on
         * the metric type and value type of
         * the original time series.
         * Alignment may change the metric
         * type or the value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
         */
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        /**
         * The alignment period for per-time
         * series alignment. If present,
         * alignmentPeriod must be at least
         * 60 seconds. After per-time series
         * alignment, each time series will
         * contain data points only on the
         * period boundaries. If
         * perSeriesAligner is not specified
         * or equals ALIGN_NONE, then this
         * field is ignored. If
         * perSeriesAligner is specified and
         * does not equal ALIGN_NONE, then
         * this field must be defined;
         * otherwise an error is returned.
         */
        alignmentPeriod?: pulumi.Input<string>;
        /**
         * The approach to be used to combine
         * time series. Not all reducer
         * functions may be applied to all
         * time series, depending on the
         * metric type and the value type of
         * the original time series.
         * Reduction may change the metric
         * type of value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
         */
        crossSeriesReducer?: pulumi.Input<string>;
        /**
         * The set of fields to preserve when
         * crossSeriesReducer is specified.
         * The groupByFields determine how
         * the time series are partitioned
         * into subsets prior to applying the
         * aggregation function. Each subset
         * contains time series that have the
         * same value for each of the
         * grouping fields. Each individual
         * time series is a member of exactly
         * one subset. The crossSeriesReducer
         * is applied to each subset of time
         * series. It is not possible to
         * reduce across different resource
         * types, so this field implicitly
         * contains resource.type. Fields not
         * specified in groupByFields are
         * aggregated away. If groupByFields
         * is not specified and all the time
         * series have the same resource
         * type, then the time series are
         * aggregated into a single output
         * time series. If crossSeriesReducer
         * is not defined, this field is
         * ignored.
         */
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The approach to be used to align
         * individual time series. Not all
         * alignment functions may be applied
         * to all time series, depending on
         * the metric type and value type of
         * the original time series.
         * Alignment may change the metric
         * type or the value type of the time
         * series.Time series data must be
         * aligned in order to perform cross-
         * time series reduction. If
         * crossSeriesReducer is specified,
         * then perSeriesAligner must be
         * specified and not equal ALIGN_NONE
         * and alignmentPeriod must be
         * specified; otherwise, an error is
         * returned.
         * Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
         */
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdForecastOptions {
        /**
         * The length of time into the future to forecast
         * whether a timeseries will violate the threshold.
         * If the predicted value is found to violate the
         * threshold, and the violation is observed in all
         * forecasts made for the Configured `duration`,
         * then the timeseries is considered to be failing.
         */
        forecastHorizon: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        /**
         * The absolute number of time series
         * that must fail the predicate for the
         * condition to be triggered.
         */
        count?: pulumi.Input<number>;
        /**
         * The percentage of time series that
         * must fail the predicate for the
         * condition to be triggered.
         */
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyCreationRecord {
        /**
         * (Output)
         * When the change occurred.
         */
        mutateTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The email address of the user making the change.
         */
        mutatedBy?: pulumi.Input<string>;
    }

    export interface AlertPolicyDocumentation {
        /**
         * The text of the documentation, interpreted according to mimeType.
         * The content may not exceed 8,192 Unicode characters and may not
         * exceed more than 10,240 bytes when encoded in UTF-8 format,
         * whichever is smaller.
         */
        content?: pulumi.Input<string>;
        /**
         * Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
         * Structure is documented below.
         */
        links?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyDocumentationLink>[]>;
        /**
         * The format of the content field. Presently, only the value
         * "text/markdown" is supported.
         */
        mimeType?: pulumi.Input<string>;
        /**
         * The subject line of the notification. The subject line may not
         * exceed 10,240 bytes. In notifications generated by this policy the contents
         * of the subject line after variable expansion will be truncated to 255 bytes
         * or shorter at the latest UTF-8 character boundary.
         */
        subject?: pulumi.Input<string>;
    }

    export interface AlertPolicyDocumentationLink {
        /**
         * A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
         */
        displayName?: pulumi.Input<string>;
        /**
         * The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
         */
        url?: pulumi.Input<string>;
    }

    export interface CustomServiceTelemetry {
        /**
         * The full name of the resource that defines this service.
         * Formatted as described in
         * https://cloud.google.com/apis/design/resource_names.
         */
        resourceName?: pulumi.Input<string>;
    }

    export interface GenericServiceBasicService {
        /**
         * Labels that specify the resource that emits the monitoring data
         * which is used for SLO reporting of this `Service`.
         */
        serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The type of service that this basic service defines, e.g.
         * APP_ENGINE service type
         */
        serviceType?: pulumi.Input<string>;
    }

    export interface GenericServiceTelemetry {
        /**
         * The full name of the resource that defines this service.
         * Formatted as described in
         * https://cloud.google.com/apis/design/resource_names.
         */
        resourceName?: pulumi.Input<string>;
    }

    export interface MetricDescriptorLabel {
        /**
         * A human-readable description for the label.
         */
        description?: pulumi.Input<string>;
        /**
         * The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
         */
        key: pulumi.Input<string>;
        /**
         * The type of data that can be assigned to the label.
         * Default value is `STRING`.
         * Possible values are: `STRING`, `BOOL`, `INT64`.
         */
        valueType?: pulumi.Input<string>;
    }

    export interface MetricDescriptorMetadata {
        /**
         * The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
         */
        ingestDelay?: pulumi.Input<string>;
        /**
         * The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
         */
        samplePeriod?: pulumi.Input<string>;
    }

    export interface NotificationChannelSensitiveLabels {
        /**
         * An authorization token for a notification channel. Channel types that support this field include: slack
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        authToken?: pulumi.Input<string>;
        /**
         * An password for a notification channel. Channel types that support this field include: webhookBasicauth
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        password?: pulumi.Input<string>;
        /**
         * An servicekey token for a notification channel. Channel types that support this field include: pagerduty
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        serviceKey?: pulumi.Input<string>;
    }

    export interface SloBasicSli {
        /**
         * Availability based SLI, dervied from count of requests made to this service that return successfully.
         * Structure is documented below.
         */
        availability?: pulumi.Input<inputs.monitoring.SloBasicSliAvailability>;
        /**
         * Parameters for a latency threshold SLI.
         * Structure is documented below.
         */
        latency?: pulumi.Input<inputs.monitoring.SloBasicSliLatency>;
        /**
         * An optional set of locations to which this SLI is relevant.
         * Telemetry from other locations will not be used to calculate
         * performance for this SLI. If omitted, this SLI applies to all
         * locations in which the Service has activity. For service types
         * that don't support breaking down by location, setting this
         * field will result in an error.
         */
        locations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An optional set of RPCs to which this SLI is relevant.
         * Telemetry from other methods will not be used to calculate
         * performance for this SLI. If omitted, this SLI applies to all
         * the Service's methods. For service types that don't support
         * breaking down by method, setting this field will result in an
         * error.
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The set of API versions to which this SLI is relevant.
         * Telemetry from other API versions will not be used to
         * calculate performance for this SLI. If omitted,
         * this SLI applies to all API versions. For service types
         * that don't support breaking down by version, setting this
         * field will result in an error.
         */
        versions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SloBasicSliAvailability {
        /**
         * Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SloBasicSliLatency {
        /**
         * A duration string, e.g. 10s.
         * Good service is defined to be the count of requests made to
         * this service that return in no more than threshold.
         */
        threshold: pulumi.Input<string>;
    }

    export interface SloRequestBasedSli {
        /**
         * Used when goodService is defined by a count of values aggregated in a
         * Distribution that fall into a good range. The totalService is the
         * total count of all values aggregated in the Distribution.
         * Defines a distribution TimeSeries filter and thresholds used for
         * measuring good service and total service.
         * Exactly one of `distributionCut` or `goodTotalRatio` can be set.
         * Structure is documented below.
         */
        distributionCut?: pulumi.Input<inputs.monitoring.SloRequestBasedSliDistributionCut>;
        /**
         * A means to compute a ratio of `goodService` to `totalService`.
         * Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
         * Must specify exactly two of good, bad, and total service filters.
         * The relationship goodService + badService = totalService
         * will be assumed.
         * Exactly one of `distributionCut` or `goodTotalRatio` can be set.
         * Structure is documented below.
         */
        goodTotalRatio?: pulumi.Input<inputs.monitoring.SloRequestBasedSliGoodTotalRatio>;
    }

    export interface SloRequestBasedSliDistributionCut {
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * aggregating values to quantify the good service provided.
         * Must have ValueType = DISTRIBUTION and
         * MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        distributionFilter: pulumi.Input<string>;
        /**
         * Range of numerical values. The computed goodService
         * will be the count of values x in the Distribution such
         * that range.min <= x <= range.max. inclusive of min and
         * max. Open ranges can be defined by setting
         * just one of min or max.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.monitoring.SloRequestBasedSliDistributionCutRange>;
    }

    export interface SloRequestBasedSliDistributionCutRange {
        /**
         * max value for the range (inclusive). If not given,
         * will be set to "infinity", defining an open range
         * ">= range.min"
         */
        max?: pulumi.Input<number>;
        /**
         * Min value for the range (inclusive). If not given,
         * will be set to "-infinity", defining an open range
         * "< range.max"
         */
        min?: pulumi.Input<number>;
    }

    export interface SloRequestBasedSliGoodTotalRatio {
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying bad service provided, either demanded service that
         * was not provided or demanded service that was of inadequate
         * quality. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        badServiceFilter?: pulumi.Input<string>;
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying good service provided. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        goodServiceFilter?: pulumi.Input<string>;
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying total demanded service. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        totalServiceFilter?: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSli {
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * with ValueType = BOOL. The window is good if any true values
         * appear in the window. One of `goodBadMetricFilter`,
         * `goodTotalRatioThreshold`, `metricMeanInRange`,
         * `metricSumInRange` must be set for `windowsBasedSli`.
         */
        goodBadMetricFilter?: pulumi.Input<string>;
        /**
         * Criterion that describes a window as good if its performance is
         * high enough. One of `goodBadMetricFilter`,
         * `goodTotalRatioThreshold`, `metricMeanInRange`,
         * `metricSumInRange` must be set for `windowsBasedSli`.
         * Structure is documented below.
         */
        goodTotalRatioThreshold?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThreshold>;
        /**
         * Criterion that describes a window as good if the metric's value
         * is in a good range, *averaged* across returned streams.
         * One of `goodBadMetricFilter`,
         * `goodTotalRatioThreshold`, `metricMeanInRange`,
         * `metricSumInRange` must be set for `windowsBasedSli`.
         * Average value X of `timeSeries` should satisfy
         * `range.min <= X <= range.max` for a good window.
         * Structure is documented below.
         */
        metricMeanInRange?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliMetricMeanInRange>;
        /**
         * Criterion that describes a window as good if the metric's value
         * is in a good range, *summed* across returned streams.
         * Summed value `X` of `timeSeries` should satisfy
         * `range.min <= X <= range.max` for a good window.
         * One of `goodBadMetricFilter`,
         * `goodTotalRatioThreshold`, `metricMeanInRange`,
         * `metricSumInRange` must be set for `windowsBasedSli`.
         * Structure is documented below.
         */
        metricSumInRange?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliMetricSumInRange>;
        /**
         * Duration over which window quality is evaluated, given as a
         * duration string "{X}s" representing X seconds. Must be an
         * integer fraction of a day and at least 60s.
         */
        windowPeriod?: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThreshold {
        /**
         * Basic SLI to evaluate to judge window quality.
         * Structure is documented below.
         */
        basicSliPerformance?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance>;
        /**
         * Request-based SLI to evaluate to judge window quality.
         * Structure is documented below.
         */
        performance?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformance>;
        /**
         * If window performance >= threshold, the window is counted
         * as good.
         */
        threshold?: pulumi.Input<number>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance {
        /**
         * Availability based SLI, dervied from count of requests made to this service that return successfully.
         * Structure is documented below.
         */
        availability?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability>;
        /**
         * Parameters for a latency threshold SLI.
         * Structure is documented below.
         */
        latency?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency>;
        /**
         * An optional set of locations to which this SLI is relevant.
         * Telemetry from other locations will not be used to calculate
         * performance for this SLI. If omitted, this SLI applies to all
         * locations in which the Service has activity. For service types
         * that don't support breaking down by location, setting this
         * field will result in an error.
         */
        locations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An optional set of RPCs to which this SLI is relevant.
         * Telemetry from other methods will not be used to calculate
         * performance for this SLI. If omitted, this SLI applies to all
         * the Service's methods. For service types that don't support
         * breaking down by method, setting this field will result in an
         * error.
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The set of API versions to which this SLI is relevant.
         * Telemetry from other API versions will not be used to
         * calculate performance for this SLI. If omitted,
         * this SLI applies to all API versions. For service types
         * that don't support breaking down by version, setting this
         * field will result in an error.
         */
        versions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability {
        /**
         * Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency {
        /**
         * A duration string, e.g. 10s.
         * Good service is defined to be the count of requests made to
         * this service that return in no more than threshold.
         */
        threshold: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdPerformance {
        /**
         * Used when goodService is defined by a count of values aggregated in a
         * Distribution that fall into a good range. The totalService is the
         * total count of all values aggregated in the Distribution.
         * Defines a distribution TimeSeries filter and thresholds used for
         * measuring good service and total service.
         * Structure is documented below.
         */
        distributionCut?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut>;
        /**
         * A means to compute a ratio of `goodService` to `totalService`.
         * Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
         * Must specify exactly two of good, bad, and total service filters.
         * The relationship goodService + badService = totalService
         * will be assumed.
         * Structure is documented below.
         */
        goodTotalRatio?: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut {
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * aggregating values to quantify the good service provided.
         * Must have ValueType = DISTRIBUTION and
         * MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        distributionFilter: pulumi.Input<string>;
        /**
         * Range of numerical values. The computed goodService
         * will be the count of values x in the Distribution such
         * that range.min <= x <= range.max. inclusive of min and
         * max. Open ranges can be defined by setting
         * just one of min or max.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange {
        /**
         * max value for the range (inclusive). If not given,
         * will be set to "infinity", defining an open range
         * ">= range.min"
         */
        max?: pulumi.Input<number>;
        /**
         * Min value for the range (inclusive). If not given,
         * will be set to "-infinity", defining an open range
         * "< range.max"
         */
        min?: pulumi.Input<number>;
    }

    export interface SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio {
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying bad service provided, either demanded service that
         * was not provided or demanded service that was of inadequate
         * quality. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        badServiceFilter?: pulumi.Input<string>;
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying good service provided. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        goodServiceFilter?: pulumi.Input<string>;
        /**
         * A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * quantifying total demanded service. Exactly two of
         * good, bad, or total service filter must be defined (where
         * good + bad = total is assumed)
         * Must have ValueType = DOUBLE or ValueType = INT64 and
         * must have MetricKind = DELTA or MetricKind = CUMULATIVE.
         */
        totalServiceFilter?: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSliMetricMeanInRange {
        /**
         * Range of numerical values. The computed goodService
         * will be the count of values x in the Distribution such
         * that range.min <= x <= range.max. inclusive of min and
         * max. Open ranges can be defined by setting
         * just one of min or max. Mean value `X` of `timeSeries`
         * values should satisfy `range.min <= X <= range.max` for a
         * good service.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.monitoring.SloWindowsBasedSliMetricMeanInRangeRange>;
        /**
         * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * specifying the TimeSeries to use for evaluating window
         * The provided TimeSeries must have ValueType = INT64 or
         * ValueType = DOUBLE and MetricKind = GAUGE. Mean value `X`
         * should satisfy `range.min <= X <= range.max`
         * under good service.
         */
        timeSeries: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSliMetricMeanInRangeRange {
        /**
         * max value for the range (inclusive). If not given,
         * will be set to "infinity", defining an open range
         * ">= range.min"
         */
        max?: pulumi.Input<number>;
        /**
         * Min value for the range (inclusive). If not given,
         * will be set to "-infinity", defining an open range
         * "< range.max"
         */
        min?: pulumi.Input<number>;
    }

    export interface SloWindowsBasedSliMetricSumInRange {
        /**
         * Range of numerical values. The computed goodService
         * will be the count of values x in the Distribution such
         * that range.min <= x <= range.max. inclusive of min and
         * max. Open ranges can be defined by setting
         * just one of min or max. Summed value `X` should satisfy
         * `range.min <= X <= range.max` for a good window.
         * Structure is documented below.
         */
        range: pulumi.Input<inputs.monitoring.SloWindowsBasedSliMetricSumInRangeRange>;
        /**
         * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
         * specifying the TimeSeries to use for evaluating window
         * quality. The provided TimeSeries must have
         * ValueType = INT64 or ValueType = DOUBLE and
         * MetricKind = GAUGE.
         * Summed value `X` should satisfy
         * `range.min <= X <= range.max` for a good window.
         */
        timeSeries: pulumi.Input<string>;
    }

    export interface SloWindowsBasedSliMetricSumInRangeRange {
        /**
         * max value for the range (inclusive). If not given,
         * will be set to "infinity", defining an open range
         * ">= range.min"
         */
        max?: pulumi.Input<number>;
        /**
         * Min value for the range (inclusive). If not given,
         * will be set to "-infinity", defining an open range
         * "< range.max"
         */
        min?: pulumi.Input<number>;
    }

    export interface UptimeCheckConfigContentMatcher {
        /**
         * String or regex content to match (max 1024 bytes)
         */
        content: pulumi.Input<string>;
        /**
         * Information needed to perform a JSONPath content match. Used for `ContentMatcherOption::MATCHES_JSON_PATH` and `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
         * Structure is documented below.
         */
        jsonPathMatcher?: pulumi.Input<inputs.monitoring.UptimeCheckConfigContentMatcherJsonPathMatcher>;
        /**
         * The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
         * Default value is `CONTAINS_STRING`.
         * Possible values are: `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, `NOT_MATCHES_REGEX`, `MATCHES_JSON_PATH`, `NOT_MATCHES_JSON_PATH`.
         */
        matcher?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigContentMatcherJsonPathMatcher {
        /**
         * Options to perform JSONPath content matching.
         * Default value is `EXACT_MATCH`.
         * Possible values are: `EXACT_MATCH`, `REGEX_MATCH`.
         */
        jsonMatcher?: pulumi.Input<string>;
        /**
         * JSONPath within the response output pointing to the expected `ContentMatcher::content` to match against.
         */
        jsonPath: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigHttpCheck {
        /**
         * If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
         * Structure is documented below.
         */
        acceptedResponseStatusCodes?: pulumi.Input<pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckAcceptedResponseStatusCode>[]>;
        /**
         * The authentication information using username and password. Optional when creating an HTTP check; defaults to empty. Do not use with other authentication fields.
         * Structure is documented below.
         */
        authInfo?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo>;
        /**
         * The request body associated with the HTTP POST request. If `contentType` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `requestMethod` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. `foo=bar` in URL-encoded form is `foo%3Dbar` and in base64 encoding is `Zm9vJTI1M0RiYXI=`.
         */
        body?: pulumi.Input<string>;
        /**
         * The content type to use for the check.
         * Possible values are: `TYPE_UNSPECIFIED`, `URL_ENCODED`, `USER_PROVIDED`.
         */
        contentType?: pulumi.Input<string>;
        /**
         * A user provided content type header to use for the check. The invalid configurations outlined in the `contentType` field apply to customContentType`, as well as the following 1. `contentType` is `URL_ENCODED` and `customContentType` is set. 2. `contentType` is `USER_PROVIDED` and `customContentType` is not set.
         */
        customContentType?: pulumi.Input<string>;
        /**
         * The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described in [RFC 2616 (page 31)](https://www.w3.org/Protocols/rfc2616/rfc2616.txt). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
         */
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `maskHeaders` is set to `true` then the headers will be obscured with `******`.
         */
        maskHeaders?: pulumi.Input<boolean>;
        /**
         * The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with `/`, a `/` will be prepended automatically. Optional (defaults to `/`).
         */
        path?: pulumi.Input<string>;
        /**
         * Contains information needed to add pings to an HTTP check.
         * Structure is documented below.
         */
        pingConfig?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckPingConfig>;
        /**
         * The port to the page to run the check against. Will be combined with `host` (specified within the `monitoredResource`) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
         */
        port?: pulumi.Input<number>;
        /**
         * The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `requestMethod` defaults to `GET`.
         * Default value is `GET`.
         * Possible values are: `METHOD_UNSPECIFIED`, `GET`, `POST`.
         */
        requestMethod?: pulumi.Input<string>;
        /**
         * The authentication information using the Monitoring Service Agent. Optional when creating an HTTPS check; defaults to empty. Do not use with other authentication fields.
         * Structure is documented below.
         */
        serviceAgentAuthentication?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckServiceAgentAuthentication>;
        /**
         * If true, use HTTPS instead of HTTP to run the check.
         */
        useSsl?: pulumi.Input<boolean>;
        /**
         * Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitoredResource` is set to `uptimeUrl`. If `useSsl` is `false`, setting `validateSsl` to `true` has no effect.
         */
        validateSsl?: pulumi.Input<boolean>;
    }

    export interface UptimeCheckConfigHttpCheckAcceptedResponseStatusCode {
        /**
         * A class of status codes to accept.
         * Possible values are: `STATUS_CLASS_1XX`, `STATUS_CLASS_2XX`, `STATUS_CLASS_3XX`, `STATUS_CLASS_4XX`, `STATUS_CLASS_5XX`, `STATUS_CLASS_ANY`.
         */
        statusClass?: pulumi.Input<string>;
        /**
         * A status code to accept.
         */
        statusValue?: pulumi.Input<number>;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        /**
         * The password to authenticate.
         */
        password?: pulumi.Input<string>;
        /**
         * The password write-only version.
         */
        passwordWoVersion?: pulumi.Input<string>;
        /**
         * The username to authenticate.
         */
        username: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigHttpCheckPingConfig {
        /**
         * Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
         */
        pingsCount: pulumi.Input<number>;
    }

    export interface UptimeCheckConfigHttpCheckServiceAgentAuthentication {
        /**
         * The type of authentication to use.
         * Possible values are: `SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED`, `OIDC_TOKEN`.
         */
        type?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigMonitoredResource {
        /**
         * Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels `projectId`, `instanceId`, and `zone`.
         */
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The monitored resource type. This field must match the type field of a [`MonitoredResourceDescriptor`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is `gceInstance`. For a list of types, see [Monitoring resource types](https://cloud.google.com/monitoring/api/resources) and [Logging resource types](https://cloud.google.com/logging/docs/api/v2/resource-list).
         */
        type: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigResourceGroup {
        /**
         * The group of resources being monitored. Should be the `name` of a group
         */
        groupId?: pulumi.Input<string>;
        /**
         * The resource type of the group members.
         * Possible values are: `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, `AWS_ELB_LOAD_BALANCER`.
         */
        resourceType?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigSyntheticMonitor {
        /**
         * Target a Synthetic Monitor GCFv2 Instance
         * Structure is documented below.
         *
         *
         * <a name="nestedSyntheticMonitorCloudFunctionV2"></a>The `cloudFunctionV2` block supports:
         */
        cloudFunctionV2: pulumi.Input<inputs.monitoring.UptimeCheckConfigSyntheticMonitorCloudFunctionV2>;
    }

    export interface UptimeCheckConfigSyntheticMonitorCloudFunctionV2 {
        /**
         * A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
         */
        name: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigTcpCheck {
        /**
         * Contains information needed to add pings to a TCP check.
         * Structure is documented below.
         */
        pingConfig?: pulumi.Input<inputs.monitoring.UptimeCheckConfigTcpCheckPingConfig>;
        /**
         * The port to the page to run the check against. Will be combined with host (specified within the `monitoredResource`) to construct the full URL.
         */
        port: pulumi.Input<number>;
    }

    export interface UptimeCheckConfigTcpCheckPingConfig {
        /**
         * Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
         */
        pingsCount: pulumi.Input<number>;
    }
}

export namespace netapp {
    export interface VolumeBackupConfig {
        /**
         * Specify a single backup policy ID for scheduled backups. Format: `projects/{{projectId}}/locations/{{location}}/backupPolicies/{{backupPolicyName}}`
         */
        backupPolicies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * ID of the backup vault to use. A backup vault is reqired to create manual or scheduled backups.
         * Format: `projects/{{projectId}}/locations/{{location}}/backupVaults/{{backupVaultName}}`
         */
        backupVault?: pulumi.Input<string>;
        /**
         * When set to true, scheduled backup is enabled on the volume. Omit if no backupPolicy is specified.
         */
        scheduledBackupEnabled?: pulumi.Input<boolean>;
    }

    export interface VolumeExportPolicy {
        /**
         * Export rules (up to 5) control NFS volume access.
         * Structure is documented below.
         */
        rules: pulumi.Input<pulumi.Input<inputs.netapp.VolumeExportPolicyRule>[]>;
    }

    export interface VolumeExportPolicyRule {
        /**
         * Defines the access type for clients matching the `allowedClients` specification.
         * Possible values are: `READ_ONLY`, `READ_WRITE`, `READ_NONE`.
         */
        accessType?: pulumi.Input<string>;
        /**
         * Defines the client ingress specification (allowed clients) as a comma separated list with IPv4 CIDRs or IPv4 host addresses.
         */
        allowedClients?: pulumi.Input<string>;
        /**
         * If enabled, the root user (UID = 0) of the specified clients doesn't get mapped to nobody (UID = 65534). This is also known as no_root_squash.
         */
        hasRootAccess?: pulumi.Input<string>;
        /**
         * If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode.
         */
        kerberos5ReadOnly?: pulumi.Input<boolean>;
        /**
         * If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode. The 'kerberos5ReadOnly' value is ignored if this is enabled.
         */
        kerberos5ReadWrite?: pulumi.Input<boolean>;
        /**
         * If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode.
         */
        kerberos5iReadOnly?: pulumi.Input<boolean>;
        /**
         * If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly' value is ignored if this is enabled.
         */
        kerberos5iReadWrite?: pulumi.Input<boolean>;
        /**
         * If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode.
         */
        kerberos5pReadOnly?: pulumi.Input<boolean>;
        /**
         * If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly' value is ignored if this is enabled.
         */
        kerberos5pReadWrite?: pulumi.Input<boolean>;
        /**
         * Enable to apply the export rule to NFSV3 clients.
         */
        nfsv3?: pulumi.Input<boolean>;
        /**
         * Enable to apply the export rule to NFSV4.1 clients.
         */
        nfsv4?: pulumi.Input<boolean>;
    }

    export interface VolumeMountOption {
        /**
         * (Output)
         * Export path of the volume.
         */
        export?: pulumi.Input<string>;
        /**
         * (Output)
         * Full export path of the volume.
         * Format for NFS volumes: `<export_ip>:/<shareName>`
         * Format for SMB volumes: `\\\\netbios_prefix-four_random_hex_letters.domain_name\\shareName`
         */
        exportFull?: pulumi.Input<string>;
        /**
         * (Output)
         * Human-readable mount instructions.
         */
        instructions?: pulumi.Input<string>;
        /**
         * (Output)
         * Protocol to mount with.
         */
        protocol?: pulumi.Input<string>;
    }

    export interface VolumeReplicationDestinationVolumeParameters {
        /**
         * Description for the destination volume.
         */
        description?: pulumi.Input<string>;
        /**
         * Share name for destination volume. If not specified, name of source volume's share name will be used.
         */
        shareName?: pulumi.Input<string>;
        /**
         * Name of an existing storage pool for the destination volume with format: `projects/{{project}}/locations/{{location}}/storagePools/{{poolId}}`
         */
        storagePool: pulumi.Input<string>;
        /**
         * Tiering policy for the volume.
         * Structure is documented below.
         */
        tieringPolicy?: pulumi.Input<inputs.netapp.VolumeReplicationDestinationVolumeParametersTieringPolicy>;
        /**
         * Name for the destination volume to be created. If not specified, the name of the source volume will be used.
         */
        volumeId?: pulumi.Input<string>;
    }

    export interface VolumeReplicationDestinationVolumeParametersTieringPolicy {
        /**
         * Optional. Time in days to mark the volume's data block as cold and make it eligible for tiering, can be range from 2-183.
         * Default is 31.
         */
        coolingThresholdDays?: pulumi.Input<number>;
        /**
         * Optional. Flag indicating if the volume has tiering policy enable/pause. Default is PAUSED.
         * Default value is `PAUSED`.
         * Possible values are: `ENABLED`, `PAUSED`.
         */
        tierAction?: pulumi.Input<string>;
    }

    export interface VolumeReplicationTransferStat {
        /**
         * (Output)
         * The elapsed time since the creation of the snapshot on the source volume that was last replicated
         * to the destination volume. Lag time represents the difference in age of the destination volume
         * data in relation to the source volume data.
         */
        lagDuration?: pulumi.Input<string>;
        /**
         * (Output)
         * Size of last completed transfer in bytes.
         */
        lastTransferBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Time taken during last completed transfer.
         */
        lastTransferDuration?: pulumi.Input<string>;
        /**
         * (Output)
         * Time when last transfer completed. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
         */
        lastTransferEndTime?: pulumi.Input<string>;
        /**
         * (Output)
         * A message describing the cause of the last transfer failure.
         */
        lastTransferError?: pulumi.Input<string>;
        /**
         * (Output)
         * Cumulative time taken across all transfers for the replication relationship.
         */
        totalTransferDuration?: pulumi.Input<string>;
        /**
         * (Output)
         * Cumulative bytes transferred so far for the replication relationship.
         */
        transferBytes?: pulumi.Input<string>;
        /**
         * (Output)
         * Time when progress was updated last. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface VolumeRestoreParameters {
        /**
         * Full name of the backup to use for creating this volume.
         * `sourceSnapshot` and `sourceBackup` cannot be used simultaneously.
         * Format: `projects/{{project}}/locations/{{location}}/backupVaults/{{backupVaultId}}/backups/{{backup}}`.
         */
        sourceBackup?: pulumi.Input<string>;
        /**
         * Full name of the snapshot to use for creating this volume.
         * `sourceSnapshot` and `sourceBackup` cannot be used simultaneously.
         * Format: `projects/{{project}}/locations/{{location}}/volumes/{{volume}}/snapshots/{{snapshot}}`.
         */
        sourceSnapshot?: pulumi.Input<string>;
    }

    export interface VolumeSnapshotPolicy {
        /**
         * Daily schedule policy.
         * Structure is documented below.
         */
        dailySchedule?: pulumi.Input<inputs.netapp.VolumeSnapshotPolicyDailySchedule>;
        /**
         * Enables automated snapshot creation according to defined schedule. Default is false.
         * To disable automatic snapshot creation you have to remove the whole snapshotPolicy block.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Hourly schedule policy.
         * Structure is documented below.
         */
        hourlySchedule?: pulumi.Input<inputs.netapp.VolumeSnapshotPolicyHourlySchedule>;
        /**
         * Monthly schedule policy.
         * Structure is documented below.
         */
        monthlySchedule?: pulumi.Input<inputs.netapp.VolumeSnapshotPolicyMonthlySchedule>;
        /**
         * Weekly schedule policy.
         * Structure is documented below.
         */
        weeklySchedule?: pulumi.Input<inputs.netapp.VolumeSnapshotPolicyWeeklySchedule>;
    }

    export interface VolumeSnapshotPolicyDailySchedule {
        /**
         * Set the hour to create the snapshot (0-23), defaults to midnight (0).
         */
        hour?: pulumi.Input<number>;
        /**
         * Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
         */
        minute?: pulumi.Input<number>;
        /**
         * The maximum number of snapshots to keep for the daily schedule.
         */
        snapshotsToKeep: pulumi.Input<number>;
    }

    export interface VolumeSnapshotPolicyHourlySchedule {
        /**
         * Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
         */
        minute?: pulumi.Input<number>;
        /**
         * The maximum number of snapshots to keep for the hourly schedule.
         */
        snapshotsToKeep: pulumi.Input<number>;
    }

    export interface VolumeSnapshotPolicyMonthlySchedule {
        /**
         * Set the day or days of the month to make a snapshot (1-31). Accepts a comma separated number of days. Defaults to '1'.
         */
        daysOfMonth?: pulumi.Input<string>;
        /**
         * Set the hour to create the snapshot (0-23), defaults to midnight (0).
         */
        hour?: pulumi.Input<number>;
        /**
         * Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
         */
        minute?: pulumi.Input<number>;
        /**
         * The maximum number of snapshots to keep for the monthly schedule
         */
        snapshotsToKeep: pulumi.Input<number>;
    }

    export interface VolumeSnapshotPolicyWeeklySchedule {
        /**
         * Set the day or days of the week to make a snapshot. Accepts a comma separated days of the week. Defaults to 'Sunday'.
         */
        day?: pulumi.Input<string>;
        /**
         * Set the hour to create the snapshot (0-23), defaults to midnight (0).
         */
        hour?: pulumi.Input<number>;
        /**
         * Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
         */
        minute?: pulumi.Input<number>;
        /**
         * The maximum number of snapshots to keep for the weekly schedule.
         */
        snapshotsToKeep: pulumi.Input<number>;
    }

    export interface VolumeTieringPolicy {
        /**
         * Optional. Time in days to mark the volume's data block as cold and make it eligible for tiering, can be range from 2-183.
         * Default is 31.
         */
        coolingThresholdDays?: pulumi.Input<number>;
        /**
         * Optional. Flag indicating if the volume has tiering policy enable/pause. Default is PAUSED.
         * Default value is `PAUSED`.
         * Possible values are: `ENABLED`, `PAUSED`.
         */
        tierAction?: pulumi.Input<string>;
    }
}

export namespace networkconnectivity {
    export interface GroupAutoAccept {
        /**
         * A list of project ids or project numbers for which you want to enable auto-accept. The auto-accept setting is applied to spokes being created or updated in these projects.
         */
        autoAcceptProjects: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface HubRoutingVpc {
        /**
         * The URI of the VPC network.
         */
        uri?: pulumi.Input<string>;
    }

    export interface InternalRangeMigration {
        /**
         * Resource path as an URI of the source resource, for example a subnet.
         * The project for the source resource should match the project for the
         * InternalRange.
         * An example /projects/{project}/regions/{region}/subnetworks/{subnet}
         */
        source: pulumi.Input<string>;
        /**
         * Resource path of the target resource. The target project can be
         * different, as in the cases when migrating to peer networks. The resource
         * may not exist yet.
         * For example /projects/{project}/regions/{region}/subnetworks/{subnet}
         */
        target: pulumi.Input<string>;
    }

    export interface PolicyBasedRouteFilter {
        /**
         * The destination IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.
         *
         * - - -
         */
        destRange?: pulumi.Input<string>;
        /**
         * The IP protocol that this policy-based route applies to. Valid values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
         */
        ipProtocol?: pulumi.Input<string>;
        /**
         * Internet protocol versions this policy-based route applies to.
         * Possible values are: `IPV4`.
         */
        protocolVersion: pulumi.Input<string>;
        /**
         * The source IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.
         */
        srcRange?: pulumi.Input<string>;
    }

    export interface PolicyBasedRouteInterconnectAttachment {
        /**
         * Cloud region to install this policy-based route on for Interconnect attachments. Use `all` to install it on all Interconnect attachments.
         */
        region: pulumi.Input<string>;
    }

    export interface PolicyBasedRouteVirtualMachine {
        /**
         * A list of VM instance tags that this policy-based route applies to. VM instances that have ANY of tags specified here will install this PBR.
         */
        tags: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyBasedRouteWarning {
        /**
         * (Output)
         * A warning code, if applicable.
         */
        code?: pulumi.Input<string>;
        /**
         * (Output)
         * Metadata about this warning in key: value format. The key should provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement.
         */
        data?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * (Output)
         * A human-readable description of the warning code.
         */
        warningMessage?: pulumi.Input<string>;
    }

    export interface ServiceConnectionPolicyPscConfig {
        /**
         * Max number of PSC connections for this policy.
         */
        limit?: pulumi.Input<string>;
        /**
         * IDs of the subnetworks or fully qualified identifiers for the subnetworks
         */
        subnetworks: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServiceConnectionPolicyPscConnection {
        /**
         * The resource reference of the consumer address.
         */
        consumerAddress?: pulumi.Input<string>;
        /**
         * The resource reference of the PSC Forwarding Rule within the consumer VPC.
         */
        consumerForwardingRule?: pulumi.Input<string>;
        /**
         * The project where the PSC connection is created.
         */
        consumerTargetProject?: pulumi.Input<string>;
        /**
         * The most recent error during operating this connection.
         * Structure is documented below.
         */
        error?: pulumi.Input<inputs.networkconnectivity.ServiceConnectionPolicyPscConnectionError>;
        /**
         * The error info for the latest error during operating this connection.
         * Structure is documented below.
         */
        errorInfo?: pulumi.Input<inputs.networkconnectivity.ServiceConnectionPolicyPscConnectionErrorInfo>;
        /**
         * The error type indicates whether the error is consumer facing, producer
         * facing or system internal.
         * Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
         */
        errorType?: pulumi.Input<string>;
        /**
         * The last Compute Engine operation to setup PSC connection.
         */
        gceOperation?: pulumi.Input<string>;
        /**
         * The PSC connection id of the PSC forwarding rule.
         */
        pscConnectionId?: pulumi.Input<string>;
        /**
         * The state of the PSC connection.
         * Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
         */
        state?: pulumi.Input<string>;
    }

    export interface ServiceConnectionPolicyPscConnectionError {
        /**
         * The status code, which should be an enum value of [google.rpc.Code][].
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * A developer-facing error message.
         */
        message?: pulumi.Input<string>;
    }

    export interface ServiceConnectionPolicyPscConnectionErrorInfo {
        /**
         * The logical grouping to which the "reason" belongs.
         */
        domain?: pulumi.Input<string>;
        /**
         * Additional structured details about this error.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The reason of the error.
         */
        reason?: pulumi.Input<string>;
    }

    export interface SpokeLinkedInterconnectAttachments {
        /**
         * IP ranges allowed to be included during import from hub (does not control transit connectivity).
         * The only allowed value for now is "ALL_IPV4_RANGES".
         */
        includeImportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
         */
        siteToSiteDataTransfer: pulumi.Input<boolean>;
        /**
         * The URIs of linked interconnect attachment resources
         */
        uris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SpokeLinkedProducerVpcNetwork {
        /**
         * IP ranges encompassing the subnets to be excluded from peering.
         */
        excludeExportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * IP ranges allowed to be included from peering.
         */
        includeExportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The URI of the Service Consumer VPC that the Producer VPC is peered with.
         */
        network: pulumi.Input<string>;
        /**
         * The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
         */
        peering: pulumi.Input<string>;
        /**
         * (Output)
         * The URI of the Producer VPC.
         */
        producerNetwork?: pulumi.Input<string>;
    }

    export interface SpokeLinkedRouterApplianceInstances {
        /**
         * IP ranges allowed to be included during import from hub (does not control transit connectivity).
         * The only allowed value for now is "ALL_IPV4_RANGES".
         */
        includeImportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of router appliance instances
         * Structure is documented below.
         */
        instances: pulumi.Input<pulumi.Input<inputs.networkconnectivity.SpokeLinkedRouterApplianceInstancesInstance>[]>;
        /**
         * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
         */
        siteToSiteDataTransfer: pulumi.Input<boolean>;
    }

    export interface SpokeLinkedRouterApplianceInstancesInstance {
        /**
         * The IP address on the VM to use for peering.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The URI of the virtual machine resource
         */
        virtualMachine: pulumi.Input<string>;
    }

    export interface SpokeLinkedVpcNetwork {
        /**
         * IP ranges encompassing the subnets to be excluded from peering.
         */
        excludeExportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * IP ranges allowed to be included from peering.
         */
        includeExportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The URI of the VPC network resource.
         */
        uri: pulumi.Input<string>;
    }

    export interface SpokeLinkedVpnTunnels {
        /**
         * IP ranges allowed to be included during import from hub (does not control transit connectivity).
         * The only allowed value for now is "ALL_IPV4_RANGES".
         */
        includeImportRanges?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
         */
        siteToSiteDataTransfer: pulumi.Input<boolean>;
        /**
         * The URIs of linked VPN tunnel resources.
         */
        uris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SpokeReason {
        /**
         * The code associated with this reason.
         */
        code?: pulumi.Input<string>;
        /**
         * Human-readable details about this reason.
         */
        message?: pulumi.Input<string>;
        /**
         * Additional information provided by the user in the RejectSpoke call.
         */
        userDetails?: pulumi.Input<string>;
    }
}

export namespace networkmanagement {
    export interface ConnectivityTestDestination {
        /**
         * A Cloud SQL instance URI.
         */
        cloudSqlInstance?: pulumi.Input<string>;
        /**
         * Forwarding rule URI. Forwarding rules are frontends for load balancers,
         * PSC endpoints, and Protocol Forwarding.
         */
        forwardingRule?: pulumi.Input<string>;
        /**
         * A DNS endpoint of Google Kubernetes Engine cluster control plane.
         * Requires gkeMasterCluster to be set, can't be used simultaneoulsly with
         * ipAddress or network. Applicable only to destination endpoint.
         */
        fqdn?: pulumi.Input<string>;
        /**
         * A cluster URI for Google Kubernetes Engine cluster control plane.
         */
        gkeMasterCluster?: pulumi.Input<string>;
        /**
         * A Compute Engine instance URI.
         */
        instance?: pulumi.Input<string>;
        /**
         * The IP address of the endpoint, which can be an external or internal IP.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * A VPC network URI.
         */
        network?: pulumi.Input<string>;
        /**
         * The IP protocol port of the endpoint. Only applicable when protocol is
         * TCP or UDP.
         */
        port?: pulumi.Input<number>;
        /**
         * Project ID where the endpoint is located.
         * The project ID can be derived from the URI if you provide a endpoint or
         * network URI.
         * The following are two cases where you may need to provide the project ID:
         * 1. Only the IP address is specified, and the IP address is within a Google
         * Cloud project.
         * 2. When you are using Shared VPC and the IP address that you provide is
         * from the service project. In this case, the network that the IP address
         * resides in is defined in the host project.
         *
         * - - -
         */
        projectId?: pulumi.Input<string>;
        /**
         * A Redis Cluster URI.
         */
        redisCluster?: pulumi.Input<string>;
        /**
         * A Redis Instance URI.
         */
        redisInstance?: pulumi.Input<string>;
    }

    export interface ConnectivityTestSource {
        /**
         * An App Engine service version.
         * Structure is documented below.
         */
        appEngineVersion?: pulumi.Input<inputs.networkmanagement.ConnectivityTestSourceAppEngineVersion>;
        /**
         * A Cloud Function.
         * Structure is documented below.
         */
        cloudFunction?: pulumi.Input<inputs.networkmanagement.ConnectivityTestSourceCloudFunction>;
        /**
         * A Cloud Run revision.
         * Structure is documented below.
         */
        cloudRunRevision?: pulumi.Input<inputs.networkmanagement.ConnectivityTestSourceCloudRunRevision>;
        /**
         * A Cloud SQL instance URI.
         */
        cloudSqlInstance?: pulumi.Input<string>;
        /**
         * A cluster URI for Google Kubernetes Engine cluster control plane.
         */
        gkeMasterCluster?: pulumi.Input<string>;
        /**
         * A Compute Engine instance URI.
         */
        instance?: pulumi.Input<string>;
        /**
         * The IP address of the endpoint, which can be an external or internal IP.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * A VPC network URI.
         */
        network?: pulumi.Input<string>;
        /**
         * Type of the network where the endpoint is located.
         * Possible values are: `GCP_NETWORK`, `NON_GCP_NETWORK`.
         */
        networkType?: pulumi.Input<string>;
        /**
         * The IP protocol port of the endpoint. Only applicable when protocol is
         * TCP or UDP.
         */
        port?: pulumi.Input<number>;
        /**
         * Project ID where the endpoint is located.
         * The project ID can be derived from the URI if you provide a endpoint or
         * network URI.
         * The following are two cases where you may need to provide the project ID:
         * 1. Only the IP address is specified, and the IP address is within a Google
         * Cloud project.
         * 2. When you are using Shared VPC and the IP address that you provide is
         * from the service project. In this case, the network that the IP address
         * resides in is defined in the host project.
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ConnectivityTestSourceAppEngineVersion {
        /**
         * An App Engine service version name.
         */
        uri?: pulumi.Input<string>;
    }

    export interface ConnectivityTestSourceCloudFunction {
        /**
         * A Cloud Function name.
         */
        uri?: pulumi.Input<string>;
    }

    export interface ConnectivityTestSourceCloudRunRevision {
        /**
         * A Cloud Run revision URI.
         */
        uri?: pulumi.Input<string>;
    }
}

export namespace networksecurity {
    export interface AddressGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AddressGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AuthorizationPolicyRule {
        /**
         * List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers.
         * If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthorizationPolicyRuleDestination>[]>;
        /**
         * List of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ipBlocks match.
         * If not set, the action specified in the 'action' field will be applied without any rule checks for the source.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthorizationPolicyRuleSource>[]>;
    }

    export interface AuthorizationPolicyRuleDestination {
        /**
         * List of host names to match. Matched against the ":authority" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example "mydomain.*") or a suffix match (example "*.myorg.com") or a presence (any) match "*".
         */
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases. At least one header should match.
         * Avoid using header matches to make authorization decisions unless there is a strong guarantee that requests arrive through a trusted client or proxy.
         * Structure is documented below.
         */
        httpHeaderMatch?: pulumi.Input<inputs.networksecurity.AuthorizationPolicyRuleDestinationHttpHeaderMatch>;
        /**
         * A list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.
         */
        methods: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of destination ports to match. At least one port should match.
         */
        ports: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AuthorizationPolicyRuleDestinationHttpHeaderMatch {
        /**
         * The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
         */
        regexMatch: pulumi.Input<string>;
    }

    export interface AuthorizationPolicyRuleSource {
        /**
         * List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone should be avoided.
         * The IP addresses of any load balancers or proxies should be considered untrusted.
         */
        ipBlocks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, "namespace/*") or a suffix match (example, "*&#47;service-account") or a presence match "*".
         * Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.
         */
        principals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthzPolicyCustomProvider {
        /**
         * Delegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.
         * Structure is documented below.
         */
        authzExtension?: pulumi.Input<inputs.networksecurity.AuthzPolicyCustomProviderAuthzExtension>;
        /**
         * Delegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.
         * Structure is documented below.
         */
        cloudIap?: pulumi.Input<inputs.networksecurity.AuthzPolicyCustomProviderCloudIap>;
    }

    export interface AuthzPolicyCustomProviderAuthzExtension {
        /**
         * A list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.
         */
        resources: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthzPolicyCustomProviderCloudIap {
        /**
         * Enable Cloud IAP at the AuthzPolicy level.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface AuthzPolicyHttpRule {
        /**
         * Describes properties of one or more sources of a request.
         * Structure is documented below.
         */
        from?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFrom>;
        /**
         * Describes properties of one or more targets of a request
         * Structure is documented below.
         */
        to?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleTo>;
        /**
         * CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.
         */
        when?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleFrom {
        /**
         * Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
         * Structure is documented below.
         */
        notSources?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromNotSource>[]>;
        /**
         * Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
         * Structure is documented below.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromSource>[]>;
    }

    export interface AuthzPolicyHttpRuleFromNotSource {
        /**
         * A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
         * Limited to 5 principals.
         * Structure is documented below.
         */
        principals?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromNotSourcePrincipal>[]>;
        /**
         * A list of resources to match against the resource of the source VM of a request.
         * Limited to 5 resources.
         * Structure is documented below.
         */
        resources?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromNotSourceResource>[]>;
    }

    export interface AuthzPolicyHttpRuleFromNotSourcePrincipal {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleFromNotSourceResource {
        /**
         * An IAM service account to match against the source service account of the VM sending the request.
         * Structure is documented below.
         */
        iamServiceAccount?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccount>;
        /**
         * A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
         * Structure is documented below.
         */
        tagValueIdSet?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSet>;
    }

    export interface AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccount {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSet {
        /**
         * A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
         * Limited to 5 matches.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthzPolicyHttpRuleFromSource {
        /**
         * A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
         * Limited to 5 principals.
         * Structure is documented below.
         */
        principals?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromSourcePrincipal>[]>;
        /**
         * A list of resources to match against the resource of the source VM of a request.
         * Limited to 5 resources.
         * Structure is documented below.
         */
        resources?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromSourceResource>[]>;
    }

    export interface AuthzPolicyHttpRuleFromSourcePrincipal {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleFromSourceResource {
        /**
         * An IAM service account to match against the source service account of the VM sending the request.
         * Structure is documented below.
         */
        iamServiceAccount?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromSourceResourceIamServiceAccount>;
        /**
         * A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
         * Structure is documented below.
         */
        tagValueIdSet?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleFromSourceResourceTagValueIdSet>;
    }

    export interface AuthzPolicyHttpRuleFromSourceResourceIamServiceAccount {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleFromSourceResourceTagValueIdSet {
        /**
         * A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
         * Limited to 5 matches.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AuthzPolicyHttpRuleTo {
        /**
         * Describes the negated properties of the targets of a request. Matches requests for operations that do not match the criteria specified in this field. At least one of operations or notOperations must be specified.
         * Structure is documented below.
         */
        notOperations?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperation>[]>;
        /**
         * Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 5 operations. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.
         * Structure is documented below.
         */
        operations?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperation>[]>;
    }

    export interface AuthzPolicyHttpRuleToNotOperation {
        /**
         * A list of headers to match against in http header.
         * Structure is documented below.
         */
        headerSet?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperationHeaderSet>;
        /**
         * A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
         * Limited to 5 matches.
         * Structure is documented below.
         */
        hosts?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperationHost>[]>;
        /**
         * A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
         * Limited to 5 matches.
         * Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
         * Structure is documented below.
         */
        paths?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperationPath>[]>;
    }

    export interface AuthzPolicyHttpRuleToNotOperationHeaderSet {
        /**
         * A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 5 matches.
         * Structure is documented below.
         */
        headers?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperationHeaderSetHeader>[]>;
    }

    export interface AuthzPolicyHttpRuleToNotOperationHeaderSetHeader {
        /**
         * Specifies the name of the header in the request.
         */
        name?: pulumi.Input<string>;
        /**
         * Specifies how the header match will be performed.
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValue>;
    }

    export interface AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValue {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleToNotOperationHost {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleToNotOperationPath {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleToOperation {
        /**
         * A list of headers to match against in http header.
         * Structure is documented below.
         */
        headerSet?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperationHeaderSet>;
        /**
         * A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
         * Limited to 5 matches.
         * Structure is documented below.
         */
        hosts?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperationHost>[]>;
        /**
         * A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
         * Limited to 5 matches.
         * Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
         * Structure is documented below.
         */
        paths?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperationPath>[]>;
    }

    export interface AuthzPolicyHttpRuleToOperationHeaderSet {
        /**
         * A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 5 matches.
         * Structure is documented below.
         */
        headers?: pulumi.Input<pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperationHeaderSetHeader>[]>;
    }

    export interface AuthzPolicyHttpRuleToOperationHeaderSetHeader {
        /**
         * Specifies the name of the header in the request.
         */
        name?: pulumi.Input<string>;
        /**
         * Specifies how the header match will be performed.
         * Structure is documented below.
         */
        value?: pulumi.Input<inputs.networksecurity.AuthzPolicyHttpRuleToOperationHeaderSetHeaderValue>;
    }

    export interface AuthzPolicyHttpRuleToOperationHeaderSetHeaderValue {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleToOperationHost {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyHttpRuleToOperationPath {
        /**
         * The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc.def
         */
        contains?: pulumi.Input<string>;
        /**
         * The input string must match exactly the string specified here.
         * Examples:
         * * abc only matches the value abc.
         */
        exact?: pulumi.Input<string>;
        /**
         * If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value abc.xyz
         */
        prefix?: pulumi.Input<string>;
        /**
         * The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
         * Examples:
         * * abc matches the value xyz.abc
         */
        suffix?: pulumi.Input<string>;
    }

    export interface AuthzPolicyTarget {
        /**
         * All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
         * For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
         * Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`, `INTERNAL_SELF_MANAGED`.
         */
        loadBalancingScheme: pulumi.Input<string>;
        /**
         * A list of references to the Forwarding Rules on which this policy will be applied.
         *
         * - - -
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClientTlsPolicyClientCertificate {
        /**
         * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
         * Structure is documented below.
         */
        certificateProviderInstance?: pulumi.Input<inputs.networksecurity.ClientTlsPolicyClientCertificateCertificateProviderInstance>;
        /**
         * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
         * Structure is documented below.
         */
        grpcEndpoint?: pulumi.Input<inputs.networksecurity.ClientTlsPolicyClientCertificateGrpcEndpoint>;
    }

    export interface ClientTlsPolicyClientCertificateCertificateProviderInstance {
        /**
         * Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "googleCloudPrivateSpiffe" to use Certificate Authority Service certificate provider instance.
         */
        pluginInstance: pulumi.Input<string>;
    }

    export interface ClientTlsPolicyClientCertificateGrpcEndpoint {
        /**
         * The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
         */
        targetUri: pulumi.Input<string>;
    }

    export interface ClientTlsPolicyServerValidationCa {
        /**
         * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
         * Structure is documented below.
         */
        certificateProviderInstance?: pulumi.Input<inputs.networksecurity.ClientTlsPolicyServerValidationCaCertificateProviderInstance>;
        /**
         * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
         * Structure is documented below.
         */
        grpcEndpoint?: pulumi.Input<inputs.networksecurity.ClientTlsPolicyServerValidationCaGrpcEndpoint>;
    }

    export interface ClientTlsPolicyServerValidationCaCertificateProviderInstance {
        /**
         * Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "googleCloudPrivateSpiffe" to use Certificate Authority Service certificate provider instance.
         */
        pluginInstance: pulumi.Input<string>;
    }

    export interface ClientTlsPolicyServerValidationCaGrpcEndpoint {
        /**
         * The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
         */
        targetUri: pulumi.Input<string>;
    }

    export interface InterceptDeploymentGroupConnectedEndpointGroup {
        /**
         * (Output)
         * The connected endpoint group's resource name, for example:
         * `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
    }

    export interface InterceptDeploymentGroupLocation {
        /**
         * The cloud location of the deployment group, currently restricted to `global`.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface InterceptEndpointGroupAssociation {
        /**
         * (Output)
         * The connected deployment group's resource name, for example:
         * `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * The associated network, for example:
         * projects/123456789/global/networks/my-network.
         * See https://google.aip.dev/124.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface InterceptEndpointGroupAssociationLocation {
        /**
         * The cloud location of the association, currently restricted to `global`.
         *
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface InterceptEndpointGroupAssociationLocationsDetail {
        /**
         * The cloud location of the association, currently restricted to `global`.
         *
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface InterceptEndpointGroupConnectedDeploymentGroup {
        /**
         * (Output)
         * The list of locations where the deployment group is present.
         * Structure is documented below.
         */
        locations?: pulumi.Input<pulumi.Input<inputs.networksecurity.InterceptEndpointGroupConnectedDeploymentGroupLocation>[]>;
        /**
         * (Output)
         * The connected deployment group's resource name, for example:
         * `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
    }

    export interface InterceptEndpointGroupConnectedDeploymentGroupLocation {
        /**
         * The cloud location of the endpoint group, currently restricted to `global`.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface MirroringDeploymentGroupConnectedEndpointGroup {
        /**
         * (Output)
         * The connected endpoint group's resource name, for example:
         * `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
    }

    export interface MirroringDeploymentGroupLocation {
        /**
         * The cloud location of the deployment group, currently restricted to `global`.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface MirroringEndpointGroupAssociation {
        /**
         * (Output)
         * The connected deployment group's resource name, for example:
         * `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
        /**
         * (Output)
         * The associated network, for example:
         * projects/123456789/global/networks/my-network.
         * See https://google.aip.dev/124.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface MirroringEndpointGroupAssociationLocation {
        /**
         * The cloud location of the association, currently restricted to `global`.
         *
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface MirroringEndpointGroupAssociationLocationsDetail {
        /**
         * The cloud location of the association, currently restricted to `global`.
         *
         *
         * - - -
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface MirroringEndpointGroupConnectedDeploymentGroup {
        /**
         * (Output)
         * The list of locations where the deployment group is present.
         * Structure is documented below.
         */
        locations?: pulumi.Input<pulumi.Input<inputs.networksecurity.MirroringEndpointGroupConnectedDeploymentGroupLocation>[]>;
        /**
         * (Output)
         * The connected deployment group's resource name, for example:
         * `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
         * See https://google.aip.dev/124.
         */
        name?: pulumi.Input<string>;
    }

    export interface MirroringEndpointGroupConnectedDeploymentGroupLocation {
        /**
         * The cloud location of the endpoint group, currently restricted to `global`.
         */
        location?: pulumi.Input<string>;
        /**
         * (Output)
         * The current state of the association in this location.
         * Possible values:
         * STATE_UNSPECIFIED
         * ACTIVE
         * OUT_OF_SYNC
         */
        state?: pulumi.Input<string>;
    }

    export interface SecurityProfileCustomInterceptProfile {
        /**
         * The Intercept Endpoint Group to which matching traffic should be intercepted.
         * Format: projects/{project_id}/locations/global/interceptEndpointGroups/{endpoint_group_id}
         */
        interceptEndpointGroup: pulumi.Input<string>;
    }

    export interface SecurityProfileCustomMirroringProfile {
        /**
         * The Mirroring Endpoint Group to which matching traffic should be mirrored.
         * Format: projects/{project_id}/locations/global/mirroringEndpointGroups/{endpoint_group_id}
         */
        mirroringEndpointGroup: pulumi.Input<string>;
    }

    export interface SecurityProfileThreatPreventionProfile {
        /**
         * Defines what action to take for antivirus threats per protocol.
         * Structure is documented below.
         */
        antivirusOverrides?: pulumi.Input<pulumi.Input<inputs.networksecurity.SecurityProfileThreatPreventionProfileAntivirusOverride>[]>;
        /**
         * The configuration for overriding threats actions by severity match.
         * Structure is documented below.
         */
        severityOverrides?: pulumi.Input<pulumi.Input<inputs.networksecurity.SecurityProfileThreatPreventionProfileSeverityOverride>[]>;
        /**
         * The configuration for overriding threats actions by threat id match.
         * If a threat is matched both by configuration provided in severity overrides
         * and threat overrides, the threat overrides action is applied.
         * Structure is documented below.
         */
        threatOverrides?: pulumi.Input<pulumi.Input<inputs.networksecurity.SecurityProfileThreatPreventionProfileThreatOverride>[]>;
    }

    export interface SecurityProfileThreatPreventionProfileAntivirusOverride {
        /**
         * Threat action override. For some threat types, only a subset of actions applies.
         * Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
         */
        action: pulumi.Input<string>;
        /**
         * Required protocol to match.
         * Possible values are: `SMTP`, `SMB`, `POP3`, `IMAP`, `HTTP2`, `HTTP`, `FTP`.
         */
        protocol: pulumi.Input<string>;
    }

    export interface SecurityProfileThreatPreventionProfileSeverityOverride {
        /**
         * Threat action override.
         * Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
         */
        action: pulumi.Input<string>;
        /**
         * Severity level to match.
         * Possible values are: `CRITICAL`, `HIGH`, `INFORMATIONAL`, `LOW`, `MEDIUM`.
         */
        severity: pulumi.Input<string>;
    }

    export interface SecurityProfileThreatPreventionProfileThreatOverride {
        /**
         * Threat action.
         * Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
         */
        action: pulumi.Input<string>;
        /**
         * Vendor-specific ID of a threat to override.
         */
        threatId: pulumi.Input<string>;
        /**
         * (Output)
         * Type of threat.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServerTlsPolicyMtlsPolicy {
        /**
         * Required if the policy is to be used with Traffic Director. For external HTTPS load balancers it must be empty.
         * Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
         * Structure is documented below.
         */
        clientValidationCas?: pulumi.Input<pulumi.Input<inputs.networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCa>[]>;
        /**
         * When the client presents an invalid certificate or no certificate to the load balancer, the clientValidationMode specifies how the client connection is handled.
         * Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
         * Possible values are: `CLIENT_VALIDATION_MODE_UNSPECIFIED`, `ALLOW_INVALID_OR_MISSING_CLIENT_CERT`, `REJECT_INVALID`.
         */
        clientValidationMode?: pulumi.Input<string>;
        /**
         * Reference to the TrustConfig from certificatemanager.googleapis.com namespace.
         * If specified, the chain validation will be performed against certificates configured in the given TrustConfig.
         * Allowed only if the policy is to be used with external HTTPS load balancers.
         */
        clientValidationTrustConfig?: pulumi.Input<string>;
    }

    export interface ServerTlsPolicyMtlsPolicyClientValidationCa {
        /**
         * Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
         * Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
         * Structure is documented below.
         */
        certificateProviderInstance?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance>;
        /**
         * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
         * Structure is documented below.
         */
        grpcEndpoint?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpoint>;
    }

    export interface ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance {
        /**
         * Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "googleCloudPrivateSpiffe" to use Certificate Authority Service certificate provider instance.
         */
        pluginInstance: pulumi.Input<string>;
    }

    export interface ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpoint {
        /**
         * The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
         */
        targetUri: pulumi.Input<string>;
    }

    export interface ServerTlsPolicyServerCertificate {
        /**
         * Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
         * Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
         * Structure is documented below.
         */
        certificateProviderInstance?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyServerCertificateCertificateProviderInstance>;
        /**
         * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
         * Structure is documented below.
         */
        grpcEndpoint?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyServerCertificateGrpcEndpoint>;
    }

    export interface ServerTlsPolicyServerCertificateCertificateProviderInstance {
        /**
         * Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "googleCloudPrivateSpiffe" to use Certificate Authority Service certificate provider instance.
         */
        pluginInstance: pulumi.Input<string>;
    }

    export interface ServerTlsPolicyServerCertificateGrpcEndpoint {
        /**
         * The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
         */
        targetUri: pulumi.Input<string>;
    }
}

export namespace networkservices {
    export interface EdgeCacheKeysetPublicKey {
        /**
         * The ID of the public key. The ID must be 1-63 characters long, and comply with RFC1035.
         * The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]*
         * which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
         */
        id: pulumi.Input<string>;
        /**
         * Set to true to have the CDN automatically manage this public key value.
         */
        managed?: pulumi.Input<boolean>;
        /**
         * The base64-encoded value of the Ed25519 public key. The base64 encoding can be padded (44 bytes) or unpadded (43 bytes).
         * Representations or encodings of the public key other than this will be rejected with an error.
         * **Note**: This property is sensitive and will not be displayed in the plan.
         */
        value?: pulumi.Input<string>;
    }

    export interface EdgeCacheKeysetValidationSharedKey {
        /**
         * The name of the secret version in Secret Manager.
         * The resource name of the secret version must be in the format `projects/*&#47;secrets/*&#47;versions/*` where the `*` values are replaced by the secrets themselves.
         * The secrets must be at least 16 bytes large.  The recommended secret size depends on the signature algorithm you are using.
         * * If you are using HMAC-SHA1, we suggest 20-byte secrets.
         * * If you are using HMAC-SHA256, we suggest 32-byte secrets.
         * See RFC 2104, Section 3 for more details on these recommendations.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface EdgeCacheOriginAwsV4Authentication {
        /**
         * The access key ID your origin uses to identify the key.
         */
        accessKeyId: pulumi.Input<string>;
        /**
         * The name of the AWS region that your origin is in.
         */
        originRegion: pulumi.Input<string>;
        /**
         * The Secret Manager secret version of the secret access key used by your origin.
         *
         * This is the resource name of the secret version in the format 'projects/*&#47;secrets/*&#47;versions/*' where the '*' values are replaced by the project, secret, and version you require.
         */
        secretAccessKeyVersion: pulumi.Input<string>;
    }

    export interface EdgeCacheOriginFlexShielding {
        /**
         * Whenever possible, content will be fetched from origin and cached in or
         * near the specified origin. Best effort.
         * You must specify exactly one FlexShieldingRegion.
         * Each value may be one of: `AFRICA_SOUTH1`, `ME_CENTRAL1`.
         */
        flexShieldingRegions?: pulumi.Input<string>;
    }

    export interface EdgeCacheOriginOriginOverrideAction {
        /**
         * The header actions, including adding and removing
         * headers, for request handled by this origin.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.networkservices.EdgeCacheOriginOriginOverrideActionHeaderAction>;
        /**
         * The URL rewrite configuration for request that are
         * handled by this origin.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.networkservices.EdgeCacheOriginOriginOverrideActionUrlRewrite>;
    }

    export interface EdgeCacheOriginOriginOverrideActionHeaderAction {
        /**
         * Describes a header to add.
         * You may add a maximum of 25 request headers.
         * Structure is documented below.
         */
        requestHeadersToAdds?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAdd>[]>;
    }

    export interface EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * Whether to replace all existing headers with the same name.
         * By default, added header values are appended
         * to the response or request headers with the
         * same field names. The added values are
         * separated by commas.
         * To overwrite existing values, set `replace` to `true`.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface EdgeCacheOriginOriginOverrideActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected
         * origin, the request's host header is replaced with
         * contents of the hostRewrite.
         * This value must be between 1 and 255 characters.
         */
        hostRewrite?: pulumi.Input<string>;
    }

    export interface EdgeCacheOriginOriginRedirect {
        /**
         * The set of redirect response codes that the CDN
         * follows. Values of
         * [RedirectConditions](https://cloud.google.com/media-cdn/docs/reference/rest/v1/projects.locations.edgeCacheOrigins#redirectconditions)
         * are accepted.
         */
        redirectConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EdgeCacheOriginTimeout {
        /**
         * The maximum duration to wait for a single origin connection to be established, including DNS lookup, TLS handshake and TCP/QUIC connection establishment.
         * Defaults to 5 seconds. The timeout must be a value between 1s and 15s.
         * The connectTimeout capped by the deadline set by the request's maxAttemptsTimeout.  The last connection attempt may have a smaller connectTimeout in order to adhere to the overall maxAttemptsTimeout.
         */
        connectTimeout?: pulumi.Input<string>;
        /**
         * The maximum time across all connection attempts to the origin, including failover origins, before returning an error to the client. A HTTP 504 will be returned if the timeout is reached before a response is returned.
         * Defaults to 15 seconds. The timeout must be a value between 1s and 30s.
         * If a failoverOrigin is specified, the maxAttemptsTimeout of the first configured origin sets the deadline for all connection attempts across all failoverOrigins.
         */
        maxAttemptsTimeout?: pulumi.Input<string>;
        /**
         * The maximum duration to wait between reads of a single HTTP connection/stream.
         * Defaults to 15 seconds.  The timeout must be a value between 1s and 30s.
         * The readTimeout is capped by the responseTimeout.  All reads of the HTTP connection/stream must be completed by the deadline set by the responseTimeout.
         * If the response headers have already been written to the connection, the response will be truncated and logged.
         *
         * <a name="nestedAwsV4Authentication"></a>The `awsV4Authentication` block supports:
         */
        readTimeout?: pulumi.Input<string>;
        /**
         * The maximum duration to wait for the last byte of a response to arrive when reading from the HTTP connection/stream.
         * Defaults to 30 seconds. The timeout must be a value between 1s and 120s.
         * The responseTimeout starts after the connection has been established.
         * This also applies to HTTP Chunked Transfer Encoding responses, and/or when an open-ended Range request is made to the origin. Origins that take longer to write additional bytes to the response than the configured responseTimeout will result in an error being returned to the client.
         * If the response headers have already been written to the connection, the response will be truncated and logged.
         */
        responseTimeout?: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceLogConfig {
        /**
         * Specifies whether to enable logging for traffic served by this service.
         */
        enable?: pulumi.Input<boolean>;
        /**
         * Configures the sampling rate of requests, where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported. The default value is 1.0, and the value of the field must be in [0, 1].
         * This field can only be specified if logging is enabled for this service.
         */
        sampleRate?: pulumi.Input<number>;
    }

    export interface EdgeCacheServiceRouting {
        /**
         * The list of hostRules to match against. These rules define which hostnames the EdgeCacheService will match against, and which route configurations apply.
         * Structure is documented below.
         */
        hostRules: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingHostRule>[]>;
        /**
         * The list of pathMatchers referenced via name by hostRules. PathMatcher is used to match the path portion of the URL when a HostRule matches the URL's host portion.
         * Structure is documented below.
         */
        pathMatchers: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcher>[]>;
    }

    export interface EdgeCacheServiceRoutingHostRule {
        /**
         * A human-readable description of the hostRule.
         */
        description?: pulumi.Input<string>;
        /**
         * The list of host patterns to match.
         * Host patterns must be valid hostnames. Ports are not allowed. Wildcard hosts are supported in the suffix or prefix form. * matches any string of ([a-z0-9-.]*). It does not match the empty string.
         * When multiple hosts are specified, hosts are matched in the following priority:
         * 1. Exact domain names: ``www.foo.com``.
         * 2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
         * 3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
         * 4. Special wildcard ``*`` matching any domain.
         * Notes:
         * The wildcard will not match the empty string. e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``. The longest wildcards match first. Only a single host in the entire service can match on ``*``. A domain must be unique across all configured hosts within a service.
         * Hosts are matched against the HTTP Host header, or for HTTP/2 and HTTP/3, the ":authority" header, from the incoming request.
         * You may specify up to 10 hosts.
         */
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the pathMatcher associated with this hostRule.
         */
        pathMatcher: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcher {
        /**
         * A human-readable description of the resource.
         */
        description?: pulumi.Input<string>;
        /**
         * The name to which this PathMatcher is referred by the HostRule.
         */
        name: pulumi.Input<string>;
        /**
         * The routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.
         * Structure is documented below.
         */
        routeRules: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRule>[]>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRule {
        /**
         * A human-readable description of the routeRule.
         */
        description?: pulumi.Input<string>;
        /**
         * The header actions, including adding & removing headers, for requests that match this route.
         * Structure is documented below.
         */
        headerAction?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction>;
        /**
         * The list of criteria for matching attributes of a request to this routeRule. This list has OR semantics: the request matches this routeRule when any of the matchRules are satisfied. However predicates
         * within a given matchRule have AND semantics. All predicates within a matchRule must match for the request to match the rule.
         * Structure is documented below.
         */
        matchRules: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule>[]>;
        /**
         * The Origin resource that requests to this route should fetch from when a matching response is not in cache. Origins can be defined as short names ("my-origin") or fully-qualified resource URLs - e.g. "networkservices.googleapis.com/projects/my-project/global/edgecacheorigins/my-origin"
         * Only one of origin or urlRedirect can be set.
         */
        origin?: pulumi.Input<string>;
        /**
         * The priority of this route rule, where 1 is the highest priority.
         * You cannot configure two or more routeRules with the same priority. Priority for each rule must be set to a number between 1 and 999 inclusive.
         * Priority numbers can have gaps, which enable you to add or remove rules in the future without affecting the rest of the rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers
         * to which you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future without any impact on existing rules.
         */
        priority: pulumi.Input<string>;
        /**
         * In response to a matching path, the routeAction performs advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request to the selected origin.
         * Structure is documented below.
         */
        routeAction?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteAction>;
        /**
         * Allow overriding the set of methods that are allowed for this route.
         * When not set, Media CDN allows only "GET", "HEAD", and "OPTIONS".
         * Structure is documented below.
         */
        routeMethods?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteMethods>;
        /**
         * The URL redirect configuration for requests that match this route.
         * Structure is documented below.
         */
        urlRedirect?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirect>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction {
        /**
         * Describes a header to add.
         * Structure is documented below.
         */
        requestHeaderToAdds?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to forwarding the request to the origin.
         * Structure is documented below.
         */
        requestHeaderToRemoves?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove>[]>;
        /**
         * Headers to add to the response prior to sending it back to the client.
         * Response headers are only sent to the client, and do not have an effect on the cache serving the response.
         * Structure is documented below.
         */
        responseHeaderToAdds?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd>[]>;
        /**
         * A list of header names for headers that need to be removed from the request prior to forwarding the request to the origin.
         * Structure is documented below.
         */
        responseHeaderToRemoves?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemove>[]>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * Whether to replace all existing headers with the same name.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove {
        /**
         * The name of the header to remove.
         */
        headerName: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd {
        /**
         * The name of the header to add.
         */
        headerName: pulumi.Input<string>;
        /**
         * The value of the header to add.
         */
        headerValue: pulumi.Input<string>;
        /**
         * Whether to replace all existing headers with the same name.
         */
        replace?: pulumi.Input<boolean>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemove {
        /**
         * Headers to remove from the response prior to sending it back to the client.
         * Response headers are only sent to the client, and do not have an effect on the cache serving the response.
         */
        headerName: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule {
        /**
         * For satisfying the matchRule condition, the path of the request must exactly match the value specified in fullPathMatch after removing any query parameters and anchor that may be part of the original URL.
         */
        fullPathMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of header match criteria, all of which must match corresponding headers in the request.
         * Structure is documented below.
         */
        headerMatches?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatch>[]>;
        /**
         * Specifies that prefixMatch and fullPathMatch matches are case sensitive.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * For satisfying the matchRule condition, the path of the request
         * must match the wildcard pattern specified in pathTemplateMatch
         * after removing any query parameters and anchor that may be part
         * of the original URL.
         * pathTemplateMatch must be between 1 and 255 characters
         * (inclusive).  The pattern specified by pathTemplateMatch may
         * have at most 5 wildcard operators and at most 5 variable
         * captures in total.
         */
        pathTemplateMatch?: pulumi.Input<string>;
        /**
         * For satisfying the matchRule condition, the request's path must begin with the specified prefixMatch. prefixMatch must begin with a /.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of query parameter match criteria, all of which must match corresponding query parameters in the request.
         * Structure is documented below.
         */
        queryParameterMatches?: pulumi.Input<pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch>[]>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatch {
        /**
         * The value of the header should exactly match contents of exactMatch.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The header name to match on.
         */
        headerName: pulumi.Input<string>;
        /**
         * If set to false (default), the headerMatch is considered a match if the match criteria above are met.
         * If set to true, the headerMatch is considered a match if the match criteria above are NOT met.
         */
        invertMatch?: pulumi.Input<boolean>;
        /**
         * The value of the header must start with the contents of prefixMatch.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The value of the header must end with the contents of suffixMatch.
         */
        suffixMatch?: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        /**
         * The queryParameterMatch matches if the value of the parameter exactly matches the contents of exactMatch.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the query parameter to match. The query parameter must exist in the request, in the absence of which the request match fails.
         */
        name: pulumi.Input<string>;
        /**
         * Specifies that the queryParameterMatch matches if the request contains the query parameter, irrespective of whether the parameter has a value or not.
         */
        presentMatch?: pulumi.Input<boolean>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteAction {
        /**
         * The policy to use for defining caching and signed request behaviour for requests that match this route.
         * Structure is documented below.
         */
        cdnPolicy?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicy>;
        /**
         * Setting the compression mode to automatic enables dynamic compression for every eligible response.
         * When dynamic compression is enabled, it is recommended to also set a cache policy to maximize efficiency.
         * Possible values are: `DISABLED`, `AUTOMATIC`.
         */
        compressionMode?: pulumi.Input<string>;
        /**
         * CORSPolicy defines Cross-Origin-Resource-Sharing configuration, including which CORS response headers will be set.
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicy>;
        /**
         * The URL rewrite configuration for requests that match this route.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewrite>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicy {
        /**
         * Enable signature generation or propagation on this route.
         * This field may only be specified when signedRequestMode is set to REQUIRE_TOKENS.
         * Structure is documented below.
         */
        addSignatures?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures>;
        /**
         * Defines the request parameters that contribute to the cache key.
         * Structure is documented below.
         */
        cacheKeyPolicy?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicy>;
        /**
         * Cache modes allow users to control the behaviour of the cache, what content it should cache automatically, whether to respect origin headers, or whether to unconditionally cache all responses.
         * For all cache modes, Cache-Control headers will be passed to the client. Use clientTtl to override what is sent to the client.
         * Possible values are: `CACHE_ALL_STATIC`, `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `BYPASS_CACHE`.
         */
        cacheMode?: pulumi.Input<string>;
        /**
         * Specifies a separate client (e.g. browser client) TTL, separate from the TTL used by the edge caches. Leaving this empty will use the same cache TTL for both the CDN and the client-facing response.
         * - The TTL must be > 0 and <= 86400s (1 day)
         * - The clientTtl cannot be larger than the defaultTtl (if set)
         * - Fractions of a second are not allowed.
         * Omit this field to use the defaultTtl, or the max-age set by the origin, as the client-facing TTL.
         * When the cache mode is set to "USE_ORIGIN_HEADERS" or "BYPASS_CACHE", you must omit this field.
         * A duration in seconds terminated by 's'. Example: "3s".
         */
        clientTtl?: pulumi.Input<string>;
        /**
         * Specifies the default TTL for cached content served by this origin for responses that do not have an existing valid TTL (max-age or s-max-age).
         * Defaults to 3600s (1 hour).
         * - The TTL must be >= 0 and <= 31,536,000 seconds (1 year)
         * - Setting a TTL of "0" means "always revalidate" (equivalent to must-revalidate)
         * - The value of defaultTTL cannot be set to a value greater than that of maxTTL.
         * - Fractions of a second are not allowed.
         * - When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite the TTL set in all responses.
         * Note that infrequently accessed objects may be evicted from the cache before the defined TTL. Objects that expire will be revalidated with the origin.
         * When the cache mode is set to "USE_ORIGIN_HEADERS" or "BYPASS_CACHE", you must omit this field.
         * A duration in seconds terminated by 's'. Example: "3s".
         */
        defaultTtl?: pulumi.Input<string>;
        /**
         * Specifies the maximum allowed TTL for cached content served by this origin.
         * Defaults to 86400s (1 day).
         * Cache directives that attempt to set a max-age or s-maxage higher than this, or an Expires header more than maxTtl seconds in the future will be capped at the value of maxTTL, as if it were the value of an s-maxage Cache-Control directive.
         * - The TTL must be >= 0 and <= 31,536,000 seconds (1 year)
         * - Setting a TTL of "0" means "always revalidate"
         * - The value of maxTtl must be equal to or greater than defaultTtl.
         * - Fractions of a second are not allowed.
         * When the cache mode is set to "USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", or "BYPASS_CACHE", you must omit this field.
         * A duration in seconds terminated by 's'. Example: "3s".
         */
        maxTtl?: pulumi.Input<string>;
        /**
         * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects. This can reduce the load on your origin and improve end-user experience by reducing response latency.
         * By default, the CDNPolicy will apply the following default TTLs to these status codes:
         * - HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m
         * - HTTP 404 (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s
         * - HTTP 405 (Method Not Found), 414 (URI Too Long), 501 (Not Implemented): 60s
         * These defaults can be overridden in negativeCachingPolicy
         */
        negativeCaching?: pulumi.Input<boolean>;
        /**
         * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
         * - Omitting the policy and leaving negativeCaching enabled will use the default TTLs for each status code, defined in negativeCaching.
         * - TTLs must be >= 0 (where 0 is "always revalidate") and <= 86400s (1 day)
         * Note that when specifying an explicit negativeCachingPolicy, you should take care to specify a cache TTL for all response codes that you wish to cache. The CDNPolicy will not apply any default negative caching when a policy exists.
         */
        negativeCachingPolicy?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The EdgeCacheKeyset containing the set of public keys used to validate signed requests at the edge.
         */
        signedRequestKeyset?: pulumi.Input<string>;
        /**
         * Limit how far into the future the expiration time of a signed request may be.
         * When set, a signed request is rejected if its expiration time is later than now + signedRequestMaximumExpirationTtl, where now is the time at which the signed request is first handled by the CDN.
         * - The TTL must be > 0.
         * - Fractions of a second are not allowed.
         * By default, signedRequestMaximumExpirationTtl is not set and the expiration time of a signed request may be arbitrarily far into future.
         */
        signedRequestMaximumExpirationTtl?: pulumi.Input<string>;
        /**
         * Whether to enforce signed requests. The default value is DISABLED, which means all content is public, and does not authorize access.
         * You must also set a signedRequestKeyset to enable signed requests.
         * When set to REQUIRE_SIGNATURES, all matching requests will have their signature validated. Requests that were not signed with the corresponding private key, or that are otherwise invalid (expired, do not match the signature, IP address, or header) will be rejected with a HTTP 403 and (if enabled) logged.
         * Possible values are: `DISABLED`, `REQUIRE_SIGNATURES`, `REQUIRE_TOKENS`.
         */
        signedRequestMode?: pulumi.Input<string>;
        /**
         * Additional options for signed tokens.
         * signedTokenOptions may only be specified when signedRequestMode is REQUIRE_TOKENS.
         * Structure is documented below.
         */
        signedTokenOptions?: pulumi.Input<inputs.networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures {
        /**
         * The actions to take to add signatures to responses.
         * Each value may be one of: `GENERATE_COOKIE`, `GENERATE_TOKEN_HLS_COOKIELESS`, `PROPAGATE_TOKEN_HLS_COOKIELESS`.
         */
        actions: pulumi.Input<string>;
        /**
         * The parameters to copy from the verified token to the generated token.
         * Only the following parameters may be copied:
         * * `PathGlobs`
         */
        copiedParameters?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The keyset to use for signature generation.
         * The following are both valid paths to an EdgeCacheKeyset resource:
         * * `projects/project/locations/global/edgeCacheKeysets/yourKeyset`
         * * `yourKeyset`
         * This must be specified when the GENERATE_COOKIE or GENERATE_TOKEN_HLS_COOKIELESS actions are specified.  This field may not be specified otherwise.
         */
        keyset?: pulumi.Input<string>;
        /**
         * The query parameter in which to put the generated token.
         * If not specified, defaults to `edge-cache-token`.
         * If specified, the name must be 1-64 characters long and match the regular expression `a-zA-Z*` which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
         * This field may only be set when the GENERATE_TOKEN_HLS_COOKIELESS or PROPAGATE_TOKEN_HLS_COOKIELESS actions are specified.
         */
        tokenQueryParameter?: pulumi.Input<string>;
        /**
         * The duration the token is valid starting from the moment the token is first generated.
         * Defaults to `86400s` (1 day).
         * The TTL must be >= 0 and <= 604,800 seconds (1 week).
         * This field may only be specified when the GENERATE_COOKIE or GENERATE_TOKEN_HLS_COOKIELESS actions are specified.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        tokenTtl?: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicy {
        /**
         * If true, requests to different hosts will be cached separately.
         * Note: this should only be enabled if hosts share the same origin and content. Removing the host from the cache key may inadvertently result in different objects being cached than intended, depending on which route the first user matched.
         */
        excludeHost?: pulumi.Input<boolean>;
        /**
         * If true, exclude query string parameters from the cache key
         * If false (the default), include the query string parameters in
         * the cache key according to includeQueryParameters and
         * excludeQueryParameters. If neither includeQueryParameters nor
         * excludeQueryParameters is set, the entire query string will be
         * included.
         */
        excludeQueryString?: pulumi.Input<boolean>;
        /**
         * Names of query string parameters to exclude from cache keys. All other parameters will be included.
         * Either specify includedQueryParameters or excludedQueryParameters, not both. '&' and '=' will be percent encoded and not treated as delimiters.
         */
        excludedQueryParameters?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, http and https requests will be cached separately.
         */
        includeProtocol?: pulumi.Input<boolean>;
        /**
         * Names of Cookies to include in cache keys.  The cookie name and cookie value of each cookie named will be used as part of the cache key.
         * Cookie names:
         * - must be valid RFC 6265 "cookie-name" tokens
         * - are case sensitive
         * - cannot start with "Edge-Cache-" (case insensitive)
         * Note that specifying several cookies, and/or cookies that have a large range of values (e.g., per-user) will dramatically impact the cache hit rate, and may result in a higher eviction rate and reduced performance.
         * You may specify up to three cookie names.
         */
        includedCookieNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of HTTP request headers to include in cache keys. The value of the header field will be used as part of the cache key.
         * - Header names must be valid HTTP RFC 7230 header field values.
         * - Header field names are case insensitive
         * - To include the HTTP method, use ":method"
         * Note that specifying several headers, and/or headers that have a large range of values (e.g. per-user) will dramatically impact the cache hit rate, and may result in a higher eviction rate and reduced performance.
         */
        includedHeaderNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of query string parameters to include in cache keys. All other parameters will be excluded.
         * Either specify includedQueryParameters or excludedQueryParameters, not both. '&' and '=' will be percent encoded and not treated as delimiters.
         */
        includedQueryParameters?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions {
        /**
         * The allowed signature algorithms to use.
         * Defaults to using only ED25519.
         * You may specify up to 3 signature algorithms to use.
         * Each value may be one of: `ED25519`, `HMAC_SHA_256`, `HMAC_SHA1`.
         */
        allowedSignatureAlgorithms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The query parameter in which to find the token.
         * The name must be 1-64 characters long and match the regular expression `a-zA-Z*` which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
         * Defaults to `edge-cache-token`.
         */
        tokenQueryParameter?: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         * This translates to the Access-Control-Allow-Credentials response header.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers response header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for the Access-Control-Allow-Methods response header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         * This translates to the Access-Control-Allow-Origin response header.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for the Access-Control-Allow-Headers response header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long results of a preflight request can be cached by a client in seconds. Note that many browser clients enforce a maximum TTL of 600s (10 minutes).
         * - Setting the value to -1 forces a pre-flight check for all requests (not recommended)
         * - A maximum TTL of 86400s can be set, but note that (as above) some clients may force pre-flight checks at a more regular interval.
         * - This translates to the Access-Control-Max-Age header.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxAge: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected origin, the request's host header is replaced with contents of hostRewrite.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected origin, the matching portion of the request's path is replaced by pathPrefixRewrite.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected origin, if the
         * request matched a pathTemplateMatch, the matching portion of the
         * request's path is replaced re-written using the pattern specified
         * by pathTemplateRewrite.
         * pathTemplateRewrite must be between 1 and 255 characters
         * (inclusive), must start with a '/', and must only use variables
         * captured by the route's pathTemplate matchers.
         * pathTemplateRewrite may only be used when all of a route's
         * MatchRules specify pathTemplate.
         * Only one of pathPrefixRewrite and pathTemplateRewrite may be
         * specified.
         */
        pathTemplateRewrite?: pulumi.Input<string>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleRouteMethods {
        /**
         * The non-empty set of HTTP methods that are allowed for this route.
         * Any combination of "GET", "HEAD", "OPTIONS", "PUT", "POST", "DELETE", and "PATCH".
         */
        allowedMethods?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was supplied in the request.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https. If set to false, the URL scheme of the redirected request will remain the same as that of the request.
         * This can only be set if there is at least one (1) edgeSslCertificate set on the service.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was supplied in the request.
         * pathRedirect cannot be supplied together with prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
         * The path value must be between 1 and 1024 characters.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The prefix that replaces the prefixMatch specified in the routeRule, retaining the remaining portion of the URL before redirecting the request.
         * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
         */
        prefixRedirect?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for this RedirectAction.
         * The supported values are:
         * - `MOVED_PERMANENTLY_DEFAULT`, which is the default value and corresponds to 301.
         * - `FOUND`, which corresponds to 302.
         * - `SEE_OTHER` which corresponds to 303.
         * - `TEMPORARY_REDIRECT`, which corresponds to 307. in this case, the request method will be retained.
         * - `PERMANENT_REDIRECT`, which corresponds to 308. in this case, the request method will be retained.
         * Possible values are: `MOVED_PERMANENTLY_DEFAULT`, `FOUND`, `SEE_OTHER`, `TEMPORARY_REDIRECT`, `PERMANENT_REDIRECT`.
         */
        redirectResponseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior to redirecting the request. If set to false, the query portion of the original URL is retained.
         *
         * - - -
         */
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface EndpointPolicyEndpointMatcher {
        /**
         * The matcher is based on node metadata presented by xDS clients.
         * Structure is documented below.
         */
        metadataLabelMatcher: pulumi.Input<inputs.networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcher>;
    }

    export interface EndpointPolicyEndpointMatcherMetadataLabelMatcher {
        /**
         * Specifies how matching should be done.
         * Possible values are: `MATCH_ANY`, `MATCH_ALL`.
         */
        metadataLabelMatchCriteria: pulumi.Input<string>;
        /**
         * The list of label value pairs that must match labels in the provided metadata based on filterMatchCriteria
         * Structure is documented below.
         */
        metadataLabels?: pulumi.Input<pulumi.Input<inputs.networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabel>[]>;
    }

    export interface EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabel {
        /**
         * Required. Label name presented as key in xDS Node Metadata.
         */
        labelName: pulumi.Input<string>;
        /**
         * Required. Label value presented as value corresponding to the above key, in xDS Node Metadata.
         *
         * - - -
         */
        labelValue: pulumi.Input<string>;
    }

    export interface EndpointPolicyTrafficPortSelector {
        /**
         * List of ports. Can be port numbers or port range (example, [80-90] specifies all ports from 80 to 90, including 80 and 90) or named ports or * to specify all ports. If the list is empty, all ports are selected.
         */
        ports: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GrpcRouteRule {
        /**
         * Required. A detailed rule defining how to route traffic.
         * Structure is documented below.
         */
        action?: pulumi.Input<inputs.networkservices.GrpcRouteRuleAction>;
        /**
         * Matches define conditions used for matching the rule against incoming gRPC requests.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.networkservices.GrpcRouteRuleMatch>[]>;
    }

    export interface GrpcRouteRuleAction {
        /**
         * The destination to which traffic should be forwarded.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.networkservices.GrpcRouteRuleActionDestination>[]>;
        /**
         * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.networkservices.GrpcRouteRuleActionFaultInjectionPolicy>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.networkservices.GrpcRouteRuleActionRetryPolicy>;
        /**
         * Specifies the timeout for selected route.
         */
        timeout?: pulumi.Input<string>;
    }

    export interface GrpcRouteRuleActionDestination {
        /**
         * The URL of a BackendService to route traffic to.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field.
         */
        weight?: pulumi.Input<number>;
    }

    export interface GrpcRouteRuleActionFaultInjectionPolicy {
        /**
         * Specification of how client requests are aborted as part of fault injection before being sent to a destination.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.networkservices.GrpcRouteRuleActionFaultInjectionPolicyAbort>;
        /**
         * Specification of how client requests are delayed as part of fault injection before being sent to a destination.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.networkservices.GrpcRouteRuleActionFaultInjectionPolicyDelay>;
    }

    export interface GrpcRouteRuleActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic which will be aborted.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface GrpcRouteRuleActionFaultInjectionPolicyDelay {
        /**
         * Specify a fixed delay before forwarding the request.
         */
        fixedDelay?: pulumi.Input<string>;
        /**
         * The percentage of traffic on which delay will be injected.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface GrpcRouteRuleActionRetryPolicy {
        /**
         * Specifies the allowed number of retries.
         *
         * - - -
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies one or more conditions when this retry policy applies.
         * Each value may be one of: `connect-failure`, `refused-stream`, `cancelled`, `deadline-exceeded`, `resource-exhausted`, `unavailable`.
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GrpcRouteRuleMatch {
        /**
         * Specifies a list of HTTP request headers to match against.
         * Structure is documented below.
         */
        headers?: pulumi.Input<pulumi.Input<inputs.networkservices.GrpcRouteRuleMatchHeader>[]>;
        /**
         * A gRPC method to match against. If this field is empty or omitted, will match all methods.
         * Structure is documented below.
         */
        method?: pulumi.Input<inputs.networkservices.GrpcRouteRuleMatchMethod>;
    }

    export interface GrpcRouteRuleMatchHeader {
        /**
         * Required. The key of the header.
         */
        key: pulumi.Input<string>;
        /**
         * The type of match.
         * Default value is `EXACT`.
         * Possible values are: `TYPE_UNSPECIFIED`, `EXACT`, `REGULAR_EXPRESSION`.
         */
        type?: pulumi.Input<string>;
        /**
         * Required. The value of the header.
         */
        value: pulumi.Input<string>;
    }

    export interface GrpcRouteRuleMatchMethod {
        /**
         * Specifies that matches are case sensitive. The default value is true.
         */
        caseSensitive?: pulumi.Input<boolean>;
        /**
         * Required. Name of the method to match against.
         */
        grpcMethod: pulumi.Input<string>;
        /**
         * Required. Name of the service to match against.
         */
        grpcService: pulumi.Input<string>;
    }

    export interface HttpRouteRule {
        /**
         * The detailed rule defining how to route matched traffic.
         * Structure is documented below.
         */
        action?: pulumi.Input<inputs.networkservices.HttpRouteRuleAction>;
        /**
         * A list of matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied.
         * If no matches field is specified, this rule will unconditionally match traffic.
         * If a default rule is desired to be configured, add a rule with no matches specified to the end of the rules list.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.networkservices.HttpRouteRuleMatch>[]>;
    }

    export interface HttpRouteRuleAction {
        /**
         * The specification for allowing client side cross-origin requests.
         * Structure is documented below.
         */
        corsPolicy?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionCorsPolicy>;
        /**
         * The destination to which traffic should be forwarded.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.networkservices.HttpRouteRuleActionDestination>[]>;
        /**
         * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
         * Structure is documented below.
         */
        faultInjectionPolicy?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionFaultInjectionPolicy>;
        /**
         * If set, the request is directed as configured by this field.
         * Structure is documented below.
         */
        redirect?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionRedirect>;
        /**
         * The specification for modifying the headers of a matching request prior to delivery of the request to the destination.
         * Structure is documented below.
         */
        requestHeaderModifier?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionRequestHeaderModifier>;
        /**
         * Specifies the policy on how requests intended for the routes destination are shadowed to a separate mirrored destination.
         * Structure is documented below.
         */
        requestMirrorPolicy?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionRequestMirrorPolicy>;
        /**
         * The specification for modifying the headers of a response prior to sending the response back to the client.
         * Structure is documented below.
         */
        responseHeaderModifier?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionResponseHeaderModifier>;
        /**
         * Specifies the retry policy associated with this route.
         * Structure is documented below.
         */
        retryPolicy?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionRetryPolicy>;
        /**
         * Specifies the timeout for selected route.
         */
        timeout?: pulumi.Input<string>;
        /**
         * The specification for rewrite URL before forwarding requests to the destination.
         * Structure is documented below.
         */
        urlRewrite?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionUrlRewrite>;
    }

    export interface HttpRouteRuleActionCorsPolicy {
        /**
         * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Specifies the content for Access-Control-Allow-Headers header.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the content for Access-Control-Allow-Methods header.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the regular expression patterns that match allowed origins.
         */
        allowOriginRegexes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the list of origins that will be allowed to do CORS requests.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
         *
         * - - -
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Specifies the content for Access-Control-Expose-Headers header.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies how long result of a preflight request can be cached in seconds.
         */
        maxAge?: pulumi.Input<string>;
    }

    export interface HttpRouteRuleActionDestination {
        /**
         * The URL of a BackendService to route traffic to.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
         * If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
         * If weights are specified for any one service name, they need to be specified for all of them.
         * If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
         */
        weight?: pulumi.Input<number>;
    }

    export interface HttpRouteRuleActionFaultInjectionPolicy {
        /**
         * Specification of how client requests are aborted as part of fault injection before being sent to a destination.
         * Structure is documented below.
         */
        abort?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionFaultInjectionPolicyAbort>;
        /**
         * Specification of how client requests are delayed as part of fault injection before being sent to a destination.
         * Structure is documented below.
         */
        delay?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionFaultInjectionPolicyDelay>;
    }

    export interface HttpRouteRuleActionFaultInjectionPolicyAbort {
        /**
         * The HTTP status code used to abort the request.
         */
        httpStatus?: pulumi.Input<number>;
        /**
         * The percentage of traffic which will be aborted.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface HttpRouteRuleActionFaultInjectionPolicyDelay {
        /**
         * Specify a fixed delay before forwarding the request.
         */
        fixedDelay?: pulumi.Input<string>;
        /**
         * The percentage of traffic on which delay will be injected.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface HttpRouteRuleActionRedirect {
        /**
         * The host that will be used in the redirect response instead of the one that was supplied in the request.
         */
        hostRedirect?: pulumi.Input<string>;
        /**
         * If set to true, the URL scheme in the redirected request is set to https.
         */
        httpsRedirect?: pulumi.Input<boolean>;
        /**
         * The path that will be used in the redirect response instead of the one that was supplied in the request. pathRedirect can not be supplied together with prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
         */
        pathRedirect?: pulumi.Input<string>;
        /**
         * The port that will be used in the redirected request instead of the one that was supplied in the request.
         */
        portRedirect?: pulumi.Input<number>;
        /**
         * Indicates that during redirection, the matched prefix (or path) should be swapped with this value.
         */
        prefixRewrite?: pulumi.Input<string>;
        /**
         * The HTTP Status code to use for the redirect.
         */
        responseCode?: pulumi.Input<string>;
        /**
         * If set to true, any accompanying query portion of the original URL is removed prior to redirecting the request.
         */
        stripQuery?: pulumi.Input<boolean>;
    }

    export interface HttpRouteRuleActionRequestHeaderModifier {
        /**
         * Add the headers with given map where key is the name of the header, value is the value of the header.
         */
        add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Remove headers (matching by header names) specified in the list.
         */
        removes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
         */
        set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface HttpRouteRuleActionRequestMirrorPolicy {
        /**
         * The destination the requests will be mirrored to.
         * Structure is documented below.
         */
        destination?: pulumi.Input<inputs.networkservices.HttpRouteRuleActionRequestMirrorPolicyDestination>;
    }

    export interface HttpRouteRuleActionRequestMirrorPolicyDestination {
        /**
         * The URL of a BackendService to route traffic to.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
         * If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
         * If weights are specified for any one service name, they need to be specified for all of them.
         * If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
         */
        weight?: pulumi.Input<number>;
    }

    export interface HttpRouteRuleActionResponseHeaderModifier {
        /**
         * Add the headers with given map where key is the name of the header, value is the value of the header.
         */
        add?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Remove headers (matching by header names) specified in the list.
         */
        removes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
         */
        set?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface HttpRouteRuleActionRetryPolicy {
        /**
         * Specifies the allowed number of retries.
         */
        numRetries?: pulumi.Input<number>;
        /**
         * Specifies a non-zero timeout per retry attempt. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        perTryTimeout?: pulumi.Input<string>;
        /**
         * Specifies one or more conditions when this retry policy applies.
         */
        retryConditions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface HttpRouteRuleActionUrlRewrite {
        /**
         * Prior to forwarding the request to the selected destination, the requests host header is replaced by this value.
         */
        hostRewrite?: pulumi.Input<string>;
        /**
         * Prior to forwarding the request to the selected destination, the matching portion of the requests path is replaced by this value.
         */
        pathPrefixRewrite?: pulumi.Input<string>;
    }

    export interface HttpRouteRuleMatch {
        /**
         * The HTTP request path value should exactly match this value.
         */
        fullPathMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of HTTP request headers to match against.
         * Structure is documented below.
         */
        headers?: pulumi.Input<pulumi.Input<inputs.networkservices.HttpRouteRuleMatchHeader>[]>;
        /**
         * Specifies if prefixMatch and fullPathMatch matches are case sensitive. The default value is false.
         */
        ignoreCase?: pulumi.Input<boolean>;
        /**
         * The HTTP request path value must begin with specified prefixMatch. prefixMatch must begin with a /.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * Specifies a list of query parameters to match against.
         * Structure is documented below.
         */
        queryParameters?: pulumi.Input<pulumi.Input<inputs.networkservices.HttpRouteRuleMatchQueryParameter>[]>;
        /**
         * The HTTP request path value must satisfy the regular expression specified by regexMatch after removing any query parameters and anchor supplied with the original URL. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface HttpRouteRuleMatchHeader {
        /**
         * The value of the header should match exactly the content of exactMatch.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * The name of the HTTP header to match against.
         */
        header?: pulumi.Input<string>;
        /**
         * If specified, the match result will be inverted before checking. Default value is set to false.
         */
        invertMatch?: pulumi.Input<boolean>;
        /**
         * The value of the header must start with the contents of prefixMatch.
         */
        prefixMatch?: pulumi.Input<string>;
        /**
         * A header with headerName must exist. The match takes place whether or not the header has a value.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * If specified, the rule will match if the request header value is within the range.
         * Structure is documented below.
         */
        rangeMatch?: pulumi.Input<inputs.networkservices.HttpRouteRuleMatchHeaderRangeMatch>;
        /**
         * The value of the header must match the regular expression specified in regexMatch.
         */
        regexMatch?: pulumi.Input<string>;
        /**
         * The value of the header must end with the contents of suffixMatch.
         */
        suffixMatch?: pulumi.Input<string>;
    }

    export interface HttpRouteRuleMatchHeaderRangeMatch {
        /**
         * End of the range (exclusive).
         */
        end: pulumi.Input<number>;
        /**
         * Start of the range (inclusive).
         */
        start: pulumi.Input<number>;
    }

    export interface HttpRouteRuleMatchQueryParameter {
        /**
         * The value of the query parameter must exactly match the contents of exactMatch.
         */
        exactMatch?: pulumi.Input<string>;
        /**
         * Specifies that the QueryParameterMatcher matches if request contains query parameter, irrespective of whether the parameter has a value or not.
         */
        presentMatch?: pulumi.Input<boolean>;
        /**
         * The name of the query parameter to match.
         */
        queryParameter?: pulumi.Input<string>;
        /**
         * The value of the query parameter must match the regular expression specified by regexMatch.For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax
         */
        regexMatch?: pulumi.Input<string>;
    }

    export interface LbRouteExtensionExtensionChain {
        /**
         * A set of extensions to execute for the matching request.
         * At least one extension is required. Up to 3 extensions can be defined for each extension chain for
         * LbTrafficExtension resource. LbRouteExtension chains are limited to 1 extension per extension chain.
         * Structure is documented below.
         */
        extensions: pulumi.Input<pulumi.Input<inputs.networkservices.LbRouteExtensionExtensionChainExtension>[]>;
        /**
         * Conditions under which this chain is invoked for a request.
         * Structure is documented below.
         */
        matchCondition: pulumi.Input<inputs.networkservices.LbRouteExtensionExtensionChainMatchCondition>;
        /**
         * The name for this extension chain. The name is logged as part of the HTTP request logs.
         * The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
         * and can have a maximum length of 63 characters. Additionally, the first character must be a letter
         * and the last character must be a letter or a number.
         */
        name: pulumi.Input<string>;
    }

    export interface LbRouteExtensionExtensionChainExtension {
        /**
         * The :authority header in the gRPC request sent from Envoy to the extension service.
         */
        authority?: pulumi.Input<string>;
        /**
         * Determines how the proxy behaves if the call to the extension fails or times out.
         * When set to TRUE, request or response processing continues without error.
         * Any subsequent extensions in the extension chain are also executed.
         * When set to FALSE: * If response headers have not been delivered to the downstream client,
         * a generic 500 error is returned to the client. The error response can be tailored by
         * configuring a custom error response in the load balancer.
         */
        failOpen?: pulumi.Input<boolean>;
        /**
         * List of the HTTP headers to forward to the extension (from the client or backend).
         * If omitted, all headers are sent. Each element is a string indicating the header name.
         *
         * - - -
         */
        forwardHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name for this extension. The name is logged as part of the HTTP request logs.
         * The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
         * and can have a maximum length of 63 characters. Additionally, the first character must be a letter
         * and the last a letter or a number.
         */
        name: pulumi.Input<string>;
        /**
         * The reference to the service that runs the extension. Must be a reference to a backend service
         */
        service: pulumi.Input<string>;
        /**
         * Specifies the timeout for each individual message on the stream. The timeout must be between 10-1000 milliseconds.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        timeout?: pulumi.Input<string>;
    }

    export interface LbRouteExtensionExtensionChainMatchCondition {
        /**
         * A Common Expression Language (CEL) expression that is used to match requests for which the extension chain is executed.
         */
        celExpression: pulumi.Input<string>;
    }

    export interface LbTrafficExtensionExtensionChain {
        /**
         * A set of extensions to execute for the matching request.
         * At least one extension is required. Up to 3 extensions can be defined for each extension chain for
         * LbTrafficExtension resource. LbRouteExtension chains are limited to 1 extension per extension chain.
         * Further documentation to be found at https://cloud.google.com/service-extensions/docs/reference/rest/v1/ExtensionChain#Extension
         * Structure is documented below.
         */
        extensions: pulumi.Input<pulumi.Input<inputs.networkservices.LbTrafficExtensionExtensionChainExtension>[]>;
        /**
         * Conditions under which this chain is invoked for a request.
         * Structure is documented below.
         */
        matchCondition: pulumi.Input<inputs.networkservices.LbTrafficExtensionExtensionChainMatchCondition>;
        /**
         * The name for this extension chain. The name is logged as part of the HTTP request logs.
         * The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
         * and can have a maximum length of 63 characters. Additionally, the first character must be a letter
         * and the last a letter or a number.
         */
        name: pulumi.Input<string>;
    }

    export interface LbTrafficExtensionExtensionChainExtension {
        /**
         * The :authority header in the gRPC request sent from Envoy to the extension service.
         */
        authority?: pulumi.Input<string>;
        /**
         * Determines how the proxy behaves if the call to the extension fails or times out.
         * When set to TRUE, request or response processing continues without error.
         * Any subsequent extensions in the extension chain are also executed.
         * When set to FALSE: * If response headers have not been delivered to the downstream client,
         * a generic 500 error is returned to the client. The error response can be tailored by
         * configuring a custom error response in the load balancer.
         */
        failOpen?: pulumi.Input<boolean>;
        /**
         * List of the HTTP headers to forward to the extension (from the client or backend).
         * If omitted, all headers are sent. Each element is a string indicating the header name.
         */
        forwardHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Metadata associated with the extension. This field is used to pass metadata to the extension service.
         * You can set up key value pairs for metadata as you like and need.
         * f.e. {"key": "value", "key2": "value2"}.
         *
         * - - -
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The name for this extension. The name is logged as part of the HTTP request logs.
         * The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
         * and can have a maximum length of 63 characters. Additionally, the first character must be a letter
         * and the last a letter or a number.
         */
        name: pulumi.Input<string>;
        /**
         * The reference to the service that runs the extension. Must be a reference to a backend service
         */
        service: pulumi.Input<string>;
        /**
         * A set of events during request or response processing for which this extension is called.
         * This field is required for the LbTrafficExtension resource. It's not relevant for the LbRouteExtension
         * resource. Possible values:`EVENT_TYPE_UNSPECIFIED`, `REQUEST_HEADERS`, `REQUEST_BODY`, `RESPONSE_HEADERS`,
         * `RESPONSE_BODY`, `RESPONSE_BODY` and `RESPONSE_BODY`.
         */
        supportedEvents?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the timeout for each individual message on the stream. The timeout must be between 10-1000 milliseconds.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        timeout?: pulumi.Input<string>;
    }

    export interface LbTrafficExtensionExtensionChainMatchCondition {
        /**
         * A Common Expression Language (CEL) expression that is used to match requests for which the extension chain is executed.
         */
        celExpression: pulumi.Input<string>;
    }

    export interface ServiceLbPoliciesAutoCapacityDrain {
        /**
         * Optional. If set to 'True', an unhealthy MIG/NEG will be set as drained. - An MIG/NEG is considered unhealthy if less than 25% of the instances/endpoints in the MIG/NEG are healthy. - This option will never result in draining more than 50% of the configured IGs/NEGs for the Backend Service.
         */
        enable?: pulumi.Input<boolean>;
    }

    export interface ServiceLbPoliciesFailoverConfig {
        /**
         * Optional. The percentage threshold that a load balancer will begin to send traffic to failover backends. If the percentage of endpoints in a MIG/NEG is smaller than this value, traffic would be sent to failover backends if possible. This field should be set to a value between 1 and 99. The default value is 50 for Global external HTTP(S) load balancer (classic) and Proxyless service mesh, and 70 for others.
         */
        failoverHealthThreshold: pulumi.Input<number>;
    }

    export interface TcpRouteRule {
        /**
         * A detailed rule defining how to route traffic.
         * Structure is documented below.
         */
        action: pulumi.Input<inputs.networkservices.TcpRouteRuleAction>;
        /**
         * RouteMatch defines the predicate used to match requests to a given action. Multiple match types are "OR"ed for evaluation.
         * If no routeMatch field is specified, this rule will unconditionally match traffic.
         * Structure is documented below.
         */
        matches?: pulumi.Input<pulumi.Input<inputs.networkservices.TcpRouteRuleMatch>[]>;
    }

    export interface TcpRouteRuleAction {
        /**
         * The destination services to which traffic should be forwarded. At least one destination service is required.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.networkservices.TcpRouteRuleActionDestination>[]>;
        /**
         * Specifies the idle timeout for the selected route. The idle timeout is defined as the period in which there are no bytes sent or received on either the upstream or downstream connection. If not set, the default idle timeout is 30 seconds. If set to 0s, the timeout will be disabled.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        idleTimeout?: pulumi.Input<string>;
        /**
         * If true, Router will use the destination IP and port of the original connection as the destination of the request.
         */
        originalDestination?: pulumi.Input<boolean>;
    }

    export interface TcpRouteRuleActionDestination {
        /**
         * The URL of a BackendService to route traffic to.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
         * If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
         * If weights are specified for any one service name, they need to be specified for all of them.
         * If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
         *
         * - - -
         */
        weight?: pulumi.Input<number>;
    }

    export interface TcpRouteRuleMatch {
        /**
         * Must be specified in the CIDR range format. A CIDR range consists of an IP Address and a prefix length to construct the subnet mask.
         * By default, the prefix length is 32 (i.e. matches a single IP address). Only IPV4 addresses are supported. Examples: "10.0.0.1" - matches against this exact IP address. "10.0.0.0/8" - matches against any IP address within the 10.0.0.0 subnet and 255.255.255.0 mask. "0.0.0.0/0" - matches against any IP address'.
         */
        address: pulumi.Input<string>;
        /**
         * Specifies the destination port to match against.
         */
        port: pulumi.Input<string>;
    }

    export interface TlsRouteRule {
        /**
         * Required. A detailed rule defining how to route traffic.
         * Structure is documented below.
         */
        action: pulumi.Input<inputs.networkservices.TlsRouteRuleAction>;
        /**
         * Matches define the predicate used to match requests to a given action.
         * Structure is documented below.
         */
        matches: pulumi.Input<pulumi.Input<inputs.networkservices.TlsRouteRuleMatch>[]>;
    }

    export interface TlsRouteRuleAction {
        /**
         * The destination to which traffic should be forwarded.
         * Structure is documented below.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.networkservices.TlsRouteRuleActionDestination>[]>;
    }

    export interface TlsRouteRuleActionDestination {
        /**
         * The URL of a BackendService to route traffic to.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field.
         *
         * - - -
         */
        weight?: pulumi.Input<number>;
    }

    export interface TlsRouteRuleMatch {
        /**
         * ALPN (Application-Layer Protocol Negotiation) to match against. Examples: "http/1.1", "h2". At least one of sniHost and alpn is required. Up to 5 alpns across all matches can be set.
         */
        alpns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * SNI (server name indicator) to match against. SNI will be matched against all wildcard domains, i.e. www.example.com will be first matched against www.example.com, then *.example.com, then *.com.
         * Partial wildcards are not supported, and values like *w.example.com are invalid. At least one of sniHost and alpn is required. Up to 5 sni hosts across all matches can be set.
         */
        sniHosts?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace notebooks {
    export interface EnvironmentContainerImage {
        /**
         * The path to the container image repository.
         * For example: gcr.io/{project_id}/{imageName}
         */
        repository: pulumi.Input<string>;
        /**
         * The tag of the container image. If not specified, this defaults to the latest tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface EnvironmentVmImage {
        /**
         * Use this VM image family to find the image; the newest image in this family will be used.
         */
        imageFamily?: pulumi.Input<string>;
        /**
         * Use VM image name to find the image.
         */
        imageName?: pulumi.Input<string>;
        /**
         * The name of the Google Cloud project that this VM image belongs to.
         * Format: projects/{project_id}
         */
        project: pulumi.Input<string>;
    }

    export interface InstanceAcceleratorConfig {
        /**
         * Count of cores of this accelerator.
         */
        coreCount: pulumi.Input<number>;
        /**
         * Type of this accelerator.
         * Possible values are: `ACCELERATOR_TYPE_UNSPECIFIED`, `NVIDIA_TESLA_K80`, `NVIDIA_TESLA_P100`, `NVIDIA_TESLA_V100`, `NVIDIA_TESLA_P4`, `NVIDIA_TESLA_T4`, `NVIDIA_TESLA_T4_VWS`, `NVIDIA_TESLA_P100_VWS`, `NVIDIA_TESLA_P4_VWS`, `NVIDIA_TESLA_A100`, `TPU_V2`, `TPU_V3`.
         */
        type: pulumi.Input<string>;
    }

    export interface InstanceContainerImage {
        /**
         * The path to the container image repository.
         * For example: gcr.io/{project_id}/{imageName}
         */
        repository: pulumi.Input<string>;
        /**
         * The tag of the container image. If not specified, this defaults to the latest tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface InstanceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceReservationAffinity {
        /**
         * The type of Compute Reservation.
         * Possible values are: `NO_RESERVATION`, `ANY_RESERVATION`, `SPECIFIC_RESERVATION`.
         */
        consumeReservationType: pulumi.Input<string>;
        /**
         * Corresponds to the label key of reservation resource.
         */
        key?: pulumi.Input<string>;
        /**
         * Corresponds to the label values of reservation resource.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceShieldedInstanceConfig {
        /**
         * Defines whether the instance has integrity monitoring enabled. Enables monitoring and attestation of the
         * boot integrity of the instance. The attestation is performed against the integrity policy baseline.
         * This baseline is initially derived from the implicitly trusted boot image when the instance is created.
         * Enabled by default.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines whether the instance has Secure Boot enabled. Secure Boot helps ensure that the system only runs
         * authentic software by verifying the digital signature of all boot components, and halting the boot process
         * if signature verification fails.
         * Disabled by default.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Defines whether the instance has the vTPM enabled.
         * Enabled by default.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceVmImage {
        /**
         * Use this VM image family to find the image; the newest image in this family will be used.
         */
        imageFamily?: pulumi.Input<string>;
        /**
         * Use VM image name to find the image.
         */
        imageName?: pulumi.Input<string>;
        /**
         * The name of the Google Cloud project that this VM image belongs to.
         * Format: projects/{project_id}
         */
        project: pulumi.Input<string>;
    }

    export interface RuntimeAccessConfig {
        /**
         * The type of access mode this instance. For valid values, see
         * `https://cloud.google.com/vertex-ai/docs/workbench/reference/
         * rest/v1/projects.locations.runtimes#RuntimeAccessType`.
         */
        accessType?: pulumi.Input<string>;
        /**
         * (Output)
         * The proxy endpoint that is used to access the runtime.
         */
        proxyUri?: pulumi.Input<string>;
        /**
         * The owner of this runtime after creation. Format: `alias@example.com`.
         * Currently supports one owner only.
         */
        runtimeOwner?: pulumi.Input<string>;
    }

    export interface RuntimeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RuntimeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RuntimeMetric {
        /**
         * (Output)
         * Contains runtime daemon metrics, such as OS and kernels and
         * sessions stats.
         */
        systemMetrics?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RuntimeSoftwareConfig {
        /**
         * Specify a custom Cloud Storage path where the GPU driver is stored.
         * If not specified, we'll automatically choose from official GPU drivers.
         */
        customGpuDriverPath?: pulumi.Input<string>;
        /**
         * Verifies core internal services are running. Default: True.
         */
        enableHealthMonitoring?: pulumi.Input<boolean>;
        /**
         * Runtime will automatically shutdown after idle_shutdown_time.
         * Default: True
         */
        idleShutdown?: pulumi.Input<boolean>;
        /**
         * Time in minutes to wait before shuting down runtime.
         * Default: 180 minutes
         */
        idleShutdownTimeout?: pulumi.Input<number>;
        /**
         * Install Nvidia Driver automatically.
         */
        installGpuDriver?: pulumi.Input<boolean>;
        /**
         * Use a list of container images to use as Kernels in the notebook instance.
         * Structure is documented below.
         */
        kernels?: pulumi.Input<pulumi.Input<inputs.notebooks.RuntimeSoftwareConfigKernel>[]>;
        /**
         * Cron expression in UTC timezone for schedule instance auto upgrade.
         * Please follow the [cron format](https://en.wikipedia.org/wiki/Cron).
         */
        notebookUpgradeSchedule?: pulumi.Input<string>;
        /**
         * Path to a Bash script that automatically runs after a notebook instance
         * fully boots up. The path must be a URL or
         * Cloud Storage path (gs://path-to-file/file-name).
         */
        postStartupScript?: pulumi.Input<string>;
        /**
         * Behavior for the post startup script.
         * Possible values are: `POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED`, `RUN_EVERY_START`, `DOWNLOAD_AND_RUN_EVERY_START`.
         */
        postStartupScriptBehavior?: pulumi.Input<string>;
        /**
         * (Output)
         * Bool indicating whether an newer image is available in an image family.
         */
        upgradeable?: pulumi.Input<boolean>;
    }

    export interface RuntimeSoftwareConfigKernel {
        /**
         * The path to the container image repository.
         * For example: gcr.io/{project_id}/{imageName}
         */
        repository: pulumi.Input<string>;
        /**
         * The tag of the container image. If not specified, this defaults to the latest tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachine {
        /**
         * (Output)
         * The unique identifier of the Managed Compute Engine instance.
         */
        instanceId?: pulumi.Input<string>;
        /**
         * (Output)
         * The user-friendly name of the Managed Compute Engine instance.
         */
        instanceName?: pulumi.Input<string>;
        /**
         * Virtual Machine configuration settings.
         * Structure is documented below.
         */
        virtualMachineConfig?: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfig>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfig {
        /**
         * The Compute Engine accelerator configuration for this runtime.
         * Structure is documented below.
         */
        acceleratorConfig?: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfig>;
        /**
         * Use a list of container images to start the notebook instance.
         * Structure is documented below.
         */
        containerImages?: pulumi.Input<pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigContainerImage>[]>;
        /**
         * Data disk option configuration settings.
         * Structure is documented below.
         */
        dataDisk: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDisk>;
        /**
         * Encryption settings for virtual machine data disk.
         * Structure is documented below.
         */
        encryptionConfig?: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigEncryptionConfig>;
        /**
         * (Output)
         * The Compute Engine guest attributes. (see [Project and instance
         * guest attributes](https://cloud.google.com/compute/docs/
         * storing-retrieving-metadata#guest_attributes)).
         */
        guestAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * If true, runtime will only have internal IP addresses. By default,
         * runtimes are not restricted to internal IP addresses, and will
         * have ephemeral external IP addresses assigned to each vm. This
         * `internalIpOnly` restriction can only be enabled for subnetwork
         * enabled networks, and all dependencies must be configured to be
         * accessible without external IP addresses.
         */
        internalIpOnly?: pulumi.Input<boolean>;
        /**
         * The labels to associate with this runtime. Label **keys** must
         * contain 1 to 63 characters, and must conform to [RFC 1035]
         * (https://www.ietf.org/rfc/rfc1035.txt). Label **values** may be
         * empty, but, if present, must contain 1 to 63 characters, and must
         * conform to [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt). No
         * more than 32 labels can be associated with a cluster.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Compute Engine machine type used for runtimes.
         */
        machineType: pulumi.Input<string>;
        /**
         * The Compute Engine metadata entries to add to virtual machine.
         * (see [Project and instance metadata](https://cloud.google.com
         * /compute/docs/storing-retrieving-metadata#project_and_instance
         * _metadata)).
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The Compute Engine network to be used for machine communications.
         * Cannot be specified with subnetwork. If neither `network` nor
         * `subnet` is specified, the "default" network of the project is
         * used, if it exists. A full URL or partial URI. Examples:
         * * `https://www.googleapis.com/compute/v1/projects/[projectId]/
         * regions/global/default`
         * * `projects/[projectId]/regions/global/default`
         * Runtimes are managed resources inside Google Infrastructure.
         * Runtimes support the following network configurations:
         * * Google Managed Network (Network & subnet are empty)
         * * Consumer Project VPC (network & subnet are required). Requires
         * configuring Private Service Access.
         * * Shared VPC (network & subnet are required). Requires
         * configuring Private Service Access.
         */
        network?: pulumi.Input<string>;
        /**
         * The type of vNIC to be used on this interface. This may be gVNIC
         * or VirtioNet.
         * Possible values are: `UNSPECIFIED_NIC_TYPE`, `VIRTIO_NET`, `GVNIC`.
         */
        nicType?: pulumi.Input<string>;
        /**
         * Reserved IP Range name is used for VPC Peering. The
         * subnetwork allocation will use the range *name* if it's assigned.
         */
        reservedIpRange?: pulumi.Input<string>;
        /**
         * Shielded VM Instance configuration settings.
         * Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfig>;
        /**
         * The Compute Engine subnetwork to be used for machine
         * communications. Cannot be specified with network. A full URL or
         * partial URI are valid. Examples:
         * * `https://www.googleapis.com/compute/v1/projects/[projectId]/
         * regions/us-east1/subnetworks/sub0`
         * * `projects/[projectId]/regions/us-east1/subnetworks/sub0`
         */
        subnet?: pulumi.Input<string>;
        /**
         * The Compute Engine tags to add to runtime (see [Tagging instances]
         * (https://cloud.google.com/compute/docs/
         * label-or-tag-resources#tags)).
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * The zone where the virtual machine is located.
         */
        zone?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfig {
        /**
         * Count of cores of this accelerator.
         */
        coreCount?: pulumi.Input<number>;
        /**
         * Accelerator model. For valid values, see
         * `https://cloud.google.com/vertex-ai/docs/workbench/reference/
         * rest/v1/projects.locations.runtimes#AcceleratorType`
         */
        type?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigContainerImage {
        /**
         * The path to the container image repository.
         * For example: gcr.io/{project_id}/{imageName}
         */
        repository: pulumi.Input<string>;
        /**
         * The tag of the container image. If not specified, this defaults to the latest tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigDataDisk {
        /**
         * (Output)
         * Optional. Specifies whether the disk will be auto-deleted
         * when the instance is deleted (but not when the disk is
         * detached from the instance).
         */
        autoDelete?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Optional. Indicates that this is a boot disk. The virtual
         * machine will use the first partition of the disk for its
         * root filesystem.
         */
        boot?: pulumi.Input<boolean>;
        /**
         * (Output)
         * Optional. Specifies a unique device name of your choice
         * that is reflected into the /dev/disk/by-id/google-* tree
         * of a Linux operating system running within the instance.
         * This name can be used to reference the device for mounting,
         * resizing, and so on, from within the instance.
         * If not specified, the server chooses a default device name
         * to apply to this disk, in the form persistent-disk-x, where
         * x is a number assigned by Google Compute Engine. This field
         * is only applicable for persistent disks.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * (Output)
         * Indicates a list of features to enable on the guest operating
         * system. Applicable only for bootable images. To see a list of
         * available features, read `https://cloud.google.com/compute/docs/
         * images/create-delete-deprecate-private-images#guest-os-features`
         * options. ``
         */
        guestOsFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Output only. A zero-based index to this disk, where 0 is
         * reserved for the boot disk. If you have many disks attached
         * to an instance, each disk would have a unique index number.
         */
        index?: pulumi.Input<number>;
        /**
         * Input only. Specifies the parameters for a new disk that will
         * be created alongside the new instance. Use initialization
         * parameters to create boot disks or local SSDs attached to the
         * new instance. This property is mutually exclusive with the
         * source property; you can only define one or the other, but not
         * both.
         * Structure is documented below.
         */
        initializeParams?: pulumi.Input<inputs.notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams>;
        /**
         * "Specifies the disk interface to use for attaching this disk,
         * which is either SCSI or NVME. The default is SCSI. Persistent
         * disks must always use SCSI and the request will fail if you attempt
         * to attach a persistent disk in any other format than SCSI. Local SSDs
         * can use either NVME or SCSI. For performance characteristics of SCSI
         * over NVMe, see Local SSD performance. Valid values: * NVME * SCSI".
         */
        interface?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the resource. Always compute#attachedDisk for attached
         * disks.
         */
        kind?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Any valid publicly visible licenses.
         */
        licenses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The mode in which to attach this disk, either READ_WRITE
         * or READ_ONLY. If not specified, the default is to attach
         * the disk in READ_WRITE mode.
         */
        mode?: pulumi.Input<string>;
        /**
         * Specifies a valid partial or full URL to an existing
         * Persistent Disk resource.
         */
        source?: pulumi.Input<string>;
        /**
         * Specifies the type of the disk, either SCRATCH or PERSISTENT.
         * If not specified, the default is PERSISTENT.
         */
        type?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams {
        /**
         * Provide this property when creating the disk.
         */
        description?: pulumi.Input<string>;
        /**
         * Specifies the disk name. If not specified, the default is
         * to use the name of the instance. If the disk with the
         * instance name exists already in the given zone/region, a
         * new name will be automatically generated.
         */
        diskName?: pulumi.Input<string>;
        /**
         * Specifies the size of the disk in base-2 GB. If not
         * specified, the disk will be the same size as the image
         * (usually 10GB). If specified, the size must be equal to
         * or larger than 10GB. Default 100 GB.
         */
        diskSizeGb?: pulumi.Input<number>;
        /**
         * The type of the boot disk attached to this runtime,
         * defaults to standard persistent disk. For valid values,
         * see `https://cloud.google.com/vertex-ai/docs/workbench/
         * reference/rest/v1/projects.locations.runtimes#disktype`
         */
        diskType?: pulumi.Input<string>;
        /**
         * Labels to apply to this disk. These can be later modified
         * by the disks.setLabels method. This field is only
         * applicable for persistent disks.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigEncryptionConfig {
        /**
         * The Cloud KMS resource identifier of the customer-managed
         * encryption key used to protect a resource, such as a disks.
         * It has the following format:
         * `projects/{PROJECT_ID}/locations/{REGION}/keyRings/
         * {KEY_RING_NAME}/cryptoKeys/{KEY_NAME}`
         */
        kmsKey?: pulumi.Input<string>;
    }

    export interface RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfig {
        /**
         * Defines whether the instance has integrity monitoring enabled.
         * Enables monitoring and attestation of the boot integrity of
         * the instance. The attestation is performed against the
         * integrity policy baseline. This baseline is initially derived
         * from the implicitly trusted boot image when the instance is
         * created. Enabled by default.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Defines whether the instance has Secure Boot enabled.Secure
         * Boot helps ensure that the system only runs authentic software
         * by verifying the digital signature of all boot components, and
         * halting the boot process if signature verification fails.
         * Disabled by default.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Defines whether the instance has the vTPM enabled. Enabled by
         * default.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }
}

export namespace oracledatabase {
    export interface AutonomousDatabaseProperties {
        /**
         * (Output)
         * The amount of storage currently being used for user and system data, in
         * terabytes.
         */
        actualUsedDataStorageSizeTb?: pulumi.Input<number>;
        /**
         * (Output)
         * The amount of storage currently allocated for the database tables and
         * billed for, rounded up in terabytes.
         */
        allocatedStorageSizeTb?: pulumi.Input<number>;
        /**
         * (Output)
         * Oracle APEX Application Development.
         * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex
         * Structure is documented below.
         */
        apexDetails?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesApexDetail>[]>;
        /**
         * (Output)
         * This field indicates the status of Data Guard and Access control for the
         * Autonomous Database. The field's value is null if Data Guard is disabled
         * or Access Control is disabled. The field's value is TRUE if both Data Guard
         * and Access Control are enabled, and the Autonomous Database is using
         * primary IP access control list (ACL) for standby. The field's value is
         * FALSE if both Data Guard and Access Control are enabled, and the Autonomous
         * Database is using a different IP access control list (ACL) for standby
         * compared to primary.
         */
        arePrimaryAllowlistedIpsUsed?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The Autonomous Container Database OCID.
         */
        autonomousContainerDatabaseId?: pulumi.Input<string>;
        /**
         * (Output)
         * The list of available Oracle Database upgrade versions for an Autonomous
         * Database.
         */
        availableUpgradeVersions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The retention period for the Autonomous Database. This field is specified
         * in days, can range from 1 day to 60 days, and has a default value of
         * 60 days.
         */
        backupRetentionPeriodDays?: pulumi.Input<number>;
        /**
         * The character set for the Autonomous Database. The default is AL32UTF8.
         */
        characterSet?: pulumi.Input<string>;
        /**
         * The number of compute servers for the Autonomous Database.
         */
        computeCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The connection string used to connect to the Autonomous Database.
         * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings
         * Structure is documented below.
         */
        connectionStrings?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesConnectionString>[]>;
        /**
         * (Output)
         * The URLs for accessing Oracle Application Express (APEX) and SQL Developer
         * Web with a browser from a Compute instance.
         * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls
         * Structure is documented below.
         */
        connectionUrls?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesConnectionUrl>[]>;
        /**
         * The list of customer contacts.
         * Structure is documented below.
         */
        customerContacts?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesCustomerContact>[]>;
        /**
         * (Output)
         * The current state of the Data Safe registration for the
         * Autonomous Database.
         * Possible values:
         * DATA_SAFE_STATE_UNSPECIFIED
         * REGISTERING
         * REGISTERED
         * DEREGISTERING
         * NOT_REGISTERED
         * FAILED
         */
        dataSafeState?: pulumi.Input<string>;
        /**
         * The size of the data stored in the database, in gigabytes.
         */
        dataStorageSizeGb?: pulumi.Input<number>;
        /**
         * The size of the data stored in the database, in terabytes.
         */
        dataStorageSizeTb?: pulumi.Input<number>;
        /**
         * (Output)
         * The current state of database management for the Autonomous Database.
         * Possible values:
         * DATABASE_MANAGEMENT_STATE_UNSPECIFIED
         * ENABLING
         * ENABLED
         * DISABLING
         * NOT_ENABLED
         * FAILED_ENABLING
         * FAILED_DISABLING
         */
        databaseManagementState?: pulumi.Input<string>;
        /**
         * The edition of the Autonomous Databases.
         * Possible values:
         * DATABASE_EDITION_UNSPECIFIED
         * STANDARD_EDITION
         * ENTERPRISE_EDITION
         */
        dbEdition?: pulumi.Input<string>;
        /**
         * The Oracle Database version for the Autonomous Database.
         */
        dbVersion?: pulumi.Input<string>;
        /**
         * Possible values:
         * DB_WORKLOAD_UNSPECIFIED
         * OLTP
         * DW
         * AJD
         * APEX
         */
        dbWorkload: pulumi.Input<string>;
        /**
         * (Output)
         * This field indicates the number of seconds of data loss during a Data
         * Guard failover.
         */
        failedDataRecoveryDuration?: pulumi.Input<string>;
        /**
         * This field indicates if auto scaling is enabled for the Autonomous Database
         * CPU core count.
         */
        isAutoScalingEnabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * This field indicates whether the Autonomous Database has local (in-region)
         * Data Guard enabled.
         */
        isLocalDataGuardEnabled?: pulumi.Input<boolean>;
        /**
         * This field indicates if auto scaling is enabled for the Autonomous Database
         * storage.
         */
        isStorageAutoScalingEnabled?: pulumi.Input<boolean>;
        /**
         * The license type used for the Autonomous Database.
         * Possible values:
         * LICENSE_TYPE_UNSPECIFIED
         * LICENSE_INCLUDED
         * BRING_YOUR_OWN_LICENSE
         */
        licenseType: pulumi.Input<string>;
        /**
         * (Output)
         * The details of the current lifestyle state of the Autonomous Database.
         */
        lifecycleDetails?: pulumi.Input<string>;
        /**
         * (Output)
         * This field indicates the maximum data loss limit for an Autonomous
         * Database, in seconds.
         */
        localAdgAutoFailoverMaxDataLossLimit?: pulumi.Input<number>;
        /**
         * (Output)
         * This field indicates the local disaster recovery (DR) type of an
         * Autonomous Database.
         * Possible values:
         * LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED
         * ADG
         * BACKUP_BASED
         */
        localDisasterRecoveryType?: pulumi.Input<string>;
        /**
         * (Output)
         * Autonomous Data Guard standby database details.
         * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary
         * Structure is documented below.
         */
        localStandbyDbs?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesLocalStandbyDb>[]>;
        /**
         * (Output)
         * The date and time when maintenance will begin.
         */
        maintenanceBeginTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The date and time when maintenance will end.
         */
        maintenanceEndTime?: pulumi.Input<string>;
        /**
         * The maintenance schedule of the Autonomous Database.
         * Possible values:
         * MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED
         * EARLY
         * REGULAR
         */
        maintenanceScheduleType?: pulumi.Input<string>;
        /**
         * (Output)
         * The amount of memory enabled per ECPU, in gigabytes.
         */
        memoryPerOracleComputeUnitGbs?: pulumi.Input<number>;
        /**
         * (Output)
         * The memory assigned to in-memory tables in an Autonomous Database.
         */
        memoryTableGbs?: pulumi.Input<number>;
        /**
         * This field specifies if the Autonomous Database requires mTLS connections.
         */
        mtlsConnectionRequired?: pulumi.Input<boolean>;
        /**
         * The national character set for the Autonomous Database. The default is
         * AL16UTF16.
         */
        nCharacterSet?: pulumi.Input<string>;
        /**
         * (Output)
         * The long term backup schedule of the Autonomous Database.
         */
        nextLongTermBackupTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The Oracle Cloud Infrastructure link for the Autonomous Database.
         */
        ociUrl?: pulumi.Input<string>;
        /**
         * (Output)
         * OCID of the Autonomous Database.
         * https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle
         */
        ocid?: pulumi.Input<string>;
        /**
         * (Output)
         * This field indicates the current mode of the Autonomous Database.
         * Possible values:
         * OPEN_MODE_UNSPECIFIED
         * READ_ONLY
         * READ_WRITE
         */
        openMode?: pulumi.Input<string>;
        /**
         * Possible values:
         * OPERATIONS_INSIGHTS_STATE_UNSPECIFIED
         * ENABLING
         * ENABLED
         * DISABLING
         * NOT_ENABLED
         * FAILED_ENABLING
         * FAILED_DISABLING
         */
        operationsInsightsState?: pulumi.Input<string>;
        /**
         * (Output)
         * The list of OCIDs of standby databases located in Autonomous Data Guard
         * remote regions that are associated with the source database.
         */
        peerDbIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * The permission level of the Autonomous Database.
         * Possible values:
         * PERMISSION_LEVEL_UNSPECIFIED
         * RESTRICTED
         * UNRESTRICTED
         */
        permissionLevel?: pulumi.Input<string>;
        /**
         * (Output)
         * The private endpoint for the Autonomous Database.
         */
        privateEndpoint?: pulumi.Input<string>;
        /**
         * The private endpoint IP address for the Autonomous Database.
         */
        privateEndpointIp?: pulumi.Input<string>;
        /**
         * The private endpoint label for the Autonomous Database.
         */
        privateEndpointLabel?: pulumi.Input<string>;
        /**
         * (Output)
         * The refresh mode of the cloned Autonomous Database.
         * Possible values:
         * REFRESHABLE_MODE_UNSPECIFIED
         * AUTOMATIC
         * MANUAL
         */
        refreshableMode?: pulumi.Input<string>;
        /**
         * (Output)
         * The refresh State of the clone.
         * Possible values:
         * REFRESHABLE_STATE_UNSPECIFIED
         * REFRESHING
         * NOT_REFRESHING
         */
        refreshableState?: pulumi.Input<string>;
        /**
         * (Output)
         * The Data Guard role of the Autonomous Database.
         * Possible values:
         * ROLE_UNSPECIFIED
         * PRIMARY
         * STANDBY
         * DISABLED_STANDBY
         * BACKUP_COPY
         * SNAPSHOT_STANDBY
         */
        role?: pulumi.Input<string>;
        /**
         * (Output)
         * The list and details of the scheduled operations of the Autonomous
         * Database.
         * Structure is documented below.
         */
        scheduledOperationDetails?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesScheduledOperationDetail>[]>;
        /**
         * (Output)
         * The SQL Web Developer URL for the Autonomous Database.
         */
        sqlWebDeveloperUrl?: pulumi.Input<string>;
        /**
         * (Output)
         * Possible values:
         * STATE_UNSPECIFIED
         * PROVISIONING
         * AVAILABLE
         * STOPPING
         * STOPPED
         * STARTING
         * TERMINATING
         * TERMINATED
         * UNAVAILABLE
         * RESTORE_IN_PROGRESS
         * RESTORE_FAILED
         * BACKUP_IN_PROGRESS
         * SCALE_IN_PROGRESS
         * AVAILABLE_NEEDS_ATTENTION
         * UPDATING
         * MAINTENANCE_IN_PROGRESS
         * RESTARTING
         * RECREATING
         * ROLE_CHANGE_IN_PROGRESS
         * UPGRADING
         * INACCESSIBLE
         * STANDBY
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * The list of available regions that can be used to create a clone for the
         * Autonomous Database.
         */
        supportedCloneRegions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * The storage space used by automatic backups of Autonomous Database, in
         * gigabytes.
         */
        totalAutoBackupStorageSizeGbs?: pulumi.Input<number>;
        /**
         * (Output)
         * The storage space used by Autonomous Database, in gigabytes.
         */
        usedDataStorageSizeTbs?: pulumi.Input<number>;
    }

    export interface AutonomousDatabasePropertiesApexDetail {
        /**
         * The Oracle APEX Application Development version.
         */
        apexVersion?: pulumi.Input<string>;
        /**
         * The Oracle REST Data Services (ORDS) version.
         */
        ordsVersion?: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesConnectionString {
        /**
         * A list of all connection strings that can be used to connect to the
         * Autonomous Database.
         */
        allConnectionStrings?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesConnectionStringAllConnectionString>[]>;
        /**
         * The database service provides the least level of resources to each SQL
         * statement, but supports the most number of concurrent SQL statements.
         */
        dedicated?: pulumi.Input<string>;
        /**
         * The database service provides the highest level of resources to each SQL
         * statement.
         */
        high?: pulumi.Input<string>;
        /**
         * The database service provides the least level of resources to each SQL
         * statement.
         */
        low?: pulumi.Input<string>;
        /**
         * The database service provides a lower level of resources to each SQL
         * statement.
         */
        medium?: pulumi.Input<string>;
        /**
         * A list of connection string profiles to allow clients to group, filter, and
         * select values based on the structured metadata.
         */
        profiles?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesConnectionStringProfile>[]>;
    }

    export interface AutonomousDatabasePropertiesConnectionStringAllConnectionString {
        /**
         * The database service provides the highest level of resources to each SQL
         * statement.
         */
        high?: pulumi.Input<string>;
        /**
         * The database service provides the least level of resources to each SQL
         * statement.
         */
        low?: pulumi.Input<string>;
        /**
         * The database service provides a lower level of resources to each SQL
         * statement.
         */
        medium?: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesConnectionStringProfile {
        /**
         * The current consumer group being used by the connection. 
         *  Possible values:
         *  CONSUMER_GROUP_UNSPECIFIED
         * HIGH
         * MEDIUM
         * LOW
         * TP
         * TPURGENT
         */
        consumerGroup?: pulumi.Input<string>;
        /**
         * The display name for the database connection.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The host name format being currently used in connection string. 
         *  Possible values:
         *  HOST_FORMAT_UNSPECIFIED
         * FQDN
         * IP
         */
        hostFormat?: pulumi.Input<string>;
        /**
         * This field indicates if the connection string is regional and is only
         * applicable for cross-region Data Guard.
         */
        isRegional?: pulumi.Input<boolean>;
        /**
         * The protocol being used by the connection. 
         *  Possible values:
         *  PROTOCOL_UNSPECIFIED
         * TCP
         * TCPS
         */
        protocol?: pulumi.Input<string>;
        /**
         * The current session mode of the connection. 
         *  Possible values:
         *  SESSION_MODE_UNSPECIFIED
         * DIRECT
         * INDIRECT
         */
        sessionMode?: pulumi.Input<string>;
        /**
         * The syntax of the connection string. 
         *  Possible values:
         *  SYNTAX_FORMAT_UNSPECIFIED
         * LONG
         * EZCONNECT
         * EZCONNECTPLUS
         */
        syntaxFormat?: pulumi.Input<string>;
        /**
         * This field indicates the TLS authentication type of the connection. 
         *  Possible values:
         *  TLS_AUTHENTICATION_UNSPECIFIED
         * SERVER
         * MUTUAL
         */
        tlsAuthentication?: pulumi.Input<string>;
        /**
         * The value of the connection string.
         */
        value?: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesConnectionUrl {
        /**
         * Oracle Application Express (APEX) URL.
         */
        apexUri?: pulumi.Input<string>;
        /**
         * The URL of the Database Transforms for the Autonomous Database.
         */
        databaseTransformsUri?: pulumi.Input<string>;
        /**
         * The URL of the Graph Studio for the Autonomous Database.
         */
        graphStudioUri?: pulumi.Input<string>;
        /**
         * The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous
         * Database.
         */
        machineLearningNotebookUri?: pulumi.Input<string>;
        /**
         * The URL of Machine Learning user management the Autonomous Database.
         */
        machineLearningUserManagementUri?: pulumi.Input<string>;
        /**
         * The URL of the MongoDB API for the Autonomous Database.
         */
        mongoDbUri?: pulumi.Input<string>;
        /**
         * The Oracle REST Data Services (ORDS) URL of the Web Access for the
         * Autonomous Database.
         */
        ordsUri?: pulumi.Input<string>;
        /**
         * The URL of the Oracle SQL Developer Web for the Autonomous Database.
         */
        sqlDevWebUri?: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesCustomerContact {
        /**
         * The email address used by Oracle to send notifications regarding databases
         * and infrastructure.
         *
         * <a name="nestedPropertiesApexDetails"></a>The `apexDetails` block contains:
         */
        email: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesLocalStandbyDb {
        /**
         * The date and time the Autonomous Data Guard role was switched for the
         * standby Autonomous Database.
         */
        dataGuardRoleChangedTime?: pulumi.Input<string>;
        /**
         * The date and time the Disaster Recovery role was switched for the standby
         * Autonomous Database.
         */
        disasterRecoveryRoleChangedTime?: pulumi.Input<string>;
        /**
         * The amount of time, in seconds, that the data of the standby database lags
         * in comparison to the data of the primary database.
         */
        lagTimeDuration?: pulumi.Input<string>;
        /**
         * The additional details about the current lifecycle state of the
         * Autonomous Database.
         */
        lifecycleDetails?: pulumi.Input<string>;
        /**
         * Possible values:
         *  STATE_UNSPECIFIED
         * PROVISIONING
         * AVAILABLE
         * STOPPING
         * STOPPED
         * STARTING
         * TERMINATING
         * TERMINATED
         * UNAVAILABLE
         * RESTORE_IN_PROGRESS
         * RESTORE_FAILED
         * BACKUP_IN_PROGRESS
         * SCALE_IN_PROGRESS
         * AVAILABLE_NEEDS_ATTENTION
         * UPDATING
         * MAINTENANCE_IN_PROGRESS
         * RESTARTING
         * RECREATING
         * ROLE_CHANGE_IN_PROGRESS
         * UPGRADING
         * INACCESSIBLE
         * STANDBY
         */
        state?: pulumi.Input<string>;
    }

    export interface AutonomousDatabasePropertiesScheduledOperationDetail {
        /**
         * Possible values:
         *  DAY_OF_WEEK_UNSPECIFIED
         * MONDAY
         * TUESDAY
         * WEDNESDAY
         * THURSDAY
         * FRIDAY
         * SATURDAY
         * SUNDAY
         */
        dayOfWeek?: pulumi.Input<string>;
        /**
         * Represents a time of day. The date and time zone are either not significant
         * or are specified elsewhere. An API may choose to allow leap seconds. Related
         * types are google.type.Date and 'google.protobuf.Timestamp'.
         */
        startTimes?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesScheduledOperationDetailStartTime>[]>;
        /**
         * Represents a time of day. The date and time zone are either not significant
         * or are specified elsewhere. An API may choose to allow leap seconds. Related
         * types are google.type.Date and 'google.protobuf.Timestamp'.
         */
        stopTimes?: pulumi.Input<pulumi.Input<inputs.oracledatabase.AutonomousDatabasePropertiesScheduledOperationDetailStopTime>[]>;
    }

    export interface AutonomousDatabasePropertiesScheduledOperationDetailStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
         * to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may
         * allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface AutonomousDatabasePropertiesScheduledOperationDetailStopTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
         * to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may
         * allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface CloudExadataInfrastructureProperties {
        /**
         * (Output)
         * The requested number of additional storage servers activated for the
         * Exadata Infrastructure.
         */
        activatedStorageCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The requested number of additional storage servers for the Exadata
         * Infrastructure.
         */
        additionalStorageCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The available storage can be allocated to the Exadata Infrastructure
         * resource, in gigabytes (GB).
         */
        availableStorageSizeGb?: pulumi.Input<number>;
        /**
         * The number of compute servers for the Exadata Infrastructure.
         */
        computeCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The number of enabled CPU cores.
         */
        cpuCount?: pulumi.Input<number>;
        /**
         * The list of customer contacts.
         * Structure is documented below.
         */
        customerContacts?: pulumi.Input<pulumi.Input<inputs.oracledatabase.CloudExadataInfrastructurePropertiesCustomerContact>[]>;
        /**
         * (Output)
         * Size, in terabytes, of the DATA disk group.
         */
        dataStorageSizeTb?: pulumi.Input<number>;
        /**
         * (Output)
         * The local node storage allocated in GBs.
         */
        dbNodeStorageSizeGb?: pulumi.Input<number>;
        /**
         * (Output)
         * The software version of the database servers (dom0) in the Exadata
         * Infrastructure.
         */
        dbServerVersion?: pulumi.Input<string>;
        /**
         * Maintenance window as defined by Oracle.
         * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow
         * Structure is documented below.
         */
        maintenanceWindow?: pulumi.Input<inputs.oracledatabase.CloudExadataInfrastructurePropertiesMaintenanceWindow>;
        /**
         * (Output)
         * The total number of CPU cores available.
         */
        maxCpuCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The total available DATA disk group size.
         */
        maxDataStorageTb?: pulumi.Input<number>;
        /**
         * (Output)
         * The total local node storage available in GBs.
         */
        maxDbNodeStorageSizeGb?: pulumi.Input<number>;
        /**
         * (Output)
         * The total memory available in GBs.
         */
        maxMemoryGb?: pulumi.Input<number>;
        /**
         * (Output)
         * The memory allocated in GBs.
         */
        memorySizeGb?: pulumi.Input<number>;
        /**
         * (Output)
         * The monthly software version of the database servers (dom0)
         * in the Exadata Infrastructure. Example: 20.1.15
         */
        monthlyDbServerVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * The monthly software version of the storage servers (cells)
         * in the Exadata Infrastructure. Example: 20.1.15
         */
        monthlyStorageServerVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * The OCID of the next maintenance run.
         */
        nextMaintenanceRunId?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the next maintenance run will occur.
         */
        nextMaintenanceRunTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the next security maintenance run will occur.
         */
        nextSecurityMaintenanceRunTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Deep link to the OCI console to view this resource.
         */
        ociUrl?: pulumi.Input<string>;
        /**
         * (Output)
         * OCID of created infra.
         * https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle
         */
        ocid?: pulumi.Input<string>;
        /**
         * The shape of the Exadata Infrastructure. The shape determines the
         * amount of CPU, storage, and memory resources allocated to the instance.
         */
        shape: pulumi.Input<string>;
        /**
         * (Output)
         * The current lifecycle state of the Exadata Infrastructure.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROVISIONING
         * AVAILABLE
         * UPDATING
         * TERMINATING
         * TERMINATED
         * FAILED
         * MAINTENANCE_IN_PROGRESS
         */
        state?: pulumi.Input<string>;
        /**
         * The number of Cloud Exadata storage servers for the Exadata Infrastructure.
         */
        storageCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The software version of the storage servers (cells) in the Exadata
         * Infrastructure.
         */
        storageServerVersion?: pulumi.Input<string>;
        /**
         * The total storage allocated to the Exadata Infrastructure
         * resource, in gigabytes (GB).
         */
        totalStorageSizeGb?: pulumi.Input<number>;
    }

    export interface CloudExadataInfrastructurePropertiesCustomerContact {
        /**
         * The email address used by Oracle to send notifications regarding databases
         * and infrastructure.
         */
        email: pulumi.Input<string>;
    }

    export interface CloudExadataInfrastructurePropertiesMaintenanceWindow {
        /**
         * Determines the amount of time the system will wait before the start of each
         * database server patching operation. Custom action timeout is in minutes and
         * valid value is between 15 to 120 (inclusive).
         */
        customActionTimeoutMins?: pulumi.Input<number>;
        /**
         * Days during the week when maintenance should be performed.
         */
        daysOfWeeks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The window of hours during the day when maintenance should be performed.
         * The window is a 4 hour slot. Valid values are:
         * 0 - represents time slot 0:00 - 3:59 UTC
         * 4 - represents time slot 4:00 - 7:59 UTC
         * 8 - represents time slot 8:00 - 11:59 UTC
         * 12 - represents time slot 12:00 - 15:59 UTC
         * 16 - represents time slot 16:00 - 19:59 UTC
         * 20 - represents time slot 20:00 - 23:59 UTC
         */
        hoursOfDays?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * If true, enables the configuration of a custom action timeout (waiting
         * period) between database server patching operations.
         */
        isCustomActionTimeoutEnabled?: pulumi.Input<boolean>;
        /**
         * Lead time window allows user to set a lead time to prepare for a down time.
         * The lead time is in weeks and valid value is between 1 to 4.
         */
        leadTimeWeek?: pulumi.Input<number>;
        /**
         * Months during the year when maintenance should be performed.
         */
        months?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Cloud CloudExadataInfrastructure node patching method, either "ROLLING"
         * or "NONROLLING". Default value is ROLLING.
         * Possible values:
         * PATCHING_MODE_UNSPECIFIED
         * ROLLING
         * NON_ROLLING
         */
        patchingMode?: pulumi.Input<string>;
        /**
         * The maintenance window scheduling preference.
         * Possible values:
         * MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED
         * CUSTOM_PREFERENCE
         * NO_PREFERENCE
         */
        preference?: pulumi.Input<string>;
        /**
         * Weeks during the month when maintenance should be performed. Weeks start on
         * the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7
         * days. Weeks start and end based on calendar dates, not days of the week.
         */
        weeksOfMonths?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface CloudVmClusterProperties {
        /**
         * OCI Cluster name.
         */
        clusterName?: pulumi.Input<string>;
        /**
         * (Output)
         * Compartment ID of cluster.
         */
        compartmentId?: pulumi.Input<string>;
        /**
         * Number of enabled CPU cores.
         */
        cpuCoreCount: pulumi.Input<number>;
        /**
         * The data disk group size to be allocated in TBs.
         */
        dataStorageSizeTb?: pulumi.Input<number>;
        /**
         * Local storage per VM
         */
        dbNodeStorageSizeGb?: pulumi.Input<number>;
        /**
         * OCID of database servers.
         */
        dbServerOcids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Data collection options for diagnostics.
         * Structure is documented below.
         */
        diagnosticsDataCollectionOptions?: pulumi.Input<inputs.oracledatabase.CloudVmClusterPropertiesDiagnosticsDataCollectionOptions>;
        /**
         * The type of redundancy.
         * Possible values:
         * DISK_REDUNDANCY_UNSPECIFIED
         * HIGH
         * NORMAL
         */
        diskRedundancy?: pulumi.Input<string>;
        /**
         * (Output)
         * DNS listener IP.
         */
        dnsListenerIp?: pulumi.Input<string>;
        /**
         * (Output)
         * Parent DNS domain where SCAN DNS and hosts names are qualified.
         * ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
         */
        domain?: pulumi.Input<string>;
        /**
         * Grid Infrastructure Version.
         */
        giVersion?: pulumi.Input<string>;
        /**
         * (Output)
         * host name without domain.
         * format: "-" with some suffix.
         * ex: sp2-yi0xq where "sp2" is the hostname_prefix.
         */
        hostname?: pulumi.Input<string>;
        /**
         * Prefix for VM cluster host names.
         */
        hostnamePrefix?: pulumi.Input<string>;
        /**
         * License type of VM Cluster.
         * Possible values:
         * LICENSE_TYPE_UNSPECIFIED
         * LICENSE_INCLUDED
         * BRING_YOUR_OWN_LICENSE
         */
        licenseType: pulumi.Input<string>;
        /**
         * Use local backup.
         */
        localBackupEnabled?: pulumi.Input<boolean>;
        /**
         * Memory allocated in GBs.
         */
        memorySizeGb?: pulumi.Input<number>;
        /**
         * Number of database servers.
         */
        nodeCount?: pulumi.Input<number>;
        /**
         * (Output)
         * Deep link to the OCI console to view this resource.
         */
        ociUrl?: pulumi.Input<string>;
        /**
         * (Output)
         * Oracle Cloud Infrastructure ID of VM Cluster.
         */
        ocid?: pulumi.Input<string>;
        /**
         * OCPU count per VM. Minimum is 0.1.
         */
        ocpuCount?: pulumi.Input<number>;
        /**
         * (Output)
         * SCAN DNS name.
         * ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
         */
        scanDns?: pulumi.Input<string>;
        /**
         * (Output)
         * OCID of scan DNS record.
         */
        scanDnsRecordId?: pulumi.Input<string>;
        /**
         * (Output)
         * OCIDs of scan IPs.
         */
        scanIpIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * SCAN listener port - TCP
         */
        scanListenerPortTcp?: pulumi.Input<number>;
        /**
         * (Output)
         * SCAN listener port - TLS
         */
        scanListenerPortTcpSsl?: pulumi.Input<number>;
        /**
         * (Output)
         * Shape of VM Cluster.
         */
        shape?: pulumi.Input<string>;
        /**
         * Use exadata sparse snapshots.
         */
        sparseDiskgroupEnabled?: pulumi.Input<boolean>;
        /**
         * SSH public keys to be stored with cluster.
         */
        sshPublicKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * State of the cluster.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROVISIONING
         * AVAILABLE
         * UPDATING
         * TERMINATING
         * TERMINATED
         * FAILED
         * MAINTENANCE_IN_PROGRESS
         */
        state?: pulumi.Input<string>;
        /**
         * (Output)
         * The storage allocation for the disk group, in gigabytes (GB).
         */
        storageSizeGb?: pulumi.Input<number>;
        /**
         * (Output)
         * Operating system version of the image.
         */
        systemVersion?: pulumi.Input<string>;
        /**
         * Represents a time zone from the
         * [IANA Time Zone Database](https://www.iana.org/time-zones).
         * Structure is documented below.
         */
        timeZone?: pulumi.Input<inputs.oracledatabase.CloudVmClusterPropertiesTimeZone>;
    }

    export interface CloudVmClusterPropertiesDiagnosticsDataCollectionOptions {
        /**
         * Indicates whether diagnostic collection is enabled for the VM cluster
         */
        diagnosticsEventsEnabled?: pulumi.Input<boolean>;
        /**
         * Indicates whether health monitoring is enabled for the VM cluster
         */
        healthMonitoringEnabled?: pulumi.Input<boolean>;
        /**
         * Indicates whether incident logs and trace collection are enabled for the VM
         * cluster
         */
        incidentLogsEnabled?: pulumi.Input<boolean>;
    }

    export interface CloudVmClusterPropertiesTimeZone {
        /**
         * IANA Time Zone Database time zone, e.g. "America/New_York".
         */
        id?: pulumi.Input<string>;
    }

}

export namespace organizations {
    export interface AccessApprovalSettingsEnrolledService {
        /**
         * The product for which Access Approval will be enrolled. Allowed values are listed (case-sensitive):
         * all
         * appengine.googleapis.com
         * bigquery.googleapis.com
         * bigtable.googleapis.com
         * cloudkms.googleapis.com
         * compute.googleapis.com
         * dataflow.googleapis.com
         * iam.googleapis.com
         * pubsub.googleapis.com
         * storage.googleapis.com
         */
        cloudProduct: pulumi.Input<string>;
        /**
         * The enrollment level of the service.
         * Default value is `BLOCK_ALL`.
         * Possible values are: `BLOCK_ALL`.
         *
         * - - -
         */
        enrollmentLevel?: pulumi.Input<string>;
    }

    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: inputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigArgs {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: pulumi.Input<pulumi.Input<inputs.organizations.GetIAMPolicyAuditConfigAuditLogConfigArgs>[]>;
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: pulumi.Input<string>;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfigArgs {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: pulumi.Input<string>;
    }

    export interface GetIAMPolicyBinding {
        /**
         * An [IAM Condition](https://cloud.google.com/iam/docs/conditions-overview) for a given binding. Structure is documented below.
         */
        condition?: inputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. Some resources **don't** support this identity.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. Some resources **don't** support this identity.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingArgs {
        /**
         * An [IAM Condition](https://cloud.google.com/iam/docs/conditions-overview) for a given binding. Structure is documented below.
         */
        condition?: pulumi.Input<inputs.organizations.GetIAMPolicyBindingConditionArgs>;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. Some resources **don't** support this identity.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. Some resources **don't** support this identity.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: pulumi.Input<string>;
    }

    export interface GetIAMPolicyBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface GetIAMPolicyBindingConditionArgs {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IamAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.
         * Each entry can have one of the following values:
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: pulumi.Input<string>;
    }

    export interface PolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface PolicyListPolicy {
        /**
         * or `deny` - (Optional) One or the other must be set.
         */
        allow?: pulumi.Input<inputs.organizations.PolicyListPolicyAllow>;
        /**
         * One or the other must be set.
         */
        deny?: pulumi.Input<inputs.organizations.PolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         *
         * The `allow` or `deny` blocks support:
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface PolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace orgpolicy {
    export interface PolicyDryRunSpec {
        /**
         * (Output)
         * An opaque tag indicating the current version of the policy, used for concurrency control. This field is ignored if used in a `CreatePolicy` request. When the policy` is returned from either a `GetPolicy` or a `ListPolicies` request, this `etag` indicates the version of the current policy to use when executing a read-modify-write loop. When the policy is returned from a `GetEffectivePolicy` request, the `etag` will be unset.
         */
        etag?: pulumi.Input<string>;
        /**
         * Determines the inheritance behavior for this policy. If `inheritFromParent` is true, policy rules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this policy becomes the new root for evaluation. This field can be set only for policies which configure list constraints.
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * Ignores policies set above this resource and restores the `constraintDefault` enforcement behavior of the specific constraint at this resource. This field can be set in policies for either list or boolean constraints. If set, `rules` must be empty and `inheritFromParent` must be set to false.
         */
        reset?: pulumi.Input<boolean>;
        /**
         * In policies for boolean constraints, the following requirements apply: - There must be one and only one policy rule where condition is unset. - Boolean policy rules with conditions must set `enforced` to the opposite of the policy rule without a condition. - During policy evaluation, policy rules with conditions that are true for a target resource take precedence.
         * Structure is documented below.
         */
        rules?: pulumi.Input<pulumi.Input<inputs.orgpolicy.PolicyDryRunSpecRule>[]>;
        /**
         * (Output)
         * Output only. The time stamp this was previously updated. This represents the last time a call to `CreatePolicy` or `UpdatePolicy` was made for that policy.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface PolicyDryRunSpecRule {
        /**
         * Setting this to `"TRUE"` means that all values are allowed. This field can be set only in Policies for list constraints.
         */
        allowAll?: pulumi.Input<string>;
        /**
         * A condition which determines whether this rule is used in the evaluation of the policy. When set, the `expression` field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where keyName and valueName are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.orgpolicy.PolicyDryRunSpecRuleCondition>;
        /**
         * Setting this to `"TRUE"` means that all values are denied. This field can be set only in Policies for list constraints.
         */
        denyAll?: pulumi.Input<string>;
        /**
         * If `"TRUE"`, then the `Policy` is enforced. If `"FALSE"`, then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
         */
        enforce?: pulumi.Input<string>;
        /**
         * Optional. Required for Managed Constraints if parameters defined in constraints. Pass parameter values when policy enforcement is enabled. Ensure that parameter value types match those defined in the constraint definition. For example: { \"allowedLocations\" : [\"us-east1\", \"us-west1\"], \"allowAll\" : true }
         */
        parameters?: pulumi.Input<string>;
        /**
         * List of values to be used for this policy rule. This field can be set only in policies for list constraints.
         * Structure is documented below.
         */
        values?: pulumi.Input<inputs.orgpolicy.PolicyDryRunSpecRuleValues>;
    }

    export interface PolicyDryRunSpecRuleCondition {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface PolicyDryRunSpecRuleValues {
        /**
         * List of values allowed at this resource.
         */
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of values denied at this resource.
         */
        deniedValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicySpec {
        /**
         * (Output)
         * An opaque tag indicating the current version of the `Policy`, used for concurrency control. This field is ignored if used in a `CreatePolicy` request. When the `Policy` is returned from either a `GetPolicy` or a `ListPolicies` request, this `etag` indicates the version of the current `Policy` to use when executing a read-modify-write loop. When the `Policy` is returned from a `GetEffectivePolicy` request, the `etag` will be unset.
         */
        etag?: pulumi.Input<string>;
        /**
         * Determines the inheritance behavior for this `Policy`. If `inheritFromParent` is true, PolicyRules set higher up in the hierarchy (up to the closest root) are inherited and present in the effective policy. If it is false, then no rules are inherited, and this Policy becomes the new root for evaluation. This field can be set only for Policies which configure list constraints.
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * Ignores policies set above this resource and restores the `constraintDefault` enforcement behavior of the specific `Constraint` at this resource. This field can be set in policies for either list or boolean constraints. If set, `rules` must be empty and `inheritFromParent` must be set to false.
         */
        reset?: pulumi.Input<boolean>;
        /**
         * In Policies for boolean constraints, the following requirements apply: - There must be one and only one PolicyRule where condition is unset. - BooleanPolicyRules with conditions must set `enforced` to the opposite of the PolicyRule without a condition. - During policy evaluation, PolicyRules with conditions that are true for a target resource take precedence.
         * Structure is documented below.
         */
        rules?: pulumi.Input<pulumi.Input<inputs.orgpolicy.PolicySpecRule>[]>;
        /**
         * (Output)
         * Output only. The time stamp this was previously updated. This represents the last time a call to `CreatePolicy` or `UpdatePolicy` was made for that `Policy`.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface PolicySpecRule {
        /**
         * Setting this to `"TRUE"` means that all values are allowed. This field can be set only in Policies for list constraints.
         */
        allowAll?: pulumi.Input<string>;
        /**
         * A condition which determines whether this rule is used in the evaluation of the policy. When set, the `expression` field in the `Expr' must include from 1 to 10 subexpressions, joined by the "||" or "&&" operators. Each subexpression must be of the form "resource.matchTag('/tag_key_short_name, 'tag_value_short_name')". or "resource.matchTagId('tagKeys/key_id', 'tagValues/value_id')". where keyName and valueName are the resource names for Label Keys and Values. These names are available from the Tag Manager Service. An example expression is: "resource.matchTag('123456789/environment, 'prod')". or "resource.matchTagId('tagKeys/123', 'tagValues/456')".
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.orgpolicy.PolicySpecRuleCondition>;
        /**
         * Setting this to `"TRUE"` means that all values are denied. This field can be set only in Policies for list constraints.
         */
        denyAll?: pulumi.Input<string>;
        /**
         * If `"TRUE"`, then the `Policy` is enforced. If `"FALSE"`, then any configuration is acceptable. This field can be set only in Policies for boolean constraints.
         */
        enforce?: pulumi.Input<string>;
        /**
         * Optional. Required for Managed Constraints if parameters defined in constraints. Pass parameter values when policy enforcement is enabled. Ensure that parameter value types match those defined in the constraint definition. For example: { \"allowedLocations\" : [\"us-east1\", \"us-west1\"], \"allowAll\" : true }
         */
        parameters?: pulumi.Input<string>;
        /**
         * List of values to be used for this policy rule. This field can be set only in policies for list constraints.
         * Structure is documented below.
         */
        values?: pulumi.Input<inputs.orgpolicy.PolicySpecRuleValues>;
    }

    export interface PolicySpecRuleCondition {
        /**
         * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression?: pulumi.Input<string>;
        /**
         * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface PolicySpecRuleValues {
        /**
         * List of values allowed at this resource.
         */
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of values denied at this resource.
         */
        deniedValues?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace osconfig {
    export interface GuestPoliciesAssignment {
        /**
         * Targets instances matching at least one of these label sets. This allows an assignment to target disparate groups,
         * for example "env=prod or env=staging".
         * Structure is documented below.
         */
        groupLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.GuestPoliciesAssignmentGroupLabel>[]>;
        /**
         * Targets VM instances whose name starts with one of these prefixes.
         * Like labels, this is another way to group VM instances when targeting configs,
         * for example prefix="prod-".
         * Only supported for project-level policies.
         */
        instanceNamePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Targets any of the instances specified. Instances are specified by their URI in the form
         * zones/[ZONE]/instances/[INSTANCE_NAME].
         * Instance targeting is uncommon and is supported to facilitate the management of changes
         * by the instance or to target specific VM instances for development and testing.
         * Only supported for project-level policies and must reference instances within this project.
         */
        instances?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Targets VM instances matching at least one of the following OS types.
         * VM instances must match all supplied criteria for a given OsType to be included.
         * Structure is documented below.
         */
        osTypes?: pulumi.Input<pulumi.Input<inputs.osconfig.GuestPoliciesAssignmentOsType>[]>;
        /**
         * Targets instances in any of these zones. Leave empty to target instances in any zone.
         * Zonal targeting is uncommon and is supported to facilitate the management of changes by zone.
         */
        zones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GuestPoliciesAssignmentGroupLabel {
        /**
         * Google Compute Engine instance labels that must be present for an instance to be included in this assignment group.
         */
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GuestPoliciesAssignmentOsType {
        /**
         * Targets VM instances with OS Inventory enabled and having the following OS architecture.
         *
         * - - -
         */
        osArchitecture?: pulumi.Input<string>;
        /**
         * Targets VM instances with OS Inventory enabled and having the following OS short name, for example "debian" or "windows".
         */
        osShortName?: pulumi.Input<string>;
        /**
         * Targets VM instances with OS Inventory enabled and having the following following OS version.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface GuestPoliciesPackage {
        /**
         * The desiredState the agent should maintain for this package. The default is to ensure the package is installed.
         * Possible values are: `INSTALLED`, `UPDATED`, `REMOVED`.
         */
        desiredState?: pulumi.Input<string>;
        /**
         * Type of package manager that can be used to install this package. If a system does not have the package manager,
         * the package is not installed or removed no error message is returned. By default, or if you specify ANY,
         * the agent attempts to install and remove this package using the default package manager.
         * This is useful when creating a policy that applies to different types of systems.
         * The default behavior is ANY.
         * Default value is `ANY`.
         * Possible values are: `ANY`, `APT`, `YUM`, `ZYPPER`, `GOO`.
         */
        manager?: pulumi.Input<string>;
        /**
         * The name of the package. A package is uniquely identified for conflict validation
         * by checking the package name and the manager(s) that the package targets.
         */
        name: pulumi.Input<string>;
    }

    export interface GuestPoliciesPackageRepository {
        /**
         * An Apt Repository.
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.GuestPoliciesPackageRepositoryApt>;
        /**
         * A Goo Repository.
         * Structure is documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.GuestPoliciesPackageRepositoryGoo>;
        /**
         * A Yum Repository.
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.GuestPoliciesPackageRepositoryYum>;
        /**
         * A Zypper Repository.
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.GuestPoliciesPackageRepositoryZypper>;
    }

    export interface GuestPoliciesPackageRepositoryApt {
        /**
         * Type of archive files in this repository. The default behavior is DEB.
         * Default value is `DEB`.
         * Possible values are: `DEB`, `DEB_SRC`.
         */
        archiveType?: pulumi.Input<string>;
        /**
         * List of components for this repository. Must contain at least one item.
         */
        components: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Distribution of this repository.
         */
        distribution: pulumi.Input<string>;
        /**
         * URI of the key file for this repository. The agent maintains a keyring at
         * /etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg containing all the keys in any applied guest policy.
         */
        gpgKey?: pulumi.Input<string>;
        /**
         * URI for this repository.
         */
        uri: pulumi.Input<string>;
    }

    export interface GuestPoliciesPackageRepositoryGoo {
        /**
         * The name of the repository.
         */
        name: pulumi.Input<string>;
        /**
         * The url of the repository.
         */
        url: pulumi.Input<string>;
    }

    export interface GuestPoliciesPackageRepositoryYum {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is the repo id in the Yum config file and also the displayName
         * if displayName is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface GuestPoliciesPackageRepositoryZypper {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is the repo id in the zypper config file and also the displayName
         * if displayName is omitted. This id is also used as the unique identifier when checking for guest policy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipe {
        /**
         * Resources available to be used in the steps in the recipe.
         * Structure is documented below.
         */
        artifacts?: pulumi.Input<pulumi.Input<inputs.osconfig.GuestPoliciesRecipeArtifact>[]>;
        /**
         * Default is INSTALLED. The desired state the agent should maintain for this recipe.
         * INSTALLED: The software recipe is installed on the instance but won't be updated to new versions.
         * INSTALLED_KEEP_UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version,
         * if a higher version of the recipe is assigned to this instance.
         * REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected.
         * Default value is `INSTALLED`.
         * Possible values are: `INSTALLED`, `UPDATED`, `REMOVED`.
         */
        desiredState?: pulumi.Input<string>;
        /**
         * Actions to be taken for installing this recipe. On failure it stops executing steps and does not attempt another installation.
         * Any steps taken (including partially completed steps) are not rolled back.
         * Structure is documented below.
         */
        installSteps?: pulumi.Input<pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStep>[]>;
        /**
         * Unique identifier for the recipe. Only one recipe with a given name is installed on an instance.
         * Names are also used to identify resources which helps to determine whether guest policies have conflicts.
         * This means that requests to create multiple recipes with the same name and version are rejected since they
         * could potentially have conflicting assignments.
         */
        name: pulumi.Input<string>;
        /**
         * Actions to be taken for updating this recipe. On failure it stops executing steps and does not attempt another update for this recipe.
         * Any steps taken (including partially completed steps) are not rolled back.
         * Structure is documented below.
         */
        updateSteps?: pulumi.Input<pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStep>[]>;
        /**
         * The version of this software recipe. Version can be up to 4 period separated numbers (e.g. 12.34.56.78).
         */
        version?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeArtifact {
        /**
         * Defaults to false. When false, recipes are subject to validations based on the artifact type:
         * Remote: A checksum must be specified, and only protocols with transport-layer security are permitted.
         * GCS: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Google Cloud Storage artifact.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeArtifactGcs>;
        /**
         * Id of the artifact, which the installation and update steps of this recipe can reference.
         * Artifacts in a recipe cannot have the same id.
         */
        id: pulumi.Input<string>;
        /**
         * A generic remote artifact.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeArtifactRemote>;
    }

    export interface GuestPoliciesRecipeArtifactGcs {
        /**
         * Bucket of the Google Cloud Storage object. Given an example URL: https://storage.googleapis.com/my-bucket/foo/bar#1234567
         * this value would be my-bucket.
         */
        bucket?: pulumi.Input<string>;
        /**
         * Must be provided if allowInsecure is false. Generation number of the Google Cloud Storage object.
         * https://storage.googleapis.com/my-bucket/foo/bar#1234567 this value would be 1234567.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Google Cloud Storage object. Given an example URL: https://storage.googleapis.com/my-bucket/foo/bar#1234567
         * this value would be foo/bar.
         */
        object?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeArtifactRemote {
        /**
         * Must be provided if allowInsecure is false. SHA256 checksum in hex format, to compare to the checksum of the artifact.
         * If the checksum is not empty and it doesn't match the artifact then the recipe installation fails before running any
         * of the steps.
         */
        checkSum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the protocol and path following the format {protocol}://{location}.
         */
        uri?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStep {
        /**
         * Extracts an archive into the specified directory.
         * Structure is documented below.
         */
        archiveExtraction?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepArchiveExtraction>;
        /**
         * Installs a deb file via dpkg.
         * Structure is documented below.
         */
        dpkgInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepDpkgInstallation>;
        /**
         * Copies a file onto the instance.
         * Structure is documented below.
         */
        fileCopy?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepFileCopy>;
        /**
         * Executes an artifact or local file.
         * Structure is documented below.
         */
        fileExec?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepFileExec>;
        /**
         * Installs an MSI file.
         * Structure is documented below.
         */
        msiInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepMsiInstallation>;
        /**
         * Installs an rpm file via the rpm utility.
         * Structure is documented below.
         */
        rpmInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepRpmInstallation>;
        /**
         * Runs commands in a shell.
         * Structure is documented below.
         */
        scriptRun?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeInstallStepScriptRun>;
    }

    export interface GuestPoliciesRecipeInstallStepArchiveExtraction {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * Directory to extract archive to. Defaults to / on Linux or C:\ on Windows.
         */
        destination?: pulumi.Input<string>;
        /**
         * The type of the archive to extract.
         * Possible values are: `TAR`, `TAR_GZIP`, `TAR_BZIP`, `TAR_LZMA`, `TAR_XZ`, `ZIP`.
         */
        type: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStepDpkgInstallation {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStepFileCopy {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * The absolute path on the instance to put the file.
         */
        destination: pulumi.Input<string>;
        /**
         * Whether to allow this step to overwrite existing files.If this is false and the file already exists the file
         * is not overwritten and the step is considered a success. Defaults to false.
         */
        overwrite?: pulumi.Input<boolean>;
        /**
         * Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users
         * for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit
         * number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one
         * bit corresponds to the execute permission. Default behavior is 755.
         * Below are some examples of permissions and their associated values:
         * read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4
         */
        permissions?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStepFileExec {
        /**
         * A list of possible return values that the program can return to indicate a success. Defaults to [0].
         */
        allowedExitCodes?: pulumi.Input<string>;
        /**
         * Arguments to be passed to the provided executable.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId?: pulumi.Input<string>;
        /**
         * The absolute path of the file on the local filesystem.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStepMsiInstallation {
        /**
         * Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
         */
        allowedExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * The flags to use when installing the MSI. Defaults to the install flag.
         */
        flags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GuestPoliciesRecipeInstallStepRpmInstallation {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeInstallStepScriptRun {
        /**
         * Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
         */
        allowedExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script is executed directly,
         * which likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * The shell script to be executed.
         */
        script: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStep {
        /**
         * Extracts an archive into the specified directory.
         * Structure is documented below.
         */
        archiveExtraction?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepArchiveExtraction>;
        /**
         * Installs a deb file via dpkg.
         * Structure is documented below.
         */
        dpkgInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepDpkgInstallation>;
        /**
         * Copies a file onto the instance.
         * Structure is documented below.
         */
        fileCopy?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepFileCopy>;
        /**
         * Executes an artifact or local file.
         * Structure is documented below.
         */
        fileExec?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepFileExec>;
        /**
         * Installs an MSI file.
         * Structure is documented below.
         */
        msiInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepMsiInstallation>;
        /**
         * Installs an rpm file via the rpm utility.
         * Structure is documented below.
         */
        rpmInstallation?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepRpmInstallation>;
        /**
         * Runs commands in a shell.
         * Structure is documented below.
         */
        scriptRun?: pulumi.Input<inputs.osconfig.GuestPoliciesRecipeUpdateStepScriptRun>;
    }

    export interface GuestPoliciesRecipeUpdateStepArchiveExtraction {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * Directory to extract archive to. Defaults to / on Linux or C:\ on Windows.
         */
        destination?: pulumi.Input<string>;
        /**
         * The type of the archive to extract.
         * Possible values are: `TAR`, `TAR_GZIP`, `TAR_BZIP`, `TAR_LZMA`, `TAR_XZ`, `ZIP`.
         */
        type: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStepDpkgInstallation {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStepFileCopy {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * The absolute path on the instance to put the file.
         */
        destination: pulumi.Input<string>;
        /**
         * Whether to allow this step to overwrite existing files.If this is false and the file already exists the file
         * is not overwritten and the step is considered a success. Defaults to false.
         */
        overwrite?: pulumi.Input<boolean>;
        /**
         * Consists of three octal digits which represent, in order, the permissions of the owner, group, and other users
         * for the file (similarly to the numeric mode used in the linux chmod utility). Each digit represents a three bit
         * number with the 4 bit corresponding to the read permissions, the 2 bit corresponds to the write bit, and the one
         * bit corresponds to the execute permission. Default behavior is 755.
         * Below are some examples of permissions and their associated values:
         * read, write, and execute: 7 read and execute: 5 read and write: 6 read only: 4
         */
        permissions?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStepFileExec {
        /**
         * A list of possible return values that the program can return to indicate a success. Defaults to [0].
         */
        allowedExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * Arguments to be passed to the provided executable.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId?: pulumi.Input<string>;
        /**
         * The absolute path of the file on the local filesystem.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStepMsiInstallation {
        /**
         * Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
         */
        allowedExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
        /**
         * The flags to use when installing the MSI. Defaults to the install flag.
         */
        flags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GuestPoliciesRecipeUpdateStepRpmInstallation {
        /**
         * The id of the relevant artifact in the recipe.
         */
        artifactId: pulumi.Input<string>;
    }

    export interface GuestPoliciesRecipeUpdateStepScriptRun {
        /**
         * Return codes that indicate that the software installed or updated successfully. Behaviour defaults to [0]
         */
        allowedExitCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script is executed directly,
         * which likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * The shell script to be executed.
         */
        script: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentInstanceFilter {
        /**
         * Target all VMs in the project. If true, no other criteria
         * is permitted.
         */
        all?: pulumi.Input<boolean>;
        /**
         * List of label sets used for VM exclusion. If
         * the list has more than one label set, the VM is excluded if any of the label
         * sets are applicable for the VM. Structure is
         * documented below.
         */
        exclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentInstanceFilterExclusionLabel>[]>;
        /**
         * List of label sets used for VM inclusion. If
         * the list has more than one `LabelSet`, the VM is included if any of the
         * label sets are applicable for the VM. Structure is
         * documented below.
         */
        inclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentInstanceFilterInclusionLabel>[]>;
        /**
         * List of inventories to select VMs. A VM is
         * selected if its inventory data matches at least one of the following
         * inventories. Structure is documented below.
         */
        inventories?: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentInstanceFilterInventory>[]>;
    }

    export interface OsPolicyAssignmentInstanceFilterExclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this map to be
         * selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface OsPolicyAssignmentInstanceFilterInclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this map to be
         * selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface OsPolicyAssignmentInstanceFilterInventory {
        /**
         * The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version Prefix matches are supported if
         * asterisk(*) is provided as the last character. For example, to match all
         * versions with a major version of `7`, specify the following value for this
         * field `7.*` An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicy {
        /**
         * This flag determines the OS
         * policy compliance status when none of the resource groups within the policy
         * are applicable for a VM. Set this value to `true` if the policy needs to be
         * reported as compliant even if the policy has nothing to validate or enforce.
         */
        allowNoResourceGroupMatch?: pulumi.Input<boolean>;
        /**
         * Policy description. Length of the description is
         * limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * The id of the OS policy with the following restrictions:
         *
         * *   Must contain only lowercase letters, numbers, and hyphens.
         * *   Must start with a letter.
         * *   Must be between 1-63 characters.
         * *   Must end with a number or a letter.
         * *   Must be unique within the assignment.
         */
        id: pulumi.Input<string>;
        /**
         * Policy mode Possible values are: `MODE_UNSPECIFIED`,
         * `VALIDATION`, `ENFORCEMENT`.
         */
        mode: pulumi.Input<string>;
        /**
         * List of resource groups for the policy. For a
         * particular VM, resource groups are evaluated in the order specified and the
         * first resource group that is applicable is selected and the rest are
         * ignored. If none of the resource groups are applicable for a VM, the VM is
         * considered to be non-compliant w.r.t this policy. This behavior can be
         * toggled by the flag `allowNoResourceGroupMatch` Structure is
         * documented below.
         */
        resourceGroups: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroup>[]>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroup {
        /**
         * List of inventory filters for the resource
         * group. The resources in this resource group are applied to the target VM if
         * it satisfies at least one of the following inventory filters. For example,
         * to apply this resource group to VMs running either `RHEL` or `CentOS`
         * operating systems, specify 2 items for the list with following values:
         * inventory_filters[0].os_short_name='rhel' and
         * inventory_filters[1].os_short_name='centos' If the list is empty, this
         * resource group will be applied to the target VM unconditionally. Structure
         * is documented below.
         */
        inventoryFilters?: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupInventoryFilter>[]>;
        /**
         * List of resources configured for this resource
         * group. The resources are executed in the exact order specified here.
         * Structure is documented below.
         */
        resources: pulumi.Input<pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResource>[]>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupInventoryFilter {
        /**
         * The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version Prefix matches are supported if
         * asterisk(*) is provided as the last character. For example, to match all
         * versions with a major version of `7`, specify the following value for this
         * field `7.*` An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResource {
        /**
         * Exec resource Structure is
         * documented below.
         */
        exec?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExec>;
        /**
         * File resource Structure is
         * documented below.
         */
        file?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceFile>;
        /**
         * The id of the resource with the following restrictions:
         *
         * *   Must contain only lowercase letters, numbers, and hyphens.
         * *   Must start with a letter.
         * *   Must be between 1-63 characters.
         * *   Must end with a number or a letter.
         * *   Must be unique within the OS policy.
         */
        id: pulumi.Input<string>;
        /**
         * Package resource Structure is
         * documented below.
         */
        pkg?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkg>;
        /**
         * Package repository resource Structure is
         * documented below.
         */
        repository?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceRepository>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExec {
        /**
         * What to run to bring this resource into the desired
         * state. An exit code of 100 indicates "success", any other exit code
         * indicates a failure running enforce. Structure is
         * documented below.
         */
        enforce?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforce>;
        /**
         * What to run to validate this resource is in the
         * desired state. An exit code of 100 indicates "in desired state", and exit
         * code of 101 indicates "not in desired state". Any other exit code indicates
         * a failure running validate. Structure is
         * documented below.
         */
        validate: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidate>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforce {
        /**
         * Optional arguments to pass to the source during
         * execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file. Structure is
         * documented below.
         */
        file?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFile>;
        /**
         * The script interpreter to use. Possible values
         * are: `INTERPRETER_UNSPECIFIED`, `NONE`, `SHELL`, `POWERSHELL`.
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec. Path to an
         * output file (that is created by this Exec) whose content will be recorded in
         * OSPolicyResourceCompliance after a successful run. Absence or failure to
         * read this file will result in this ExecResource being non-compliant. Output
         * file size is limited to 100K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script. The size of the script is limited to
         * 1024 characters.
         */
        script?: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFile {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFileRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecEnforceFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidate {
        /**
         * Optional arguments to pass to the source during
         * execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file. Structure is
         * documented below.
         */
        file?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFile>;
        /**
         * The script interpreter to use. Possible values
         * are: `INTERPRETER_UNSPECIFIED`, `NONE`, `SHELL`, `POWERSHELL`.
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec. Path to an
         * output file (that is created by this Exec) whose content will be recorded in
         * OSPolicyResourceCompliance after a successful run. Absence or failure to
         * read this file will result in this ExecResource being non-compliant. Output
         * file size is limited to 100K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script. The size of the script is limited to
         * 1024 characters.
         */
        script?: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFile {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFileRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceExecValidateFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceFile {
        /**
         * A a file with this content. The size of the content
         * is limited to 1024 characters.
         */
        content?: pulumi.Input<string>;
        /**
         * A remote or local source. Structure is
         * documented below.
         */
        file?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceFileFile>;
        /**
         * The absolute path of the file within the VM.
         */
        path: pulumi.Input<string>;
        /**
         * Consists of three octal digits which represent, in
         * order, the permissions of the owner, group, and other users for the file
         * (similarly to the numeric mode used in the linux chmod utility). Each digit
         * represents a three bit number with the 4 bit corresponding to the read
         * permissions, the 2 bit corresponds to the write bit, and the one bit
         * corresponds to the execute permission. Default behavior is 755. Below are
         * some examples of permissions and their associated values: read, write, and
         * execute: 7 read and execute: 5 read and write: 6 read only: 4
         */
        permissions?: pulumi.Input<string>;
        /**
         * Desired state of the file. Possible values are:
         * `DESIRED_STATE_UNSPECIFIED`, `PRESENT`, `ABSENT`, `CONTENTS_MATCH`.
         */
        state: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceFileFile {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceFileFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceFileFileRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceFileFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceFileFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkg {
        /**
         * A package managed by Apt. Structure is
         * documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgApt>;
        /**
         * A deb package file. Structure is
         * documented below.
         */
        deb?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDeb>;
        /**
         * The desired state the agent should maintain for
         * this package. Possible values are: `DESIRED_STATE_UNSPECIFIED`, `INSTALLED`,
         * `REMOVED`.
         */
        desiredState: pulumi.Input<string>;
        /**
         * A package managed by GooGet. Structure is
         * documented below.
         */
        googet?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgGooget>;
        /**
         * An MSI package. Structure is
         * documented below.
         */
        msi?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsi>;
        /**
         * An rpm package file. Structure is
         * documented below.
         */
        rpm?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpm>;
        /**
         * A package managed by YUM. Structure is
         * documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgYum>;
        /**
         * A package managed by Zypper. Structure is
         * documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgZypper>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgApt {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDeb {
        /**
         * Whether dependencies should also be installed. -
         * install when false: `dpkg -i package` - install when true: `apt-get update
         * && apt-get -y install package.deb`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A deb package. Structure is
         * documented below.
         */
        source: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSource>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSource {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSourceRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgDebSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgGooget {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsi {
        /**
         * Additional properties to use during installation.
         * This should be in the format of Property=Setting. Appended to the defaults
         * of `ACTION=INSTALL REBOOT=ReallySuppress`.
         */
        properties?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The MSI package. Structure is
         * documented below.
         */
        source: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSource>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSource {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSourceRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgMsiSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpm {
        /**
         * Whether dependencies should also be installed. -
         * install when false: `rpm --upgrade --replacepkgs package.rpm` - install when
         * true: `yum -y install package.rpm` or `zypper -y install package.rpm`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * An rpm package. Structure is
         * documented below.
         */
        source: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSource>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSource {
        /**
         * Defaults to false. When false, files are
         * subject to validations based on the file type: Remote: A checksum must be
         * specified. Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * A Cloud Storage object. Structure is
         * documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * A generic remote file. Structure is
         * documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSourceRemote>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<number>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgRpmSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain
         * both the protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgYum {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourcePkgZypper {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceRepository {
        /**
         * An Apt Repository. Structure is
         * documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryApt>;
        /**
         * A Goo Repository. Structure is
         * documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryGoo>;
        /**
         * A Yum Repository. Structure is
         * documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryYum>;
        /**
         * A Zypper Repository. Structure is
         * documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryZypper>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryApt {
        /**
         * Type of archive files in this repository.
         * Possible values are: `ARCHIVE_TYPE_UNSPECIFIED`, `DEB`, `DEB_SRC`.
         */
        archiveType: pulumi.Input<string>;
        /**
         * List of components for this repository. Must
         * contain at least one item.
         */
        components: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Distribution of this repository.
         */
        distribution: pulumi.Input<string>;
        /**
         * URI of the key file for this repository. The agent
         * maintains a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
         */
        gpgKey?: pulumi.Input<string>;
        /**
         * URI for this repository.
         */
        uri: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryGoo {
        /**
         * The name of the repository.
         */
        name: pulumi.Input<string>;
        /**
         * The url of the repository.
         */
        url: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryYum {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is the
         * `repo id` in the yum config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique identifier
         * when checking for resource conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentOsPolicyResourceGroupResourceRepositoryZypper {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is the
         * `repo id` in the zypper config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique identifier
         * when checking for GuestPolicy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentRollout {
        /**
         * The maximum number (or percentage) of VMs
         * per zone to disrupt at any given moment. Structure is
         * documented below.
         */
        disruptionBudget: pulumi.Input<inputs.osconfig.OsPolicyAssignmentRolloutDisruptionBudget>;
        /**
         * This determines the minimum duration of
         * time to wait after the configuration changes are applied through the current
         * rollout. A VM continues to count towards the `disruptionBudget` at least
         * until this duration of time has passed after configuration changes are
         * applied.
         */
        minWaitDuration: pulumi.Input<string>;
    }

    export interface OsPolicyAssignmentRolloutDisruptionBudget {
        /**
         * Specifies a fixed value.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies the relative value defined as a percentage,
         * which will be multiplied by a reference value.
         *
         * --------------------------------------------------------------------------------
         */
        percent?: pulumi.Input<number>;
    }

    export interface PatchDeploymentInstanceFilter {
        /**
         * Target all VM instances in the project. If true, no other criteria is permitted.
         */
        all?: pulumi.Input<boolean>;
        /**
         * Targets VM instances matching ANY of these GroupLabels. This allows targeting of disparate groups of VM instances.
         * Structure is documented below.
         */
        groupLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.PatchDeploymentInstanceFilterGroupLabel>[]>;
        /**
         * Targets VMs whose name starts with one of these prefixes. Similar to labels, this is another way to group
         * VMs when targeting configs, for example prefix="prod-".
         */
        instanceNamePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Targets any of the VM instances specified. Instances are specified by their URI in the `form zones/{{zone}}/instances/{{instance_name}}`,
         * `projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}`, or
         * `https://www.googleapis.com/compute/v1/projects/{{project_id}}/zones/{{zone}}/instances/{{instance_name}}`
         */
        instances?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Targets VM instances in ANY of these zones. Leave empty to target VM instances in any zone.
         */
        zones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PatchDeploymentInstanceFilterGroupLabel {
        /**
         * Compute Engine instance labels that must be present for a VM instance to be targeted by this filter
         *
         * - - -
         */
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface PatchDeploymentOneTimeSchedule {
        /**
         * The desired patch job execution time. A timestamp in RFC3339 UTC "Zulu" format,
         * accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
         */
        executeTime: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfig {
        /**
         * Apt update settings. Use this setting to override the default apt patch rules.
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigApt>;
        /**
         * goo update settings. Use this setting to override the default goo patch rules.
         * Structure is documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigGoo>;
        /**
         * Allows the patch job to run on Managed instance groups (MIGs).
         */
        migInstancesAllowed?: pulumi.Input<boolean>;
        /**
         * The ExecStep to run after the patch update.
         * Structure is documented below.
         */
        postStep?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPostStep>;
        /**
         * The ExecStep to run before the patch update.
         * Structure is documented below.
         */
        preStep?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPreStep>;
        /**
         * Post-patch reboot settings.
         * Possible values are: `DEFAULT`, `ALWAYS`, `NEVER`.
         */
        rebootConfig?: pulumi.Input<string>;
        /**
         * Windows update settings. Use this setting to override the default Windows patch rules.
         * Structure is documented below.
         */
        windowsUpdate?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigWindowsUpdate>;
        /**
         * Yum update settings. Use this setting to override the default yum patch rules.
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigYum>;
        /**
         * zypper update settings. Use this setting to override the default zypper patch rules.
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigZypper>;
    }

    export interface PatchDeploymentPatchConfigApt {
        /**
         * List of packages to exclude from update. These packages will be excluded.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An exclusive list of packages to be updated. These are the only packages that will be updated.
         * If these packages are not installed, they will be ignored. This field cannot be specified with
         * any other patch configuration fields.
         */
        exclusivePackages?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * By changing the type to DIST, the patching is performed using apt-get dist-upgrade instead.
         * Possible values are: `DIST`, `UPGRADE`.
         */
        type?: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigGoo {
        /**
         * goo update settings. Use this setting to override the default goo patch rules.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface PatchDeploymentPatchConfigPostStep {
        /**
         * The ExecStepConfig for all Linux VMs targeted by the PatchJob.
         * Structure is documented below.
         */
        linuxExecStepConfig?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPostStepLinuxExecStepConfig>;
        /**
         * The ExecStepConfig for all Windows VMs targeted by the PatchJob.
         * Structure is documented below.
         */
        windowsExecStepConfig?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPostStepWindowsExecStepConfig>;
    }

    export interface PatchDeploymentPatchConfigPostStepLinuxExecStepConfig {
        /**
         * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
         */
        allowedSuccessCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * A Cloud Storage object containing the executable.
         * Structure is documented below.
         */
        gcsObject?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPostStepLinuxExecStepConfigGcsObject>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script will
         * be executed directly, which will likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * An absolute path to the executable on the VM.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPostStepLinuxExecStepConfigGcsObject {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
         */
        generationNumber: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPostStepWindowsExecStepConfig {
        /**
         * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
         */
        allowedSuccessCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * A Cloud Storage object containing the executable.
         * Structure is documented below.
         */
        gcsObject?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPostStepWindowsExecStepConfigGcsObject>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script will
         * be executed directly, which will likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * An absolute path to the executable on the VM.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPostStepWindowsExecStepConfigGcsObject {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
         */
        generationNumber: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPreStep {
        /**
         * The ExecStepConfig for all Linux VMs targeted by the PatchJob.
         * Structure is documented below.
         */
        linuxExecStepConfig?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPreStepLinuxExecStepConfig>;
        /**
         * The ExecStepConfig for all Windows VMs targeted by the PatchJob.
         * Structure is documented below.
         */
        windowsExecStepConfig?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPreStepWindowsExecStepConfig>;
    }

    export interface PatchDeploymentPatchConfigPreStepLinuxExecStepConfig {
        /**
         * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
         */
        allowedSuccessCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * A Cloud Storage object containing the executable.
         * Structure is documented below.
         */
        gcsObject?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPreStepLinuxExecStepConfigGcsObject>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script will
         * be executed directly, which will likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * An absolute path to the executable on the VM.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPreStepLinuxExecStepConfigGcsObject {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
         */
        generationNumber: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPreStepWindowsExecStepConfig {
        /**
         * Defaults to [0]. A list of possible return values that the execution can return to indicate a success.
         */
        allowedSuccessCodes?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * A Cloud Storage object containing the executable.
         * Structure is documented below.
         */
        gcsObject?: pulumi.Input<inputs.osconfig.PatchDeploymentPatchConfigPreStepWindowsExecStepConfigGcsObject>;
        /**
         * The script interpreter to use to run the script. If no interpreter is specified the script will
         * be executed directly, which will likely only succeed for scripts with shebang lines.
         * Possible values are: `SHELL`, `POWERSHELL`.
         */
        interpreter?: pulumi.Input<string>;
        /**
         * An absolute path to the executable on the VM.
         */
        localPath?: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigPreStepWindowsExecStepConfigGcsObject {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object. This is used to ensure that the ExecStep specified by this PatchJob does not change.
         */
        generationNumber: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface PatchDeploymentPatchConfigWindowsUpdate {
        /**
         * Only apply updates of these windows update classifications. If empty, all updates are applied.
         * Each value may be one of: `CRITICAL`, `SECURITY`, `DEFINITION`, `DRIVER`, `FEATURE_PACK`, `SERVICE_PACK`, `TOOL`, `UPDATE_ROLLUP`, `UPDATE`.
         */
        classifications?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of KBs to exclude from update.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An exclusive list of kbs to be updated. These are the only patches that will be updated.
         * This field must not be used with other patch configurations.
         */
        exclusivePatches?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PatchDeploymentPatchConfigYum {
        /**
         * List of packages to exclude from update. These packages will be excluded.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An exclusive list of packages to be updated. These are the only packages that will be updated.
         * If these packages are not installed, they will be ignored. This field cannot be specified with
         * any other patch configuration fields.
         */
        exclusivePackages?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Will cause patch to run yum update-minimal instead.
         */
        minimal?: pulumi.Input<boolean>;
        /**
         * Adds the --security flag to yum update. Not supported on all platforms.
         */
        security?: pulumi.Input<boolean>;
    }

    export interface PatchDeploymentPatchConfigZypper {
        /**
         * Install only patches with these categories. Common categories include security, recommended, and feature.
         */
        categories?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of packages to exclude from update.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An exclusive list of patches to be updated. These are the only patches that will be installed using 'zypper patch patch:' command.
         * This field must not be used with any other patch configuration fields.
         */
        exclusivePatches?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Install only patches with these severities. Common severities include critical, important, moderate, and low.
         */
        severities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Adds the --with-optional flag to zypper patch.
         */
        withOptional?: pulumi.Input<boolean>;
        /**
         * Adds the --with-update flag, to zypper patch.
         */
        withUpdate?: pulumi.Input<boolean>;
    }

    export interface PatchDeploymentRecurringSchedule {
        /**
         * The end time at which a recurring patch deployment schedule is no longer active.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time the last patch job ran successfully.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
         */
        lastExecuteTime?: pulumi.Input<string>;
        /**
         * Schedule with monthly executions.
         * Structure is documented below.
         */
        monthly?: pulumi.Input<inputs.osconfig.PatchDeploymentRecurringScheduleMonthly>;
        /**
         * (Output)
         * The time the next patch job is scheduled to run.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
         */
        nextExecuteTime?: pulumi.Input<string>;
        /**
         * The time that the recurring schedule becomes effective. Defaults to createTime of the patch deployment.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds. Example: "2014-10-02T15:01:23.045123456Z".
         */
        startTime?: pulumi.Input<string>;
        /**
         * Time of the day to run a recurring deployment.
         * Structure is documented below.
         */
        timeOfDay: pulumi.Input<inputs.osconfig.PatchDeploymentRecurringScheduleTimeOfDay>;
        /**
         * Defines the time zone that timeOfDay is relative to. The rules for daylight saving time are
         * determined by the chosen time zone.
         * Structure is documented below.
         */
        timeZone: pulumi.Input<inputs.osconfig.PatchDeploymentRecurringScheduleTimeZone>;
        /**
         * Schedule with weekly executions.
         * Structure is documented below.
         */
        weekly?: pulumi.Input<inputs.osconfig.PatchDeploymentRecurringScheduleWeekly>;
    }

    export interface PatchDeploymentRecurringScheduleMonthly {
        /**
         * One day of the month. 1-31 indicates the 1st to the 31st day. -1 indicates the last day of the month.
         * Months without the target day will be skipped. For example, a schedule to run "every month on the 31st"
         * will not run in February, April, June, etc.
         */
        monthDay?: pulumi.Input<number>;
        /**
         * Week day in a month.
         * Structure is documented below.
         */
        weekDayOfMonth?: pulumi.Input<inputs.osconfig.PatchDeploymentRecurringScheduleMonthlyWeekDayOfMonth>;
    }

    export interface PatchDeploymentRecurringScheduleMonthlyWeekDayOfMonth {
        /**
         * A day of the week.
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeek: pulumi.Input<string>;
        /**
         * Represents the number of days before or after the given week day of month that the patch deployment is scheduled for.
         */
        dayOffset?: pulumi.Input<number>;
        /**
         * Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1 indicates the last week of the month.
         */
        weekOrdinal: pulumi.Input<number>;
    }

    export interface PatchDeploymentRecurringScheduleTimeOfDay {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface PatchDeploymentRecurringScheduleTimeZone {
        /**
         * IANA Time Zone Database time zone, e.g. "America/New_York".
         */
        id: pulumi.Input<string>;
        /**
         * IANA Time Zone Database version number, e.g. "2019a".
         */
        version?: pulumi.Input<string>;
    }

    export interface PatchDeploymentRecurringScheduleWeekly {
        /**
         * IANA Time Zone Database time zone, e.g. "America/New_York".
         * Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        dayOfWeek: pulumi.Input<string>;
    }

    export interface PatchDeploymentRollout {
        /**
         * The maximum number (or percentage) of VMs per zone to disrupt at any given moment. The number of VMs calculated from multiplying the percentage by the total number of VMs in a zone is rounded up.
         * During patching, a VM is considered disrupted from the time the agent is notified to begin until patching has completed. This disruption time includes the time to complete reboot and any post-patch steps.
         * A VM contributes to the disruption budget if its patching operation fails either when applying the patches, running pre or post patch steps, or if it fails to respond with a success notification before timing out. VMs that are not running or do not have an active agent do not count toward this disruption budget.
         * For zone-by-zone rollouts, if the disruption budget in a zone is exceeded, the patch job stops, because continuing to the next zone requires completion of the patch process in the previous zone.
         * For example, if the disruption budget has a fixed value of 10, and 8 VMs fail to patch in the current zone, the patch job continues to patch 2 VMs at a time until the zone is completed. When that zone is completed successfully, patching begins with 10 VMs at a time in the next zone. If 10 VMs in the next zone fail to patch, the patch job stops.
         * Structure is documented below.
         */
        disruptionBudget: pulumi.Input<inputs.osconfig.PatchDeploymentRolloutDisruptionBudget>;
        /**
         * Mode of the patch rollout.
         * Possible values are: `ZONE_BY_ZONE`, `CONCURRENT_ZONES`.
         */
        mode: pulumi.Input<string>;
    }

    export interface PatchDeploymentRolloutDisruptionBudget {
        /**
         * Specifies a fixed value.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies the relative value defined as a percentage, which will be multiplied by a reference value.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResource {
        /**
         * ID of the resource to be used while generating set of affected resources.
         * For UPSERT action the value is auto-generated during PolicyOrchestrator
         * creation when not set. When the value is set it should following next
         * restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the project.
         * For DELETE action, ID must be specified explicitly during
         * PolicyOrchestrator creation.
         *
         *
         * <a name="nestedOrchestratedResourceOsPolicyAssignmentV1Payload"></a>The `osPolicyAssignmentV1Payload` block supports:
         */
        id?: pulumi.Input<string>;
        /**
         * OS policy assignment is an API resource that is used to
         * apply a set of OS policies to a dynamically targeted group of Compute Engine
         * VM instances.
         * An OS policy is used to define the desired state configuration for a
         * Compute Engine VM instance through a set of configuration resources that
         * provide capabilities such as installing or removing software packages, or
         * executing a script.
         * For more information about the OS policy resource definitions and examples,
         * see
         * [OS policy and OS policy
         * assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
         * Structure is documented below.
         */
        osPolicyAssignmentV1Payload?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1Payload>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1Payload {
        /**
         * Indicates that this revision has been successfully rolled out in this zone
         * and new VMs will be assigned OS policies from this revision.
         *
         * For a given OS policy assignment, there is only one revision with a value
         * of 'true' for this field.
         */
        baseline?: pulumi.Input<boolean>;
        /**
         * Indicates that this revision deletes the OS policy assignment.
         */
        deleted?: pulumi.Input<boolean>;
        /**
         * OS policy assignment description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * This checksum is computed by the server based on the value of other
         * fields, and may be sent on update and delete requests to ensure the
         * client has an up-to-date value before proceeding.
         */
        etag?: pulumi.Input<string>;
        /**
         * Filters to select target VMs for an assignment.
         *
         * If more than one filter criteria is specified below, a VM will be selected
         * if and only if it satisfies all of them.
         */
        instanceFilter: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter>;
        /**
         * Identifier. In form of
         * * `organizations/{organization_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `folders/{folder_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `projects/{project_id_or_number}/locations/global/policyOrchestrators/{orchestrator_id}`
         */
        name?: pulumi.Input<string>;
        /**
         * List of OS policies to be applied to the VMs.
         */
        osPolicies: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy>[]>;
        /**
         * Set to true, if the there are ongoing changes being applied by the
         * orchestrator.
         */
        reconciling?: pulumi.Input<boolean>;
        /**
         * The timestamp that the revision was created.
         */
        revisionCreateTime?: pulumi.Input<string>;
        /**
         * The assignment revision ID
         * A new revision is committed whenever a rollout is triggered for a OS policy
         * assignment
         */
        revisionId?: pulumi.Input<string>;
        /**
         * Message to configure the rollout at the zonal level for the OS policy
         * assignment.
         */
        rollout: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadRollout>;
        /**
         * OS policy assignment rollout state
         * Possible values:
         * IN_PROGRESS
         * CANCELLING
         * CANCELLED
         * SUCCEEDED
         */
        rolloutState?: pulumi.Input<string>;
        /**
         * Server generated unique id for the OS policy assignment resource.
         */
        uid?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter {
        /**
         * Target all VMs in the project. If true, no other criteria is
         * permitted.
         */
        all?: pulumi.Input<boolean>;
        /**
         * List of label sets used for VM exclusion.
         * If the list has more than one label set, the VM is excluded if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        exclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel>[]>;
        /**
         * List of label sets used for VM inclusion.
         * If the list has more than one `LabelSet`, the VM is included if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        inclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel>[]>;
        /**
         * List of inventories to select VMs.
         * A VM is selected if its inventory data matches at least one of the
         * following inventories.
         * Structure is documented below.
         */
        inventories?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory {
        /**
         * The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy {
        /**
         * This flag determines the OS policy compliance status when none of the
         * resource groups within the policy are applicable for a VM. Set this value
         * to `true` if the policy needs to be reported as compliant even if the
         * policy has nothing to validate or enforce.
         */
        allowNoResourceGroupMatch?: pulumi.Input<boolean>;
        /**
         * Policy description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * The id of the OS policy with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the assignment.
         */
        id: pulumi.Input<string>;
        /**
         * Policy mode
         * Possible values are: `VALIDATION`, `ENFORCEMENT`.
         */
        mode: pulumi.Input<string>;
        /**
         * List of resource groups for the policy.
         * For a particular VM, resource groups are evaluated in the order specified
         * and the first resource group that is applicable is selected and the rest
         * are ignored.
         * If none of the resource groups are applicable for a VM, the VM is
         * considered to be non-compliant w.r.t this policy. This behavior can be
         * toggled by the flag `allowNoResourceGroupMatch`
         * Structure is documented below.
         */
        resourceGroups: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup {
        /**
         * List of inventory filters for the resource group.
         * The resources in this resource group are applied to the target VM if it
         * satisfies at least one of the following inventory filters.
         * For example, to apply this resource group to VMs running either `RHEL` or
         * `CentOS` operating systems, specify 2 items for the list with following
         * values:
         * inventory_filters[0].os_short_name='rhel' and
         * inventory_filters[1].os_short_name='centos'
         * If the list is empty, this resource group will be applied to the target
         * VM unconditionally.
         * Structure is documented below.
         */
        inventoryFilters?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter>[]>;
        /**
         * List of resources configured for this resource group.
         * The resources are executed in the exact order specified here.
         * Structure is documented below.
         */
        resources: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter {
        /**
         * The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource {
        /**
         * A resource that allows executing scripts on the VM.
         * The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
         * accept a script as an argument to execute.
         * When the `ExecResource` is applied by the agent, it first executes the
         * script in the `validate` stage. The `validate` stage can signal that the
         * `ExecResource` is already in the desired state by returning an exit code
         * of `100`. If the `ExecResource` is not in the desired state, it should
         * return an exit code of `101`. Any other exit code returned by this stage
         * is considered an error.
         * If the `ExecResource` is not in the desired state based on the exit code
         * from the `validate` stage, the agent proceeds to execute the script from
         * the `enforce` stage. If the `ExecResource` is already in the desired
         * state, the `enforce` stage will not be run.
         * Similar to `validate` stage, the `enforce` stage should return an exit
         * code of `100` to indicate that the resource in now in its desired state.
         * Any other exit code is considered an error.
         * NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
         * have an explicit indicator of `in desired state`, `not in desired state`
         * and errors. Because, for example, Powershell will always return an exit
         * code of `0` unless an `exit` statement is provided in the script. So, for
         * reasons of consistency and being explicit, exit codes `100` and `101`
         * were chosen.
         * Structure is documented below.
         */
        exec?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec>;
        /**
         * A resource that manages the state of a file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile>;
        /**
         * The id of the resource with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the OS policy.
         */
        id: pulumi.Input<string>;
        /**
         * A resource that manages a system package.
         * Structure is documented below.
         */
        pkg?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg>;
        /**
         * A resource that manages a package repository.
         * Structure is documented below.
         */
        repository?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec {
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        enforce?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce>;
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        validate: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile>;
        /**
         * The script interpreter to use.
         * Possible values are: `NONE`, `SHELL`, `POWERSHELL`.
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile>;
        /**
         * The script interpreter to use.
         * Possible values are: `NONE`, `SHELL`, `POWERSHELL`.
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile {
        /**
         * A a file with this content.
         * The size of the content is limited to 32KiB.
         */
        content?: pulumi.Input<string>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile>;
        /**
         * The absolute path of the file within the VM.
         */
        path: pulumi.Input<string>;
        /**
         * Consists of three octal digits which represent, in
         * order, the permissions of the owner, group, and other users for the
         * file (similarly to the numeric mode used in the linux chmod
         * utility). Each digit represents a three bit number with the 4 bit
         * corresponding to the read permissions, the 2 bit corresponds to the
         * write bit, and the one bit corresponds to the execute permission.
         * Default behavior is 755.
         * Below are some examples of permissions and their associated values:
         * read, write, and execute: 7
         * read and execute: 5
         * read and write: 6
         * read only: 4
         */
        permissions?: pulumi.Input<string>;
        /**
         * Desired state of the file.
         * Possible values are: `PRESENT`, `ABSENT`, `CONTENTS_MATCH`.
         */
        state: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg {
        /**
         * A package managed by APT.
         * - install: `apt-get update && apt-get -y install [name]`
         * - remove: `apt-get -y remove [name]`
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt>;
        /**
         * A deb package file. dpkg packages only support INSTALLED state.
         * Structure is documented below.
         */
        deb?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb>;
        /**
         * The desired state the agent should maintain for this package.
         * Possible values are: `INSTALLED`, `REMOVED`.
         */
        desiredState: pulumi.Input<string>;
        /**
         * A package managed by GooGet.
         * - install: `googet -noconfirm install package`
         * - remove: `googet -noconfirm remove package`
         * Structure is documented below.
         */
        googet?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget>;
        /**
         * An MSI package. MSI packages only support INSTALLED state.
         * Structure is documented below.
         */
        msi?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi>;
        /**
         * An RPM package file. RPM packages only support INSTALLED state.
         * Structure is documented below.
         */
        rpm?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm>;
        /**
         * A package managed by YUM.
         * - install: `yum -y install package`
         * - remove: `yum -y remove package`
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum>;
        /**
         * A package managed by Zypper.
         * - install: `zypper -y install package`
         * - remove: `zypper -y rm package`
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `dpkg -i package`
         * - install when true: `apt-get update && apt-get -y install
         * package.deb`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi {
        /**
         * Additional properties to use during installation.
         * This should be in the format of Property=Setting.
         * Appended to the defaults of `ACTION=INSTALL
         * REBOOT=ReallySuppress`.
         */
        properties?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `rpm --upgrade --replacepkgs package.rpm`
         * - install when true: `yum -y install package.rpm` or
         * `zypper -y install package.rpm`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs {
        /**
         * Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper {
        /**
         * Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository {
        /**
         * Represents a single apt package repository. These will be added to
         * a repo file that will be managed at
         * `/etc/apt/sources.list.d/google_osconfig.list`.
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt>;
        /**
         * Represents a Goo package repository. These are added to a repo file
         * that is managed at
         * `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
         * Structure is documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo>;
        /**
         * Represents a single yum package repository. These are added to a
         * repo file that is managed at
         * `/etc/yum.repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum>;
        /**
         * Represents a single zypper package repository. These are added to a
         * repo file that is managed at
         * `/etc/zypp/repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt {
        /**
         * Type of archive files in this repository.
         * Possible values are: `DEB`, `DEB_SRC`.
         */
        archiveType: pulumi.Input<string>;
        /**
         * List of components for this repository. Must contain at least one
         * item.
         */
        components: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Distribution of this repository.
         */
        distribution: pulumi.Input<string>;
        /**
         * URI of the key file for this repository. The agent maintains a
         * keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
         */
        gpgKey?: pulumi.Input<string>;
        /**
         * URI for this repository.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo {
        /**
         * The name of the repository.
         */
        name: pulumi.Input<string>;
        /**
         * The url of the repository.
         */
        url: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is  the `repo
         * id` in the yum config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for resource conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper {
        /**
         * The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A one word, unique name for this repository. This is the `repo
         * id` in the zypper config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for GuestPolicy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadRollout {
        /**
         * Message encapsulating a value that can be either absolute ("fixed") or
         * relative ("percent") to a value.
         * Structure is documented below.
         */
        disruptionBudget: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget>;
        /**
         * This determines the minimum duration of time to wait after the
         * configuration changes are applied through the current rollout. A
         * VM continues to count towards the `disruptionBudget` at least
         * until this duration of time has passed after configuration changes are
         * applied.
         */
        minWaitDuration: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget {
        /**
         * Specifies a fixed value.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies the relative value defined as a percentage, which will be
         * multiplied by a reference value.
         *
         * - - -
         */
        percent?: pulumi.Input<number>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationScope {
        /**
         * Selectors of the orchestration scope. There is a logical AND between each
         * selector defined.
         * When there is no explicit `ResourceHierarchySelector` selector specified,
         * the scope is by default bounded to the parent of the policy orchestrator
         * resource.
         * Structure is documented below.
         */
        selectors?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationScopeSelector>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationScopeSelector {
        /**
         * Selector containing locations in scope.
         * Structure is documented below.
         */
        locationSelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationScopeSelectorLocationSelector>;
        /**
         * Selector containing Cloud Resource Manager resource hierarchy nodes.
         * Structure is documented below.
         */
        resourceHierarchySelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationScopeSelectorResourceHierarchySelector>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationScopeSelectorLocationSelector {
        /**
         * Names of the locations in scope.
         * Format: `us-central1-a`
         */
        includedLocations?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationScopeSelectorResourceHierarchySelector {
        /**
         * Names of the folders in scope.
         * Format: `folders/{folder_id}`
         */
        includedFolders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Names of the projects in scope.
         * Format: `projects/{project_number}`
         */
        includedProjects?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationState {
        /**
         * (Output)
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        currentIterationStates?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationState>[]>;
        /**
         * (Output)
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        previousIterationStates?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationState>[]>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationState {
        /**
         * (Output)
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationStateError>[]>;
        /**
         * (Output)
         * Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the iteration.
         * Possible values:
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationStateError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationStateErrorDetail>[]>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStateCurrentIterationStateErrorDetail {
        /**
         * (Output)
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Output)
         */
        value?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationState {
        /**
         * (Output)
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        errors?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationStateError>[]>;
        /**
         * (Output)
         * Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * State of the iteration.
         * Possible values:
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationStateError {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationStateErrorDetail>[]>;
        /**
         * (Output)
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForFolderOrchestrationStatePreviousIterationStateErrorDetail {
        /**
         * (Output)
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Output)
         */
        value?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResource {
        /**
         * Optional. ID of the resource to be used while generating set of affected resources.
         * For UPSERT action the value is auto-generated during PolicyOrchestrator
         * creation when not set. When the value is set it should following next
         * restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the project.
         * For DELETE action, ID must be specified explicitly during
         * PolicyOrchestrator creation.
         *
         *
         * <a name="nestedOrchestratedResourceOsPolicyAssignmentV1Payload"></a>The `osPolicyAssignmentV1Payload` block supports:
         */
        id?: pulumi.Input<string>;
        /**
         * OS policy assignment is an API resource that is used to
         * apply a set of OS policies to a dynamically targeted group of Compute Engine
         * VM instances.
         * An OS policy is used to define the desired state configuration for a
         * Compute Engine VM instance through a set of configuration resources that
         * provide capabilities such as installing or removing software packages, or
         * executing a script.
         * For more information about the OS policy resource definitions and examples,
         * see
         * [OS policy and OS policy
         * assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
         * Structure is documented below.
         */
        osPolicyAssignmentV1Payload?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1Payload>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1Payload {
        /**
         * Output only. Indicates that this revision has been successfully rolled out in this zone
         * and new VMs will be assigned OS policies from this revision.
         *
         * For a given OS policy assignment, there is only one revision with a value
         * of 'true' for this field.
         */
        baseline?: pulumi.Input<boolean>;
        /**
         * Output only. Indicates that this revision deletes the OS policy assignment.
         */
        deleted?: pulumi.Input<boolean>;
        /**
         * OS policy assignment description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * Output only. This checksum is computed by the server based on the value of other
         * fields, and may be sent on update and delete requests to ensure the
         * client has an up-to-date value before proceeding.
         */
        etag?: pulumi.Input<string>;
        /**
         * Filters to select target VMs for an assignment.
         *
         * If more than one filter criteria is specified below, a VM will be selected
         * if and only if it satisfies all of them.
         */
        instanceFilter: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter>;
        /**
         * Immutable. Identifier. In form of
         * * `organizations/{organization_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `folders/{folder_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `projects/{project_id_or_number}/locations/global/policyOrchestrators/{orchestrator_id}`
         */
        name?: pulumi.Input<string>;
        /**
         * Required. List of OS policies to be applied to the VMs.
         */
        osPolicies: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy>[]>;
        /**
         * Output only. Set to true, if the there are ongoing changes being applied by the
         * orchestrator.
         */
        reconciling?: pulumi.Input<boolean>;
        /**
         * Output only. The timestamp that the revision was created.
         */
        revisionCreateTime?: pulumi.Input<string>;
        /**
         * Output only. The assignment revision ID
         * A new revision is committed whenever a rollout is triggered for a OS policy
         * assignment
         */
        revisionId?: pulumi.Input<string>;
        /**
         * Message to configure the rollout at the zonal level for the OS policy
         * assignment.
         */
        rollout: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadRollout>;
        /**
         * Output only. OS policy assignment rollout state
         * Possible values:
         * ROLLOUT_STATE_UNSPECIFIED
         * IN_PROGRESS
         * CANCELLING
         * CANCELLED
         * SUCCEEDED
         */
        rolloutState?: pulumi.Input<string>;
        /**
         * Output only. Server generated unique id for the OS policy assignment resource.
         */
        uid?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter {
        /**
         * Target all VMs in the project. If true, no other criteria is
         * permitted.
         */
        all?: pulumi.Input<boolean>;
        /**
         * List of label sets used for VM exclusion.
         * If the list has more than one label set, the VM is excluded if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        exclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel>[]>;
        /**
         * List of label sets used for VM inclusion.
         * If the list has more than one `LabelSet`, the VM is included if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        inclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel>[]>;
        /**
         * List of inventories to select VMs.
         * A VM is selected if its inventory data matches at least one of the
         * following inventories.
         * Structure is documented below.
         */
        inventories?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory {
        /**
         * Required. The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy {
        /**
         * This flag determines the OS policy compliance status when none of the
         * resource groups within the policy are applicable for a VM. Set this value
         * to `true` if the policy needs to be reported as compliant even if the
         * policy has nothing to validate or enforce.
         */
        allowNoResourceGroupMatch?: pulumi.Input<boolean>;
        /**
         * Policy description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * Required. The id of the OS policy with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the assignment.
         */
        id: pulumi.Input<string>;
        /**
         * Required. Policy mode
         * Possible values:
         * MODE_UNSPECIFIED
         * VALIDATION
         * ENFORCEMENT
         */
        mode: pulumi.Input<string>;
        /**
         * Required. List of resource groups for the policy.
         * For a particular VM, resource groups are evaluated in the order specified
         * and the first resource group that is applicable is selected and the rest
         * are ignored.
         * If none of the resource groups are applicable for a VM, the VM is
         * considered to be non-compliant w.r.t this policy. This behavior can be
         * toggled by the flag `allowNoResourceGroupMatch`
         * Structure is documented below.
         */
        resourceGroups: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup {
        /**
         * List of inventory filters for the resource group.
         * The resources in this resource group are applied to the target VM if it
         * satisfies at least one of the following inventory filters.
         * For example, to apply this resource group to VMs running either `RHEL` or
         * `CentOS` operating systems, specify 2 items for the list with following
         * values:
         * inventory_filters[0].os_short_name='rhel' and
         * inventory_filters[1].os_short_name='centos'
         * If the list is empty, this resource group will be applied to the target
         * VM unconditionally.
         * Structure is documented below.
         */
        inventoryFilters?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter>[]>;
        /**
         * Required. List of resources configured for this resource group.
         * The resources are executed in the exact order specified here.
         * Structure is documented below.
         */
        resources: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter {
        /**
         * Required. The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource {
        /**
         * A resource that allows executing scripts on the VM.
         * The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
         * accept a script as an argument to execute.
         * When the `ExecResource` is applied by the agent, it first executes the
         * script in the `validate` stage. The `validate` stage can signal that the
         * `ExecResource` is already in the desired state by returning an exit code
         * of `100`. If the `ExecResource` is not in the desired state, it should
         * return an exit code of `101`. Any other exit code returned by this stage
         * is considered an error.
         * If the `ExecResource` is not in the desired state based on the exit code
         * from the `validate` stage, the agent proceeds to execute the script from
         * the `enforce` stage. If the `ExecResource` is already in the desired
         * state, the `enforce` stage will not be run.
         * Similar to `validate` stage, the `enforce` stage should return an exit
         * code of `100` to indicate that the resource in now in its desired state.
         * Any other exit code is considered an error.
         * NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
         * have an explicit indicator of `in desired state`, `not in desired state`
         * and errors. Because, for example, Powershell will always return an exit
         * code of `0` unless an `exit` statement is provided in the script. So, for
         * reasons of consistency and being explicit, exit codes `100` and `101`
         * were chosen.
         * Structure is documented below.
         */
        exec?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec>;
        /**
         * A resource that manages the state of a file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile>;
        /**
         * Required. The id of the resource with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the OS policy.
         */
        id: pulumi.Input<string>;
        /**
         * A resource that manages a system package.
         * Structure is documented below.
         */
        pkg?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg>;
        /**
         * A resource that manages a package repository.
         * Structure is documented below.
         */
        repository?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec {
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        enforce?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce>;
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        validate: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile>;
        /**
         * Required. The script interpreter to use.
         * Possible values:
         * INTERPRETER_UNSPECIFIED
         * NONE
         * SHELL
         * POWERSHELL
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile>;
        /**
         * Required. The script interpreter to use.
         * Possible values:
         * INTERPRETER_UNSPECIFIED
         * NONE
         * SHELL
         * POWERSHELL
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile {
        /**
         * A a file with this content.
         * The size of the content is limited to 32KiB.
         */
        content?: pulumi.Input<string>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile>;
        /**
         * Required. The absolute path of the file within the VM.
         */
        path: pulumi.Input<string>;
        /**
         * Consists of three octal digits which represent, in
         * order, the permissions of the owner, group, and other users for the
         * file (similarly to the numeric mode used in the linux chmod
         * utility). Each digit represents a three bit number with the 4 bit
         * corresponding to the read permissions, the 2 bit corresponds to the
         * write bit, and the one bit corresponds to the execute permission.
         * Default behavior is 755.
         * Below are some examples of permissions and their associated values:
         * read, write, and execute: 7
         * read and execute: 5
         * read and write: 6
         * read only: 4
         */
        permissions?: pulumi.Input<string>;
        /**
         * Required. Desired state of the file.
         * Possible values:
         * DESIRED_STATE_UNSPECIFIED
         * PRESENT
         * ABSENT
         * CONTENTS_MATCH
         */
        state: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg {
        /**
         * A package managed by APT.
         * - install: `apt-get update && apt-get -y install [name]`
         * - remove: `apt-get -y remove [name]`
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt>;
        /**
         * A deb package file. dpkg packages only support INSTALLED state.
         * Structure is documented below.
         */
        deb?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb>;
        /**
         * Required. The desired state the agent should maintain for this package.
         * Possible values:
         * DESIRED_STATE_UNSPECIFIED
         * INSTALLED
         * REMOVED
         */
        desiredState: pulumi.Input<string>;
        /**
         * A package managed by GooGet.
         * - install: `googet -noconfirm install package`
         * - remove: `googet -noconfirm remove package`
         * Structure is documented below.
         */
        googet?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget>;
        /**
         * An MSI package. MSI packages only support INSTALLED state.
         * Structure is documented below.
         */
        msi?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi>;
        /**
         * An RPM package file. RPM packages only support INSTALLED state.
         * Structure is documented below.
         */
        rpm?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm>;
        /**
         * A package managed by YUM.
         * - install: `yum -y install package`
         * - remove: `yum -y remove package`
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum>;
        /**
         * A package managed by Zypper.
         * - install: `zypper -y install package`
         * - remove: `zypper -y rm package`
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `dpkg -i package`
         * - install when true: `apt-get update && apt-get -y install
         * package.deb`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi {
        /**
         * Additional properties to use during installation.
         * This should be in the format of Property=Setting.
         * Appended to the defaults of `ACTION=INSTALL
         * REBOOT=ReallySuppress`.
         */
        properties?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `rpm --upgrade --replacepkgs package.rpm`
         * - install when true: `yum -y install package.rpm` or
         * `zypper -y install package.rpm`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository {
        /**
         * Represents a single apt package repository. These will be added to
         * a repo file that will be managed at
         * `/etc/apt/sources.list.d/google_osconfig.list`.
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt>;
        /**
         * Represents a Goo package repository. These are added to a repo file
         * that is managed at
         * `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
         * Structure is documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo>;
        /**
         * Represents a single yum package repository. These are added to a
         * repo file that is managed at
         * `/etc/yum.repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum>;
        /**
         * Represents a single zypper package repository. These are added to a
         * repo file that is managed at
         * `/etc/zypp/repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt {
        /**
         * Required. Type of archive files in this repository.
         * Possible values:
         * ARCHIVE_TYPE_UNSPECIFIED
         * DEB
         * DEB_SRC
         */
        archiveType: pulumi.Input<string>;
        /**
         * Required. List of components for this repository. Must contain at least one
         * item.
         */
        components: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. Distribution of this repository.
         */
        distribution: pulumi.Input<string>;
        /**
         * URI of the key file for this repository. The agent maintains a
         * keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
         */
        gpgKey?: pulumi.Input<string>;
        /**
         * Required. URI for this repository.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo {
        /**
         * Required. The name of the repository.
         */
        name: pulumi.Input<string>;
        /**
         * Required. The url of the repository.
         */
        url: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum {
        /**
         * Required. The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. A one word, unique name for this repository. This is  the `repo
         * id` in the yum config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for resource conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper {
        /**
         * Required. The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. A one word, unique name for this repository. This is the `repo
         * id` in the zypper config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for GuestPolicy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadRollout {
        /**
         * Message encapsulating a value that can be either absolute ("fixed") or
         * relative ("percent") to a value.
         * Structure is documented below.
         */
        disruptionBudget: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget>;
        /**
         * Required. This determines the minimum duration of time to wait after the
         * configuration changes are applied through the current rollout. A
         * VM continues to count towards the `disruptionBudget` at least
         * until this duration of time has passed after configuration changes are
         * applied.
         */
        minWaitDuration: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget {
        /**
         * Specifies a fixed value.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies the relative value defined as a percentage, which will be
         * multiplied by a reference value.
         *
         * - - -
         */
        percent?: pulumi.Input<number>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationScope {
        /**
         * Optional. Selectors of the orchestration scope. There is a logical AND between each
         * selector defined.
         * When there is no explicit `ResourceHierarchySelector` selector specified,
         * the scope is by default bounded to the parent of the policy orchestrator
         * resource.
         * Structure is documented below.
         */
        selectors?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationScopeSelector>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationScopeSelector {
        /**
         * Selector containing locations in scope.
         * Structure is documented below.
         */
        locationSelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationScopeSelectorLocationSelector>;
        /**
         * Selector containing Cloud Resource Manager resource hierarchy nodes.
         * Structure is documented below.
         */
        resourceHierarchySelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationScopeSelectorResourceHierarchySelector>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationScopeSelectorLocationSelector {
        /**
         * Optional. Names of the locations in scope.
         * Format: `us-central1-a`
         */
        includedLocations?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationScopeSelectorResourceHierarchySelector {
        /**
         * Optional. Names of the folders in scope.
         * Format: `folders/{folder_id}`
         */
        includedFolders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Names of the projects in scope.
         * Format: `projects/{project_number}`
         */
        includedProjects?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationState {
        /**
         * (Output)
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        currentIterationStates?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationState>[]>;
        /**
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        previousIterationState?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationState>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationState {
        /**
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        error?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationStateError>;
        /**
         * (Output)
         * Output only. Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. State of the iteration.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationStateError {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationStateErrorDetail>[]>;
        /**
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStateCurrentIterationStateErrorDetail {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Optional)
         */
        value?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationState {
        /**
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        error?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationStateError>;
        /**
         * (Output)
         * Output only. Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. State of the iteration.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationStateError {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationStateErrorDetail>[]>;
        /**
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorForOrganizationOrchestrationStatePreviousIterationStateErrorDetail {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Optional)
         */
        value?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResource {
        /**
         * Optional. ID of the resource to be used while generating set of affected resources.
         * For UPSERT action the value is auto-generated during PolicyOrchestrator
         * creation when not set. When the value is set it should following next
         * restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the project.
         * For DELETE action, ID must be specified explicitly during
         * PolicyOrchestrator creation.
         *
         *
         * <a name="nestedOrchestratedResourceOsPolicyAssignmentV1Payload"></a>The `osPolicyAssignmentV1Payload` block supports:
         */
        id?: pulumi.Input<string>;
        /**
         * OS policy assignment is an API resource that is used to
         * apply a set of OS policies to a dynamically targeted group of Compute Engine
         * VM instances.
         * An OS policy is used to define the desired state configuration for a
         * Compute Engine VM instance through a set of configuration resources that
         * provide capabilities such as installing or removing software packages, or
         * executing a script.
         * For more information about the OS policy resource definitions and examples,
         * see
         * [OS policy and OS policy
         * assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
         * Structure is documented below.
         */
        osPolicyAssignmentV1Payload?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload {
        /**
         * Output only. Indicates that this revision has been successfully rolled out in this zone
         * and new VMs will be assigned OS policies from this revision.
         *
         * For a given OS policy assignment, there is only one revision with a value
         * of 'true' for this field.
         */
        baseline?: pulumi.Input<boolean>;
        /**
         * Output only. Indicates that this revision deletes the OS policy assignment.
         */
        deleted?: pulumi.Input<boolean>;
        /**
         * OS policy assignment description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * Filters to select target VMs for an assignment.
         *
         * If more than one filter criteria is specified below, a VM will be selected
         * if and only if it satisfies all of them.
         */
        instanceFilter: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter>;
        /**
         * Immutable. Identifier. In form of
         * * `organizations/{organization_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `folders/{folder_id}/locations/global/policyOrchestrators/{orchestrator_id}`
         * * `projects/{project_id_or_number}/locations/global/policyOrchestrators/{orchestrator_id}`
         */
        name?: pulumi.Input<string>;
        /**
         * Required. List of OS policies to be applied to the VMs.
         */
        osPolicies: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy>[]>;
        /**
         * Output only. Set to true, if the there are ongoing changes being applied by the
         * orchestrator.
         */
        reconciling?: pulumi.Input<boolean>;
        /**
         * Output only. The timestamp that the revision was created.
         */
        revisionCreateTime?: pulumi.Input<string>;
        /**
         * Output only. The assignment revision ID
         * A new revision is committed whenever a rollout is triggered for a OS policy
         * assignment
         */
        revisionId?: pulumi.Input<string>;
        /**
         * Message to configure the rollout at the zonal level for the OS policy
         * assignment.
         */
        rollout: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout>;
        /**
         * Output only. OS policy assignment rollout state
         * Possible values:
         * ROLLOUT_STATE_UNSPECIFIED
         * IN_PROGRESS
         * CANCELLING
         * CANCELLED
         * SUCCEEDED
         */
        rolloutState?: pulumi.Input<string>;
        /**
         * Output only. Server generated unique id for the OS policy assignment resource.
         */
        uid?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter {
        /**
         * Target all VMs in the project. If true, no other criteria is
         * permitted.
         */
        all?: pulumi.Input<boolean>;
        /**
         * List of label sets used for VM exclusion.
         * If the list has more than one label set, the VM is excluded if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        exclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel>[]>;
        /**
         * List of label sets used for VM inclusion.
         * If the list has more than one `LabelSet`, the VM is included if any
         * of the label sets are applicable for the VM.
         * Structure is documented below.
         */
        inclusionLabels?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel>[]>;
        /**
         * List of inventories to select VMs.
         * A VM is selected if its inventory data matches at least one of the
         * following inventories.
         * Structure is documented below.
         */
        inventories?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory>[]>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabel {
        /**
         * Labels are identified by key/value pairs in this map.
         * A VM should contain all the key/value pairs specified in this
         * map to be selected.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventory {
        /**
         * Required. The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicy {
        /**
         * This flag determines the OS policy compliance status when none of the
         * resource groups within the policy are applicable for a VM. Set this value
         * to `true` if the policy needs to be reported as compliant even if the
         * policy has nothing to validate or enforce.
         */
        allowNoResourceGroupMatch?: pulumi.Input<boolean>;
        /**
         * Policy description.
         * Length of the description is limited to 1024 characters.
         */
        description?: pulumi.Input<string>;
        /**
         * Required. The id of the OS policy with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the assignment.
         */
        id: pulumi.Input<string>;
        /**
         * Required. Policy mode
         * Possible values:
         * MODE_UNSPECIFIED
         * VALIDATION
         * ENFORCEMENT
         */
        mode: pulumi.Input<string>;
        /**
         * Required. List of resource groups for the policy.
         * For a particular VM, resource groups are evaluated in the order specified
         * and the first resource group that is applicable is selected and the rest
         * are ignored.
         * If none of the resource groups are applicable for a VM, the VM is
         * considered to be non-compliant w.r.t this policy. This behavior can be
         * toggled by the flag `allowNoResourceGroupMatch`
         * Structure is documented below.
         */
        resourceGroups: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup>[]>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroup {
        /**
         * List of inventory filters for the resource group.
         * The resources in this resource group are applied to the target VM if it
         * satisfies at least one of the following inventory filters.
         * For example, to apply this resource group to VMs running either `RHEL` or
         * `CentOS` operating systems, specify 2 items for the list with following
         * values:
         * inventory_filters[0].os_short_name='rhel' and
         * inventory_filters[1].os_short_name='centos'
         * If the list is empty, this resource group will be applied to the target
         * VM unconditionally.
         * Structure is documented below.
         */
        inventoryFilters?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter>[]>;
        /**
         * Required. List of resources configured for this resource group.
         * The resources are executed in the exact order specified here.
         * Structure is documented below.
         */
        resources: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource>[]>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupInventoryFilter {
        /**
         * Required. The OS short name
         */
        osShortName: pulumi.Input<string>;
        /**
         * The OS version
         * Prefix matches are supported if asterisk(*) is provided as the
         * last character. For example, to match all versions with a major
         * version of `7`, specify the following value for this field `7.*`
         * An empty string matches all OS versions.
         */
        osVersion?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResource {
        /**
         * A resource that allows executing scripts on the VM.
         * The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
         * accept a script as an argument to execute.
         * When the `ExecResource` is applied by the agent, it first executes the
         * script in the `validate` stage. The `validate` stage can signal that the
         * `ExecResource` is already in the desired state by returning an exit code
         * of `100`. If the `ExecResource` is not in the desired state, it should
         * return an exit code of `101`. Any other exit code returned by this stage
         * is considered an error.
         * If the `ExecResource` is not in the desired state based on the exit code
         * from the `validate` stage, the agent proceeds to execute the script from
         * the `enforce` stage. If the `ExecResource` is already in the desired
         * state, the `enforce` stage will not be run.
         * Similar to `validate` stage, the `enforce` stage should return an exit
         * code of `100` to indicate that the resource in now in its desired state.
         * Any other exit code is considered an error.
         * NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
         * have an explicit indicator of `in desired state`, `not in desired state`
         * and errors. Because, for example, Powershell will always return an exit
         * code of `0` unless an `exit` statement is provided in the script. So, for
         * reasons of consistency and being explicit, exit codes `100` and `101`
         * were chosen.
         * Structure is documented below.
         */
        exec?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec>;
        /**
         * A resource that manages the state of a file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile>;
        /**
         * Required. The id of the resource with the following restrictions:
         * * Must contain only lowercase letters, numbers, and hyphens.
         * * Must start with a letter.
         * * Must be between 1-63 characters.
         * * Must end with a number or a letter.
         * * Must be unique within the OS policy.
         */
        id: pulumi.Input<string>;
        /**
         * A resource that manages a system package.
         * Structure is documented below.
         */
        pkg?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg>;
        /**
         * A resource that manages a package repository.
         * Structure is documented below.
         */
        repository?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExec {
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        enforce?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce>;
        /**
         * A file or script to execute.
         * Structure is documented below.
         */
        validate: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforce {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile>;
        /**
         * Required. The script interpreter to use.
         * Possible values:
         * INTERPRETER_UNSPECIFIED
         * NONE
         * SHELL
         * POWERSHELL
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecEnforceFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidate {
        /**
         * Optional arguments to pass to the source during execution.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile>;
        /**
         * Required. The script interpreter to use.
         * Possible values:
         * INTERPRETER_UNSPECIFIED
         * NONE
         * SHELL
         * POWERSHELL
         */
        interpreter: pulumi.Input<string>;
        /**
         * Only recorded for enforce Exec.
         * Path to an output file (that is created by this Exec) whose
         * content will be recorded in OSPolicyResourceCompliance after a
         * successful run. Absence or failure to read this file will result in
         * this ExecResource being non-compliant. Output file size is limited to
         * 500K bytes.
         */
        outputFilePath?: pulumi.Input<string>;
        /**
         * An inline script.
         * The size of the script is limited to 32KiB.
         */
        script?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceExecValidateFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFile {
        /**
         * A a file with this content.
         * The size of the content is limited to 32KiB.
         */
        content?: pulumi.Input<string>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        file?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile>;
        /**
         * Required. The absolute path of the file within the VM.
         */
        path: pulumi.Input<string>;
        /**
         * Consists of three octal digits which represent, in
         * order, the permissions of the owner, group, and other users for the
         * file (similarly to the numeric mode used in the linux chmod
         * utility). Each digit represents a three bit number with the 4 bit
         * corresponding to the read permissions, the 2 bit corresponds to the
         * write bit, and the one bit corresponds to the execute permission.
         * Default behavior is 755.
         * Below are some examples of permissions and their associated values:
         * read, write, and execute: 7
         * read and execute: 5
         * read and write: 6
         * read only: 4
         */
        permissions?: pulumi.Input<string>;
        /**
         * Required. Desired state of the file.
         * Possible values:
         * DESIRED_STATE_UNSPECIFIED
         * PRESENT
         * ABSENT
         * CONTENTS_MATCH
         */
        state: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFile {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceFileFileRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkg {
        /**
         * A package managed by APT.
         * - install: `apt-get update && apt-get -y install [name]`
         * - remove: `apt-get -y remove [name]`
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt>;
        /**
         * A deb package file. dpkg packages only support INSTALLED state.
         * Structure is documented below.
         */
        deb?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb>;
        /**
         * Required. The desired state the agent should maintain for this package.
         * Possible values:
         * DESIRED_STATE_UNSPECIFIED
         * INSTALLED
         * REMOVED
         */
        desiredState: pulumi.Input<string>;
        /**
         * A package managed by GooGet.
         * - install: `googet -noconfirm install package`
         * - remove: `googet -noconfirm remove package`
         * Structure is documented below.
         */
        googet?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget>;
        /**
         * An MSI package. MSI packages only support INSTALLED state.
         * Structure is documented below.
         */
        msi?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi>;
        /**
         * An RPM package file. RPM packages only support INSTALLED state.
         * Structure is documented below.
         */
        rpm?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm>;
        /**
         * A package managed by YUM.
         * - install: `yum -y install package`
         * - remove: `yum -y remove package`
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum>;
        /**
         * A package managed by Zypper.
         * - install: `zypper -y install package`
         * - remove: `zypper -y rm package`
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgApt {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDeb {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `dpkg -i package`
         * - install when true: `apt-get update && apt-get -y install
         * package.deb`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgDebSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgGooget {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsi {
        /**
         * Additional properties to use during installation.
         * This should be in the format of Property=Setting.
         * Appended to the defaults of `ACTION=INSTALL
         * REBOOT=ReallySuppress`.
         */
        properties?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgMsiSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpm {
        /**
         * Whether dependencies should also be installed.
         * - install when false: `rpm --upgrade --replacepkgs package.rpm`
         * - install when true: `yum -y install package.rpm` or
         * `zypper -y install package.rpm`
         */
        pullDeps?: pulumi.Input<boolean>;
        /**
         * A remote or local file.
         * Structure is documented below.
         */
        source: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSource {
        /**
         * Defaults to false. When false, files are subject to validations
         * based on the file type:
         * Remote: A checksum must be specified.
         * Cloud Storage: An object generation number must be specified.
         */
        allowInsecure?: pulumi.Input<boolean>;
        /**
         * Specifies a file available as a Cloud Storage Object.
         * Structure is documented below.
         */
        gcs?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs>;
        /**
         * A local path within the VM to use.
         */
        localPath?: pulumi.Input<string>;
        /**
         * Specifies a file available via some URI.
         * Structure is documented below.
         */
        remote?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceGcs {
        /**
         * Required. Bucket of the Cloud Storage object.
         */
        bucket: pulumi.Input<string>;
        /**
         * Generation number of the Cloud Storage object.
         */
        generation?: pulumi.Input<string>;
        /**
         * Required. Name of the Cloud Storage object.
         */
        object: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgRpmSourceRemote {
        /**
         * SHA256 checksum of the remote file.
         */
        sha256Checksum?: pulumi.Input<string>;
        /**
         * Required. URI from which to fetch the object. It should contain both the
         * protocol and path following the format `{protocol}://{location}`.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgYum {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourcePkgZypper {
        /**
         * Required. Package name.
         */
        name: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepository {
        /**
         * Represents a single apt package repository. These will be added to
         * a repo file that will be managed at
         * `/etc/apt/sources.list.d/google_osconfig.list`.
         * Structure is documented below.
         */
        apt?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt>;
        /**
         * Represents a Goo package repository. These are added to a repo file
         * that is managed at
         * `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
         * Structure is documented below.
         */
        goo?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo>;
        /**
         * Represents a single yum package repository. These are added to a
         * repo file that is managed at
         * `/etc/yum.repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        yum?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum>;
        /**
         * Represents a single zypper package repository. These are added to a
         * repo file that is managed at
         * `/etc/zypp/repos.d/google_osconfig.repo`.
         * Structure is documented below.
         */
        zypper?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryApt {
        /**
         * Required. Type of archive files in this repository.
         * Possible values:
         * ARCHIVE_TYPE_UNSPECIFIED
         * DEB
         * DEB_SRC
         */
        archiveType: pulumi.Input<string>;
        /**
         * Required. List of components for this repository. Must contain at least one
         * item.
         */
        components: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. Distribution of this repository.
         */
        distribution: pulumi.Input<string>;
        /**
         * URI of the key file for this repository. The agent maintains a
         * keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
         */
        gpgKey?: pulumi.Input<string>;
        /**
         * Required. URI for this repository.
         */
        uri: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryGoo {
        /**
         * Required. The name of the repository.
         */
        name: pulumi.Input<string>;
        /**
         * Required. The url of the repository.
         */
        url: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryYum {
        /**
         * Required. The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. A one word, unique name for this repository. This is  the `repo
         * id` in the yum config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for resource conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicyResourceGroupResourceRepositoryZypper {
        /**
         * Required. The location of the repository directory.
         */
        baseUrl: pulumi.Input<string>;
        /**
         * The display name of the repository.
         */
        displayName?: pulumi.Input<string>;
        /**
         * URIs of GPG keys.
         */
        gpgKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required. A one word, unique name for this repository. This is the `repo
         * id` in the zypper config file and also the `displayName` if
         * `displayName` is omitted. This id is also used as the unique
         * identifier when checking for GuestPolicy conflicts.
         */
        id: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout {
        /**
         * Message encapsulating a value that can be either absolute ("fixed") or
         * relative ("percent") to a value.
         * Structure is documented below.
         */
        disruptionBudget: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget>;
        /**
         * Required. This determines the minimum duration of time to wait after the
         * configuration changes are applied through the current rollout. A
         * VM continues to count towards the `disruptionBudget` at least
         * until this duration of time has passed after configuration changes are
         * applied.
         */
        minWaitDuration: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget {
        /**
         * Specifies a fixed value.
         */
        fixed?: pulumi.Input<number>;
        /**
         * Specifies the relative value defined as a percentage, which will be
         * multiplied by a reference value.
         *
         * - - -
         */
        percent?: pulumi.Input<number>;
    }

    export interface V2PolicyOrchestratorOrchestrationScope {
        /**
         * Optional. Selectors of the orchestration scope. There is a logical AND between each
         * selector defined.
         * When there is no explicit `ResourceHierarchySelector` selector specified,
         * the scope is by default bounded to the parent of the policy orchestrator
         * resource.
         * Structure is documented below.
         */
        selectors?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationScopeSelector>[]>;
    }

    export interface V2PolicyOrchestratorOrchestrationScopeSelector {
        /**
         * Selector containing locations in scope.
         * Structure is documented below.
         */
        locationSelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationScopeSelectorLocationSelector>;
        /**
         * Selector containing Cloud Resource Manager resource hierarchy nodes.
         * Structure is documented below.
         */
        resourceHierarchySelector?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationScopeSelectorResourceHierarchySelector>;
    }

    export interface V2PolicyOrchestratorOrchestrationScopeSelectorLocationSelector {
        /**
         * Optional. Names of the locations in scope.
         * Format: `us-central1-a`
         */
        includedLocations?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorOrchestrationScopeSelectorResourceHierarchySelector {
        /**
         * Optional. Names of the folders in scope.
         * Format: `folders/{folder_id}`
         */
        includedFolders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Names of the projects in scope.
         * Format: `projects/{project_number}`
         */
        includedProjects?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2PolicyOrchestratorOrchestrationState {
        /**
         * (Output)
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        currentIterationStates?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStateCurrentIterationState>[]>;
        /**
         * Describes the state of a single iteration of the orchestrator.
         * Structure is documented below.
         */
        previousIterationState?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStatePreviousIterationState>;
    }

    export interface V2PolicyOrchestratorOrchestrationStateCurrentIterationState {
        /**
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        error?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStateCurrentIterationStateError>;
        /**
         * (Output)
         * Output only. Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. State of the iteration.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestrationStateCurrentIterationStateError {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetail>[]>;
        /**
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetail {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Optional)
         */
        value?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestrationStatePreviousIterationState {
        /**
         * The `Status` type defines a logical error model that is suitable for
         * different programming environments, including REST APIs and RPC APIs. It is
         * used by [gRPC](https://github.com/grpc). Each `Status` message contains
         * three pieces of data: error code, error message, and error details.
         * You can find out more about this error model and how to work with it in the
         * [API Design Guide](https://cloud.google.com/apis/design/errors).
         * Structure is documented below.
         */
        error?: pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStatePreviousIterationStateError>;
        /**
         * (Output)
         * Output only. Number of orchestration actions which failed so far. For more details,
         * query the Cloud Logs.
         */
        failedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Finish time of the wave iteration.
         */
        finishTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Overall number of actions done by the orchestrator so far.
         */
        performedActions?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. An estimated percentage of the progress. Number between 0 and 100.
         */
        progress?: pulumi.Input<number>;
        /**
         * (Output)
         * Output only. Handle to the Progressive Rollouts API rollout resource, which contains
         * detailed information about a particular orchestration iteration.
         */
        rolloutResource?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Start time of the wave iteration.
         */
        startTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. State of the iteration.
         * Possible values:
         * STATE_UNSPECIFIED
         * PROCESSING
         * COMPLETED
         * FAILED
         * CANCELLED
         * UNKNOWN
         */
        state?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestrationStatePreviousIterationStateError {
        /**
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * A list of messages that carry the error details.  There is a common set of
         * message types for APIs to use.
         * Structure is documented below.
         */
        details?: pulumi.Input<pulumi.Input<inputs.osconfig.V2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetail>[]>;
        /**
         * A developer-facing error message, which should be in English. Any
         * user-facing error message should be localized and sent in the
         * google.rpc.Status.details field, or localized by the client.
         */
        message?: pulumi.Input<string>;
    }

    export interface V2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetail {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message
         */
        typeUrl?: pulumi.Input<string>;
        /**
         * (Optional)
         */
        value?: pulumi.Input<string>;
    }
}

export namespace parametermanager {
    export interface ParameterPolicyMember {
        /**
         * (Output)
         * IAM policy binding member referring to a Google Cloud resource by user-assigned name. If a
         * resource is deleted and recreated with the same name, the binding will be applicable to the
         * new resource. Format:
         * `principal://parametermanager.googleapis.com/projects/{{project}}/name/locations/global/parameters/{{parameter_id}}`
         */
        iamPolicyNamePrincipal?: pulumi.Input<string>;
        /**
         * (Output)
         * IAM policy binding member referring to a Google Cloud resource by system-assigned unique identifier.
         * If a resource is deleted and recreated with the same name, the binding will not be applicable to the
         * new resource. Format:
         * `principal://parametermanager.googleapis.com/projects/{{project}}/uid/locations/global/parameters/{{uid}}`
         */
        iamPolicyUidPrincipal?: pulumi.Input<string>;
    }

    export interface RegionalParameterPolicyMember {
        /**
         * (Output)
         * IAM policy binding member referring to a Google Cloud resource by user-assigned name. If a resource is
         * deleted and recreated with the same name, the binding will be applicable to the new resource. Format:
         * `principal://parametermanager.googleapis.com/projects/{{project}}/name/locations/{{location}}/parameters/{{parameter_id}}`
         */
        iamPolicyNamePrincipal?: pulumi.Input<string>;
        /**
         * (Output)
         * IAM policy binding member referring to a Google Cloud resource by system-assigned unique identifier. If
         * a resource is deleted and recreated with the same name, the binding will not be applicable to the new
         * resource. Format:
         * `principal://parametermanager.googleapis.com/projects/{{project}}/uid/locations/{{location}}/parameters/{{uid}}`
         */
        iamPolicyUidPrincipal?: pulumi.Input<string>;
    }
}

export namespace privilegedaccessmanager {
    export interface EntitlementAdditionalNotificationTargets {
        /**
         * Optional. Additional email addresses to be notified when a principal(requester) is granted access.
         */
        adminEmailRecipients?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Optional. Additional email address to be notified about an eligible entitlement.
         */
        requesterEmailRecipients?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EntitlementApprovalWorkflow {
        /**
         * A manual approval workflow where users who are designated as approvers need to call the ApproveGrant/DenyGrant APIs for an Grant.
         * The workflow can consist of multiple serial steps where each step defines who can act as Approver in that step and how many of those users should approve before the workflow moves to the next step.
         * This can be used to create approval workflows such as
         * * Require an approval from any user in a group G.
         * * Require an approval from any k number of users from a Group G.
         * * Require an approval from any user in a group G and then from a user U. etc.
         * A single user might be part of `approvers` ACL for multiple steps in this workflow but they can only approve once and that approval will only be considered to satisfy the approval step at which it was granted.
         * Structure is documented below.
         */
        manualApprovals: pulumi.Input<inputs.privilegedaccessmanager.EntitlementApprovalWorkflowManualApprovals>;
    }

    export interface EntitlementApprovalWorkflowManualApprovals {
        /**
         * Optional. Do the approvers need to provide a justification for their actions?
         */
        requireApproverJustification?: pulumi.Input<boolean>;
        /**
         * List of approval steps in this workflow. These steps would be followed in the specified order sequentially.  1 step is supported for now.
         * Structure is documented below.
         */
        steps: pulumi.Input<pulumi.Input<inputs.privilegedaccessmanager.EntitlementApprovalWorkflowManualApprovalsStep>[]>;
    }

    export interface EntitlementApprovalWorkflowManualApprovalsStep {
        /**
         * How many users from the above list need to approve.
         * If there are not enough distinct users in the list above then the workflow
         * will indefinitely block. Should always be greater than 0. Currently 1 is the only
         * supported value.
         */
        approvalsNeeded?: pulumi.Input<number>;
        /**
         * Optional. Additional email addresses to be notified when a grant is pending approval.
         */
        approverEmailRecipients?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The potential set of approvers in this step. This list should contain at only one entry.
         * Structure is documented below.
         */
        approvers: pulumi.Input<inputs.privilegedaccessmanager.EntitlementApprovalWorkflowManualApprovalsStepApprovers>;
    }

    export interface EntitlementApprovalWorkflowManualApprovalsStepApprovers {
        /**
         * Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at: https://cloud.google.com/iam/docs/principal-identifiers#v1
         */
        principals: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EntitlementEligibleUser {
        /**
         * Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at "https://cloud.google.com/iam/docs/principal-identifiers#v1"
         */
        principals: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EntitlementPrivilegedAccess {
        /**
         * GcpIamAccess represents IAM based access control on a GCP resource. Refer to https://cloud.google.com/iam/docs to understand more about IAM.
         * Structure is documented below.
         */
        gcpIamAccess: pulumi.Input<inputs.privilegedaccessmanager.EntitlementPrivilegedAccessGcpIamAccess>;
    }

    export interface EntitlementPrivilegedAccessGcpIamAccess {
        /**
         * Name of the resource.
         */
        resource: pulumi.Input<string>;
        /**
         * The type of this resource.
         */
        resourceType: pulumi.Input<string>;
        /**
         * Role bindings to be created on successful grant.
         * Structure is documented below.
         */
        roleBindings: pulumi.Input<pulumi.Input<inputs.privilegedaccessmanager.EntitlementPrivilegedAccessGcpIamAccessRoleBinding>[]>;
    }

    export interface EntitlementPrivilegedAccessGcpIamAccessRoleBinding {
        /**
         * The expression field of the IAM condition to be associated with the role. If specified, a user with an active grant for this entitlement would be able to access the resource only if this condition evaluates to true for their request.
         * https://cloud.google.com/iam/docs/conditions-overview#attributes.
         */
        conditionExpression?: pulumi.Input<string>;
        /**
         * IAM role to be granted. https://cloud.google.com/iam/docs/roles-overview.
         */
        role: pulumi.Input<string>;
    }

    export interface EntitlementRequesterJustificationConfig {
        /**
         * The justification is not mandatory but can be provided in any of the supported formats.
         */
        notMandatory?: pulumi.Input<inputs.privilegedaccessmanager.EntitlementRequesterJustificationConfigNotMandatory>;
        /**
         * The requester has to provide a justification in the form of free flowing text.
         *
         * - - -
         */
        unstructured?: pulumi.Input<inputs.privilegedaccessmanager.EntitlementRequesterJustificationConfigUnstructured>;
    }

    export interface EntitlementRequesterJustificationConfigNotMandatory {
    }

    export interface EntitlementRequesterJustificationConfigUnstructured {
    }

}

export namespace projects {
    export interface AccessApprovalSettingsEnrolledService {
        /**
         * The product for which Access Approval will be enrolled. Allowed values are listed (case-sensitive):
         * all
         * appengine.googleapis.com
         * bigquery.googleapis.com
         * bigtable.googleapis.com
         * cloudkms.googleapis.com
         * compute.googleapis.com
         * dataflow.googleapis.com
         * iam.googleapis.com
         * pubsub.googleapis.com
         * storage.googleapis.com
         */
        cloudProduct: pulumi.Input<string>;
        /**
         * The enrollment level of the service.
         * Default value is `BLOCK_ALL`.
         * Possible values are: `BLOCK_ALL`.
         *
         * - - -
         */
        enrollmentLevel?: pulumi.Input<string>;
    }

    export interface ApiKeyRestrictions {
        /**
         * The Android apps that are allowed to use the key.
         */
        androidKeyRestrictions?: pulumi.Input<inputs.projects.ApiKeyRestrictionsAndroidKeyRestrictions>;
        /**
         * A restriction for a specific service and optionally one or more specific methods. Requests are allowed if they match any of these restrictions. If no restrictions are specified, all targets are allowed.
         */
        apiTargets?: pulumi.Input<pulumi.Input<inputs.projects.ApiKeyRestrictionsApiTarget>[]>;
        /**
         * The HTTP referrers (websites) that are allowed to use the key.
         */
        browserKeyRestrictions?: pulumi.Input<inputs.projects.ApiKeyRestrictionsBrowserKeyRestrictions>;
        /**
         * The iOS apps that are allowed to use the key.
         */
        iosKeyRestrictions?: pulumi.Input<inputs.projects.ApiKeyRestrictionsIosKeyRestrictions>;
        /**
         * The IP addresses of callers that are allowed to use the key.
         */
        serverKeyRestrictions?: pulumi.Input<inputs.projects.ApiKeyRestrictionsServerKeyRestrictions>;
    }

    export interface ApiKeyRestrictionsAndroidKeyRestrictions {
        /**
         * A list of Android applications that are allowed to make API calls with this key.
         */
        allowedApplications: pulumi.Input<pulumi.Input<inputs.projects.ApiKeyRestrictionsAndroidKeyRestrictionsAllowedApplication>[]>;
    }

    export interface ApiKeyRestrictionsAndroidKeyRestrictionsAllowedApplication {
        /**
         * The package name of the application.
         */
        packageName: pulumi.Input<string>;
        /**
         * The SHA1 fingerprint of the application. For example, both sha1 formats are acceptable : DA:39:A3:EE:5E:6B:4B:0D:32:55:BF:EF:95:60:18:90:AF:D8:07:09 or DA39A3EE5E6B4B0D3255BFEF95601890AFD80709. Output format is the latter.
         */
        sha1Fingerprint: pulumi.Input<string>;
    }

    export interface ApiKeyRestrictionsApiTarget {
        /**
         * Optional. List of one or more methods that can be called. If empty, all methods for the service are allowed. A wildcard (*) can be used as the last symbol. Valid examples: `google.cloud.translate.v2.TranslateService.GetSupportedLanguage` `TranslateText` `Get*` `translate.googleapis.com.Get*`
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The service for this restriction. It should be the canonical service name, for example: `translate.googleapis.com`. You can use `gcloud services list` to get a list of services that are enabled in the project.
         */
        service: pulumi.Input<string>;
    }

    export interface ApiKeyRestrictionsBrowserKeyRestrictions {
        /**
         * A list of regular expressions for the referrer URLs that are allowed to make API calls with this key.
         */
        allowedReferrers: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApiKeyRestrictionsIosKeyRestrictions {
        /**
         * A list of bundle IDs that are allowed when making API calls with this key.
         */
        allowedBundleIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApiKeyRestrictionsServerKeyRestrictions {
        /**
         * A list of the caller IP addresses that are allowed to make API calls with this key.
         */
        allowedIps: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface IAMAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.  The format is the same as that for `members`.
         */
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: pulumi.Input<string>;
    }

    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        /**
         * or `deny` - (Optional) One or the other must be set.
         */
        allow?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyAllow>;
        /**
         * One or the other must be set.
         */
        deny?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyDeny>;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         *
         * The `allow` or `deny` blocks support:
         */
        inheritFromParent?: pulumi.Input<boolean>;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: pulumi.Input<boolean>;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: pulumi.Input<boolean>;
    }
}

export namespace pubsub {
    export interface LiteSubscriptionDeliveryConfig {
        /**
         * When this subscription should send messages to subscribers relative to messages persistence in storage.
         * Possible values are: `DELIVER_IMMEDIATELY`, `DELIVER_AFTER_STORED`, `DELIVERY_REQUIREMENT_UNSPECIFIED`.
         */
        deliveryRequirement: pulumi.Input<string>;
    }

    export interface LiteTopicPartitionConfig {
        /**
         * The capacity configuration.
         * Structure is documented below.
         */
        capacity?: pulumi.Input<inputs.pubsub.LiteTopicPartitionConfigCapacity>;
        /**
         * The number of partitions in the topic. Must be at least 1.
         */
        count: pulumi.Input<number>;
    }

    export interface LiteTopicPartitionConfigCapacity {
        /**
         * Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
         */
        publishMibPerSec: pulumi.Input<number>;
        /**
         * Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
         */
        subscribeMibPerSec: pulumi.Input<number>;
    }

    export interface LiteTopicReservationConfig {
        /**
         * The Reservation to use for this topic's throughput capacity.
         */
        throughputReservation?: pulumi.Input<string>;
    }

    export interface LiteTopicRetentionConfig {
        /**
         * The provisioned storage, in bytes, per partition. If the number of bytes stored
         * in any of the topic's partitions grows beyond this value, older messages will be
         * dropped to make room for newer ones, regardless of the value of period.
         */
        perPartitionBytes: pulumi.Input<string>;
        /**
         * How long a published message is retained. If unset, messages will be retained as
         * long as the bytes retained for each partition is below perPartitionBytes. A
         * duration in seconds with up to nine fractional digits, terminated by 's'.
         * Example: "3.5s".
         */
        period?: pulumi.Input<string>;
    }

    export interface SchemaIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SchemaIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionBigqueryConfig {
        /**
         * When true and useTopicSchema or useTableSchema is true, any fields that are a part of the topic schema or message schema that
         * are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
         * and any messages with extra fields are not written and remain in the subscription's backlog.
         */
        dropUnknownFields?: pulumi.Input<boolean>;
        /**
         * The service account to use to write to BigQuery. If not specified, the Pub/Sub
         * [service agent](https://cloud.google.com/iam/docs/service-agents),
         * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
         */
        table: pulumi.Input<string>;
        /**
         * When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
         * must be published in JSON format. Only one of useTopicSchema and useTableSchema can be set.
         */
        useTableSchema?: pulumi.Input<boolean>;
        /**
         * When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
         * Only one of useTopicSchema and useTableSchema can be set.
         */
        useTopicSchema?: pulumi.Input<boolean>;
        /**
         * When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
         * The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
         */
        writeMetadata?: pulumi.Input<boolean>;
    }

    export interface SubscriptionCloudStorageConfig {
        /**
         * If set, message data will be written to Cloud Storage in Avro format.
         * Structure is documented below.
         */
        avroConfig?: pulumi.Input<inputs.pubsub.SubscriptionCloudStorageConfigAvroConfig>;
        /**
         * User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
         */
        bucket: pulumi.Input<string>;
        /**
         * User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
         */
        filenameDatetimeFormat?: pulumi.Input<string>;
        /**
         * User-provided prefix for Cloud Storage filename.
         */
        filenamePrefix?: pulumi.Input<string>;
        /**
         * User-provided suffix for Cloud Storage filename. Must not end in "/".
         */
        filenameSuffix?: pulumi.Input<string>;
        /**
         * The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
         * The maxBytes limit may be exceeded in cases where messages are larger than the limit.
         */
        maxBytes?: pulumi.Input<number>;
        /**
         * The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
         * May not exceed the subscription's acknowledgement deadline.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        maxDuration?: pulumi.Input<string>;
        /**
         * The maximum messages that can be written to a Cloud Storage file before a new file is created. Min 1000 messages.
         */
        maxMessages?: pulumi.Input<number>;
        /**
         * The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
         * [service agent](https://cloud.google.com/iam/docs/service-agents),
         * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * (Output)
         * An output-only field that indicates whether or not the subscription can receive messages.
         */
        state?: pulumi.Input<string>;
    }

    export interface SubscriptionCloudStorageConfigAvroConfig {
        /**
         * When true, the output Cloud Storage file will be serialized using the topic schema, if it exists.
         */
        useTopicSchema?: pulumi.Input<boolean>;
        /**
         * When true, write the subscription name, messageId, publishTime, attributes, and orderingKey as additional fields in the output.
         */
        writeMetadata?: pulumi.Input<boolean>;
    }

    export interface SubscriptionDeadLetterPolicy {
        /**
         * The name of the topic to which dead letter messages should be published.
         * Format is `projects/{project}/topics/{topic}`.
         * The Cloud Pub/Sub service account associated with the enclosing subscription's
         * parent project (i.e.,
         * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
         * permission to Publish() to this topic.
         * The operation will fail if the topic does not exist.
         * Users should ensure that there is a subscription attached to this topic
         * since messages published to a topic with no subscriptions are lost.
         */
        deadLetterTopic?: pulumi.Input<string>;
        /**
         * The maximum number of delivery attempts for any message. The value must be
         * between 5 and 100.
         * The number of delivery attempts is defined as 1 + (the sum of number of
         * NACKs and number of times the acknowledgement deadline has been exceeded for the message).
         * A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
         * client libraries may automatically extend ack_deadlines.
         * This field will be honored on a best effort basis.
         * If this parameter is 0, a default value of 5 is used.
         */
        maxDeliveryAttempts?: pulumi.Input<number>;
    }

    export interface SubscriptionExpirationPolicy {
        /**
         * Specifies the "time-to-live" duration for an associated resource. The
         * resource expires if it is not active for a period of ttl.
         * If ttl is set to "", the associated resource never expires.
         * A duration in seconds with up to nine fractional digits, terminated by 's'.
         * Example - "3.5s".
         */
        ttl: pulumi.Input<string>;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfig {
        /**
         * Endpoint configuration attributes.
         * Every endpoint has a set of API supported attributes that can
         * be used to control different aspects of the message delivery.
         * The currently supported attribute is x-goog-version, which you
         * can use to change the format of the pushed message. This
         * attribute indicates the version of the data expected by
         * the endpoint. This controls the shape of the pushed message
         * (i.e., its fields and metadata). The endpoint version is
         * based on the version of the Pub/Sub API.
         * If not present during the subscriptions.create call,
         * it will default to the version of the API used to make
         * such call. If not present during a subscriptions.modifyPushConfig
         * call, its value will not be changed. subscriptions.get
         * calls will always return a valid version, even if the
         * subscription was created without this attribute.
         * The possible values for this attribute are:
         * - v1beta1: uses the push format defined in the v1beta1 Pub/Sub API.
         * - v1 or v1beta2: uses the push format defined in the v1 Pub/Sub API.
         */
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * When set, the payload to the push endpoint is not wrapped.Sets the
         * `data` field as the HTTP body for delivery.
         * Structure is documented below.
         */
        noWrapper?: pulumi.Input<inputs.pubsub.SubscriptionPushConfigNoWrapper>;
        /**
         * If specified, Pub/Sub will generate and attach an OIDC JWT token as
         * an Authorization header in the HTTP request for every pushed message.
         * Structure is documented below.
         */
        oidcToken?: pulumi.Input<inputs.pubsub.SubscriptionPushConfigOidcToken>;
        /**
         * A URL locating the endpoint to which messages should be pushed.
         * For example, a Webhook endpoint might use
         * "https://example.com/push".
         */
        pushEndpoint: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfigNoWrapper {
        /**
         * When true, writes the Pub/Sub message metadata to
         * `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
         * Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
         */
        writeMetadata: pulumi.Input<boolean>;
    }

    export interface SubscriptionPushConfigOidcToken {
        /**
         * Audience to be used when generating OIDC token. The audience claim
         * identifies the recipients that the JWT is intended for. The audience
         * value is a single case-sensitive string. Having multiple values (array)
         * for the audience field is not supported. More info about the OIDC JWT
         * token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
         * Note: if not specified, the Push endpoint URL will be used.
         */
        audience?: pulumi.Input<string>;
        /**
         * Service account email to be used for generating the OIDC token.
         * The caller (for subscriptions.create, subscriptions.patch, and
         * subscriptions.modifyPushConfig RPCs) must have the
         * iam.serviceAccounts.actAs permission for the service account.
         */
        serviceAccountEmail: pulumi.Input<string>;
    }

    export interface SubscriptionRetryPolicy {
        /**
         * The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maximumBackoff?: pulumi.Input<string>;
        /**
         * The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minimumBackoff?: pulumi.Input<string>;
    }

    export interface TopicIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettings {
        /**
         * Settings for ingestion from Amazon Kinesis Data Streams.
         * Structure is documented below.
         */
        awsKinesis?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsAwsKinesis>;
        /**
         * Settings for ingestion from Amazon Managed Streaming for Apache Kafka.
         * Structure is documented below.
         */
        awsMsk?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsAwsMsk>;
        /**
         * Settings for ingestion from Azure Event Hubs.
         * Structure is documented below.
         */
        azureEventHubs?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsAzureEventHubs>;
        /**
         * Settings for ingestion from Cloud Storage.
         * Structure is documented below.
         */
        cloudStorage?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsCloudStorage>;
        /**
         * Settings for ingestion from Confluent Cloud.
         * Structure is documented below.
         */
        confluentCloud?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsConfluentCloud>;
        /**
         * Settings for Platform Logs regarding ingestion to Pub/Sub. If unset,
         * no Platform Logs will be generated.'
         * Structure is documented below.
         */
        platformLogsSettings?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsPlatformLogsSettings>;
    }

    export interface TopicIngestionDataSourceSettingsAwsKinesis {
        /**
         * AWS role ARN to be used for Federated Identity authentication with
         * Kinesis. Check the Pub/Sub docs for how to set up this role and the
         * required permissions that need to be attached to it.
         */
        awsRoleArn: pulumi.Input<string>;
        /**
         * The Kinesis consumer ARN to used for ingestion in
         * Enhanced Fan-Out mode. The consumer must be already
         * created and ready to be used.
         */
        consumerArn: pulumi.Input<string>;
        /**
         * The GCP service account to be used for Federated Identity authentication
         * with Kinesis (via a `AssumeRoleWithWebIdentity` call for the provided
         * role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
         * equals to this service account number.
         */
        gcpServiceAccount: pulumi.Input<string>;
        /**
         * The Kinesis stream ARN to ingest data from.
         */
        streamArn: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettingsAwsMsk {
        /**
         * AWS role ARN to be used for Federated Identity authentication with
         * MSK. Check the Pub/Sub docs for how to set up this role and the
         * required permissions that need to be attached to it.
         */
        awsRoleArn: pulumi.Input<string>;
        /**
         * ARN that uniquely identifies the MSK cluster.
         */
        clusterArn: pulumi.Input<string>;
        /**
         * The GCP service account to be used for Federated Identity authentication
         * with MSK (via a `AssumeRoleWithWebIdentity` call for the provided
         * role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
         * equals to this service account number.
         */
        gcpServiceAccount: pulumi.Input<string>;
        /**
         * The name of the MSK topic that Pub/Sub will import from.
         */
        topic: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettingsAzureEventHubs {
        /**
         * The Azure event hub client ID to use for ingestion.
         */
        clientId?: pulumi.Input<string>;
        /**
         * The Azure event hub to ingest data from.
         */
        eventHub?: pulumi.Input<string>;
        /**
         * The GCP service account to be used for Federated Identity authentication
         * with Azure (via a `AssumeRoleWithWebIdentity` call for the provided
         * role).
         */
        gcpServiceAccount?: pulumi.Input<string>;
        /**
         * The Azure event hub namespace to ingest data from.
         */
        namespace?: pulumi.Input<string>;
        /**
         * The name of the resource group within an Azure subscription.
         */
        resourceGroup?: pulumi.Input<string>;
        /**
         * The Azure event hub subscription ID to use for ingestion.
         */
        subscriptionId?: pulumi.Input<string>;
        /**
         * The Azure event hub tenant ID to use for ingestion.
         */
        tenantId?: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettingsCloudStorage {
        /**
         * Configuration for reading Cloud Storage data in Avro binary format. The
         * bytes of each object will be set to the `data` field of a Pub/Sub message.
         */
        avroFormat?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsCloudStorageAvroFormat>;
        /**
         * Cloud Storage bucket. The bucket name must be without any
         * prefix like "gs://". See the bucket naming requirements:
         * https://cloud.google.com/storage/docs/buckets#naming.
         */
        bucket: pulumi.Input<string>;
        /**
         * Glob pattern used to match objects that will be ingested. If unset, all
         * objects will be ingested. See the supported patterns:
         * https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob
         */
        matchGlob?: pulumi.Input<string>;
        /**
         * The timestamp set in RFC3339 text format. If set, only objects with a
         * larger or equal timestamp will be ingested. Unset by default, meaning
         * all objects will be ingested.
         */
        minimumObjectCreateTime?: pulumi.Input<string>;
        /**
         * Configuration for reading Cloud Storage data written via Cloud Storage
         * subscriptions(See https://cloud.google.com/pubsub/docs/cloudstorage). The
         * data and attributes fields of the originally exported Pub/Sub message
         * will be restored when publishing.
         */
        pubsubAvroFormat?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormat>;
        /**
         * Configuration for reading Cloud Storage data in text format. Each line of
         * text as specified by the delimiter will be set to the `data` field of a
         * Pub/Sub message.
         * Structure is documented below.
         */
        textFormat?: pulumi.Input<inputs.pubsub.TopicIngestionDataSourceSettingsCloudStorageTextFormat>;
    }

    export interface TopicIngestionDataSourceSettingsCloudStorageAvroFormat {
    }

    export interface TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormat {
    }

    export interface TopicIngestionDataSourceSettingsCloudStorageTextFormat {
        /**
         * The delimiter to use when using the 'text' format. Each line of text as
         * specified by the delimiter will be set to the 'data' field of a Pub/Sub
         * message. When unset, '\n' is used.
         */
        delimiter?: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettingsConfluentCloud {
        /**
         * The Confluent Cloud bootstrap server. The format is url:port.
         */
        bootstrapServer: pulumi.Input<string>;
        /**
         * The Confluent Cloud cluster ID.
         */
        clusterId?: pulumi.Input<string>;
        /**
         * The GCP service account to be used for Federated Identity authentication
         * with Confluent Cloud.
         */
        gcpServiceAccount: pulumi.Input<string>;
        /**
         * Identity pool ID to be used for Federated Identity authentication with Confluent Cloud.
         */
        identityPoolId: pulumi.Input<string>;
        /**
         * Name of the Confluent Cloud topic that Pub/Sub will import from.
         */
        topic: pulumi.Input<string>;
    }

    export interface TopicIngestionDataSourceSettingsPlatformLogsSettings {
        /**
         * The minimum severity level of Platform Logs that will be written. If unspecified,
         * no Platform Logs will be written.
         * Default value is `SEVERITY_UNSPECIFIED`.
         * Possible values are: `SEVERITY_UNSPECIFIED`, `DISABLED`, `DEBUG`, `INFO`, `WARNING`, `ERROR`.
         */
        severity?: pulumi.Input<string>;
    }

    export interface TopicMessageStoragePolicy {
        /**
         * A list of IDs of GCP regions where messages that are published to
         * the topic may be persisted in storage. Messages published by
         * publishers running in non-allowed GCP regions (or running outside
         * of GCP altogether) will be routed for storage in one of the
         * allowed regions. An empty list means that no regions are allowed,
         * and is not a valid configuration.
         */
        allowedPersistenceRegions: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, `allowedPersistenceRegions` is also used to enforce in-transit
         * guarantees for messages. That is, Pub/Sub will fail topics.publish
         * operations on this topic and subscribe operations on any subscription
         * attached to this topic in any region that is not in `allowedPersistenceRegions`.
         */
        enforceInTransit?: pulumi.Input<boolean>;
    }

    export interface TopicSchemaSettings {
        /**
         * The encoding of messages validated against schema.
         * Default value is `ENCODING_UNSPECIFIED`.
         * Possible values are: `ENCODING_UNSPECIFIED`, `JSON`, `BINARY`.
         */
        encoding?: pulumi.Input<string>;
        /**
         * The name of the schema that messages published should be
         * validated against. Format is projects/{project}/schemas/{schema}.
         * The value of this field will be _deleted-schema_
         * if the schema has been deleted.
         */
        schema: pulumi.Input<string>;
    }
}

export namespace recaptcha {
    export interface EnterpriseKeyAndroidSettings {
        /**
         * If set to true, it means allowedPackageNames will not be enforced.
         */
        allowAllPackageNames?: pulumi.Input<boolean>;
        /**
         * Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
         */
        allowedPackageNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EnterpriseKeyIosSettings {
        /**
         * If set to true, it means allowedBundleIds will not be enforced.
         */
        allowAllBundleIds?: pulumi.Input<boolean>;
        /**
         * iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
         */
        allowedBundleIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EnterpriseKeyTestingOptions {
        /**
         * For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if UNSOLVABLE_CHALLENGE. Possible values: TESTING_CHALLENGE_UNSPECIFIED, NOCAPTCHA, UNSOLVABLE_CHALLENGE
         */
        testingChallenge?: pulumi.Input<string>;
        /**
         * All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
         */
        testingScore?: pulumi.Input<number>;
    }

    export interface EnterpriseKeyWafSettings {
        /**
         * Supported WAF features. For more information, see https://cloud.google.com/recaptcha-enterprise/docs/usecase#comparison_of_features. Possible values: CHALLENGE_PAGE, SESSION_TOKEN, ACTION_TOKEN, EXPRESS
         */
        wafFeature: pulumi.Input<string>;
        /**
         * The WAF service that uses this key. Possible values: CA, FASTLY
         */
        wafService: pulumi.Input<string>;
    }

    export interface EnterpriseKeyWebSettings {
        /**
         * If set to true, it means allowedDomains will not be enforced.
         */
        allowAllDomains?: pulumi.Input<boolean>;
        /**
         * If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
         */
        allowAmpTraffic?: pulumi.Input<boolean>;
        /**
         * Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
         */
        allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE. Possible values: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED, USABILITY, BALANCE, SECURITY
         */
        challengeSecurityPreference?: pulumi.Input<string>;
        /**
         * Required. Describes how this key is integrated with the website. Possible values: SCORE, CHECKBOX, INVISIBLE
         */
        integrationType: pulumi.Input<string>;
    }
}

export namespace redis {
    export interface ClusterAutomatedBackupConfig {
        /**
         * Trigger automated backups at a fixed frequency.
         * Structure is documented below.
         */
        fixedFrequencySchedule: pulumi.Input<inputs.redis.ClusterAutomatedBackupConfigFixedFrequencySchedule>;
        /**
         * How long to keep automated backups before the backups are deleted.
         * The value should be between 1 day and 365 days. If not specified, the default value is 35 days.
         * A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
         */
        retention: pulumi.Input<string>;
    }

    export interface ClusterAutomatedBackupConfigFixedFrequencySchedule {
        /**
         * The start time of every automated backup in UTC.
         * It must be set to the start of an hour. This field is required.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.redis.ClusterAutomatedBackupConfigFixedFrequencyScheduleStartTime>;
    }

    export interface ClusterAutomatedBackupConfigFixedFrequencyScheduleStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours: pulumi.Input<number>;
    }

    export interface ClusterCrossClusterReplicationConfig {
        /**
         * The role of the cluster in cross cluster replication. Supported values are:
         * 1. `CLUSTER_ROLE_UNSPECIFIED`: This is an independent cluster that has never participated in cross cluster replication. It allows both reads and writes.
         * 1. `NONE`: This is an independent cluster that previously participated in cross cluster replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
         * 1. `PRIMARY`: This cluster serves as the replication source for secondary clusters that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
         * 1. `SECONDARY`: This cluster replicates data from the primary cluster. It allows only reads.
         * Possible values are: `CLUSTER_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.
         */
        clusterRole?: pulumi.Input<string>;
        /**
         * (Output)
         * An output only view of all the member clusters participating in cross cluster replication. This field is populated for all the member clusters irrespective of their cluster role.
         * Structure is documented below.
         */
        memberships?: pulumi.Input<pulumi.Input<inputs.redis.ClusterCrossClusterReplicationConfigMembership>[]>;
        /**
         * Details of the primary cluster that is used as the replication source for this secondary cluster. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
         * Structure is documented below.
         */
        primaryCluster?: pulumi.Input<inputs.redis.ClusterCrossClusterReplicationConfigPrimaryCluster>;
        /**
         * List of secondary clusters that are replicating from this primary cluster. This is allowed to be set only for clusters whose cluster role is of type `PRIMARY`.
         * Structure is documented below.
         */
        secondaryClusters?: pulumi.Input<pulumi.Input<inputs.redis.ClusterCrossClusterReplicationConfigSecondaryCluster>[]>;
        /**
         * (Output)
         * The last time cross cluster replication config was updated.
         */
        updateTime?: pulumi.Input<string>;
    }

    export interface ClusterCrossClusterReplicationConfigMembership {
        /**
         * Details of the primary cluster that is used as the replication source for all the secondary clusters.
         */
        primaryClusters?: pulumi.Input<pulumi.Input<inputs.redis.ClusterCrossClusterReplicationConfigMembershipPrimaryCluster>[]>;
        /**
         * List of secondary clusters that are replicating from the primary cluster.
         */
        secondaryClusters?: pulumi.Input<pulumi.Input<inputs.redis.ClusterCrossClusterReplicationConfigMembershipSecondaryCluster>[]>;
    }

    export interface ClusterCrossClusterReplicationConfigMembershipPrimaryCluster {
        /**
         * The full resource path of the primary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}
         */
        cluster?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the primary cluster.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ClusterCrossClusterReplicationConfigMembershipSecondaryCluster {
        /**
         * (Output)
         * The full resource path of the secondary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}
         */
        cluster?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the secondary cluster.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ClusterCrossClusterReplicationConfigPrimaryCluster {
        /**
         * The full resource path of the primary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}
         */
        cluster?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the primary cluster.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ClusterCrossClusterReplicationConfigSecondaryCluster {
        /**
         * (Output)
         * The full resource path of the secondary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}
         */
        cluster?: pulumi.Input<string>;
        /**
         * (Output)
         * The unique id of the secondary cluster.
         */
        uid?: pulumi.Input<string>;
    }

    export interface ClusterDiscoveryEndpoint {
        /**
         * Output only. The IP allocated on the consumer network for the PSC forwarding rule.
         */
        address?: pulumi.Input<string>;
        /**
         * Output only. The port number of the exposed Redis endpoint.
         */
        port?: pulumi.Input<number>;
        /**
         * Output only. Customer configuration for where the endpoint
         * is created and accessed from.
         * Structure is documented below.
         */
        pscConfig?: pulumi.Input<inputs.redis.ClusterDiscoveryEndpointPscConfig>;
    }

    export interface ClusterDiscoveryEndpointPscConfig {
        /**
         * The consumer network where the IP address resides, in the form of projects/{projectId}/global/networks/{network_id}.
         */
        network?: pulumi.Input<string>;
    }

    export interface ClusterGcsSource {
        /**
         * URIs of the GCS objects to import. Example: gs://bucket1/object1, gs://bucket2/folder2/object2
         */
        uris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterMaintenancePolicy {
        /**
         * (Output)
         * Output only. The time when the policy was created.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The time when the policy was last updated.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * Optional. Maintenance window that is applied to resources covered by this policy.
         * Minimum 1. For the current version, the maximum number
         * of weeklyWindow is expected to be one.
         * Structure is documented below.
         */
        weeklyMaintenanceWindows?: pulumi.Input<pulumi.Input<inputs.redis.ClusterMaintenancePolicyWeeklyMaintenanceWindow>[]>;
    }

    export interface ClusterMaintenancePolicyWeeklyMaintenanceWindow {
        /**
         * Required. The day of week that maintenance updates occur.
         * - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
         * - MONDAY: Monday
         * - TUESDAY: Tuesday
         * - WEDNESDAY: Wednesday
         * - THURSDAY: Thursday
         * - FRIDAY: Friday
         * - SATURDAY: Saturday
         * - SUNDAY: Sunday
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Duration of the maintenance window.
         * The current window is fixed at 1 hour.
         * A duration in seconds with up to nine fractional digits,
         * terminated by 's'. Example: "3.5s".
         */
        duration?: pulumi.Input<string>;
        /**
         * Required. Start time of the window in UTC time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.redis.ClusterMaintenancePolicyWeeklyMaintenanceWindowStartTime>;
    }

    export interface ClusterMaintenancePolicyWeeklyMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         * An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface ClusterMaintenanceSchedule {
        /**
         * (Output)
         * Output only. The end time of any upcoming scheduled maintenance for this cluster.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The deadline that the maintenance schedule start time
         * can not go beyond, including reschedule.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        scheduleDeadlineTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The start time of any upcoming scheduled maintenance for this cluster.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface ClusterManagedBackupSource {
        /**
         * Example: //redis.googleapis.com/projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup} A shorter version (without the prefix) of the backup name is also supported,
         * like projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backupId}. In this case, it assumes the backup is under redis.googleapis.com.
         */
        backup: pulumi.Input<string>;
    }

    export interface ClusterPersistenceConfig {
        /**
         * AOF configuration. This field will be ignored if mode is not AOF.
         * Structure is documented below.
         */
        aofConfig?: pulumi.Input<inputs.redis.ClusterPersistenceConfigAofConfig>;
        /**
         * Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
         * - DISABLED: 	Persistence (both backup and restore) is disabled for the cluster.
         * - RDB: RDB based Persistence is enabled.
         * - AOF: AOF based Persistence is enabled.
         * Possible values are: `PERSISTENCE_MODE_UNSPECIFIED`, `DISABLED`, `RDB`, `AOF`.
         */
        mode?: pulumi.Input<string>;
        /**
         * RDB configuration. This field will be ignored if mode is not RDB.
         * Structure is documented below.
         */
        rdbConfig?: pulumi.Input<inputs.redis.ClusterPersistenceConfigRdbConfig>;
    }

    export interface ClusterPersistenceConfigAofConfig {
        /**
         * Optional. Available fsync modes.
         * - NO - Do not explicitly call fsync(). Rely on OS defaults.
         * - EVERYSEC - Call fsync() once per second in a background thread. A balance between performance and durability.
         * - ALWAYS - Call fsync() for earch write command.
         * Possible values are: `APPEND_FSYNC_UNSPECIFIED`, `NO`, `EVERYSEC`, `ALWAYS`.
         */
        appendFsync?: pulumi.Input<string>;
    }

    export interface ClusterPersistenceConfigRdbConfig {
        /**
         * Optional. Available snapshot periods for scheduling.
         * - ONE_HOUR:	Snapshot every 1 hour.
         * - SIX_HOURS:	Snapshot every 6 hours.
         * - TWELVE_HOURS:	Snapshot every 12 hours.
         * - TWENTY_FOUR_HOURS:	Snapshot every 24 hours.
         * Possible values are: `SNAPSHOT_PERIOD_UNSPECIFIED`, `ONE_HOUR`, `SIX_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`.
         */
        rdbSnapshotPeriod?: pulumi.Input<string>;
        /**
         * The time that the first snapshot was/will be attempted, and to which
         * future snapshots will be aligned.
         * If not provided, the current time will be used.
         */
        rdbSnapshotStartTime?: pulumi.Input<string>;
    }

    export interface ClusterPscConfig {
        /**
         * Required. The consumer network where the network address of
         * the discovery endpoint will be reserved, in the form of
         * projects/{network_project_id_or_number}/global/networks/{network_id}.
         */
        network: pulumi.Input<string>;
    }

    export interface ClusterPscConnection {
        /**
         * Output only. The IP allocated on the consumer network for the PSC forwarding rule.
         */
        address?: pulumi.Input<string>;
        /**
         * Output only. The URI of the consumer side forwarding rule. Example: projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
         */
        forwardingRule?: pulumi.Input<string>;
        /**
         * The consumer network where the IP address resides, in the form of projects/{projectId}/global/networks/{network_id}.
         */
        network?: pulumi.Input<string>;
        /**
         * Output only. The consumer projectId where the forwarding rule is created from.
         */
        projectId?: pulumi.Input<string>;
        /**
         * Output only. The PSC connection id of the forwarding rule connected to the service attachment.
         */
        pscConnectionId?: pulumi.Input<string>;
    }

    export interface ClusterPscServiceAttachment {
        /**
         * (Output)
         * Type of a PSC connection targeting this service attachment.
         */
        connectionType?: pulumi.Input<string>;
        /**
         * (Output)
         * Service attachment URI which your self-created PscConnection should use as
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface ClusterStateInfo {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        updateInfo?: pulumi.Input<inputs.redis.ClusterStateInfoUpdateInfo>;
    }

    export interface ClusterStateInfoUpdateInfo {
        /**
         * Target number of replica nodes per shard.
         */
        targetReplicaCount?: pulumi.Input<number>;
        /**
         * Target number of shards for redis cluster.
         */
        targetShardCount?: pulumi.Input<number>;
    }

    export interface ClusterUserCreatedConnectionsClusterEndpoint {
        /**
         * Structure is documented below.
         */
        connections?: pulumi.Input<pulumi.Input<inputs.redis.ClusterUserCreatedConnectionsClusterEndpointConnection>[]>;
    }

    export interface ClusterUserCreatedConnectionsClusterEndpointConnection {
        /**
         * Detailed information of a PSC connection that is created by the customer
         * who owns the cluster.
         * Structure is documented below.
         */
        pscConnection?: pulumi.Input<inputs.redis.ClusterUserCreatedConnectionsClusterEndpointConnectionPscConnection>;
    }

    export interface ClusterUserCreatedConnectionsClusterEndpointConnectionPscConnection {
        /**
         * The IP allocated on the consumer network for the PSC forwarding rule.
         */
        address: pulumi.Input<string>;
        /**
         * (Output)
         * Output Only. Type of a PSC Connection.
         * Possible values:
         * CONNECTION_TYPE_DISCOVERY
         * CONNECTION_TYPE_PRIMARY
         * CONNECTION_TYPE_READER
         */
        connectionType?: pulumi.Input<string>;
        /**
         * The URI of the consumer side forwarding rule.
         * Format:
         * projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
         */
        forwardingRule: pulumi.Input<string>;
        /**
         * The consumer network where the IP address resides, in the form of
         * projects/{project_id}/global/networks/{network_id}.
         */
        network: pulumi.Input<string>;
        /**
         * The consumer projectId where the forwarding rule is created from.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The PSC connection id of the forwarding rule connected to the
         * service attachment.
         */
        pscConnectionId: pulumi.Input<string>;
        /**
         * (Output)
         * Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
         * Possible values:
         * ACTIVE
         * NOT_FOUND
         */
        pscConnectionStatus?: pulumi.Input<string>;
        /**
         * The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
         */
        serviceAttachment: pulumi.Input<string>;
    }

    export interface ClusterZoneDistributionConfig {
        /**
         * Immutable. The mode for zone distribution for Memorystore Redis cluster.
         * If not provided, MULTI_ZONE will be used as default
         * Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Immutable. The zone for single zone Memorystore Redis cluster.
         */
        zone?: pulumi.Input<string>;
    }

    export interface InstanceMaintenancePolicy {
        /**
         * (Output)
         * Output only. The time when the policy was created.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Optional. Description of what this policy is for.
         * Create/Update methods return INVALID_ARGUMENT if the
         * length is greater than 512.
         */
        description?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The time when the policy was last updated.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        updateTime?: pulumi.Input<string>;
        /**
         * Optional. Maintenance window that is applied to resources covered by this policy.
         * Minimum 1. For the current version, the maximum number
         * of weeklyWindow is expected to be one.
         * Structure is documented below.
         */
        weeklyMaintenanceWindows?: pulumi.Input<pulumi.Input<inputs.redis.InstanceMaintenancePolicyWeeklyMaintenanceWindow>[]>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindow {
        /**
         * Required. The day of week that maintenance updates occur.
         * - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
         * - MONDAY: Monday
         * - TUESDAY: Tuesday
         * - WEDNESDAY: Wednesday
         * - THURSDAY: Thursday
         * - FRIDAY: Friday
         * - SATURDAY: Saturday
         * - SUNDAY: Sunday
         * Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
         */
        day: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Duration of the maintenance window.
         * The current window is fixed at 1 hour.
         * A duration in seconds with up to nine fractional digits,
         * terminated by 's'. Example: "3.5s".
         */
        duration?: pulumi.Input<string>;
        /**
         * Required. Start time of the window in UTC time.
         * Structure is documented below.
         */
        startTime: pulumi.Input<inputs.redis.InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime>;
    }

    export interface InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         * An API may choose to allow the value "24:00:00" for scenarios like business closing time.
         */
        hours?: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes?: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         * An API may allow the value 60 if it allows leap-seconds.
         */
        seconds?: pulumi.Input<number>;
    }

    export interface InstanceMaintenanceSchedule {
        /**
         * (Output)
         * Output only. The end time of any upcoming scheduled maintenance for this instance.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        endTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The deadline that the maintenance schedule start time
         * can not go beyond, including reschedule.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        scheduleDeadlineTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The start time of any upcoming scheduled maintenance for this instance.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
         * resolution and up to nine fractional digits.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface InstanceNode {
        /**
         * (Output)
         * Node identifying string. e.g. 'node-0', 'node-1'
         */
        id?: pulumi.Input<string>;
        /**
         * (Output)
         * Location of the node.
         */
        zone?: pulumi.Input<string>;
    }

    export interface InstancePersistenceConfig {
        /**
         * Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
         * - DISABLED: 	Persistence is disabled for the instance, and any existing snapshots are deleted.
         * - RDB: RDB based Persistence is enabled.
         * Possible values are: `DISABLED`, `RDB`.
         */
        persistenceMode?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The next time that a snapshot attempt is scheduled to occur.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
         * to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        rdbNextSnapshotTime?: pulumi.Input<string>;
        /**
         * Optional. Available snapshot periods for scheduling.
         * - ONE_HOUR:	Snapshot every 1 hour.
         * - SIX_HOURS:	Snapshot every 6 hours.
         * - TWELVE_HOURS:	Snapshot every 12 hours.
         * - TWENTY_FOUR_HOURS:	Snapshot every 24 hours.
         * Possible values are: `ONE_HOUR`, `SIX_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`.
         */
        rdbSnapshotPeriod?: pulumi.Input<string>;
        /**
         * Optional. Date and time that the first snapshot was/will be attempted,
         * and to which future snapshots will be aligned. If not provided,
         * the current time will be used.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution
         * and up to nine fractional digits.
         * Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        rdbSnapshotStartTime?: pulumi.Input<string>;
    }

    export interface InstanceServerCaCert {
        /**
         * (Output)
         * The certificate data in PEM format.
         */
        cert?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the certificate was created.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * The time when the certificate expires.
         */
        expireTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Serial number, as extracted from the certificate.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * (Output)
         * Sha1 Fingerprint of the certificate.
         */
        sha1Fingerprint?: pulumi.Input<string>;
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ConfigIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace secretmanager {
    export interface RegionalSecretCustomerManagedEncryption {
        /**
         * The resource name of the Cloud KMS CryptoKey used to encrypt secret payloads.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface RegionalSecretIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface RegionalSecretIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface RegionalSecretRotation {
        /**
         * Timestamp in UTC at which the Secret is scheduled to rotate.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine
         * fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        nextRotationTime?: pulumi.Input<string>;
        /**
         * The Duration between rotation notifications. Must be in seconds and at least 3600s (1h)
         * and at most 3153600000s (100 years). If rotationPeriod is set, `nextRotationTime` must
         * be set. `nextRotationTime` will be advanced by this period when the service
         * automatically sends rotation notifications.
         */
        rotationPeriod?: pulumi.Input<string>;
    }

    export interface RegionalSecretTopic {
        /**
         * The resource name of the Pub/Sub topic that will be published to, in the following format:
         * projects/*&#47;topics/*. For publication to succeed, the Secret Manager Service
         * Agent service account must have pubsub.publisher permissions on the topic.
         */
        name: pulumi.Input<string>;
    }

    export interface RegionalSecretVersionCustomerManagedEncryption {
        /**
         * (Output)
         * The resource name of the Cloud KMS CryptoKey used to encrypt secret payloads.
         */
        kmsKeyVersionName?: pulumi.Input<string>;
    }

    export interface SecretIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SecretIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface SecretReplication {
        /**
         * The Secret will automatically be replicated without any restrictions.
         * Structure is documented below.
         */
        auto?: pulumi.Input<inputs.secretmanager.SecretReplicationAuto>;
        /**
         * The Secret will be replicated to the regions specified by the user.
         * Structure is documented below.
         */
        userManaged?: pulumi.Input<inputs.secretmanager.SecretReplicationUserManaged>;
    }

    export interface SecretReplicationAuto {
        /**
         * The customer-managed encryption configuration of the Secret.
         * If no configuration is provided, Google-managed default
         * encryption is used.
         * Structure is documented below.
         */
        customerManagedEncryption?: pulumi.Input<inputs.secretmanager.SecretReplicationAutoCustomerManagedEncryption>;
    }

    export interface SecretReplicationAutoCustomerManagedEncryption {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination secret.
         *
         * - - -
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface SecretReplicationUserManaged {
        /**
         * The list of Replicas for this Secret. Cannot be empty.
         * Structure is documented below.
         */
        replicas: pulumi.Input<pulumi.Input<inputs.secretmanager.SecretReplicationUserManagedReplica>[]>;
    }

    export interface SecretReplicationUserManagedReplica {
        /**
         * Customer Managed Encryption for the secret.
         * Structure is documented below.
         */
        customerManagedEncryption?: pulumi.Input<inputs.secretmanager.SecretReplicationUserManagedReplicaCustomerManagedEncryption>;
        /**
         * The canonical IDs of the location to replicate data. For example: "us-east1".
         */
        location: pulumi.Input<string>;
    }

    export interface SecretReplicationUserManagedReplicaCustomerManagedEncryption {
        /**
         * Describes the Cloud KMS encryption key that will be used to protect destination secret.
         *
         * - - -
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface SecretRotation {
        /**
         * Timestamp in UTC at which the Secret is scheduled to rotate.
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        nextRotationTime?: pulumi.Input<string>;
        /**
         * The Duration between rotation notifications. Must be in seconds and at least 3600s (1h) and at most 3153600000s (100 years).
         * If rotationPeriod is set, `nextRotationTime` must be set. `nextRotationTime` will be advanced by this period when the service automatically sends rotation notifications.
         */
        rotationPeriod?: pulumi.Input<string>;
    }

    export interface SecretTopic {
        /**
         * The resource name of the Pub/Sub topic that will be published to, in the following format: projects/*&#47;topics/*.
         * For publication to succeed, the Secret Manager Service Agent service account must have pubsub.publisher permissions on the topic.
         */
        name: pulumi.Input<string>;
    }
}

export namespace securesourcemanager {
    export interface InstanceHostConfig {
        /**
         * (Output)
         * API hostname.
         */
        api?: pulumi.Input<string>;
        /**
         * (Output)
         * Git HTTP hostname.
         */
        gitHttp?: pulumi.Input<string>;
        /**
         * (Output)
         * Git SSH hostname.
         */
        gitSsh?: pulumi.Input<string>;
        /**
         * (Output)
         * HTML hostname.
         */
        html?: pulumi.Input<string>;
    }

    export interface InstanceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstancePrivateConfig {
        /**
         * CA pool resource, resource must in the format of `projects/{project}/locations/{location}/caPools/{ca_pool}`.
         */
        caPool: pulumi.Input<string>;
        /**
         * (Output)
         * Service Attachment for HTTP, resource is in the format of `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
         */
        httpServiceAttachment?: pulumi.Input<string>;
        /**
         * 'Indicate if it's private instance.'
         */
        isPrivate: pulumi.Input<boolean>;
        /**
         * (Output)
         * Service Attachment for SSH, resource is in the format of `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
         */
        sshServiceAttachment?: pulumi.Input<string>;
    }

    export interface InstanceWorkforceIdentityFederationConfig {
        /**
         * 'Whether Workforce Identity Federation is enabled.'
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryInitialConfig {
        /**
         * Default branch name of the repository.
         */
        defaultBranch?: pulumi.Input<string>;
        /**
         * List of gitignore template names user can choose from.
         * Valid values can be viewed at https://cloud.google.com/secure-source-manager/docs/reference/rest/v1/projects.locations.repositories#initialconfig.
         */
        gitignores?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * License template name user can choose from.
         * Valid values can be viewed at https://cloud.google.com/secure-source-manager/docs/reference/rest/v1/projects.locations.repositories#initialconfig.
         */
        license?: pulumi.Input<string>;
        /**
         * README template name.
         * Valid values can be viewed at https://cloud.google.com/secure-source-manager/docs/reference/rest/v1/projects.locations.repositories#initialconfig.
         */
        readme?: pulumi.Input<string>;
    }

    export interface RepositoryUri {
        /**
         * (Output)
         * API is the URI for API access.
         */
        api?: pulumi.Input<string>;
        /**
         * (Output)
         * gitHttps is the git HTTPS URI for git operations.
         */
        gitHttps?: pulumi.Input<string>;
        /**
         * (Output)
         * HTML is the URI for the user to view the repository in a browser.
         */
        html?: pulumi.Input<string>;
    }
}

export namespace securitycenter {
    export interface FolderCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.FolderCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securitycenter.FolderCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securitycenter.FolderCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface FolderCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.FolderCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface FolderCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.FolderCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface FolderCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface FolderCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface FolderCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         *
         * - - -
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FolderNotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }

    export interface InstanceIamBindingCondition {
        /**
         * An optional description of the instance.
         */
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        /**
         * An optional description of the instance.
         */
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate?: pulumi.Input<inputs.securitycenter.ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation?: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector?: pulumi.Input<inputs.securitycenter.ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity?: pulumi.Input<string>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementFolderSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securitycenter.ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securitycenter.ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementOrganizationSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securitycenter.ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securitycenter.ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ManagementProjectSecurityHealthAnalyticsCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }

    export interface OrganizationCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.OrganizationCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securitycenter.OrganizationCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securitycenter.OrganizationCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface OrganizationCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.OrganizationCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface OrganizationCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.OrganizationCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface OrganizationCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface OrganizationCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface OrganizationCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         *
         * - - -
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ProjectCustomModuleCustomConfig {
        /**
         * Custom output properties.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securitycenter.ProjectCustomModuleCustomConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects. This explanation is returned with each finding instance to
         * help investigators understand the detected issue. The text must be enclosed in quotation marks.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings. When the expression evaluates
         * to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securitycenter.ProjectCustomModuleCustomConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to resolve
         * the detected issue. This explanation is returned with each finding generated by
         * this module in the nextSteps property of the finding JSON.
         */
        recommendation: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securitycenter.ProjectCustomModuleCustomConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface ProjectCustomModuleCustomConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securitycenter.ProjectCustomModuleCustomConfigCustomOutputProperty>[]>;
    }

    export interface ProjectCustomModuleCustomConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name?: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be specified
         * to return the value of the property or a text string enclosed in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securitycenter.ProjectCustomModuleCustomConfigCustomOutputPropertyValueExpression>;
    }

    export interface ProjectCustomModuleCustomConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ProjectCustomModuleCustomConfigPredicate {
        /**
         * Description of the expression. This is a longer text which describes the
         * expression, e.g. when hovered over it in a UI.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a
         * file name and a position in the file.
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose. This can
         * be used e.g. in UIs which allow to enter the expression.
         */
        title?: pulumi.Input<string>;
    }

    export interface ProjectCustomModuleCustomConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         *
         * - - -
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ProjectNotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }

    export interface SourceIamBindingCondition {
        /**
         * The description of the source (max of 1024 characters).
         */
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface SourceIamMemberCondition {
        /**
         * The description of the source (max of 1024 characters).
         */
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface V2FolderNotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }

    export interface V2OrganizationNotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }

    export interface V2OrganizationSourceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface V2OrganizationSourceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface V2ProjectNotificationConfigStreamingConfig {
        /**
         * Expression that defines the filter to apply across create/update
         * events of assets or findings as specified by the event type. The
         * expression is a list of zero or more restrictions combined via
         * logical operators AND and OR. Parentheses are supported, and OR
         * has higher precedence than AND.
         * Restrictions have the form <field> <operator> <value> and may have
         * a - character in front of them to indicate negation. The fields
         * map to those defined in the corresponding resource.
         * The supported operators are:
         * * = for all value types.
         * * >, <, >=, <= for integer values.
         * * :, meaning substring matching, for strings.
         * The supported value types are:
         * * string literals in quotes.
         * * integer literals without quotes.
         * * boolean literals true and false without quotes.
         * See
         * [Filtering notifications](https://cloud.google.com/security-command-center/docs/how-to-api-filter-notifications)
         * for information on how to write a filter.
         *
         * - - -
         */
        filter: pulumi.Input<string>;
    }
}

export namespace securityposture {
    export interface PosturePolicySet {
        /**
         * Description of the policy set.
         */
        description?: pulumi.Input<string>;
        /**
         * List of security policy
         * Structure is documented below.
         */
        policies: pulumi.Input<pulumi.Input<inputs.securityposture.PosturePolicySetPolicy>[]>;
        /**
         * ID of the policy set.
         */
        policySetId: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicy {
        /**
         * Mapping for policy to security standards and controls.
         * Structure is documented below.
         */
        complianceStandards?: pulumi.Input<pulumi.Input<inputs.securityposture.PosturePolicySetPolicyComplianceStandard>[]>;
        /**
         * Policy constraint definition.It can have the definition of one of following constraints: orgPolicyConstraint orgPolicyConstraintCustom securityHealthAnalyticsModule securityHealthAnalyticsCustomModule
         * Structure is documented below.
         */
        constraint: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraint>;
        /**
         * Description of the policy.
         */
        description?: pulumi.Input<string>;
        /**
         * ID of the policy.
         */
        policyId: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyComplianceStandard {
        /**
         * Mapping of security controls for the policy.
         */
        control?: pulumi.Input<string>;
        /**
         * Mapping of compliance standards for the policy.
         */
        standard?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraint {
        /**
         * Organization policy canned constraint definition.
         * Structure is documented below.
         */
        orgPolicyConstraint?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraint>;
        /**
         * Organization policy custom constraint policy definition.
         * Structure is documented below.
         */
        orgPolicyConstraintCustom?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintCustom>;
        /**
         * Definition of Security Health Analytics Custom Module.
         * Structure is documented below.
         */
        securityHealthAnalyticsCustomModule?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModule>;
        /**
         * Security Health Analytics built-in detector definition.
         * Structure is documented below.
         */
        securityHealthAnalyticsModule?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsModule>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraint {
        /**
         * Organization policy canned constraint Id
         */
        cannedConstraintId: pulumi.Input<string>;
        /**
         * Definition of policy rules
         * Structure is documented below.
         */
        policyRules: pulumi.Input<pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRule>[]>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintCustom {
        /**
         * Organization policy custom constraint definition.
         * Structure is documented below.
         */
        customConstraint?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomCustomConstraint>;
        /**
         * Definition of policy rules
         * Structure is documented below.
         */
        policyRules: pulumi.Input<pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRule>[]>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomCustomConstraint {
        /**
         * The action to take if the condition is met.
         * Possible values are: `ALLOW`, `DENY`.
         */
        actionType: pulumi.Input<string>;
        /**
         * A CEL condition that refers to a supported service resource, for example `resource.management.autoUpgrade == false`. For details about CEL usage, see [Common Expression Language](https://cloud.google.com/resource-manager/docs/organization-policy/creating-managing-custom-constraints#common_expression_language).
         */
        condition: pulumi.Input<string>;
        /**
         * A human-friendly description of the constraint to display as an error message when the policy is violated.
         */
        description?: pulumi.Input<string>;
        /**
         * A human-friendly name for the constraint.
         */
        displayName?: pulumi.Input<string>;
        /**
         * A list of RESTful methods for which to enforce the constraint. Can be `CREATE`, `UPDATE`, or both. Not all Google Cloud services support both methods. To see supported methods for each service, find the service in [Supported services](https://cloud.google.com/resource-manager/docs/organization-policy/custom-constraint-supported-services).
         */
        methodTypes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Immutable. The name of the custom constraint. This is unique within the organization.
         */
        name: pulumi.Input<string>;
        /**
         * Immutable. The fully qualified name of the Google Cloud REST resource containing the object and field you want to restrict. For example, `container.googleapis.com/NodePool`.
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRule {
        /**
         * Setting this to true means that all values are allowed. This field can be set only in policies for list constraints.
         */
        allowAll?: pulumi.Input<boolean>;
        /**
         * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language.
         * This page details the objects and attributes that are used to the build the CEL expressions for
         * custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRuleCondition>;
        /**
         * Setting this to true means that all values are denied. This field can be set only in policies for list constraints.
         */
        denyAll?: pulumi.Input<boolean>;
        /**
         * If `true`, then the policy is enforced. If `false`, then any configuration is acceptable.
         * This field can be set only in policies for boolean constraints.
         */
        enforce?: pulumi.Input<boolean>;
        /**
         * List of values to be used for this policy rule. This field can be set only in policies for list constraints.
         * Structure is documented below.
         */
        values?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRuleValues>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRuleCondition {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintCustomPolicyRuleValues {
        /**
         * List of values allowed at this resource.
         */
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of values denied at this resource.
         */
        deniedValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRule {
        /**
         * Setting this to true means that all values are allowed. This field can be set only in policies for list constraints.
         */
        allowAll?: pulumi.Input<boolean>;
        /**
         * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language.
         * This page details the objects and attributes that are used to the build the CEL expressions for
         * custom access levels - https://cloud.google.com/access-context-manager/docs/custom-access-level-spec.
         * Structure is documented below.
         */
        condition?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRuleCondition>;
        /**
         * Setting this to true means that all values are denied. This field can be set only in policies for list constraints.
         */
        denyAll?: pulumi.Input<boolean>;
        /**
         * If `true`, then the policy is enforced. If `false`, then any configuration is acceptable.
         * This field can be set only in policies for boolean constraints.
         */
        enforce?: pulumi.Input<boolean>;
        /**
         * List of values to be used for this policy rule. This field can be set only in policies for list constraints.
         * Structure is documented below.
         */
        values?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRuleValues>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRuleCondition {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintOrgPolicyConstraintPolicyRuleValues {
        /**
         * List of values allowed at this resource.
         */
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of values denied at this resource.
         */
        deniedValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModule {
        /**
         * Custom module details.
         * Structure is documented below.
         */
        config: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfig>;
        /**
         * The display name of the Security Health Analytics custom module. This
         * display name becomes the finding category for all findings that are
         * returned by this custom module.
         */
        displayName?: pulumi.Input<string>;
        /**
         * (Output)
         * A server generated id of custom module.
         */
        id?: pulumi.Input<string>;
        /**
         * The state of enablement for the module at its level of the resource hierarchy.
         * Possible values are: `ENABLEMENT_STATE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
         */
        moduleEnablementState?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfig {
        /**
         * Custom output properties. A set of optional name-value pairs that define custom source properties to
         * return with each finding that is generated by the custom module. The custom
         * source properties that are defined here are included in the finding JSON
         * under `sourceProperties`.
         * Structure is documented below.
         */
        customOutput?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutput>;
        /**
         * Text that describes the vulnerability or misconfiguration that the custom
         * module detects.
         */
        description?: pulumi.Input<string>;
        /**
         * The CEL expression to evaluate to produce findings.When the expression
         * evaluates to true against a resource, a finding is generated.
         * Structure is documented below.
         */
        predicate: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigPredicate>;
        /**
         * An explanation of the recommended steps that security teams can take to
         * resolve the detected issue
         */
        recommendation?: pulumi.Input<string>;
        /**
         * The resource types that the custom module operates on. Each custom module
         * can specify up to 5 resource types.
         * Structure is documented below.
         */
        resourceSelector: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigResourceSelector>;
        /**
         * The severity to assign to findings generated by the module.
         * Possible values are: `SEVERITY_UNSPECIFIED`, `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`.
         */
        severity: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutput {
        /**
         * A list of custom output properties to add to the finding.
         * Structure is documented below.
         */
        properties?: pulumi.Input<pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutputProperty>[]>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutputProperty {
        /**
         * Name of the property for the custom output.
         */
        name: pulumi.Input<string>;
        /**
         * The CEL expression for the custom output. A resource property can be
         * specified to return the value of the property or a text string enclosed
         * in quotation marks.
         * Structure is documented below.
         */
        valueExpression?: pulumi.Input<inputs.securityposture.PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutputPropertyValueExpression>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigCustomOutputPropertyValueExpression {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigPredicate {
        /**
         * Description of the expression
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * String indicating the location of the expression for error reporting, e.g. a file name and a position in the file
         */
        location?: pulumi.Input<string>;
        /**
         * Title for the expression, i.e. a short string describing its purpose.
         */
        title?: pulumi.Input<string>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsCustomModuleConfigResourceSelector {
        /**
         * The resource types to run the detector on.
         *
         * - - -
         */
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PosturePolicySetPolicyConstraintSecurityHealthAnalyticsModule {
        /**
         * The state of enablement for the module at its level of the resource hierarchy.
         * Possible values are: `ENABLEMENT_STATE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
         */
        moduleEnablementState?: pulumi.Input<string>;
        /**
         * The name of the module eg: BIGQUERY_TABLE_CMEK_DISABLED.
         */
        moduleName: pulumi.Input<string>;
    }
}

export namespace serviceaccount {
    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }
}

export namespace servicedirectory {
    export interface NamespaceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface NamespaceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface ServiceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace siteverification {
    export interface WebResourceSite {
        /**
         * The site identifier. If the type is set to SITE, the identifier is a URL. If the type is
         * set to INET_DOMAIN, the identifier is a domain name.
         *
         * - - -
         */
        identifier: pulumi.Input<string>;
        /**
         * The type of resource to be verified.
         * Possible values are: `INET_DOMAIN`, `SITE`.
         */
        type: pulumi.Input<string>;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface RepositoryPubsubConfig {
        /**
         * The format of the Cloud Pub/Sub messages.
         * - PROTOBUF: The message payload is a serialized protocol buffer of SourceRepoEvent.
         * - JSON: The message payload is a JSON string of SourceRepoEvent.
         * Possible values are: `PROTOBUF`, `JSON`.
         */
        messageFormat: pulumi.Input<string>;
        /**
         * Email address of the service account used for publishing Cloud Pub/Sub messages.
         * This service account needs to be in the same project as the PubsubConfig. When added,
         * the caller needs to have iam.serviceAccounts.actAs permission on this service account.
         * If unspecified, it defaults to the compute engine default service account.
         */
        serviceAccountEmail?: pulumi.Input<string>;
        /**
         * The identifier for this object. Format specified above.
         */
        topic: pulumi.Input<string>;
    }
}

export namespace spanner {
    export interface BackupScheduleEncryptionConfig {
        /**
         * The encryption type of backups created by the backup schedule.
         * Possible values are USE_DATABASE_ENCRYPTION, GOOGLE_DEFAULT_ENCRYPTION, or CUSTOMER_MANAGED_ENCRYPTION.
         * If you use CUSTOMER_MANAGED_ENCRYPTION, you must specify a kmsKeyName.
         * If your backup type is incremental-backup, the encryption type must be GOOGLE_DEFAULT_ENCRYPTION.
         * Possible values are: `USE_DATABASE_ENCRYPTION`, `GOOGLE_DEFAULT_ENCRYPTION`, `CUSTOMER_MANAGED_ENCRYPTION`.
         */
        encryptionType: pulumi.Input<string>;
        /**
         * The resource name of the Cloud KMS key to use for encryption.
         * Format: 'projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}'
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface BackupScheduleFullBackupSpec {
    }

    export interface BackupScheduleIncrementalBackupSpec {
    }

    export interface BackupScheduleSpec {
        /**
         * Cron style schedule specification..
         * Structure is documented below.
         */
        cronSpec?: pulumi.Input<inputs.spanner.BackupScheduleSpecCronSpec>;
    }

    export interface BackupScheduleSpecCronSpec {
        /**
         * Textual representation of the crontab. User can customize the
         * backup frequency and the backup version time using the cron
         * expression. The version time must be in UTC timzeone.
         * The backup will contain an externally consistent copy of the
         * database at the version time. Allowed frequencies are 12 hour, 1 day,
         * 1 week and 1 month. Examples of valid cron specifications:
         * 0 2/12 * * * : every 12 hours at (2, 14) hours past midnight in UTC.
         * 0 2,14 * * * : every 12 hours at (2,14) hours past midnight in UTC.
         * 0 2 * * *    : once a day at 2 past midnight in UTC.
         * 0 2 * * 0    : once a week every Sunday at 2 past midnight in UTC.
         * 0 2 8 * *    : once a month on 8th day at 2 past midnight in UTC.
         */
        text?: pulumi.Input<string>;
    }

    export interface DatabaseEncryptionConfig {
        /**
         * Fully qualified name of the KMS key to use to encrypt this database. This key must exist
         * in the same location as the Spanner Database.
         */
        kmsKeyName?: pulumi.Input<string>;
        /**
         * Fully qualified name of the KMS keys to use to encrypt this database. The keys must exist
         * in the same locations as the Spanner Database.
         */
        kmsKeyNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatabaseIAMBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface DatabaseIAMMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface InstanceAutoscalingConfig {
        /**
         * Asymmetric autoscaling options for specific replicas.
         * Structure is documented below.
         */
        asymmetricAutoscalingOptions?: pulumi.Input<pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAsymmetricAutoscalingOption>[]>;
        /**
         * Defines scale in controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events. Users can define the minimum and
         * maximum compute capacity allocated to the instance, and the autoscaler will
         * only scale within that range. Users can either use nodes or processing
         * units to specify the limits, but should use the same unit to set both the
         * minLimit and max_limit.
         * Structure is documented below.
         */
        autoscalingLimits?: pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAutoscalingLimits>;
        /**
         * Defines scale in controls to reduce the risk of response latency
         * and outages due to abrupt scale-in events
         * Structure is documented below.
         */
        autoscalingTargets?: pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAutoscalingTargets>;
    }

    export interface InstanceAutoscalingConfigAsymmetricAutoscalingOption {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        overrides: pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAsymmetricAutoscalingOptionOverrides>;
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        replicaSelection: pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAsymmetricAutoscalingOptionReplicaSelection>;
    }

    export interface InstanceAutoscalingConfigAsymmetricAutoscalingOptionOverrides {
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        autoscalingLimits: pulumi.Input<inputs.spanner.InstanceAutoscalingConfigAsymmetricAutoscalingOptionOverridesAutoscalingLimits>;
    }

    export interface InstanceAutoscalingConfigAsymmetricAutoscalingOptionOverridesAutoscalingLimits {
        /**
         * The maximum number of nodes for this specific replica.
         */
        maxNodes: pulumi.Input<number>;
        /**
         * The minimum number of nodes for this specific replica.
         */
        minNodes: pulumi.Input<number>;
    }

    export interface InstanceAutoscalingConfigAsymmetricAutoscalingOptionReplicaSelection {
        /**
         * The location of the replica to apply asymmetric autoscaling options.
         */
        location: pulumi.Input<string>;
    }

    export interface InstanceAutoscalingConfigAutoscalingLimits {
        /**
         * The maximum number of nodes for this specific replica.
         */
        maxNodes?: pulumi.Input<number>;
        /**
         * Specifies maximum number of processing units allocated to the instance.
         * If set, this number should be multiples of 1000 and be greater than or equal to
         * min_processing_units.
         */
        maxProcessingUnits?: pulumi.Input<number>;
        /**
         * The minimum number of nodes for this specific replica.
         */
        minNodes?: pulumi.Input<number>;
        /**
         * Specifies minimum number of processing units allocated to the instance.
         * If set, this number should be multiples of 1000.
         */
        minProcessingUnits?: pulumi.Input<number>;
    }

    export interface InstanceAutoscalingConfigAutoscalingTargets {
        /**
         * Specifies the target high priority cpu utilization percentage that the autoscaler
         * should be trying to achieve for the instance.
         * This number is on a scale from 0 (no utilization) to 100 (full utilization)..
         */
        highPriorityCpuUtilizationPercent?: pulumi.Input<number>;
        /**
         * Specifies the target storage utilization percentage that the autoscaler
         * should be trying to achieve for the instance.
         * This number is on a scale from 0 (no utilization) to 100 (full utilization).
         */
        storageUtilizationPercent?: pulumi.Input<number>;
    }

    export interface InstanceConfigReplica {
        /**
         * If true, this location is designated as the default leader location where
         * leader replicas are placed.
         *
         * - - -
         */
        defaultLeaderLocation?: pulumi.Input<boolean>;
        /**
         * The location of the serving resources, e.g. "us-central1".
         */
        location?: pulumi.Input<string>;
        /**
         * Indicates the type of replica.  See the [replica types
         * documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
         * for more details.
         * Possible values are: `READ_WRITE`, `READ_ONLY`, `WITNESS`.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceIAMBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIAMMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace sql {
    export interface DatabaseInstanceClone {
        /**
         * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
         */
        allocatedIpRange?: pulumi.Input<string>;
        /**
         * (SQL Server only, use with `pointInTime`) Clone only the specified databases from the source instance. Clone all databases if empty.
         */
        databaseNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The timestamp of the point in time that should be restored.
         *
         * A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        pointInTime?: pulumi.Input<string>;
        /**
         * (Point-in-time recovery for PostgreSQL only) Clone to an instance in the specified zone. If no zone is specified, clone to the same zone as the source instance. [clone-unavailable-instance](https://cloud.google.com/sql/docs/postgres/clone-instance#clone-unavailable-instance)
         */
        preferredZone?: pulumi.Input<string>;
        /**
         * Name of the source instance which will be cloned.
         */
        sourceInstanceName: pulumi.Input<string>;
    }

    export interface DatabaseInstanceDnsName {
        /**
         * The connection type of the DNS name. Can be either `PUBLIC`, `PRIVATE_SERVICES_ACCESS`, or `PRIVATE_SERVICE_CONNECT`.
         */
        connectionType?: pulumi.Input<string>;
        /**
         * The scope that the DNS name applies to.
         */
        dnsScope?: pulumi.Input<string>;
        /**
         * The name of the instance. If the name is left
         * blank, the provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceIpAddress {
        /**
         * The IPv4 address assigned.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * The time this IP address will be retired, in RFC
         * 3339 format.
         */
        timeToRetire?: pulumi.Input<string>;
        /**
         * The type of this IP address.
         */
        type?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        /**
         * PEM representation of the trusted CA's x509
         * certificate.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * Specifies if the replica is a cascadable replica. If true, instance must be in different region from primary.
         *
         * > **NOTE:** Only supported for SQL Server database.
         */
        cascadableReplica?: pulumi.Input<boolean>;
        /**
         * PEM representation of the replica's x509
         * certificate.
         */
        clientCertificate?: pulumi.Input<string>;
        /**
         * PEM representation of the replica's private key. The
         * corresponding public key in encoded in the `clientCertificate`.
         */
        clientKey?: pulumi.Input<string>;
        /**
         * The number of seconds
         * between connect retries. MySQL's default is 60 seconds.
         */
        connectRetryInterval?: pulumi.Input<number>;
        /**
         * Path to a SQL file in GCS from which replica
         * instances are created. Format is `gs://bucket/filename`. Note, if the master
         * instance is a source representation instance this field must be present.
         */
        dumpFilePath?: pulumi.Input<string>;
        /**
         * Specifies if the replica is the failover target.
         * If the field is set to true the replica will be designated as a failover replica.
         * If the master instance fails, the replica instance will be promoted as
         * the new master instance.
         * > **NOTE:** Not supported for Postgres database.
         */
        failoverTarget?: pulumi.Input<boolean>;
        /**
         * Time in ms between replication
         * heartbeats.
         */
        masterHeartbeatPeriod?: pulumi.Input<number>;
        /**
         * Password for the replication connection.
         */
        password?: pulumi.Input<string>;
        /**
         * Permissible ciphers for use in SSL encryption.
         */
        sslCipher?: pulumi.Input<string>;
        /**
         * Username for replication connection.
         */
        username?: pulumi.Input<string>;
        /**
         * True if the master's common name
         * value is checked during the SSL handshake.
         */
        verifyServerCertificate?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceReplicationCluster {
        /**
         * Read-only field that indicates whether the replica is a DR replica.
         */
        drReplica?: pulumi.Input<boolean>;
        /**
         * If the instance is a primary instance, then this field identifies the disaster recovery (DR) replica. The standard format of this field is "your-project:your-instance". You can also set this field to "your-instance", but cloud SQL backend will convert it to the aforementioned standard format.
         */
        failoverDrReplicaName?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceRestoreBackupContext {
        /**
         * The ID of the backup run to restore from.
         */
        backupRunId: pulumi.Input<number>;
        /**
         * The ID of the instance that the backup was taken from. If left empty,
         * this instance's ID will be used.
         */
        instanceId?: pulumi.Input<string>;
        /**
         * The full project ID of the source instance.`
         */
        project?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceServerCaCert {
        /**
         * The CA Certificate used to connect to the SQL Instance via SSL.
         */
        cert?: pulumi.Input<string>;
        /**
         * The CN valid for the CA Cert.
         */
        commonName?: pulumi.Input<string>;
        /**
         * Creation time of the CA Cert.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Expiration time of the CA Cert.
         */
        expirationTime?: pulumi.Input<string>;
        /**
         * SHA Fingerprint of the CA Cert.
         */
        sha1Fingerprint?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettings {
        /**
         * This specifies when the instance should be
         * active. Can be either `ALWAYS`, `NEVER` or `ON_DEMAND`.
         */
        activationPolicy?: pulumi.Input<string>;
        activeDirectoryConfig?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsActiveDirectoryConfig>;
        advancedMachineFeatures?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsAdvancedMachineFeatures>;
        /**
         * The availability type of the Cloud SQL
         * instance, high availability (`REGIONAL`) or single zone (`ZONAL`).' For all instances, ensure that
         * `settings.backup_configuration.enabled` is set to `true`.
         * For MySQL instances, ensure that `settings.backup_configuration.binary_log_enabled` is set to `true`.
         * For Postgres and SQL Server instances, ensure that `settings.backup_configuration.point_in_time_recovery_enabled`
         * is set to `true`. Defaults to `ZONAL`.
         */
        availabilityType?: pulumi.Input<string>;
        backupConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsBackupConfiguration>;
        /**
         * The name of server instance collation.
         */
        collation?: pulumi.Input<string>;
        /**
         * The managed connection pool setting for a Cloud SQL instance.
         */
        connectionPoolConfigs?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsConnectionPoolConfig>[]>;
        /**
         * Control the enforcement of Cloud SQL Auth Proxy or Cloud SQL connectors for all the connections, can be `REQUIRED` or `NOT_REQUIRED`. If enabled, all the direct connections are rejected.
         */
        connectorEnforcement?: pulumi.Input<string>;
        /**
         * Data cache configurations.
         */
        dataCacheConfig?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsDataCacheConfig>;
        /**
         * Provisioned number of I/O operations per second for the data disk. This field is only used for `HYPERDISK_BALANCED` disk types.
         */
        dataDiskProvisionedIops?: pulumi.Input<number>;
        /**
         * Provisioned throughput measured in MiB per second for the data disk. This field is only used for `HYPERDISK_BALANCED` disk types.
         */
        dataDiskProvisionedThroughput?: pulumi.Input<number>;
        databaseFlags?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsDatabaseFlag>[]>;
        /**
         * Configuration to protect against accidental instance deletion.
         */
        deletionProtectionEnabled?: pulumi.Input<boolean>;
        denyMaintenancePeriod?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsDenyMaintenancePeriod>;
        /**
         * Enables auto-resizing of the storage size. Defaults to `true`. Note that if `diskSize` is set, future `pulumi up` calls will attempt to delete the instance in order to resize the disk to the value specified in diskSize if it has been resized. To avoid this, ensure that `lifecycle.ignore_changes` is applied to `diskSize`.
         */
        diskAutoresize?: pulumi.Input<boolean>;
        /**
         * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
         */
        diskAutoresizeLimit?: pulumi.Input<number>;
        /**
         * The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB for PD_SSD, PD_HDD and 20GB for HYPERDISK_BALANCED. Note that this value will override the resizing from `diskAutoresize` if that feature is enabled. To avoid this, set `lifecycle.ignore_changes` on this field.
         */
        diskSize?: pulumi.Input<number>;
        /**
         * The type of data disk: PD_SSD, PD_HDD, or HYPERDISK_BALANCED. Defaults to `PD_SSD`. HYPERDISK_BALANCED is preview.
         */
        diskType?: pulumi.Input<string>;
        /**
         * The edition of the instance, can be `ENTERPRISE` or `ENTERPRISE_PLUS`.
         */
        edition?: pulumi.Input<string>;
        /**
         * Enables [Cloud SQL instance integration with Dataplex](https://cloud.google.com/sql/docs/mysql/dataplex-catalog-integration). MySQL, Postgres and SQL Server instances are supported for this feature. Defaults to `false`.
         */
        enableDataplexIntegration?: pulumi.Input<boolean>;
        /**
         * Enables [Cloud SQL instances to connect to Vertex AI](https://cloud.google.com/sql/docs/postgres/integrate-cloud-sql-with-vertex-ai) and pass requests for real-time predictions and insights. Defaults to `false`.
         */
        enableGoogleMlIntegration?: pulumi.Input<boolean>;
        /**
         * Configuration of Query Insights.
         */
        insightsConfig?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsInsightsConfig>;
        ipConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfiguration>;
        locationPreference?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsLocationPreference>;
        /**
         * Declares a one-hour maintenance window when an Instance can automatically restart to apply updates. The maintenance window is specified in UTC time.
         */
        maintenanceWindow?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsMaintenanceWindow>;
        passwordValidationPolicy?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsPasswordValidationPolicy>;
        /**
         * Pricing plan for this instance, can only be `PER_USE`.
         */
        pricingPlan?: pulumi.Input<string>;
        /**
         * When this parameter is set to true, Cloud SQL retains backups of the instance even after the instance is deleted. The `ON_DEMAND` backup will be retained until customer deletes the backup or the project. The `AUTOMATED` backup will be retained based on the backups retention setting.
         */
        retainBackupsOnDelete?: pulumi.Input<boolean>;
        sqlServerAuditConfig?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsSqlServerAuditConfig>;
        /**
         * The machine type to use. See [tiers](https://cloud.google.com/sql/docs/admin-api/v1beta4/tiers)
         * for more details and supported versions. Postgres supports only shared-core machine types,
         * and custom machine types such as `db-custom-2-13312`. See the [Custom Machine Type Documentation](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) to learn about specifying custom machine types.
         */
        tier: pulumi.Input<string>;
        /**
         * The timeZone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
         */
        timeZone?: pulumi.Input<string>;
        /**
         * A set of key/value user label pairs to assign to the instance.
         */
        userLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Used to make sure changes to the `settings` block are
         * atomic.
         */
        version?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsActiveDirectoryConfig {
        /**
         * The domain name for the active directory (e.g., mydomain.com).
         * Can only be used with SQL Server.
         */
        domain: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsAdvancedMachineFeatures {
        /**
         * The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See [smt](https://cloud.google.com/sql/docs/sqlserver/create-instance#smt-create-instance) for more details.
         */
        threadsPerCore?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        /**
         * Backup retention settings. The configuration is detailed below.
         */
        backupRetentionSettings?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsBackupConfigurationBackupRetentionSettings>;
        /**
         * True if binary logging is enabled.
         * Can only be used with MySQL.
         */
        binaryLogEnabled?: pulumi.Input<boolean>;
        /**
         * True if backup configuration is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The region where the backup will be stored
         */
        location?: pulumi.Input<string>;
        /**
         * True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances. Enabled by default for PostgreSQL Enterprise Plus and SQL Server Enterprise Plus instances.
         */
        pointInTimeRecoveryEnabled?: pulumi.Input<boolean>;
        /**
         * `HH:MM` format time indicating when backup
         * configuration starts.
         */
        startTime?: pulumi.Input<string>;
        /**
         * The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus and SQL Server Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
         */
        transactionLogRetentionDays?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsBackupConfigurationBackupRetentionSettings {
        /**
         * Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retentionUnit
         * is 'COUNT', we will retain this many backups.
         */
        retainedBackups: pulumi.Input<number>;
        /**
         * The unit that 'retained_backups' represents. Defaults to `COUNT`.
         */
        retentionUnit?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsConnectionPoolConfig {
        /**
         * True if the manager connection pooling configuration is enabled.
         */
        connectionPoolingEnabled?: pulumi.Input<boolean>;
        /**
         * List of connection pool configuration flags
         */
        flags?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsConnectionPoolConfigFlag>[]>;
    }

    export interface DatabaseInstanceSettingsConnectionPoolConfigFlag {
        /**
         * Name of the flag.
         */
        name: pulumi.Input<string>;
        /**
         * Value of the flag.
         */
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsDataCacheConfig {
        /**
         * Whether data cache is enabled for the instance. Defaults to `false`. Can be used with MYSQL and PostgreSQL only.
         */
        dataCacheEnabled?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * Name of the flag.
         */
        name: pulumi.Input<string>;
        /**
         * Value of the flag.
         */
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsDenyMaintenancePeriod {
        /**
         * "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-m-dd (the month is without leading zeros)i.e., 2020-1-01, or 2020-11-01, or mm-dd, i.e., 11-01
         */
        endDate: pulumi.Input<string>;
        /**
         * "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-m-dd (the month is without leading zeros)i.e., 2020-1-01, or 2020-11-01, or mm-dd, i.e., 11-01
         */
        startDate: pulumi.Input<string>;
        /**
         * Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
         */
        time: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsInsightsConfig {
        /**
         * True if Query Insights feature is enabled.
         */
        queryInsightsEnabled?: pulumi.Input<boolean>;
        /**
         * Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
         */
        queryPlansPerMinute?: pulumi.Input<number>;
        /**
         * Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
         */
        queryStringLength?: pulumi.Input<number>;
        /**
         * True if Query Insights will record application tags from query when enabled.
         */
        recordApplicationTags?: pulumi.Input<boolean>;
        /**
         * True if Query Insights will record client address when enabled.
         */
        recordClientAddress?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        /**
         * The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035). Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
         */
        allocatedIpRange?: pulumi.Input<string>;
        authorizedNetworks?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork>[]>;
        /**
         * The custom subject alternative names for an instance with `CUSTOMER_MANAGED_CAS_CA` as the `serverCaMode`.
         */
        customSubjectAlternativeNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
         */
        enablePrivatePathForGoogleCloudServices?: pulumi.Input<boolean>;
        /**
         * Whether this Cloud SQL instance should be assigned
         * a public IPV4 address. At least `ipv4Enabled` must be enabled or a
         * `privateNetwork` must be configured.
         */
        ipv4Enabled?: pulumi.Input<boolean>;
        /**
         * The VPC network from which the Cloud SQL
         * instance is accessible for private IP. For example,projects/myProject/global/networks/default.
         * Specifying a network enables private IP.
         * At least `ipv4Enabled` must be enabled or a `privateNetwork` must be configured.
         * This setting can be updated, but it cannot be removed after it is set.
         */
        privateNetwork?: pulumi.Input<string>;
        /**
         * PSC settings for a Cloud SQL instance.
         */
        pscConfigs?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationPscConfig>[]>;
        /**
         * Specify how the server certificate's Certificate Authority is hosted. Supported values are `GOOGLE_MANAGED_INTERNAL_CA` and `GOOGLE_MANAGED_CAS_CA`.
         */
        serverCaMode?: pulumi.Input<string>;
        /**
         * The resource name of the server CA pool for an instance with `CUSTOMER_MANAGED_CAS_CA` as the `serverCaMode`.
         */
        serverCaPool?: pulumi.Input<string>;
        /**
         * Specify how SSL connection should be enforced in DB connections. Supported values are `ALLOW_UNENCRYPTED_AND_ENCRYPTED`, `ENCRYPTED_ONLY`, and `TRUSTED_CLIENT_CERTIFICATE_REQUIRED` (not supported for SQL Server). See [API reference doc](https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration) for details.
         */
        sslMode?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        /**
         * The [RFC 3339](https://tools.ietf.org/html/rfc3339)
         * formatted date time string indicating when this whitelist expires.
         */
        expirationTime?: pulumi.Input<string>;
        /**
         * A name for this whitelist entry.
         */
        name?: pulumi.Input<string>;
        /**
         * A CIDR notation IPv4 or IPv6 address that is allowed to
         * access this instance. Must be set even if other two attributes are not for
         * the whitelist to become active.
         */
        value: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationPscConfig {
        /**
         * List of consumer projects that are allow-listed for PSC connections to this instance. This instance can be connected to with PSC from any network in these projects. Each consumer project in this list may be represented by a project number (numeric) or by a project id (alphanumeric).
         */
        allowedConsumerProjects?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A comma-separated list of networks or a comma-separated list of network-project pairs. Each project in this list is represented by a project number (numeric) or by a project ID (alphanumeric). This allows Private Service Connect connections to be created automatically for the specified networks.
         */
        pscAutoConnections?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationPscConfigPscAutoConnection>[]>;
        /**
         * Whether PSC connectivity is enabled for this instance.
         */
        pscEnabled?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationPscConfigPscAutoConnection {
        /**
         * "The consumer network of this consumer endpoint. This must be a resource path that includes both the host project and the network name. For example, `projects/project1/global/networks/network1`. The consumer host project of this network might be different from the consumer service project."
         */
        consumerNetwork: pulumi.Input<string>;
        /**
         * The project ID of consumer service project of this consumer endpoint.
         */
        consumerServiceProjectId?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        /**
         * A GAE application whose zone to remain
         * in. Must be in the same region as this instance.
         */
        followGaeApplication?: pulumi.Input<string>;
        /**
         * The preferred Compute Engine zone for the secondary/failover.
         */
        secondaryZone?: pulumi.Input<string>;
        /**
         * The preferred compute engine
         * [zone](https://cloud.google.com/compute/docs/zones?hl=en).
         */
        zone?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        /**
         * Day of week (`1-7`), starting on Monday
         */
        day?: pulumi.Input<number>;
        /**
         * Hour of day (`0-23`), ignored if `day` not set
         */
        hour?: pulumi.Input<number>;
        /**
         * Receive updates after one week (`canary`) or after two weeks (`stable`) or after five weeks (`week5`) of notification.
         */
        updateTrack?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsPasswordValidationPolicy {
        /**
         * Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
         */
        complexity?: pulumi.Input<string>;
        /**
         * Prevents the use of the username in the password.
         */
        disallowUsernameSubstring?: pulumi.Input<boolean>;
        /**
         * Enables or disable the password validation policy.
         */
        enablePasswordPolicy: pulumi.Input<boolean>;
        /**
         * Specifies the minimum number of characters that the password must have.
         */
        minLength?: pulumi.Input<number>;
        /**
         * Specifies the minimum duration after which you can change the password.
         */
        passwordChangeInterval?: pulumi.Input<string>;
        /**
         * Specifies the number of previous passwords that you can't reuse.
         */
        reuseInterval?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsSqlServerAuditConfig {
        /**
         * The name of the destination bucket (e.g., gs://mybucket).
         */
        bucket?: pulumi.Input<string>;
        /**
         * How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        retentionInterval?: pulumi.Input<string>;
        /**
         * How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        uploadInterval?: pulumi.Input<string>;
    }

    export interface UserPasswordPolicy {
        /**
         * Number of failed attempts allowed before the user get locked.
         */
        allowedFailedAttempts?: pulumi.Input<number>;
        /**
         * If true, the check that will lock user after too many failed login attempts will be enabled.
         */
        enableFailedAttemptsCheck?: pulumi.Input<boolean>;
        /**
         * If true, the user must specify the current password before changing the password. This flag is supported only for MySQL.
         */
        enablePasswordVerification?: pulumi.Input<boolean>;
        /**
         * Password expiration duration with one week grace period.
         */
        passwordExpirationDuration?: pulumi.Input<string>;
        statuses?: pulumi.Input<pulumi.Input<inputs.sql.UserPasswordPolicyStatus>[]>;
    }

    export interface UserPasswordPolicyStatus {
        /**
         * If true, user does not have login privileges.
         */
        locked?: pulumi.Input<boolean>;
        /**
         * Password expiration duration with one week grace period.
         */
        passwordExpirationTime?: pulumi.Input<string>;
    }

    export interface UserSqlServerUserDetail {
        /**
         * If the user has been disabled.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * The server roles for this user in the database.
         */
        serverRoles?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace storage {
    export interface BatchOperationsJobBucketList {
        /**
         * List of buckets and their objects to be transformed.
         * Structure is documented below.
         */
        buckets: pulumi.Input<inputs.storage.BatchOperationsJobBucketListBuckets>;
    }

    export interface BatchOperationsJobBucketListBuckets {
        /**
         * Bucket name for the objects to be transformed.
         */
        bucket: pulumi.Input<string>;
        /**
         * contain the manifest source file that is a CSV file in a Google Cloud Storage bucket.
         * Structure is documented below.
         */
        manifest?: pulumi.Input<inputs.storage.BatchOperationsJobBucketListBucketsManifest>;
        /**
         * Specifies objects matching a prefix set.
         * Structure is documented below.
         */
        prefixList?: pulumi.Input<inputs.storage.BatchOperationsJobBucketListBucketsPrefixList>;
    }

    export interface BatchOperationsJobBucketListBucketsManifest {
        /**
         * Specifies objects in a manifest file.
         */
        manifestLocation?: pulumi.Input<string>;
    }

    export interface BatchOperationsJobBucketListBucketsPrefixList {
        /**
         * (Optional)
         */
        includedObjectPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BatchOperationsJobDeleteObject {
        /**
         * enable flag to permanently delete object and all object versions if versioning is enabled on bucket.
         */
        permanentObjectDeletionEnabled: pulumi.Input<boolean>;
    }

    export interface BatchOperationsJobPutMetadata {
        /**
         * Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
         */
        cacheControl?: pulumi.Input<string>;
        /**
         * Content-Disposition of the object data.
         */
        contentDisposition?: pulumi.Input<string>;
        /**
         * Content Encoding of the object data.
         */
        contentEncoding?: pulumi.Input<string>;
        /**
         * Content-Language of the object data.
         */
        contentLanguage?: pulumi.Input<string>;
        /**
         * Content-Type of the object data.
         */
        contentType?: pulumi.Input<string>;
        /**
         * User-provided metadata, in key/value pairs.
         */
        customMetadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Updates the objects fixed custom time metadata.
         */
        customTime?: pulumi.Input<string>;
    }

    export interface BatchOperationsJobPutObjectHold {
        /**
         * set/unset to update event based hold for objects.
         */
        eventBasedHold?: pulumi.Input<string>;
        /**
         * set/unset to update temporary based hold for objects.
         */
        temporaryHold?: pulumi.Input<string>;
    }

    export interface BatchOperationsJobRewriteObject {
        /**
         * valid kms key
         */
        kmsKey: pulumi.Input<string>;
    }

    export interface BucketAutoclass {
        /**
         * While set to `true`, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: `NEARLINE`, `ARCHIVE`.
         */
        terminalStorageClass?: pulumi.Input<string>;
    }

    export interface BucketCor {
        /**
         * The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
         */
        maxAgeSeconds?: pulumi.Input<number>;
        /**
         * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
         */
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
         */
        origins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
         */
        responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BucketCustomPlacementConfig {
        /**
         * The list of individual regions that comprise a dual-region bucket. See [Cloud Storage bucket locations](https://cloud.google.com/storage/docs/dual-regions#availability) for a list of acceptable regions. **Note**: If any of the dataLocations changes, it will [recreate the bucket](https://cloud.google.com/storage/docs/locations#key-concepts).
         */
        dataLocations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BucketEncryption {
        /**
         * The `id` of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
         * You must pay attention to whether the crypto key is available in the location that this bucket is created in.
         * See [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for more details.
         *
         * > As per [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for customer-managed encryption keys, the IAM policy for the
         * specified key must permit the [automatic Google Cloud Storage service account](https://cloud.google.com/storage/docs/projects#service-accounts) for the bucket's
         * project to use the specified key for encryption and decryption operations.
         * Although the service account email address follows a well-known format, the service account is created on-demand and may not necessarily exist for your project
         * until a relevant action has occurred which triggers its creation.
         * You should use the [`gcp.storage.getProjectServiceAccount`](https://www.terraform.io/docs/providers/google/d/storage_project_service_account.html) data source to obtain the email
         * address for the service account when configuring IAM policy on the Cloud KMS key.
         * This data source calls an API which creates the account if required, ensuring your provider applies cleanly and repeatedly irrespective of the
         * state of the project.
         * You should take care for race conditions when the same provider manages IAM policy on the Cloud KMS crypto key. See the data source page for more details.
         */
        defaultKmsKeyName: pulumi.Input<string>;
    }

    export interface BucketHierarchicalNamespace {
        /**
         * Enables hierarchical namespace for the bucket.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface BucketIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BucketIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         *
         * > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
         * identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
         * consider it to be an entirely different resource and will treat it as such.
         */
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface BucketLifecycleRule {
        /**
         * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
         */
        action: pulumi.Input<inputs.storage.BucketLifecycleRuleAction>;
        /**
         * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
         */
        condition: pulumi.Input<inputs.storage.BucketLifecycleRuleCondition>;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`.
         */
        storageClass?: pulumi.Input<string>;
        /**
         * The type of the action of this Lifecycle Rule. Supported values include: `Delete`, `SetStorageClass` and `AbortIncompleteMultipartUpload`.
         */
        type: pulumi.Input<string>;
    }

    export interface BucketLifecycleRuleCondition {
        /**
         * Minimum age of an object in days to satisfy this condition. **Note** To set `0` value of `age`, `sendAgeIfZero` should be set `true` otherwise `0` value of `age` field will be ignored.
         */
        age?: pulumi.Input<number>;
        /**
         * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
         */
        createdBefore?: pulumi.Input<string>;
        /**
         * A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
         */
        customTimeBefore?: pulumi.Input<string>;
        /**
         * Number of days elapsed since the user-specified timestamp set on an object.
         */
        daysSinceCustomTime?: pulumi.Input<number>;
        /**
         * Number of days elapsed since the noncurrent timestamp of an object. This
         * 										condition is relevant only for versioned objects.
         */
        daysSinceNoncurrentTime?: pulumi.Input<number>;
        /**
         * One or more matching name prefixes to satisfy this condition.
         */
        matchesPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `DURABLE_REDUCED_AVAILABILITY`.
         */
        matchesStorageClasses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * One or more matching name suffixes to satisfy this condition.
         */
        matchesSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.
         */
        noncurrentTimeBefore?: pulumi.Input<string>;
        /**
         * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
         */
        numNewerVersions?: pulumi.Input<number>;
        /**
         * While set true, `age` value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the `age` field. It can be used alone or together with `age` attribute. **NOTE** `age` attibute with `0` value will be ommitted from the API request if `sendAgeIfZero` field is having `false` value.
         */
        sendAgeIfZero?: pulumi.Input<boolean>;
        /**
         * While set true, `daysSinceCustomTime` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `daysSinceCustomTime` field. It can be used alone or together with `daysSinceCustomTime`.
         */
        sendDaysSinceCustomTimeIfZero?: pulumi.Input<boolean>;
        /**
         * While set true, `daysSinceNoncurrentTime` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `daysSinceNoncurrentTime` field. It can be used alone or together with `daysSinceNoncurrentTime`.
         */
        sendDaysSinceNoncurrentTimeIfZero?: pulumi.Input<boolean>;
        /**
         * While set true, `numNewerVersions` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `numNewerVersions` field. It can be used alone or together with `numNewerVersions`.
         */
        sendNumNewerVersionsIfZero?: pulumi.Input<boolean>;
        /**
         * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
         */
        withState?: pulumi.Input<string>;
    }

    export interface BucketLogging {
        /**
         * The bucket that will receive log objects.
         */
        logBucket: pulumi.Input<string>;
        /**
         * The object prefix for log objects. If it's not provided,
         * by default GCS sets this to this bucket's name.
         */
        logObjectPrefix?: pulumi.Input<string>;
    }

    export interface BucketObjectCustomerEncryption {
        /**
         * Encryption algorithm. Default: AES256
         */
        encryptionAlgorithm?: pulumi.Input<string>;
        /**
         * Base64 encoded Customer-Supplied Encryption Key.
         */
        encryptionKey: pulumi.Input<string>;
    }

    export interface BucketObjectRetention {
        /**
         * The retention policy mode. Either `Locked` or `Unlocked`.
         */
        mode: pulumi.Input<string>;
        /**
         * The time to retain the object until in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.
         *
         * <a name>
         */
        retainUntilTime: pulumi.Input<string>;
    }

    export interface BucketRetentionPolicy {
        /**
         * If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
         */
        isLocked?: pulumi.Input<boolean>;
        /**
         * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 2,147,483,647 seconds.
         */
        retentionPeriod: pulumi.Input<number>;
    }

    export interface BucketSoftDeletePolicy {
        /**
         * Server-determined value that indicates the time from which the policy, or one with a greater retention, was effective. This value is in RFC 3339 format.
         */
        effectiveTime?: pulumi.Input<string>;
        /**
         * The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). **Note**: To disable the soft delete policy on a bucket, This field must be set to 0.
         */
        retentionDurationSeconds?: pulumi.Input<number>;
    }

    export interface BucketVersioning {
        /**
         * While set to `true`, versioning is fully enabled for this bucket.
         */
        enabled: pulumi.Input<boolean>;
    }

    export interface BucketWebsite {
        /**
         * Behaves as the bucket's directory index where
         * missing objects are treated as potential directories.
         */
        mainPageSuffix?: pulumi.Input<string>;
        /**
         * The custom object to return when a requested
         * resource is not found.
         */
        notFoundPage?: pulumi.Input<string>;
    }

    export interface ControlFolderIntelligenceConfigEffectiveIntelligenceConfig {
        /**
         * (Output)
         * The `StorageIntelligence` edition that is applicable for the resource.
         */
        effectiveEdition?: pulumi.Input<string>;
        /**
         * (Output)
         * The Intelligence config resource that is applied for the target resource.
         */
        intelligenceConfig?: pulumi.Input<string>;
    }

    export interface ControlFolderIntelligenceConfigFilter {
        /**
         * Buckets to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlFolderIntelligenceConfigFilterExcludedCloudStorageBuckets>;
        /**
         * Locations to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocations>;
        /**
         * Buckets to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlFolderIntelligenceConfigFilterIncludedCloudStorageBuckets>;
        /**
         * Locations to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocations>;
    }

    export interface ControlFolderIntelligenceConfigFilterExcludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlFolderIntelligenceConfigFilterIncludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlFolderIntelligenceConfigTrialConfig {
        /**
         * (Output)
         * The time at which the trial expires.
         */
        expireTime?: pulumi.Input<string>;
    }

    export interface ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfig {
        /**
         * (Output)
         * The `StorageIntelligence` edition that is applicable for the resource.
         */
        effectiveEdition?: pulumi.Input<string>;
        /**
         * (Output)
         * The Intelligence config resource that is applied for the target resource.
         */
        intelligenceConfig?: pulumi.Input<string>;
    }

    export interface ControlOrganizationIntelligenceConfigFilter {
        /**
         * Buckets to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBuckets>;
        /**
         * Locations to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocations>;
        /**
         * Buckets to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBuckets>;
        /**
         * Locations to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocations>;
    }

    export interface ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlOrganizationIntelligenceConfigTrialConfig {
        /**
         * (Output)
         * The time at which the trial expires.
         */
        expireTime?: pulumi.Input<string>;
    }

    export interface ControlProjectIntelligenceConfigEffectiveIntelligenceConfig {
        /**
         * (Output)
         * The `StorageIntelligence` edition that is applicable for the resource.
         */
        effectiveEdition?: pulumi.Input<string>;
        /**
         * (Output)
         * The Intelligence config resource that is applied for the target resource.
         */
        intelligenceConfig?: pulumi.Input<string>;
    }

    export interface ControlProjectIntelligenceConfigFilter {
        /**
         * Buckets to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlProjectIntelligenceConfigFilterExcludedCloudStorageBuckets>;
        /**
         * Locations to exclude from the Storage Intelligence plan.
         * Structure is documented below.
         */
        excludedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocations>;
        /**
         * Buckets to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageBuckets?: pulumi.Input<inputs.storage.ControlProjectIntelligenceConfigFilterIncludedCloudStorageBuckets>;
        /**
         * Locations to include in the Storage Intelligence plan.
         * Structure is documented below.
         */
        includedCloudStorageLocations?: pulumi.Input<inputs.storage.ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocations>;
    }

    export interface ControlProjectIntelligenceConfigFilterExcludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlProjectIntelligenceConfigFilterIncludedCloudStorageBuckets {
        /**
         * List of bucket id regexes to exclude in the storage intelligence plan.
         */
        bucketIdRegexes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocations {
        /**
         * List of locations.
         */
        locations: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ControlProjectIntelligenceConfigTrialConfig {
        /**
         * (Output)
         * The time at which the trial expires.
         */
        expireTime?: pulumi.Input<string>;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        /**
         * The project team associated with the entity
         */
        projectNumber?: pulumi.Input<string>;
        /**
         * The team.
         * Possible values are: `editors`, `owners`, `viewers`.
         */
        team?: pulumi.Input<string>;
    }

    export interface InsightsReportConfigCsvOptions {
        /**
         * The delimiter used to separate the fields in the inventory report CSV file.
         */
        delimiter?: pulumi.Input<string>;
        /**
         * The boolean that indicates whether or not headers are included in the inventory report CSV file.
         */
        headerRequired?: pulumi.Input<boolean>;
        /**
         * The character used to separate the records in the inventory report CSV file.
         */
        recordSeparator?: pulumi.Input<string>;
    }

    export interface InsightsReportConfigFrequencyOptions {
        /**
         * The date to stop generating inventory reports. For example, {"day": 15, "month": 9, "year": 2022}.
         * Structure is documented below.
         */
        endDate: pulumi.Input<inputs.storage.InsightsReportConfigFrequencyOptionsEndDate>;
        /**
         * The frequency in which inventory reports are generated. Values are DAILY or WEEKLY.
         * Possible values are: `DAILY`, `WEEKLY`.
         */
        frequency: pulumi.Input<string>;
        /**
         * The date to start generating inventory reports. For example, {"day": 15, "month": 8, "year": 2022}.
         * Structure is documented below.
         */
        startDate: pulumi.Input<inputs.storage.InsightsReportConfigFrequencyOptionsStartDate>;
    }

    export interface InsightsReportConfigFrequencyOptionsEndDate {
        /**
         * The day of the month to stop generating inventory reports.
         */
        day: pulumi.Input<number>;
        /**
         * The month to stop generating inventory reports.
         */
        month: pulumi.Input<number>;
        /**
         * The year to stop generating inventory reports
         */
        year: pulumi.Input<number>;
    }

    export interface InsightsReportConfigFrequencyOptionsStartDate {
        /**
         * The day of the month to start generating inventory reports.
         */
        day: pulumi.Input<number>;
        /**
         * The month to start generating inventory reports.
         */
        month: pulumi.Input<number>;
        /**
         * The year to start generating inventory reports
         */
        year: pulumi.Input<number>;
    }

    export interface InsightsReportConfigObjectMetadataReportOptions {
        /**
         * The metadata fields included in an inventory report.
         */
        metadataFields: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Options for where the inventory reports are stored.
         * Structure is documented below.
         */
        storageDestinationOptions: pulumi.Input<inputs.storage.InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptions>;
        /**
         * A nested object resource.
         * Structure is documented below.
         */
        storageFilters?: pulumi.Input<inputs.storage.InsightsReportConfigObjectMetadataReportOptionsStorageFilters>;
    }

    export interface InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptions {
        /**
         * The destination bucket that stores the generated inventory reports.
         */
        bucket: pulumi.Input<string>;
        /**
         * The path within the destination bucket to store generated inventory reports.
         */
        destinationPath?: pulumi.Input<string>;
    }

    export interface InsightsReportConfigObjectMetadataReportOptionsStorageFilters {
        /**
         * The filter to use when specifying which bucket to generate inventory reports for.
         */
        bucket?: pulumi.Input<string>;
    }

    export interface InsightsReportConfigParquetOptions {
    }

    export interface ManagedFolderIamBindingCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ManagedFolderIamMemberCondition {
        description?: pulumi.Input<string>;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: pulumi.Input<string>;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: pulumi.Input<string>;
    }

    export interface ObjectAccessControlProjectTeam {
        /**
         * The project team associated with the entity
         */
        projectNumber?: pulumi.Input<string>;
        /**
         * The team.
         * Possible values are: `editors`, `owners`, `viewers`.
         */
        team?: pulumi.Input<string>;
    }

    export interface TransferAgentPoolBandwidthLimit {
        /**
         * Bandwidth rate in megabytes per second, distributed across all the agents in the pool.
         */
        limitMbps: pulumi.Input<string>;
    }

    export interface TransferJobEventStream {
        /**
         * Specifies the data and time at which Storage Transfer Service stops listening for events from this stream. After this time, any transfers in progress will complete, but no new transfers are initiated.A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        eventStreamExpirationTime?: pulumi.Input<string>;
        /**
         * Specifies the date and time that Storage Transfer Service starts listening for events from this stream. If no start time is specified or start time is in the past, Storage Transfer Service starts listening immediately. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        eventStreamStartTime?: pulumi.Input<string>;
        /**
         * Specifies a unique name of the resource such as AWS SQS ARN in the form 'arn:aws:sqs:region:account_id:queue_name', or Pub/Sub subscription resource name in the form 'projects/{project}/subscriptions/{sub}'.
         */
        name: pulumi.Input<string>;
    }

    export interface TransferJobLoggingConfig {
        /**
         * For transfers with a PosixFilesystem source, this option enables the Cloud Storage transfer logs for this transfer.
         */
        enableOnPremGcsTransferLogs?: pulumi.Input<boolean>;
        /**
         * States in which logActions are logged. Not supported for transfers with PosifxFilesystem data sources; use enableOnPremGcsTransferLogs instead.
         */
        logActionStates?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the actions to be logged. Not supported for transfers with PosifxFilesystem data sources; use enableOnPremGcsTransferLogs instead.
         */
        logActions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TransferJobNotificationConfig {
        /**
         * Event types for which a notification is desired. If empty, send notifications for all event types. The valid types are "TRANSFER_OPERATION_SUCCESS", "TRANSFER_OPERATION_FAILED", "TRANSFER_OPERATION_ABORTED".
         */
        eventTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The desired format of the notification message payloads. One of "NONE" or "JSON".
         */
        payloadFormat: pulumi.Input<string>;
        /**
         * The Topic.name of the Pub/Sub topic to which to publish notifications. Must be of the format: projects/{project}/topics/{topic}. Not matching this format results in an INVALID_ARGUMENT error.
         */
        pubsubTopic: pulumi.Input<string>;
    }

    export interface TransferJobReplicationSpec {
        /**
         * A Google Cloud Storage data sink. Structure documented below.
         */
        gcsDataSink?: pulumi.Input<inputs.storage.TransferJobReplicationSpecGcsDataSink>;
        /**
         * A Google Cloud Storage data source. Structure documented below.
         */
        gcsDataSource?: pulumi.Input<inputs.storage.TransferJobReplicationSpecGcsDataSource>;
        /**
         * Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `lastModificationTime` do not exclude objects in a data sink. Structure documented below.
         */
        objectConditions?: pulumi.Input<inputs.storage.TransferJobReplicationSpecObjectConditions>;
        /**
         * Characteristics of how to treat files from datasource and sink during job. If the option `deleteObjectsUniqueInSink` is true, object conditions based on objects' `lastModificationTime` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
         */
        transferOptions?: pulumi.Input<inputs.storage.TransferJobReplicationSpecTransferOptions>;
    }

    export interface TransferJobReplicationSpecGcsDataSink {
        /**
         * Google Cloud Storage bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path?: pulumi.Input<string>;
    }

    export interface TransferJobReplicationSpecGcsDataSource {
        /**
         * Google Cloud Storage bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path?: pulumi.Input<string>;
    }

    export interface TransferJobReplicationSpecObjectConditions {
        /**
         * `excludePrefixes` must follow the requirements described for `includePrefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        excludePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If `includePrefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `includePrefixes` and that do not start with any of the `excludePrefixes`. If `includePrefixes` is not specified, all objects except those that have names starting with one of the `excludePrefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        includePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastModifiedBefore?: pulumi.Input<string>;
        /**
         * If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastModifiedSince?: pulumi.Input<string>;
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxTimeElapsedSinceLastModification?: pulumi.Input<string>;
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minTimeElapsedSinceLastModification?: pulumi.Input<string>;
    }

    export interface TransferJobReplicationSpecTransferOptions {
        /**
         * Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `deleteObjectsUniqueInSink` are mutually exclusive.
         */
        deleteObjectsFromSourceAfterTransfer?: pulumi.Input<boolean>;
        /**
         * Whether objects that exist only in the sink should be deleted. Note that this option and
         * `deleteObjectsFromSourceAfterTransfer` are mutually exclusive.
         */
        deleteObjectsUniqueInSink?: pulumi.Input<boolean>;
        /**
         * Specifies the metadata options for running a transfer
         */
        metadataOptions?: pulumi.Input<inputs.storage.TransferJobReplicationSpecTransferOptionsMetadataOptions>;
        /**
         * Whether overwriting objects that already exist in the sink is allowed.
         */
        overwriteObjectsAlreadyExistingInSink?: pulumi.Input<boolean>;
        /**
         * When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwriteObjectsAlreadyExistingInSink`. Possible values: ALWAYS, DIFFERENT, NEVER.
         */
        overwriteWhen?: pulumi.Input<string>;
    }

    export interface TransferJobReplicationSpecTransferOptionsMetadataOptions {
        /**
         * Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets
         */
        acl?: pulumi.Input<string>;
        /**
         * Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
         */
        gid?: pulumi.Input<string>;
        /**
         * Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * Specifies how each file's mode attribute should be handled by the transfer.
         */
        mode?: pulumi.Input<string>;
        /**
         * Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets
         */
        storageClass?: pulumi.Input<string>;
        /**
         * Specifies how symlinks should be handled by the transfer.
         */
        symlink?: pulumi.Input<string>;
        /**
         * SSpecifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets
         */
        temporaryHold?: pulumi.Input<string>;
        /**
         * Specifies how each object's timeCreated metadata is preserved for transfers.
         */
        timeCreated?: pulumi.Input<string>;
        /**
         * Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
         */
        uid?: pulumi.Input<string>;
    }

    export interface TransferJobSchedule {
        /**
         * Interval between the start of each scheduled transfer. If unspecified, the default value is 24 hours. This value may not be less than 1 hour. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        repeatInterval?: pulumi.Input<string>;
        /**
         * The last day the recurring transfer will be run. If `scheduleEndDate` is the same as `scheduleStartDate`, the transfer will be executed only once. Structure documented below.
         */
        scheduleEndDate?: pulumi.Input<inputs.storage.TransferJobScheduleScheduleEndDate>;
        /**
         * The first day the recurring transfer is scheduled to run. If `scheduleStartDate` is in the past, the transfer will run for the first time on the following day. Structure documented below.
         */
        scheduleStartDate: pulumi.Input<inputs.storage.TransferJobScheduleScheduleStartDate>;
        /**
         * The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
         */
        startTimeOfDay?: pulumi.Input<inputs.storage.TransferJobScheduleStartTimeOfDay>;
    }

    export interface TransferJobScheduleScheduleEndDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleScheduleStartDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: pulumi.Input<number>;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: pulumi.Input<number>;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23.
         */
        hours: pulumi.Input<number>;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes: pulumi.Input<number>;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos: pulumi.Input<number>;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         */
        seconds: pulumi.Input<number>;
    }

    export interface TransferJobTransferSpec {
        /**
         * An AWS S3 data source. Structure documented below.
         */
        awsS3DataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSource>;
        /**
         * An Azure Blob Storage data source. Structure documented below.
         */
        azureBlobStorageDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecAzureBlobStorageDataSource>;
        /**
         * A Google Cloud Storage data sink. Structure documented below.
         */
        gcsDataSink?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSink>;
        /**
         * A Google Cloud Storage data source. Structure documented below.
         */
        gcsDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSource>;
        /**
         * An HDFS data source. Structure documented below.
         */
        hdfsDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecHdfsDataSource>;
        /**
         * A HTTP URL data source. Structure documented below.
         */
        httpDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecHttpDataSource>;
        /**
         * Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `lastModificationTime` do not exclude objects in a data sink. Structure documented below.
         */
        objectConditions?: pulumi.Input<inputs.storage.TransferJobTransferSpecObjectConditions>;
        /**
         * A POSIX data sink. Structure documented below.
         */
        posixDataSink?: pulumi.Input<inputs.storage.TransferJobTransferSpecPosixDataSink>;
        /**
         * A POSIX filesystem data source. Structure documented below.
         */
        posixDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecPosixDataSource>;
        /**
         * Specifies the agent pool name associated with the posix data sink. When unspecified, the default name is used.
         */
        sinkAgentPoolName?: pulumi.Input<string>;
        /**
         * Specifies the agent pool name associated with the posix data source. When unspecified, the default name is used.
         */
        sourceAgentPoolName?: pulumi.Input<string>;
        /**
         * Characteristics of how to treat files from datasource and sink during job. If the option `deleteObjectsUniqueInSink` is true, object conditions based on objects' `lastModificationTime` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
         */
        transferOptions?: pulumi.Input<inputs.storage.TransferJobTransferSpecTransferOptions>;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        /**
         * AWS credentials block.
         */
        awsAccessKey?: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey>;
        /**
         * S3 Bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Egress bytes over a Google-managed private network. This network is shared between other users of Storage Transfer Service.
         */
        managedPrivateNetwork?: pulumi.Input<boolean>;
        /**
         * S3 Bucket path in bucket to transfer.
         */
        path?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the role to support temporary credentials via 'AssumeRoleWithWebIdentity'. For more information about ARNs, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). When a role ARN is provided, Transfer Service fetches temporary credentials for the session using a 'AssumeRoleWithWebIdentity' call for the provided role using the [GoogleServiceAccount][] for this project.
         */
        roleArn?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        /**
         * AWS Key ID.
         */
        accessKeyId: pulumi.Input<string>;
        /**
         * AWS Secret Access Key.
         */
        secretAccessKey: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAzureBlobStorageDataSource {
        /**
         * Credentials used to authenticate API requests to Azure block.
         */
        azureCredentials?: pulumi.Input<inputs.storage.TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentials>;
        /**
         * The container to transfer from the Azure Storage account.`
         */
        container: pulumi.Input<string>;
        /**
         * Full Resource name of a secret in Secret Manager containing [SAS Credentials in JSON form](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#azureblobstoragedata:~:text=begin%20with%20a%20%27/%27.-,credentialsSecret,-string). Service Agent for Storage Transfer must have permissions to access secret. If credentialsSecret is specified, do not specify azure_credentials.`,
         */
        credentialsSecret?: pulumi.Input<string>;
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path?: pulumi.Input<string>;
        /**
         * The name of the Azure Storage account.
         */
        storageAccount: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentials {
        /**
         * Azure shared access signature. See [Grant limited access to Azure Storage resources using shared access signatures (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
         *
         * <a name="nestedScheduleStartEndDate"></a>The `scheduleStartDate` and `scheduleEndDate` blocks support:
         */
        sasToken: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        /**
         * Google Cloud Storage bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        /**
         * Google Cloud Storage bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecHdfsDataSource {
        /**
         * Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
         */
        path: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        /**
         * The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
         */
        listUrl: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecObjectConditions {
        /**
         * `excludePrefixes` must follow the requirements described for `includePrefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        excludePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If `includePrefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `includePrefixes` and that do not start with any of the `excludePrefixes`. If `includePrefixes` is not specified, all objects except those that have names starting with one of the `excludePrefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        includePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastModifiedBefore?: pulumi.Input<string>;
        /**
         * If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
         */
        lastModifiedSince?: pulumi.Input<string>;
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxTimeElapsedSinceLastModification?: pulumi.Input<string>;
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minTimeElapsedSinceLastModification?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecPosixDataSink {
        /**
         * Root directory path to the filesystem.
         */
        rootDirectory: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecPosixDataSource {
        /**
         * Root directory path to the filesystem.
         */
        rootDirectory: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecTransferOptions {
        /**
         * Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `deleteObjectsUniqueInSink` are mutually exclusive.
         */
        deleteObjectsFromSourceAfterTransfer?: pulumi.Input<boolean>;
        /**
         * Whether objects that exist only in the sink should be deleted. Note that this option and
         * `deleteObjectsFromSourceAfterTransfer` are mutually exclusive.
         */
        deleteObjectsUniqueInSink?: pulumi.Input<boolean>;
        /**
         * Specifies the metadata options for running a transfer
         */
        metadataOptions?: pulumi.Input<inputs.storage.TransferJobTransferSpecTransferOptionsMetadataOptions>;
        /**
         * Whether overwriting objects that already exist in the sink is allowed.
         */
        overwriteObjectsAlreadyExistingInSink?: pulumi.Input<boolean>;
        /**
         * When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwriteObjectsAlreadyExistingInSink`. Possible values: ALWAYS, DIFFERENT, NEVER.
         */
        overwriteWhen?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecTransferOptionsMetadataOptions {
        /**
         * Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets
         */
        acl?: pulumi.Input<string>;
        /**
         * Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
         */
        gid?: pulumi.Input<string>;
        /**
         * Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets
         */
        kmsKey?: pulumi.Input<string>;
        /**
         * Specifies how each file's mode attribute should be handled by the transfer.
         */
        mode?: pulumi.Input<string>;
        /**
         * Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets
         */
        storageClass?: pulumi.Input<string>;
        /**
         * Specifies how symlinks should be handled by the transfer.
         */
        symlink?: pulumi.Input<string>;
        /**
         * SSpecifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets
         */
        temporaryHold?: pulumi.Input<string>;
        /**
         * Specifies how each object's timeCreated metadata is preserved for transfers.
         */
        timeCreated?: pulumi.Input<string>;
        /**
         * Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
         */
        uid?: pulumi.Input<string>;
    }
}

export namespace tags {
    export interface TagKeyIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TagKeyIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TagValueIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TagValueIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        /**
         * (Output)
         * The IP address of this network endpoint.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * The port of this network endpoint.
         */
        port?: pulumi.Input<number>;
    }

    export interface NodeSchedulingConfig {
        /**
         * Defines whether the TPU instance is preemptible.
         */
        preemptible: pulumi.Input<boolean>;
    }

    export interface V2QueuedResourceTpu {
        /**
         * The TPU node(s) being requested.
         * Structure is documented below.
         */
        nodeSpecs?: pulumi.Input<pulumi.Input<inputs.tpu.V2QueuedResourceTpuNodeSpec>[]>;
    }

    export interface V2QueuedResourceTpuNodeSpec {
        /**
         * The node.
         * Structure is documented below.
         */
        node: pulumi.Input<inputs.tpu.V2QueuedResourceTpuNodeSpecNode>;
        /**
         * Unqualified node identifier used to identify the node in the project once provisioned.
         */
        nodeId?: pulumi.Input<string>;
        /**
         * The parent resource name.
         */
        parent: pulumi.Input<string>;
    }

    export interface V2QueuedResourceTpuNodeSpecNode {
        /**
         * TPU accelerator type for the TPU. If not specified, this defaults to 'v2-8'.
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * Text description of the TPU.
         */
        description?: pulumi.Input<string>;
        /**
         * Network configurations for the TPU node.
         * Structure is documented below.
         */
        networkConfig?: pulumi.Input<inputs.tpu.V2QueuedResourceTpuNodeSpecNodeNetworkConfig>;
        /**
         * Runtime version for the TPU.
         */
        runtimeVersion: pulumi.Input<string>;
    }

    export interface V2QueuedResourceTpuNodeSpecNodeNetworkConfig {
        /**
         * Allows the TPU node to send and receive packets with non-matching destination or source
         * IPs. This is required if you plan to use the TPU workers to forward routes.
         */
        canIpForward?: pulumi.Input<boolean>;
        /**
         * Indicates that external IP addresses would be associated with the TPU workers. If set to
         * false, the specified subnetwork or network should have Private Google Access enabled.
         */
        enableExternalIps?: pulumi.Input<boolean>;
        /**
         * The name of the network for the TPU node. It must be a preexisting Google Compute Engine
         * network. If none is provided, "default" will be used.
         */
        network?: pulumi.Input<string>;
        /**
         * Specifies networking queue count for TPU VM instance's network interface.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * The name of the subnetwork for the TPU node. It must be a preexisting Google Compute
         * Engine subnetwork. If none is provided, "default" will be used.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface V2VmAcceleratorConfig {
        /**
         * Topology of TPU in chips.
         */
        topology: pulumi.Input<string>;
        /**
         * Type of TPU. Please select one of the allowed types: https://cloud.google.com/tpu/docs/reference/rest/v2/AcceleratorConfig#Type
         */
        type: pulumi.Input<string>;
    }

    export interface V2VmDataDisk {
        /**
         * The mode in which to attach this disk. If not specified, the default is READ_WRITE
         * mode. Only applicable to dataDisks.
         * Default value is `READ_WRITE`.
         * Possible values are: `READ_WRITE`, `READ_ONLY`.
         */
        mode?: pulumi.Input<string>;
        /**
         * Specifies the full path to an existing disk. For example:
         * "projects/my-project/zones/us-central1-c/disks/my-disk".
         */
        sourceDisk: pulumi.Input<string>;
    }

    export interface V2VmNetworkConfig {
        /**
         * Allows the TPU node to send and receive packets with non-matching destination or source
         * IPs. This is required if you plan to use the TPU workers to forward routes.
         */
        canIpForward?: pulumi.Input<boolean>;
        /**
         * Indicates that external IP addresses would be associated with the TPU workers. If set to
         * false, the specified subnetwork or network should have Private Google Access enabled.
         */
        enableExternalIps?: pulumi.Input<boolean>;
        /**
         * The name of the network for the TPU node. It must be a preexisting Google Compute Engine
         * network. If none is provided, "default" will be used.
         */
        network?: pulumi.Input<string>;
        /**
         * Specifies networking queue count for TPU VM instance's network interface.
         */
        queueCount?: pulumi.Input<number>;
        /**
         * The name of the subnetwork for the TPU node. It must be a preexisting Google Compute
         * Engine subnetwork. If none is provided, "default" will be used.
         */
        subnetwork?: pulumi.Input<string>;
    }

    export interface V2VmNetworkEndpoint {
        /**
         * (Output)
         * The access config for the TPU worker.
         * Structure is documented below.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.tpu.V2VmNetworkEndpointAccessConfig>[]>;
        /**
         * (Output)
         * The internal IP address of this network endpoint.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * The port of this network endpoint.
         */
        port?: pulumi.Input<number>;
    }

    export interface V2VmNetworkEndpointAccessConfig {
        /**
         * (Output)
         * An external IP address associated with the TPU worker.
         */
        externalIp?: pulumi.Input<string>;
    }

    export interface V2VmSchedulingConfig {
        /**
         * Defines whether the node is preemptible.
         */
        preemptible?: pulumi.Input<boolean>;
        /**
         * Whether the node is created under a reservation.
         */
        reserved?: pulumi.Input<boolean>;
        /**
         * Optional. Defines whether the node is Spot VM.
         */
        spot?: pulumi.Input<boolean>;
    }

    export interface V2VmServiceAccount {
        /**
         * Email address of the service account. If empty, default Compute service account will be used.
         */
        email?: pulumi.Input<string>;
        /**
         * The list of scopes to be made available for this service account. If empty, access to all
         * Cloud APIs will be allowed.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface V2VmShieldedInstanceConfig {
        /**
         * Defines whether the instance has Secure Boot enabled.
         */
        enableSecureBoot: pulumi.Input<boolean>;
    }

    export interface V2VmSymptom {
        /**
         * (Output)
         * Timestamp when the Symptom is created.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * Detailed information of the current Symptom.
         */
        details?: pulumi.Input<string>;
        /**
         * (Output)
         * Type of the Symptom.
         */
        symptomType?: pulumi.Input<string>;
        /**
         * (Output)
         * A string used to uniquely distinguish a worker within a TPU node.
         */
        workerId?: pulumi.Input<string>;
    }
}

export namespace transcoder {
    export interface JobConfig {
        /**
         * Ad break.
         * Structure is documented below.
         */
        adBreaks?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigAdBreak>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        editLists?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigEditList>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        elementaryStreams?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigElementaryStream>[]>;
        /**
         * List of encryption configurations for the content.
         * Structure is documented below.
         */
        encryptions?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigEncryption>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        inputs?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigInput>[]>;
        /**
         * Manifest configuration.
         * Structure is documented below.
         */
        manifests?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigManifest>[]>;
        /**
         * Multiplexing settings for output stream.
         * Structure is documented below.
         */
        muxStreams?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigMuxStream>[]>;
        /**
         * Location of output file(s) in a Cloud Storage bucket.
         * Structure is documented below.
         */
        output?: pulumi.Input<inputs.transcoder.JobConfigOutput>;
        /**
         * List of overlays on the output video, in descending Z-order.
         * Structure is documented below.
         */
        overlays?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigOverlay>[]>;
        /**
         * Pub/Sub destination.
         * Structure is documented below.
         */
        pubsubDestination?: pulumi.Input<inputs.transcoder.JobConfigPubsubDestination>;
    }

    export interface JobConfigAdBreak {
        /**
         * Start time in seconds for the ad break, relative to the output file timeline
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    export interface JobConfigEditList {
        /**
         * List of values identifying files that should be used in this atom.
         */
        inputs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A unique key for this atom.
         */
        key?: pulumi.Input<string>;
        /**
         * Start time in seconds for the atom, relative to the input file timeline. The default is `0s`.
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    export interface JobConfigElementaryStream {
        /**
         * Encoding of an audio stream.
         * Structure is documented below.
         */
        audioStream?: pulumi.Input<inputs.transcoder.JobConfigElementaryStreamAudioStream>;
        /**
         * A unique key for this atom.
         */
        key?: pulumi.Input<string>;
        /**
         * Encoding of a video stream.
         * Structure is documented below.
         */
        videoStream?: pulumi.Input<inputs.transcoder.JobConfigElementaryStreamVideoStream>;
    }

    export interface JobConfigElementaryStreamAudioStream {
        /**
         * Audio bitrate in bits per second.
         */
        bitrateBps: pulumi.Input<number>;
        /**
         * Number of audio channels. The default is `2`.
         */
        channelCount?: pulumi.Input<number>;
        /**
         * A list of channel names specifying layout of the audio channels. The default is ["fl", "fr"].
         */
        channelLayouts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The codec for this audio stream. The default is `aac`.
         */
        codec?: pulumi.Input<string>;
        /**
         * The audio sample rate in Hertz. The default is `48000`.
         */
        sampleRateHertz?: pulumi.Input<number>;
    }

    export interface JobConfigElementaryStreamVideoStream {
        /**
         * H264 codec settings
         * Structure is documented below.
         *
         *
         * <a name="nestedConfigElementaryStreamsElementaryStreamsVideoStreamH264"></a>The `h264` block supports:
         */
        h264?: pulumi.Input<inputs.transcoder.JobConfigElementaryStreamVideoStreamH264>;
    }

    export interface JobConfigElementaryStreamVideoStreamH264 {
        /**
         * The video bitrate in bits per second.
         */
        bitrateBps: pulumi.Input<number>;
        /**
         * Target CRF level. The default is '21'.
         */
        crfLevel?: pulumi.Input<number>;
        /**
         * The entropy coder to use. The default is 'cabac'.
         */
        entropyCoder?: pulumi.Input<string>;
        /**
         * The target video frame rate in frames per second (FPS).
         */
        frameRate: pulumi.Input<number>;
        /**
         * Select the GOP size based on the specified duration. The default is '3s'.
         */
        gopDuration?: pulumi.Input<string>;
        /**
         * The height of the video in pixels.
         */
        heightPixels?: pulumi.Input<number>;
        /**
         * HLG color format setting for H264.
         */
        hlg?: pulumi.Input<inputs.transcoder.JobConfigElementaryStreamVideoStreamH264Hlg>;
        /**
         * Pixel format to use. The default is 'yuv420p'.
         */
        pixelFormat?: pulumi.Input<string>;
        /**
         * Enforces the specified codec preset. The default is 'veryfast'.
         */
        preset?: pulumi.Input<string>;
        /**
         * Enforces the specified codec profile.
         */
        profile?: pulumi.Input<string>;
        /**
         * Specify the mode. The default is 'vbr'.
         */
        rateControlMode?: pulumi.Input<string>;
        /**
         * SDR color format setting for H264.
         */
        sdr?: pulumi.Input<inputs.transcoder.JobConfigElementaryStreamVideoStreamH264Sdr>;
        /**
         * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
         */
        vbvFullnessBits?: pulumi.Input<number>;
        /**
         * Size of the Video Buffering Verifier (VBV) buffer in bits.
         */
        vbvSizeBits?: pulumi.Input<number>;
        /**
         * The width of the video in pixels.
         */
        widthPixels?: pulumi.Input<number>;
    }

    export interface JobConfigElementaryStreamVideoStreamH264Hlg {
    }

    export interface JobConfigElementaryStreamVideoStreamH264Sdr {
    }

    export interface JobConfigEncryption {
        /**
         * Configuration for AES-128 encryption.
         */
        aes128?: pulumi.Input<inputs.transcoder.JobConfigEncryptionAes128>;
        /**
         * DRM system(s) to use; at least one must be specified. If a DRM system is omitted, it is considered disabled.
         * Structure is documented below.
         */
        drmSystems?: pulumi.Input<inputs.transcoder.JobConfigEncryptionDrmSystems>;
        /**
         * Identifier for this set of encryption options.
         */
        id: pulumi.Input<string>;
        /**
         * Configuration for MPEG Common Encryption (MPEG-CENC).
         * Structure is documented below.
         */
        mpegCenc?: pulumi.Input<inputs.transcoder.JobConfigEncryptionMpegCenc>;
        /**
         * Configuration for SAMPLE-AES encryption.
         */
        sampleAes?: pulumi.Input<inputs.transcoder.JobConfigEncryptionSampleAes>;
        /**
         * Configuration for secrets stored in Google Secret Manager.
         * Structure is documented below.
         */
        secretManagerKeySource?: pulumi.Input<inputs.transcoder.JobConfigEncryptionSecretManagerKeySource>;
    }

    export interface JobConfigEncryptionAes128 {
    }

    export interface JobConfigEncryptionDrmSystems {
        /**
         * Clearkey configuration.
         */
        clearkey?: pulumi.Input<inputs.transcoder.JobConfigEncryptionDrmSystemsClearkey>;
        /**
         * Fairplay configuration.
         */
        fairplay?: pulumi.Input<inputs.transcoder.JobConfigEncryptionDrmSystemsFairplay>;
        /**
         * Playready configuration.
         */
        playready?: pulumi.Input<inputs.transcoder.JobConfigEncryptionDrmSystemsPlayready>;
        /**
         * Widevine configuration.
         */
        widevine?: pulumi.Input<inputs.transcoder.JobConfigEncryptionDrmSystemsWidevine>;
    }

    export interface JobConfigEncryptionDrmSystemsClearkey {
    }

    export interface JobConfigEncryptionDrmSystemsFairplay {
    }

    export interface JobConfigEncryptionDrmSystemsPlayready {
    }

    export interface JobConfigEncryptionDrmSystemsWidevine {
    }

    export interface JobConfigEncryptionMpegCenc {
        /**
         * Specify the encryption scheme.
         */
        scheme: pulumi.Input<string>;
    }

    export interface JobConfigEncryptionSampleAes {
    }

    export interface JobConfigEncryptionSecretManagerKeySource {
        /**
         * The name of the Secret Version containing the encryption key in the following format: projects/{project}/secrets/{secret_id}/versions/{version_number}.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface JobConfigInput {
        /**
         * A unique key for this input. Must be specified when using advanced mapping and edit lists.
         */
        key?: pulumi.Input<string>;
        /**
         * URI of the media. Input files must be at least 5 seconds in duration and stored in Cloud Storage (for example, gs://bucket/inputs/file.mp4).
         * If empty, the value is populated from Job.input_uri.
         */
        uri?: pulumi.Input<string>;
    }

    export interface JobConfigManifest {
        /**
         * The name of the generated file. The default is `manifest`.
         */
        fileName?: pulumi.Input<string>;
        /**
         * List of user supplied MuxStream.key values that should appear in this manifest.
         */
        muxStreams?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the manifest.
         * Possible values are: `MANIFEST_TYPE_UNSPECIFIED`, `HLS`, `DASH`.
         */
        type?: pulumi.Input<string>;
    }

    export interface JobConfigMuxStream {
        /**
         * The container format. The default is `mp4`.
         */
        container?: pulumi.Input<string>;
        /**
         * List of ElementaryStream.key values multiplexed in this stream.
         */
        elementaryStreams?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Identifier of the encryption configuration to use.
         */
        encryptionId?: pulumi.Input<string>;
        /**
         * The name of the generated file.
         */
        fileName?: pulumi.Input<string>;
        /**
         * A unique key for this multiplexed stream.
         */
        key?: pulumi.Input<string>;
        /**
         * Segment settings for ts, fmp4 and vtt.
         * Structure is documented below.
         */
        segmentSettings?: pulumi.Input<inputs.transcoder.JobConfigMuxStreamSegmentSettings>;
    }

    export interface JobConfigMuxStreamSegmentSettings {
        /**
         * Duration of the segments in seconds. The default is `6.0s`.
         */
        segmentDuration?: pulumi.Input<string>;
    }

    export interface JobConfigOutput {
        /**
         * URI for the output file(s). For example, gs://my-bucket/outputs/.
         */
        uri?: pulumi.Input<string>;
    }

    export interface JobConfigOverlay {
        /**
         * List of animations. The list should be chronological, without any time overlap.
         * Structure is documented below.
         */
        animations?: pulumi.Input<pulumi.Input<inputs.transcoder.JobConfigOverlayAnimation>[]>;
        /**
         * Image overlay.
         * Structure is documented below.
         */
        image?: pulumi.Input<inputs.transcoder.JobConfigOverlayImage>;
    }

    export interface JobConfigOverlayAnimation {
        /**
         * Display overlay object with fade animation.
         * Structure is documented below.
         */
        animationFade?: pulumi.Input<inputs.transcoder.JobConfigOverlayAnimationAnimationFade>;
    }

    export interface JobConfigOverlayAnimationAnimationFade {
        /**
         * The time to end the fade animation, in seconds.
         */
        endTimeOffset?: pulumi.Input<string>;
        /**
         * Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
         * The possible values are:
         * * `FADE_TYPE_UNSPECIFIED`: The fade type is not specified.
         * * `FADE_IN`: Fade the overlay object into view.
         * * `FADE_OUT`: Fade the overlay object out of view.
         * Possible values are: `FADE_TYPE_UNSPECIFIED`, `FADE_IN`, `FADE_OUT`.
         */
        fadeType: pulumi.Input<string>;
        /**
         * The time to start the fade animation, in seconds.
         */
        startTimeOffset?: pulumi.Input<string>;
        /**
         * Normalized coordinates based on output video resolution.
         * Structure is documented below.
         */
        xy?: pulumi.Input<inputs.transcoder.JobConfigOverlayAnimationAnimationFadeXy>;
    }

    export interface JobConfigOverlayAnimationAnimationFadeXy {
        /**
         * Normalized x coordinate.
         */
        x?: pulumi.Input<number>;
        /**
         * Normalized y coordinate.
         */
        y?: pulumi.Input<number>;
    }

    export interface JobConfigOverlayImage {
        /**
         * URI of the image in Cloud Storage. For example, gs://bucket/inputs/image.png.
         */
        uri: pulumi.Input<string>;
    }

    export interface JobConfigPubsubDestination {
        /**
         * The name of the Pub/Sub topic to publish job completion notification to. For example: projects/{project}/topics/{topic}.
         */
        topic?: pulumi.Input<string>;
    }

    export interface JobTemplateConfig {
        /**
         * Ad break.
         * Structure is documented below.
         */
        adBreaks?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigAdBreak>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        editLists?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigEditList>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        elementaryStreams?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStream>[]>;
        /**
         * List of encryption configurations for the content.
         * Structure is documented below.
         */
        encryptions?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigEncryption>[]>;
        /**
         * List of input assets stored in Cloud Storage.
         * Structure is documented below.
         */
        inputs?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigInput>[]>;
        /**
         * Manifest configuration.
         * Structure is documented below.
         */
        manifests?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigManifest>[]>;
        /**
         * Multiplexing settings for output stream.
         * Structure is documented below.
         */
        muxStreams?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigMuxStream>[]>;
        /**
         * Location of output file(s) in a Cloud Storage bucket.
         * Structure is documented below.
         */
        output?: pulumi.Input<inputs.transcoder.JobTemplateConfigOutput>;
        /**
         * List of overlays on the output video, in descending Z-order.
         * Structure is documented below.
         */
        overlays?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigOverlay>[]>;
        /**
         * Pub/Sub destination.
         * Structure is documented below.
         */
        pubsubDestination?: pulumi.Input<inputs.transcoder.JobTemplateConfigPubsubDestination>;
    }

    export interface JobTemplateConfigAdBreak {
        /**
         * Start time in seconds for the ad break, relative to the output file timeline
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigEditList {
        /**
         * List of values identifying files that should be used in this atom.
         */
        inputs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A unique key for this atom.
         */
        key?: pulumi.Input<string>;
        /**
         * Start time in seconds for the atom, relative to the input file timeline.  The default is `0s`.
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigElementaryStream {
        /**
         * Encoding of an audio stream.
         * Structure is documented below.
         */
        audioStream?: pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStreamAudioStream>;
        /**
         * A unique key for this atom.
         */
        key?: pulumi.Input<string>;
        /**
         * Encoding of a video stream.
         * Structure is documented below.
         */
        videoStream?: pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStreamVideoStream>;
    }

    export interface JobTemplateConfigElementaryStreamAudioStream {
        /**
         * Audio bitrate in bits per second.
         */
        bitrateBps: pulumi.Input<number>;
        /**
         * Number of audio channels. The default is `2`.
         */
        channelCount?: pulumi.Input<number>;
        /**
         * A list of channel names specifying layout of the audio channels.  The default is ["fl", "fr"].
         */
        channelLayouts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The codec for this audio stream. The default is `aac`.
         */
        codec?: pulumi.Input<string>;
        /**
         * The audio sample rate in Hertz. The default is `48000`.
         */
        sampleRateHertz?: pulumi.Input<number>;
    }

    export interface JobTemplateConfigElementaryStreamVideoStream {
        /**
         * H264 codec settings
         * Structure is documented below.
         *
         *
         * <a name="nestedConfigElementaryStreamsElementaryStreamsVideoStreamH264"></a>The `h264` block supports:
         */
        h264?: pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStreamVideoStreamH264>;
    }

    export interface JobTemplateConfigElementaryStreamVideoStreamH264 {
        /**
         * The video bitrate in bits per second.
         */
        bitrateBps: pulumi.Input<number>;
        /**
         * Target CRF level. The default is '21'.
         */
        crfLevel?: pulumi.Input<number>;
        /**
         * The entropy coder to use. The default is 'cabac'.
         */
        entropyCoder?: pulumi.Input<string>;
        /**
         * The target video frame rate in frames per second (FPS).
         */
        frameRate: pulumi.Input<number>;
        /**
         * Select the GOP size based on the specified duration. The default is '3s'.
         */
        gopDuration?: pulumi.Input<string>;
        /**
         * The height of the video in pixels.
         */
        heightPixels?: pulumi.Input<number>;
        /**
         * HLG color format setting for H264.
         */
        hlg?: pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStreamVideoStreamH264Hlg>;
        /**
         * Pixel format to use. The default is 'yuv420p'.
         */
        pixelFormat?: pulumi.Input<string>;
        /**
         * Enforces the specified codec preset. The default is 'veryfast'.
         */
        preset?: pulumi.Input<string>;
        /**
         * Enforces the specified codec profile.
         */
        profile?: pulumi.Input<string>;
        /**
         * Specify the mode. The default is 'vbr'.
         */
        rateControlMode?: pulumi.Input<string>;
        /**
         * SDR color format setting for H264.
         */
        sdr?: pulumi.Input<inputs.transcoder.JobTemplateConfigElementaryStreamVideoStreamH264Sdr>;
        /**
         * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
         */
        vbvFullnessBits?: pulumi.Input<number>;
        /**
         * Size of the Video Buffering Verifier (VBV) buffer in bits.
         */
        vbvSizeBits?: pulumi.Input<number>;
        /**
         * The width of the video in pixels.
         */
        widthPixels?: pulumi.Input<number>;
    }

    export interface JobTemplateConfigElementaryStreamVideoStreamH264Hlg {
    }

    export interface JobTemplateConfigElementaryStreamVideoStreamH264Sdr {
    }

    export interface JobTemplateConfigEncryption {
        /**
         * Configuration for AES-128 encryption.
         */
        aes128?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionAes128>;
        /**
         * DRM system(s) to use; at least one must be specified. If a DRM system is omitted, it is considered disabled.
         * Structure is documented below.
         */
        drmSystems?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionDrmSystems>;
        /**
         * Identifier for this set of encryption options.
         */
        id: pulumi.Input<string>;
        /**
         * Configuration for MPEG Common Encryption (MPEG-CENC).
         * Structure is documented below.
         */
        mpegCenc?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionMpegCenc>;
        /**
         * Configuration for SAMPLE-AES encryption.
         */
        sampleAes?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionSampleAes>;
        /**
         * Configuration for secrets stored in Google Secret Manager.
         * Structure is documented below.
         */
        secretManagerKeySource?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionSecretManagerKeySource>;
    }

    export interface JobTemplateConfigEncryptionAes128 {
    }

    export interface JobTemplateConfigEncryptionDrmSystems {
        /**
         * Clearkey configuration.
         */
        clearkey?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionDrmSystemsClearkey>;
        /**
         * Fairplay configuration.
         */
        fairplay?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionDrmSystemsFairplay>;
        /**
         * Playready configuration.
         */
        playready?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionDrmSystemsPlayready>;
        /**
         * Widevine configuration.
         */
        widevine?: pulumi.Input<inputs.transcoder.JobTemplateConfigEncryptionDrmSystemsWidevine>;
    }

    export interface JobTemplateConfigEncryptionDrmSystemsClearkey {
    }

    export interface JobTemplateConfigEncryptionDrmSystemsFairplay {
    }

    export interface JobTemplateConfigEncryptionDrmSystemsPlayready {
    }

    export interface JobTemplateConfigEncryptionDrmSystemsWidevine {
    }

    export interface JobTemplateConfigEncryptionMpegCenc {
        /**
         * Specify the encryption scheme.
         */
        scheme: pulumi.Input<string>;
    }

    export interface JobTemplateConfigEncryptionSampleAes {
    }

    export interface JobTemplateConfigEncryptionSecretManagerKeySource {
        /**
         * The name of the Secret Version containing the encryption key in the following format: projects/{project}/secrets/{secret_id}/versions/{version_number}.
         */
        secretVersion: pulumi.Input<string>;
    }

    export interface JobTemplateConfigInput {
        /**
         * A unique key for this input. Must be specified when using advanced mapping and edit lists.
         */
        key?: pulumi.Input<string>;
        /**
         * URI of the media. Input files must be at least 5 seconds in duration and stored in Cloud Storage (for example, gs://bucket/inputs/file.mp4).
         * If empty, the value is populated from Job.input_uri.
         */
        uri?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigManifest {
        /**
         * The name of the generated file. The default is `manifest`.
         */
        fileName?: pulumi.Input<string>;
        /**
         * List of user supplied MuxStream.key values that should appear in this manifest.
         */
        muxStreams?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the manifest.
         * Possible values are: `MANIFEST_TYPE_UNSPECIFIED`, `HLS`, `DASH`.
         */
        type?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigMuxStream {
        /**
         * The container format. The default is `mp4`.
         */
        container?: pulumi.Input<string>;
        /**
         * List of ElementaryStream.key values multiplexed in this stream.
         */
        elementaryStreams?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Identifier of the encryption configuration to use.
         */
        encryptionId?: pulumi.Input<string>;
        /**
         * The name of the generated file.
         */
        fileName?: pulumi.Input<string>;
        /**
         * A unique key for this multiplexed stream.
         */
        key?: pulumi.Input<string>;
        /**
         * Segment settings for ts, fmp4 and vtt.
         * Structure is documented below.
         */
        segmentSettings?: pulumi.Input<inputs.transcoder.JobTemplateConfigMuxStreamSegmentSettings>;
    }

    export interface JobTemplateConfigMuxStreamSegmentSettings {
        /**
         * Duration of the segments in seconds. The default is `6.0s`.
         */
        segmentDuration?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigOutput {
        /**
         * URI for the output file(s). For example, gs://my-bucket/outputs/.
         */
        uri?: pulumi.Input<string>;
    }

    export interface JobTemplateConfigOverlay {
        /**
         * List of animations. The list should be chronological, without any time overlap.
         * Structure is documented below.
         */
        animations?: pulumi.Input<pulumi.Input<inputs.transcoder.JobTemplateConfigOverlayAnimation>[]>;
        /**
         * Image overlay.
         * Structure is documented below.
         */
        image?: pulumi.Input<inputs.transcoder.JobTemplateConfigOverlayImage>;
    }

    export interface JobTemplateConfigOverlayAnimation {
        /**
         * Display overlay object with fade animation.
         * Structure is documented below.
         */
        animationFade?: pulumi.Input<inputs.transcoder.JobTemplateConfigOverlayAnimationAnimationFade>;
    }

    export interface JobTemplateConfigOverlayAnimationAnimationFade {
        /**
         * The time to end the fade animation, in seconds.
         */
        endTimeOffset?: pulumi.Input<string>;
        /**
         * Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
         * The possible values are:
         * * `FADE_TYPE_UNSPECIFIED`: The fade type is not specified.
         * * `FADE_IN`: Fade the overlay object into view.
         * * `FADE_OUT`: Fade the overlay object out of view.
         * Possible values are: `FADE_TYPE_UNSPECIFIED`, `FADE_IN`, `FADE_OUT`.
         */
        fadeType: pulumi.Input<string>;
        /**
         * The time to start the fade animation, in seconds.
         */
        startTimeOffset?: pulumi.Input<string>;
        /**
         * Normalized coordinates based on output video resolution.
         * Structure is documented below.
         */
        xy?: pulumi.Input<inputs.transcoder.JobTemplateConfigOverlayAnimationAnimationFadeXy>;
    }

    export interface JobTemplateConfigOverlayAnimationAnimationFadeXy {
        /**
         * Normalized x coordinate.
         */
        x?: pulumi.Input<number>;
        /**
         * Normalized y coordinate.
         */
        y?: pulumi.Input<number>;
    }

    export interface JobTemplateConfigOverlayImage {
        /**
         * URI of the image in Cloud Storage. For example, gs://bucket/inputs/image.png.
         */
        uri: pulumi.Input<string>;
    }

    export interface JobTemplateConfigPubsubDestination {
        /**
         * The name of the Pub/Sub topic to publish job completion notification to. For example: projects/{project}/topics/{topic}.
         */
        topic?: pulumi.Input<string>;
    }
}

export namespace vertex {
    export interface AiDatasetEncryptionSpec {
        /**
         * Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource.
         * Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface AiDeploymentResourcePoolDedicatedResources {
        /**
         * A list of the metric specifications that overrides a resource utilization metric.
         * Structure is documented below.
         */
        autoscalingMetricSpecs?: pulumi.Input<pulumi.Input<inputs.vertex.AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpec>[]>;
        /**
         * The specification of a single machine used by the prediction
         * Structure is documented below.
         */
        machineSpec: pulumi.Input<inputs.vertex.AiDeploymentResourcePoolDedicatedResourcesMachineSpec>;
        /**
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use minReplicaCount as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for maxReplicaCount * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
         */
        maxReplicaCount?: pulumi.Input<number>;
        /**
         * The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
         */
        minReplicaCount: pulumi.Input<number>;
    }

    export interface AiDeploymentResourcePoolDedicatedResourcesAutoscalingMetricSpec {
        /**
         * The resource metric name. Supported metrics: For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
         */
        metricName: pulumi.Input<string>;
        /**
         * The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
         */
        target?: pulumi.Input<number>;
    }

    export interface AiDeploymentResourcePoolDedicatedResourcesMachineSpec {
        /**
         * The number of accelerators to attach to the machine.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * The type of accelerator(s) that may be attached to the machine as per accelerator_count. See possible values [here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/MachineSpec#AcceleratorType).
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types).
         */
        machineType?: pulumi.Input<string>;
    }

    export interface AiEndpointDeployedModel {
        /**
         * (Output)
         * A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
         * Structure is documented below.
         */
        automaticResources?: pulumi.Input<pulumi.Input<inputs.vertex.AiEndpointDeployedModelAutomaticResource>[]>;
        /**
         * (Output)
         * Output only. Timestamp when the DeployedModel was created.
         */
        createTime?: pulumi.Input<string>;
        /**
         * (Output)
         * A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
         * Structure is documented below.
         */
        dedicatedResources?: pulumi.Input<pulumi.Input<inputs.vertex.AiEndpointDeployedModelDedicatedResource>[]>;
        /**
         * Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
         */
        displayName?: pulumi.Input<string>;
        /**
         * (Output)
         * These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that Stackdriver logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
         */
        enableAccessLogging?: pulumi.Input<boolean>;
        /**
         * (Output)
         * If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Stackdriver Logging. Only supported for custom-trained Models and AutoML Tabular Models.
         */
        enableContainerLogging?: pulumi.Input<boolean>;
        /**
         * (Output)
         * The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
         */
        id?: pulumi.Input<string>;
        /**
         * (Output)
         * The name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel's Endpoint.
         */
        model?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The version ID of the model that is deployed.
         */
        modelVersionId?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
         * Structure is documented below.
         */
        privateEndpoints?: pulumi.Input<pulumi.Input<inputs.vertex.AiEndpointDeployedModelPrivateEndpoint>[]>;
        /**
         * (Output)
         * The service account that the DeployedModel's container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn't have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * (Output)
         * The resource name of the shared DeploymentResourcePool to deploy on. Format: projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}
         */
        sharedResources?: pulumi.Input<string>;
    }

    export interface AiEndpointDeployedModelAutomaticResource {
        /**
         * (Output)
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
         */
        maxReplicaCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
         */
        minReplicaCount?: pulumi.Input<number>;
    }

    export interface AiEndpointDeployedModelDedicatedResource {
        /**
         * (Output)
         * The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator's duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator's duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
         * Structure is documented below.
         */
        autoscalingMetricSpecs?: pulumi.Input<pulumi.Input<inputs.vertex.AiEndpointDeployedModelDedicatedResourceAutoscalingMetricSpec>[]>;
        /**
         * (Output)
         * The specification of a single machine used by the prediction.
         * Structure is documented below.
         */
        machineSpecs?: pulumi.Input<pulumi.Input<inputs.vertex.AiEndpointDeployedModelDedicatedResourceMachineSpec>[]>;
        /**
         * (Output)
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
         */
        maxReplicaCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
         */
        minReplicaCount?: pulumi.Input<number>;
    }

    export interface AiEndpointDeployedModelDedicatedResourceAutoscalingMetricSpec {
        /**
         * (Output)
         * The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
         */
        metricName?: pulumi.Input<string>;
        /**
         * (Output)
         * The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
         */
        target?: pulumi.Input<number>;
    }

    export interface AiEndpointDeployedModelDedicatedResourceMachineSpec {
        /**
         * (Output)
         * The number of accelerators to attach to the machine.
         */
        acceleratorCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The type of accelerator(s) that may be attached to the machine as per accelerator_count. See possible values [here](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/MachineSpec#AcceleratorType).
         */
        acceleratorType?: pulumi.Input<string>;
        /**
         * (Output)
         * The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required. TODO(rsurowka): Try to better unify the required vs optional.
         */
        machineType?: pulumi.Input<string>;
    }

    export interface AiEndpointDeployedModelPrivateEndpoint {
        /**
         * (Output)
         * Output only. Http(s) path to send explain requests.
         */
        explainHttpUri?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Http(s) path to send health check requests.
         */
        healthHttpUri?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. Http(s) path to send prediction requests.
         */
        predictHttpUri?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The name of the service attachment resource. Populated if private service connect is enabled.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface AiEndpointEncryptionSpec {
        /**
         * Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface AiEndpointIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiEndpointIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiEndpointPredictRequestResponseLoggingConfig {
        /**
         * BigQuery table for logging. If only given a project, a new dataset will be created with name `logging_<endpoint-display-name>_<endpoint-id>` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `requestResponseLogging`
         * Structure is documented below.
         */
        bigqueryDestination?: pulumi.Input<inputs.vertex.AiEndpointPredictRequestResponseLoggingConfigBigqueryDestination>;
        /**
         * If logging is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Percentage of requests to be logged, expressed as a fraction in range(0,1]
         */
        samplingRate?: pulumi.Input<number>;
    }

    export interface AiEndpointPredictRequestResponseLoggingConfigBigqueryDestination {
        /**
         * BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: - BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
         */
        outputUri?: pulumi.Input<string>;
    }

    export interface AiEndpointPrivateServiceConnectConfig {
        /**
         * Required. If true, expose the IndexEndpoint via private service connect.
         */
        enablePrivateServiceConnect: pulumi.Input<boolean>;
        /**
         * If set to true, enable secure private service connect with IAM authorization. Otherwise, private service connect will be done without authorization. Note latency will be slightly increased if authorization is enabled.
         */
        enableSecurePrivateServiceConnect?: pulumi.Input<boolean>;
        /**
         * A list of Projects from which the forwarding rule will target the service attachment.
         */
        projectAllowlists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiFeatureGroupBigQuery {
        /**
         * The BigQuery source URI that points to either a BigQuery Table or View.
         * Structure is documented below.
         */
        bigQuerySource: pulumi.Input<inputs.vertex.AiFeatureGroupBigQueryBigQuerySource>;
        /**
         * Columns to construct entityId / row keys. If not provided defaults to entityId.
         */
        entityIdColumns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiFeatureGroupBigQueryBigQuerySource {
        /**
         * BigQuery URI to a table, up to 2000 characters long. For example: `bq://projectId.bqDatasetId.bqTableId.`
         */
        inputUri: pulumi.Input<string>;
    }

    export interface AiFeatureGroupIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureGroupIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreBigtable {
        /**
         * Autoscaling config applied to Bigtable Instance.
         * Structure is documented below.
         */
        autoScaling: pulumi.Input<inputs.vertex.AiFeatureOnlineStoreBigtableAutoScaling>;
    }

    export interface AiFeatureOnlineStoreBigtableAutoScaling {
        /**
         * A percentage of the cluster's CPU capacity. Can be from 10% to 80%. When a cluster's CPU utilization exceeds the target that you have set, Bigtable immediately adds nodes to the cluster. When CPU utilization is substantially lower than the target, Bigtable removes nodes. If not set will default to 50%.
         */
        cpuUtilizationTarget?: pulumi.Input<number>;
        /**
         * The maximum number of nodes to scale up to. Must be greater than or equal to minNodeCount, and less than or equal to 10 times of 'minNodeCount'.
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * The minimum number of nodes to scale down to. Must be greater than or equal to 1.
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface AiFeatureOnlineStoreDedicatedServingEndpoint {
        /**
         * Private service connect config.
         * Structure is documented below.
         */
        privateServiceConnectConfig?: pulumi.Input<inputs.vertex.AiFeatureOnlineStoreDedicatedServingEndpointPrivateServiceConnectConfig>;
        /**
         * (Output)
         * Domain name to use for this FeatureOnlineStore
         */
        publicEndpointDomainName?: pulumi.Input<string>;
        /**
         * (Output)
         * Name of the service attachment resource. Applicable only if private service connect is enabled and after FeatureViewSync is created.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreDedicatedServingEndpointPrivateServiceConnectConfig {
        /**
         * If set to true, customers will use private service connection to send request. Otherwise, the connection will set to public endpoint.
         */
        enablePrivateServiceConnect: pulumi.Input<boolean>;
        /**
         * A list of Projects from which the forwarding rule will target the service attachment.
         */
        projectAllowlists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiFeatureOnlineStoreEmbeddingManagement {
        /**
         * Enable embedding management.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface AiFeatureOnlineStoreFeatureviewBigQuerySource {
        /**
         * Columns to construct entityId / row keys. Start by supporting 1 only.
         */
        entityIdColumns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The BigQuery view URI that will be materialized on each sync trigger based on FeatureView.SyncConfig.
         */
        uri: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreFeatureviewFeatureRegistrySource {
        /**
         * List of features that need to be synced to Online Store.
         * Structure is documented below.
         */
        featureGroups: pulumi.Input<pulumi.Input<inputs.vertex.AiFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroup>[]>;
        /**
         * The project number of the parent project of the feature Groups.
         */
        projectNumber?: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreFeatureviewFeatureRegistrySourceFeatureGroup {
        /**
         * Identifier of the feature group.
         */
        featureGroupId: pulumi.Input<string>;
        /**
         * Identifiers of features under the feature group.
         */
        featureIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiFeatureOnlineStoreFeatureviewIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreFeatureviewIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreFeatureviewSyncConfig {
        /**
         * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.
         * To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
         */
        cron?: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreFeatureviewVectorSearchConfig {
        /**
         * Configuration options for using brute force search, which simply implements the standard linear search in the database for each query. It is primarily meant for benchmarking and to generate the ground truth for approximate search.
         */
        bruteForceConfig?: pulumi.Input<inputs.vertex.AiFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig>;
        /**
         * Column of crowding. This column contains crowding attribute which is a constraint on a neighbor list produced by nearest neighbor search requiring that no more than some value k' of the k neighbors returned have the same value of crowdingAttribute.
         */
        crowdingColumn?: pulumi.Input<string>;
        /**
         * The distance measure used in nearest neighbor search.
         * For details on allowed values, see the [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1beta1/projects.locations.featureOnlineStores.featureViews#DistanceMeasureType).
         * Possible values are: `SQUARED_L2_DISTANCE`, `COSINE_DISTANCE`, `DOT_PRODUCT_DISTANCE`.
         */
        distanceMeasureType?: pulumi.Input<string>;
        /**
         * Column of embedding. This column contains the source data to create index for vector search.
         */
        embeddingColumn: pulumi.Input<string>;
        /**
         * The number of dimensions of the input embedding.
         */
        embeddingDimension?: pulumi.Input<number>;
        /**
         * Columns of features that are used to filter vector search results.
         */
        filterColumns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric Hashing). Please refer to this paper for more details: https://arxiv.org/abs/1908.10396
         * Structure is documented below.
         */
        treeAhConfig?: pulumi.Input<inputs.vertex.AiFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig>;
    }

    export interface AiFeatureOnlineStoreFeatureviewVectorSearchConfigBruteForceConfig {
    }

    export interface AiFeatureOnlineStoreFeatureviewVectorSearchConfigTreeAhConfig {
        /**
         * Number of embeddings on each leaf node. The default value is 1000 if not set.
         */
        leafNodeEmbeddingCount?: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureOnlineStoreOptimized {
    }

    export interface AiFeatureStoreEncryptionSpec {
        /**
         * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the compute resource is created.
         */
        kmsKeyName: pulumi.Input<string>;
    }

    export interface AiFeatureStoreEntityTypeIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureStoreEntityTypeIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureStoreEntityTypeMonitoringConfig {
        /**
         * Threshold for categorical features of anomaly detection. This is shared by all types of Featurestore Monitoring for categorical features (i.e. Features with type (Feature.ValueType) BOOL or STRING).
         * Structure is documented below.
         */
        categoricalThresholdConfig?: pulumi.Input<inputs.vertex.AiFeatureStoreEntityTypeMonitoringConfigCategoricalThresholdConfig>;
        /**
         * The config for ImportFeatures Analysis Based Feature Monitoring.
         * Structure is documented below.
         */
        importFeaturesAnalysis?: pulumi.Input<inputs.vertex.AiFeatureStoreEntityTypeMonitoringConfigImportFeaturesAnalysis>;
        /**
         * Threshold for numerical features of anomaly detection. This is shared by all objectives of Featurestore Monitoring for numerical features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64).
         * Structure is documented below.
         */
        numericalThresholdConfig?: pulumi.Input<inputs.vertex.AiFeatureStoreEntityTypeMonitoringConfigNumericalThresholdConfig>;
        /**
         * The config for Snapshot Analysis Based Feature Monitoring.
         * Structure is documented below.
         */
        snapshotAnalysis?: pulumi.Input<inputs.vertex.AiFeatureStoreEntityTypeMonitoringConfigSnapshotAnalysis>;
    }

    export interface AiFeatureStoreEntityTypeMonitoringConfigCategoricalThresholdConfig {
        /**
         * Specify a threshold value that can trigger the alert. For categorical feature, the distribution distance is calculated by L-inifinity norm. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
         */
        value: pulumi.Input<number>;
    }

    export interface AiFeatureStoreEntityTypeMonitoringConfigImportFeaturesAnalysis {
        /**
         * Defines the baseline to do anomaly detection for feature values imported by each [entityTypes.importFeatureValues][] operation. The value must be one of the values below:
         * * LATEST_STATS: Choose the later one statistics generated by either most recent snapshot analysis or previous import features analysis. If non of them exists, skip anomaly detection and only generate a statistics.
         * * MOST_RECENT_SNAPSHOT_STATS: Use the statistics generated by the most recent snapshot analysis if exists.
         * * PREVIOUS_IMPORT_FEATURES_STATS: Use the statistics generated by the previous import features analysis if exists.
         */
        anomalyDetectionBaseline?: pulumi.Input<string>;
        /**
         * Whether to enable / disable / inherite default hebavior for import features analysis. The value must be one of the values below:
         * * DEFAULT: The default behavior of whether to enable the monitoring. EntityType-level config: disabled.
         * * ENABLED: Explicitly enables import features analysis. EntityType-level config: by default enables import features analysis for all Features under it.
         * * DISABLED: Explicitly disables import features analysis. EntityType-level config: by default disables import features analysis for all Features under it.
         */
        state?: pulumi.Input<string>;
    }

    export interface AiFeatureStoreEntityTypeMonitoringConfigNumericalThresholdConfig {
        /**
         * Specify a threshold value that can trigger the alert. For numerical feature, the distribution distance is calculated by JensenShannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature. The default value is 0.3.
         */
        value: pulumi.Input<number>;
    }

    export interface AiFeatureStoreEntityTypeMonitoringConfigSnapshotAnalysis {
        /**
         * The monitoring schedule for snapshot analysis. For EntityType-level config: unset / disabled = true indicates disabled by default for Features under it; otherwise by default enable snapshot analysis monitoring with monitoringInterval for Features under it.
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Configuration of the snapshot analysis based monitoring pipeline running interval. The value is rolled up to full day.
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         *
         * > **Warning:** `monitoringInterval` is deprecated and will be removed in a future release.
         *
         * @deprecated `monitoringInterval` is deprecated and will be removed in a future release.
         */
        monitoringInterval?: pulumi.Input<string>;
        /**
         * Configuration of the snapshot analysis based monitoring pipeline running interval. The value indicates number of days. The default value is 1.
         * If both FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days and [FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval][] are set when creating/updating EntityTypes/Features, FeaturestoreMonitoringConfig.SnapshotAnalysis.monitoring_interval_days will be used.
         */
        monitoringIntervalDays?: pulumi.Input<number>;
        /**
         * Customized export features time window for snapshot analysis. Unit is one day. The default value is 21 days. Minimum value is 1 day. Maximum value is 4000 days.
         */
        stalenessDays?: pulumi.Input<number>;
    }

    export interface AiFeatureStoreIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureStoreIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AiFeatureStoreOnlineServingConfig {
        /**
         * The number of nodes for each cluster. The number of nodes will not scale automatically but can be scaled manually by providing different values when updating.
         */
        fixedNodeCount?: pulumi.Input<number>;
        /**
         * Online serving scaling configuration. Only one of fixedNodeCount and scaling can be set. Setting one will reset the other.
         * Structure is documented below.
         */
        scaling?: pulumi.Input<inputs.vertex.AiFeatureStoreOnlineServingConfigScaling>;
    }

    export interface AiFeatureStoreOnlineServingConfigScaling {
        /**
         * The maximum number of nodes to scale up to. Must be greater than minNodeCount, and less than or equal to 10 times of 'minNodeCount'.
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * The minimum number of nodes to scale down to. Must be greater than or equal to 1.
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface AiIndexDeployedIndex {
        /**
         * (Output)
         * The ID of the DeployedIndex in the above IndexEndpoint.
         */
        deployedIndexId?: pulumi.Input<string>;
        /**
         * (Output)
         * A resource name of the IndexEndpoint.
         */
        indexEndpoint?: pulumi.Input<string>;
    }

    export interface AiIndexEndpointDeployedIndexAutomaticResources {
        /**
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If maxReplicaCount is not set, the default value is minReplicaCount. The max allowed replica count is 1000.
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
         */
        maxReplicaCount?: pulumi.Input<number>;
        /**
         * The minimum number of replicas this DeployedModel will be always deployed on. If minReplicaCount is not set, the default value is 2 (we don't provide SLA when minReplicaCount=1).
         * If traffic against it increases, it may dynamically be deployed onto more replicas up to [maxReplicaCount](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/AutomaticResources#FIELDS.max_replica_count), and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
         */
        minReplicaCount?: pulumi.Input<number>;
    }

    export interface AiIndexEndpointDeployedIndexDedicatedResources {
        /**
         * The minimum number of replicas this DeployedModel will be always deployed on.
         * Structure is documented below.
         */
        machineSpec: pulumi.Input<inputs.vertex.AiIndexEndpointDeployedIndexDedicatedResourcesMachineSpec>;
        /**
         * The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If maxReplicaCount is not set, the default value is minReplicaCount
         */
        maxReplicaCount?: pulumi.Input<number>;
        /**
         * The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1.
         */
        minReplicaCount: pulumi.Input<number>;
    }

    export interface AiIndexEndpointDeployedIndexDedicatedResourcesMachineSpec {
        /**
         * The type of the machine.
         * See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
         * See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
         * For [DeployedModel](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.endpoints#DeployedModel) this field is optional, and the default value is n1-standard-2. For [BatchPredictionJob](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.batchPredictionJobs#BatchPredictionJob) or as part of [WorkerPoolSpec](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/CustomJobSpec#WorkerPoolSpec) this field is required.
         */
        machineType?: pulumi.Input<string>;
    }

    export interface AiIndexEndpointDeployedIndexDeployedIndexAuthConfig {
        /**
         * Defines the authentication provider that the DeployedIndex uses.
         * Structure is documented below.
         */
        authProvider?: pulumi.Input<inputs.vertex.AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProvider>;
    }

    export interface AiIndexEndpointDeployedIndexDeployedIndexAuthConfigAuthProvider {
        /**
         * A list of allowed JWT issuers. Each entry must be a valid Google service account, in the following format: service-account-name@project-id.iam.gserviceaccount.com
         */
        allowedIssuers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of JWT audiences. that are allowed to access. A JWT containing any of these audiences will be accepted.
         */
        audiences?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiIndexEndpointDeployedIndexPrivateEndpoint {
        /**
         * (Output)
         * The ip address used to send match gRPC requests.
         */
        matchGrpcAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * PscAutomatedEndpoints is populated if private service connect is enabled if PscAutomatedConfig is set.
         * Structure is documented below.
         */
        pscAutomatedEndpoints?: pulumi.Input<pulumi.Input<inputs.vertex.AiIndexEndpointDeployedIndexPrivateEndpointPscAutomatedEndpoint>[]>;
        /**
         * (Output)
         * The name of the service attachment resource. Populated if private service connect is enabled.
         */
        serviceAttachment?: pulumi.Input<string>;
    }

    export interface AiIndexEndpointDeployedIndexPrivateEndpointPscAutomatedEndpoint {
        /**
         * (Output)
         * ip Address created by the automated forwarding rule.
         */
        matchAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * Corresponding network in pscAutomationConfigs.
         */
        network?: pulumi.Input<string>;
        /**
         * (Output)
         * Corresponding projectId in pscAutomationConfigs
         */
        projectId?: pulumi.Input<string>;
    }

    export interface AiIndexEndpointPrivateServiceConnectConfig {
        /**
         * If set to true, the IndexEndpoint is created without private service access.
         */
        enablePrivateServiceConnect: pulumi.Input<boolean>;
        /**
         * A list of Projects from which the forwarding rule will target the service attachment.
         */
        projectAllowlists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AiIndexIndexStat {
        /**
         * (Output)
         * The number of shards in the Index.
         */
        shardsCount?: pulumi.Input<number>;
        /**
         * (Output)
         * The number of vectors in the Index.
         */
        vectorsCount?: pulumi.Input<string>;
    }

    export interface AiIndexMetadata {
        /**
         * The configuration of the Matching Engine Index.
         * Structure is documented below.
         */
        config?: pulumi.Input<inputs.vertex.AiIndexMetadataConfig>;
        /**
         * Allows inserting, updating  or deleting the contents of the Matching Engine Index.
         * The string must be a valid Cloud Storage directory path. If this
         * field is set when calling IndexService.UpdateIndex, then no other
         * Index field can be also updated as part of the same call.
         * The expected structure and format of the files this URI points to is
         * described at https://cloud.google.com/vertex-ai/docs/matching-engine/using-matching-engine#input-data-format
         */
        contentsDeltaUri?: pulumi.Input<string>;
        /**
         * If this field is set together with contentsDeltaUri when calling IndexService.UpdateIndex,
         * then existing content of the Index will be replaced by the data from the contentsDeltaUri.
         */
        isCompleteOverwrite?: pulumi.Input<boolean>;
    }

    export interface AiIndexMetadataConfig {
        /**
         * The configuration with regard to the algorithms used for efficient search.
         * Structure is documented below.
         */
        algorithmConfig?: pulumi.Input<inputs.vertex.AiIndexMetadataConfigAlgorithmConfig>;
        /**
         * The default number of neighbors to find via approximate search before exact reordering is
         * performed. Exact reordering is a procedure where results returned by an
         * approximate search algorithm are reordered via a more expensive distance computation.
         * Required if tree-AH algorithm is used.
         */
        approximateNeighborsCount?: pulumi.Input<number>;
        /**
         * The number of dimensions of the input vectors.
         */
        dimensions: pulumi.Input<number>;
        /**
         * The distance measure used in nearest neighbor search. The value must be one of the followings:
         * * SQUARED_L2_DISTANCE: Euclidean (L_2) Distance
         * * L1_DISTANCE: Manhattan (L_1) Distance
         * * COSINE_DISTANCE: Cosine Distance. Defined as 1 - cosine similarity.
         * * DOT_PRODUCT_DISTANCE: Dot Product Distance. Defined as a negative of the dot product
         */
        distanceMeasureType?: pulumi.Input<string>;
        /**
         * Type of normalization to be carried out on each vector. The value must be one of the followings:
         * * UNIT_L2_NORM: Unit L2 normalization type
         * * NONE: No normalization type is specified.
         */
        featureNormType?: pulumi.Input<string>;
        /**
         * Index data is split into equal parts to be processed. These are called "shards".
         * The shard size must be specified when creating an index. The value must be one of the followings:
         * * SHARD_SIZE_SMALL: Small (2GB)
         * * SHARD_SIZE_MEDIUM: Medium (20GB)
         * * SHARD_SIZE_LARGE: Large (50GB)
         */
        shardSize?: pulumi.Input<string>;
    }

    export interface AiIndexMetadataConfigAlgorithmConfig {
        /**
         * Configuration options for using brute force search, which simply implements the
         * standard linear search in the database for each query.
         */
        bruteForceConfig?: pulumi.Input<inputs.vertex.AiIndexMetadataConfigAlgorithmConfigBruteForceConfig>;
        /**
         * Configuration options for using the tree-AH algorithm (Shallow tree + Asymmetric Hashing).
         * Please refer to this paper for more details: https://arxiv.org/abs/1908.10396
         * Structure is documented below.
         */
        treeAhConfig?: pulumi.Input<inputs.vertex.AiIndexMetadataConfigAlgorithmConfigTreeAhConfig>;
    }

    export interface AiIndexMetadataConfigAlgorithmConfigBruteForceConfig {
    }

    export interface AiIndexMetadataConfigAlgorithmConfigTreeAhConfig {
        /**
         * Number of embeddings on each leaf node. The default value is 1000 if not set.
         */
        leafNodeEmbeddingCount?: pulumi.Input<number>;
        /**
         * The default percentage of leaf nodes that any query may be searched. Must be in
         * range 1-100, inclusive. The default value is 10 (means 10%) if not set.
         */
        leafNodesToSearchPercent?: pulumi.Input<number>;
    }

    export interface AiMetadataStoreEncryptionSpec {
        /**
         * Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource.
         * Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
         */
        kmsKeyName?: pulumi.Input<string>;
    }

    export interface AiMetadataStoreState {
        /**
         * (Output)
         * The disk utilization of the MetadataStore in bytes.
         */
        diskUtilizationBytes?: pulumi.Input<string>;
    }

    export interface AiTensorboardEncryptionSpec {
        /**
         * The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource.
         * Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the resource is created.
         */
        kmsKeyName: pulumi.Input<string>;
    }

}

export namespace vmwareengine {
    export interface ClusterAutoscalingSettings {
        /**
         * The map with autoscaling policies applied to the cluster.
         * The key is the identifier of the policy.
         * It must meet the following requirements:
         * * Only contains 1-63 alphanumeric characters and hyphens
         * * Begins with an alphabetical character
         * * Ends with a non-hyphen character
         * * Not formatted as a UUID
         * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
         * Currently the map must contain only one element
         * that describes the autoscaling policy for compute nodes.
         * Structure is documented below.
         */
        autoscalingPolicies: pulumi.Input<pulumi.Input<inputs.vmwareengine.ClusterAutoscalingSettingsAutoscalingPolicy>[]>;
        /**
         * The minimum duration between consecutive autoscale operations.
         * It starts once addition or removal of nodes is fully completed.
         * Minimum cool down period is 30m.
         * Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        coolDownPeriod?: pulumi.Input<string>;
        /**
         * Maximum number of nodes of any type in a cluster.
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        maxClusterNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of nodes of any type in a cluster.
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        minClusterNodeCount?: pulumi.Input<number>;
    }

    export interface ClusterAutoscalingSettingsAutoscalingPolicy {
        /**
         * The identifier for this object. Format specified above.
         */
        autoscalePolicyId: pulumi.Input<string>;
        /**
         * Utilization thresholds pertaining to amount of consumed memory.
         * Structure is documented below.
         */
        consumedMemoryThresholds?: pulumi.Input<inputs.vmwareengine.ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds>;
        /**
         * Utilization thresholds pertaining to CPU utilization.
         * Structure is documented below.
         */
        cpuThresholds?: pulumi.Input<inputs.vmwareengine.ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds>;
        /**
         * The canonical identifier of the node type to add or remove.
         */
        nodeTypeId: pulumi.Input<string>;
        /**
         * Number of nodes to add to a cluster during a scale-out operation.
         * Must be divisible by 2 for stretched clusters.
         */
        scaleOutSize: pulumi.Input<number>;
        /**
         * Utilization thresholds pertaining to amount of consumed storage.
         * Structure is documented below.
         */
        storageThresholds?: pulumi.Input<inputs.vmwareengine.ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds>;
    }

    export interface ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface ClusterNodeTypeConfig {
        /**
         * Customized number of cores available to each node of the type.
         * This number must always be one of `nodeType.availableCustomCoreCounts`.
         * If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
         * Once the customer is created then corecount cannot be changed.
         */
        customCoreCount?: pulumi.Input<number>;
        /**
         * The number of nodes of this type in the cluster.
         */
        nodeCount: pulumi.Input<number>;
        /**
         * The identifier for this object. Format specified above.
         */
        nodeTypeId: pulumi.Input<string>;
    }

    export interface ExternalAccessRuleDestinationIpRange {
        /**
         * The name of an `ExternalAddress` resource.
         *
         * - - -
         */
        externalAddress?: pulumi.Input<string>;
        /**
         * An IP address range in the CIDR format.
         */
        ipAddressRange?: pulumi.Input<string>;
    }

    export interface ExternalAccessRuleSourceIpRange {
        /**
         * A single IP address.
         */
        ipAddress?: pulumi.Input<string>;
        /**
         * An IP address range in the CIDR format.
         */
        ipAddressRange?: pulumi.Input<string>;
    }

    export interface NetworkPolicyExternalIp {
        /**
         * True if the service is enabled; false otherwise.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * State of the service. New values may be added to this enum when appropriate.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkPolicyInternetAccess {
        /**
         * True if the service is enabled; false otherwise.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Output)
         * State of the service. New values may be added to this enum when appropriate.
         */
        state?: pulumi.Input<string>;
    }

    export interface NetworkVpcNetwork {
        /**
         * (Output)
         * The relative resource name of the service VPC network this VMware Engine network is attached to.
         * For example: projects/123123/global/networks/my-network
         */
        network?: pulumi.Input<string>;
        /**
         * VMware Engine network type.
         * Possible values are: `LEGACY`, `STANDARD`.
         */
        type?: pulumi.Input<string>;
    }

    export interface PrivateCloudHcx {
        /**
         * Fully qualified domain name of the appliance.
         */
        fqdn?: pulumi.Input<string>;
        /**
         * Internal IP address of the appliance.
         */
        internalIp?: pulumi.Input<string>;
        /**
         * State of the appliance.
         * Possible values are: `ACTIVE`, `CREATING`.
         */
        state?: pulumi.Input<string>;
        /**
         * Version of the appliance.
         */
        version?: pulumi.Input<string>;
    }

    export interface PrivateCloudManagementCluster {
        /**
         * Configuration of the autoscaling applied to this cluster
         * Private cloud must have a minimum of 3 nodes to add autoscale settings
         * Structure is documented below.
         */
        autoscalingSettings?: pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterAutoscalingSettings>;
        /**
         * The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
         * * Only contains 1-63 alphanumeric characters and hyphens
         * * Begins with an alphabetical character
         * * Ends with a non-hyphen character
         * * Not formatted as a UUID
         * * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
         */
        clusterId: pulumi.Input<string>;
        /**
         * The map of cluster node types in this cluster,
         * where the key is canonical identifier of the node type (corresponds to the NodeType).
         * Structure is documented below.
         */
        nodeTypeConfigs?: pulumi.Input<pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterNodeTypeConfig>[]>;
        /**
         * The stretched cluster configuration for the private cloud.
         * Structure is documented below.
         */
        stretchedClusterConfig?: pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterStretchedClusterConfig>;
    }

    export interface PrivateCloudManagementClusterAutoscalingSettings {
        /**
         * The map with autoscaling policies applied to the cluster.
         * The key is the identifier of the policy.
         * It must meet the following requirements:
         * * Only contains 1-63 alphanumeric characters and hyphens
         * * Begins with an alphabetical character
         * * Ends with a non-hyphen character
         * * Not formatted as a UUID
         * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
         * Currently the map must contain only one element
         * that describes the autoscaling policy for compute nodes.
         * Structure is documented below.
         */
        autoscalingPolicies: pulumi.Input<pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy>[]>;
        /**
         * The minimum duration between consecutive autoscale operations.
         * It starts once addition or removal of nodes is fully completed.
         * Minimum cool down period is 30m.
         * Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        coolDownPeriod?: pulumi.Input<string>;
        /**
         * Maximum number of nodes of any type in a cluster.
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        maxClusterNodeCount?: pulumi.Input<number>;
        /**
         * Minimum number of nodes of any type in a cluster.
         * Mandatory for successful addition of autoscaling settings in cluster.
         */
        minClusterNodeCount?: pulumi.Input<number>;
    }

    export interface PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy {
        /**
         * The identifier for this object. Format specified above.
         */
        autoscalePolicyId: pulumi.Input<string>;
        /**
         * Utilization thresholds pertaining to amount of consumed memory.
         * Structure is documented below.
         */
        consumedMemoryThresholds?: pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds>;
        /**
         * Utilization thresholds pertaining to CPU utilization.
         * Structure is documented below.
         */
        cpuThresholds?: pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds>;
        /**
         * The canonical identifier of the node type to add or remove.
         */
        nodeTypeId: pulumi.Input<string>;
        /**
         * Number of nodes to add to a cluster during a scale-out operation.
         * Must be divisible by 2 for stretched clusters.
         */
        scaleOutSize: pulumi.Input<number>;
        /**
         * Utilization thresholds pertaining to amount of consumed storage.
         * Structure is documented below.
         */
        storageThresholds?: pulumi.Input<inputs.vmwareengine.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds>;
    }

    export interface PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds {
        /**
         * The utilization triggering the scale-in operation in percent.
         *
         * - - -
         */
        scaleIn: pulumi.Input<number>;
        /**
         * The utilization triggering the scale-out operation in percent.
         */
        scaleOut: pulumi.Input<number>;
    }

    export interface PrivateCloudManagementClusterNodeTypeConfig {
        /**
         * Customized number of cores available to each node of the type.
         * This number must always be one of `nodeType.availableCustomCoreCounts`.
         * If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
         * This cannot be changed once the PrivateCloud is created.
         */
        customCoreCount?: pulumi.Input<number>;
        /**
         * The number of nodes of this type in the cluster.
         */
        nodeCount: pulumi.Input<number>;
        /**
         * The identifier for this object. Format specified above.
         */
        nodeTypeId: pulumi.Input<string>;
    }

    export interface PrivateCloudManagementClusterStretchedClusterConfig {
        /**
         * Zone that will remain operational when connection between the two zones is lost.
         * Specify the zone in the following format: projects/{project}/locations/{location}.
         */
        preferredLocation?: pulumi.Input<string>;
        /**
         * Additional zone for a higher level of availability and load balancing.
         * Specify the zone in the following format: projects/{project}/locations/{location}.
         */
        secondaryLocation?: pulumi.Input<string>;
    }

    export interface PrivateCloudNetworkConfig {
        /**
         * (Output)
         * DNS Server IP of the Private Cloud.
         */
        dnsServerIp?: pulumi.Input<string>;
        /**
         * Management CIDR used by VMware management appliances.
         */
        managementCidr: pulumi.Input<string>;
        /**
         * (Output)
         * The IP address layout version of the management IP address range.
         * Possible versions include:
         * * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
         * as it does not support all features.
         * * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
         * used by all newly created private clouds. This version supports all current features.
         */
        managementIpAddressLayoutVersion?: pulumi.Input<number>;
        /**
         * The relative resource name of the VMware Engine network attached to the private cloud.
         * Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
         * where {project} can either be a project number or a project ID.
         */
        vmwareEngineNetwork?: pulumi.Input<string>;
        /**
         * (Output)
         * The canonical name of the VMware Engine network in
         * the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
         */
        vmwareEngineNetworkCanonical?: pulumi.Input<string>;
    }

    export interface PrivateCloudNsx {
        /**
         * Fully qualified domain name of the appliance.
         */
        fqdn?: pulumi.Input<string>;
        /**
         * Internal IP address of the appliance.
         */
        internalIp?: pulumi.Input<string>;
        /**
         * State of the appliance.
         * Possible values are: `ACTIVE`, `CREATING`.
         */
        state?: pulumi.Input<string>;
        /**
         * Version of the appliance.
         */
        version?: pulumi.Input<string>;
    }

    export interface PrivateCloudVcenter {
        /**
         * Fully qualified domain name of the appliance.
         */
        fqdn?: pulumi.Input<string>;
        /**
         * Internal IP address of the appliance.
         */
        internalIp?: pulumi.Input<string>;
        /**
         * State of the appliance.
         * Possible values are: `ACTIVE`, `CREATING`.
         */
        state?: pulumi.Input<string>;
        /**
         * Version of the appliance.
         */
        version?: pulumi.Input<string>;
    }

    export interface SubnetDhcpAddressRange {
        /**
         * (Output)
         * The first IP address of the range.
         */
        firstAddress?: pulumi.Input<string>;
        /**
         * (Output)
         * The last IP address of the range.
         */
        lastAddress?: pulumi.Input<string>;
    }
}

export namespace vpcaccess {
    export interface ConnectorSubnet {
        /**
         * Subnet name (relative, not fully qualified). E.g. if the full subnet selfLink is
         * https://compute.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetName} the correct input for this field would be {subnetName}"
         */
        name?: pulumi.Input<string>;
        /**
         * Project in which the subnet exists. If not set, this project is assumed to be the project for which the connector create request was issued.
         */
        projectId?: pulumi.Input<string>;
    }

}

export namespace workbench {
    export interface InstanceGceSetup {
        /**
         * The hardware accelerators used on this instance. If you use accelerators, make sure that your configuration has
         * [enough vCPUs and memory to support the `machineType` you have selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
         * Currently supports only one accelerator configuration.
         * Structure is documented below.
         */
        acceleratorConfigs?: pulumi.Input<pulumi.Input<inputs.workbench.InstanceGceSetupAcceleratorConfig>[]>;
        /**
         * The definition of a boot disk.
         * Structure is documented below.
         */
        bootDisk?: pulumi.Input<inputs.workbench.InstanceGceSetupBootDisk>;
        /**
         * Confidential instance configuration.
         * Structure is documented below.
         */
        confidentialInstanceConfig?: pulumi.Input<inputs.workbench.InstanceGceSetupConfidentialInstanceConfig>;
        /**
         * Use a container image to start the workbench instance.
         * Structure is documented below.
         */
        containerImage?: pulumi.Input<inputs.workbench.InstanceGceSetupContainerImage>;
        /**
         * Data disks attached to the VM instance. Currently supports only one data disk.
         * Structure is documented below.
         */
        dataDisks?: pulumi.Input<inputs.workbench.InstanceGceSetupDataDisks>;
        /**
         * Optional. If true, no external IP will be assigned to this VM instance.
         */
        disablePublicIp?: pulumi.Input<boolean>;
        /**
         * Optional. Flag to enable ip forwarding or not, default false/off.
         * https://cloud.google.com/vpc/docs/using-routes#canipforward
         */
        enableIpForwarding?: pulumi.Input<boolean>;
        /**
         * Optional. The machine type of the VM instance. https://cloud.google.com/compute/docs/machine-resource
         */
        machineType?: pulumi.Input<string>;
        /**
         * Optional. Custom metadata to apply to this instance.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The network interfaces for the VM. Supports only one interface.
         * Structure is documented below.
         */
        networkInterfaces?: pulumi.Input<pulumi.Input<inputs.workbench.InstanceGceSetupNetworkInterface>[]>;
        /**
         * The service account that serves as an identity for the VM instance. Currently supports only one service account.
         * Structure is documented below.
         */
        serviceAccounts?: pulumi.Input<pulumi.Input<inputs.workbench.InstanceGceSetupServiceAccount>[]>;
        /**
         * A set of Shielded Instance options. See [Images using supported Shielded
         * VM features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
         * Not all combinations are valid.
         * Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.workbench.InstanceGceSetupShieldedInstanceConfig>;
        /**
         * Optional. The Compute Engine tags to add to instance (see [Tagging
         * instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Definition of a custom Compute Engine virtual machine image for starting
         * a workbench instance with the environment installed directly on the VM.
         * Structure is documented below.
         */
        vmImage?: pulumi.Input<inputs.workbench.InstanceGceSetupVmImage>;
    }

    export interface InstanceGceSetupAcceleratorConfig {
        /**
         * Optional. Count of cores of this accelerator.
         */
        coreCount?: pulumi.Input<string>;
        /**
         * Optional. Type of this accelerator.
         * Possible values are: `NVIDIA_TESLA_P100`, `NVIDIA_TESLA_V100`, `NVIDIA_TESLA_P4`, `NVIDIA_TESLA_T4`, `NVIDIA_TESLA_A100`, `NVIDIA_A100_80GB`, `NVIDIA_L4`, `NVIDIA_TESLA_T4_VWS`, `NVIDIA_TESLA_P100_VWS`, `NVIDIA_TESLA_P4_VWS`.
         */
        type?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupBootDisk {
        /**
         * Optional. Input only. Disk encryption method used on the boot and
         * data disks, defaults to GMEK.
         * Possible values are: `GMEK`, `CMEK`.
         */
        diskEncryption?: pulumi.Input<string>;
        /**
         * Optional. The size of the boot disk in GB attached to this instance,
         * up to a maximum of 64000 GB (64 TB). If not specified, this defaults to the
         * recommended value of 150GB.
         */
        diskSizeGb?: pulumi.Input<string>;
        /**
         * Optional. Indicates the type of the disk.
         * Possible values are: `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * 'Optional. The KMS key used to encrypt the disks, only
         * applicable if diskEncryption is CMEK. Format: `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
         * Learn more about using your own encryption keys.'
         */
        kmsKey?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupConfidentialInstanceConfig {
        /**
         * Defines the type of technology used by the confidential instance.
         * Possible values are: `SEV`.
         */
        confidentialInstanceType?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupContainerImage {
        /**
         * The path to the container image repository.
         * For example: gcr.io/{project_id}/{imageName}
         */
        repository: pulumi.Input<string>;
        /**
         * The tag of the container image. If not specified, this defaults to the latest tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupDataDisks {
        /**
         * Optional. Input only. Disk encryption method used on the boot
         * and data disks, defaults to GMEK.
         * Possible values are: `GMEK`, `CMEK`.
         */
        diskEncryption?: pulumi.Input<string>;
        /**
         * Optional. The size of the disk in GB attached to this VM instance,
         * up to a maximum of 64000 GB (64 TB). If not specified, this defaults to
         * 100.
         */
        diskSizeGb?: pulumi.Input<string>;
        /**
         * Optional. Input only. Indicates the type of the disk.
         * Possible values are: `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * 'Optional. The KMS key used to encrypt the disks,
         * only applicable if diskEncryption is CMEK. Format: `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
         * Learn more about using your own encryption keys.'
         */
        kmsKey?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupNetworkInterface {
        /**
         * Optional. An array of configurations for this interface. Currently, only one access
         * config, ONE_TO_ONE_NAT, is supported. If no accessConfigs specified, the
         * instance will have an external internet access through an ephemeral
         * external IP address.
         * Structure is documented below.
         */
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.workbench.InstanceGceSetupNetworkInterfaceAccessConfig>[]>;
        /**
         * Optional. The name of the VPC that this VM instance is in.
         */
        network?: pulumi.Input<string>;
        /**
         * Optional. The type of vNIC to be used on this interface. This
         * may be gVNIC or VirtioNet.
         * Possible values are: `VIRTIO_NET`, `GVNIC`.
         */
        nicType?: pulumi.Input<string>;
        /**
         * Optional. The name of the subnet that this VM instance is in.
         */
        subnet?: pulumi.Input<string>;
    }

    export interface InstanceGceSetupNetworkInterfaceAccessConfig {
        /**
         * An external IP address associated with this instance. Specify an unused
         * static external IP address available to the project or leave this field
         * undefined to use an IP from a shared ephemeral IP address pool. If you
         * specify a static external IP address, it must live in the same region as
         * the zone of the instance.
         */
        externalIp: pulumi.Input<string>;
    }

    export interface InstanceGceSetupServiceAccount {
        /**
         * Optional. Email address of the service account.
         */
        email?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The list of scopes to be made available for this
         * service account. Set by the CLH to https://www.googleapis.com/auth/cloud-platform
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceGceSetupShieldedInstanceConfig {
        /**
         * Optional. Defines whether the VM instance has integrity monitoring
         * enabled. Enables monitoring and attestation of the boot integrity of the VM
         * instance. The attestation is performed against the integrity policy baseline.
         * This baseline is initially derived from the implicitly trusted boot image
         * when the VM instance is created. Enabled by default.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Optional. Defines whether the VM instance has Secure Boot enabled.
         * Secure Boot helps ensure that the system only runs authentic software by verifying
         * the digital signature of all boot components, and halting the boot process
         * if signature verification fails. Disabled by default.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Optional. Defines whether the VM instance has the vTPM enabled.
         * Enabled by default.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceGceSetupVmImage {
        /**
         * Optional. Use this VM image family to find the image; the newest
         * image in this family will be used.
         */
        family?: pulumi.Input<string>;
        /**
         * Optional. Use VM image name to find the image.
         */
        name?: pulumi.Input<string>;
        /**
         * The name of the Google Cloud project that this VM image belongs to.
         * Format: {project_id}
         */
        project?: pulumi.Input<string>;
    }

    export interface InstanceHealthInfo {
    }

    export interface InstanceIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface InstanceUpgradeHistory {
        /**
         * Optional. Action. Rolloback or Upgrade.
         */
        action?: pulumi.Input<string>;
        /**
         * Optional. The container image before this instance upgrade.
         */
        containerImage?: pulumi.Input<string>;
        /**
         * An RFC3339 timestamp in UTC time. This in the format of yyyy-MM-ddTHH:mm:ss.SSSZ.
         * The milliseconds portion (".SSS") is optional.
         */
        createTime?: pulumi.Input<string>;
        /**
         * Optional. The framework of this workbench instance.
         */
        framework?: pulumi.Input<string>;
        /**
         * Optional. The snapshot of the boot disk of this workbench instance before upgrade.
         */
        snapshot?: pulumi.Input<string>;
        /**
         * (Output)
         * Output only. The state of this instance upgrade history entry.
         */
        state?: pulumi.Input<string>;
        /**
         * Optional. Target VM Version, like m63.
         */
        targetVersion?: pulumi.Input<string>;
        /**
         * Optional. The version of the workbench instance before this upgrade.
         */
        version?: pulumi.Input<string>;
        /**
         * Optional. The VM image before this instance upgrade.
         */
        vmImage?: pulumi.Input<string>;
    }
}

export namespace workstations {
    export interface WorkstationClusterCondition {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
    }

    export interface WorkstationClusterDomainConfig {
        /**
         * Domain used by Workstations for HTTP ingress.
         */
        domain: pulumi.Input<string>;
    }

    export interface WorkstationClusterPrivateClusterConfig {
        /**
         * Additional project IDs that are allowed to attach to the workstation cluster's service attachment.
         * By default, the workstation cluster's project and the VPC host project (if different) are allowed.
         */
        allowedProjects?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (Output)
         * Hostname for the workstation cluster.
         * This field will be populated only when private endpoint is enabled.
         * To access workstations in the cluster, create a new DNS zone mapping this domain name to an internal IP address and a forwarding rule mapping that address to the service attachment.
         */
        clusterHostname?: pulumi.Input<string>;
        /**
         * Whether Workstations endpoint is private.
         */
        enablePrivateEndpoint: pulumi.Input<boolean>;
        /**
         * (Output)
         * Service attachment URI for the workstation cluster.
         * The service attachment is created when private endpoint is enabled.
         * To access workstations in the cluster, configure access to the managed service using (Private Service Connect)[https://cloud.google.com/vpc/docs/configure-private-service-connect-services].
         */
        serviceAttachmentUri?: pulumi.Input<string>;
    }

    export interface WorkstationConfigAllowedPort {
        /**
         * Starting port number for the current range of ports. Valid ports are 22, 80, and ports within the range 1024-65535.
         */
        first?: pulumi.Input<number>;
        /**
         * Ending port number for the current range of ports. Valid ports are 22, 80, and ports within the range 1024-65535.
         */
        last?: pulumi.Input<number>;
    }

    export interface WorkstationConfigCondition {
        /**
         * (Output)
         * The status code, which should be an enum value of google.rpc.Code.
         */
        code?: pulumi.Input<number>;
        /**
         * (Output)
         * A list of messages that carry the error details.
         */
        details?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * (Output)
         * Human readable message indicating details about the current status.
         */
        message?: pulumi.Input<string>;
    }

    export interface WorkstationConfigContainer {
        /**
         * Arguments passed to the entrypoint.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If set, overrides the default ENTRYPOINT specified by the image.
         */
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Environment variables passed to the container.
         * The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
         */
        env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Docker image defining the container. This image must be accessible by the config's service account.
         */
        image?: pulumi.Input<string>;
        /**
         * If set, overrides the USER specified in the image with the given uid.
         */
        runAsUser?: pulumi.Input<number>;
        /**
         * If set, overrides the default DIR specified by the image.
         */
        workingDir?: pulumi.Input<string>;
    }

    export interface WorkstationConfigEncryptionKey {
        /**
         * The name of the Google Cloud KMS encryption key.
         */
        kmsKey: pulumi.Input<string>;
        /**
         * The service account to use with the specified KMS key.
         */
        kmsKeyServiceAccount: pulumi.Input<string>;
    }

    export interface WorkstationConfigEphemeralDirectory {
        /**
         * An EphemeralDirectory backed by a Compute Engine persistent disk.
         * Structure is documented below.
         */
        gcePd?: pulumi.Input<inputs.workstations.WorkstationConfigEphemeralDirectoryGcePd>;
        /**
         * Location of this directory in the running workstation.
         */
        mountPath?: pulumi.Input<string>;
    }

    export interface WorkstationConfigEphemeralDirectoryGcePd {
        /**
         * Type of the disk to use. Defaults to `"pd-standard"`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * Whether the disk is read only. If true, the disk may be shared by multiple VMs and `sourceSnapshot` must be set.
         */
        readOnly?: pulumi.Input<boolean>;
        /**
         * Name of the disk image to use as the source for the disk.
         * Must be empty `sourceSnapshot` is set.
         * Updating `sourceImage` will update content in the ephemeral directory after the workstation is restarted.
         */
        sourceImage?: pulumi.Input<string>;
        /**
         * Name of the snapshot to use as the source for the disk.
         * Must be empty if `sourceImage` is set.
         * Must be empty if `readOnly` is false.
         * Updating `sourceSnapshot` will update content in the ephemeral directory after the workstation is restarted.
         */
        sourceSnapshot?: pulumi.Input<string>;
    }

    export interface WorkstationConfigHost {
        /**
         * A runtime using a Compute Engine instance.
         * Structure is documented below.
         */
        gceInstance?: pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstance>;
    }

    export interface WorkstationConfigHostGceInstance {
        /**
         * An accelerator card attached to the instance.
         * Structure is documented below.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstanceAccelerator>[]>;
        /**
         * A list of the boost configurations that workstations created using this workstation configuration are allowed to use.
         * Structure is documented below.
         */
        boostConfigs?: pulumi.Input<pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstanceBoostConfig>[]>;
        /**
         * Size of the boot disk in GB.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * A set of Compute Engine Confidential VM instance options.
         * Structure is documented below.
         */
        confidentialInstanceConfig?: pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstanceConfidentialInstanceConfig>;
        /**
         * Whether instances have no public IP address.
         */
        disablePublicIpAddresses?: pulumi.Input<boolean>;
        /**
         * Whether to disable SSH access to the VM.
         */
        disableSsh?: pulumi.Input<boolean>;
        /**
         * Whether to enable nested virtualization on the Compute Engine VMs backing the Workstations.
         * See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * The name of a Compute Engine machine type.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Number of instances to pool for faster workstation startup.
         */
        poolSize?: pulumi.Input<number>;
        /**
         * Email address of the service account that will be used on VM instances used to support this config. This service account must have permission to pull the specified container image. If not set, VMs will run without a service account, in which case the image must be publicly accessible.
         */
        serviceAccount?: pulumi.Input<string>;
        /**
         * Scopes to grant to the service_account. Various scopes are automatically added based on feature usage. When specified, users of workstations under this configuration must have `iam.serviceAccounts.actAs` on the service account.
         */
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A set of Compute Engine Shielded instance options.
         * Structure is documented below.
         */
        shieldedInstanceConfig?: pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstanceShieldedInstanceConfig>;
        /**
         * Network tags to add to the Compute Engine machines backing the Workstations.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Resource manager tags to be bound to the VM instances backing the Workstations.
         * Tag keys and values have the same definition as
         * https://cloud.google.com/resource-manager/docs/tags/tags-overview
         * Keys must be in the format `tagKeys/{tag_key_id}`, and
         * values are in the format `tagValues/456`.
         */
        vmTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WorkstationConfigHostGceInstanceAccelerator {
        /**
         * Number of accelerator cards exposed to the instance.
         */
        count: pulumi.Input<number>;
        /**
         * Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
         */
        type: pulumi.Input<string>;
    }

    export interface WorkstationConfigHostGceInstanceBoostConfig {
        /**
         * An accelerator card attached to the boost instance.
         * Structure is documented below.
         */
        accelerators?: pulumi.Input<pulumi.Input<inputs.workstations.WorkstationConfigHostGceInstanceBoostConfigAccelerator>[]>;
        /**
         * Size of the boot disk in GB. The minimum boot disk size is `30` GB. Defaults to `50` GB.
         */
        bootDiskSizeGb?: pulumi.Input<number>;
        /**
         * Whether to enable nested virtualization on the Compute Engine VMs backing boosted Workstations.
         * See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
         */
        enableNestedVirtualization?: pulumi.Input<boolean>;
        /**
         * The id to be used for the boost config.
         */
        id: pulumi.Input<string>;
        /**
         * The type of machine that boosted VM instances will usefor example, e2-standard-4. For more information about machine types that Cloud Workstations supports, see the list of available machine types https://cloud.google.com/workstations/docs/available-machine-types. Defaults to e2-standard-4.
         */
        machineType?: pulumi.Input<string>;
        /**
         * Number of instances to pool for faster workstation boosting.
         */
        poolSize?: pulumi.Input<number>;
    }

    export interface WorkstationConfigHostGceInstanceBoostConfigAccelerator {
        /**
         * Number of accelerator cards exposed to the instance.
         */
        count: pulumi.Input<number>;
        /**
         * Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
         */
        type: pulumi.Input<string>;
    }

    export interface WorkstationConfigHostGceInstanceConfidentialInstanceConfig {
        /**
         * Whether the instance has confidential compute enabled.
         */
        enableConfidentialCompute?: pulumi.Input<boolean>;
    }

    export interface WorkstationConfigHostGceInstanceShieldedInstanceConfig {
        /**
         * Whether the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        /**
         * Whether the instance has Secure Boot enabled.
         */
        enableSecureBoot?: pulumi.Input<boolean>;
        /**
         * Whether the instance has the vTPM enabled.
         */
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface WorkstationConfigIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WorkstationConfigIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WorkstationConfigPersistentDirectory {
        /**
         * A directory to persist across workstation sessions, backed by a Compute Engine regional persistent disk. Can only be updated if not empty during creation.
         * Structure is documented below.
         */
        gcePd?: pulumi.Input<inputs.workstations.WorkstationConfigPersistentDirectoryGcePd>;
        /**
         * Location of this directory in the running workstation.
         */
        mountPath?: pulumi.Input<string>;
    }

    export interface WorkstationConfigPersistentDirectoryGcePd {
        /**
         * Type of the disk to use. Defaults to `"pd-standard"`.
         */
        diskType?: pulumi.Input<string>;
        /**
         * Type of file system that the disk should be formatted with. The workstation image must support this file system type. Must be empty if `sourceSnapshot` is set. Defaults to `ext4`.
         */
        fsType?: pulumi.Input<string>;
        /**
         * Whether the persistent disk should be deleted when the workstation is deleted. Valid values are `DELETE` and `RETAIN`. Defaults to `DELETE`.
         * Possible values are: `DELETE`, `RETAIN`.
         */
        reclaimPolicy?: pulumi.Input<string>;
        /**
         * The GB capacity of a persistent home directory for each workstation created with this configuration. Must be empty if `sourceSnapshot` is set.
         * Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`. Defaults to `200`. If less than `200` GB, the `diskType` must be `pd-balanced` or `pd-ssd`.
         */
        sizeGb?: pulumi.Input<number>;
        /**
         * Name of the snapshot to use as the source for the disk.
         * Must be empty if `sourceImage` is set.
         * Must be empty if `readOnly` is false.
         * Updating `sourceSnapshot` will update content in the ephemeral directory after the workstation is restarted.
         */
        sourceSnapshot?: pulumi.Input<string>;
    }

    export interface WorkstationConfigReadinessCheck {
        /**
         * Path to which the request should be sent.
         */
        path: pulumi.Input<string>;
        /**
         * Port to which the request should be sent.
         */
        port: pulumi.Input<number>;
    }

    export interface WorkstationIamBindingCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface WorkstationIamMemberCondition {
        description?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }
}
