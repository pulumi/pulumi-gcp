// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";

export interface ProviderBatching {
    enableBatching?: pulumi.Input<boolean>;
    sendAfter?: pulumi.Input<string>;
}

export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: pulumi.Input<string>;
        conditions: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicCondition>[]>;
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy>;
        ipSubnetworks?: pulumi.Input<pulumi.Input<string>[]>;
        members?: pulumi.Input<pulumi.Input<string>[]>;
        negate?: pulumi.Input<boolean>;
        requiredAccessLevels?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: pulumi.Input<pulumi.Input<string>[]>;
        allowedEncryptionStatuses?: pulumi.Input<pulumi.Input<string>[]>;
        osConstraints?: pulumi.Input<pulumi.Input<inputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint>[]>;
        requireScreenLock?: pulumi.Input<boolean>;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: pulumi.Input<string>;
        osType?: pulumi.Input<string>;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: pulumi.Input<pulumi.Input<string>[]>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        restrictedServices?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks?: pulumi.Input<boolean>;
    }

    export interface ApplicationUrlDispatchRule {
        domain?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
    }

    export interface DomainMappingResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingSslSettings {
        certificateId?: pulumi.Input<string>;
        pendingManagedCertificateId?: pulumi.Input<string>;
        sslManagementType?: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeployment {
        files?: pulumi.Input<pulumi.Input<inputs.appengine.StandardAppVersionDeploymentFile>[]>;
        zip?: pulumi.Input<inputs.appengine.StandardAppVersionDeploymentZip>;
    }

    export interface StandardAppVersionDeploymentFile {
        name: pulumi.Input<string>;
        sha1Sum?: pulumi.Input<string>;
        sourceUrl?: pulumi.Input<string>;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: pulumi.Input<number>;
        sourceUrl?: pulumi.Input<string>;
    }

    export interface StandardAppVersionEntrypoint {
        shell?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: pulumi.Input<string>;
        login?: pulumi.Input<string>;
        redirectHttpResponseCode?: pulumi.Input<string>;
        script?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerScript>;
        securityLevel?: pulumi.Input<string>;
        staticFiles?: pulumi.Input<inputs.appengine.StandardAppVersionHandlerStaticFiles>;
        urlRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath?: pulumi.Input<string>;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: pulumi.Input<boolean>;
        expiration?: pulumi.Input<string>;
        httpHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        mimeType?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        requireMatchingFile?: pulumi.Input<boolean>;
        uploadPathRegex?: pulumi.Input<string>;
    }

    export interface StandardAppVersionLibrary {
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: pulumi.Input<boolean>;
        clusterId?: pulumi.Input<string>;
    }

    export interface DatasetAccess {
        domain?: pulumi.Input<string>;
        groupByEmail?: pulumi.Input<string>;
        role?: pulumi.Input<string>;
        specialGroup?: pulumi.Input<string>;
        userByEmail?: pulumi.Input<string>;
        view?: pulumi.Input<inputs.bigquery.DatasetAccessView>;
    }

    export interface DatasetAccessView {
        datasetId: pulumi.Input<string>;
        projectId: pulumi.Input<string>;
        tableId: pulumi.Input<string>;
    }

    export interface TableExternalDataConfiguration {
        autodetect: pulumi.Input<boolean>;
        compression?: pulumi.Input<string>;
        csvOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationCsvOptions>;
        googleSheetsOptions?: pulumi.Input<inputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions>;
        ignoreUnknownValues?: pulumi.Input<boolean>;
        maxBadRecords?: pulumi.Input<number>;
        sourceFormat: pulumi.Input<string>;
        sourceUris: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableExternalDataConfigurationCsvOptions {
        allowJaggedRows?: pulumi.Input<boolean>;
        allowQuotedNewlines?: pulumi.Input<boolean>;
        encoding?: pulumi.Input<string>;
        fieldDelimiter?: pulumi.Input<string>;
        quote: pulumi.Input<string>;
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        range?: pulumi.Input<string>;
        skipLeadingRows?: pulumi.Input<number>;
    }

    export interface TableTimePartitioning {
        expirationMs?: pulumi.Input<number>;
        field?: pulumi.Input<string>;
        requirePartitionFilter?: pulumi.Input<boolean>;
        /**
         * Describes the table type.
         */
        type: pulumi.Input<string>;
    }

    export interface TableView {
        query: pulumi.Input<string>;
        useLegacySql?: pulumi.Input<boolean>;
    }
}

export namespace bigtable {
    export interface InstanceCluster {
        clusterId: pulumi.Input<string>;
        numNodes?: pulumi.Input<number>;
        storageType?: pulumi.Input<string>;
        zone: pulumi.Input<string>;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: pulumi.Input<string>;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail?: pulumi.Input<string>;
        noteReference: pulumi.Input<string>;
        publicKeys?: pulumi.Input<pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey>[]>;
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: pulumi.Input<string>;
        comment?: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        pkixPublicKey?: pulumi.Input<inputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey>;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: pulumi.Input<string>;
        signatureAlgorithm?: pulumi.Input<string>;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern?: pulumi.Input<string>;
    }

    export interface PolicyClusterAdmissionRule {
        cluster: pulumi.Input<string>;
        enforcementMode?: pulumi.Input<string>;
        evaluationMode?: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: pulumi.Input<string>;
        evaluationMode: pulumi.Input<string>;
        requireAttestationsBies?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: pulumi.Input<pulumi.Input<string>[]>;
        steps?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStep>[]>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TriggerBuildStep {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        dir?: pulumi.Input<string>;
        entrypoint?: pulumi.Input<string>;
        envs?: pulumi.Input<pulumi.Input<string>[]>;
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        secretEnvs?: pulumi.Input<pulumi.Input<string>[]>;
        timeout?: pulumi.Input<string>;
        timing?: pulumi.Input<string>;
        volumes?: pulumi.Input<pulumi.Input<inputs.cloudbuild.TriggerBuildStepVolume>[]>;
        waitFors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TriggerBuildStepVolume {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface TriggerTriggerTemplate {
        branchName?: pulumi.Input<string>;
        commitSha?: pulumi.Input<string>;
        dir?: pulumi.Input<string>;
        projectId?: pulumi.Input<string>;
        repoName?: pulumi.Input<string>;
        tagName?: pulumi.Input<string>;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        eventType: pulumi.Input<string>;
        failurePolicy?: pulumi.Input<inputs.cloudfunctions.FunctionEventTriggerFailurePolicy>;
        resource: pulumi.Input<string>;
    }

    export interface FunctionEventTriggerFailurePolicy {
        retry: pulumi.Input<boolean>;
    }

    export interface FunctionSourceRepository {
        deployedUrl?: pulumi.Input<string>;
        url: pulumi.Input<string>;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface DomainMappingSpec {
        certificateMode?: pulumi.Input<string>;
        forceOverride?: pulumi.Input<boolean>;
        routeName: pulumi.Input<string>;
    }

    export interface DomainMappingStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusCondition>[]>;
        mappedRouteName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        resourceRecords?: pulumi.Input<pulumi.Input<inputs.cloudrun.DomainMappingStatusResourceRecord>[]>;
    }

    export interface DomainMappingStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DomainMappingStatusResourceRecord {
        name?: pulumi.Input<string>;
        rrdata?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface ServiceMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        generation?: pulumi.Input<number>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        namespace: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface ServiceSpec {
        containerConcurrency?: pulumi.Input<number>;
        containers: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceSpecContainer>[]>;
        servingState?: pulumi.Input<string>;
    }

    export interface ServiceSpecContainer {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        envs?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnv>[]>;
        envFroms?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnvFrom>[]>;
        image: pulumi.Input<string>;
        resources?: pulumi.Input<inputs.cloudrun.ServiceSpecContainerResources>;
        workingDir?: pulumi.Input<string>;
    }

    export interface ServiceSpecContainerEnv {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ServiceSpecContainerEnvFrom {
        configMapRef?: pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnvFromConfigMapRef>;
        prefix?: pulumi.Input<string>;
        secretRef?: pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnvFromSecretRef>;
    }

    export interface ServiceSpecContainerEnvFromConfigMapRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnvFromConfigMapRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name?: pulumi.Input<string>;
    }

    export interface ServiceSpecContainerEnvFromSecretRef {
        localObjectReference?: pulumi.Input<inputs.cloudrun.ServiceSpecContainerEnvFromSecretRefLocalObjectReference>;
        optional?: pulumi.Input<boolean>;
    }

    export interface ServiceSpecContainerEnvFromSecretRefLocalObjectReference {
        name?: pulumi.Input<string>;
    }

    export interface ServiceSpecContainerResources {
        limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ServiceStatus {
        conditions?: pulumi.Input<pulumi.Input<inputs.cloudrun.ServiceStatusCondition>[]>;
        latestCreatedRevisionName?: pulumi.Input<string>;
        latestReadyRevisionName?: pulumi.Input<string>;
        observedGeneration?: pulumi.Input<number>;
        url?: pulumi.Input<string>;
    }

    export interface ServiceStatusCondition {
        message?: pulumi.Input<string>;
        reason?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: pulumi.Input<inputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting>;
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        relativeUri: pulumi.Input<string>;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: pulumi.Input<string>;
        service?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface JobHttpTarget {
        body?: pulumi.Input<string>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        httpMethod?: pulumi.Input<string>;
        oauthToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOauthToken>;
        oidcToken?: pulumi.Input<inputs.cloudscheduler.JobHttpTargetOidcToken>;
        uri: pulumi.Input<string>;
    }

    export interface JobHttpTargetOauthToken {
        scope?: pulumi.Input<string>;
        serviceAccountEmail?: pulumi.Input<string>;
    }

    export interface JobHttpTargetOidcToken {
        audience?: pulumi.Input<string>;
        serviceAccountEmail?: pulumi.Input<string>;
    }

    export interface JobPubsubTarget {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        data?: pulumi.Input<string>;
        topicName: pulumi.Input<string>;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: pulumi.Input<string>;
        maxDoublings?: pulumi.Input<number>;
        maxRetryDuration?: pulumi.Input<string>;
        minBackoffDuration?: pulumi.Input<string>;
        retryCount?: pulumi.Input<number>;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri?: pulumi.Input<string>;
        dagGcsPrefix?: pulumi.Input<string>;
        gkeCluster?: pulumi.Input<string>;
        nodeConfig?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        privateEnvironmentConfig?: pulumi.Input<inputs.composer.EnvironmentConfigPrivateEnvironmentConfig>;
        softwareConfig?: pulumi.Input<inputs.composer.EnvironmentConfigSoftwareConfig>;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        ipAllocationPolicy?: pulumi.Input<inputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy>;
        machineType?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        serviceAccount?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        zone: pulumi.Input<string>;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        clusterSecondaryRangeName?: pulumi.Input<string>;
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        servicesSecondaryRangeName?: pulumi.Input<string>;
        useIpAliases?: pulumi.Input<boolean>;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        masterIpv4CidrBlock?: pulumi.Input<string>;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        envVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        imageVersion?: pulumi.Input<string>;
        pypiPackages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pythonVersion?: pulumi.Input<string>;
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.AutoscalarAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendServiceBackend {
        balancingMode?: pulumi.Input<string>;
        capacityScaler?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        group?: pulumi.Input<string>;
        maxConnections?: pulumi.Input<number>;
        maxConnectionsPerEndpoint?: pulumi.Input<number>;
        maxConnectionsPerInstance?: pulumi.Input<number>;
        maxRate?: pulumi.Input<number>;
        maxRatePerEndpoint?: pulumi.Input<number>;
        maxRatePerInstance?: pulumi.Input<number>;
        maxUtilization?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: pulumi.Input<inputs.compute.BackendServiceCdnPolicyCacheKeyPolicy>;
        signedUrlCacheMaxAgeSec?: pulumi.Input<number>;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: pulumi.Input<boolean>;
        includeProtocol?: pulumi.Input<boolean>;
        includeQueryString?: pulumi.Input<boolean>;
        queryStringBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: pulumi.Input<inputs.compute.BackendServiceCircuitBreakersConnectTimeout>;
        maxConnections?: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
        maxRequests?: pulumi.Input<number>;
        maxRequestsPerConnection?: pulumi.Input<number>;
        maxRetries?: pulumi.Input<number>;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookie>;
        httpHeaderName?: pulumi.Input<string>;
        minimumRingSize?: pulumi.Input<number>;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        ttl?: pulumi.Input<inputs.compute.BackendServiceConsistentHashHttpCookieTtl>;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceIap {
        oauth2ClientId: pulumi.Input<string>;
        oauth2ClientSecret: pulumi.Input<string>;
        oauth2ClientSecretSha256?: pulumi.Input<string>;
    }

    export interface BackendServiceLogConfig {
        enable?: pulumi.Input<boolean>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionBaseEjectionTime>;
        consecutiveErrors?: pulumi.Input<number>;
        consecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingConsecutiveErrors?: pulumi.Input<number>;
        enforcingConsecutiveGatewayFailure?: pulumi.Input<number>;
        enforcingSuccessRate?: pulumi.Input<number>;
        interval?: pulumi.Input<inputs.compute.BackendServiceOutlierDetectionInterval>;
        maxEjectionPercent?: pulumi.Input<number>;
        successRateMinimumHosts?: pulumi.Input<number>;
        successRateRequestVolume?: pulumi.Input<number>;
        successRateStdevFactor?: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface ExternalVpnGatewayInterface {
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface FirewallAllow {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface FirewallDeny {
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: pulumi.Input<pulumi.Input<inputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel>[]>;
        filterMatchCriteria: pulumi.Input<string>;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface HaVpnGatewayVpnInterface {
        id?: pulumi.Input<number>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface ImageGuestOsFeature {
        type?: pulumi.Input<string>;
    }

    export interface ImageRawDisk {
        containerType?: pulumi.Input<string>;
        sha1?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceAttachedDisk {
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceBootDisk {
        autoDelete?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        initializeParams?: pulumi.Input<inputs.compute.InstanceBootDiskInitializeParams>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface InstanceBootDiskInitializeParams {
        image?: pulumi.Input<string>;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels?: pulumi.Input<{[key: string]: any}>;
        size?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKeyRaw?: pulumi.Input<string>;
        diskEncryptionKeySha256?: pulumi.Input<string>;
        initializeParams?: pulumi.Input<inputs.compute.InstanceFromTemplateBootDiskInitializeParams>;
        kmsKeySelfLink?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: any}>;
        size?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceFromTemplateSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateScratchDisk {
        interface?: pulumi.Input<string>;
    }

    export interface InstanceFromTemplateServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        healthCheck: pulumi.Input<string>;
        initialDelaySec: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        maxSurgeFixed?: pulumi.Input<number>;
        maxSurgePercent?: pulumi.Input<number>;
        maxUnavailableFixed?: pulumi.Input<number>;
        maxUnavailablePercent?: pulumi.Input<number>;
        minReadySec?: pulumi.Input<number>;
        minimalAction: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface InstanceGroupManagerVersion {
        /**
         * ) The
         * full URL to an instance template from which all new instances
         * will be created. This field is only present in the `google` provider.
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: pulumi.Input<inputs.compute.InstanceGroupManagerVersionTargetSize>;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        fixed?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name of the instance group. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface InstanceGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetworkInterfaceAliasIpRange>[]>;
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
        publicPtrDomainName?: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceScratchDisk {
        interface?: pulumi.Input<string>;
    }

    export interface InstanceServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateDisk {
        autoDelete?: pulumi.Input<boolean>;
        boot?: pulumi.Input<boolean>;
        deviceName?: pulumi.Input<string>;
        diskEncryptionKey?: pulumi.Input<inputs.compute.InstanceTemplateDiskDiskEncryptionKey>;
        diskName?: pulumi.Input<string>;
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        interface?: pulumi.Input<string>;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        mode?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
        sourceImage?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        kmsKeySelfLink?: pulumi.Input<string>;
    }

    export interface InstanceTemplateGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterface {
        accessConfigs?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAccessConfig>[]>;
        aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange>[]>;
        network?: pulumi.Input<string>;
        networkIp?: pulumi.Input<string>;
        subnetwork?: pulumi.Input<string>;
        subnetworkProject?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        natIp?: pulumi.Input<string>;
        networkTier?: pulumi.Input<string>;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: pulumi.Input<string>;
        subnetworkRangeName?: pulumi.Input<string>;
    }

    export interface InstanceTemplateScheduling {
        automaticRestart?: pulumi.Input<boolean>;
        nodeAffinities?: pulumi.Input<pulumi.Input<inputs.compute.InstanceTemplateSchedulingNodeAffinity>[]>;
        onHostMaintenance?: pulumi.Input<string>;
        preemptible?: pulumi.Input<boolean>;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        key: pulumi.Input<string>;
        operator: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateServiceAccount {
        email?: pulumi.Input<string>;
        scopes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: pulumi.Input<boolean>;
        enableSecureBoot?: pulumi.Input<boolean>;
        enableVtpm?: pulumi.Input<boolean>;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q?: pulumi.Input<number>;
    }

    export interface ManagedSslCertificateManaged {
        domains: pulumi.Input<string>;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: pulumi.Input<string>;
        localSsd?: pulumi.Input<string>;
        memory?: pulumi.Input<string>;
    }

    export interface NodeTemplateServerBinding {
        type: pulumi.Input<string>;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: pulumi.Input<number>;
        cpuUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization>;
        loadBalancingUtilization?: pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization>;
        maxReplicas: pulumi.Input<number>;
        metrics?: pulumi.Input<pulumi.Input<inputs.compute.RegionAutoscalerAutoscalingPolicyMetric>[]>;
        minReplicas: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: pulumi.Input<number>;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        singleInstanceAssignment?: pulumi.Input<number>;
        target?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceBackend {
        description?: pulumi.Input<string>;
        failover?: pulumi.Input<boolean>;
        group?: pulumi.Input<string>;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: pulumi.Input<boolean>;
        dropTrafficIfUnhealthy?: pulumi.Input<boolean>;
        failoverRatio?: pulumi.Input<number>;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: pulumi.Input<string>;
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        requestPath?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: pulumi.Input<number>;
        portName?: pulumi.Input<string>;
        portSpecification?: pulumi.Input<string>;
        proxyHeader?: pulumi.Input<string>;
        request?: pulumi.Input<string>;
        response?: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        healthCheck: pulumi.Input<string>;
        initialDelaySec: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        instanceRedistributionType?: pulumi.Input<string>;
        maxSurgeFixed?: pulumi.Input<number>;
        maxSurgePercent?: pulumi.Input<number>;
        maxUnavailableFixed?: pulumi.Input<number>;
        maxUnavailablePercent?: pulumi.Input<number>;
        minReadySec?: pulumi.Input<number>;
        minimalAction: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface RegionInstanceGroupManagerVersion {
        /**
         * ) The full URL to an instance template from
         * which all new instances will be created. This field is only present in the
         * `google` provider.
         */
        instanceTemplate: pulumi.Input<string>;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: pulumi.Input<string>;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: pulumi.Input<inputs.compute.RegionInstanceGroupManagerVersionTargetSize>;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        fixed?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface RegionUrlMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.RegionUrlMapPathMatcherPathRule>[]>;
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        service: pulumi.Input<string>;
    }

    export interface RegionUrlMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservation {
        count: pulumi.Input<number>;
        inUseCount?: pulumi.Input<number>;
        instanceProperties: pulumi.Input<inputs.compute.ReservationSpecificReservationInstanceProperties>;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator>[]>;
        localSsds?: pulumi.Input<pulumi.Input<inputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd>[]>;
        machineType: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: pulumi.Input<number>;
        interface?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy>;
        schedule: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySchedule>;
        snapshotProperties?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: pulumi.Input<number>;
        onSourceDiskDelete?: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule>;
        hourlySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule>;
        weeklySchedule?: pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: pulumi.Input<number>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: pulumi.Input<pulumi.Input<inputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek>[]>;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: pulumi.Input<boolean>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        storageLocations?: pulumi.Input<string>;
    }

    export interface RouterBgp {
        advertiseMode?: pulumi.Input<string>;
        advertisedGroups?: pulumi.Input<pulumi.Input<string>[]>;
        advertisedIpRanges?: pulumi.Input<pulumi.Input<inputs.compute.RouterBgpAdvertisedIpRange>[]>;
        asn: pulumi.Input<number>;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range?: pulumi.Input<string>;
    }

    export interface RouterNatLogConfig {
        enable: pulumi.Input<boolean>;
        filter: pulumi.Input<string>;
    }

    export interface RouterNatSubnetwork {
        name: pulumi.Input<string>;
        secondaryIpRangeNames?: pulumi.Input<pulumi.Input<string>[]>;
        sourceIpRangesToNats: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: pulumi.Input<string>;
        range?: pulumi.Input<string>;
    }

    export interface SecurityPolicyRule {
        action: pulumi.Input<string>;
        /**
         * An optional description of this security policy. Max size is 2048.
         */
        description?: pulumi.Input<string>;
        match: pulumi.Input<inputs.compute.SecurityPolicyRuleMatch>;
        preview?: pulumi.Input<boolean>;
        priority: pulumi.Input<number>;
    }

    export interface SecurityPolicyRuleMatch {
        config: pulumi.Input<inputs.compute.SecurityPolicyRuleMatchConfig>;
        versionedExpr: pulumi.Input<string>;
    }

    export interface SecurityPolicyRuleMatchConfig {
        srcIpRanges: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationCustomAccount>;
        googleAccount?: pulumi.Input<inputs.compute.SecurityScanConfigAuthenticationGoogleAccount>;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: pulumi.Input<string>;
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: pulumi.Input<number>;
        scheduleTime?: pulumi.Input<string>;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey?: pulumi.Input<string>;
        sha256?: pulumi.Input<string>;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: pulumi.Input<string>;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: pulumi.Input<string>;
        flowSampling?: pulumi.Input<number>;
        metadata?: pulumi.Input<string>;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: pulumi.Input<string>;
        rangeName: pulumi.Input<string>;
    }

    export interface URLMapHostRule {
        description?: pulumi.Input<string>;
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        pathMatcher: pulumi.Input<string>;
    }

    export interface URLMapPathMatcher {
        defaultService: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        pathRules?: pulumi.Input<pulumi.Input<inputs.compute.URLMapPathMatcherPathRule>[]>;
    }

    export interface URLMapPathMatcherPathRule {
        paths: pulumi.Input<pulumi.Input<string>[]>;
        service: pulumi.Input<string>;
    }

    export interface URLMapTest {
        description?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        path: pulumi.Input<string>;
        service: pulumi.Input<string>;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        cloudrunConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigCloudrunConfig>;
        horizontalPodAutoscaling?: pulumi.Input<inputs.container.ClusterAddonsConfigHorizontalPodAutoscaling>;
        httpLoadBalancing?: pulumi.Input<inputs.container.ClusterAddonsConfigHttpLoadBalancing>;
        istioConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigIstioConfig>;
        kubernetesDashboard?: pulumi.Input<inputs.container.ClusterAddonsConfigKubernetesDashboard>;
        networkPolicyConfig?: pulumi.Input<inputs.container.ClusterAddonsConfigNetworkPolicyConfig>;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigIstioConfig {
        auth?: pulumi.Input<string>;
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigKubernetesDashboard {
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        disabled?: pulumi.Input<boolean>;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        securityGroup: pulumi.Input<string>;
    }

    export interface ClusterClusterAutoscaling {
        enabled: pulumi.Input<boolean>;
        resourceLimits?: pulumi.Input<pulumi.Input<inputs.container.ClusterClusterAutoscalingResourceLimit>[]>;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        maximum?: pulumi.Input<number>;
        minimum?: pulumi.Input<number>;
        resourceType: pulumi.Input<string>;
    }

    export interface ClusterDatabaseEncryption {
        keyName?: pulumi.Input<string>;
        state: pulumi.Input<string>;
    }

    export interface ClusterIpAllocationPolicy {
        clusterIpv4CidrBlock?: pulumi.Input<string>;
        clusterSecondaryRangeName?: pulumi.Input<string>;
        createSubnetwork?: pulumi.Input<boolean>;
        nodeIpv4CidrBlock?: pulumi.Input<string>;
        servicesIpv4CidrBlock?: pulumi.Input<string>;
        servicesSecondaryRangeName?: pulumi.Input<string>;
        subnetworkName?: pulumi.Input<string>;
        useIpAliases?: pulumi.Input<boolean>;
    }

    export interface ClusterMaintenancePolicy {
        dailyMaintenanceWindow: pulumi.Input<inputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow>;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration?: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface ClusterMasterAuth {
        clientCertificate?: pulumi.Input<string>;
        clientCertificateConfig?: pulumi.Input<inputs.container.ClusterMasterAuthClientCertificateConfig>;
        clientKey?: pulumi.Input<string>;
        clusterCaCertificate?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: pulumi.Input<boolean>;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        cidrBlocks?: pulumi.Input<pulumi.Input<inputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock>[]>;
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: pulumi.Input<string>;
        displayName?: pulumi.Input<string>;
    }

    export interface ClusterNetworkPolicy {
        enabled?: pulumi.Input<boolean>;
        provider?: pulumi.Input<string>;
    }

    export interface ClusterNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterNodePool {
        autoscaling?: pulumi.Input<inputs.container.ClusterNodePoolAutoscaling>;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount?: pulumi.Input<number>;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls?: pulumi.Input<pulumi.Input<string>[]>;
        management?: pulumi.Input<inputs.container.ClusterNodePoolManagement>;
        maxPodsPerNode?: pulumi.Input<number>;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name?: pulumi.Input<string>;
        namePrefix?: pulumi.Input<string>;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfig>;
        nodeCount?: pulumi.Input<number>;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations?: pulumi.Input<pulumi.Input<string>[]>;
        version?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: pulumi.Input<number>;
        minNodeCount: pulumi.Input<number>;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: pulumi.Input<boolean>;
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface ClusterNodePoolNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.ClusterNodePoolNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }

    export interface ClusterPodSecurityPolicyConfig {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterPrivateClusterConfig {
        enablePrivateEndpoint?: pulumi.Input<boolean>;
        enablePrivateNodes?: pulumi.Input<boolean>;
        masterIpv4CidrBlock?: pulumi.Input<string>;
        privateEndpoint?: pulumi.Input<string>;
        publicEndpoint?: pulumi.Input<string>;
    }

    export interface ClusterResourceUsageExportConfig {
        bigqueryDestination: pulumi.Input<inputs.container.ClusterResourceUsageExportConfigBigqueryDestination>;
        enableNetworkEgressMetering?: pulumi.Input<boolean>;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: pulumi.Input<string>;
    }

    export interface ClusterVerticalPodAutoscaling {
        enabled?: pulumi.Input<boolean>;
    }

    export interface ClusterWorkloadIdentityConfig {
        identityNamespace: pulumi.Input<string>;
    }

    export interface NodePoolAutoscaling {
        maxNodeCount: pulumi.Input<number>;
        minNodeCount: pulumi.Input<number>;
    }

    export interface NodePoolManagement {
        autoRepair?: pulumi.Input<boolean>;
        autoUpgrade?: pulumi.Input<boolean>;
    }

    export interface NodePoolNodeConfig {
        diskSizeGb?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        guestAccelerators?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigGuestAccelerator>[]>;
        imageType?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        localSsdCount?: pulumi.Input<number>;
        machineType?: pulumi.Input<string>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        minCpuPlatform?: pulumi.Input<string>;
        oauthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        preemptible?: pulumi.Input<boolean>;
        sandboxConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigSandboxConfig>;
        serviceAccount?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        taints?: pulumi.Input<pulumi.Input<inputs.container.NodePoolNodeConfigTaint>[]>;
        workloadMetadataConfig?: pulumi.Input<inputs.container.NodePoolNodeConfigWorkloadMetadataConfig>;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: pulumi.Input<string>;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: pulumi.Input<inputs.containeranalysis.NoteAttestationAuthorityHint>;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: pulumi.Input<string>;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: pulumi.Input<string>;
        yarnConfig: pulumi.Input<inputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig>;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: pulumi.Input<string>;
        scaleDownFactor: pulumi.Input<number>;
        scaleDownMinWorkerFraction?: pulumi.Input<number>;
        scaleUpFactor: pulumi.Input<number>;
        scaleUpMinWorkerFraction?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: pulumi.Input<number>;
        minInstances?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfig {
        autoscalingConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigAutoscalingConfig>;
        bucket?: pulumi.Input<string>;
        encryptionConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigEncryptionConfig>;
        gceClusterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigGceClusterConfig>;
        initializationActions?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigInitializationAction>[]>;
        masterConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfig>;
        preemptibleWorkerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig>;
        softwareConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigSoftwareConfig>;
        stagingBucket?: pulumi.Input<string>;
        workerConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfig>;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        policyUri?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        kmsKeyName: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        internalIpOnly?: pulumi.Input<boolean>;
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        network?: pulumi.Input<string>;
        serviceAccount?: pulumi.Input<string>;
        serviceAccountScopes?: pulumi.Input<pulumi.Input<string>[]>;
        subnetwork?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        zone?: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: pulumi.Input<string>;
        timeoutSec?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMasterConfig {
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigAccelerator>[]>;
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig>;
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        machineType?: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        imageVersion?: pulumi.Input<string>;
        optionalComponents?: pulumi.Input<pulumi.Input<string>[]>;
        overrideProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        properties?: pulumi.Input<{[key: string]: any}>;
    }

    export interface ClusterClusterConfigWorkerConfig {
        accelerators?: pulumi.Input<pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator>[]>;
        diskConfig?: pulumi.Input<inputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig>;
        imageUri?: pulumi.Input<string>;
        instanceNames?: pulumi.Input<pulumi.Input<string>[]>;
        machineType?: pulumi.Input<string>;
        minCpuPlatform?: pulumi.Input<string>;
        numInstances?: pulumi.Input<number>;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        acceleratorCount: pulumi.Input<number>;
        acceleratorType: pulumi.Input<string>;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        bootDiskSizeGb?: pulumi.Input<number>;
        bootDiskType?: pulumi.Input<string>;
        numLocalSsds?: pulumi.Input<number>;
    }

    export interface JobHadoopConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobHadoopConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        mainJarFileUri?: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobHiveConfig {
        continueOnFailure?: pulumi.Input<boolean>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPigConfig {
        continueOnFailure?: pulumi.Input<boolean>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPigConfigLoggingConfig>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobPlacement {
        clusterName: pulumi.Input<string>;
        clusterUuid?: pulumi.Input<string>;
    }

    export interface JobPysparkConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobPysparkConfigLoggingConfig>;
        mainPythonFileUri: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pythonFileUris?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobReference {
        jobId?: pulumi.Input<string>;
    }

    export interface JobScheduling {
        maxFailuresPerHour?: pulumi.Input<number>;
    }

    export interface JobSparkConfig {
        archiveUris?: pulumi.Input<pulumi.Input<string>[]>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        fileUris?: pulumi.Input<pulumi.Input<string>[]>;
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparkConfigLoggingConfig>;
        mainClass?: pulumi.Input<string>;
        mainJarFileUri?: pulumi.Input<string>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfig {
        jarFileUris?: pulumi.Input<pulumi.Input<string>[]>;
        loggingConfig?: pulumi.Input<inputs.dataproc.JobSparksqlConfigLoggingConfig>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        queryFileUri?: pulumi.Input<string>;
        queryLists?: pulumi.Input<pulumi.Input<string>[]>;
        scriptVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface JobStatus {
        details?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
        stateStartTime?: pulumi.Input<string>;
        substate?: pulumi.Input<string>;
    }
}

export namespace dns {
    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneDnssecConfigDefaultKeySpec>[]>;
        kind?: pulumi.Input<string>;
        nonExistence?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: pulumi.Input<string>;
        keyLength?: pulumi.Input<number>;
        keyType?: pulumi.Input<string>;
        kind?: pulumi.Input<string>;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZoneForwardingConfigTargetNameServer>[]>;
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        ipv4Address?: pulumi.Input<string>;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork?: pulumi.Input<inputs.dns.ManagedZonePeeringConfigTargetNetwork>;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl?: pulumi.Input<string>;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks?: pulumi.Input<pulumi.Input<inputs.dns.ManagedZonePrivateVisibilityConfigNetwork>[]>;
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl?: pulumi.Input<string>;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers?: pulumi.Input<pulumi.Input<inputs.dns.PolicyAlternativeNameServerConfigTargetNameServer>[]>;
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address?: pulumi.Input<string>;
    }

    export interface PolicyNetwork {
        networkUrl?: pulumi.Input<string>;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods?: pulumi.Input<pulumi.Input<inputs.endpoints.ServiceApiMethod>[]>;
        name?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface ServiceApiMethod {
        name?: pulumi.Input<string>;
        requestType?: pulumi.Input<string>;
        responseType?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
    }

    export interface ServiceEndpoint {
        address?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: pulumi.Input<number>;
        name: pulumi.Input<string>;
    }

    export interface InstanceNetwork {
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        modes: pulumi.Input<pulumi.Input<string>[]>;
        network: pulumi.Input<string>;
        reservedIpRange?: pulumi.Input<string>;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: pulumi.Input<string>;
        fieldPath?: pulumi.Input<string>;
        order?: pulumi.Input<string>;
    }
}

export namespace folder {
    export interface OrganizationPolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.folder.OrganizationPolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace healthcare {
    export interface DicomStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: pulumi.Input<string>;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: pulumi.Input<boolean>;
        segmentTerminator?: pulumi.Input<string>;
    }
}

export namespace kms {
    export interface CryptoKeyVersionTemplate {
        algorithm: pulumi.Input<string>;
        protectionLevel?: pulumi.Input<string>;
    }

    export interface GetKMSCryptoKeyVersionPublicKey {
        /**
         * The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
         */
        algorithm?: string;
        /**
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem?: string;
    }

    export interface RegistryCredential {
        publicKeyCertificate?: pulumi.Input<inputs.kms.RegistryCredentialPublicKeyCertificate>;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        certificate: pulumi.Input<string>;
        format: pulumi.Input<string>;
    }

    export interface RegistryEventNotificationConfig {
        pubsubTopicName: pulumi.Input<string>;
    }

    export interface RegistryEventNotificationConfigItem {
        pubsubTopicName: pulumi.Input<string>;
        subfolderMatches?: pulumi.Input<string>;
    }

    export interface RegistryHttpConfig {
        httpEnabledState: pulumi.Input<string>;
    }

    export interface RegistryMqttConfig {
        mqttEnabledState: pulumi.Input<string>;
    }

    export interface RegistryStateNotificationConfig {
        pubsubTopicName: pulumi.Input<string>;
    }
}

export namespace logging {
    export interface MetricBucketOptions {
        explicitBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExplicitBuckets>;
        exponentialBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsExponentialBuckets>;
        linearBuckets?: pulumi.Input<inputs.logging.MetricBucketOptionsLinearBuckets>;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: pulumi.Input<number>;
        numFiniteBuckets?: pulumi.Input<number>;
        scale?: pulumi.Input<number>;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: pulumi.Input<number>;
        offset?: pulumi.Input<number>;
        width?: pulumi.Input<number>;
    }

    export interface MetricMetricDescriptor {
        labels?: pulumi.Input<pulumi.Input<inputs.logging.MetricMetricDescriptorLabel>[]>;
        metricKind: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
        valueType: pulumi.Input<string>;
    }

    export interface MetricMetricDescriptorLabel {
        description?: pulumi.Input<string>;
        key: pulumi.Input<string>;
        valueType?: pulumi.Input<string>;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name?: pulumi.Input<string>;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsent>;
        conditionThreshold?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThreshold>;
        displayName: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentAggregation>[]>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionAbsentTrigger>;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdAggregation>[]>;
        comparison: pulumi.Input<string>;
        denominatorAggregations?: pulumi.Input<pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation>[]>;
        denominatorFilter?: pulumi.Input<string>;
        duration: pulumi.Input<string>;
        filter?: pulumi.Input<string>;
        thresholdValue?: pulumi.Input<number>;
        trigger?: pulumi.Input<inputs.monitoring.AlertPolicyConditionConditionThresholdTrigger>;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: pulumi.Input<string>;
        crossSeriesReducer?: pulumi.Input<string>;
        groupByFields?: pulumi.Input<pulumi.Input<string>[]>;
        perSeriesAligner?: pulumi.Input<string>;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: pulumi.Input<number>;
        percent?: pulumi.Input<number>;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime?: pulumi.Input<string>;
        mutatedBy?: pulumi.Input<string>;
    }

    export interface AlertPolicyDocumentation {
        content?: pulumi.Input<string>;
        mimeType?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigContentMatcher {
        content?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: pulumi.Input<inputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo>;
        headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        maskHeaders?: pulumi.Input<boolean>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        useSsl?: pulumi.Input<boolean>;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigInternalChecker {
        displayName?: pulumi.Input<string>;
        gcpZone?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        peerProjectId?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        type: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: pulumi.Input<string>;
        resourceType?: pulumi.Input<string>;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: pulumi.Input<number>;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: inputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface PolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface PolicyListPolicy {
        allow?: pulumi.Input<inputs.organizations.PolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.organizations.PolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface PolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace projects {
    export interface IAMAuditConfigAuditLogConfig {
        exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
        logType: pulumi.Input<string>;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: pulumi.Input<boolean>;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyAllow>;
        deny?: pulumi.Input<inputs.projects.OrganizationPolicyListPolicyDeny>;
        inheritFromParent?: pulumi.Input<boolean>;
        suggestedValue?: pulumi.Input<string>;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: pulumi.Input<boolean>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OrganizationPolicyRestorePolicy {
        default: pulumi.Input<boolean>;
    }
}

export namespace pubsub {
    export interface SubscriptionExpirationPolicy {
        ttl?: pulumi.Input<string>;
    }

    export interface SubscriptionPushConfig {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pushEndpoint: pulumi.Input<string>;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress?: pulumi.Input<string>;
        timeToRetire?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        caCertificate?: pulumi.Input<string>;
        clientCertificate?: pulumi.Input<string>;
        clientKey?: pulumi.Input<string>;
        connectRetryInterval?: pulumi.Input<number>;
        dumpFilePath?: pulumi.Input<string>;
        failoverTarget?: pulumi.Input<boolean>;
        masterHeartbeatPeriod?: pulumi.Input<number>;
        password?: pulumi.Input<string>;
        sslCipher?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        verifyServerCertificate?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceServerCaCert {
        cert?: pulumi.Input<string>;
        commonName?: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        expirationTime?: pulumi.Input<string>;
        sha1Fingerprint?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettings {
        activationPolicy?: pulumi.Input<string>;
        authorizedGaeApplications?: pulumi.Input<pulumi.Input<string>[]>;
        availabilityType?: pulumi.Input<string>;
        backupConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsBackupConfiguration>;
        crashSafeReplication?: pulumi.Input<boolean>;
        databaseFlags?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsDatabaseFlag>[]>;
        diskAutoresize?: pulumi.Input<boolean>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        ipConfiguration?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfiguration>;
        locationPreference?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsLocationPreference>;
        maintenanceWindow?: pulumi.Input<inputs.sql.DatabaseInstanceSettingsMaintenanceWindow>;
        pricingPlan?: pulumi.Input<string>;
        replicationType?: pulumi.Input<string>;
        tier: pulumi.Input<string>;
        userLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        version?: pulumi.Input<number>;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        binaryLogEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        startTime?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: pulumi.Input<pulumi.Input<inputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork>[]>;
        ipv4Enabled?: pulumi.Input<boolean>;
        privateNetwork?: pulumi.Input<string>;
        requireSsl?: pulumi.Input<boolean>;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        expirationTime?: pulumi.Input<string>;
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        followGaeApplication?: pulumi.Input<string>;
        zone?: pulumi.Input<string>;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        day?: pulumi.Input<number>;
        hour?: pulumi.Input<number>;
        updateTrack?: pulumi.Input<string>;
    }
}

export namespace storage {
    export interface BucketCor {
        maxAgeSeconds?: pulumi.Input<number>;
        methods?: pulumi.Input<pulumi.Input<string>[]>;
        origins?: pulumi.Input<pulumi.Input<string>[]>;
        responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BucketEncryption {
        defaultKmsKeyName: pulumi.Input<string>;
    }

    export interface BucketLifecycleRule {
        action: pulumi.Input<inputs.storage.BucketLifecycleRuleAction>;
        condition: pulumi.Input<inputs.storage.BucketLifecycleRuleCondition>;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of the new bucket. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface BucketLifecycleRuleCondition {
        age?: pulumi.Input<number>;
        createdBefore?: pulumi.Input<string>;
        isLive?: pulumi.Input<boolean>;
        matchesStorageClasses?: pulumi.Input<pulumi.Input<string>[]>;
        numNewerVersions?: pulumi.Input<number>;
        withState?: pulumi.Input<string>;
    }

    export interface BucketLogging {
        logBucket: pulumi.Input<string>;
        logObjectPrefix?: pulumi.Input<string>;
    }

    export interface BucketRetentionPolicy {
        isLocked?: pulumi.Input<boolean>;
        retentionPeriod: pulumi.Input<number>;
    }

    export interface BucketVersioning {
        enabled?: pulumi.Input<boolean>;
    }

    export interface BucketWebsite {
        mainPageSuffix?: pulumi.Input<string>;
        notFoundPage?: pulumi.Input<string>;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: pulumi.Input<string>;
        team?: pulumi.Input<string>;
    }

    export interface TransferJobSchedule {
        scheduleEndDate?: pulumi.Input<inputs.storage.TransferJobScheduleScheduleEndDate>;
        scheduleStartDate: pulumi.Input<inputs.storage.TransferJobScheduleScheduleStartDate>;
        startTimeOfDay?: pulumi.Input<inputs.storage.TransferJobScheduleStartTimeOfDay>;
    }

    export interface TransferJobScheduleScheduleEndDate {
        day: pulumi.Input<number>;
        month: pulumi.Input<number>;
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleScheduleStartDate {
        day: pulumi.Input<number>;
        month: pulumi.Input<number>;
        year: pulumi.Input<number>;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        hours: pulumi.Input<number>;
        minutes: pulumi.Input<number>;
        nanos: pulumi.Input<number>;
        seconds: pulumi.Input<number>;
    }

    export interface TransferJobTransferSpec {
        awsS3DataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSource>;
        gcsDataSink?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSink>;
        gcsDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecGcsDataSource>;
        httpDataSource?: pulumi.Input<inputs.storage.TransferJobTransferSpecHttpDataSource>;
        objectConditions?: pulumi.Input<inputs.storage.TransferJobTransferSpecObjectConditions>;
        transferOptions?: pulumi.Input<inputs.storage.TransferJobTransferSpecTransferOptions>;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        awsAccessKey: pulumi.Input<inputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey>;
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        accessKeyId: pulumi.Input<string>;
        secretAccessKey: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        bucketName: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        listUrl: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecObjectConditions {
        excludePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        includePrefixes?: pulumi.Input<pulumi.Input<string>[]>;
        maxTimeElapsedSinceLastModification?: pulumi.Input<string>;
        minTimeElapsedSinceLastModification?: pulumi.Input<string>;
    }

    export interface TransferJobTransferSpecTransferOptions {
        deleteObjectsFromSourceAfterTransfer?: pulumi.Input<boolean>;
        deleteObjectsUniqueInSink?: pulumi.Input<boolean>;
        overwriteObjectsAlreadyExistingInSink?: pulumi.Input<boolean>;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface NodeSchedulingConfig {
        preemptible?: pulumi.Input<boolean>;
    }
}
