// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";


export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: string;
        conditions: outputs.accesscontextmanager.AccessLevelBasicCondition[];
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy;
        ipSubnetworks?: string[];
        members?: string[];
        negate?: boolean;
        requiredAccessLevels?: string[];
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: string[];
        allowedEncryptionStatuses?: string[];
        osConstraints?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint[];
        requireScreenLock?: boolean;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: string;
        osType?: string;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: string[];
        resources?: string[];
        restrictedServices?: string[];
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks?: boolean;
    }

    export interface ApplicationUrlDispatchRule {
        domain: string;
        path: string;
        service: string;
    }

    export interface DomainMappingResourceRecord {
        name?: string;
        rrdata?: string;
        type?: string;
    }

    export interface DomainMappingSslSettings {
        certificateId?: string;
        pendingManagedCertificateId: string;
        sslManagementType?: string;
    }

    export interface StandardAppVersionDeployment {
        files?: outputs.appengine.StandardAppVersionDeploymentFile[];
        zip?: outputs.appengine.StandardAppVersionDeploymentZip;
    }

    export interface StandardAppVersionDeploymentFile {
        name: string;
        sha1Sum?: string;
        sourceUrl?: string;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: number;
        sourceUrl?: string;
    }

    export interface StandardAppVersionEntrypoint {
        shell?: string;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: string;
        login?: string;
        redirectHttpResponseCode?: string;
        script?: outputs.appengine.StandardAppVersionHandlerScript;
        securityLevel?: string;
        staticFiles?: outputs.appengine.StandardAppVersionHandlerStaticFiles;
        urlRegex?: string;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath?: string;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: boolean;
        expiration?: string;
        httpHeaders?: {[key: string]: string};
        mimeType?: string;
        path?: string;
        requireMatchingFile?: boolean;
        uploadPathRegex?: string;
    }

    export interface StandardAppVersionLibrary {
        name?: string;
        version?: string;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: boolean;
        clusterId?: string;
    }

    export interface DatasetAccess {
        domain?: string;
        groupByEmail?: string;
        role?: string;
        specialGroup?: string;
        userByEmail?: string;
        view?: outputs.bigquery.DatasetAccessView;
    }

    export interface DatasetAccessView {
        datasetId: string;
        projectId: string;
        tableId: string;
    }

    export interface TableExternalDataConfiguration {
        autodetect: boolean;
        compression?: string;
        csvOptions?: outputs.bigquery.TableExternalDataConfigurationCsvOptions;
        googleSheetsOptions?: outputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions;
        ignoreUnknownValues?: boolean;
        maxBadRecords?: number;
        sourceFormat: string;
        sourceUris: string[];
    }

    export interface TableExternalDataConfigurationCsvOptions {
        allowJaggedRows?: boolean;
        allowQuotedNewlines?: boolean;
        encoding?: string;
        fieldDelimiter?: string;
        quote: string;
        skipLeadingRows?: number;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        range?: string;
        skipLeadingRows?: number;
    }

    export interface TableTimePartitioning {
        expirationMs?: number;
        field?: string;
        requirePartitionFilter?: boolean;
        /**
         * Describes the table type.
         */
        type: string;
    }

    export interface TableView {
        query: string;
        useLegacySql?: boolean;
    }
}

export namespace bigtable {
    export interface InstanceCluster {
        clusterId: string;
        numNodes?: number;
        storageType?: string;
        zone: string;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: string;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail: string;
        noteReference: string;
        publicKeys?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey[];
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: string;
        comment?: string;
        id: string;
        pkixPublicKey?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: string;
        signatureAlgorithm?: string;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern?: string;
    }

    export interface PolicyClusterAdmissionRule {
        cluster: string;
        enforcementMode?: string;
        evaluationMode?: string;
        requireAttestationsBies?: string[];
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: string[];
        steps?: outputs.cloudbuild.TriggerBuildStep[];
        tags?: string[];
    }

    export interface TriggerBuildStep {
        args?: string[];
        dir?: string;
        entrypoint?: string;
        envs?: string[];
        id?: string;
        name?: string;
        secretEnvs?: string[];
        timeout?: string;
        timing?: string;
        volumes?: outputs.cloudbuild.TriggerBuildStepVolume[];
        waitFors?: string[];
    }

    export interface TriggerBuildStepVolume {
        name?: string;
        path?: string;
    }

    export interface TriggerTriggerTemplate {
        branchName?: string;
        commitSha?: string;
        dir?: string;
        projectId: string;
        repoName?: string;
        tagName?: string;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        eventType: string;
        failurePolicy: outputs.cloudfunctions.FunctionEventTriggerFailurePolicy;
        resource: string;
    }

    export interface FunctionEventTriggerFailurePolicy {
        retry: boolean;
    }

    export interface FunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }

    export interface GetFunctionEventTrigger {
        /**
         * The type of event being observed. For example: `"providers/cloud.storage/eventTypes/object.change"`
         * and `"providers/cloud.pubsub/eventTypes/topic.publish"`. See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/)
         * for a full reference.
         */
        eventType: string;
        /**
         * Policy for failed executions. Structure is documented below.
         */
        failurePolicies: outputs.cloudfunctions.GetFunctionEventTriggerFailurePolicy[];
        /**
         * The name of the resource whose events are being observed, for example, `"myBucket"`
         */
        resource: string;
    }

    export interface GetFunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure.
         */
        retry: boolean;
    }

    export interface GetFunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface DomainMappingSpec {
        certificateMode?: string;
        forceOverride?: boolean;
        routeName: string;
    }

    export interface DomainMappingStatus {
        conditions: outputs.cloudrun.DomainMappingStatusCondition[];
        mappedRouteName: string;
        observedGeneration: number;
        resourceRecords?: outputs.cloudrun.DomainMappingStatusResourceRecord[];
    }

    export interface DomainMappingStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface DomainMappingStatusResourceRecord {
        name: string;
        rrdata?: string;
        type?: string;
    }

    export interface ServiceMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceSpec {
        containerConcurrency?: number;
        containers: outputs.cloudrun.ServiceSpecContainer[];
        servingState: string;
    }

    export interface ServiceSpecContainer {
        args?: string[];
        commands?: string[];
        envs?: outputs.cloudrun.ServiceSpecContainerEnv[];
        envFroms?: outputs.cloudrun.ServiceSpecContainerEnvFrom[];
        image: string;
        resources?: outputs.cloudrun.ServiceSpecContainerResources;
        workingDir?: string;
    }

    export interface ServiceSpecContainerEnv {
        name?: string;
        value?: string;
    }

    export interface ServiceSpecContainerEnvFrom {
        configMapRef?: outputs.cloudrun.ServiceSpecContainerEnvFromConfigMapRef;
        prefix?: string;
        secretRef?: outputs.cloudrun.ServiceSpecContainerEnvFromSecretRef;
    }

    export interface ServiceSpecContainerEnvFromConfigMapRef {
        localObjectReference?: outputs.cloudrun.ServiceSpecContainerEnvFromConfigMapRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name?: string;
    }

    export interface ServiceSpecContainerEnvFromSecretRef {
        localObjectReference?: outputs.cloudrun.ServiceSpecContainerEnvFromSecretRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceSpecContainerEnvFromSecretRefLocalObjectReference {
        name?: string;
    }

    export interface ServiceSpecContainerResources {
        limits?: {[key: string]: string};
        requests?: {[key: string]: string};
    }

    export interface ServiceStatus {
        conditions: outputs.cloudrun.ServiceStatusCondition[];
        latestCreatedRevisionName: string;
        latestReadyRevisionName: string;
        observedGeneration: number;
        url: string;
    }

    export interface ServiceStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: outputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting;
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        relativeUri: string;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface JobHttpTarget {
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        oauthToken?: outputs.cloudscheduler.JobHttpTargetOauthToken;
        oidcToken?: outputs.cloudscheduler.JobHttpTargetOidcToken;
        uri: string;
    }

    export interface JobHttpTargetOauthToken {
        scope?: string;
        serviceAccountEmail?: string;
    }

    export interface JobHttpTargetOidcToken {
        audience?: string;
        serviceAccountEmail?: string;
    }

    export interface JobPubsubTarget {
        attributes?: {[key: string]: string};
        data?: string;
        topicName: string;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: string;
        maxDoublings?: number;
        maxRetryDuration?: string;
        minBackoffDuration?: string;
        retryCount?: number;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri: string;
        dagGcsPrefix: string;
        gkeCluster: string;
        nodeConfig: outputs.composer.EnvironmentConfigNodeConfig;
        nodeCount: number;
        privateEnvironmentConfig: outputs.composer.EnvironmentConfigPrivateEnvironmentConfig;
        softwareConfig: outputs.composer.EnvironmentConfigSoftwareConfig;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb: number;
        ipAllocationPolicy: outputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy;
        machineType: string;
        network: string;
        oauthScopes: string[];
        serviceAccount: string;
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: string;
        clusterSecondaryRangeName?: string;
        servicesIpv4CidrBlock?: string;
        servicesSecondaryRangeName?: string;
        useIpAliases?: boolean;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: boolean;
        masterIpv4CidrBlock?: string;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: {[key: string]: string};
        envVariables?: {[key: string]: string};
        imageVersion: string;
        pypiPackages?: {[key: string]: string};
        pythonVersion: string;
    }

    export interface GetImageVersionsImageVersion {
        /**
         * The string identifier of the image version, in the form: "composer-x.y.z-airflow-a.b(.c)"
         */
        imageVersionId: string;
        /**
         * Supported python versions for this image version
         */
        supportedPythonVersions: string[];
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.AutoscalarAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.AutoscalarAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec?: number;
    }

    export interface BackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        group?: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: outputs.compute.BackendServiceCdnPolicyCacheKeyPolicy;
        signedUrlCacheMaxAgeSec?: number;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: boolean;
        includeProtocol?: boolean;
        includeQueryString?: boolean;
        queryStringBlacklists?: string[];
        queryStringWhitelists?: string[];
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.BackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: outputs.compute.BackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.BackendServiceConsistentHashHttpCookieTtl;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface BackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.BackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.BackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface ExternalVpnGatewayInterface {
        id?: number;
        ipAddress?: string;
    }

    export interface FirewallAllow {
        ports?: string[];
        protocol: string;
    }

    export interface FirewallDeny {
        ports?: string[];
        protocol: string;
    }

    export interface GetBackendServiceBackend {
        balancingMode: string;
        capacityScaler: number;
        /**
         * Textual description for the Backend Service.
         */
        description: string;
        group: string;
        maxConnections: number;
        maxConnectionsPerEndpoint: number;
        maxConnectionsPerInstance: number;
        maxRate: number;
        maxRatePerEndpoint: number;
        maxRatePerInstance: number;
        maxUtilization: number;
    }

    export interface GetBackendServiceCdnPolicy {
        cacheKeyPolicies: outputs.compute.GetBackendServiceCdnPolicyCacheKeyPolicy[];
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceCdnPolicyCacheKeyPolicy {
        includeHost: boolean;
        includeProtocol: boolean;
        includeQueryString: boolean;
        queryStringBlacklists: string[];
        queryStringWhitelists: string[];
    }

    export interface GetBackendServiceCircuitBreaker {
        connectTimeouts: outputs.compute.GetBackendServiceCircuitBreakerConnectTimeout[];
        maxConnections: number;
        maxPendingRequests: number;
        maxRequests: number;
        maxRequestsPerConnection: number;
        maxRetries: number;
    }

    export interface GetBackendServiceCircuitBreakerConnectTimeout {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceConsistentHash {
        httpCookies: outputs.compute.GetBackendServiceConsistentHashHttpCooky[];
        httpHeaderName: string;
        minimumRingSize: number;
    }

    export interface GetBackendServiceConsistentHashHttpCooky {
        /**
         * The name of the Backend Service.
         */
        name: string;
        path: string;
        ttls: outputs.compute.GetBackendServiceConsistentHashHttpCookyTtl[];
    }

    export interface GetBackendServiceConsistentHashHttpCookyTtl {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface GetBackendServiceLogConfig {
        enable: boolean;
        sampleRate: number;
    }

    export interface GetBackendServiceOutlierDetection {
        baseEjectionTimes: outputs.compute.GetBackendServiceOutlierDetectionBaseEjectionTime[];
        consecutiveErrors: number;
        consecutiveGatewayFailure: number;
        enforcingConsecutiveErrors: number;
        enforcingConsecutiveGatewayFailure: number;
        enforcingSuccessRate: number;
        intervals: outputs.compute.GetBackendServiceOutlierDetectionInterval[];
        maxEjectionPercent: number;
        successRateMinimumHosts: number;
        successRateRequestVolume: number;
        successRateStdevFactor: number;
    }

    export interface GetBackendServiceOutlierDetectionBaseEjectionTime {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceOutlierDetectionInterval {
        nanos: number;
        seconds: number;
    }

    export interface GetInstanceAttachedDisk {
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete: boolean;
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        /**
         * Parameters with which a disk was created alongside the instance.
         * Structure is documented below.
         */
        initializeParams: outputs.compute.GetInstanceBootDiskInitializeParam[];
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDiskInitializeParam {
        /**
         * The image from which this disk was initialised.
         */
        image: string;
        /**
         * A set of key/value label pairs assigned to the instance.
         */
        labels: {[key: string]: any};
        /**
         * The size of the image in gigabytes.
         */
        size: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete: boolean;
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        disk: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        /**
         * The image from which this disk was initialised.
         */
        image: string;
        scratch: boolean;
        /**
         * The size of the image in gigabytes.
         */
        size: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceGroupNamedPort {
        /**
         * The name of the instance group. Either `name` or `selfLink` must be provided.
         */
        name: string;
        port: number;
    }

    export interface GetInstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Structure documented below.
         */
        accessConfigs: outputs.compute.GetInstanceNetworkInterfaceAccessConfig[];
        address: string;
        /**
         * An array of alias IP ranges for this network interface. Structure documented below.
         */
        aliasIpRanges: outputs.compute.GetInstanceNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance. One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network: string;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp: string;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork: string;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject: string;
    }

    export interface GetInstanceNetworkInterfaceAccessConfig {
        assignedNatIp: string;
        /**
         * The IP address that is be 1:1 mapped to the instance's
         * network ip.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
         */
        networkTier: string;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName: string;
    }

    export interface GetInstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range.
         */
        subnetworkRangeName: string;
    }

    export interface GetInstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.GetInstanceSchedulingNodeAffinity[];
        /**
         * Describes maintenance behavior for the
         * instance. One of `MIGRATE` or `TERMINATE`, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
         */
        onHostMaintenance: string;
        /**
         * Whether the instance is preemptible.
         */
        preemptible: boolean;
    }

    export interface GetInstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface GetInstanceScratchDisk {
        /**
         * The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
         */
        interface: string;
    }

    export interface GetInstanceServiceAccount {
        /**
         * The service account e-mail address.
         */
        email: string;
        /**
         * A list of service scopes.
         */
        scopes: string[];
    }

    export interface GetInstanceShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface GetRegionInstanceGroupInstance {
        /**
         * URL to the instance.
         */
        instance: string;
        /**
         * List of named ports in the group, as a list of resources, each containing:
         */
        namedPorts: outputs.compute.GetRegionInstanceGroupInstanceNamedPort[];
        /**
         * String description of current state of the instance.
         */
        status: string;
    }

    export interface GetRegionInstanceGroupInstanceNamedPort {
        /**
         * The name of the instance group.  One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * Integer port number
         */
        port: number;
    }

    export interface GetSubnetworkSecondaryIpRange {
        /**
         * The range of IP addresses belonging to this subnetwork
         * secondary range.
         */
        ipCidrRange: string;
        /**
         * The name associated with this subnetwork secondary range, used
         * when adding an alias IP range to a VM instance.
         */
        rangeName: string;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: outputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface HaVpnGatewayVpnInterface {
        id?: number;
        ipAddress?: string;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface ImageGuestOsFeature {
        type?: string;
    }

    export interface ImageRawDisk {
        containerType?: string;
        sha1?: string;
        source: string;
    }

    export interface InstanceAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDisk {
        autoDelete?: boolean;
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDiskInitializeParams {
        image: string;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete: boolean;
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceFromTemplateBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image: string;
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs: outputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges: outputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.InstanceFromTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible: boolean;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: string;
    }

    export interface InstanceFromTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface InstanceGroupManagerVersion {
        /**
         * ) The
         * full URL to an instance template from which all new instances
         * will be created. This field is only present in the `google` provider.
         */
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.InstanceGroupManagerVersionTargetSize;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name of the instance group. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceNetworkInterface {
        accessConfigs?: outputs.compute.InstanceNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName?: string;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceScratchDisk {
        interface?: string;
    }

    export interface InstanceServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InstanceTemplateDisk {
        autoDelete?: boolean;
        boot: boolean;
        deviceName: string;
        diskEncryptionKey?: outputs.compute.InstanceTemplateDiskDiskEncryptionKey;
        diskName?: string;
        diskSizeGb?: number;
        diskType: string;
        interface: string;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: {[key: string]: string};
        mode: string;
        source?: string;
        sourceImage: string;
        type: string;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        kmsKeySelfLink?: string;
    }

    export interface InstanceTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceTemplateNetworkInterface {
        accessConfigs?: outputs.compute.InstanceTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange[];
        network: string;
        networkIp?: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceTemplateScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q: number;
    }

    export interface MangedSslCertificateManaged {
        domains: string;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: string;
        localSsd: string;
        memory?: string;
    }

    export interface NodeTemplateServerBinding {
        type: string;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.RegionAutoscalerAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface RegionBackendServiceBackend {
        description?: string;
        failover?: boolean;
        group?: string;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: boolean;
        dropTrafficIfUnhealthy?: boolean;
        failoverRatio?: number;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        instanceRedistributionType?: string;
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface RegionInstanceGroupManagerVersion {
        /**
         * ) The full URL to an instance template from
         * which all new instances will be created. This field is only present in the
         * `google` provider.
         */
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.RegionInstanceGroupManagerVersionTargetSize;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface RegionUrlMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: string;
        description?: string;
        name: string;
        pathRules?: outputs.compute.RegionUrlMapPathMatcherPathRule[];
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: string[];
        service: string;
    }

    export interface RegionUrlMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }

    export interface ReservationSpecificReservation {
        count: number;
        inUseCount: number;
        instanceProperties: outputs.compute.ReservationSpecificReservationInstanceProperties;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: outputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator[];
        localSsds?: outputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd[];
        machineType: string;
        minCpuPlatform: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: number;
        interface?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: outputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy;
        schedule: outputs.compute.ResourcePolicySnapshotSchedulePolicySchedule;
        snapshotProperties?: outputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: number;
        onSourceDiskDelete?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule;
        hourlySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule;
        weeklySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek[];
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: string;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: boolean;
        labels?: {[key: string]: string};
        storageLocations?: string;
    }

    export interface RouterBgp {
        advertiseMode?: string;
        advertisedGroups?: string[];
        advertisedIpRanges?: outputs.compute.RouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: string;
        range?: string;
    }

    export interface RouterNatLogConfig {
        enable: boolean;
        filter: string;
    }

    export interface RouterNatSubnetwork {
        name: string;
        secondaryIpRangeNames?: string[];
        sourceIpRangesToNats: string[];
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: string;
        range?: string;
    }

    export interface SecurityPolicyRule {
        action: string;
        /**
         * An optional description of this security policy. Max size is 2048.
         */
        description?: string;
        match: outputs.compute.SecurityPolicyRuleMatch;
        preview?: boolean;
        priority: number;
    }

    export interface SecurityPolicyRuleMatch {
        config: outputs.compute.SecurityPolicyRuleMatchConfig;
        versionedExpr: string;
    }

    export interface SecurityPolicyRuleMatchConfig {
        srcIpRanges: string[];
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: outputs.compute.SecurityScanConfigAuthenticationCustomAccount;
        googleAccount?: outputs.compute.SecurityScanConfigAuthenticationGoogleAccount;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: string;
        password: string;
        username: string;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: string;
        username: string;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: number;
        scheduleTime?: string;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey?: string;
        sha256: string;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: string;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: string;
        flowSampling?: number;
        metadata?: string;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: string;
        rangeName: string;
    }

    export interface URLMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface URLMapPathMatcher {
        defaultService: string;
        description?: string;
        name: string;
        pathRules?: outputs.compute.URLMapPathMatcherPathRule[];
    }

    export interface URLMapPathMatcherPathRule {
        paths: string[];
        service: string;
    }

    export interface URLMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        cloudrunConfig: outputs.container.ClusterAddonsConfigCloudrunConfig;
        horizontalPodAutoscaling: outputs.container.ClusterAddonsConfigHorizontalPodAutoscaling;
        httpLoadBalancing: outputs.container.ClusterAddonsConfigHttpLoadBalancing;
        istioConfig: outputs.container.ClusterAddonsConfigIstioConfig;
        kubernetesDashboard: outputs.container.ClusterAddonsConfigKubernetesDashboard;
        networkPolicyConfig: outputs.container.ClusterAddonsConfigNetworkPolicyConfig;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        disabled?: boolean;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        disabled?: boolean;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        disabled?: boolean;
    }

    export interface ClusterAddonsConfigIstioConfig {
        auth?: string;
        disabled?: boolean;
    }

    export interface ClusterAddonsConfigKubernetesDashboard {
        disabled?: boolean;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        disabled?: boolean;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface ClusterClusterAutoscaling {
        enabled: boolean;
        resourceLimits?: outputs.container.ClusterClusterAutoscalingResourceLimit[];
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        maximum?: number;
        minimum?: number;
        resourceType: string;
    }

    export interface ClusterDatabaseEncryption {
        keyName?: string;
        state: string;
    }

    export interface ClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        createSubnetwork?: boolean;
        nodeIpv4CidrBlock: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
        subnetworkName?: string;
        useIpAliases?: boolean;
    }

    export interface ClusterMaintenancePolicy {
        dailyMaintenanceWindow: outputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface ClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfig: outputs.container.ClusterMasterAuthClientCertificateConfig;
        clientKey: string;
        clusterCaCertificate: string;
        password?: string;
        username?: string;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        cidrBlocks?: outputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName?: string;
    }

    export interface ClusterNetworkPolicy {
        enabled?: boolean;
        provider?: string;
    }

    export interface ClusterNodeConfig {
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodeConfigSandboxConfig;
        serviceAccount: string;
        tags?: string[];
        taints: outputs.container.ClusterNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterNodePool {
        autoscaling?: outputs.container.ClusterNodePoolAutoscaling;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount: number;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls: string[];
        management: outputs.container.ClusterNodePoolManagement;
        maxPodsPerNode: number;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name: string;
        namePrefix: string;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig: outputs.container.ClusterNodePoolNodeConfig;
        nodeCount: number;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations: string[];
        version: string;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface ClusterNodePoolNodeConfig {
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        tags?: string[];
        taints: outputs.container.ClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface ClusterPrivateClusterConfig {
        enablePrivateEndpoint?: boolean;
        enablePrivateNodes?: boolean;
        masterIpv4CidrBlock?: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface ClusterResourceUsageExportConfig {
        bigqueryDestination: outputs.container.ClusterResourceUsageExportConfigBigqueryDestination;
        enableNetworkEgressMetering?: boolean;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface ClusterVerticalPodAutoscaling {
        enabled?: boolean;
    }

    export interface ClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface GetClusterAddonsConfig {
        cloudrunConfigs: outputs.container.GetClusterAddonsConfigCloudrunConfig[];
        horizontalPodAutoscalings: outputs.container.GetClusterAddonsConfigHorizontalPodAutoscaling[];
        httpLoadBalancings: outputs.container.GetClusterAddonsConfigHttpLoadBalancing[];
        istioConfigs: outputs.container.GetClusterAddonsConfigIstioConfig[];
        kubernetesDashboards: outputs.container.GetClusterAddonsConfigKubernetesDashboard[];
        networkPolicyConfigs: outputs.container.GetClusterAddonsConfigNetworkPolicyConfig[];
    }

    export interface GetClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigIstioConfig {
        auth: string;
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigKubernetesDashboard {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface GetClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface GetClusterClusterAutoscaling {
        enabled: boolean;
        resourceLimits: outputs.container.GetClusterClusterAutoscalingResourceLimit[];
    }

    export interface GetClusterClusterAutoscalingResourceLimit {
        maximum: number;
        minimum: number;
        resourceType: string;
    }

    export interface GetClusterDatabaseEncryption {
        keyName: string;
        state: string;
    }

    export interface GetClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        createSubnetwork: boolean;
        nodeIpv4CidrBlock: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
        subnetworkName: string;
        useIpAliases: boolean;
    }

    export interface GetClusterMaintenancePolicy {
        dailyMaintenanceWindows: outputs.container.GetClusterMaintenancePolicyDailyMaintenanceWindow[];
    }

    export interface GetClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface GetClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfigs: outputs.container.GetClusterMasterAuthClientCertificateConfig[];
        clientKey: string;
        clusterCaCertificate: string;
        password: string;
        username: string;
    }

    export interface GetClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface GetClusterMasterAuthorizedNetworksConfig {
        cidrBlocks: outputs.container.GetClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface GetClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName: string;
    }

    export interface GetClusterNetworkPolicy {
        enabled: boolean;
        provider: string;
    }

    export interface GetClusterNodeConfig {
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodeConfigSandboxConfig[];
        serviceAccount: string;
        tags: string[];
        taints: outputs.container.GetClusterNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePool {
        autoscalings: outputs.container.GetClusterNodePoolAutoscaling[];
        initialNodeCount: number;
        instanceGroupUrls: string[];
        managements: outputs.container.GetClusterNodePoolManagement[];
        maxPodsPerNode: number;
        /**
         * The name of the cluster.
         */
        name: string;
        namePrefix: string;
        nodeConfigs: outputs.container.GetClusterNodePoolNodeConfig[];
        nodeCount: number;
        nodeLocations: string[];
        version: string;
    }

    export interface GetClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface GetClusterNodePoolManagement {
        autoRepair: boolean;
        autoUpgrade: boolean;
    }

    export interface GetClusterNodePoolNodeConfig {
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodePoolNodeConfigSandboxConfig[];
        serviceAccount: string;
        tags: string[];
        taints: outputs.container.GetClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodePoolNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface GetClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes: boolean;
        masterIpv4CidrBlock: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface GetClusterResourceUsageExportConfig {
        bigqueryDestinations: outputs.container.GetClusterResourceUsageExportConfigBigqueryDestination[];
        enableNetworkEgressMetering: boolean;
    }

    export interface GetClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface GetClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface GetClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface NodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface NodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface NodePoolNodeConfig {
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.NodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.NodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        tags?: string[];
        taints: outputs.container.NodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.NodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface NodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: outputs.containeranalysis.NoteAttestationAuthorityHint;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: string;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: string;
        yarnConfig: outputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: string;
        scaleDownFactor: number;
        scaleDownMinWorkerFraction?: number;
        scaleUpFactor: number;
        scaleUpMinWorkerFraction?: number;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: number;
        minInstances?: number;
        weight?: number;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: number;
        minInstances?: number;
        weight?: number;
    }

    export interface ClusterClusterConfig {
        autoscalingConfig?: outputs.dataproc.ClusterClusterConfigAutoscalingConfig;
        bucket: string;
        encryptionConfig?: outputs.dataproc.ClusterClusterConfigEncryptionConfig;
        gceClusterConfig: outputs.dataproc.ClusterClusterConfigGceClusterConfig;
        initializationActions?: outputs.dataproc.ClusterClusterConfigInitializationAction[];
        masterConfig: outputs.dataproc.ClusterClusterConfigMasterConfig;
        preemptibleWorkerConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig;
        softwareConfig: outputs.dataproc.ClusterClusterConfigSoftwareConfig;
        stagingBucket?: string;
        workerConfig: outputs.dataproc.ClusterClusterConfigWorkerConfig;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        policyUri?: string;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        kmsKeyName: string;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        internalIpOnly?: boolean;
        metadata?: {[key: string]: string};
        network: string;
        serviceAccount?: string;
        serviceAccountScopes: string[];
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: string;
        timeoutSec?: number;
    }

    export interface ClusterClusterConfigMasterConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigMasterConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        diskConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig;
        instanceNames: string[];
        numInstances: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        imageVersion: string;
        optionalComponents?: string[];
        overrideProperties?: {[key: string]: string};
        properties: {[key: string]: any};
    }

    export interface ClusterClusterConfigWorkerConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface JobHadoopConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobHadoopConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels?: {[key: string]: string};
    }

    export interface JobHiveConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobPigConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPigConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels?: {[key: string]: string};
    }

    export interface JobPlacement {
        clusterName: string;
        clusterUuid: string;
    }

    export interface JobPysparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPysparkConfigLoggingConfig;
        mainPythonFileUri: string;
        properties?: {[key: string]: string};
        pythonFileUris?: string[];
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels?: {[key: string]: string};
    }

    export interface JobReference {
        jobId: string;
    }

    export interface JobScheduling {
        maxFailuresPerHour?: number;
    }

    export interface JobSparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparkConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels?: {[key: string]: string};
    }

    export interface JobSparksqlConfig {
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparksqlConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels?: {[key: string]: string};
    }

    export interface JobStatus {
        details: string;
        state: string;
        stateStartTime: string;
        substate: string;
    }
}

export namespace dns {
    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs: outputs.dns.ManagedZoneDnssecConfigDefaultKeySpec[];
        kind?: string;
        nonExistence: string;
        state?: string;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: string;
        keyLength?: number;
        keyType?: string;
        kind?: string;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers?: outputs.dns.ManagedZoneForwardingConfigTargetNameServer[];
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        ipv4Address?: string;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork?: outputs.dns.ManagedZonePeeringConfigTargetNetwork;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl?: string;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks?: outputs.dns.ManagedZonePrivateVisibilityConfigNetwork[];
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl?: string;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers?: outputs.dns.PolicyAlternativeNameServerConfigTargetNameServer[];
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address?: string;
    }

    export interface PolicyNetwork {
        networkUrl?: string;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods: outputs.endpoints.ServiceApiMethod[];
        name: string;
        syntax: string;
        version: string;
    }

    export interface ServiceApiMethod {
        name: string;
        requestType: string;
        responseType: string;
        syntax: string;
    }

    export interface ServiceEndpoint {
        address: string;
        name: string;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: number;
        name: string;
    }

    export interface InstanceNetwork {
        ipAddresses: string[];
        modes: string[];
        network: string;
        reservedIpRange: string;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: string;
        fieldPath?: string;
        order?: string;
    }
}

export namespace folder {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.folder.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.folder.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.folder.OrganizationPolicyListPolicyAllow;
        deny?: outputs.folder.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace healthcare {
    export interface DicomStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: boolean;
        segmentTerminator?: string;
    }
}

export namespace kms {
    export interface CryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel?: string;
    }

    export interface GetKMSCryptoKeyVersionPublicKey {
        /**
         * The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
         */
        algorithm: string;
        /**
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem: string;
    }

    export interface GetKMSCryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel: string;
    }

    export interface RegistryCredential {
        publicKeyCertificate?: outputs.kms.RegistryCredentialPublicKeyCertificate;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        certificate: string;
        format: string;
    }

    export interface RegistryEventNotificationConfig {
        pubsubTopicName: string;
    }

    export interface RegistryEventNotificationConfigItem {
        pubsubTopicName: string;
        subfolderMatches?: string;
    }

    export interface RegistryHttpConfig {
        httpEnabledState: string;
    }

    export interface RegistryMqttConfig {
        mqttEnabledState: string;
    }

    export interface RegistryStateNotificationConfig {
        pubsubTopicName: string;
    }
}

export namespace logging {
    export interface MetricBucketOptions {
        explicitBuckets?: outputs.logging.MetricBucketOptionsExplicitBuckets;
        exponentialBuckets?: outputs.logging.MetricBucketOptionsExponentialBuckets;
        linearBuckets?: outputs.logging.MetricBucketOptionsLinearBuckets;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds?: number[];
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: number;
        numFiniteBuckets?: number;
        scale?: number;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: number;
        offset?: number;
        width?: number;
    }

    export interface MetricMetricDescriptor {
        labels?: outputs.logging.MetricMetricDescriptorLabel[];
        metricKind: string;
        unit?: string;
        valueType: string;
    }

    export interface MetricMetricDescriptorLabel {
        description?: string;
        key: string;
        valueType?: string;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name?: string;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: outputs.monitoring.AlertPolicyConditionConditionAbsent;
        conditionThreshold?: outputs.monitoring.AlertPolicyConditionConditionThreshold;
        displayName: string;
        name: string;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionAbsentAggregation[];
        duration: string;
        filter?: string;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionAbsentTrigger;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdAggregation[];
        comparison: string;
        denominatorAggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation[];
        denominatorFilter?: string;
        duration: string;
        filter?: string;
        thresholdValue?: number;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionThresholdTrigger;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime: string;
        mutatedBy: string;
    }

    export interface AlertPolicyDocumentation {
        content?: string;
        mimeType?: string;
    }

    export interface UptimeCheckConfigContentMatcher {
        content?: string;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: outputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo;
        headers?: {[key: string]: string};
        maskHeaders?: boolean;
        path?: string;
        port: number;
        useSsl?: boolean;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password?: string;
        username?: string;
    }

    export interface UptimeCheckConfigInternalChecker {
        displayName?: string;
        gcpZone?: string;
        name?: string;
        network?: string;
        peerProjectId?: string;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: {[key: string]: string};
        type: string;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: string;
        resourceType?: string;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: number;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: outputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetProjectAppEngine {
        authDomain: string;
        codeBucket: string;
        defaultBucket: string;
        defaultHostname: string;
        featureSettings: outputs.organizations.GetProjectAppEngineFeatureSetting[];
        gcrDomain: string;
        locationId: string;
        name: string;
        servingStatus: string;
        urlDispatchRules: outputs.organizations.GetProjectAppEngineUrlDispatchRule[];
    }

    export interface GetProjectAppEngineFeatureSetting {
        splitHealthChecks: boolean;
    }

    export interface GetProjectAppEngineUrlDispatchRule {
        domain: string;
        path: string;
        service: string;
    }

    export interface PolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface PolicyListPolicy {
        allow?: outputs.organizations.PolicyListPolicyAllow;
        deny?: outputs.organizations.PolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface PolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyRestorePolicy {
        default: boolean;
    }
}

export namespace projects {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.projects.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.projects.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface GetProjectProject {
        /**
         * The project id of the project.
         */
        projectId: string;
    }

    export interface IAMAuditConfigAuditLogConfig {
        exemptedMembers?: string[];
        logType: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.projects.OrganizationPolicyListPolicyAllow;
        deny?: outputs.projects.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace pubsub {
    export interface SubscriptionExpirationPolicy {
        ttl?: string;
    }

    export interface SubscriptionPushConfig {
        attributes?: {[key: string]: string};
        pushEndpoint: string;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: string[];
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress: string;
        timeToRetire: string;
        type: string;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        caCertificate?: string;
        clientCertificate?: string;
        clientKey?: string;
        connectRetryInterval?: number;
        dumpFilePath?: string;
        failoverTarget?: boolean;
        masterHeartbeatPeriod?: number;
        password?: string;
        sslCipher?: string;
        username?: string;
        verifyServerCertificate?: boolean;
    }

    export interface DatabaseInstanceServerCaCert {
        cert: string;
        commonName: string;
        createTime: string;
        expirationTime: string;
        sha1Fingerprint: string;
    }

    export interface DatabaseInstanceSettings {
        activationPolicy: string;
        authorizedGaeApplications?: string[];
        availabilityType: string;
        backupConfiguration: outputs.sql.DatabaseInstanceSettingsBackupConfiguration;
        crashSafeReplication: boolean;
        databaseFlags?: outputs.sql.DatabaseInstanceSettingsDatabaseFlag[];
        diskAutoresize?: boolean;
        diskSize: number;
        diskType: string;
        ipConfiguration: outputs.sql.DatabaseInstanceSettingsIpConfiguration;
        locationPreference: outputs.sql.DatabaseInstanceSettingsLocationPreference;
        maintenanceWindow?: outputs.sql.DatabaseInstanceSettingsMaintenanceWindow;
        pricingPlan?: string;
        replicationType?: string;
        tier: string;
        userLabels?: {[key: string]: string};
        version: number;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        binaryLogEnabled?: boolean;
        enabled?: boolean;
        startTime: string;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: string;
        value?: string;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: outputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork[];
        ipv4Enabled: boolean;
        privateNetwork?: string;
        requireSsl?: boolean;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        expirationTime?: string;
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: string;
        value?: string;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        followGaeApplication?: string;
        zone?: string;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        day?: number;
        hour?: number;
        updateTrack?: string;
    }
}

export namespace storage {
    export interface BucketCor {
        maxAgeSeconds?: number;
        methods?: string[];
        origins?: string[];
        responseHeaders?: string[];
    }

    export interface BucketEncryption {
        defaultKmsKeyName: string;
    }

    export interface BucketLifecycleRule {
        action: outputs.storage.BucketLifecycleRuleAction;
        condition: outputs.storage.BucketLifecycleRuleCondition;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of the new bucket. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: string;
        type: string;
    }

    export interface BucketLifecycleRuleCondition {
        age?: number;
        createdBefore?: string;
        isLive: boolean;
        matchesStorageClasses?: string[];
        numNewerVersions?: number;
        withState: string;
    }

    export interface BucketLogging {
        logBucket: string;
        logObjectPrefix: string;
    }

    export interface BucketRetentionPolicy {
        isLocked?: boolean;
        retentionPeriod: number;
    }

    export interface BucketVersioning {
        enabled?: boolean;
    }

    export interface BucketWebsite {
        mainPageSuffix?: string;
        notFoundPage?: string;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface TransferJobSchedule {
        scheduleEndDate?: outputs.storage.TransferJobScheduleScheduleEndDate;
        scheduleStartDate: outputs.storage.TransferJobScheduleScheduleStartDate;
        startTimeOfDay?: outputs.storage.TransferJobScheduleStartTimeOfDay;
    }

    export interface TransferJobScheduleScheduleEndDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleScheduleStartDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        hours: number;
        minutes: number;
        nanos: number;
        seconds: number;
    }

    export interface TransferJobTransferSpec {
        awsS3DataSource?: outputs.storage.TransferJobTransferSpecAwsS3DataSource;
        gcsDataSink?: outputs.storage.TransferJobTransferSpecGcsDataSink;
        gcsDataSource?: outputs.storage.TransferJobTransferSpecGcsDataSource;
        httpDataSource?: outputs.storage.TransferJobTransferSpecHttpDataSource;
        objectConditions?: outputs.storage.TransferJobTransferSpecObjectConditions;
        transferOptions?: outputs.storage.TransferJobTransferSpecTransferOptions;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        awsAccessKey: outputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey;
        bucketName: string;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        accessKeyId: string;
        secretAccessKey: string;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        bucketName: string;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        bucketName: string;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        listUrl: string;
    }

    export interface TransferJobTransferSpecObjectConditions {
        excludePrefixes?: string[];
        includePrefixes?: string[];
        maxTimeElapsedSinceLastModification?: string;
        minTimeElapsedSinceLastModification?: string;
    }

    export interface TransferJobTransferSpecTransferOptions {
        deleteObjectsFromSourceAfterTransfer?: boolean;
        deleteObjectsUniqueInSink?: boolean;
        overwriteObjectsAlreadyExistingInSink?: boolean;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress: string;
        port: number;
    }

    export interface NodeSchedulingConfig {
        preemptible?: boolean;
    }
}
