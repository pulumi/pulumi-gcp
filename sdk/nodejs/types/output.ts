// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";


export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: string;
        conditions: outputs.accesscontextmanager.AccessLevelBasicCondition[];
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy;
        ipSubnetworks?: string[];
        members?: string[];
        negate?: boolean;
        requiredAccessLevels?: string[];
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: string[];
        allowedEncryptionStatuses?: string[];
        osConstraints?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint[];
        requireAdminApproval?: boolean;
        requireCorpOwned?: boolean;
        requireScreenLock?: boolean;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: string;
        osType: string;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: string[];
        resources?: string[];
        restrictedServices?: string[];
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: boolean;
    }

    export interface ApplicationIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface ApplicationUrlDispatchRule {
        domain: string;
        path: string;
        service: string;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        domain?: string;
        path: string;
        service: string;
    }

    export interface DomainMappingResourceRecord {
        name?: string;
        rrdata?: string;
        type?: string;
    }

    export interface DomainMappingSslSettings {
        certificateId: string;
        pendingManagedCertificateId: string;
        sslManagementType: string;
    }

    export interface EngineSplitTrafficSplit {
        allocations: {[key: string]: string};
        shardBy?: string;
    }

    export interface StandardAppVersionDeployment {
        files?: outputs.appengine.StandardAppVersionDeploymentFile[];
        zip?: outputs.appengine.StandardAppVersionDeploymentZip;
    }

    export interface StandardAppVersionDeploymentFile {
        name: string;
        sha1Sum?: string;
        sourceUrl: string;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: number;
        sourceUrl: string;
    }

    export interface StandardAppVersionEntrypoint {
        shell: string;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: string;
        login?: string;
        redirectHttpResponseCode?: string;
        script?: outputs.appengine.StandardAppVersionHandlerScript;
        securityLevel?: string;
        staticFiles?: outputs.appengine.StandardAppVersionHandlerStaticFiles;
        urlRegex?: string;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath: string;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: boolean;
        expiration?: string;
        httpHeaders?: {[key: string]: string};
        mimeType?: string;
        path?: string;
        requireMatchingFile?: boolean;
        uploadPathRegex?: string;
    }

    export interface StandardAppVersionLibrary {
        name?: string;
        version?: string;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: boolean;
        clusterId: string;
    }

    export interface DatasetAccess {
        domain?: string;
        groupByEmail?: string;
        role?: string;
        specialGroup?: string;
        userByEmail?: string;
        view?: outputs.bigquery.DatasetAccessView;
    }

    export interface DatasetAccessView {
        datasetId: string;
        projectId: string;
        tableId: string;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        kmsKeyName: string;
    }

    export interface TableEncryptionConfiguration {
        kmsKeyName: string;
    }

    export interface TableExternalDataConfiguration {
        autodetect: boolean;
        compression?: string;
        csvOptions?: outputs.bigquery.TableExternalDataConfigurationCsvOptions;
        googleSheetsOptions?: outputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions;
        ignoreUnknownValues?: boolean;
        maxBadRecords?: number;
        sourceFormat: string;
        sourceUris: string[];
    }

    export interface TableExternalDataConfigurationCsvOptions {
        allowJaggedRows?: boolean;
        allowQuotedNewlines?: boolean;
        encoding?: string;
        fieldDelimiter?: string;
        quote: string;
        skipLeadingRows?: number;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        range?: string;
        skipLeadingRows?: number;
    }

    export interface TableRangePartitioning {
        field: string;
        range: outputs.bigquery.TableRangePartitioningRange;
    }

    export interface TableRangePartitioningRange {
        end: number;
        interval: number;
        start: number;
    }

    export interface TableTimePartitioning {
        expirationMs?: number;
        field?: string;
        requirePartitionFilter?: boolean;
        /**
         * Describes the table type.
         */
        type: string;
    }

    export interface TableView {
        query: string;
        useLegacySql?: boolean;
    }
}

export namespace bigtable {
    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         */
        days: number;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         */
        number: number;
    }

    export interface InstanceCluster {
        clusterId: string;
        numNodes: number;
        storageType?: string;
        zone: string;
    }

    export interface InstanceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: string;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AccountIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BudgetAllUpdatesRule {
        pubsubTopic: string;
        schemaVersion?: string;
    }

    export interface BudgetAmount {
        specifiedAmount: outputs.billing.BudgetAmountSpecifiedAmount;
    }

    export interface BudgetAmountSpecifiedAmount {
        currencyCode?: string;
        nanos?: number;
        units?: string;
    }

    export interface BudgetBudgetFilter {
        creditTypesTreatment?: string;
        projects?: string[];
        services?: string[];
    }

    export interface BudgetThresholdRule {
        spendBasis?: string;
        thresholdPercent: number;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail: string;
        noteReference: string;
        publicKeys?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey[];
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: string;
        comment?: string;
        /**
         * an identifier for the resource with format `projects/{{project}}/attestors/{{name}}`
         */
        id: string;
        pkixPublicKey?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: string;
        signatureAlgorithm?: string;
    }

    export interface AttestorIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AttestorIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern: string;
    }

    export interface PolicyClusterAdmissionRule {
        cluster: string;
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: string[];
        steps: outputs.cloudbuild.TriggerBuildStep[];
        tags?: string[];
        timeout?: string;
    }

    export interface TriggerBuildStep {
        args?: string[];
        dir?: string;
        entrypoint?: string;
        envs?: string[];
        /**
         * an identifier for the resource with format `projects/{{project}}/triggers/{{trigger_id}}`
         */
        id?: string;
        name: string;
        secretEnvs?: string[];
        timeout?: string;
        timing?: string;
        volumes?: outputs.cloudbuild.TriggerBuildStepVolume[];
        waitFors?: string[];
    }

    export interface TriggerBuildStepVolume {
        name: string;
        path: string;
    }

    export interface TriggerGithub {
        name?: string;
        owner?: string;
        pullRequest?: outputs.cloudbuild.TriggerGithubPullRequest;
        push?: outputs.cloudbuild.TriggerGithubPush;
    }

    export interface TriggerGithubPullRequest {
        branch: string;
        commentControl?: string;
    }

    export interface TriggerGithubPush {
        branch?: string;
        tag?: string;
    }

    export interface TriggerTriggerTemplate {
        branchName?: string;
        commitSha?: string;
        dir?: string;
        projectId: string;
        repoName?: string;
        tagName?: string;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        eventType: string;
        failurePolicy: outputs.cloudfunctions.FunctionEventTriggerFailurePolicy;
        resource: string;
    }

    export interface FunctionEventTriggerFailurePolicy {
        retry: boolean;
    }

    export interface FunctionIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }

    export interface GetFunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/)
         * for a full reference of accepted triggers.
         */
        eventType: string;
        /**
         * Policy for failed executions. Structure is documented below.
         */
        failurePolicies: outputs.cloudfunctions.GetFunctionEventTriggerFailurePolicy[];
        /**
         * The name of the resource whose events are being observed, for example, `"myBucket"`
         */
        resource: string;
    }

    export interface GetFunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure.
         */
        retry: boolean;
    }

    export interface GetFunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface DomainMappingSpec {
        certificateMode?: string;
        forceOverride?: boolean;
        routeName: string;
    }

    export interface DomainMappingStatus {
        conditions: outputs.cloudrun.DomainMappingStatusCondition[];
        mappedRouteName: string;
        observedGeneration: number;
        resourceRecords?: outputs.cloudrun.DomainMappingStatusResourceRecord[];
    }

    export interface DomainMappingStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface DomainMappingStatusResourceRecord {
        name: string;
        rrdata: string;
        type?: string;
    }

    export interface IamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceStatus {
        conditions: outputs.cloudrun.ServiceStatusCondition[];
        latestCreatedRevisionName: string;
        latestReadyRevisionName: string;
        observedGeneration: number;
        url: string;
    }

    export interface ServiceStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface ServiceTemplate {
        metadata: outputs.cloudrun.ServiceTemplateMetadata;
        spec: outputs.cloudrun.ServiceTemplateSpec;
    }

    export interface ServiceTemplateMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels?: {[key: string]: string};
        name: string;
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceTemplateSpec {
        containerConcurrency: number;
        containers: outputs.cloudrun.ServiceTemplateSpecContainer[];
        serviceAccountName?: string;
        servingState: string;
    }

    export interface ServiceTemplateSpecContainer {
        args?: string[];
        commands?: string[];
        envs?: outputs.cloudrun.ServiceTemplateSpecContainerEnv[];
        envFroms?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFrom[];
        image: string;
        resources: outputs.cloudrun.ServiceTemplateSpecContainerResources;
        workingDir?: string;
    }

    export interface ServiceTemplateSpecContainerEnv {
        name?: string;
        value?: string;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        configMapRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef;
        prefix?: string;
        secretRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerResources {
        limits: {[key: string]: string};
        requests?: {[key: string]: string};
    }

    export interface ServiceTraffic {
        latestRevision?: boolean;
        percent: number;
        revisionName?: string;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: outputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting;
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        relativeUri: string;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface JobHttpTarget {
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        oauthToken?: outputs.cloudscheduler.JobHttpTargetOauthToken;
        oidcToken?: outputs.cloudscheduler.JobHttpTargetOidcToken;
        uri: string;
    }

    export interface JobHttpTargetOauthToken {
        scope?: string;
        serviceAccountEmail: string;
    }

    export interface JobHttpTargetOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface JobPubsubTarget {
        attributes?: {[key: string]: string};
        data?: string;
        topicName: string;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: string;
        maxDoublings?: number;
        maxRetryDuration?: string;
        minBackoffDuration?: string;
        retryCount?: number;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        host: string;
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface QueueRateLimits {
        maxBurstSize: number;
        maxConcurrentDispatches: number;
        maxDispatchesPerSecond: number;
    }

    export interface QueueRetryConfig {
        maxAttempts: number;
        maxBackoff: string;
        maxDoublings: number;
        maxRetryDuration: string;
        minBackoff: string;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri: string;
        dagGcsPrefix: string;
        gkeCluster: string;
        nodeConfig: outputs.composer.EnvironmentConfigNodeConfig;
        nodeCount: number;
        privateEnvironmentConfig: outputs.composer.EnvironmentConfigPrivateEnvironmentConfig;
        softwareConfig: outputs.composer.EnvironmentConfigSoftwareConfig;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb: number;
        ipAllocationPolicy: outputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy;
        machineType: string;
        network: string;
        oauthScopes: string[];
        serviceAccount: string;
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: string;
        clusterSecondaryRangeName?: string;
        servicesIpv4CidrBlock?: string;
        servicesSecondaryRangeName?: string;
        useIpAliases: boolean;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: boolean;
        masterIpv4CidrBlock?: string;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: {[key: string]: string};
        envVariables?: {[key: string]: string};
        imageVersion: string;
        pypiPackages?: {[key: string]: string};
        pythonVersion: string;
    }

    export interface GetImageVersionsImageVersion {
        /**
         * The string identifier of the image version, in the form: "composer-x.y.z-airflow-a.b(.c)"
         */
        imageVersionId: string;
        /**
         * Supported python versions for this image version
         */
        supportedPythonVersions: string[];
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.AutoscalarAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.AutoscalarAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: number;
    }

    export interface BackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: outputs.compute.BackendServiceCdnPolicyCacheKeyPolicy;
        signedUrlCacheMaxAgeSec?: number;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: boolean;
        includeProtocol?: boolean;
        includeQueryString?: boolean;
        queryStringBlacklists?: string[];
        queryStringWhitelists?: string[];
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.BackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: outputs.compute.BackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.BackendServiceConsistentHashHttpCookieTtl;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface BackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.BackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.BackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/global/externalVpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface FirewallAllow {
        ports?: string[];
        protocol: string;
    }

    export interface FirewallDeny {
        ports?: string[];
        protocol: string;
    }

    export interface GetBackendBucketCdnPolicy {
        /**
         * Maximum number of seconds the response to a signed URL request will be considered fresh. After this time period, the response will be revalidated before being served. When serving responses to signed URL requests, Cloud CDN will internally behave as though all responses from this backend had a "Cache-Control: public, max-age=[TTL]" header, regardless of any existing Cache-Control header. The actual headers served in responses will not be altered.
         */
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceBackend {
        balancingMode: string;
        capacityScaler: number;
        /**
         * Textual description for the Backend Service.
         */
        description: string;
        group: string;
        maxConnections: number;
        maxConnectionsPerEndpoint: number;
        maxConnectionsPerInstance: number;
        maxRate: number;
        maxRatePerEndpoint: number;
        maxRatePerInstance: number;
        maxUtilization: number;
    }

    export interface GetBackendServiceCdnPolicy {
        cacheKeyPolicies: outputs.compute.GetBackendServiceCdnPolicyCacheKeyPolicy[];
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceCdnPolicyCacheKeyPolicy {
        includeHost: boolean;
        includeProtocol: boolean;
        includeQueryString: boolean;
        queryStringBlacklists: string[];
        queryStringWhitelists: string[];
    }

    export interface GetBackendServiceCircuitBreaker {
        connectTimeouts: outputs.compute.GetBackendServiceCircuitBreakerConnectTimeout[];
        maxConnections: number;
        maxPendingRequests: number;
        maxRequests: number;
        maxRequestsPerConnection: number;
        maxRetries: number;
    }

    export interface GetBackendServiceCircuitBreakerConnectTimeout {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceConsistentHash {
        httpCookies: outputs.compute.GetBackendServiceConsistentHashHttpCooky[];
        httpHeaderName: string;
        minimumRingSize: number;
    }

    export interface GetBackendServiceConsistentHashHttpCooky {
        /**
         * The name of the Backend Service.
         */
        name: string;
        path: string;
        ttls: outputs.compute.GetBackendServiceConsistentHashHttpCookyTtl[];
    }

    export interface GetBackendServiceConsistentHashHttpCookyTtl {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface GetBackendServiceLogConfig {
        enable: boolean;
        sampleRate: number;
    }

    export interface GetBackendServiceOutlierDetection {
        baseEjectionTimes: outputs.compute.GetBackendServiceOutlierDetectionBaseEjectionTime[];
        consecutiveErrors: number;
        consecutiveGatewayFailure: number;
        enforcingConsecutiveErrors: number;
        enforcingConsecutiveGatewayFailure: number;
        enforcingSuccessRate: number;
        intervals: outputs.compute.GetBackendServiceOutlierDetectionInterval[];
        maxEjectionPercent: number;
        successRateMinimumHosts: number;
        successRateRequestVolume: number;
        successRateStdevFactor: number;
    }

    export interface GetBackendServiceOutlierDetectionBaseEjectionTime {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceOutlierDetectionInterval {
        nanos: number;
        seconds: number;
    }

    export interface GetInstanceAttachedDisk {
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete: boolean;
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        /**
         * Parameters with which a disk was created alongside the instance.
         * Structure is documented below.
         */
        initializeParams: outputs.compute.GetInstanceBootDiskInitializeParam[];
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDiskInitializeParam {
        /**
         * The image from which this disk was initialised.
         */
        image: string;
        /**
         * A set of key/value label pairs assigned to the instance.
         */
        labels: {[key: string]: any};
        /**
         * The size of the image in gigabytes.
         */
        size: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceGroupNamedPort {
        /**
         * The name of the instance group. Either `name` or `selfLink` must be provided.
         */
        name: string;
        port: number;
    }

    export interface GetInstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Structure documented below.
         */
        accessConfigs: outputs.compute.GetInstanceNetworkInterfaceAccessConfig[];
        /**
         * An array of alias IP ranges for this network interface. Structure documented below.
         */
        aliasIpRanges: outputs.compute.GetInstanceNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance. One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network: string;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp: string;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork: string;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject: string;
    }

    export interface GetInstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that is be 1:1 mapped to the instance's
         * network ip.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
         */
        networkTier: string;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName: string;
    }

    export interface GetInstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range.
         */
        subnetworkRangeName: string;
    }

    export interface GetInstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.GetInstanceSchedulingNodeAffinity[];
        /**
         * Describes maintenance behavior for the
         * instance. One of `MIGRATE` or `TERMINATE`, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
         */
        onHostMaintenance: string;
        /**
         * Whether the instance is preemptible.
         */
        preemptible: boolean;
    }

    export interface GetInstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface GetInstanceScratchDisk {
        /**
         * The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
         */
        interface: string;
    }

    export interface GetInstanceServiceAccount {
        /**
         * The service account e-mail address.
         */
        email: string;
        /**
         * A list of service scopes.
         */
        scopes: string[];
    }

    export interface GetInstanceShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface GetRegionInstanceGroupInstance {
        /**
         * URL to the instance.
         */
        instance: string;
        /**
         * List of named ports in the group, as a list of resources, each containing:
         */
        namedPorts: outputs.compute.GetRegionInstanceGroupInstanceNamedPort[];
        /**
         * String description of current state of the instance.
         */
        status: string;
    }

    export interface GetRegionInstanceGroupInstanceNamedPort {
        /**
         * The name of the instance group.  One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * Integer port number
         */
        port: number;
    }

    export interface GetRouterBgp {
        advertiseMode: string;
        advertisedGroups: string[];
        advertisedIpRanges: outputs.compute.GetRouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface GetRouterBgpAdvertisedIpRange {
        description: string;
        range: string;
    }

    export interface GetSubnetworkSecondaryIpRange {
        /**
         * The range of IP addresses belonging to this subnetwork
         * secondary range.
         */
        ipCidrRange: string;
        /**
         * The name associated with this subnetwork secondary range, used
         * when adding an alias IP range to a VM instance.
         */
        rangeName: string;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: outputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface ImageGuestOsFeature {
        type: string;
    }

    export interface ImageRawDisk {
        containerType?: string;
        sha1?: string;
        source: string;
    }

    export interface InstanceAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDisk {
        autoDelete?: boolean;
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDiskInitializeParams {
        image: string;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete: boolean;
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceFromTemplateBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image: string;
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs: outputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges: outputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.InstanceFromTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible: boolean;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: string;
    }

    export interface InstanceFromTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface InstanceGroupManagerVersion {
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.InstanceGroupManagerVersionTargetSize;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name of the instance group. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceNetworkInterface {
        accessConfigs?: outputs.compute.InstanceNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName?: string;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceScratchDisk {
        interface: string;
    }

    export interface InstanceServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InstanceTemplateDisk {
        autoDelete?: boolean;
        boot: boolean;
        deviceName: string;
        diskEncryptionKey?: outputs.compute.InstanceTemplateDiskDiskEncryptionKey;
        diskName?: string;
        diskSizeGb?: number;
        diskType: string;
        interface: string;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: {[key: string]: string};
        mode: string;
        source?: string;
        sourceImage: string;
        type: string;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        kmsKeySelfLink: string;
    }

    export interface InstanceTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceTemplateNetworkInterface {
        accessConfigs?: outputs.compute.InstanceTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name: string;
        network: string;
        networkIp?: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceTemplateScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q: number;
    }

    export interface ManagedSslCertificateManaged {
        domains: string[];
    }

    export interface MangedSslCertificateManaged {
        domains: string[];
    }

    export interface NodeGroupAutoscalingPolicy {
        maxNodes: number;
        minNodes: number;
        mode: string;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: string;
        localSsd: string;
        memory?: string;
    }

    export interface NodeTemplateServerBinding {
        type: string;
    }

    export interface PacketMirroringCollectorIlb {
        url: string;
    }

    export interface PacketMirroringFilter {
        cidrRanges?: string[];
        ipProtocols?: string[];
    }

    export interface PacketMirroringMirroredResources {
        instances?: outputs.compute.PacketMirroringMirroredResourcesInstance[];
        subnetworks?: outputs.compute.PacketMirroringMirroredResourcesSubnetwork[];
        tags?: string[];
    }

    export interface PacketMirroringMirroredResourcesInstance {
        url: string;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        url: string;
    }

    export interface PacketMirroringNetwork {
        url: string;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.RegionAutoscalerAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface RegionBackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        failover: boolean;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface RegionBackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceConsistentHash {
        httpCookie?: outputs.compute.RegionBackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: boolean;
        dropTrafficIfUnhealthy?: boolean;
        failoverRatio?: number;
    }

    export interface RegionBackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface RegionBackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.RegionBackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        instanceRedistributionType?: string;
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface RegionInstanceGroupManagerVersion {
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.RegionInstanceGroupManagerVersionTargetSize;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface RegionUrlMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: string;
        description?: string;
        name: string;
        pathRules?: outputs.compute.RegionUrlMapPathMatcherPathRule[];
        routeRules?: outputs.compute.RegionUrlMapPathMatcherRouteRule[];
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface RegionUrlMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }

    export interface ReservationSpecificReservation {
        count: number;
        inUseCount: number;
        instanceProperties: outputs.compute.ReservationSpecificReservationInstanceProperties;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: outputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator[];
        localSsds?: outputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd[];
        machineType: string;
        minCpuPlatform: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: number;
        interface?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: outputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy;
        schedule: outputs.compute.ResourcePolicySnapshotSchedulePolicySchedule;
        snapshotProperties?: outputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: number;
        onSourceDiskDelete?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule;
        hourlySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule;
        weeklySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek[];
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: string;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: boolean;
        labels?: {[key: string]: string};
        storageLocations?: string;
    }

    export interface RouterBgp {
        advertiseMode?: string;
        advertisedGroups?: string[];
        advertisedIpRanges?: outputs.compute.RouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface RouterNatLogConfig {
        enable: boolean;
        filter: string;
    }

    export interface RouterNatSubnetwork {
        name: string;
        secondaryIpRangeNames?: string[];
        sourceIpRangesToNats: string[];
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface SecurityPolicyRule {
        action: string;
        /**
         * An optional description of this security policy. Max size is 2048.
         */
        description?: string;
        match: outputs.compute.SecurityPolicyRuleMatch;
        preview?: boolean;
        priority: number;
    }

    export interface SecurityPolicyRuleMatch {
        config?: outputs.compute.SecurityPolicyRuleMatchConfig;
        expr?: outputs.compute.SecurityPolicyRuleMatchExpr;
        versionedExpr?: string;
    }

    export interface SecurityPolicyRuleMatchConfig {
        srcIpRanges: string[];
    }

    export interface SecurityPolicyRuleMatchExpr {
        expression: string;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: outputs.compute.SecurityScanConfigAuthenticationCustomAccount;
        googleAccount?: outputs.compute.SecurityScanConfigAuthenticationGoogleAccount;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: string;
        password: string;
        username: string;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: string;
        username: string;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: number;
        scheduleTime?: string;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey: string;
        sha256: string;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: string;
    }

    export interface SubnetworkIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubnetworkIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: string;
        flowSampling?: number;
        metadata?: string;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: string;
        rangeName: string;
    }

    export interface URLMapHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface URLMapPathMatcher {
        defaultService?: string;
        description?: string;
        headerAction?: outputs.compute.URLMapPathMatcherHeaderAction;
        name: string;
        pathRules?: outputs.compute.URLMapPathMatcherPathRule[];
        routeRules?: outputs.compute.URLMapPathMatcherRouteRule[];
    }

    export interface URLMapPathMatcherHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.URLMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherPathRuleUrlRedirect;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface URLMapPathMatcherRouteRule {
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.URLMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface URLMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        cloudrunConfig: outputs.container.ClusterAddonsConfigCloudrunConfig;
        dnsCacheConfig: outputs.container.ClusterAddonsConfigDnsCacheConfig;
        horizontalPodAutoscaling: outputs.container.ClusterAddonsConfigHorizontalPodAutoscaling;
        httpLoadBalancing: outputs.container.ClusterAddonsConfigHttpLoadBalancing;
        istioConfig: outputs.container.ClusterAddonsConfigIstioConfig;
        networkPolicyConfig: outputs.container.ClusterAddonsConfigNetworkPolicyConfig;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigDnsCacheConfig {
        enabled: boolean;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigIstioConfig {
        auth?: string;
        disabled: boolean;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface ClusterClusterAutoscaling {
        autoProvisioningDefaults: outputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults;
        autoscalingProfile?: string;
        enabled: boolean;
        resourceLimits?: outputs.container.ClusterClusterAutoscalingResourceLimit[];
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        oauthScopes: string[];
        serviceAccount?: string;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        maximum?: number;
        minimum?: number;
        resourceType: string;
    }

    export interface ClusterDatabaseEncryption {
        keyName?: string;
        state: string;
    }

    export interface ClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
    }

    export interface ClusterMaintenancePolicy {
        dailyMaintenanceWindow?: outputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow;
        recurringWindow?: outputs.container.ClusterMaintenancePolicyRecurringWindow;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface ClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfig: outputs.container.ClusterMasterAuthClientCertificateConfig;
        clientKey: string;
        clusterCaCertificate: string;
        password?: string;
        username?: string;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        cidrBlocks?: outputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName?: string;
    }

    export interface ClusterNetworkPolicy {
        enabled: boolean;
        provider?: string;
    }

    export interface ClusterNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.ClusterNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.ClusterNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterNodePool {
        autoscaling?: outputs.container.ClusterNodePoolAutoscaling;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount: number;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls: string[];
        management: outputs.container.ClusterNodePoolManagement;
        maxPodsPerNode: number;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name: string;
        namePrefix: string;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig: outputs.container.ClusterNodePoolNodeConfig;
        nodeCount: number;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations: string[];
        upgradeSettings: outputs.container.ClusterNodePoolUpgradeSettings;
        version: string;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface ClusterNodePoolNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.ClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterNodePoolUpgradeSettings {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface ClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface ClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes?: boolean;
        masterIpv4CidrBlock?: string;
        peeringName: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface ClusterReleaseChannel {
        channel: string;
    }

    export interface ClusterResourceUsageExportConfig {
        bigqueryDestination: outputs.container.ClusterResourceUsageExportConfigBigqueryDestination;
        enableNetworkEgressMetering?: boolean;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface ClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface ClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface GetClusterAddonsConfig {
        cloudrunConfigs: outputs.container.GetClusterAddonsConfigCloudrunConfig[];
        dnsCacheConfigs: outputs.container.GetClusterAddonsConfigDnsCacheConfig[];
        horizontalPodAutoscalings: outputs.container.GetClusterAddonsConfigHorizontalPodAutoscaling[];
        httpLoadBalancings: outputs.container.GetClusterAddonsConfigHttpLoadBalancing[];
        istioConfigs: outputs.container.GetClusterAddonsConfigIstioConfig[];
        kubernetesDashboards: outputs.container.GetClusterAddonsConfigKubernetesDashboard[];
        networkPolicyConfigs: outputs.container.GetClusterAddonsConfigNetworkPolicyConfig[];
    }

    export interface GetClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigDnsCacheConfig {
        enabled: boolean;
    }

    export interface GetClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigIstioConfig {
        auth: string;
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigKubernetesDashboard {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface GetClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface GetClusterClusterAutoscaling {
        autoProvisioningDefaults: outputs.container.GetClusterClusterAutoscalingAutoProvisioningDefault[];
        autoscalingProfile: string;
        enabled: boolean;
        resourceLimits: outputs.container.GetClusterClusterAutoscalingResourceLimit[];
    }

    export interface GetClusterClusterAutoscalingAutoProvisioningDefault {
        oauthScopes: string[];
        serviceAccount: string;
    }

    export interface GetClusterClusterAutoscalingResourceLimit {
        maximum: number;
        minimum: number;
        resourceType: string;
    }

    export interface GetClusterDatabaseEncryption {
        keyName: string;
        state: string;
    }

    export interface GetClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        nodeIpv4CidrBlock: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
        subnetworkName: string;
    }

    export interface GetClusterMaintenancePolicy {
        dailyMaintenanceWindows: outputs.container.GetClusterMaintenancePolicyDailyMaintenanceWindow[];
        recurringWindows: outputs.container.GetClusterMaintenancePolicyRecurringWindow[];
    }

    export interface GetClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface GetClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface GetClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfigs: outputs.container.GetClusterMasterAuthClientCertificateConfig[];
        clientKey: string;
        clusterCaCertificate: string;
        password: string;
        username: string;
    }

    export interface GetClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface GetClusterMasterAuthorizedNetworksConfig {
        cidrBlocks: outputs.container.GetClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface GetClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName: string;
    }

    export interface GetClusterNetworkPolicy {
        enabled: boolean;
        provider: string;
    }

    export interface GetClusterNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePool {
        autoscalings: outputs.container.GetClusterNodePoolAutoscaling[];
        initialNodeCount: number;
        instanceGroupUrls: string[];
        managements: outputs.container.GetClusterNodePoolManagement[];
        maxPodsPerNode: number;
        /**
         * The name of the cluster.
         */
        name: string;
        namePrefix: string;
        nodeConfigs: outputs.container.GetClusterNodePoolNodeConfig[];
        nodeCount: number;
        nodeLocations: string[];
        upgradeSettings: outputs.container.GetClusterNodePoolUpgradeSetting[];
        version: string;
    }

    export interface GetClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface GetClusterNodePoolManagement {
        autoRepair: boolean;
        autoUpgrade: boolean;
    }

    export interface GetClusterNodePoolNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodePoolNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodePoolNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodePoolNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePoolUpgradeSetting {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface GetClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface GetClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes: boolean;
        masterIpv4CidrBlock: string;
        peeringName: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface GetClusterReleaseChannel {
        channel: string;
    }

    export interface GetClusterResourceUsageExportConfig {
        bigqueryDestinations: outputs.container.GetClusterResourceUsageExportConfigBigqueryDestination[];
        enableNetworkEgressMetering: boolean;
    }

    export interface GetClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface GetClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface GetClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface NodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface NodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface NodePoolNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.NodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.NodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.NodePoolNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.NodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.NodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface NodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface NodePoolUpgradeSettings {
        maxSurge: number;
        maxUnavailable: number;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: outputs.containeranalysis.NoteAttestationAuthorityHint;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: string;
    }
}

export namespace datafusion {
    export interface InstanceNetworkConfig {
        ipAllocation: string;
        network: string;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: string;
        yarnConfig: outputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: string;
        scaleDownFactor: number;
        scaleDownMinWorkerFraction?: number;
        scaleUpFactor: number;
        scaleUpMinWorkerFraction?: number;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: number;
        minInstances?: number;
        weight?: number;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: number;
        minInstances?: number;
        weight?: number;
    }

    export interface ClusterClusterConfig {
        autoscalingConfig?: outputs.dataproc.ClusterClusterConfigAutoscalingConfig;
        bucket: string;
        encryptionConfig?: outputs.dataproc.ClusterClusterConfigEncryptionConfig;
        gceClusterConfig: outputs.dataproc.ClusterClusterConfigGceClusterConfig;
        initializationActions?: outputs.dataproc.ClusterClusterConfigInitializationAction[];
        lifecycleConfig?: outputs.dataproc.ClusterClusterConfigLifecycleConfig;
        masterConfig: outputs.dataproc.ClusterClusterConfigMasterConfig;
        preemptibleWorkerConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig;
        securityConfig?: outputs.dataproc.ClusterClusterConfigSecurityConfig;
        softwareConfig: outputs.dataproc.ClusterClusterConfigSoftwareConfig;
        stagingBucket?: string;
        workerConfig: outputs.dataproc.ClusterClusterConfigWorkerConfig;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        policyUri: string;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        kmsKeyName: string;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        internalIpOnly?: boolean;
        metadata?: {[key: string]: string};
        network: string;
        serviceAccount?: string;
        serviceAccountScopes: string[];
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: string;
        timeoutSec?: number;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        autoDeleteTime?: string;
        idleDeleteTtl?: string;
        idleStartTime: string;
    }

    export interface ClusterClusterConfigMasterConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigMasterConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        diskConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig;
        instanceNames: string[];
        numInstances: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigSecurityConfig {
        kerberosConfig: outputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        crossRealmTrustAdminServer?: string;
        crossRealmTrustKdc?: string;
        crossRealmTrustRealm?: string;
        crossRealmTrustSharedPasswordUri?: string;
        enableKerberos?: boolean;
        kdcDbKeyUri?: string;
        keyPasswordUri?: string;
        keystorePasswordUri?: string;
        keystoreUri?: string;
        kmsKeyUri: string;
        realm?: string;
        rootPrincipalPasswordUri: string;
        tgtLifetimeHours?: number;
        truststorePasswordUri?: string;
        truststoreUri?: string;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        imageVersion: string;
        optionalComponents?: string[];
        overrideProperties?: {[key: string]: string};
        properties: {[key: string]: any};
    }

    export interface ClusterClusterConfigWorkerConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ClusterIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobHadoopConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobHadoopConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobHiveConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobPigConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPigConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobPlacement {
        clusterName: string;
        clusterUuid: string;
    }

    export interface JobPysparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPysparkConfigLoggingConfig;
        mainPythonFileUri: string;
        properties?: {[key: string]: string};
        pythonFileUris?: string[];
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobReference {
        jobId: string;
    }

    export interface JobScheduling {
        maxFailuresPerHour: number;
    }

    export interface JobSparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparkConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobSparksqlConfig {
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparksqlConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobStatus {
        details: string;
        state: string;
        stateStartTime: string;
        substate: string;
    }
}

export namespace datastore {
    export interface DataStoreIndexProperty {
        direction: string;
        name: string;
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        key?: string;
        value?: string;
    }

    export interface DeploymentTarget {
        config: outputs.deploymentmanager.DeploymentTargetConfig;
        imports?: outputs.deploymentmanager.DeploymentTargetImport[];
    }

    export interface DeploymentTargetConfig {
        content: string;
    }

    export interface DeploymentTargetImport {
        content?: string;
        name?: string;
    }
}

export namespace dns {
    export interface GetKeysKeySigningKey {
        /**
         * String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
         */
        algorithm: string;
        /**
         * The time that this resource was created in the control plane. This is in RFC3339 text format.
         */
        creationTime: string;
        /**
         * A mutable string of at most 1024 characters associated with this resource for the user's convenience.
         */
        description: string;
        /**
         * A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
         * - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
         * - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
         */
        digests: outputs.dns.GetKeysKeySigningKeyDigest[];
        /**
         * The DS record based on the KSK record. This is used when [delegating](https://cloud.google.com/dns/docs/dnssec-advanced#subdelegation) DNSSEC-signed subdomains.
         */
        dsRecord: string;
        /**
         * Unique identifier for the resource; defined by the server.
         */
        id: string;
        /**
         * Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
         */
        isActive: boolean;
        /**
         * Length of the key in bits. Specified at creation time then immutable.
         */
        keyLength: number;
        /**
         * The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
         */
        keyTag: number;
        /**
         * Base64 encoded public half of this key.
         */
        publicKey: string;
    }

    export interface GetKeysKeySigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface GetKeysZoneSigningKey {
        /**
         * String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
         */
        algorithm: string;
        /**
         * The time that this resource was created in the control plane. This is in RFC3339 text format.
         */
        creationTime: string;
        /**
         * A mutable string of at most 1024 characters associated with this resource for the user's convenience.
         */
        description: string;
        /**
         * A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
         * - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
         * - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
         */
        digests: outputs.dns.GetKeysZoneSigningKeyDigest[];
        /**
         * Unique identifier for the resource; defined by the server.
         */
        id: string;
        /**
         * Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
         */
        isActive: boolean;
        /**
         * Length of the key in bits. Specified at creation time then immutable.
         */
        keyLength: number;
        /**
         * The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
         */
        keyTag: number;
        /**
         * Base64 encoded public half of this key.
         */
        publicKey: string;
    }

    export interface GetKeysZoneSigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs: outputs.dns.ManagedZoneDnssecConfigDefaultKeySpec[];
        kind?: string;
        nonExistence: string;
        state?: string;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: string;
        keyLength?: number;
        keyType?: string;
        kind?: string;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers: outputs.dns.ManagedZoneForwardingConfigTargetNameServer[];
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        forwardingPath?: string;
        ipv4Address: string;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork: outputs.dns.ManagedZonePeeringConfigTargetNetwork;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl: string;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks: outputs.dns.ManagedZonePrivateVisibilityConfigNetwork[];
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl: string;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers: outputs.dns.PolicyAlternativeNameServerConfigTargetNameServer[];
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address: string;
    }

    export interface PolicyNetwork {
        networkUrl: string;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods: outputs.endpoints.ServiceApiMethod[];
        name: string;
        syntax: string;
        version: string;
    }

    export interface ServiceApiMethod {
        name: string;
        requestType: string;
        responseType: string;
        syntax: string;
    }

    export interface ServiceEndpoint {
        address: string;
        name: string;
    }

    export interface ServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: number;
        name: string;
    }

    export interface InstanceNetwork {
        ipAddresses: string[];
        modes: string[];
        network: string;
        reservedIpRange: string;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: string;
        fieldPath?: string;
        order?: string;
    }
}

export namespace folder {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.folder.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.folder.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.folder.OrganizationPolicyListPolicyAllow;
        deny?: outputs.folder.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace gameservices {
    export interface GameServerClusterConnectionInfo {
        gkeClusterReference: outputs.gameservices.GameServerClusterConnectionInfoGkeClusterReference;
        namespace: string;
    }

    export interface GameServerClusterConnectionInfoGkeClusterReference {
        cluster: string;
    }

    export interface GameServerConfigFleetConfig {
        fleetSpec: string;
        name: string;
    }

    export interface GameServerConfigScalingConfig {
        fleetAutoscalerSpec: string;
        name: string;
        schedules?: outputs.gameservices.GameServerConfigScalingConfigSchedule[];
        selectors?: outputs.gameservices.GameServerConfigScalingConfigSelector[];
    }

    export interface GameServerConfigScalingConfigSchedule {
        cronJobDuration?: string;
        cronSpec?: string;
        endTime?: string;
        startTime?: string;
    }

    export interface GameServerConfigScalingConfigSelector {
        labels?: {[key: string]: string};
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverride {
        configVersion?: string;
        realmsSelector?: outputs.gameservices.GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector {
        realms?: string[];
    }
}

export namespace healthcare {
    export interface DatasetIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatasetIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface FhirStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: boolean;
        segmentTerminator?: string;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineVersionIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineVersionIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TunnelInstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TunnelInstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebBackendServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebBackendServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeComputeIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeComputeIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace identityplatform {
    export interface InboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface InboundSamlConfigSpConfig {
        callbackUri?: string;
        spCertificates: outputs.identityplatform.InboundSamlConfigSpConfigSpCertificate[];
        spEntityId?: string;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface TenantInboundSamlConfigSpConfig {
        callbackUri: string;
        spCertificates: outputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate[];
        spEntityId: string;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface CryptoKeyIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface CryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel?: string;
    }

    export interface GetKMSCryptoKeyVersionPublicKey {
        /**
         * The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
         */
        algorithm: string;
        /**
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem: string;
    }

    export interface GetKMSCryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel: string;
    }

    export interface KeyRingIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface KeyRingIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RegistryCredential {
        publicKeyCertificate: outputs.kms.RegistryCredentialPublicKeyCertificate;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        certificate: string;
        format: string;
    }

    export interface RegistryEventNotificationConfigItem {
        pubsubTopicName: string;
        subfolderMatches?: string;
    }

    export interface RegistryHttpConfig {
        httpEnabledState: string;
    }

    export interface RegistryMqttConfig {
        mqttEnabledState: string;
    }

    export interface RegistryStateNotificationConfig {
        pubsubTopicName: string;
    }
}

export namespace logging {
    export interface BillingAccountSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface FolderSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface MetricBucketOptions {
        explicitBuckets?: outputs.logging.MetricBucketOptionsExplicitBuckets;
        exponentialBuckets?: outputs.logging.MetricBucketOptionsExponentialBuckets;
        linearBuckets?: outputs.logging.MetricBucketOptionsLinearBuckets;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds: number[];
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: number;
        numFiniteBuckets?: number;
        scale?: number;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: number;
        offset?: number;
        width?: number;
    }

    export interface MetricMetricDescriptor {
        displayName?: string;
        labels?: outputs.logging.MetricMetricDescriptorLabel[];
        metricKind: string;
        unit?: string;
        valueType: string;
    }

    export interface MetricMetricDescriptorLabel {
        description?: string;
        key: string;
        valueType?: string;
    }

    export interface OrganizationSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface ProjectSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name: string;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: outputs.monitoring.AlertPolicyConditionConditionAbsent;
        conditionThreshold?: outputs.monitoring.AlertPolicyConditionConditionThreshold;
        displayName: string;
        name: string;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionAbsentAggregation[];
        duration: string;
        filter?: string;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionAbsentTrigger;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdAggregation[];
        comparison: string;
        denominatorAggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation[];
        denominatorFilter?: string;
        duration: string;
        filter?: string;
        thresholdValue?: number;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionThresholdTrigger;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime: string;
        mutatedBy: string;
    }

    export interface AlertPolicyDocumentation {
        content?: string;
        mimeType?: string;
    }

    export interface GetNotificationChannelSensitiveLabel {
        authToken: string;
        password: string;
        serviceKey: string;
    }

    export interface NotificationChannelSensitiveLabels {
        authToken?: string;
        password?: string;
        serviceKey?: string;
    }

    export interface UptimeCheckConfigContentMatcher {
        content: string;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: outputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo;
        headers?: {[key: string]: string};
        maskHeaders?: boolean;
        path?: string;
        port: number;
        useSsl?: boolean;
        validateSsl?: boolean;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password: string;
        username: string;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: {[key: string]: string};
        type: string;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: string;
        resourceType?: string;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: number;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: outputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        condition?: outputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamAuditConfigAuditLogConfig {
        exemptedMembers?: string[];
        logType: string;
    }

    export interface PolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface PolicyListPolicy {
        allow?: outputs.organizations.PolicyListPolicyAllow;
        deny?: outputs.organizations.PolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface PolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyRestorePolicy {
        default: boolean;
    }
}

export namespace projects {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.projects.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.projects.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface GetProjectProject {
        /**
         * The project id of the project.
         */
        projectId: string;
    }

    export interface IAMAuditConfigAuditLogConfig {
        exemptedMembers?: string[];
        logType: string;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.projects.OrganizationPolicyListPolicyAllow;
        deny?: outputs.projects.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace pubsub {
    export interface SubscriptionExpirationPolicy {
        ttl: string;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionPushConfig {
        attributes?: {[key: string]: string};
        oidcToken?: outputs.pubsub.SubscriptionPushConfigOidcToken;
        pushEndpoint: string;
    }

    export interface SubscriptionPushConfigOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface TopicIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: string[];
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ConfigIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace secretmanager {
    export interface SecretIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretReplication {
        automatic?: boolean;
        userManaged?: outputs.secretmanager.SecretReplicationUserManaged;
    }

    export interface SecretReplicationUserManaged {
        replicas: outputs.secretmanager.SecretReplicationUserManagedReplica[];
    }

    export interface SecretReplicationUserManagedReplica {
        location: string;
    }
}

export namespace serviceAccount {
    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryPubsubConfig {
        messageFormat: string;
        serviceAccountEmail: string;
        topic: string;
    }
}

export namespace spanner {
    export interface DatabaseIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatabaseIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress: string;
        timeToRetire: string;
        type: string;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        caCertificate?: string;
        clientCertificate?: string;
        clientKey?: string;
        connectRetryInterval?: number;
        dumpFilePath?: string;
        failoverTarget?: boolean;
        masterHeartbeatPeriod?: number;
        password?: string;
        sslCipher?: string;
        username?: string;
        verifyServerCertificate?: boolean;
    }

    export interface DatabaseInstanceServerCaCert {
        cert: string;
        commonName: string;
        createTime: string;
        expirationTime: string;
        sha1Fingerprint: string;
    }

    export interface DatabaseInstanceSettings {
        activationPolicy: string;
        authorizedGaeApplications?: string[];
        availabilityType: string;
        backupConfiguration: outputs.sql.DatabaseInstanceSettingsBackupConfiguration;
        crashSafeReplication: boolean;
        databaseFlags?: outputs.sql.DatabaseInstanceSettingsDatabaseFlag[];
        diskAutoresize?: boolean;
        diskSize: number;
        diskType: string;
        ipConfiguration: outputs.sql.DatabaseInstanceSettingsIpConfiguration;
        locationPreference: outputs.sql.DatabaseInstanceSettingsLocationPreference;
        maintenanceWindow?: outputs.sql.DatabaseInstanceSettingsMaintenanceWindow;
        pricingPlan?: string;
        replicationType?: string;
        tier: string;
        userLabels?: {[key: string]: string};
        version: number;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        binaryLogEnabled?: boolean;
        enabled?: boolean;
        location?: string;
        startTime: string;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * The name of the instance. If the name is left
         * blank, the provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name: string;
        value: string;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: outputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork[];
        ipv4Enabled: boolean;
        privateNetwork?: string;
        requireSsl?: boolean;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        expirationTime?: string;
        /**
         * The name of the instance. If the name is left
         * blank, the provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: string;
        value: string;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        followGaeApplication?: string;
        zone?: string;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        day?: number;
        hour?: number;
        updateTrack?: string;
    }

    export interface GetCaCertsCert {
        /**
         * The CA certificate used to connect to the SQL instance via SSL.
         */
        cert: string;
        /**
         * The CN valid for the CA cert.
         */
        commonName: string;
        /**
         * Creation time of the CA cert.
         */
        createTime: string;
        /**
         * Expiration time of the CA cert.
         */
        expirationTime: string;
        /**
         * SHA1 fingerprint of the CA cert.
         */
        sha1Fingerprint: string;
    }
}

export namespace storage {
    export interface BucketCor {
        maxAgeSeconds?: number;
        methods?: string[];
        origins?: string[];
        responseHeaders?: string[];
    }

    export interface BucketEncryption {
        defaultKmsKeyName: string;
    }

    export interface BucketIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BucketIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BucketLifecycleRule {
        action: outputs.storage.BucketLifecycleRuleAction;
        condition: outputs.storage.BucketLifecycleRuleCondition;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of the new bucket. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: string;
        type: string;
    }

    export interface BucketLifecycleRuleCondition {
        age?: number;
        createdBefore?: string;
        matchesStorageClasses?: string[];
        numNewerVersions?: number;
        withState: string;
    }

    export interface BucketLogging {
        logBucket: string;
        logObjectPrefix: string;
    }

    export interface BucketRetentionPolicy {
        isLocked?: boolean;
        retentionPeriod: number;
    }

    export interface BucketVersioning {
        enabled: boolean;
    }

    export interface BucketWebsite {
        mainPageSuffix?: string;
        notFoundPage?: string;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface TransferJobSchedule {
        scheduleEndDate?: outputs.storage.TransferJobScheduleScheduleEndDate;
        scheduleStartDate: outputs.storage.TransferJobScheduleScheduleStartDate;
        startTimeOfDay?: outputs.storage.TransferJobScheduleStartTimeOfDay;
    }

    export interface TransferJobScheduleScheduleEndDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleScheduleStartDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        hours: number;
        minutes: number;
        nanos: number;
        seconds: number;
    }

    export interface TransferJobTransferSpec {
        awsS3DataSource?: outputs.storage.TransferJobTransferSpecAwsS3DataSource;
        gcsDataSink?: outputs.storage.TransferJobTransferSpecGcsDataSink;
        gcsDataSource?: outputs.storage.TransferJobTransferSpecGcsDataSource;
        httpDataSource?: outputs.storage.TransferJobTransferSpecHttpDataSource;
        objectConditions?: outputs.storage.TransferJobTransferSpecObjectConditions;
        transferOptions?: outputs.storage.TransferJobTransferSpecTransferOptions;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        awsAccessKey: outputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey;
        bucketName: string;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        accessKeyId: string;
        secretAccessKey: string;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        bucketName: string;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        bucketName: string;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        listUrl: string;
    }

    export interface TransferJobTransferSpecObjectConditions {
        excludePrefixes?: string[];
        includePrefixes?: string[];
        maxTimeElapsedSinceLastModification?: string;
        minTimeElapsedSinceLastModification?: string;
    }

    export interface TransferJobTransferSpecTransferOptions {
        deleteObjectsFromSourceAfterTransfer?: boolean;
        deleteObjectsUniqueInSink?: boolean;
        overwriteObjectsAlreadyExistingInSink?: boolean;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress: string;
        port: number;
    }

    export interface NodeSchedulingConfig {
        preemptible: boolean;
    }
}
