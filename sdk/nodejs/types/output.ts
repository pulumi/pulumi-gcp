// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";


export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: string;
        conditions: outputs.accesscontextmanager.AccessLevelBasicCondition[];
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy;
        ipSubnetworks?: string[];
        members?: string[];
        negate?: boolean;
        requiredAccessLevels?: string[];
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: string[];
        allowedEncryptionStatuses?: string[];
        osConstraints?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint[];
        requireAdminApproval?: boolean;
        requireCorpOwned?: boolean;
        requireScreenLock?: boolean;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: string;
        osType: string;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: string[];
        resources?: string[];
        restrictedServices?: string[];
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: boolean;
    }

    export interface ApplicationIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface ApplicationUrlDispatchRule {
        domain: string;
        path: string;
        service: string;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        domain?: string;
        path: string;
        service: string;
    }

    export interface DomainMappingResourceRecord {
        name?: string;
        rrdata?: string;
        type?: string;
    }

    export interface DomainMappingSslSettings {
        certificateId: string;
        pendingManagedCertificateId: string;
        sslManagementType: string;
    }

    export interface EngineSplitTrafficSplit {
        allocations: {[key: string]: string};
        shardBy?: string;
    }

    export interface StandardAppVersionDeployment {
        files?: outputs.appengine.StandardAppVersionDeploymentFile[];
        zip?: outputs.appengine.StandardAppVersionDeploymentZip;
    }

    export interface StandardAppVersionDeploymentFile {
        name: string;
        sha1Sum?: string;
        sourceUrl: string;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: number;
        sourceUrl: string;
    }

    export interface StandardAppVersionEntrypoint {
        shell: string;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: string;
        login?: string;
        redirectHttpResponseCode?: string;
        script?: outputs.appengine.StandardAppVersionHandlerScript;
        securityLevel?: string;
        staticFiles?: outputs.appengine.StandardAppVersionHandlerStaticFiles;
        urlRegex?: string;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath: string;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: boolean;
        expiration?: string;
        httpHeaders?: {[key: string]: string};
        mimeType?: string;
        path?: string;
        requireMatchingFile?: boolean;
        uploadPathRegex?: string;
    }

    export interface StandardAppVersionLibrary {
        name?: string;
        version?: string;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: boolean;
        clusterId: string;
    }

    export interface DatasetAccess {
        domain?: string;
        groupByEmail?: string;
        role?: string;
        specialGroup?: string;
        userByEmail?: string;
        view?: outputs.bigquery.DatasetAccessView;
    }

    export interface DatasetAccessView {
        datasetId: string;
        projectId: string;
        tableId: string;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        kmsKeyName: string;
    }

    export interface TableEncryptionConfiguration {
        kmsKeyName: string;
    }

    export interface TableExternalDataConfiguration {
        autodetect: boolean;
        compression?: string;
        csvOptions?: outputs.bigquery.TableExternalDataConfigurationCsvOptions;
        googleSheetsOptions?: outputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions;
        ignoreUnknownValues?: boolean;
        maxBadRecords?: number;
        sourceFormat: string;
        sourceUris: string[];
    }

    export interface TableExternalDataConfigurationCsvOptions {
        allowJaggedRows?: boolean;
        allowQuotedNewlines?: boolean;
        encoding?: string;
        fieldDelimiter?: string;
        quote: string;
        skipLeadingRows?: number;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        range?: string;
        skipLeadingRows?: number;
    }

    export interface TableRangePartitioning {
        field: string;
        range: outputs.bigquery.TableRangePartitioningRange;
    }

    export interface TableRangePartitioningRange {
        end: number;
        interval: number;
        start: number;
    }

    export interface TableTimePartitioning {
        expirationMs?: number;
        field?: string;
        requirePartitionFilter?: boolean;
        /**
         * Describes the table type.
         */
        type: string;
    }

    export interface TableView {
        query: string;
        useLegacySql?: boolean;
    }
}

export namespace bigtable {
    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         */
        days: number;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         */
        number: number;
    }

    export interface InstanceCluster {
        clusterId: string;
        numNodes: number;
        storageType?: string;
        zone: string;
    }

    export interface InstanceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: string;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AccountIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BudgetAllUpdatesRule {
        pubsubTopic: string;
        schemaVersion?: string;
    }

    export interface BudgetAmount {
        specifiedAmount: outputs.billing.BudgetAmountSpecifiedAmount;
    }

    export interface BudgetAmountSpecifiedAmount {
        currencyCode?: string;
        nanos?: number;
        units?: string;
    }

    export interface BudgetBudgetFilter {
        creditTypesTreatment?: string;
        projects?: string[];
        services?: string[];
    }

    export interface BudgetThresholdRule {
        spendBasis?: string;
        thresholdPercent: number;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail: string;
        noteReference: string;
        publicKeys?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey[];
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: string;
        comment?: string;
        /**
         * an identifier for the resource with format `projects/{{project}}/attestors/{{name}}`
         */
        id: string;
        pkixPublicKey?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: string;
        signatureAlgorithm?: string;
    }

    export interface AttestorIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AttestorIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern: string;
    }

    export interface PolicyClusterAdmissionRule {
        cluster: string;
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: string[];
        steps: outputs.cloudbuild.TriggerBuildStep[];
        tags?: string[];
        timeout?: string;
    }

    export interface TriggerBuildStep {
        args?: string[];
        dir?: string;
        entrypoint?: string;
        envs?: string[];
        /**
         * an identifier for the resource with format `projects/{{project}}/triggers/{{trigger_id}}`
         */
        id?: string;
        name: string;
        secretEnvs?: string[];
        timeout?: string;
        timing?: string;
        volumes?: outputs.cloudbuild.TriggerBuildStepVolume[];
        waitFors?: string[];
    }

    export interface TriggerBuildStepVolume {
        name: string;
        path: string;
    }

    export interface TriggerGithub {
        name?: string;
        owner?: string;
        pullRequest?: outputs.cloudbuild.TriggerGithubPullRequest;
        push?: outputs.cloudbuild.TriggerGithubPush;
    }

    export interface TriggerGithubPullRequest {
        branch: string;
        commentControl?: string;
    }

    export interface TriggerGithubPush {
        branch?: string;
        tag?: string;
    }

    export interface TriggerTriggerTemplate {
        branchName?: string;
        commitSha?: string;
        dir?: string;
        projectId: string;
        repoName?: string;
        tagName?: string;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        eventType: string;
        failurePolicy: outputs.cloudfunctions.FunctionEventTriggerFailurePolicy;
        resource: string;
    }

    export interface FunctionEventTriggerFailurePolicy {
        retry: boolean;
    }

    export interface FunctionIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }

    export interface GetFunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/)
         * for a full reference of accepted triggers.
         */
        eventType: string;
        /**
         * Policy for failed executions. Structure is documented below.
         */
        failurePolicies: outputs.cloudfunctions.GetFunctionEventTriggerFailurePolicy[];
        /**
         * The name of the resource whose events are being observed, for example, `"myBucket"`
         */
        resource: string;
    }

    export interface GetFunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure.
         */
        retry: boolean;
    }

    export interface GetFunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface DomainMappingSpec {
        certificateMode?: string;
        forceOverride?: boolean;
        routeName: string;
    }

    export interface DomainMappingStatus {
        conditions: outputs.cloudrun.DomainMappingStatusCondition[];
        mappedRouteName: string;
        observedGeneration: number;
        resourceRecords?: outputs.cloudrun.DomainMappingStatusResourceRecord[];
    }

    export interface DomainMappingStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface DomainMappingStatusResourceRecord {
        name: string;
        rrdata: string;
        type?: string;
    }

    export interface IamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceStatus {
        conditions: outputs.cloudrun.ServiceStatusCondition[];
        latestCreatedRevisionName: string;
        latestReadyRevisionName: string;
        observedGeneration: number;
        url: string;
    }

    export interface ServiceStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface ServiceTemplate {
        metadata: outputs.cloudrun.ServiceTemplateMetadata;
        spec: outputs.cloudrun.ServiceTemplateSpec;
    }

    export interface ServiceTemplateMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels?: {[key: string]: string};
        name: string;
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceTemplateSpec {
        containerConcurrency: number;
        containers: outputs.cloudrun.ServiceTemplateSpecContainer[];
        serviceAccountName?: string;
        servingState: string;
    }

    export interface ServiceTemplateSpecContainer {
        args?: string[];
        commands?: string[];
        envs?: outputs.cloudrun.ServiceTemplateSpecContainerEnv[];
        envFroms?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFrom[];
        image: string;
        resources: outputs.cloudrun.ServiceTemplateSpecContainerResources;
        workingDir?: string;
    }

    export interface ServiceTemplateSpecContainerEnv {
        name?: string;
        value?: string;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        configMapRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef;
        prefix?: string;
        secretRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerResources {
        limits: {[key: string]: string};
        requests?: {[key: string]: string};
    }

    export interface ServiceTraffic {
        latestRevision?: boolean;
        percent: number;
        revisionName?: string;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: outputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting;
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        relativeUri: string;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface JobHttpTarget {
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        oauthToken?: outputs.cloudscheduler.JobHttpTargetOauthToken;
        oidcToken?: outputs.cloudscheduler.JobHttpTargetOidcToken;
        uri: string;
    }

    export interface JobHttpTargetOauthToken {
        scope?: string;
        serviceAccountEmail: string;
    }

    export interface JobHttpTargetOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface JobPubsubTarget {
        attributes?: {[key: string]: string};
        data?: string;
        topicName: string;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: string;
        maxDoublings?: number;
        maxRetryDuration?: string;
        minBackoffDuration?: string;
        retryCount?: number;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        host: string;
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface QueueRateLimits {
        maxBurstSize: number;
        maxConcurrentDispatches: number;
        maxDispatchesPerSecond: number;
    }

    export interface QueueRetryConfig {
        maxAttempts: number;
        maxBackoff: string;
        maxDoublings: number;
        maxRetryDuration: string;
        minBackoff: string;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri: string;
        dagGcsPrefix: string;
        gkeCluster: string;
        nodeConfig: outputs.composer.EnvironmentConfigNodeConfig;
        nodeCount: number;
        privateEnvironmentConfig: outputs.composer.EnvironmentConfigPrivateEnvironmentConfig;
        softwareConfig: outputs.composer.EnvironmentConfigSoftwareConfig;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb: number;
        ipAllocationPolicy: outputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy;
        machineType: string;
        network: string;
        oauthScopes: string[];
        serviceAccount: string;
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: string;
        clusterSecondaryRangeName?: string;
        servicesIpv4CidrBlock?: string;
        servicesSecondaryRangeName?: string;
        useIpAliases: boolean;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: boolean;
        masterIpv4CidrBlock?: string;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: {[key: string]: string};
        envVariables?: {[key: string]: string};
        imageVersion: string;
        pypiPackages?: {[key: string]: string};
        pythonVersion: string;
    }

    export interface GetImageVersionsImageVersion {
        /**
         * The string identifier of the image version, in the form: "composer-x.y.z-airflow-a.b(.c)"
         */
        imageVersionId: string;
        /**
         * Supported python versions for this image version
         */
        supportedPythonVersions: string[];
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.AutoscalarAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.AutoscalarAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: number;
    }

    export interface BackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: outputs.compute.BackendServiceCdnPolicyCacheKeyPolicy;
        signedUrlCacheMaxAgeSec?: number;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: boolean;
        includeProtocol?: boolean;
        includeQueryString?: boolean;
        queryStringBlacklists?: string[];
        queryStringWhitelists?: string[];
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.BackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: outputs.compute.BackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.BackendServiceConsistentHashHttpCookieTtl;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface BackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.BackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.BackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/global/externalVpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface FirewallAllow {
        ports?: string[];
        protocol: string;
    }

    export interface FirewallDeny {
        ports?: string[];
        protocol: string;
    }

    export interface GetBackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceBackend {
        balancingMode: string;
        capacityScaler: number;
        /**
         * Textual description for the Backend Service.
         */
        description: string;
        group: string;
        maxConnections: number;
        maxConnectionsPerEndpoint: number;
        maxConnectionsPerInstance: number;
        maxRate: number;
        maxRatePerEndpoint: number;
        maxRatePerInstance: number;
        maxUtilization: number;
    }

    export interface GetBackendServiceCdnPolicy {
        cacheKeyPolicies: outputs.compute.GetBackendServiceCdnPolicyCacheKeyPolicy[];
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceCdnPolicyCacheKeyPolicy {
        includeHost: boolean;
        includeProtocol: boolean;
        includeQueryString: boolean;
        queryStringBlacklists: string[];
        queryStringWhitelists: string[];
    }

    export interface GetBackendServiceCircuitBreaker {
        connectTimeouts: outputs.compute.GetBackendServiceCircuitBreakerConnectTimeout[];
        maxConnections: number;
        maxPendingRequests: number;
        maxRequests: number;
        maxRequestsPerConnection: number;
        maxRetries: number;
    }

    export interface GetBackendServiceCircuitBreakerConnectTimeout {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceConsistentHash {
        httpCookies: outputs.compute.GetBackendServiceConsistentHashHttpCooky[];
        httpHeaderName: string;
        minimumRingSize: number;
    }

    export interface GetBackendServiceConsistentHashHttpCooky {
        /**
         * The name of the Backend Service.
         */
        name: string;
        path: string;
        ttls: outputs.compute.GetBackendServiceConsistentHashHttpCookyTtl[];
    }

    export interface GetBackendServiceConsistentHashHttpCookyTtl {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface GetBackendServiceLogConfig {
        enable: boolean;
        sampleRate: number;
    }

    export interface GetBackendServiceOutlierDetection {
        baseEjectionTimes: outputs.compute.GetBackendServiceOutlierDetectionBaseEjectionTime[];
        consecutiveErrors: number;
        consecutiveGatewayFailure: number;
        enforcingConsecutiveErrors: number;
        enforcingConsecutiveGatewayFailure: number;
        enforcingSuccessRate: number;
        intervals: outputs.compute.GetBackendServiceOutlierDetectionInterval[];
        maxEjectionPercent: number;
        successRateMinimumHosts: number;
        successRateRequestVolume: number;
        successRateStdevFactor: number;
    }

    export interface GetBackendServiceOutlierDetectionBaseEjectionTime {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceOutlierDetectionInterval {
        nanos: number;
        seconds: number;
    }

    export interface GetInstanceAttachedDisk {
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete: boolean;
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        /**
         * Parameters with which a disk was created alongside the instance.
         * Structure is documented below.
         */
        initializeParams: outputs.compute.GetInstanceBootDiskInitializeParam[];
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDiskInitializeParam {
        /**
         * The image from which this disk was initialised.
         */
        image: string;
        /**
         * A set of key/value label pairs assigned to the instance.
         */
        labels: {[key: string]: any};
        /**
         * The size of the image in gigabytes.
         */
        size: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceGroupNamedPort {
        /**
         * The name of the instance group. Either `name` or `selfLink` must be provided.
         */
        name: string;
        port: number;
    }

    export interface GetInstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Structure documented below.
         */
        accessConfigs: outputs.compute.GetInstanceNetworkInterfaceAccessConfig[];
        /**
         * An array of alias IP ranges for this network interface. Structure documented below.
         */
        aliasIpRanges: outputs.compute.GetInstanceNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance. One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network: string;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp: string;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork: string;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject: string;
    }

    export interface GetInstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that is be 1:1 mapped to the instance's
         * network ip.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
         */
        networkTier: string;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName: string;
    }

    export interface GetInstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range.
         */
        subnetworkRangeName: string;
    }

    export interface GetInstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.GetInstanceSchedulingNodeAffinity[];
        /**
         * Describes maintenance behavior for the
         * instance. One of `MIGRATE` or `TERMINATE`, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
         */
        onHostMaintenance: string;
        /**
         * Whether the instance is preemptible.
         */
        preemptible: boolean;
    }

    export interface GetInstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface GetInstanceScratchDisk {
        /**
         * The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
         */
        interface: string;
    }

    export interface GetInstanceServiceAccount {
        /**
         * The service account e-mail address.
         */
        email: string;
        /**
         * A list of service scopes.
         */
        scopes: string[];
    }

    export interface GetInstanceShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface GetRegionInstanceGroupInstance {
        /**
         * URL to the instance.
         */
        instance: string;
        /**
         * List of named ports in the group, as a list of resources, each containing:
         */
        namedPorts: outputs.compute.GetRegionInstanceGroupInstanceNamedPort[];
        /**
         * String description of current state of the instance.
         */
        status: string;
    }

    export interface GetRegionInstanceGroupInstanceNamedPort {
        /**
         * The name of the instance group.  One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * Integer port number
         */
        port: number;
    }

    export interface GetRouterBgp {
        advertiseMode: string;
        advertisedGroups: string[];
        advertisedIpRanges: outputs.compute.GetRouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface GetRouterBgpAdvertisedIpRange {
        description: string;
        range: string;
    }

    export interface GetSubnetworkSecondaryIpRange {
        /**
         * The range of IP addresses belonging to this subnetwork
         * secondary range.
         */
        ipCidrRange: string;
        /**
         * The name associated with this subnetwork secondary range, used
         * when adding an alias IP range to a VM instance.
         */
        rangeName: string;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: outputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface ImageGuestOsFeature {
        type: string;
    }

    export interface ImageRawDisk {
        containerType?: string;
        sha1?: string;
        source: string;
    }

    export interface InstanceAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDisk {
        autoDelete?: boolean;
        deviceName: string;
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode?: string;
        source: string;
    }

    export interface InstanceBootDiskInitializeParams {
        image: string;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete: boolean;
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceFromTemplateBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image: string;
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs: outputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges: outputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.InstanceFromTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible: boolean;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: string;
    }

    export interface InstanceFromTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface InstanceGroupManagerVersion {
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.InstanceGroupManagerVersionTargetSize;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name of the instance group. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface InstanceGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceNetworkInterface {
        accessConfigs?: outputs.compute.InstanceNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName?: string;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceScratchDisk {
        interface: string;
    }

    export interface InstanceServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InstanceTemplateDisk {
        autoDelete?: boolean;
        boot: boolean;
        deviceName: string;
        diskEncryptionKey?: outputs.compute.InstanceTemplateDiskDiskEncryptionKey;
        diskName?: string;
        diskSizeGb?: number;
        diskType: string;
        interface: string;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: {[key: string]: string};
        mode: string;
        source?: string;
        sourceImage: string;
        type: string;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        kmsKeySelfLink: string;
    }

    export interface InstanceTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceTemplateNetworkInterface {
        accessConfigs?: outputs.compute.InstanceTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange[];
        network: string;
        networkIp?: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName?: string;
    }

    export interface InstanceTemplateScheduling {
        automaticRestart?: boolean;
        nodeAffinities?: outputs.compute.InstanceTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible?: boolean;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
        enableVtpm?: boolean;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q: number;
    }

    export interface ManagedSslCertificateManaged {
        domains: string[];
    }

    export interface MangedSslCertificateManaged {
        domains: string[];
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: string;
        localSsd: string;
        memory?: string;
    }

    export interface NodeTemplateServerBinding {
        type: string;
    }

    export interface PacketMirroringCollectorIlb {
        url: string;
    }

    export interface PacketMirroringFilter {
        cidrRanges?: string[];
        ipProtocols?: string[];
    }

    export interface PacketMirroringMirroredResources {
        instances?: outputs.compute.PacketMirroringMirroredResourcesInstance[];
        subnetworks?: outputs.compute.PacketMirroringMirroredResourcesSubnetwork[];
        tags?: string[];
    }

    export interface PacketMirroringMirroredResourcesInstance {
        url: string;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        url: string;
    }

    export interface PacketMirroringNetwork {
        url: string;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.RegionAutoscalerAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface RegionBackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        failover: boolean;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface RegionBackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceConsistentHash {
        httpCookie?: outputs.compute.RegionBackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: boolean;
        dropTrafficIfUnhealthy?: boolean;
        failoverRatio?: number;
    }

    export interface RegionBackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface RegionBackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.RegionBackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        healthCheck: string;
        initialDelaySec: number;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name: string;
        port: number;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        instanceRedistributionType?: string;
        maxSurgeFixed: number;
        maxSurgePercent?: number;
        maxUnavailableFixed: number;
        maxUnavailablePercent?: number;
        minReadySec?: number;
        minimalAction: string;
        type: string;
    }

    export interface RegionInstanceGroupManagerVersion {
        instanceTemplate: string;
        /**
         * The name of the instance group manager. Must be 1-63
         * characters long and comply with
         * [RFC1035](https://www.ietf.org/rfc/rfc1035.txt). Supported characters
         * include lowercase letters, numbers, and hyphens.
         */
        name?: string;
        /**
         * The target number of running instances for this managed
         * instance group. This value should always be explicitly set unless this resource is attached to
         * an autoscaler, in which case it should never be set. Defaults to `0`.
         */
        targetSize?: outputs.compute.RegionInstanceGroupManagerVersionTargetSize;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        fixed?: number;
        percent?: number;
    }

    export interface RegionUrlMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: string;
        description?: string;
        name: string;
        pathRules?: outputs.compute.RegionUrlMapPathMatcherPathRule[];
        routeRules?: outputs.compute.RegionUrlMapPathMatcherRouteRule[];
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface RegionUrlMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }

    export interface ReservationSpecificReservation {
        count: number;
        inUseCount: number;
        instanceProperties: outputs.compute.ReservationSpecificReservationInstanceProperties;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: outputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator[];
        localSsds?: outputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd[];
        machineType: string;
        minCpuPlatform: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: number;
        interface?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: outputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy;
        schedule: outputs.compute.ResourcePolicySnapshotSchedulePolicySchedule;
        snapshotProperties?: outputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: number;
        onSourceDiskDelete?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule;
        hourlySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule;
        weeklySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek[];
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: string;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: boolean;
        labels?: {[key: string]: string};
        storageLocations?: string;
    }

    export interface RouterBgp {
        advertiseMode?: string;
        advertisedGroups?: string[];
        advertisedIpRanges?: outputs.compute.RouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface RouterNatLogConfig {
        enable: boolean;
        filter: string;
    }

    export interface RouterNatSubnetwork {
        name: string;
        secondaryIpRangeNames?: string[];
        sourceIpRangesToNats: string[];
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface SecurityPolicyRule {
        action: string;
        /**
         * An optional description of this security policy. Max size is 2048.
         */
        description?: string;
        match: outputs.compute.SecurityPolicyRuleMatch;
        preview?: boolean;
        priority: number;
    }

    export interface SecurityPolicyRuleMatch {
        config?: outputs.compute.SecurityPolicyRuleMatchConfig;
        expr?: outputs.compute.SecurityPolicyRuleMatchExpr;
        versionedExpr?: string;
    }

    export interface SecurityPolicyRuleMatchConfig {
        srcIpRanges: string[];
    }

    export interface SecurityPolicyRuleMatchExpr {
        expression: string;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: outputs.compute.SecurityScanConfigAuthenticationCustomAccount;
        googleAccount?: outputs.compute.SecurityScanConfigAuthenticationGoogleAccount;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: string;
        password: string;
        username: string;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: string;
        username: string;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: number;
        scheduleTime?: string;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey: string;
        sha256: string;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: string;
    }

    export interface SubnetworkIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubnetworkIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: string;
        flowSampling?: number;
        metadata?: string;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: string;
        rangeName: string;
    }

    export interface URLMapHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface URLMapPathMatcher {
        defaultService?: string;
        description?: string;
        headerAction?: outputs.compute.URLMapPathMatcherHeaderAction;
        name: string;
        pathRules?: outputs.compute.URLMapPathMatcherPathRule[];
        routeRules?: outputs.compute.URLMapPathMatcherRouteRule[];
    }

    export interface URLMapPathMatcherHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.URLMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherPathRuleUrlRedirect;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface URLMapPathMatcherRouteRule {
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.URLMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface URLMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        cloudrunConfig: outputs.container.ClusterAddonsConfigCloudrunConfig;
        horizontalPodAutoscaling: outputs.container.ClusterAddonsConfigHorizontalPodAutoscaling;
        httpLoadBalancing: outputs.container.ClusterAddonsConfigHttpLoadBalancing;
        istioConfig: outputs.container.ClusterAddonsConfigIstioConfig;
        networkPolicyConfig: outputs.container.ClusterAddonsConfigNetworkPolicyConfig;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface ClusterAddonsConfigIstioConfig {
        auth?: string;
        disabled: boolean;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface ClusterClusterAutoscaling {
        autoProvisioningDefaults: outputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults;
        autoscalingProfile?: string;
        enabled: boolean;
        resourceLimits?: outputs.container.ClusterClusterAutoscalingResourceLimit[];
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        oauthScopes: string[];
        serviceAccount?: string;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        maximum?: number;
        minimum?: number;
        resourceType: string;
    }

    export interface ClusterDatabaseEncryption {
        keyName?: string;
        state: string;
    }

    export interface ClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
    }

    export interface ClusterMaintenancePolicy {
        dailyMaintenanceWindow?: outputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow;
        recurringWindow?: outputs.container.ClusterMaintenancePolicyRecurringWindow;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface ClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfig: outputs.container.ClusterMasterAuthClientCertificateConfig;
        clientKey: string;
        clusterCaCertificate: string;
        password?: string;
        username?: string;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        cidrBlocks?: outputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName?: string;
    }

    export interface ClusterNetworkPolicy {
        enabled: boolean;
        provider?: string;
    }

    export interface ClusterNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.ClusterNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.ClusterNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterNodePool {
        autoscaling?: outputs.container.ClusterNodePoolAutoscaling;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount: number;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls: string[];
        management: outputs.container.ClusterNodePoolManagement;
        maxPodsPerNode: number;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name: string;
        namePrefix: string;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig: outputs.container.ClusterNodePoolNodeConfig;
        nodeCount: number;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations: string[];
        upgradeSettings?: outputs.container.ClusterNodePoolUpgradeSettings;
        version: string;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface ClusterNodePoolNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.ClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.ClusterNodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.ClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface ClusterNodePoolUpgradeSettings {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface ClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface ClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes?: boolean;
        masterIpv4CidrBlock?: string;
        peeringName: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface ClusterReleaseChannel {
        channel: string;
    }

    export interface ClusterResourceUsageExportConfig {
        bigqueryDestination: outputs.container.ClusterResourceUsageExportConfigBigqueryDestination;
        enableNetworkEgressMetering?: boolean;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface ClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface ClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface GetClusterAddonsConfig {
        cloudrunConfigs: outputs.container.GetClusterAddonsConfigCloudrunConfig[];
        horizontalPodAutoscalings: outputs.container.GetClusterAddonsConfigHorizontalPodAutoscaling[];
        httpLoadBalancings: outputs.container.GetClusterAddonsConfigHttpLoadBalancing[];
        istioConfigs: outputs.container.GetClusterAddonsConfigIstioConfig[];
        kubernetesDashboards: outputs.container.GetClusterAddonsConfigKubernetesDashboard[];
        networkPolicyConfigs: outputs.container.GetClusterAddonsConfigNetworkPolicyConfig[];
    }

    export interface GetClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigIstioConfig {
        auth: string;
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigKubernetesDashboard {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface GetClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface GetClusterClusterAutoscaling {
        autoProvisioningDefaults: outputs.container.GetClusterClusterAutoscalingAutoProvisioningDefault[];
        autoscalingProfile: string;
        enabled: boolean;
        resourceLimits: outputs.container.GetClusterClusterAutoscalingResourceLimit[];
    }

    export interface GetClusterClusterAutoscalingAutoProvisioningDefault {
        oauthScopes: string[];
        serviceAccount: string;
    }

    export interface GetClusterClusterAutoscalingResourceLimit {
        maximum: number;
        minimum: number;
        resourceType: string;
    }

    export interface GetClusterDatabaseEncryption {
        keyName: string;
        state: string;
    }

    export interface GetClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        nodeIpv4CidrBlock: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
        subnetworkName: string;
    }

    export interface GetClusterMaintenancePolicy {
        dailyMaintenanceWindows: outputs.container.GetClusterMaintenancePolicyDailyMaintenanceWindow[];
        recurringWindows: outputs.container.GetClusterMaintenancePolicyRecurringWindow[];
    }

    export interface GetClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface GetClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface GetClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfigs: outputs.container.GetClusterMasterAuthClientCertificateConfig[];
        clientKey: string;
        clusterCaCertificate: string;
        password: string;
        username: string;
    }

    export interface GetClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface GetClusterMasterAuthorizedNetworksConfig {
        cidrBlocks: outputs.container.GetClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface GetClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName: string;
    }

    export interface GetClusterNetworkPolicy {
        enabled: boolean;
        provider: string;
    }

    export interface GetClusterNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePool {
        autoscalings: outputs.container.GetClusterNodePoolAutoscaling[];
        initialNodeCount: number;
        instanceGroupUrls: string[];
        managements: outputs.container.GetClusterNodePoolManagement[];
        maxPodsPerNode: number;
        /**
         * The name of the cluster.
         */
        name: string;
        namePrefix: string;
        nodeConfigs: outputs.container.GetClusterNodePoolNodeConfig[];
        nodeCount: number;
        nodeLocations: string[];
        upgradeSettings: outputs.container.GetClusterNodePoolUpgradeSetting[];
        version: string;
    }

    export interface GetClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface GetClusterNodePoolManagement {
        autoRepair: boolean;
        autoUpgrade: boolean;
    }

    export interface GetClusterNodePoolNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodePoolNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodePoolNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodePoolNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePoolUpgradeSetting {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface GetClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface GetClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes: boolean;
        masterIpv4CidrBlock: string;
        peeringName: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface GetClusterReleaseChannel {
        channel: string;
    }

    export interface GetClusterResourceUsageExportConfig {
        bigqueryDestinations: outputs.container.GetClusterResourceUsageExportConfigBigqueryDestination[];
        enableNetworkEgressMetering: boolean;
    }

    export interface GetClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface GetClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface GetClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface NodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface NodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface NodePoolNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.NodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.NodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.NodePoolNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.NodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.NodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface NodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface NodePoolUpgradeSettings {
        maxSurge: number;
        maxUnavailable: number;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: outputs.containeranalysis.NoteAttestationAuthorityHint;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: string;
    }
}

export namespace datafusion {
    export interface InstanceNetworkConfig {
        ipAllocation: string;
        network: string;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: string;
        yarnConfig: outputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: string;
        scaleDownFactor: number;
        scaleDownMinWorkerFraction?: number;
        scaleUpFactor: number;
        scaleUpMinWorkerFraction?: number;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: number;
        minInstances?: number;
        weight?: number;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: number;
        minInstances?: number;
        weight?: number;
    }

    export interface ClusterClusterConfig {
        autoscalingConfig?: outputs.dataproc.ClusterClusterConfigAutoscalingConfig;
        bucket: string;
        encryptionConfig?: outputs.dataproc.ClusterClusterConfigEncryptionConfig;
        gceClusterConfig: outputs.dataproc.ClusterClusterConfigGceClusterConfig;
        initializationActions?: outputs.dataproc.ClusterClusterConfigInitializationAction[];
        lifecycleConfig?: outputs.dataproc.ClusterClusterConfigLifecycleConfig;
        masterConfig: outputs.dataproc.ClusterClusterConfigMasterConfig;
        preemptibleWorkerConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig;
        securityConfig?: outputs.dataproc.ClusterClusterConfigSecurityConfig;
        softwareConfig: outputs.dataproc.ClusterClusterConfigSoftwareConfig;
        stagingBucket?: string;
        workerConfig: outputs.dataproc.ClusterClusterConfigWorkerConfig;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        policyUri: string;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        kmsKeyName: string;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        internalIpOnly?: boolean;
        metadata?: {[key: string]: string};
        network: string;
        serviceAccount?: string;
        serviceAccountScopes: string[];
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: string;
        timeoutSec?: number;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        autoDeleteTime?: string;
        idleDeleteTtl?: string;
        idleStartTime: string;
    }

    export interface ClusterClusterConfigMasterConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigMasterConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        diskConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig;
        instanceNames: string[];
        numInstances: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigSecurityConfig {
        kerberosConfig: outputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        crossRealmTrustAdminServer?: string;
        crossRealmTrustKdc?: string;
        crossRealmTrustRealm?: string;
        crossRealmTrustSharedPasswordUri?: string;
        enableKerberos?: boolean;
        kdcDbKeyUri?: string;
        keyPasswordUri?: string;
        keystorePasswordUri?: string;
        keystoreUri?: string;
        kmsKeyUri: string;
        realm?: string;
        rootPrincipalPasswordUri: string;
        tgtLifetimeHours?: number;
        truststorePasswordUri?: string;
        truststoreUri?: string;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        imageVersion: string;
        optionalComponents?: string[];
        overrideProperties?: {[key: string]: string};
        properties: {[key: string]: any};
    }

    export interface ClusterClusterConfigWorkerConfig {
        accelerators?: outputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator[];
        diskConfig: outputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig;
        imageUri: string;
        instanceNames: string[];
        machineType: string;
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        bootDiskSizeGb: number;
        bootDiskType?: string;
        numLocalSsds: number;
    }

    export interface ClusterIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ClusterIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobHadoopConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobHadoopConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobHiveConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobPigConfig {
        continueOnFailure?: boolean;
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPigConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobPlacement {
        clusterName: string;
        clusterUuid: string;
    }

    export interface JobPysparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPysparkConfigLoggingConfig;
        mainPythonFileUri: string;
        properties?: {[key: string]: string};
        pythonFileUris?: string[];
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobReference {
        jobId: string;
    }

    export interface JobScheduling {
        maxFailuresPerHour: number;
    }

    export interface JobSparkConfig {
        archiveUris?: string[];
        args?: string[];
        fileUris?: string[];
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparkConfigLoggingConfig;
        mainClass?: string;
        mainJarFileUri?: string;
        properties?: {[key: string]: string};
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobSparksqlConfig {
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparksqlConfigLoggingConfig;
        properties?: {[key: string]: string};
        queryFileUri?: string;
        queryLists?: string[];
        scriptVariables?: {[key: string]: string};
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobStatus {
        details: string;
        state: string;
        stateStartTime: string;
        substate: string;
    }
}

export namespace datastore {
    export interface DataStoreIndexProperty {
        direction: string;
        name: string;
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        key?: string;
        value?: string;
    }

    export interface DeploymentTarget {
        config: outputs.deploymentmanager.DeploymentTargetConfig;
        imports?: outputs.deploymentmanager.DeploymentTargetImport[];
    }

    export interface DeploymentTargetConfig {
        content: string;
    }

    export interface DeploymentTargetImport {
        content?: string;
        name?: string;
    }
}

export namespace dns {
    export interface GetKeysKeySigningKey {
        algorithm: string;
        creationTime: string;
        description: string;
        digests: outputs.dns.GetKeysKeySigningKeyDigest[];
        dsRecord: string;
        id: string;
        isActive: boolean;
        keyLength: number;
        keyTag: number;
        publicKey: string;
    }

    export interface GetKeysKeySigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface GetKeysZoneSigningKey {
        algorithm: string;
        creationTime: string;
        description: string;
        digests: outputs.dns.GetKeysZoneSigningKeyDigest[];
        id: string;
        isActive: boolean;
        keyLength: number;
        keyTag: number;
        publicKey: string;
    }

    export interface GetKeysZoneSigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs: outputs.dns.ManagedZoneDnssecConfigDefaultKeySpec[];
        kind?: string;
        nonExistence: string;
        state?: string;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: string;
        keyLength?: number;
        keyType?: string;
        kind?: string;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers: outputs.dns.ManagedZoneForwardingConfigTargetNameServer[];
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        forwardingPath?: string;
        ipv4Address: string;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork: outputs.dns.ManagedZonePeeringConfigTargetNetwork;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl: string;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks: outputs.dns.ManagedZonePrivateVisibilityConfigNetwork[];
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl: string;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers: outputs.dns.PolicyAlternativeNameServerConfigTargetNameServer[];
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address: string;
    }

    export interface PolicyNetwork {
        networkUrl: string;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods: outputs.endpoints.ServiceApiMethod[];
        name: string;
        syntax: string;
        version: string;
    }

    export interface ServiceApiMethod {
        name: string;
        requestType: string;
        responseType: string;
        syntax: string;
    }

    export interface ServiceEndpoint {
        address: string;
        name: string;
    }

    export interface ServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: number;
        name: string;
    }

    export interface InstanceNetwork {
        ipAddresses: string[];
        modes: string[];
        network: string;
        reservedIpRange: string;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: string;
        fieldPath?: string;
        order?: string;
    }
}

export namespace folder {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.folder.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.folder.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.folder.OrganizationPolicyListPolicyAllow;
        deny?: outputs.folder.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace gameservices {
    export interface GameServerClusterConnectionInfo {
        gkeClusterReference: outputs.gameservices.GameServerClusterConnectionInfoGkeClusterReference;
        namespace: string;
    }

    export interface GameServerClusterConnectionInfoGkeClusterReference {
        cluster: string;
    }

    export interface GameServerConfigFleetConfig {
        fleetSpec: string;
        name: string;
    }

    export interface GameServerConfigScalingConfig {
        fleetAutoscalerSpec: string;
        name: string;
        schedules?: outputs.gameservices.GameServerConfigScalingConfigSchedule[];
        selectors?: outputs.gameservices.GameServerConfigScalingConfigSelector[];
    }

    export interface GameServerConfigScalingConfigSchedule {
        cronJobDuration?: string;
        cronSpec?: string;
        endTime?: string;
        startTime?: string;
    }

    export interface GameServerConfigScalingConfigSelector {
        labels?: {[key: string]: string};
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverride {
        configVersion?: string;
        realmsSelector?: outputs.gameservices.GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector {
        realms?: string[];
    }
}

export namespace healthcare {
    export interface DatasetIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatasetIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface FhirStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: boolean;
        segmentTerminator?: string;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineVersionIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AppEngineVersionIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TunnelInstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TunnelInstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebBackendServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebBackendServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeComputeIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface WebTypeComputeIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace identityplatform {
    export interface InboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface InboundSamlConfigSpConfig {
        callbackUri?: string;
        spCertificates: outputs.identityplatform.InboundSamlConfigSpConfigSpCertificate[];
        spEntityId?: string;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface TenantInboundSamlConfigSpConfig {
        callbackUri: string;
        spCertificates: outputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate[];
        spEntityId: string;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface CryptoKeyIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface CryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel?: string;
    }

    export interface GetKMSCryptoKeyVersionPublicKey {
        /**
         * The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
         */
        algorithm: string;
        /**
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem: string;
    }

    export interface GetKMSCryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel: string;
    }

    export interface KeyRingIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface KeyRingIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RegistryCredential {
        publicKeyCertificate: outputs.kms.RegistryCredentialPublicKeyCertificate;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        certificate: string;
        format: string;
    }

    export interface RegistryEventNotificationConfigItem {
        pubsubTopicName: string;
        subfolderMatches?: string;
    }

    export interface RegistryHttpConfig {
        httpEnabledState: string;
    }

    export interface RegistryMqttConfig {
        mqttEnabledState: string;
    }

    export interface RegistryStateNotificationConfig {
        pubsubTopicName: string;
    }
}

export namespace logging {
    export interface BillingAccountSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface FolderSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface MetricBucketOptions {
        explicitBuckets?: outputs.logging.MetricBucketOptionsExplicitBuckets;
        exponentialBuckets?: outputs.logging.MetricBucketOptionsExponentialBuckets;
        linearBuckets?: outputs.logging.MetricBucketOptionsLinearBuckets;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds: number[];
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: number;
        numFiniteBuckets?: number;
        scale?: number;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: number;
        offset?: number;
        width?: number;
    }

    export interface MetricMetricDescriptor {
        displayName?: string;
        labels?: outputs.logging.MetricMetricDescriptorLabel[];
        metricKind: string;
        unit?: string;
        valueType: string;
    }

    export interface MetricMetricDescriptorLabel {
        description?: string;
        key: string;
        valueType?: string;
    }

    export interface OrganizationSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }

    export interface ProjectSinkBigqueryOptions {
        usePartitionedTables: boolean;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name: string;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: outputs.monitoring.AlertPolicyConditionConditionAbsent;
        conditionThreshold?: outputs.monitoring.AlertPolicyConditionConditionThreshold;
        displayName: string;
        name: string;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionAbsentAggregation[];
        duration: string;
        filter?: string;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionAbsentTrigger;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdAggregation[];
        comparison: string;
        denominatorAggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation[];
        denominatorFilter?: string;
        duration: string;
        filter?: string;
        thresholdValue?: number;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionThresholdTrigger;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime: string;
        mutatedBy: string;
    }

    export interface AlertPolicyDocumentation {
        content?: string;
        mimeType?: string;
    }

    export interface UptimeCheckConfigContentMatcher {
        content: string;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: outputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo;
        headers?: {[key: string]: string};
        maskHeaders?: boolean;
        path?: string;
        port: number;
        useSsl?: boolean;
        validateSsl?: boolean;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password: string;
        username: string;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: {[key: string]: string};
        type: string;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: string;
        resourceType?: string;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: number;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: outputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        condition?: outputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamAuditConfigAuditLogConfig {
        exemptedMembers?: string[];
        logType: string;
    }

    export interface PolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface PolicyListPolicy {
        allow?: outputs.organizations.PolicyListPolicyAllow;
        deny?: outputs.organizations.PolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface PolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface PolicyRestorePolicy {
        default: boolean;
    }
}

export namespace projects {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.projects.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.projects.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface GetProjectProject {
        /**
         * The project id of the project.
         */
        projectId: string;
    }

    export interface IAMAuditConfigAuditLogConfig {
        exemptedMembers?: string[];
        logType: string;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.projects.OrganizationPolicyListPolicyAllow;
        deny?: outputs.projects.OrganizationPolicyListPolicyDeny;
        inheritFromParent?: boolean;
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        all?: boolean;
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        default: boolean;
    }
}

export namespace pubsub {
    export interface SubscriptionExpirationPolicy {
        ttl: string;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionPushConfig {
        attributes?: {[key: string]: string};
        oidcToken?: outputs.pubsub.SubscriptionPushConfigOidcToken;
        pushEndpoint: string;
    }

    export interface SubscriptionPushConfigOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface TopicIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: string[];
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ConfigIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace secretmanager {
    export interface SecretIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretReplication {
        automatic?: boolean;
        userManaged?: outputs.secretmanager.SecretReplicationUserManaged;
    }

    export interface SecretReplicationUserManaged {
        replicas: outputs.secretmanager.SecretReplicationUserManagedReplica[];
    }

    export interface SecretReplicationUserManagedReplica {
        location: string;
    }
}

export namespace serviceAccount {
    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryPubsubConfig {
        messageFormat: string;
        serviceAccountEmail: string;
        topic: string;
    }
}

export namespace spanner {
    export interface DatabaseIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatabaseIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress: string;
        timeToRetire: string;
        type: string;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        caCertificate?: string;
        clientCertificate?: string;
        clientKey?: string;
        connectRetryInterval?: number;
        dumpFilePath?: string;
        failoverTarget?: boolean;
        masterHeartbeatPeriod?: number;
        password?: string;
        sslCipher?: string;
        username?: string;
        verifyServerCertificate?: boolean;
    }

    export interface DatabaseInstanceServerCaCert {
        cert: string;
        commonName: string;
        createTime: string;
        expirationTime: string;
        sha1Fingerprint: string;
    }

    export interface DatabaseInstanceSettings {
        activationPolicy: string;
        authorizedGaeApplications?: string[];
        availabilityType: string;
        backupConfiguration: outputs.sql.DatabaseInstanceSettingsBackupConfiguration;
        crashSafeReplication: boolean;
        databaseFlags?: outputs.sql.DatabaseInstanceSettingsDatabaseFlag[];
        diskAutoresize?: boolean;
        diskSize: number;
        diskType: string;
        ipConfiguration: outputs.sql.DatabaseInstanceSettingsIpConfiguration;
        locationPreference: outputs.sql.DatabaseInstanceSettingsLocationPreference;
        maintenanceWindow?: outputs.sql.DatabaseInstanceSettingsMaintenanceWindow;
        pricingPlan?: string;
        replicationType?: string;
        tier: string;
        userLabels?: {[key: string]: string};
        version: number;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        binaryLogEnabled?: boolean;
        enabled?: boolean;
        location?: string;
        startTime: string;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name: string;
        value: string;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: outputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork[];
        ipv4Enabled: boolean;
        privateNetwork?: string;
        requireSsl?: boolean;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        expirationTime?: string;
        /**
         * The name of the instance. If the name is left
         * blank, this provider will randomly generate one when the instance is first
         * created. This is done because after a name is used, it cannot be reused for
         * up to [one week](https://cloud.google.com/sql/docs/delete-instance).
         */
        name?: string;
        value: string;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        followGaeApplication?: string;
        zone?: string;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        day?: number;
        hour?: number;
        updateTrack?: string;
    }

    export interface GetCaCertsCert {
        cert: string;
        commonName: string;
        createTime: string;
        expirationTime: string;
        sha1Fingerprint: string;
    }
}

export namespace storage {
    export interface BucketCor {
        maxAgeSeconds?: number;
        methods?: string[];
        origins?: string[];
        responseHeaders?: string[];
    }

    export interface BucketEncryption {
        defaultKmsKeyName: string;
    }

    export interface BucketIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BucketIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BucketLifecycleRule {
        action: outputs.storage.BucketLifecycleRuleAction;
        condition: outputs.storage.BucketLifecycleRuleCondition;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of the new bucket. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: string;
        type: string;
    }

    export interface BucketLifecycleRuleCondition {
        age?: number;
        createdBefore?: string;
        matchesStorageClasses?: string[];
        numNewerVersions?: number;
        withState: string;
    }

    export interface BucketLogging {
        logBucket: string;
        logObjectPrefix: string;
    }

    export interface BucketRetentionPolicy {
        isLocked?: boolean;
        retentionPeriod: number;
    }

    export interface BucketVersioning {
        enabled: boolean;
    }

    export interface BucketWebsite {
        mainPageSuffix?: string;
        notFoundPage?: string;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface TransferJobSchedule {
        scheduleEndDate?: outputs.storage.TransferJobScheduleScheduleEndDate;
        scheduleStartDate: outputs.storage.TransferJobScheduleScheduleStartDate;
        startTimeOfDay?: outputs.storage.TransferJobScheduleStartTimeOfDay;
    }

    export interface TransferJobScheduleScheduleEndDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleScheduleStartDate {
        day: number;
        month: number;
        year: number;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        hours: number;
        minutes: number;
        nanos: number;
        seconds: number;
    }

    export interface TransferJobTransferSpec {
        awsS3DataSource?: outputs.storage.TransferJobTransferSpecAwsS3DataSource;
        gcsDataSink?: outputs.storage.TransferJobTransferSpecGcsDataSink;
        gcsDataSource?: outputs.storage.TransferJobTransferSpecGcsDataSource;
        httpDataSource?: outputs.storage.TransferJobTransferSpecHttpDataSource;
        objectConditions?: outputs.storage.TransferJobTransferSpecObjectConditions;
        transferOptions?: outputs.storage.TransferJobTransferSpecTransferOptions;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        awsAccessKey: outputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey;
        bucketName: string;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        accessKeyId: string;
        secretAccessKey: string;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        bucketName: string;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        bucketName: string;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        listUrl: string;
    }

    export interface TransferJobTransferSpecObjectConditions {
        excludePrefixes?: string[];
        includePrefixes?: string[];
        maxTimeElapsedSinceLastModification?: string;
        minTimeElapsedSinceLastModification?: string;
    }

    export interface TransferJobTransferSpecTransferOptions {
        deleteObjectsFromSourceAfterTransfer?: boolean;
        deleteObjectsUniqueInSink?: boolean;
        overwriteObjectsAlreadyExistingInSink?: boolean;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress: string;
        port: number;
    }

    export interface NodeSchedulingConfig {
        preemptible: boolean;
    }
}
