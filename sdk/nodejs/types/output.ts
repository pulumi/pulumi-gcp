// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";


export namespace accesscontextmanager {
    export interface AccessLevelBasic {
        combiningFunction?: string;
        conditions: outputs.accesscontextmanager.AccessLevelBasicCondition[];
    }

    export interface AccessLevelBasicCondition {
        devicePolicy?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicy;
        ipSubnetworks?: string[];
        members?: string[];
        negate?: boolean;
        regions?: string[];
        requiredAccessLevels?: string[];
    }

    export interface AccessLevelBasicConditionDevicePolicy {
        allowedDeviceManagementLevels?: string[];
        allowedEncryptionStatuses?: string[];
        osConstraints?: outputs.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraint[];
        requireAdminApproval?: boolean;
        requireCorpOwned?: boolean;
        requireScreenLock?: boolean;
    }

    export interface AccessLevelBasicConditionDevicePolicyOsConstraint {
        minimumVersion?: string;
        osType: string;
    }

    export interface ServicePerimeterStatus {
        accessLevels?: string[];
        resources?: string[];
        restrictedServices?: string[];
        vpcAccessibleServices?: outputs.accesscontextmanager.ServicePerimeterStatusVpcAccessibleServices;
    }

    export interface ServicePerimeterStatusVpcAccessibleServices {
        allowedServices?: string[];
        enableRestriction?: boolean;
    }
}

export namespace appengine {
    export interface ApplicationFeatureSettings {
        /**
         * Set to false to use the legacy health check instead of the readiness
         * and liveness checks.
         */
        splitHealthChecks: boolean;
    }

    export interface ApplicationIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface ApplicationUrlDispatchRule {
        domain: string;
        path: string;
        service: string;
    }

    export interface ApplicationUrlDispatchRulesDispatchRule {
        domain?: string;
        path: string;
        service: string;
    }

    export interface DomainMappingResourceRecord {
        name?: string;
        rrdata?: string;
        type?: string;
    }

    export interface DomainMappingSslSettings {
        certificateId: string;
        pendingManagedCertificateId: string;
        sslManagementType: string;
    }

    export interface EngineSplitTrafficSplit {
        allocations: {[key: string]: string};
        shardBy?: string;
    }

    export interface FlexibleAppVersionApiConfig {
        authFailAction?: string;
        login?: string;
        script: string;
        securityLevel?: string;
        url?: string;
    }

    export interface FlexibleAppVersionAutomaticScaling {
        coolDownPeriod?: string;
        cpuUtilization: outputs.appengine.FlexibleAppVersionAutomaticScalingCpuUtilization;
        diskUtilization?: outputs.appengine.FlexibleAppVersionAutomaticScalingDiskUtilization;
        maxConcurrentRequests: number;
        maxIdleInstances?: number;
        maxPendingLatency?: string;
        maxTotalInstances?: number;
        minIdleInstances?: number;
        minPendingLatency?: string;
        minTotalInstances?: number;
        networkUtilization?: outputs.appengine.FlexibleAppVersionAutomaticScalingNetworkUtilization;
        requestUtilization?: outputs.appengine.FlexibleAppVersionAutomaticScalingRequestUtilization;
    }

    export interface FlexibleAppVersionAutomaticScalingCpuUtilization {
        aggregationWindowLength?: string;
        targetUtilization: number;
    }

    export interface FlexibleAppVersionAutomaticScalingDiskUtilization {
        targetReadBytesPerSecond?: number;
        targetReadOpsPerSecond?: number;
        targetWriteBytesPerSecond?: number;
        targetWriteOpsPerSecond?: number;
    }

    export interface FlexibleAppVersionAutomaticScalingNetworkUtilization {
        targetReceivedBytesPerSecond?: number;
        targetReceivedPacketsPerSecond?: number;
        targetSentBytesPerSecond?: number;
        targetSentPacketsPerSecond?: number;
    }

    export interface FlexibleAppVersionAutomaticScalingRequestUtilization {
        targetConcurrentRequests?: number;
        targetRequestCountPerSecond?: string;
    }

    export interface FlexibleAppVersionDeployment {
        cloudBuildOptions?: outputs.appengine.FlexibleAppVersionDeploymentCloudBuildOptions;
        container?: outputs.appengine.FlexibleAppVersionDeploymentContainer;
        files?: outputs.appengine.FlexibleAppVersionDeploymentFile[];
        zip?: outputs.appengine.FlexibleAppVersionDeploymentZip;
    }

    export interface FlexibleAppVersionDeploymentCloudBuildOptions {
        appYamlPath: string;
        cloudBuildTimeout?: string;
    }

    export interface FlexibleAppVersionDeploymentContainer {
        image: string;
    }

    export interface FlexibleAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
        sha1Sum?: string;
        sourceUrl: string;
    }

    export interface FlexibleAppVersionDeploymentZip {
        filesCount?: number;
        sourceUrl: string;
    }

    export interface FlexibleAppVersionEndpointsApiService {
        configId?: string;
        disableTraceSampling?: boolean;
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
        rolloutStrategy?: string;
    }

    export interface FlexibleAppVersionEntrypoint {
        shell: string;
    }

    export interface FlexibleAppVersionLivenessCheck {
        checkInterval?: string;
        failureThreshold?: number;
        host?: string;
        initialDelay?: string;
        path: string;
        successThreshold?: number;
        timeout?: string;
    }

    export interface FlexibleAppVersionManualScaling {
        instances: number;
    }

    export interface FlexibleAppVersionNetwork {
        forwardedPorts?: string[];
        instanceTag?: string;
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
        sessionAffinity?: boolean;
        subnetwork?: string;
    }

    export interface FlexibleAppVersionReadinessCheck {
        appStartTimeout?: string;
        checkInterval?: string;
        failureThreshold?: number;
        host?: string;
        path: string;
        successThreshold?: number;
        timeout?: string;
    }

    export interface FlexibleAppVersionResources {
        cpu?: number;
        diskGb?: number;
        memoryGb?: number;
        volumes?: outputs.appengine.FlexibleAppVersionResourcesVolume[];
    }

    export interface FlexibleAppVersionResourcesVolume {
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
        sizeGb: number;
        volumeType: string;
    }

    export interface FlexibleAppVersionVpcAccessConnector {
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
    }

    export interface StandardAppVersionDeployment {
        files?: outputs.appengine.StandardAppVersionDeploymentFile[];
        zip?: outputs.appengine.StandardAppVersionDeploymentZip;
    }

    export interface StandardAppVersionDeploymentFile {
        /**
         * The identifier for this object. Format specified above.
         */
        name: string;
        sha1Sum?: string;
        sourceUrl: string;
    }

    export interface StandardAppVersionDeploymentZip {
        filesCount?: number;
        sourceUrl: string;
    }

    export interface StandardAppVersionEntrypoint {
        shell: string;
    }

    export interface StandardAppVersionHandler {
        authFailAction?: string;
        login?: string;
        redirectHttpResponseCode?: string;
        script?: outputs.appengine.StandardAppVersionHandlerScript;
        securityLevel?: string;
        staticFiles?: outputs.appengine.StandardAppVersionHandlerStaticFiles;
        urlRegex?: string;
    }

    export interface StandardAppVersionHandlerScript {
        scriptPath: string;
    }

    export interface StandardAppVersionHandlerStaticFiles {
        applicationReadable?: boolean;
        expiration?: string;
        httpHeaders?: {[key: string]: string};
        mimeType?: string;
        path?: string;
        requireMatchingFile?: boolean;
        uploadPathRegex?: string;
    }

    export interface StandardAppVersionLibrary {
        /**
         * The identifier for this object. Format specified above.
         */
        name?: string;
        version?: string;
    }
}

export namespace bigquery {
    export interface AppProfileSingleClusterRouting {
        allowTransactionalWrites?: boolean;
        clusterId: string;
    }

    export interface DatasetAccess {
        domain?: string;
        groupByEmail?: string;
        role?: string;
        specialGroup?: string;
        userByEmail?: string;
        view?: outputs.bigquery.DatasetAccessView;
    }

    export interface DatasetAccessView {
        datasetId: string;
        projectId: string;
        tableId: string;
    }

    export interface DatasetDefaultEncryptionConfiguration {
        kmsKeyName: string;
    }

    export interface TableEncryptionConfiguration {
        /**
         * The self link or full name of a key which should be used to
         * encrypt this table.  Note that the default bigquery service account will need to have
         * encrypt/decrypt permissions on this key - you may want to see the
         * `gcp.bigquery.getDefaultServiceAccount` datasource and the
         * `gcp.kms.CryptoKeyIAMBinding` resource.
         */
        kmsKeyName: string;
    }

    export interface TableExternalDataConfiguration {
        /**
         * - Let BigQuery try to autodetect the schema
         * and format of the table.
         */
        autodetect: boolean;
        /**
         * The compression type of the data source.
         * Valid values are "NONE" or "GZIP".
         */
        compression?: string;
        /**
         * Additional properties to set if
         * `sourceFormat` is set to "CSV". Structure is documented below.
         */
        csvOptions?: outputs.bigquery.TableExternalDataConfigurationCsvOptions;
        /**
         * Additional options if
         * `sourceFormat` is set to "GOOGLE_SHEETS". Structure is
         * documented below.
         */
        googleSheetsOptions?: outputs.bigquery.TableExternalDataConfigurationGoogleSheetsOptions;
        /**
         * Indicates if BigQuery should
         * allow extra values that are not represented in the table schema.
         * If true, the extra values are ignored. If false, records with
         * extra columns are treated as bad records, and if there are too
         * many bad records, an invalid error is returned in the job result.
         * The default value is false.
         */
        ignoreUnknownValues?: boolean;
        /**
         * The maximum number of bad records that
         * BigQuery can ignore when reading data.
         */
        maxBadRecords?: number;
        /**
         * The data format. Supported values are:
         * "CSV", "GOOGLE_SHEETS", "NEWLINE_DELIMITED_JSON", "AVRO", "PARQUET",
         * and "DATSTORE_BACKUP". To use "GOOGLE_SHEETS"
         * the `scopes` must include
         * "https://www.googleapis.com/auth/drive.readonly".
         */
        sourceFormat: string;
        /**
         * A list of the fully-qualified URIs that point to
         * your data in Google Cloud.
         */
        sourceUris: string[];
    }

    export interface TableExternalDataConfigurationCsvOptions {
        /**
         * Indicates if BigQuery should accept rows
         * that are missing trailing optional columns.
         */
        allowJaggedRows?: boolean;
        /**
         * Indicates if BigQuery should allow
         * quoted data sections that contain newline characters in a CSV file.
         * The default value is false.
         */
        allowQuotedNewlines?: boolean;
        /**
         * The character encoding of the data. The supported
         * values are UTF-8 or ISO-8859-1.
         */
        encoding?: string;
        /**
         * The separator for fields in a CSV file.
         */
        fieldDelimiter?: string;
        /**
         * The value that is used to quote data sections in a
         * CSV file. If your data does not contain quoted sections, set the
         * property value to an empty string. If your data contains quoted newline
         * characters, you must also set the `allowQuotedNewlines` property to true.
         * The API-side default is `"`, specified in the provider escaped as `\"`. Due to
         * limitations with default values, this value is required to be
         * explicitly set.
         */
        quote: string;
        /**
         * The number of rows at the top of the sheet
         * that BigQuery will skip when reading the data. At least one of `range` or
         * `skipLeadingRows` must be set.
         */
        skipLeadingRows?: number;
    }

    export interface TableExternalDataConfigurationGoogleSheetsOptions {
        /**
         * Information required to partition based on ranges.
         * Structure is documented below.
         */
        range?: string;
        /**
         * The number of rows at the top of the sheet
         * that BigQuery will skip when reading the data. At least one of `range` or
         * `skipLeadingRows` must be set.
         */
        skipLeadingRows?: number;
    }

    export interface TableRangePartitioning {
        /**
         * The field used to determine how to create a range-based
         * partition.
         */
        field: string;
        /**
         * Information required to partition based on ranges.
         * Structure is documented below.
         */
        range: outputs.bigquery.TableRangePartitioningRange;
    }

    export interface TableRangePartitioningRange {
        /**
         * End of the range partitioning, exclusive.
         */
        end: number;
        /**
         * The width of each range within the partition.
         */
        interval: number;
        /**
         * Start of the range partitioning, inclusive.
         */
        start: number;
    }

    export interface TableTimePartitioning {
        /**
         * Number of milliseconds for which to keep the
         * storage for a partition.
         */
        expirationMs?: number;
        /**
         * The field used to determine how to create a range-based
         * partition.
         */
        field?: string;
        /**
         * If set to true, queries over this table
         * require a partition filter that can be used for partition elimination to be
         * specified.
         */
        requirePartitionFilter?: boolean;
        /**
         * The only type supported is DAY, which will generate
         * one partition per day based on data loading time.
         */
        type: string;
    }

    export interface TableView {
        /**
         * A query that BigQuery executes when the view is referenced.
         */
        query: string;
        /**
         * Specifies whether to use BigQuery's legacy SQL for this view.
         * The default value is true. If set to false, the view will use BigQuery's standard SQL.
         */
        useLegacySql?: boolean;
    }
}

export namespace bigtable {
    export interface GCPolicyMaxAge {
        /**
         * Number of days before applying GC policy.
         */
        days: number;
    }

    export interface GCPolicyMaxVersion {
        /**
         * Number of version before applying the GC policy.
         */
        number: number;
    }

    export interface InstanceCluster {
        /**
         * The ID of the Cloud Bigtable cluster.
         */
        clusterId: string;
        /**
         * The number of nodes in your Cloud Bigtable cluster.
         * Required, with a minimum of `3` for a `PRODUCTION` instance. Must be left unset
         * for a `DEVELOPMENT` instance.
         */
        numNodes: number;
        /**
         * The storage type to use. One of `"SSD"` or
         * `"HDD"`. Defaults to `"SSD"`.
         */
        storageType?: string;
        /**
         * The zone to create the Cloud Bigtable cluster in. Each
         * cluster must have a different zone in the same region. Zones that support
         * Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
         */
        zone: string;
    }

    export interface InstanceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TableColumnFamily {
        /**
         * The name of the column family.
         */
        family: string;
    }
}

export namespace billing {
    export interface AccountIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AccountIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface BudgetAllUpdatesRule {
        pubsubTopic: string;
        schemaVersion?: string;
    }

    export interface BudgetAmount {
        specifiedAmount: outputs.billing.BudgetAmountSpecifiedAmount;
    }

    export interface BudgetAmountSpecifiedAmount {
        currencyCode?: string;
        nanos?: number;
        units?: string;
    }

    export interface BudgetBudgetFilter {
        creditTypesTreatment?: string;
        projects?: string[];
        services?: string[];
    }

    export interface BudgetThresholdRule {
        spendBasis?: string;
        thresholdPercent: number;
    }
}

export namespace binaryauthorization {
    export interface AttestorAttestationAuthorityNote {
        delegationServiceAccountEmail: string;
        noteReference: string;
        publicKeys?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKey[];
    }

    export interface AttestorAttestationAuthorityNotePublicKey {
        asciiArmoredPgpPublicKey?: string;
        comment?: string;
        /**
         * an identifier for the resource with format `projects/{{project}}/attestors/{{name}}`
         */
        id: string;
        pkixPublicKey?: outputs.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKey;
    }

    export interface AttestorAttestationAuthorityNotePublicKeyPkixPublicKey {
        publicKeyPem?: string;
        signatureAlgorithm?: string;
    }

    export interface AttestorIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface AttestorIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface PolicyAdmissionWhitelistPattern {
        namePattern: string;
    }

    export interface PolicyClusterAdmissionRule {
        /**
         * The identifier for this object. Format specified above.
         */
        cluster: string;
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }

    export interface PolicyDefaultAdmissionRule {
        enforcementMode: string;
        evaluationMode: string;
        requireAttestationsBies?: string[];
    }
}

export namespace cloudbuild {
    export interface TriggerBuild {
        images?: string[];
        steps: outputs.cloudbuild.TriggerBuildStep[];
        tags?: string[];
        timeout?: string;
    }

    export interface TriggerBuildStep {
        args?: string[];
        dir?: string;
        entrypoint?: string;
        envs?: string[];
        /**
         * an identifier for the resource with format `projects/{{project}}/triggers/{{trigger_id}}`
         */
        id?: string;
        name: string;
        secretEnvs?: string[];
        timeout?: string;
        timing?: string;
        volumes?: outputs.cloudbuild.TriggerBuildStepVolume[];
        waitFors?: string[];
    }

    export interface TriggerBuildStepVolume {
        name: string;
        path: string;
    }

    export interface TriggerGithub {
        name?: string;
        owner?: string;
        pullRequest?: outputs.cloudbuild.TriggerGithubPullRequest;
        push?: outputs.cloudbuild.TriggerGithubPush;
    }

    export interface TriggerGithubPullRequest {
        branch: string;
        commentControl?: string;
    }

    export interface TriggerGithubPush {
        branch?: string;
        tag?: string;
    }

    export interface TriggerTriggerTemplate {
        branchName?: string;
        commitSha?: string;
        dir?: string;
        projectId: string;
        repoName?: string;
        tagName?: string;
    }
}

export namespace cloudfunctions {
    export interface FunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
         * full reference of accepted triggers.
         */
        eventType: string;
        /**
         * Specifies policy for failed executions. Structure is documented below.
         */
        failurePolicy: outputs.cloudfunctions.FunctionEventTriggerFailurePolicy;
        /**
         * Required. The name or partial URI of the resource from
         * which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
         */
        resource: string;
    }

    export interface FunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure. Defaults to `false`.
         */
        retry: boolean;
    }

    export interface FunctionIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FunctionSourceRepository {
        deployedUrl: string;
        /**
         * The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:
         */
        url: string;
    }

    export interface GetFunctionEventTrigger {
        /**
         * The type of event to observe. For example: `"google.storage.object.finalize"`.
         * See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/)
         * for a full reference of accepted triggers.
         */
        eventType: string;
        /**
         * Policy for failed executions. Structure is documented below.
         */
        failurePolicies: outputs.cloudfunctions.GetFunctionEventTriggerFailurePolicy[];
        /**
         * The name of the resource whose events are being observed, for example, `"myBucket"`
         */
        resource: string;
    }

    export interface GetFunctionEventTriggerFailurePolicy {
        /**
         * Whether the function should be retried on failure.
         */
        retry: boolean;
    }

    export interface GetFunctionSourceRepository {
        deployedUrl: string;
        url: string;
    }
}

export namespace cloudrun {
    export interface DomainMappingMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface DomainMappingSpec {
        certificateMode?: string;
        forceOverride?: boolean;
        routeName: string;
    }

    export interface DomainMappingStatus {
        conditions: outputs.cloudrun.DomainMappingStatusCondition[];
        mappedRouteName: string;
        observedGeneration: number;
        resourceRecords?: outputs.cloudrun.DomainMappingStatusResourceRecord[];
    }

    export interface DomainMappingStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface DomainMappingStatusResourceRecord {
        name: string;
        rrdata: string;
        type?: string;
    }

    export interface IamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels: {[key: string]: string};
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceStatus {
        conditions: outputs.cloudrun.ServiceStatusCondition[];
        latestCreatedRevisionName: string;
        latestReadyRevisionName: string;
        observedGeneration: number;
        url: string;
    }

    export interface ServiceStatusCondition {
        message: string;
        reason: string;
        status: string;
        type: string;
    }

    export interface ServiceTemplate {
        metadata: outputs.cloudrun.ServiceTemplateMetadata;
        spec: outputs.cloudrun.ServiceTemplateSpec;
    }

    export interface ServiceTemplateMetadata {
        annotations: {[key: string]: string};
        generation: number;
        labels?: {[key: string]: string};
        name: string;
        namespace: string;
        resourceVersion: string;
        selfLink: string;
        uid: string;
    }

    export interface ServiceTemplateSpec {
        containerConcurrency: number;
        containers: outputs.cloudrun.ServiceTemplateSpecContainer[];
        serviceAccountName?: string;
        servingState: string;
    }

    export interface ServiceTemplateSpecContainer {
        args?: string[];
        commands?: string[];
        envs?: outputs.cloudrun.ServiceTemplateSpecContainerEnv[];
        envFroms?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFrom[];
        image: string;
        resources: outputs.cloudrun.ServiceTemplateSpecContainerResources;
        workingDir?: string;
    }

    export interface ServiceTemplateSpecContainerEnv {
        name?: string;
        value?: string;
    }

    export interface ServiceTemplateSpecContainerEnvFrom {
        configMapRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRef;
        prefix?: string;
        secretRef?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRef;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromConfigMapRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRef {
        localObjectReference?: outputs.cloudrun.ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference;
        optional?: boolean;
    }

    export interface ServiceTemplateSpecContainerEnvFromSecretRefLocalObjectReference {
        name: string;
    }

    export interface ServiceTemplateSpecContainerResources {
        limits: {[key: string]: string};
        requests?: {[key: string]: string};
    }

    export interface ServiceTraffic {
        latestRevision?: boolean;
        percent: number;
        revisionName?: string;
    }
}

export namespace cloudscheduler {
    export interface JobAppEngineHttpTarget {
        appEngineRouting?: outputs.cloudscheduler.JobAppEngineHttpTargetAppEngineRouting;
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        relativeUri: string;
    }

    export interface JobAppEngineHttpTargetAppEngineRouting {
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface JobHttpTarget {
        body?: string;
        headers?: {[key: string]: string};
        httpMethod?: string;
        oauthToken?: outputs.cloudscheduler.JobHttpTargetOauthToken;
        oidcToken?: outputs.cloudscheduler.JobHttpTargetOidcToken;
        uri: string;
    }

    export interface JobHttpTargetOauthToken {
        scope?: string;
        serviceAccountEmail: string;
    }

    export interface JobHttpTargetOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface JobPubsubTarget {
        attributes?: {[key: string]: string};
        data?: string;
        topicName: string;
    }

    export interface JobRetryConfig {
        maxBackoffDuration?: string;
        maxDoublings?: number;
        maxRetryDuration?: string;
        minBackoffDuration?: string;
        retryCount?: number;
    }
}

export namespace cloudtasks {
    export interface QueueAppEngineRoutingOverride {
        host: string;
        instance?: string;
        service?: string;
        version?: string;
    }

    export interface QueueRateLimits {
        maxBurstSize: number;
        maxConcurrentDispatches: number;
        maxDispatchesPerSecond: number;
    }

    export interface QueueRetryConfig {
        maxAttempts: number;
        maxBackoff: string;
        maxDoublings: number;
        maxRetryDuration: string;
        minBackoff: string;
    }
}

export namespace composer {
    export interface EnvironmentConfig {
        airflowUri: string;
        dagGcsPrefix: string;
        gkeCluster: string;
        nodeConfig: outputs.composer.EnvironmentConfigNodeConfig;
        nodeCount: number;
        privateEnvironmentConfig: outputs.composer.EnvironmentConfigPrivateEnvironmentConfig;
        softwareConfig: outputs.composer.EnvironmentConfigSoftwareConfig;
    }

    export interface EnvironmentConfigNodeConfig {
        diskSizeGb: number;
        ipAllocationPolicy: outputs.composer.EnvironmentConfigNodeConfigIpAllocationPolicy;
        machineType: string;
        network: string;
        oauthScopes: string[];
        serviceAccount: string;
        subnetwork?: string;
        tags?: string[];
        zone: string;
    }

    export interface EnvironmentConfigNodeConfigIpAllocationPolicy {
        clusterIpv4CidrBlock?: string;
        clusterSecondaryRangeName?: string;
        servicesIpv4CidrBlock?: string;
        servicesSecondaryRangeName?: string;
        useIpAliases: boolean;
    }

    export interface EnvironmentConfigPrivateEnvironmentConfig {
        enablePrivateEndpoint?: boolean;
        masterIpv4CidrBlock?: string;
    }

    export interface EnvironmentConfigSoftwareConfig {
        airflowConfigOverrides?: {[key: string]: string};
        envVariables?: {[key: string]: string};
        /**
         * -
         * The version of the software running in the environment. This encapsulates both the version of Cloud Composer
         * functionality and the version of Apache Airflow. It must match the regular expression
         * `composer-[0-9]+\.[0-9]+(\.[0-9]+)?-airflow-[0-9]+\.[0-9]+(\.[0-9]+.*)?`.
         * The Cloud Composer portion of the version is a semantic version.
         * The portion of the image version following 'airflow-' is an official Apache Airflow repository release name.
         * See [documentation](https://cloud.google.com/composer/docs/reference/rest/v1beta1/projects.locations.environments#softwareconfig)
         * for allowed release names.
         */
        imageVersion: string;
        pypiPackages?: {[key: string]: string};
        /**
         * -
         * The major version of Python used to run the Apache Airflow scheduler, worker, and webserver processes.
         * Can be set to '2' or '3'. If not specified, the default is '2'. Cannot be updated.
         */
        pythonVersion: string;
    }

    export interface GetImageVersionsImageVersion {
        /**
         * The string identifier of the image version, in the form: "composer-x.y.z-airflow-a.b(.c)"
         */
        imageVersionId: string;
        /**
         * Supported python versions for this image version
         */
        supportedPythonVersions: string[];
    }
}

export namespace compute {
    export interface AutoscalarAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.AutoscalarAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.AutoscalarAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.AutoscalarAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface AutoscalarAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface AutoscalarAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface AutoscalerAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.AutoscalerAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.AutoscalerAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.AutoscalerAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface AutoscalerAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface AutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface AutoscalerAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface BackendBucketCdnPolicy {
        signedUrlCacheMaxAgeSec: number;
    }

    export interface BackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface BackendServiceCdnPolicy {
        cacheKeyPolicy?: outputs.compute.BackendServiceCdnPolicyCacheKeyPolicy;
        signedUrlCacheMaxAgeSec?: number;
    }

    export interface BackendServiceCdnPolicyCacheKeyPolicy {
        includeHost?: boolean;
        includeProtocol?: boolean;
        includeQueryString?: boolean;
        queryStringBlacklists?: string[];
        queryStringWhitelists?: string[];
    }

    export interface BackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.BackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface BackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceConsistentHash {
        httpCookie?: outputs.compute.BackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface BackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.BackendServiceConsistentHashHttpCookieTtl;
    }

    export interface BackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface BackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface BackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.BackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.BackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface BackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface BackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface DiskDiskEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceImageEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface DiskSourceSnapshotEncryptionKey {
        kmsKeySelfLink?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface ExternalVpnGatewayInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/global/externalVpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface FirewallAllow {
        ports?: string[];
        protocol: string;
    }

    export interface FirewallDeny {
        ports?: string[];
        protocol: string;
    }

    export interface GetBackendBucketCdnPolicy {
        /**
         * Maximum number of seconds the response to a signed URL request will be considered fresh. After this time period, the response will be revalidated before being served. When serving responses to signed URL requests, Cloud CDN will internally behave as though all responses from this backend had a "Cache-Control: public, max-age=[TTL]" header, regardless of any existing Cache-Control header. The actual headers served in responses will not be altered.
         */
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceBackend {
        balancingMode: string;
        capacityScaler: number;
        /**
         * Textual description for the Backend Service.
         */
        description: string;
        group: string;
        maxConnections: number;
        maxConnectionsPerEndpoint: number;
        maxConnectionsPerInstance: number;
        maxRate: number;
        maxRatePerEndpoint: number;
        maxRatePerInstance: number;
        maxUtilization: number;
    }

    export interface GetBackendServiceCdnPolicy {
        cacheKeyPolicies: outputs.compute.GetBackendServiceCdnPolicyCacheKeyPolicy[];
        signedUrlCacheMaxAgeSec: number;
    }

    export interface GetBackendServiceCdnPolicyCacheKeyPolicy {
        includeHost: boolean;
        includeProtocol: boolean;
        includeQueryString: boolean;
        queryStringBlacklists: string[];
        queryStringWhitelists: string[];
    }

    export interface GetBackendServiceCircuitBreaker {
        connectTimeouts: outputs.compute.GetBackendServiceCircuitBreakerConnectTimeout[];
        maxConnections: number;
        maxPendingRequests: number;
        maxRequests: number;
        maxRequestsPerConnection: number;
        maxRetries: number;
    }

    export interface GetBackendServiceCircuitBreakerConnectTimeout {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceConsistentHash {
        httpCookies: outputs.compute.GetBackendServiceConsistentHashHttpCooky[];
        httpHeaderName: string;
        minimumRingSize: number;
    }

    export interface GetBackendServiceConsistentHashHttpCooky {
        /**
         * The name of the Backend Service.
         */
        name: string;
        path: string;
        ttls: outputs.compute.GetBackendServiceConsistentHashHttpCookyTtl[];
    }

    export interface GetBackendServiceConsistentHashHttpCookyTtl {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceIap {
        oauth2ClientId: string;
        oauth2ClientSecret: string;
        oauth2ClientSecretSha256: string;
    }

    export interface GetBackendServiceLogConfig {
        enable: boolean;
        sampleRate: number;
    }

    export interface GetBackendServiceOutlierDetection {
        baseEjectionTimes: outputs.compute.GetBackendServiceOutlierDetectionBaseEjectionTime[];
        consecutiveErrors: number;
        consecutiveGatewayFailure: number;
        enforcingConsecutiveErrors: number;
        enforcingConsecutiveGatewayFailure: number;
        enforcingSuccessRate: number;
        intervals: outputs.compute.GetBackendServiceOutlierDetectionInterval[];
        maxEjectionPercent: number;
        successRateMinimumHosts: number;
        successRateRequestVolume: number;
        successRateStdevFactor: number;
    }

    export interface GetBackendServiceOutlierDetectionBaseEjectionTime {
        nanos: number;
        seconds: number;
    }

    export interface GetBackendServiceOutlierDetectionInterval {
        nanos: number;
        seconds: number;
    }

    export interface GetInstanceAttachedDisk {
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete: boolean;
        /**
         * Name with which the attached disk is accessible
         * under `/dev/disk/by-id/`
         */
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        /**
         * Parameters with which a disk was created alongside the instance.
         * Structure is documented below.
         */
        initializeParams: outputs.compute.GetInstanceBootDiskInitializeParam[];
        kmsKeySelfLink: string;
        /**
         * Read/write mode for the disk. One of `"READ_ONLY"` or `"READ_WRITE"`.
         */
        mode: string;
        /**
         * The name or selfLink of the disk attached to this instance.
         */
        source: string;
    }

    export interface GetInstanceBootDiskInitializeParam {
        /**
         * The image from which this disk was initialised.
         */
        image: string;
        /**
         * A set of key/value label pairs assigned to the instance.
         */
        labels: {[key: string]: any};
        /**
         * The size of the image in gigabytes.
         */
        size: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceGroupNamedPort {
        /**
         * The name of the instance group. Either `name` or `selfLink` must be provided.
         */
        name: string;
        port: number;
    }

    export interface GetInstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource exposed to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface GetInstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Structure documented below.
         */
        accessConfigs: outputs.compute.GetInstanceNetworkInterfaceAccessConfig[];
        /**
         * An array of alias IP ranges for this network interface. Structure documented below.
         */
        aliasIpRanges: outputs.compute.GetInstanceNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance. One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * The name or selfLink of the network attached to this interface.
         */
        network: string;
        /**
         * The private IP address assigned to the instance.
         */
        networkIp: string;
        /**
         * The name or selfLink of the subnetwork attached to this interface.
         */
        subnetwork: string;
        /**
         * The project in which the subnetwork belongs.
         */
        subnetworkProject: string;
    }

    export interface GetInstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that is be 1:1 mapped to the instance's
         * network ip.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring this instance. One of `PREMIUM` or `STANDARD`.
         */
        networkTier: string;
        /**
         * The DNS domain name for the public PTR record.
         */
        publicPtrDomainName: string;
    }

    export interface GetInstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range.
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range.
         */
        subnetworkRangeName: string;
    }

    export interface GetInstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         */
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.GetInstanceSchedulingNodeAffinity[];
        /**
         * Describes maintenance behavior for the
         * instance. One of `MIGRATE` or `TERMINATE`, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)
         */
        onHostMaintenance: string;
        /**
         * Whether the instance is preemptible.
         */
        preemptible: boolean;
    }

    export interface GetInstanceSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface GetInstanceScratchDisk {
        /**
         * The disk interface used for attaching this disk. One of `SCSI` or `NVME`.
         */
        interface: string;
    }

    export interface GetInstanceServiceAccount {
        /**
         * The service account e-mail address.
         */
        email: string;
        /**
         * A list of service scopes.
         */
        scopes: string[];
    }

    export interface GetInstanceShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface GetRegionInstanceGroupInstance {
        /**
         * URL to the instance.
         */
        instance: string;
        /**
         * List of named ports in the group, as a list of resources, each containing:
         */
        namedPorts: outputs.compute.GetRegionInstanceGroupInstanceNamedPort[];
        /**
         * String description of current state of the instance.
         */
        status: string;
    }

    export interface GetRegionInstanceGroupInstanceNamedPort {
        /**
         * The name of the instance group.  One of `name` or `selfLink` must be provided.
         */
        name: string;
        /**
         * Integer port number
         */
        port: number;
    }

    export interface GetRouterBgp {
        advertiseMode: string;
        advertisedGroups: string[];
        advertisedIpRanges: outputs.compute.GetRouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface GetRouterBgpAdvertisedIpRange {
        description: string;
        range: string;
    }

    export interface GetSubnetworkSecondaryIpRange {
        /**
         * The range of IP addresses belonging to this subnetwork
         * secondary range.
         */
        ipCidrRange: string;
        /**
         * The name associated with this subnetwork secondary range, used
         * when adding an alias IP range to a VM instance.
         */
        rangeName: string;
    }

    export interface GlobalForwardingRuleMetadataFilter {
        filterLabels: outputs.compute.GlobalForwardingRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface GlobalForwardingRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface HaVpnGatewayVpnInterface {
        /**
         * an identifier for the resource with format `projects/{{project}}/regions/{{region}}/vpnGateways/{{name}}`
         */
        id?: number;
        ipAddress?: string;
    }

    export interface HealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface HealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface HealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface ImageGuestOsFeature {
        type: string;
    }

    export interface ImageRawDisk {
        containerType?: string;
        sha1?: string;
        source: string;
    }

    export interface InstanceAttachedDisk {
        /**
         * Name with which the attached disk will be accessible
         * under `/dev/disk/by-id/google-*`
         */
        deviceName: string;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink` and `diskEncryptionKeyRaw` may be set.
         */
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`
         * and `diskEncryptionKeyRaw` may be set.
         */
        kmsKeySelfLink: string;
        /**
         * Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
         * If you have a persistent disk with data that you want to share
         * between multiple instances, detach it from any read-write instances and
         * attach it to one or more instances in read-only mode.
         */
        mode?: string;
        /**
         * The name or selfLink of the disk to attach to this instance.
         */
        source: string;
    }

    export interface InstanceBootDisk {
        /**
         * Whether the disk will be auto-deleted when the instance
         * is deleted. Defaults to true.
         */
        autoDelete?: boolean;
        /**
         * Name with which the attached disk will be accessible
         * under `/dev/disk/by-id/google-*`
         */
        deviceName: string;
        /**
         * A 256-bit [customer-supplied encryption key]
         * (https://cloud.google.com/compute/docs/disks/customer-supplied-encryption),
         * encoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)
         * to encrypt this disk. Only one of `kmsKeySelfLink` and `diskEncryptionKeyRaw` may be set.
         */
        diskEncryptionKeyRaw?: string;
        diskEncryptionKeySha256: string;
        /**
         * Parameters for a new disk that will be created
         * alongside the new instance. Either `initializeParams` or `source` must be set.
         * Structure is documented below.
         */
        initializeParams: outputs.compute.InstanceBootDiskInitializeParams;
        /**
         * The selfLink of the encryption key that is
         * stored in Google Cloud KMS to encrypt this disk. Only one of `kmsKeySelfLink`
         * and `diskEncryptionKeyRaw` may be set.
         */
        kmsKeySelfLink: string;
        /**
         * Either "READ_ONLY" or "READ_WRITE", defaults to "READ_WRITE"
         * If you have a persistent disk with data that you want to share
         * between multiple instances, detach it from any read-write instances and
         * attach it to one or more instances in read-only mode.
         */
        mode?: string;
        /**
         * The name or selfLink of the disk to attach to this instance.
         */
        source: string;
    }

    export interface InstanceBootDiskInitializeParams {
        /**
         * The image from which to initialize this disk. This can be
         * one of: the image's `selfLink`, `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`. If referred by family, the
         * images names must include the family name. If they don't, use the
         * [gcp.compute.Image data source](https://www.terraform.io/docs/providers/google/d/datasource_compute_image.html).
         * For instance, the image `centos-6-v20180104` includes its family name `centos-6`.
         * These images can be referred by family name here.
         */
        image: string;
        /**
         * A map of key/value label pairs to assign to the instance.
         */
        labels: {[key: string]: any};
        /**
         * The size of the image in gigabytes. If not specified, it
         * will inherit the size of its base image.
         */
        size: number;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface InstanceFromTemplateAttachedDisk {
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDisk {
        autoDelete: boolean;
        deviceName: string;
        diskEncryptionKeyRaw: string;
        diskEncryptionKeySha256: string;
        initializeParams: outputs.compute.InstanceFromTemplateBootDiskInitializeParams;
        kmsKeySelfLink: string;
        mode: string;
        source: string;
    }

    export interface InstanceFromTemplateBootDiskInitializeParams {
        image: string;
        labels: {[key: string]: any};
        size: number;
        type: string;
    }

    export interface InstanceFromTemplateGuestAccelerator {
        count: number;
        type: string;
    }

    export interface InstanceFromTemplateNetworkInterface {
        accessConfigs: outputs.compute.InstanceFromTemplateNetworkInterfaceAccessConfig[];
        aliasIpRanges: outputs.compute.InstanceFromTemplateNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        network: string;
        networkIp: string;
        subnetwork: string;
        subnetworkProject: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAccessConfig {
        natIp: string;
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceFromTemplateNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface InstanceFromTemplateScheduling {
        automaticRestart: boolean;
        nodeAffinities: outputs.compute.InstanceFromTemplateSchedulingNodeAffinity[];
        onHostMaintenance: string;
        preemptible: boolean;
    }

    export interface InstanceFromTemplateSchedulingNodeAffinity {
        key: string;
        operator: string;
        values: string[];
    }

    export interface InstanceFromTemplateScratchDisk {
        interface: string;
    }

    export interface InstanceFromTemplateServiceAccount {
        email: string;
        scopes: string[];
    }

    export interface InstanceFromTemplateShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
        enableVtpm: boolean;
    }

    export interface InstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: string;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: number;
    }

    export interface InstanceGroupManagerNamedPort {
        /**
         * - Version name.
         */
        name: string;
        /**
         * The port number.
         * - - -
         */
        port: number;
    }

    export interface InstanceGroupManagerUpdatePolicy {
        /**
         * , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `maxSurgePercent`. If neither is set, defaults to 1
         */
        maxSurgeFixed: number;
        /**
         * , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `maxSurgeFixed`.
         */
        maxSurgePercent?: number;
        /**
         * , The maximum number of instances that can be unavailable during the update process. Conflicts with `maxUnavailablePercent`. If neither is set, defaults to 1
         */
        maxUnavailableFixed: number;
        /**
         * , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `maxUnavailableFixed`.
         */
        maxUnavailablePercent?: number;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         * - - -
         */
        minReadySec?: number;
        /**
         * - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: string;
        /**
         * - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: string;
    }

    export interface InstanceGroupManagerVersion {
        /**
         * - The full URL to an instance template from which all new instances of this version will be created.
         */
        instanceTemplate: string;
        /**
         * - Version name.
         */
        name?: string;
        /**
         * - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         */
        targetSize?: outputs.compute.InstanceGroupManagerVersionTargetSize;
    }

    export interface InstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: number;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: number;
    }

    export interface InstanceGroupNamedPort {
        /**
         * The name which the port will be mapped to.
         */
        name: string;
        /**
         * The port number to map the name to.
         */
        port: number;
    }

    export interface InstanceGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface InstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface InstanceNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Omit to ensure that the instance
         * is not accessible from the Internet. If omitted, ssh will not
         * work unless this provider can send traffic to the instance's network (e.g. via
         * tunnel or because it is running on another cloud instance on that network).
         * This block can be repeated multiple times. Structure documented below.
         */
        accessConfigs?: outputs.compute.InstanceNetworkInterfaceAccessConfig[];
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: outputs.compute.InstanceNetworkInterfaceAliasIpRange[];
        /**
         * A unique name for the resource, required by GCE.
         * Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Either `network` or `subnetwork` must be provided.
         */
        network: string;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp: string;
        /**
         * The name or selfLink of the subnetwork to attach this
         * interface to. The subnetwork must exist in the same region this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork: string;
        /**
         * The project in which the subnetwork belongs.
         * If the `subnetwork` is a self_link, this field is ignored in favor of the project
         * defined in the subnetwork self_link. If the `subnetwork` is a name and this
         * field is not provided, the provider project is used.
         */
        subnetworkProject: string;
    }

    export interface InstanceNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring this instance.
         * This field can take the following values: PREMIUM or STANDARD. If this field is
         * not specified, it is assumed to be PREMIUM.
         */
        networkTier: string;
        /**
         * The DNS domain name for the public PTR record.
         * To set this field on an instance, you must be verified as the owner of the domain.
         * See [the docs](https://cloud.google.com/compute/docs/instances/create-ptr-record) for how
         * to become verified as a domain owner.
         */
        publicPtrDomainName?: string;
    }

    export interface InstanceNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. This range may be a single IP address
         * (e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: string;
    }

    export interface InstanceScheduling {
        /**
         * Specifies if the instance should be
         * restarted if it was terminated by Compute Engine (not a user).
         * Defaults to true.
         */
        automaticRestart?: boolean;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: outputs.compute.InstanceSchedulingNodeAffinity[];
        /**
         * Describes maintenance behavior for the
         * instance. Can be MIGRATE or TERMINATE, for more info, read
         * [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).
         */
        onHostMaintenance: string;
        /**
         * Specifies if the instance is preemptible.
         * If this field is set to true, then `automaticRestart` must be
         * set to false.  Defaults to false.
         */
        preemptible?: boolean;
    }

    export interface InstanceSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: string;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: string;
        values: string[];
    }

    export interface InstanceScratchDisk {
        /**
         * The disk interface to use for attaching this disk; either SCSI or NVME.
         */
        interface: string;
    }

    export interface InstanceServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        email: string;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         * **Note**: `allowStoppingForUpdate` must be set to true or your instance must have a `desiredStatus` of `TERMINATED` in order to update this field.
         */
        scopes: string[];
    }

    export interface InstanceShieldedInstanceConfig {
        /**
         * -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: boolean;
        /**
         * -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: boolean;
        /**
         * -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: boolean;
    }

    export interface InstanceTemplateDisk {
        /**
         * Whether or not the disk should be auto-deleted.
         * This defaults to true.
         */
        autoDelete?: boolean;
        /**
         * Indicates that this is a boot disk.
         */
        boot: boolean;
        /**
         * A unique device name that is reflected into the
         * /dev/  tree of a Linux operating system running within the instance. If not
         * specified, the server chooses a default device name to apply to this disk.
         */
        deviceName: string;
        /**
         * Encrypts or decrypts a disk using a customer-supplied encryption key.
         */
        diskEncryptionKey?: outputs.compute.InstanceTemplateDiskDiskEncryptionKey;
        /**
         * Name of the disk. When not provided, this defaults
         * to the name of the instance.
         */
        diskName?: string;
        /**
         * The size of the image in gigabytes. If not
         * specified, it will inherit the size of its base image. For SCRATCH disks,
         * the size must be exactly 375GB.
         */
        diskSizeGb?: number;
        /**
         * The GCE disk type. Can be either `"pd-ssd"`,
         * `"local-ssd"`, or `"pd-standard"`.
         */
        diskType: string;
        /**
         * Specifies the disk interface to use for attaching
         * this disk.
         */
        interface: string;
        /**
         * A set of key/value label pairs to assign to instances
         * created from this template,
         */
        labels?: {[key: string]: string};
        /**
         * The mode in which to attach this disk, either READ_WRITE
         * or READ_ONLY. If you are attaching or creating a boot disk, this must
         * read-write mode.
         */
        mode: string;
        /**
         * The name (**not self_link**)
         * of the disk (such as those managed by `gcp.compute.Disk`) to attach.
         */
        source?: string;
        /**
         * The image from which to
         * initialize this disk. This can be one of: the image's `selfLink`,
         * `projects/{project}/global/images/{image}`,
         * `projects/{project}/global/images/family/{family}`, `global/images/{image}`,
         * `global/images/family/{family}`, `family/{family}`, `{project}/{family}`,
         * `{project}/{image}`, `{family}`, or `{image}`.
         */
        sourceImage: string;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface InstanceTemplateDiskDiskEncryptionKey {
        /**
         * The self link of the encryption key that is stored in Google Cloud KMS
         */
        kmsKeySelfLink: string;
    }

    export interface InstanceTemplateGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface InstanceTemplateNetworkInterface {
        /**
         * Access configurations, i.e. IPs via which this
         * instance can be accessed via the Internet. Omit to ensure that the instance
         * is not accessible from the Internet (this means that ssh provisioners will
         * not work unless you can send traffic to the instance's
         * network (e.g. via tunnel or because it is running on another cloud instance
         * on that network). This block can be repeated multiple times. Structure documented below.
         */
        accessConfigs?: outputs.compute.InstanceTemplateNetworkInterfaceAccessConfig[];
        /**
         * An
         * array of alias IP ranges for this network interface. Can only be specified for network
         * interfaces on subnet-mode networks. Structure documented below.
         */
        aliasIpRanges?: outputs.compute.InstanceTemplateNetworkInterfaceAliasIpRange[];
        /**
         * The name of the instance template. If you leave
         * this blank, the provider will auto-generate a unique name.
         */
        name: string;
        /**
         * The name or selfLink of the network to attach this interface to.
         * Use `network` attribute for Legacy or Auto subnetted networks and
         * `subnetwork` for custom subnetted networks.
         */
        network: string;
        /**
         * The private IP address to assign to the instance. If
         * empty, the address will be automatically assigned.
         */
        networkIp?: string;
        /**
         * the name of the subnetwork to attach this interface
         * to. The subnetwork must exist in the same `region` this instance will be
         * created in. Either `network` or `subnetwork` must be provided.
         */
        subnetwork: string;
        /**
         * The ID of the project in which the subnetwork belongs.
         * If it is not provided, the provider project is used.
         */
        subnetworkProject: string;
    }

    export interface InstanceTemplateNetworkInterfaceAccessConfig {
        /**
         * The IP address that will be 1:1 mapped to the instance's
         * network ip. If not given, one will be generated.
         */
        natIp: string;
        /**
         * The [networking tier][network-tier] used for configuring
         * this instance template. This field can take the following values: PREMIUM or
         * STANDARD. If this field is not specified, it is assumed to be PREMIUM.
         */
        networkTier: string;
        publicPtrDomainName: string;
    }

    export interface InstanceTemplateNetworkInterfaceAliasIpRange {
        /**
         * The IP CIDR range represented by this alias IP range. This IP CIDR range
         * must belong to the specified subnetwork and cannot contain IP addresses reserved by
         * system or used by other network interfaces. At the time of writing only a
         * netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API
         * error.
         */
        ipCidrRange: string;
        /**
         * The subnetwork secondary range name specifying
         * the secondary range from which to allocate the IP CIDR range for this alias IP
         * range. If left unspecified, the primary range of the subnetwork will be used.
         */
        subnetworkRangeName?: string;
    }

    export interface InstanceTemplateScheduling {
        /**
         * Specifies whether the instance should be
         * automatically restarted if it is terminated by Compute Engine (not
         * terminated by a user). This defaults to true.
         */
        automaticRestart?: boolean;
        /**
         * Specifies node affinities or anti-affinities
         * to determine which sole-tenant nodes your instances and managed instance
         * groups will use as host systems. Read more on sole-tenant node creation
         * [here](https://cloud.google.com/compute/docs/nodes/create-nodes).
         * Structure documented below.
         */
        nodeAffinities?: outputs.compute.InstanceTemplateSchedulingNodeAffinity[];
        /**
         * Defines the maintenance behavior for this
         * instance.
         */
        onHostMaintenance: string;
        /**
         * Allows instance to be preempted. This defaults to
         * false. Read more on this
         * [here](https://cloud.google.com/compute/docs/instances/preemptible).
         */
        preemptible?: boolean;
    }

    export interface InstanceTemplateSchedulingNodeAffinity {
        /**
         * The key for the node affinity label.
         */
        key: string;
        /**
         * The operator. Can be `IN` for node-affinities
         * or `NOT_IN` for anti-affinities.
         */
        operator: string;
        values: string[];
    }

    export interface InstanceTemplateServiceAccount {
        /**
         * The service account e-mail address. If not given, the
         * default Google Compute Engine service account is used.
         */
        email: string;
        /**
         * A list of service scopes. Both OAuth2 URLs and gcloud
         * short names are supported. To allow full access to all Cloud APIs, use the
         * `cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).
         */
        scopes: string[];
    }

    export interface InstanceTemplateShieldedInstanceConfig {
        /**
         * -- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
         */
        enableIntegrityMonitoring?: boolean;
        /**
         * -- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
         */
        enableSecureBoot?: boolean;
        /**
         * -- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
         */
        enableVtpm?: boolean;
    }

    export interface InterconnectAttachmentPrivateInterconnectInfo {
        tag8021q: number;
    }

    export interface ManagedSslCertificateManaged {
        domains: string[];
    }

    export interface MangedSslCertificateManaged {
        domains: string[];
    }

    export interface NodeGroupAutoscalingPolicy {
        maxNodes: number;
        minNodes: number;
        mode: string;
    }

    export interface NodeTemplateNodeTypeFlexibility {
        cpus?: string;
        localSsd: string;
        memory?: string;
    }

    export interface NodeTemplateServerBinding {
        type: string;
    }

    export interface PacketMirroringCollectorIlb {
        url: string;
    }

    export interface PacketMirroringFilter {
        cidrRanges?: string[];
        ipProtocols?: string[];
    }

    export interface PacketMirroringMirroredResources {
        instances?: outputs.compute.PacketMirroringMirroredResourcesInstance[];
        subnetworks?: outputs.compute.PacketMirroringMirroredResourcesSubnetwork[];
        tags?: string[];
    }

    export interface PacketMirroringMirroredResourcesInstance {
        url: string;
    }

    export interface PacketMirroringMirroredResourcesSubnetwork {
        url: string;
    }

    export interface PacketMirroringNetwork {
        url: string;
    }

    export interface RegionAutoscalerAutoscalingPolicy {
        cooldownPeriod?: number;
        cpuUtilization: outputs.compute.RegionAutoscalerAutoscalingPolicyCpuUtilization;
        loadBalancingUtilization?: outputs.compute.RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization;
        maxReplicas: number;
        metrics?: outputs.compute.RegionAutoscalerAutoscalingPolicyMetric[];
        minReplicas: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyCpuUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyLoadBalancingUtilization {
        target: number;
    }

    export interface RegionAutoscalerAutoscalingPolicyMetric {
        filter?: string;
        name: string;
        singleInstanceAssignment?: number;
        target?: number;
        type?: string;
    }

    export interface RegionBackendServiceBackend {
        balancingMode?: string;
        capacityScaler?: number;
        description?: string;
        failover: boolean;
        group: string;
        maxConnections?: number;
        maxConnectionsPerEndpoint?: number;
        maxConnectionsPerInstance?: number;
        maxRate?: number;
        maxRatePerEndpoint?: number;
        maxRatePerInstance?: number;
        maxUtilization?: number;
    }

    export interface RegionBackendServiceCircuitBreakers {
        connectTimeout?: outputs.compute.RegionBackendServiceCircuitBreakersConnectTimeout;
        maxConnections?: number;
        maxPendingRequests?: number;
        maxRequests?: number;
        maxRequestsPerConnection?: number;
        maxRetries?: number;
    }

    export interface RegionBackendServiceCircuitBreakersConnectTimeout {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceConsistentHash {
        httpCookie?: outputs.compute.RegionBackendServiceConsistentHashHttpCookie;
        httpHeaderName?: string;
        minimumRingSize?: number;
    }

    export interface RegionBackendServiceConsistentHashHttpCookie {
        name?: string;
        path?: string;
        ttl?: outputs.compute.RegionBackendServiceConsistentHashHttpCookieTtl;
    }

    export interface RegionBackendServiceConsistentHashHttpCookieTtl {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceFailoverPolicy {
        disableConnectionDrainOnFailover?: boolean;
        dropTrafficIfUnhealthy?: boolean;
        failoverRatio?: number;
    }

    export interface RegionBackendServiceLogConfig {
        enable?: boolean;
        sampleRate?: number;
    }

    export interface RegionBackendServiceOutlierDetection {
        baseEjectionTime?: outputs.compute.RegionBackendServiceOutlierDetectionBaseEjectionTime;
        consecutiveErrors?: number;
        consecutiveGatewayFailure?: number;
        enforcingConsecutiveErrors?: number;
        enforcingConsecutiveGatewayFailure?: number;
        enforcingSuccessRate?: number;
        interval?: outputs.compute.RegionBackendServiceOutlierDetectionInterval;
        maxEjectionPercent?: number;
        successRateMinimumHosts?: number;
        successRateRequestVolume?: number;
        successRateStdevFactor?: number;
    }

    export interface RegionBackendServiceOutlierDetectionBaseEjectionTime {
        nanos?: number;
        seconds: number;
    }

    export interface RegionBackendServiceOutlierDetectionInterval {
        nanos?: number;
        seconds: number;
    }

    export interface RegionDiskDiskEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionDiskSourceSnapshotEncryptionKey {
        kmsKeyName?: string;
        rawKey?: string;
        sha256: string;
    }

    export interface RegionHealthCheckHttp2HealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckHttpsHealthCheck {
        host?: string;
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        requestPath?: string;
        response?: string;
    }

    export interface RegionHealthCheckSslHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionHealthCheckTcpHealthCheck {
        port?: number;
        portName?: string;
        portSpecification?: string;
        proxyHeader?: string;
        request?: string;
        response?: string;
    }

    export interface RegionInstanceGroupManagerAutoHealingPolicies {
        /**
         * The health check resource that signals autohealing.
         */
        healthCheck: string;
        /**
         * The number of seconds that the managed instance group waits before
         * it applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.
         */
        initialDelaySec: number;
    }

    export interface RegionInstanceGroupManagerNamedPort {
        /**
         * - Version name.
         */
        name: string;
        /**
         * The port number.
         * - - -
         */
        port: number;
    }

    export interface RegionInstanceGroupManagerUpdatePolicy {
        /**
         * - The instance redistribution policy for regional managed instance groups. Valid values are: `"PROACTIVE"`, `"NONE"`. If `PROACTIVE` (default), the group attempts to maintain an even distribution of VM instances across zones in the region. If `NONE`, proactive redistribution is disabled.
         */
        instanceRedistributionType?: string;
        /**
         * , The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `maxSurgePercent`. It has to be either 0 or at least equal to the number of zones.  If fixed values are used, at least one of `maxUnavailableFixed` or `maxSurgeFixed` must be greater than 0.
         */
        maxSurgeFixed: number;
        /**
         * , The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `maxSurgeFixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
         */
        maxSurgePercent?: number;
        /**
         * , The maximum number of instances that can be unavailable during the update process. Conflicts with `maxUnavailablePercent`. It has to be either 0 or at least equal to the number of zones. If fixed values are used, at least one of `maxUnavailableFixed` or `maxSurgeFixed` must be greater than 0.
         */
        maxUnavailableFixed: number;
        /**
         * , The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `maxUnavailableFixed`. Percent value is only allowed for regional managed instance groups with size at least 10.
         */
        maxUnavailablePercent?: number;
        /**
         * , Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]
         * - - -
         */
        minReadySec?: number;
        /**
         * - Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
         */
        minimalAction: string;
        /**
         * - The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
         */
        type: string;
    }

    export interface RegionInstanceGroupManagerVersion {
        /**
         * - The full URL to an instance template from which all new instances of this version will be created.
         */
        instanceTemplate: string;
        /**
         * - Version name.
         */
        name?: string;
        /**
         * - The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.
         */
        targetSize?: outputs.compute.RegionInstanceGroupManagerVersionTargetSize;
    }

    export interface RegionInstanceGroupManagerVersionTargetSize {
        /**
         * , The number of instances which are managed for this version. Conflicts with `percent`.
         */
        fixed?: number;
        /**
         * , The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.
         * Note that when using `percent`, rounding will be in favor of explicitly set `targetSize` values; a managed instance group with 2 instances and 2 `version`s,
         * one of which has a `target_size.percent` of `60` will create 2 instances of that `version`.
         */
        percent?: number;
    }

    export interface RegionUrlMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface RegionUrlMapPathMatcher {
        defaultService: string;
        description?: string;
        name: string;
        pathRules?: outputs.compute.RegionUrlMapPathMatcherPathRule[];
        routeRules?: outputs.compute.RegionUrlMapPathMatcherRouteRule[];
    }

    export interface RegionUrlMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherPathRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRule {
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.RegionUrlMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface RegionUrlMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface RegionUrlMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }

    export interface ReservationSpecificReservation {
        count: number;
        inUseCount: number;
        instanceProperties: outputs.compute.ReservationSpecificReservationInstanceProperties;
    }

    export interface ReservationSpecificReservationInstanceProperties {
        guestAccelerators?: outputs.compute.ReservationSpecificReservationInstancePropertiesGuestAccelerator[];
        localSsds?: outputs.compute.ReservationSpecificReservationInstancePropertiesLocalSsd[];
        machineType: string;
        minCpuPlatform: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesGuestAccelerator {
        acceleratorCount: number;
        acceleratorType: string;
    }

    export interface ReservationSpecificReservationInstancePropertiesLocalSsd {
        diskSizeGb: number;
        interface?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicy {
        retentionPolicy?: outputs.compute.ResourcePolicySnapshotSchedulePolicyRetentionPolicy;
        schedule: outputs.compute.ResourcePolicySnapshotSchedulePolicySchedule;
        snapshotProperties?: outputs.compute.ResourcePolicySnapshotSchedulePolicySnapshotProperties;
    }

    export interface ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
        maxRetentionDays: number;
        onSourceDiskDelete?: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySchedule {
        dailySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule;
        hourlySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule;
        weeklySchedule?: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleDailySchedule {
        daysInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleHourlySchedule {
        hoursInCycle: number;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklySchedule {
        dayOfWeeks: outputs.compute.ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek[];
    }

    export interface ResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeek {
        day: string;
        startTime: string;
    }

    export interface ResourcePolicySnapshotSchedulePolicySnapshotProperties {
        guestFlush?: boolean;
        labels?: {[key: string]: string};
        storageLocations?: string;
    }

    export interface RouterBgp {
        advertiseMode?: string;
        advertisedGroups?: string[];
        advertisedIpRanges?: outputs.compute.RouterBgpAdvertisedIpRange[];
        asn: number;
    }

    export interface RouterBgpAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface RouterNatLogConfig {
        enable: boolean;
        filter: string;
    }

    export interface RouterNatSubnetwork {
        name: string;
        secondaryIpRangeNames?: string[];
        sourceIpRangesToNats: string[];
    }

    export interface RouterPeerAdvertisedIpRange {
        description?: string;
        range: string;
    }

    export interface SecurityPolicyRule {
        /**
         * Action to take when `match` matches the request. Valid values:
         * * "allow" : allow access to target
         * * "deny(status)" : deny access to target, returns the  HTTP response code specified (valid values are 403, 404 and 502)
         */
        action: string;
        /**
         * An optional description of this rule. Max size is 64.
         */
        description?: string;
        /**
         * A match condition that incoming traffic is evaluated against.
         * If it evaluates to true, the corresponding `action` is enforced. Structure is documented below.
         */
        match: outputs.compute.SecurityPolicyRuleMatch;
        /**
         * When set to true, the `action` specified above is not enforced.
         * Stackdriver logs for requests that trigger a preview action are annotated as such.
         */
        preview?: boolean;
        /**
         * An unique positive integer indicating the priority of evaluation for a rule.
         * Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
         */
        priority: number;
    }

    export interface SecurityPolicyRuleMatch {
        /**
         * The configuration options available when specifying `versionedExpr`.
         * This field must be specified if `versionedExpr` is specified and cannot be specified if `versionedExpr` is not specified.
         * Structure is documented below.
         */
        config?: outputs.compute.SecurityPolicyRuleMatchConfig;
        /**
         * User defined CEVAL expression. A CEVAL expression is used to specify match criteria
         * such as origin.ip, source.region_code and contents in the request header.
         * Structure is documented below.
         */
        expr?: outputs.compute.SecurityPolicyRuleMatchExpr;
        /**
         * Predefined rule expression. If this field is specified, `config` must also be specified.
         * Available options:
         * * SRC_IPS_V1: Must specify the corresponding `srcIpRanges` field in `config`.
         */
        versionedExpr?: string;
    }

    export interface SecurityPolicyRuleMatchConfig {
        /**
         * Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation
         * to match against inbound traffic. There is a limit of 5 IP ranges per rule. A value of '\*' matches all IPs
         * (can be used to override the default behavior).
         */
        srcIpRanges: string[];
    }

    export interface SecurityPolicyRuleMatchExpr {
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         * The application context of the containing message determines which well-known feature set of CEL is supported.
         */
        expression: string;
    }

    export interface SecurityScanConfigAuthentication {
        customAccount?: outputs.compute.SecurityScanConfigAuthenticationCustomAccount;
        googleAccount?: outputs.compute.SecurityScanConfigAuthenticationGoogleAccount;
    }

    export interface SecurityScanConfigAuthenticationCustomAccount {
        loginUrl: string;
        password: string;
        username: string;
    }

    export interface SecurityScanConfigAuthenticationGoogleAccount {
        password: string;
        username: string;
    }

    export interface SecurityScanConfigSchedule {
        intervalDurationDays: number;
        scheduleTime?: string;
    }

    export interface SnapshotSnapshotEncryptionKey {
        rawKey: string;
        sha256: string;
    }

    export interface SnapshotSourceDiskEncryptionKey {
        rawKey?: string;
    }

    export interface SubnetworkIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface SubnetworkIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface SubnetworkLogConfig {
        aggregationInterval?: string;
        flowSampling?: number;
        metadata?: string;
    }

    export interface SubnetworkSecondaryIpRange {
        ipCidrRange: string;
        rangeName: string;
    }

    export interface URLMapHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapHostRule {
        description?: string;
        hosts: string[];
        pathMatcher: string;
    }

    export interface URLMapPathMatcher {
        defaultService?: string;
        description?: string;
        headerAction?: outputs.compute.URLMapPathMatcherHeaderAction;
        name: string;
        pathRules?: outputs.compute.URLMapPathMatcherPathRule[];
        routeRules?: outputs.compute.URLMapPathMatcherRouteRule[];
    }

    export interface URLMapPathMatcherHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRule {
        paths: string[];
        routeAction?: outputs.compute.URLMapPathMatcherPathRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherPathRuleUrlRedirect;
    }

    export interface URLMapPathMatcherPathRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherPathRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus: number;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay: outputs.compute.URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicy {
        numRetries?: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherPathRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery: boolean;
    }

    export interface URLMapPathMatcherRouteRule {
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleHeaderAction;
        matchRules?: outputs.compute.URLMapPathMatcherRouteRuleMatchRule[];
        priority: number;
        routeAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteAction;
        service?: string;
        urlRedirect?: outputs.compute.URLMapPathMatcherRouteRuleUrlRedirect;
    }

    export interface URLMapPathMatcherRouteRuleHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleMatchRule {
        fullPathMatch?: string;
        headerMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatch[];
        ignoreCase?: boolean;
        metadataFilters?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilter[];
        prefixMatch?: string;
        queryParameterMatches?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch[];
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatch {
        exactMatch?: string;
        headerName: string;
        invertMatch?: boolean;
        prefixMatch?: string;
        presentMatch?: boolean;
        rangeMatch?: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch;
        regexMatch?: string;
        suffixMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleHeaderMatchRangeMatch {
        rangeEnd: number;
        rangeStart: number;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilter {
        filterLabels: outputs.compute.URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel[];
        filterMatchCriteria: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleMetadataFilterFilterLabel {
        name: string;
        value: string;
    }

    export interface URLMapPathMatcherRouteRuleMatchRuleQueryParameterMatch {
        exactMatch?: string;
        name: string;
        presentMatch?: boolean;
        regexMatch?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteAction {
        corsPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionCorsPolicy;
        faultInjectionPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy;
        requestMirrorPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy;
        retryPolicy?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicy;
        timeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionTimeout;
        urlRewrite?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionUrlRewrite;
        weightedBackendServices?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendService[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionCorsPolicy {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOriginRegexes?: string[];
        allowOrigins?: string[];
        disabled?: boolean;
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicy {
        abort?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort;
        delay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyAbort {
        httpStatus?: number;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelay {
        fixedDelay?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay;
        percentage?: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRequestMirrorPolicy {
        backendService: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicy {
        numRetries: number;
        perTryTimeout?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout;
        retryConditions?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionRetryPolicyPerTryTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionTimeout {
        nanos?: number;
        seconds: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionUrlRewrite {
        hostRewrite?: string;
        pathPrefixRewrite?: string;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendService {
        backendService: string;
        headerAction?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction;
        weight: number;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderAction {
        requestHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd[];
        requestHeadersToRemoves?: string[];
        responseHeadersToAdds?: outputs.compute.URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd[];
        responseHeadersToRemoves?: string[];
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionRequestHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleRouteActionWeightedBackendServiceHeaderActionResponseHeadersToAdd {
        headerName: string;
        headerValue: string;
        replace: boolean;
    }

    export interface URLMapPathMatcherRouteRuleUrlRedirect {
        hostRedirect?: string;
        httpsRedirect?: boolean;
        pathRedirect?: string;
        prefixRedirect?: string;
        redirectResponseCode?: string;
        stripQuery?: boolean;
    }

    export interface URLMapTest {
        description?: string;
        host: string;
        path: string;
        service: string;
    }
}

export namespace container {
    export interface ClusterAddonsConfig {
        /**
         * .
         * The status of the CloudRun addon. It requires `istioConfig` enabled. It is disabled by default.
         * Set `disabled = false` to enable. This addon can only be enabled at cluster creation time.
         */
        cloudrunConfig: outputs.container.ClusterAddonsConfigCloudrunConfig;
        /**
         * .
         * The status of the NodeLocal DNSCache addon. It is disabled by default.
         * Set `enabled = true` to enable.
         */
        dnsCacheConfig: outputs.container.ClusterAddonsConfigDnsCacheConfig;
        /**
         * The status of the Horizontal Pod Autoscaling
         * addon, which increases or decreases the number of replica pods a replication controller
         * has based on the resource usage of the existing pods.
         * It ensures that a Heapster pod is running in the cluster, which is also used by the Cloud Monitoring service.
         * It is enabled by default;
         * set `disabled = true` to disable.
         */
        horizontalPodAutoscaling: outputs.container.ClusterAddonsConfigHorizontalPodAutoscaling;
        /**
         * The status of the HTTP (L7) load balancing
         * controller addon, which makes it easy to set up HTTP load balancers for services in a
         * cluster. It is enabled by default; set `disabled = true` to disable.
         */
        httpLoadBalancing: outputs.container.ClusterAddonsConfigHttpLoadBalancing;
        /**
         * .
         * Structure is documented below.
         */
        istioConfig: outputs.container.ClusterAddonsConfigIstioConfig;
        /**
         * Whether we should enable the network policy addon
         * for the master.  This must be enabled in order to enable network policy for the nodes.
         * To enable this, you must also define a `networkPolicy` block,
         * otherwise nothing will happen.
         * It can only be disabled if the nodes already do not have network policies enabled.
         * Defaults to disabled; set `disabled = false` to enable.
         */
        networkPolicyConfig: outputs.container.ClusterAddonsConfigNetworkPolicyConfig;
    }

    export interface ClusterAddonsConfigCloudrunConfig {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: boolean;
    }

    export interface ClusterAddonsConfigDnsCacheConfig {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: boolean;
    }

    export interface ClusterAddonsConfigHorizontalPodAutoscaling {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: boolean;
    }

    export interface ClusterAddonsConfigHttpLoadBalancing {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: boolean;
    }

    export interface ClusterAddonsConfigIstioConfig {
        /**
         * The authentication type between services in Istio. Available options include `AUTH_MUTUAL_TLS`.
         */
        auth?: string;
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: boolean;
    }

    export interface ClusterAddonsConfigNetworkPolicyConfig {
        /**
         * The status of the Istio addon, which makes it easy to set up Istio for services in a
         * cluster. It is disabled by default. Set `disabled = false` to enable.
         */
        disabled: boolean;
    }

    export interface ClusterAuthenticatorGroupsConfig {
        /**
         * The name of the RBAC security group for use with Google security groups in Kubernetes RBAC. Group name must be in format `gke-security-groups@yourdomain.com`.
         */
        securityGroup: string;
    }

    export interface ClusterClusterAutoscaling {
        /**
         * Contains defaults for a node pool created by NAP.
         * Structure is documented below.
         */
        autoProvisioningDefaults: outputs.container.ClusterClusterAutoscalingAutoProvisioningDefaults;
        /**
         * Configuration
         * options for the [Autoscaling profile](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#autoscaling_profiles)
         * feature, which lets you choose whether the cluster autoscaler should optimize for resource utilization or resource availability
         * when deciding to remove nodes from a cluster. Can be `BALANCED` or `OPTIMIZE_UTILIZATION`. Defaults to `BALANCED`.
         */
        autoscalingProfile?: string;
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: boolean;
        /**
         * Global constraints for machine resources in the
         * cluster. Configuring the `cpu` and `memory` types is required if node
         * auto-provisioning is enabled. These limits will apply to node pool autoscaling
         * in addition to node auto-provisioning. Structure is documented below.
         */
        resourceLimits?: outputs.container.ClusterClusterAutoscalingResourceLimit[];
    }

    export interface ClusterClusterAutoscalingAutoProvisioningDefaults {
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes: string[];
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount?: string;
    }

    export interface ClusterClusterAutoscalingResourceLimit {
        /**
         * Maximum amount of the resource in the cluster.
         */
        maximum?: number;
        /**
         * Minimum amount of the resource in the cluster.
         */
        minimum?: number;
        /**
         * The type of the resource. For example, `cpu` and
         * `memory`.  See the [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
         * for a list of types.
         */
        resourceType: string;
    }

    export interface ClusterDatabaseEncryption {
        /**
         * the key to use to encrypt/decrypt secrets.  See the [DatabaseEncryption definition](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#Cluster.DatabaseEncryption) for more information.
         */
        keyName?: string;
        /**
         * `ENCRYPTED` or `DECRYPTED`
         */
        state: string;
    }

    export interface ClusterIpAllocationPolicy {
        /**
         * The IP address range for the cluster pod IPs.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        clusterIpv4CidrBlock: string;
        /**
         * The name of the existing secondary
         * range in the cluster's subnetwork to use for pod IP addresses. Alternatively,
         * `clusterIpv4CidrBlock` can be used to automatically create a GKE-managed one.
         */
        clusterSecondaryRangeName: string;
        /**
         * The IP address range of the services IPs in this cluster.
         * Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14)
         * to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14)
         * from the RFC-1918 private networks (e.g. 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to
         * pick a specific range to use.
         */
        servicesIpv4CidrBlock: string;
        /**
         * The name of the existing
         * secondary range in the cluster's subnetwork to use for service `ClusterIP`s.
         * Alternatively, `servicesIpv4CidrBlock` can be used to automatically create a
         * GKE-managed one.
         */
        servicesSecondaryRangeName: string;
    }

    export interface ClusterMaintenancePolicy {
        /**
         * Time window specified for daily maintenance operations.
         * Specify `startTime` in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format "HH:MM”,
         * where HH : \[00-23\] and MM : \[00-59\] GMT. For example:
         */
        dailyMaintenanceWindow?: outputs.container.ClusterMaintenancePolicyDailyMaintenanceWindow;
        /**
         * Time window for
         * recurring maintenance operations.
         */
        recurringWindow?: outputs.container.ClusterMaintenancePolicyRecurringWindow;
    }

    export interface ClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface ClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface ClusterMasterAuth {
        clientCertificate: string;
        /**
         * Whether client certificate authorization is enabled for this cluster.  For example:
         */
        clientCertificateConfig: outputs.container.ClusterMasterAuthClientCertificateConfig;
        clientKey: string;
        clusterCaCertificate: string;
        /**
         * The password to use for HTTP basic authentication when accessing
         * the Kubernetes master endpoint.
         */
        password?: string;
        /**
         * The username to use for HTTP basic authentication when accessing
         * the Kubernetes master endpoint. If not present basic auth will be disabled.
         */
        username?: string;
    }

    export interface ClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface ClusterMasterAuthorizedNetworksConfig {
        /**
         * External networks that can access the
         * Kubernetes cluster master through HTTPS.
         */
        cidrBlocks?: outputs.container.ClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface ClusterMasterAuthorizedNetworksConfigCidrBlock {
        /**
         * External network that can access Kubernetes master through HTTPS.
         * Must be specified in CIDR notation.
         */
        cidrBlock: string;
        /**
         * Field for users to identify CIDR blocks.
         */
        displayName?: string;
    }

    export interface ClusterNetworkPolicy {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: boolean;
        /**
         * The selected network policy provider. Defaults to PROVIDER_UNSPECIFIED.
         */
        provider?: string;
    }

    export interface ClusterNodeConfig {
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         */
        bootDiskKmsKey?: string;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb: number;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType: string;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators: outputs.container.ClusterNodeConfigGuestAccelerator[];
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType: string;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node.
         */
        labels: {[key: string]: string};
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount: number;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `n1-standard-1`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType: string;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata: {[key: string]: string};
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: string;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes: string[];
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: boolean;
        /**
         * [GKE Sandbox](https://cloud.google.com/kubernetes-engine/docs/how-to/sandbox-pods) configuration. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion = "1.12.7-gke.17"` or later to use it.
         * Structure is documented below.
         */
        sandboxConfig?: outputs.container.ClusterNodeConfigSandboxConfig;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount: string;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig: outputs.container.ClusterNodeConfigShieldedInstanceConfig;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: string[];
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints: outputs.container.ClusterNodeConfigTaint[];
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: outputs.container.ClusterNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface ClusterNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         */
        sandboxType: string;
    }

    export interface ClusterNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: boolean;
        /**
         * Defines if the instance has Secure Boot enabled.
         */
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: string;
        /**
         * Key for taint.
         */
        key: string;
        /**
         * Value for taint.
         */
        value: string;
    }

    export interface ClusterNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * SECURE: Prevent workloads not in hostNetwork from accessing certain VM metadata, specifically kube-env, which contains Kubelet credentials, and the instance identity token. See [Metadata Concealment](https://cloud.google.com/kubernetes-engine/docs/how-to/metadata-proxy) documentation.
         * * EXPOSE: Expose all VM metadata to pods.
         * * GKE_METADATA_SERVER: Enables [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) on the node.
         */
        nodeMetadata: string;
    }

    export interface ClusterNodePool {
        autoscaling?: outputs.container.ClusterNodePoolAutoscaling;
        /**
         * The number of nodes to create in this
         * cluster's default node pool. In regional or multi-zonal clusters, this is the
         * number of nodes per zone. Must be set if `nodePool` is not set. If you're using
         * `gcp.container.NodePool` objects with no default node pool, you'll need to
         * set this to a value of at least `1`, alongside setting
         * `removeDefaultNodePool` to `true`.
         */
        initialNodeCount: number;
        /**
         * List of instance group URLs which have been assigned
         * to the cluster.
         */
        instanceGroupUrls: string[];
        management: outputs.container.ClusterNodePoolManagement;
        maxPodsPerNode: number;
        /**
         * The name of the cluster, unique within the project and
         * location.
         */
        name: string;
        namePrefix: string;
        /**
         * Parameters used in creating the default node pool.
         * Generally, this field should not be used at the same time as a
         * `gcp.container.NodePool` or a `nodePool` block; this configuration
         * manages the default node pool, which isn't recommended to be used with
         * this provider. Structure is documented below.
         */
        nodeConfig: outputs.container.ClusterNodePoolNodeConfig;
        nodeCount: number;
        /**
         * The list of zones in which the cluster's nodes
         * are located. Nodes must be in the region of their regional cluster or in the
         * same region as their cluster's zone for zonal clusters. If this is specified for
         * a zonal cluster, omit the cluster's zone.
         */
        nodeLocations: string[];
        upgradeSettings: outputs.container.ClusterNodePoolUpgradeSettings;
        version: string;
    }

    export interface ClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface ClusterNodePoolManagement {
        autoRepair?: boolean;
        autoUpgrade?: boolean;
    }

    export interface ClusterNodePoolNodeConfig {
        /**
         * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         */
        bootDiskKmsKey?: string;
        /**
         * Size of the disk attached to each node, specified
         * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
         */
        diskSizeGb: number;
        /**
         * Type of the disk attached to each node
         * (e.g. 'pd-standard' or 'pd-ssd'). If unspecified, the default disk type is 'pd-standard'
         */
        diskType: string;
        /**
         * List of the type and count of accelerator cards attached to the instance.
         * Structure documented below.
         */
        guestAccelerators: outputs.container.ClusterNodePoolNodeConfigGuestAccelerator[];
        /**
         * The image type to use for this node. Note that changing the image type
         * will delete and recreate all nodes in the node pool.
         */
        imageType: string;
        /**
         * The Kubernetes labels (key/value pairs) to be applied to each node.
         */
        labels: {[key: string]: string};
        /**
         * The amount of local SSD disks that will be
         * attached to each cluster node. Defaults to 0.
         */
        localSsdCount: number;
        /**
         * The name of a Google Compute Engine machine type.
         * Defaults to `n1-standard-1`. To create a custom machine type, value should be set as specified
         * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
         */
        machineType: string;
        /**
         * The metadata key/value pairs assigned to instances in
         * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
         * `true` by the API; if `metadata` is set but that default value is not
         * included, the provider will attempt to unset the value. To avoid this, set the
         * value in your config.
         */
        metadata: {[key: string]: string};
        /**
         * Minimum CPU platform to be used by this instance.
         * The instance may be scheduled on the specified or newer CPU platform. Applicable
         * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
         * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for more information.
         */
        minCpuPlatform?: string;
        /**
         * The set of Google API scopes to be made available
         * on all of the node VMs under the "default" service account. These can be
         * either FQDNs, or scope aliases. The following scopes are necessary to ensure
         * the correct functioning of the cluster:
         */
        oauthScopes: string[];
        /**
         * A boolean that represents whether or not the underlying node VMs
         * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
         * for more information. Defaults to false.
         */
        preemptible?: boolean;
        /**
         * [GKE Sandbox](https://cloud.google.com/kubernetes-engine/docs/how-to/sandbox-pods) configuration. When enabling this feature you must specify `imageType = "COS_CONTAINERD"` and `nodeVersion = "1.12.7-gke.17"` or later to use it.
         * Structure is documented below.
         */
        sandboxConfig?: outputs.container.ClusterNodePoolNodeConfigSandboxConfig;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         * In order to use the configured `oauthScopes` for logging and monitoring, the service account being used needs the
         * [roles/logging.logWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_logging_roles) and
         * [roles/monitoring.metricWriter](https://cloud.google.com/iam/docs/understanding-roles#stackdriver_monitoring_roles) roles.
         */
        serviceAccount: string;
        /**
         * Shielded Instance options. Structure is documented below.
         */
        shieldedInstanceConfig: outputs.container.ClusterNodePoolNodeConfigShieldedInstanceConfig;
        /**
         * The list of instance tags applied to all nodes. Tags are used to identify
         * valid sources or targets for network firewalls.
         */
        tags?: string[];
        /**
         * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
         * to apply to nodes. GKE's API can only set this field on cluster creation.
         * However, GKE will add taints to your nodes if you enable certain features such
         * as GPUs. If this field is set, any diffs on this field will cause the provider to
         * recreate the underlying resource. Taint values can be updated safely in
         * Kubernetes (eg. through `kubectl`), and it's recommended that you do not use
         * this field to manage taints. If you do, `lifecycle.ignore_changes` is
         * recommended. Structure is documented below.
         */
        taints: outputs.container.ClusterNodePoolNodeConfigTaint[];
        /**
         * Metadata configuration to expose to workloads on the node pool.
         * Structure is documented below.
         */
        workloadMetadataConfig?: outputs.container.ClusterNodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface ClusterNodePoolNodeConfigGuestAccelerator {
        /**
         * The number of the guest accelerator cards exposed to this instance.
         */
        count: number;
        /**
         * The accelerator type resource to expose to this instance. E.g. `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface ClusterNodePoolNodeConfigSandboxConfig {
        /**
         * Which sandbox to use for pods in the node pool.
         * Accepted values are:
         */
        sandboxType: string;
    }

    export interface ClusterNodePoolNodeConfigShieldedInstanceConfig {
        /**
         * Defines if the instance has integrity monitoring enabled.
         */
        enableIntegrityMonitoring?: boolean;
        /**
         * Defines if the instance has Secure Boot enabled.
         */
        enableSecureBoot?: boolean;
    }

    export interface ClusterNodePoolNodeConfigTaint {
        /**
         * Effect for taint. Accepted values are `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, and `NO_EXECUTE`.
         */
        effect: string;
        /**
         * Key for taint.
         */
        key: string;
        /**
         * Value for taint.
         */
        value: string;
    }

    export interface ClusterNodePoolNodeConfigWorkloadMetadataConfig {
        /**
         * How to expose the node metadata to the workload running on the node.
         * Accepted values are:
         * * UNSPECIFIED: Not Set
         * * SECURE: Prevent workloads not in hostNetwork from accessing certain VM metadata, specifically kube-env, which contains Kubelet credentials, and the instance identity token. See [Metadata Concealment](https://cloud.google.com/kubernetes-engine/docs/how-to/metadata-proxy) documentation.
         * * EXPOSE: Expose all VM metadata to pods.
         * * GKE_METADATA_SERVER: Enables [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) on the node.
         */
        nodeMetadata: string;
    }

    export interface ClusterNodePoolUpgradeSettings {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface ClusterPodSecurityPolicyConfig {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: boolean;
    }

    export interface ClusterPrivateClusterConfig {
        /**
         * When `true`, the cluster's private
         * endpoint is used as the cluster endpoint and access through the public endpoint
         * is disabled. When `false`, either endpoint can be used. This field only applies
         * to private clusters, when `enablePrivateNodes` is `true`.
         */
        enablePrivateEndpoint: boolean;
        /**
         * Enables the private cluster feature,
         * creating a private endpoint on the cluster. In a private cluster, nodes only
         * have RFC 1918 private addresses and communicate with the master's private
         * endpoint via private networking.
         */
        enablePrivateNodes?: boolean;
        /**
         * The IP range in CIDR notation to use for
         * the hosted master network. This range will be used for assigning private IP
         * addresses to the cluster master(s) and the ILB VIP. This range must not overlap
         * with any other ranges in use within the cluster's network, and it must be a /28
         * subnet. See [Private Cluster Limitations](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#limitations)
         * for more details. This field only applies to private clusters, when
         * `enablePrivateNodes` is `true`.
         */
        masterIpv4CidrBlock?: string;
        /**
         * The name of the peering between this cluster and the Google owned VPC.
         */
        peeringName: string;
        /**
         * The internal IP address of this cluster's master endpoint.
         */
        privateEndpoint: string;
        /**
         * The external IP address of this cluster's master endpoint.
         */
        publicEndpoint: string;
    }

    export interface ClusterReleaseChannel {
        /**
         * The selected release channel.
         * Accepted values are:
         * * UNSPECIFIED: Not set.
         * * RAPID: Weekly upgrade cadence; Early testers and developers who requires new features.
         * * REGULAR: Multiple per month upgrade cadence; Production users who need features not yet offered in the Stable channel.
         * * STABLE: Every few months upgrade cadence; Production users who need stability above all else, and for whom frequent upgrades are too risky.
         */
        channel: string;
    }

    export interface ClusterResourceUsageExportConfig {
        /**
         * Parameters for using BigQuery as the destination of resource usage export.
         */
        bigqueryDestination: outputs.container.ClusterResourceUsageExportConfigBigqueryDestination;
        /**
         * Whether to enable network egress metering for this cluster. If enabled, a daemonset will be created
         * in the cluster to meter network egress traffic.
         */
        enableNetworkEgressMetering?: boolean;
        /**
         * Whether to enable resource
         * consumption metering on this cluster. When enabled, a table will be created in
         * the resource export BigQuery dataset to store resource consumption data. The
         * resulting table can be joined with the resource usage table or with BigQuery
         * billing export. Defaults to `true`.
         */
        enableResourceConsumptionMetering?: boolean;
    }

    export interface ClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface ClusterVerticalPodAutoscaling {
        /**
         * Enable the PodSecurityPolicy controller for this cluster.
         * If enabled, pods must be valid under a PodSecurityPolicy to be created.
         */
        enabled: boolean;
    }

    export interface ClusterWorkloadIdentityConfig {
        /**
         * Currently, the only supported identity namespace is the project's default.
         */
        identityNamespace: string;
    }

    export interface GetClusterAddonsConfig {
        cloudrunConfigs: outputs.container.GetClusterAddonsConfigCloudrunConfig[];
        dnsCacheConfigs: outputs.container.GetClusterAddonsConfigDnsCacheConfig[];
        horizontalPodAutoscalings: outputs.container.GetClusterAddonsConfigHorizontalPodAutoscaling[];
        httpLoadBalancings: outputs.container.GetClusterAddonsConfigHttpLoadBalancing[];
        istioConfigs: outputs.container.GetClusterAddonsConfigIstioConfig[];
        kubernetesDashboards: outputs.container.GetClusterAddonsConfigKubernetesDashboard[];
        networkPolicyConfigs: outputs.container.GetClusterAddonsConfigNetworkPolicyConfig[];
    }

    export interface GetClusterAddonsConfigCloudrunConfig {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigDnsCacheConfig {
        enabled: boolean;
    }

    export interface GetClusterAddonsConfigHorizontalPodAutoscaling {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigHttpLoadBalancing {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigIstioConfig {
        auth: string;
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigKubernetesDashboard {
        disabled: boolean;
    }

    export interface GetClusterAddonsConfigNetworkPolicyConfig {
        disabled: boolean;
    }

    export interface GetClusterAuthenticatorGroupsConfig {
        securityGroup: string;
    }

    export interface GetClusterClusterAutoscaling {
        autoProvisioningDefaults: outputs.container.GetClusterClusterAutoscalingAutoProvisioningDefault[];
        autoscalingProfile: string;
        enabled: boolean;
        resourceLimits: outputs.container.GetClusterClusterAutoscalingResourceLimit[];
    }

    export interface GetClusterClusterAutoscalingAutoProvisioningDefault {
        oauthScopes: string[];
        serviceAccount: string;
    }

    export interface GetClusterClusterAutoscalingResourceLimit {
        maximum: number;
        minimum: number;
        resourceType: string;
    }

    export interface GetClusterDatabaseEncryption {
        keyName: string;
        state: string;
    }

    export interface GetClusterIpAllocationPolicy {
        clusterIpv4CidrBlock: string;
        clusterSecondaryRangeName: string;
        nodeIpv4CidrBlock: string;
        servicesIpv4CidrBlock: string;
        servicesSecondaryRangeName: string;
        subnetworkName: string;
    }

    export interface GetClusterMaintenancePolicy {
        dailyMaintenanceWindows: outputs.container.GetClusterMaintenancePolicyDailyMaintenanceWindow[];
        recurringWindows: outputs.container.GetClusterMaintenancePolicyRecurringWindow[];
    }

    export interface GetClusterMaintenancePolicyDailyMaintenanceWindow {
        duration: string;
        startTime: string;
    }

    export interface GetClusterMaintenancePolicyRecurringWindow {
        endTime: string;
        recurrence: string;
        startTime: string;
    }

    export interface GetClusterMasterAuth {
        clientCertificate: string;
        clientCertificateConfigs: outputs.container.GetClusterMasterAuthClientCertificateConfig[];
        clientKey: string;
        clusterCaCertificate: string;
        password: string;
        username: string;
    }

    export interface GetClusterMasterAuthClientCertificateConfig {
        issueClientCertificate: boolean;
    }

    export interface GetClusterMasterAuthorizedNetworksConfig {
        cidrBlocks: outputs.container.GetClusterMasterAuthorizedNetworksConfigCidrBlock[];
    }

    export interface GetClusterMasterAuthorizedNetworksConfigCidrBlock {
        cidrBlock: string;
        displayName: string;
    }

    export interface GetClusterNetworkPolicy {
        enabled: boolean;
        provider: string;
    }

    export interface GetClusterNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePool {
        autoscalings: outputs.container.GetClusterNodePoolAutoscaling[];
        initialNodeCount: number;
        instanceGroupUrls: string[];
        managements: outputs.container.GetClusterNodePoolManagement[];
        maxPodsPerNode: number;
        /**
         * The name of the cluster.
         */
        name: string;
        namePrefix: string;
        nodeConfigs: outputs.container.GetClusterNodePoolNodeConfig[];
        nodeCount: number;
        nodeLocations: string[];
        upgradeSettings: outputs.container.GetClusterNodePoolUpgradeSetting[];
        version: string;
    }

    export interface GetClusterNodePoolAutoscaling {
        maxNodeCount: number;
        minNodeCount: number;
    }

    export interface GetClusterNodePoolManagement {
        autoRepair: boolean;
        autoUpgrade: boolean;
    }

    export interface GetClusterNodePoolNodeConfig {
        bootDiskKmsKey: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.GetClusterNodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform: string;
        oauthScopes: string[];
        preemptible: boolean;
        sandboxConfigs: outputs.container.GetClusterNodePoolNodeConfigSandboxConfig[];
        serviceAccount: string;
        shieldedInstanceConfigs: outputs.container.GetClusterNodePoolNodeConfigShieldedInstanceConfig[];
        tags: string[];
        taints: outputs.container.GetClusterNodePoolNodeConfigTaint[];
        workloadMetadataConfigs: outputs.container.GetClusterNodePoolNodeConfigWorkloadMetadataConfig[];
    }

    export interface GetClusterNodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface GetClusterNodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface GetClusterNodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring: boolean;
        enableSecureBoot: boolean;
    }

    export interface GetClusterNodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface GetClusterNodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface GetClusterNodePoolUpgradeSetting {
        maxSurge: number;
        maxUnavailable: number;
    }

    export interface GetClusterPodSecurityPolicyConfig {
        enabled: boolean;
    }

    export interface GetClusterPrivateClusterConfig {
        enablePrivateEndpoint: boolean;
        enablePrivateNodes: boolean;
        masterIpv4CidrBlock: string;
        peeringName: string;
        privateEndpoint: string;
        publicEndpoint: string;
    }

    export interface GetClusterReleaseChannel {
        channel: string;
    }

    export interface GetClusterResourceUsageExportConfig {
        bigqueryDestinations: outputs.container.GetClusterResourceUsageExportConfigBigqueryDestination[];
        enableNetworkEgressMetering: boolean;
        enableResourceConsumptionMetering: boolean;
    }

    export interface GetClusterResourceUsageExportConfigBigqueryDestination {
        datasetId: string;
    }

    export interface GetClusterVerticalPodAutoscaling {
        enabled: boolean;
    }

    export interface GetClusterWorkloadIdentityConfig {
        identityNamespace: string;
    }

    export interface NodePoolAutoscaling {
        /**
         * Maximum number of nodes in the NodePool. Must be >= min_node_count.
         */
        maxNodeCount: number;
        /**
         * Minimum number of nodes in the NodePool. Must be >=0 and
         * <= `maxNodeCount`.
         */
        minNodeCount: number;
    }

    export interface NodePoolManagement {
        /**
         * Whether the nodes will be automatically repaired.
         */
        autoRepair?: boolean;
        /**
         * Whether the nodes will be automatically upgraded.
         */
        autoUpgrade?: boolean;
    }

    export interface NodePoolNodeConfig {
        bootDiskKmsKey?: string;
        diskSizeGb: number;
        diskType: string;
        guestAccelerators: outputs.container.NodePoolNodeConfigGuestAccelerator[];
        imageType: string;
        labels: {[key: string]: string};
        localSsdCount: number;
        machineType: string;
        metadata: {[key: string]: string};
        minCpuPlatform?: string;
        oauthScopes: string[];
        preemptible?: boolean;
        sandboxConfig?: outputs.container.NodePoolNodeConfigSandboxConfig;
        serviceAccount: string;
        shieldedInstanceConfig: outputs.container.NodePoolNodeConfigShieldedInstanceConfig;
        tags?: string[];
        taints: outputs.container.NodePoolNodeConfigTaint[];
        workloadMetadataConfig?: outputs.container.NodePoolNodeConfigWorkloadMetadataConfig;
    }

    export interface NodePoolNodeConfigGuestAccelerator {
        count: number;
        type: string;
    }

    export interface NodePoolNodeConfigSandboxConfig {
        sandboxType: string;
    }

    export interface NodePoolNodeConfigShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface NodePoolNodeConfigTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodePoolNodeConfigWorkloadMetadataConfig {
        nodeMetadata: string;
    }

    export interface NodePoolUpgradeSettings {
        /**
         * The number of additional nodes that can be added to the node pool during
         * an upgrade. Increasing `maxSurge` raises the number of nodes that can be upgraded simultaneously.
         * Can be set to 0 or greater.
         */
        maxSurge: number;
        /**
         * The number of nodes that can be simultaneously unavailable during
         * an upgrade. Increasing `maxUnavailable` raises the number of nodes that can be upgraded in
         * parallel. Can be set to 0 or greater.
         */
        maxUnavailable: number;
    }
}

export namespace containeranalysis {
    export interface NoteAttestationAuthority {
        hint: outputs.containeranalysis.NoteAttestationAuthorityHint;
    }

    export interface NoteAttestationAuthorityHint {
        humanReadableName: string;
    }
}

export namespace datafusion {
    export interface InstanceNetworkConfig {
        ipAllocation: string;
        network: string;
    }
}

export namespace dataproc {
    export interface AutoscalingPolicyBasicAlgorithm {
        cooldownPeriod?: string;
        yarnConfig: outputs.dataproc.AutoscalingPolicyBasicAlgorithmYarnConfig;
    }

    export interface AutoscalingPolicyBasicAlgorithmYarnConfig {
        gracefulDecommissionTimeout: string;
        scaleDownFactor: number;
        scaleDownMinWorkerFraction?: number;
        scaleUpFactor: number;
        scaleUpMinWorkerFraction?: number;
    }

    export interface AutoscalingPolicySecondaryWorkerConfig {
        maxInstances?: number;
        minInstances?: number;
        weight?: number;
    }

    export interface AutoscalingPolicyWorkerConfig {
        maxInstances: number;
        minInstances?: number;
        weight?: number;
    }

    export interface ClusterClusterConfig {
        /**
         * The autoscaling policy config associated with the cluster.
         * Structure defined below.
         */
        autoscalingConfig?: outputs.dataproc.ClusterClusterConfigAutoscalingConfig;
        bucket: string;
        /**
         * The Customer managed encryption keys settings for the cluster.
         * Structure defined below.
         */
        encryptionConfig?: outputs.dataproc.ClusterClusterConfigEncryptionConfig;
        /**
         * Common config settings for resources of Google Compute Engine cluster
         * instances, applicable to all instances in the cluster. Structure defined below.
         */
        gceClusterConfig: outputs.dataproc.ClusterClusterConfigGceClusterConfig;
        /**
         * Commands to execute on each node after config is completed.
         * You can specify multiple versions of these. Structure defined below.
         */
        initializationActions?: outputs.dataproc.ClusterClusterConfigInitializationAction[];
        lifecycleConfig?: outputs.dataproc.ClusterClusterConfigLifecycleConfig;
        /**
         * The Google Compute Engine config settings for the master instances
         * in a cluster.. Structure defined below.
         */
        masterConfig: outputs.dataproc.ClusterClusterConfigMasterConfig;
        /**
         * The Google Compute Engine config settings for the additional (aka
         * preemptible) instances in a cluster. Structure defined below.
         */
        preemptibleWorkerConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfig;
        /**
         * Security related configuration. Structure defined below.
         */
        securityConfig?: outputs.dataproc.ClusterClusterConfigSecurityConfig;
        /**
         * The config settings for software inside the cluster.
         * Structure defined below.
         */
        softwareConfig: outputs.dataproc.ClusterClusterConfigSoftwareConfig;
        /**
         * The Cloud Storage staging bucket used to stage files,
         * such as Hadoop jars, between client machines and the cluster.
         * Note: If you don't explicitly specify a `stagingBucket`
         * then GCP will auto create / assign one for you. However, you are not guaranteed
         * an auto generated bucket which is solely dedicated to your cluster; it may be shared
         * with other clusters in the same region/zone also choosing to use the auto generation
         * option.
         */
        stagingBucket?: string;
        /**
         * The Google Compute Engine config settings for the worker instances
         * in a cluster.. Structure defined below.
         */
        workerConfig: outputs.dataproc.ClusterClusterConfigWorkerConfig;
    }

    export interface ClusterClusterConfigAutoscalingConfig {
        /**
         * The autoscaling policy used by the cluster.
         */
        policyUri: string;
    }

    export interface ClusterClusterConfigEncryptionConfig {
        /**
         * The Cloud KMS key name to use for PD disk encryption for
         * all instances in the cluster.
         */
        kmsKeyName: string;
    }

    export interface ClusterClusterConfigGceClusterConfig {
        /**
         * By default, clusters are not restricted to internal IP addresses, 
         * and will have ephemeral external IP addresses assigned to each instance. If set to true, all
         * instances in the cluster will only have internal IP addresses. Note: Private Google Access
         * (also known as `privateIpGoogleAccess`) must be enabled on the subnetwork that the cluster
         * will be launched in.
         */
        internalIpOnly?: boolean;
        /**
         * A map of the Compute Engine metadata entries to add to all instances
         * (see [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
         */
        metadata?: {[key: string]: string};
        /**
         * The name or selfLink of the Google Compute Engine
         * network to the cluster will be part of. Conflicts with `subnetwork`.
         * If neither is specified, this defaults to the "default" network.
         */
        network: string;
        /**
         * The service account to be used by the Node VMs.
         * If not specified, the "default" service account is used.
         */
        serviceAccount?: string;
        /**
         * The set of Google API scopes
         * to be made available on all of the node VMs under the `serviceAccount`
         * specified. These can be	either FQDNs, or scope aliases. The following scopes
         * must be set if any other scopes are set. They're necessary to ensure the
         * correct functioning ofthe cluster, and are set automatically by the API:
         */
        serviceAccountScopes: string[];
        /**
         * The name or selfLink of the Google Compute Engine
         * subnetwork the cluster will be part of. Conflicts with `network`.
         */
        subnetwork?: string;
        /**
         * The list of instance tags applied to instances in the cluster.
         * Tags are used to identify valid sources or targets for network firewalls.
         */
        tags?: string[];
        /**
         * The GCP zone where your data is stored and used (i.e. where
         * the master and the worker nodes will be created in). If `region` is set to 'global' (default)
         * then `zone` is mandatory, otherwise GCP is able to make use of [Auto Zone Placement](https://cloud.google.com/dataproc/docs/concepts/auto-zone)
         * to determine this automatically for you.
         * Note: This setting additionally determines and restricts
         * which computing resources are available for use with other configs such as
         * `cluster_config.master_config.machine_type` and `cluster_config.worker_config.machine_type`.
         */
        zone: string;
    }

    export interface ClusterClusterConfigInitializationAction {
        script: string;
        /**
         * The maximum duration (in seconds) which `script` is
         * allowed to take to execute its action. GCP will default to a predetermined
         * computed value if not set (currently 300).
         */
        timeoutSec?: number;
    }

    export interface ClusterClusterConfigLifecycleConfig {
        /**
         * The time when cluster will be auto-deleted.
         * A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
         * Example: "2014-10-02T15:01:23.045123456Z".
         */
        autoDeleteTime?: string;
        /**
         * The duration to keep the cluster alive while idling
         * (no jobs running). After this TTL, the cluster will be deleted. Valid range: [10m, 14d].
         */
        idleDeleteTtl?: string;
        idleStartTime: string;
    }

    export interface ClusterClusterConfigMasterConfig {
        /**
         * The Compute Engine accelerator configuration for these instances. Can be specified multiple times.
         */
        accelerators?: outputs.dataproc.ClusterClusterConfigMasterConfigAccelerator[];
        /**
         * Disk Config
         */
        diskConfig: outputs.dataproc.ClusterClusterConfigMasterConfigDiskConfig;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri: string;
        instanceNames: string[];
        /**
         * The name of a Google Compute Engine machine type
         * to create for the worker nodes. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType: string;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigMasterConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         */
        acceleratorCount: number;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: string;
    }

    export interface ClusterClusterConfigMasterConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb: number;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: string;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfig {
        /**
         * Disk Config
         */
        diskConfig: outputs.dataproc.ClusterClusterConfigPreemptibleWorkerConfigDiskConfig;
        instanceNames: string[];
        numInstances: number;
    }

    export interface ClusterClusterConfigPreemptibleWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb: number;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: string;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds: number;
    }

    export interface ClusterClusterConfigSecurityConfig {
        /**
         * Kerberos Configuration
         */
        kerberosConfig: outputs.dataproc.ClusterClusterConfigSecurityConfigKerberosConfig;
    }

    export interface ClusterClusterConfigSecurityConfigKerberosConfig {
        /**
         * The admin server (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustAdminServer?: string;
        /**
         * The KDC (IP or hostname) for the
         * remote trusted realm in a cross realm trust relationship.
         */
        crossRealmTrustKdc?: string;
        /**
         * The remote realm the Dataproc on-cluster KDC will
         * trust, should the user enable cross realm trust.
         */
        crossRealmTrustRealm?: string;
        /**
         * The Cloud Storage URI of a KMS
         * encrypted file containing the shared password between the on-cluster Kerberos realm
         * and the remote trusted realm, in a cross realm trust relationship.
         */
        crossRealmTrustSharedPasswordUri?: string;
        /**
         * Flag to indicate whether to Kerberize the cluster.
         */
        enableKerberos?: boolean;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the master key of the KDC database.
         */
        kdcDbKeyUri?: string;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided key. For the self-signed certificate, this password
         * is generated by Dataproc.
         */
        keyPasswordUri?: string;
        /**
         * The Cloud Storage URI of a KMS encrypted file containing
         * the password to the user provided keystore. For the self-signed certificated, the password
         * is generated by Dataproc.
         */
        keystorePasswordUri?: string;
        /**
         * The Cloud Storage URI of the keystore file used for SSL encryption.
         * If not provided, Dataproc will provide a self-signed certificate.
         */
        keystoreUri?: string;
        /**
         * The URI of the KMS key used to encrypt various sensitive files.
         */
        kmsKeyUri: string;
        /**
         * The name of the on-cluster Kerberos realm. If not specified, the
         * uppercased domain of hostnames will be the realm.
         */
        realm?: string;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the root principal password.
         */
        rootPrincipalPasswordUri: string;
        /**
         * The lifetime of the ticket granting ticket, in hours.
         */
        tgtLifetimeHours?: number;
        /**
         * The Cloud Storage URI of a KMS encrypted file
         * containing the password to the user provided truststore. For the self-signed
         * certificate, this password is generated by Dataproc.
         */
        truststorePasswordUri?: string;
        /**
         * The Cloud Storage URI of the truststore file used for
         * SSL encryption. If not provided, Dataproc will provide a self-signed certificate.
         */
        truststoreUri?: string;
    }

    export interface ClusterClusterConfigSoftwareConfig {
        /**
         * The Cloud Dataproc image version to use
         * for the cluster - this controls the sets of software versions
         * installed onto the nodes when you create clusters. If not specified, defaults to the
         * latest version. For a list of valid versions see
         * [Cloud Dataproc versions](https://cloud.google.com/dataproc/docs/concepts/dataproc-versions)
         */
        imageVersion: string;
        /**
         * The set of optional components to activate on the cluster. 
         * Accepted values are:
         * * ANACONDA
         * * DRUID
         * * HIVE_WEBHCAT
         * * JUPYTER
         * * KERBEROS
         * * PRESTO
         * * ZEPPELIN
         * * ZOOKEEPER
         */
        optionalComponents?: string[];
        /**
         * A list of override and additional properties (key/value pairs)
         * used to modify various aspects of the common configuration files used when creating
         * a cluster. For a list of valid properties please see
         * [Cluster properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties)
         */
        overrideProperties?: {[key: string]: string};
        properties: {[key: string]: any};
    }

    export interface ClusterClusterConfigWorkerConfig {
        /**
         * The Compute Engine accelerator configuration for these instances. Can be specified multiple times.
         */
        accelerators?: outputs.dataproc.ClusterClusterConfigWorkerConfigAccelerator[];
        /**
         * Disk Config
         */
        diskConfig: outputs.dataproc.ClusterClusterConfigWorkerConfigDiskConfig;
        /**
         * The URI for the image to use for this worker.  See [the guide](https://cloud.google.com/dataproc/docs/guides/dataproc-images)
         * for more information.
         */
        imageUri: string;
        instanceNames: string[];
        /**
         * The name of a Google Compute Engine machine type
         * to create for the worker nodes. If not specified, GCP will default to a predetermined
         * computed value (currently `n1-standard-4`).
         */
        machineType: string;
        /**
         * The name of a minimum generation of CPU family
         * for the master. If not specified, GCP will default to a predetermined computed value
         * for each zone. See [the guide](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * for details about which CPU families are available (and defaulted) for each zone.
         */
        minCpuPlatform: string;
        numInstances: number;
    }

    export interface ClusterClusterConfigWorkerConfigAccelerator {
        /**
         * The number of the accelerator cards of this type exposed to this instance. Often restricted to one of `1`, `2`, `4`, or `8`.
         */
        acceleratorCount: number;
        /**
         * The short name of the accelerator type to expose to this instance. For example, `nvidia-tesla-k80`.
         */
        acceleratorType: string;
    }

    export interface ClusterClusterConfigWorkerConfigDiskConfig {
        /**
         * Size of the primary disk attached to each preemptible worker node, specified
         * in GB. The smallest allowed disk size is 10GB. GCP will default to a predetermined
         * computed value if not set (currently 500GB). Note: If SSDs are not
         * attached, it also contains the HDFS data blocks and Hadoop working directories.
         */
        bootDiskSizeGb: number;
        /**
         * The disk type of the primary disk attached to each preemptible worker node.
         * One of `"pd-ssd"` or `"pd-standard"`. Defaults to `"pd-standard"`.
         */
        bootDiskType?: string;
        /**
         * The amount of local SSD disks that will be
         * attached to each preemptible worker node. Defaults to 0.
         */
        numLocalSsds: number;
    }

    export interface ClusterIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ClusterIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobHadoopConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: string[];
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: string[];
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: string[];
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobHadoopConfigLoggingConfig;
        mainClass?: string;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'. Conflicts with `mainClass`
         */
        mainJarFileUri?: string;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
    }

    export interface JobHadoopConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobHiveConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: boolean;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: string;
        queryLists?: string[];
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: {[key: string]: string};
    }

    export interface JobIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface JobPigConfig {
        /**
         * Whether to continue executing queries if a query fails. The default value is false. Setting to true can be useful when executing independent parallel queries. Defaults to false.
         */
        continueOnFailure?: boolean;
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPigConfigLoggingConfig;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: string;
        queryLists?: string[];
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: {[key: string]: string};
    }

    export interface JobPigConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobPlacement {
        clusterName: string;
        clusterUuid: string;
    }

    export interface JobPysparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: string[];
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: string[];
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: string[];
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobPysparkConfigLoggingConfig;
        mainPythonFileUri: string;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
        /**
         * HCFS file URIs of Python files to pass to the PySpark framework. Supported file types: .py, .egg, and .zip.
         */
        pythonFileUris?: string[];
    }

    export interface JobPysparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobReference {
        jobId: string;
    }

    export interface JobScheduling {
        maxFailuresPerHour: number;
    }

    export interface JobSparkConfig {
        /**
         * HCFS URIs of archives to be extracted in the working directory of .jar, .tar, .tar.gz, .tgz, and .zip.
         */
        archiveUris?: string[];
        /**
         * The arguments to pass to the driver. Do not include arguments, such as -libjars or -Dfoo=bar, that can be set as job properties, since a collision may occur that causes an incorrect job submission.
         */
        args?: string[];
        /**
         * HCFS URIs of files to be copied to the working directory of Hadoop drivers and distributed tasks. Useful for naively parallel tasks.
         */
        fileUris?: string[];
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparkConfigLoggingConfig;
        mainClass?: string;
        /**
         * The HCFS URI of the jar file containing the main class. Examples: 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar' 'hdfs:/tmp/test-samples/custom-wordcount.jar' 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'. Conflicts with `mainClass`
         */
        mainJarFileUri?: string;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
    }

    export interface JobSparkConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobSparksqlConfig {
        /**
         * HCFS URIs of jar files to be added to the Spark CLASSPATH.
         */
        jarFileUris?: string[];
        loggingConfig: outputs.dataproc.JobSparksqlConfigLoggingConfig;
        /**
         * A mapping of property names to values, used to configure Spark SQL's SparkConf. Properties that conflict with values set by the Cloud Dataproc API may be overwritten.
         */
        properties?: {[key: string]: string};
        /**
         * The HCFS URI of the script that contains SQL queries.
         * Conflicts with `queryList`
         */
        queryFileUri?: string;
        queryLists?: string[];
        /**
         * Mapping of query variable names to values (equivalent to the Spark SQL command: `SET name="value";`).
         */
        scriptVariables?: {[key: string]: string};
    }

    export interface JobSparksqlConfigLoggingConfig {
        driverLogLevels: {[key: string]: string};
    }

    export interface JobStatus {
        details: string;
        state: string;
        stateStartTime: string;
        substate: string;
    }
}

export namespace datastore {
    export interface DataStoreIndexProperty {
        direction: string;
        name: string;
    }
}

export namespace deploymentmanager {
    export interface DeploymentLabel {
        key?: string;
        value?: string;
    }

    export interface DeploymentTarget {
        config: outputs.deploymentmanager.DeploymentTargetConfig;
        imports?: outputs.deploymentmanager.DeploymentTargetImport[];
    }

    export interface DeploymentTargetConfig {
        content: string;
    }

    export interface DeploymentTargetImport {
        content?: string;
        name?: string;
    }
}

export namespace dns {
    export interface GetKeysKeySigningKey {
        /**
         * String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
         */
        algorithm: string;
        /**
         * The time that this resource was created in the control plane. This is in RFC3339 text format.
         */
        creationTime: string;
        /**
         * A mutable string of at most 1024 characters associated with this resource for the user's convenience.
         */
        description: string;
        /**
         * A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
         * - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
         * - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
         */
        digests: outputs.dns.GetKeysKeySigningKeyDigest[];
        /**
         * The DS record based on the KSK record. This is used when [delegating](https://cloud.google.com/dns/docs/dnssec-advanced#subdelegation) DNSSEC-signed subdomains.
         */
        dsRecord: string;
        /**
         * Unique identifier for the resource; defined by the server.
         */
        id: string;
        /**
         * Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
         */
        isActive: boolean;
        /**
         * Length of the key in bits. Specified at creation time then immutable.
         */
        keyLength: number;
        /**
         * The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
         */
        keyTag: number;
        /**
         * Base64 encoded public half of this key.
         */
        publicKey: string;
    }

    export interface GetKeysKeySigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface GetKeysZoneSigningKey {
        /**
         * String mnemonic specifying the DNSSEC algorithm of this key. Immutable after creation time. Possible values are `ecdsap256sha256`, `ecdsap384sha384`, `rsasha1`, `rsasha256`, and `rsasha512`.
         */
        algorithm: string;
        /**
         * The time that this resource was created in the control plane. This is in RFC3339 text format.
         */
        creationTime: string;
        /**
         * A mutable string of at most 1024 characters associated with this resource for the user's convenience.
         */
        description: string;
        /**
         * A list of cryptographic hashes of the DNSKEY resource record associated with this DnsKey. These digests are needed to construct a DS record that points at this DNS key. Each contains:
         * - `digest` - The base-16 encoded bytes of this digest. Suitable for use in a DS resource record.
         * - `type` - Specifies the algorithm used to calculate this digest. Possible values are `sha1`, `sha256` and `sha384`
         */
        digests: outputs.dns.GetKeysZoneSigningKeyDigest[];
        /**
         * Unique identifier for the resource; defined by the server.
         */
        id: string;
        /**
         * Active keys will be used to sign subsequent changes to the ManagedZone. Inactive keys will still be present as DNSKEY Resource Records for the use of resolvers validating existing signatures.
         */
        isActive: boolean;
        /**
         * Length of the key in bits. Specified at creation time then immutable.
         */
        keyLength: number;
        /**
         * The key tag is a non-cryptographic hash of the a DNSKEY resource record associated with this DnsKey. The key tag can be used to identify a DNSKEY more quickly (but it is not a unique identifier). In particular, the key tag is used in a parent zone's DS record to point at the DNSKEY in this child ManagedZone. The key tag is a number in the range [0, 65535] and the algorithm to calculate it is specified in RFC4034 Appendix B.
         */
        keyTag: number;
        /**
         * Base64 encoded public half of this key.
         */
        publicKey: string;
    }

    export interface GetKeysZoneSigningKeyDigest {
        digest?: string;
        type?: string;
    }

    export interface ManagedZoneDnssecConfig {
        defaultKeySpecs: outputs.dns.ManagedZoneDnssecConfigDefaultKeySpec[];
        kind?: string;
        nonExistence: string;
        state?: string;
    }

    export interface ManagedZoneDnssecConfigDefaultKeySpec {
        algorithm?: string;
        keyLength?: number;
        keyType?: string;
        kind?: string;
    }

    export interface ManagedZoneForwardingConfig {
        targetNameServers: outputs.dns.ManagedZoneForwardingConfigTargetNameServer[];
    }

    export interface ManagedZoneForwardingConfigTargetNameServer {
        forwardingPath?: string;
        ipv4Address: string;
    }

    export interface ManagedZonePeeringConfig {
        targetNetwork: outputs.dns.ManagedZonePeeringConfigTargetNetwork;
    }

    export interface ManagedZonePeeringConfigTargetNetwork {
        networkUrl: string;
    }

    export interface ManagedZonePrivateVisibilityConfig {
        networks: outputs.dns.ManagedZonePrivateVisibilityConfigNetwork[];
    }

    export interface ManagedZonePrivateVisibilityConfigNetwork {
        networkUrl: string;
    }

    export interface PolicyAlternativeNameServerConfig {
        targetNameServers: outputs.dns.PolicyAlternativeNameServerConfigTargetNameServer[];
    }

    export interface PolicyAlternativeNameServerConfigTargetNameServer {
        ipv4Address: string;
    }

    export interface PolicyNetwork {
        networkUrl: string;
    }
}

export namespace endpoints {
    export interface ServiceApi {
        methods: outputs.endpoints.ServiceApiMethod[];
        name: string;
        syntax: string;
        version: string;
    }

    export interface ServiceApiMethod {
        name: string;
        requestType: string;
        responseType: string;
        syntax: string;
    }

    export interface ServiceEndpoint {
        address: string;
        name: string;
    }

    export interface ServiceIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ServiceIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace filestore {
    export interface InstanceFileShares {
        capacityGb: number;
        name: string;
    }

    export interface InstanceNetwork {
        ipAddresses: string[];
        modes: string[];
        network: string;
        reservedIpRange: string;
    }
}

export namespace firestore {
    export interface IndexField {
        arrayConfig?: string;
        fieldPath?: string;
        order?: string;
    }
}

export namespace folder {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.folder.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.folder.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.folder.OrganizationPolicyListPolicyAllow;
        deny?: outputs.folder.OrganizationPolicyListPolicyDeny;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: boolean;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: boolean;
    }
}

export namespace gameservices {
    export interface GameServerClusterConnectionInfo {
        gkeClusterReference: outputs.gameservices.GameServerClusterConnectionInfoGkeClusterReference;
        namespace: string;
    }

    export interface GameServerClusterConnectionInfoGkeClusterReference {
        cluster: string;
    }

    export interface GameServerConfigFleetConfig {
        fleetSpec: string;
        name: string;
    }

    export interface GameServerConfigScalingConfig {
        fleetAutoscalerSpec: string;
        name: string;
        schedules?: outputs.gameservices.GameServerConfigScalingConfigSchedule[];
        selectors?: outputs.gameservices.GameServerConfigScalingConfigSelector[];
    }

    export interface GameServerConfigScalingConfigSchedule {
        cronJobDuration?: string;
        cronSpec?: string;
        endTime?: string;
        startTime?: string;
    }

    export interface GameServerConfigScalingConfigSelector {
        labels?: {[key: string]: string};
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverride {
        configVersion?: string;
        realmsSelector?: outputs.gameservices.GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector;
    }

    export interface GameServerDeploymentRolloutGameServerConfigOverrideRealmsSelector {
        realms?: string[];
    }
}

export namespace healthcare {
    export interface DatasetIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatasetIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DicomStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface FhirStoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface FhirStoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface Hl7StoreNotificationConfig {
        pubsubTopic: string;
    }

    export interface Hl7StoreParserConfig {
        allowNullHeader?: boolean;
        segmentTerminator?: string;
    }
}

export namespace iap {
    export interface AppEngineServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface AppEngineServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface AppEngineVersionIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface AppEngineVersionIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface TunnelInstanceIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface TunnelInstanceIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebBackendServiceIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebBackendServiceIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebTypeAppEngingIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebTypeAppEngingIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebTypeComputeIamBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface WebTypeComputeIamMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }
}

export namespace identityplatform {
    export interface InboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.InboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface InboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface InboundSamlConfigSpConfig {
        callbackUri?: string;
        spCertificates: outputs.identityplatform.InboundSamlConfigSpConfigSpCertificate[];
        spEntityId?: string;
    }

    export interface InboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }

    export interface TenantInboundSamlConfigIdpConfig {
        idpCertificates: outputs.identityplatform.TenantInboundSamlConfigIdpConfigIdpCertificate[];
        idpEntityId: string;
        signRequest?: boolean;
        ssoUrl: string;
    }

    export interface TenantInboundSamlConfigIdpConfigIdpCertificate {
        x509Certificate?: string;
    }

    export interface TenantInboundSamlConfigSpConfig {
        callbackUri: string;
        spCertificates: outputs.identityplatform.TenantInboundSamlConfigSpConfigSpCertificate[];
        spEntityId: string;
    }

    export interface TenantInboundSamlConfigSpConfigSpCertificate {
        x509Certificate: string;
    }
}

export namespace kms {
    export interface CryptoKeyIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface CryptoKeyIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface CryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel?: string;
    }

    export interface GetKMSCryptoKeyVersionPublicKey {
        /**
         * The CryptoKeyVersionAlgorithm that this CryptoKeyVersion supports.
         */
        algorithm: string;
        /**
         * The public key, encoded in PEM format. For more information, see the RFC 7468 sections for General Considerations and Textual Encoding of Subject Public Key Info.
         */
        pem: string;
    }

    export interface GetKMSCryptoKeyVersionTemplate {
        algorithm: string;
        protectionLevel: string;
    }

    export interface KeyRingIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface KeyRingIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface RegistryCredential {
        /**
         * The certificate format and data.
         */
        publicKeyCertificate: outputs.kms.RegistryCredentialPublicKeyCertificate;
    }

    export interface RegistryCredentialPublicKeyCertificate {
        /**
         * The certificate data.
         */
        certificate: string;
        /**
         * The field allows only  `X509_CERTIFICATE_PEM`.
         */
        format: string;
    }

    export interface RegistryEventNotificationConfigItem {
        /**
         * PubSub topic name to publish device state updates.
         */
        pubsubTopicName: string;
        /**
         * If the subfolder name matches this string
         * exactly, this configuration will be used. The string must not include the
         * leading '/' character. If empty, all strings are matched. Empty value can
         * only be used for the last `eventNotificationConfigs` item.
         */
        subfolderMatches?: string;
    }

    export interface RegistryHttpConfig {
        /**
         * The field allows `HTTP_ENABLED` or `HTTP_DISABLED`.
         */
        httpEnabledState: string;
    }

    export interface RegistryMqttConfig {
        /**
         * The field allows `MQTT_ENABLED` or `MQTT_DISABLED`.
         */
        mqttEnabledState: string;
    }

    export interface RegistryStateNotificationConfig {
        /**
         * PubSub topic name to publish device state updates.
         */
        pubsubTopicName: string;
    }
}

export namespace logging {
    export interface BillingAccountSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: boolean;
    }

    export interface FolderSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: boolean;
    }

    export interface MetricBucketOptions {
        explicitBuckets?: outputs.logging.MetricBucketOptionsExplicitBuckets;
        exponentialBuckets?: outputs.logging.MetricBucketOptionsExponentialBuckets;
        linearBuckets?: outputs.logging.MetricBucketOptionsLinearBuckets;
    }

    export interface MetricBucketOptionsExplicitBuckets {
        bounds: number[];
    }

    export interface MetricBucketOptionsExponentialBuckets {
        growthFactor?: number;
        numFiniteBuckets?: number;
        scale?: number;
    }

    export interface MetricBucketOptionsLinearBuckets {
        numFiniteBuckets?: number;
        offset?: number;
        width?: number;
    }

    export interface MetricMetricDescriptor {
        displayName?: string;
        labels?: outputs.logging.MetricMetricDescriptorLabel[];
        metricKind: string;
        unit?: string;
        valueType: string;
    }

    export interface MetricMetricDescriptorLabel {
        description?: string;
        key: string;
        valueType?: string;
    }

    export interface OrganizationSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: boolean;
    }

    export interface ProjectSinkBigqueryOptions {
        /**
         * Whether to use [BigQuery's partition tables](https://cloud.google.com/bigquery/docs/partitioned-tables).
         * By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned
         * tables the date suffix is no longer present and [special query syntax](https://cloud.google.com/bigquery/docs/querying-partitioned-tables)
         * has to be used instead. In both cases, tables are sharded based on UTC timezone.
         */
        usePartitionedTables: boolean;
    }
}

export namespace ml {
    export interface EngineModelDefaultVersion {
        name: string;
    }
}

export namespace monitoring {
    export interface AlertPolicyCondition {
        conditionAbsent?: outputs.monitoring.AlertPolicyConditionConditionAbsent;
        conditionThreshold?: outputs.monitoring.AlertPolicyConditionConditionThreshold;
        displayName: string;
        name: string;
    }

    export interface AlertPolicyConditionConditionAbsent {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionAbsentAggregation[];
        duration: string;
        filter?: string;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionAbsentTrigger;
    }

    export interface AlertPolicyConditionConditionAbsentAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionAbsentTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyConditionConditionThreshold {
        aggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdAggregation[];
        comparison: string;
        denominatorAggregations?: outputs.monitoring.AlertPolicyConditionConditionThresholdDenominatorAggregation[];
        denominatorFilter?: string;
        duration: string;
        filter?: string;
        thresholdValue?: number;
        trigger?: outputs.monitoring.AlertPolicyConditionConditionThresholdTrigger;
    }

    export interface AlertPolicyConditionConditionThresholdAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdDenominatorAggregation {
        alignmentPeriod?: string;
        crossSeriesReducer?: string;
        groupByFields?: string[];
        perSeriesAligner?: string;
    }

    export interface AlertPolicyConditionConditionThresholdTrigger {
        count?: number;
        percent?: number;
    }

    export interface AlertPolicyCreationRecord {
        mutateTime: string;
        mutatedBy: string;
    }

    export interface AlertPolicyDocumentation {
        content?: string;
        mimeType?: string;
    }

    export interface GetNotificationChannelSensitiveLabel {
        authToken: string;
        password: string;
        serviceKey: string;
    }

    export interface GetUptimeCheckIPsUptimeCheckIp {
        ipAddress: string;
        location: string;
        region: string;
    }

    export interface NotificationChannelSensitiveLabels {
        authToken?: string;
        password?: string;
        serviceKey?: string;
    }

    export interface UptimeCheckConfigContentMatcher {
        content: string;
    }

    export interface UptimeCheckConfigHttpCheck {
        authInfo?: outputs.monitoring.UptimeCheckConfigHttpCheckAuthInfo;
        headers?: {[key: string]: string};
        maskHeaders?: boolean;
        path?: string;
        port: number;
        useSsl?: boolean;
        validateSsl?: boolean;
    }

    export interface UptimeCheckConfigHttpCheckAuthInfo {
        password: string;
        username: string;
    }

    export interface UptimeCheckConfigMonitoredResource {
        labels: {[key: string]: string};
        type: string;
    }

    export interface UptimeCheckConfigResourceGroup {
        groupId?: string;
        resourceType?: string;
    }

    export interface UptimeCheckConfigTcpCheck {
        port: number;
    }
}

export namespace organizations {
    export interface GetIAMPolicyAuditConfig {
        /**
         * A nested block that defines the operations you'd like to log.
         */
        auditLogConfigs: outputs.organizations.GetIAMPolicyAuditConfigAuditLogConfig[];
        /**
         * Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service: string;
    }

    export interface GetIAMPolicyAuditConfigAuditLogConfig {
        /**
         * Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.
         */
        exemptedMembers?: string[];
        /**
         * Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.
         */
        logType: string;
    }

    export interface GetIAMPolicyBinding {
        condition?: outputs.organizations.GetIAMPolicyBindingCondition;
        /**
         * An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding
         * Each entry can have one of the following values:
         * * **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. It **can't** be used with the `gcp.organizations.Project` resource.
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        members: string[];
        /**
         * The role/permission that will be granted to the members.
         * See the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.
         * Note that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.
         */
        role: string;
    }

    export interface GetIAMPolicyBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface IamAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.
         * Each entry can have one of the following values:
         * * **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
         * * **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
         * * **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
         * * **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
         */
        exemptedMembers?: string[];
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: string;
    }

    export interface PolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: boolean;
    }

    export interface PolicyListPolicy {
        allow?: outputs.organizations.PolicyListPolicyAllow;
        deny?: outputs.organizations.PolicyListPolicyDeny;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: boolean;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue: string;
    }

    export interface PolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface PolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface PolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: boolean;
    }
}

export namespace projects {
    export interface GetOrganizationPolicyBooleanPolicy {
        enforced: boolean;
    }

    export interface GetOrganizationPolicyListPolicy {
        allows: outputs.projects.GetOrganizationPolicyListPolicyAllow[];
        denies: outputs.projects.GetOrganizationPolicyListPolicyDeny[];
        inheritFromParent: boolean;
        suggestedValue: string;
    }

    export interface GetOrganizationPolicyListPolicyAllow {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyListPolicyDeny {
        all: boolean;
        values: string[];
    }

    export interface GetOrganizationPolicyRestorePolicy {
        default: boolean;
    }

    export interface GetProjectProject {
        /**
         * The project id of the project.
         */
        projectId: string;
    }

    export interface IAMAuditConfigAuditLogConfig {
        /**
         * Identities that do not cause logging for this type of permission.  The format is the same as that for `members`.
         */
        exemptedMembers?: string[];
        /**
         * Permission type for which logging is to be configured.  Must be one of `DATA_READ`, `DATA_WRITE`, or `ADMIN_READ`.
         */
        logType: string;
    }

    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface OrganizationPolicyBooleanPolicy {
        /**
         * If true, then the Policy is enforced. If false, then any configuration is acceptable.
         */
        enforced: boolean;
    }

    export interface OrganizationPolicyListPolicy {
        allow?: outputs.projects.OrganizationPolicyListPolicyAllow;
        deny?: outputs.projects.OrganizationPolicyListPolicyDeny;
        /**
         * If set to true, the values from the effective Policy of the parent resource
         * are inherited, meaning the values set in this Policy are added to the values inherited up the hierarchy.
         */
        inheritFromParent?: boolean;
        /**
         * The Google Cloud Console will try to default to a configuration that matches the value specified in this field.
         */
        suggestedValue: string;
    }

    export interface OrganizationPolicyListPolicyAllow {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface OrganizationPolicyListPolicyDeny {
        /**
         * The policy allows or denies all values.
         */
        all?: boolean;
        /**
         * The policy can define specific values that are allowed or denied.
         */
        values?: string[];
    }

    export interface OrganizationPolicyRestorePolicy {
        /**
         * May only be set to true. If set, then the default Policy is restored.
         */
        default: boolean;
    }
}

export namespace pubsub {
    export interface SubscriptionDeadLetterPolicy {
        deadLetterTopic?: string;
        maxDeliveryAttempts?: number;
    }

    export interface SubscriptionExpirationPolicy {
        ttl: string;
    }

    export interface SubscriptionIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SubscriptionPushConfig {
        attributes?: {[key: string]: string};
        oidcToken?: outputs.pubsub.SubscriptionPushConfigOidcToken;
        pushEndpoint: string;
    }

    export interface SubscriptionPushConfigOidcToken {
        audience?: string;
        serviceAccountEmail: string;
    }

    export interface TopicIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface TopicMessageStoragePolicy {
        allowedPersistenceRegions: string[];
    }
}

export namespace runtimeconfig {
    export interface ConfigIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface ConfigIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace secretmanager {
    export interface SecretIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface SecretReplication {
        automatic?: boolean;
        userManaged?: outputs.secretmanager.SecretReplicationUserManaged;
    }

    export interface SecretReplicationUserManaged {
        replicas: outputs.secretmanager.SecretReplicationUserManagedReplica[];
    }

    export interface SecretReplicationUserManagedReplica {
        location: string;
    }
}

export namespace serviceAccount {
    export interface IAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface IAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }
}

export namespace sourcerepo {
    export interface RepositoryIamBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryIamMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface RepositoryPubsubConfig {
        messageFormat: string;
        serviceAccountEmail: string;
        /**
         * The identifier for this object. Format specified above.
         */
        topic: string;
    }
}

export namespace spanner {
    export interface DatabaseIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface DatabaseIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMBindingCondition {
        description?: string;
        expression: string;
        title: string;
    }

    export interface InstanceIAMMemberCondition {
        description?: string;
        expression: string;
        title: string;
    }
}

export namespace sql {
    export interface DatabaseInstanceIpAddress {
        ipAddress: string;
        timeToRetire: string;
        type: string;
    }

    export interface DatabaseInstanceReplicaConfiguration {
        /**
         * PEM representation of the trusted CA's x509
         * certificate.
         */
        caCertificate?: string;
        /**
         * PEM representation of the slave's x509
         * certificate.
         */
        clientCertificate?: string;
        /**
         * PEM representation of the slave's private key. The
         * corresponding public key in encoded in the `clientCertificate`.
         */
        clientKey?: string;
        /**
         * The number of seconds
         * between connect retries.
         */
        connectRetryInterval?: number;
        /**
         * Path to a SQL file in GCS from which slave
         * instances are created. Format is `gs://bucket/filename`.
         */
        dumpFilePath?: string;
        /**
         * Specifies if the replica is the failover target.
         * If the field is set to true the replica will be designated as a failover replica.
         * If the master instance fails, the replica instance will be promoted as
         * the new master instance.
         */
        failoverTarget?: boolean;
        /**
         * Time in ms between replication
         * heartbeats.
         */
        masterHeartbeatPeriod?: number;
        /**
         * Password for the replication connection.
         */
        password?: string;
        sslCipher?: string;
        /**
         * Username for replication connection.
         */
        username?: string;
        /**
         * True if the master's common name
         * value is checked during the SSL handshake.
         */
        verifyServerCertificate?: boolean;
    }

    export interface DatabaseInstanceServerCaCert {
        cert: string;
        commonName: string;
        createTime: string;
        /**
         * The [RFC 3339](https://tools.ietf.org/html/rfc3339)
         * formatted date time string indicating when this whitelist expires.
         */
        expirationTime: string;
        sha1Fingerprint: string;
    }

    export interface DatabaseInstanceSettings {
        /**
         * This specifies when the instance should be
         * active. Can be either `ALWAYS`, `NEVER` or `ON_DEMAND`.
         */
        activationPolicy: string;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * A list of Google App Engine (GAE) project names that are allowed to access this instance.
         */
        authorizedGaeApplications?: string[];
        /**
         * This specifies whether a PostgreSQL instance
         * should be set up for high availability (`REGIONAL`) or single zone (`ZONAL`).
         */
        availabilityType: string;
        backupConfiguration: outputs.sql.DatabaseInstanceSettingsBackupConfiguration;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * Specific to read instances, indicates
         * when crash-safe replication flags are enabled.
         */
        crashSafeReplication: boolean;
        databaseFlags?: outputs.sql.DatabaseInstanceSettingsDatabaseFlag[];
        /**
         * Configuration to increase storage size automatically.  Note that future `pulumi apply` calls will attempt to resize the disk to the value specified in `diskSize` - if this is set, do not set `diskSize`.
         */
        diskAutoresize?: boolean;
        /**
         * The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased.
         */
        diskSize: number;
        /**
         * The type of data disk: PD_SSD or PD_HDD.
         */
        diskType: string;
        ipConfiguration: outputs.sql.DatabaseInstanceSettingsIpConfiguration;
        locationPreference: outputs.sql.DatabaseInstanceSettingsLocationPreference;
        maintenanceWindow?: outputs.sql.DatabaseInstanceSettingsMaintenanceWindow;
        /**
         * Pricing plan for this instance, can only be `PER_USE`.
         */
        pricingPlan?: string;
        /**
         * This property is only applicable to First Generation instances.
         * First Generation instances are now deprecated, see [here](https://cloud.google.com/sql/docs/mysql/upgrade-2nd-gen)
         * for information on how to upgrade to Second Generation instances.
         * Replication type for this instance, can be one of `ASYNCHRONOUS` or `SYNCHRONOUS`.
         */
        replicationType?: string;
        /**
         * The machine type to use. See [tiers](https://cloud.google.com/sql/docs/admin-api/v1beta4/tiers)
         * for more details and supported versions. Postgres supports only shared-core machine types such as `db-f1-micro`,
         * and custom machine types such as `db-custom-2-13312`. See the [Custom Machine Type Documentation](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) to learn about specifying custom machine types.
         */
        tier: string;
        /**
         * A set of key/value user label pairs to assign to the instance.
         */
        userLabels?: {[key: string]: string};
        version: number;
    }

    export interface DatabaseInstanceSettingsBackupConfiguration {
        /**
         * True if binary logging is enabled. If
         * `settings.backup_configuration.enabled` is false, this must be as well.
         * Cannot be used with Postgres.
         */
        binaryLogEnabled?: boolean;
        /**
         * True if backup configuration is enabled.
         */
        enabled?: boolean;
        location?: string;
        /**
         * `HH:MM` format time indicating when backup
         * configuration starts.
         */
        startTime: string;
    }

    export interface DatabaseInstanceSettingsDatabaseFlag {
        /**
         * A name for this whitelist entry.
         */
        name: string;
        /**
         * A CIDR notation IPv4 or IPv6 address that is allowed to
         * access this instance. Must be set even if other two attributes are not for
         * the whitelist to become active.
         */
        value: string;
    }

    export interface DatabaseInstanceSettingsIpConfiguration {
        authorizedNetworks?: outputs.sql.DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork[];
        /**
         * Whether this Cloud SQL instance should be assigned
         * a public IPV4 address. Either `ipv4Enabled` must be enabled or a
         * `privateNetwork` must be configured.
         */
        ipv4Enabled: boolean;
        /**
         * The VPC network from which the Cloud SQL
         * instance is accessible for private IP. For example, projects/myProject/global/networks/default.
         * Specifying a network enables private IP.
         * Either `ipv4Enabled` must be enabled or a `privateNetwork` must be configured.
         * This setting can be updated, but it cannot be removed after it is set.
         */
        privateNetwork?: string;
        /**
         * True if mysqld should default to `REQUIRE X509`
         * for users connecting over IP.
         */
        requireSsl?: boolean;
    }

    export interface DatabaseInstanceSettingsIpConfigurationAuthorizedNetwork {
        /**
         * The [RFC 3339](https://tools.ietf.org/html/rfc3339)
         * formatted date time string indicating when this whitelist expires.
         */
        expirationTime?: string;
        /**
         * A name for this whitelist entry.
         */
        name?: string;
        /**
         * A CIDR notation IPv4 or IPv6 address that is allowed to
         * access this instance. Must be set even if other two attributes are not for
         * the whitelist to become active.
         */
        value: string;
    }

    export interface DatabaseInstanceSettingsLocationPreference {
        /**
         * A GAE application whose zone to remain
         * in. Must be in the same region as this instance.
         */
        followGaeApplication?: string;
        /**
         * The preferred compute engine
         * [zone](https://cloud.google.com/compute/docs/zones?hl=en).
         */
        zone?: string;
    }

    export interface DatabaseInstanceSettingsMaintenanceWindow {
        /**
         * Day of week (`1-7`), starting on Monday
         */
        day?: number;
        /**
         * Hour of day (`0-23`), ignored if `day` not set
         */
        hour?: number;
        /**
         * Receive updates earlier (`canary`) or later
         * (`stable`)
         */
        updateTrack?: string;
    }

    export interface GetCaCertsCert {
        /**
         * The CA certificate used to connect to the SQL instance via SSL.
         */
        cert: string;
        /**
         * The CN valid for the CA cert.
         */
        commonName: string;
        /**
         * Creation time of the CA cert.
         */
        createTime: string;
        /**
         * Expiration time of the CA cert.
         */
        expirationTime: string;
        /**
         * SHA1 fingerprint of the CA cert.
         */
        sha1Fingerprint: string;
    }
}

export namespace storage {
    export interface BucketCor {
        /**
         * The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
         */
        maxAgeSeconds?: number;
        /**
         * The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
         */
        methods?: string[];
        /**
         * The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
         */
        origins?: string[];
        /**
         * The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
         */
        responseHeaders?: string[];
    }

    export interface BucketEncryption {
        defaultKmsKeyName: string;
    }

    export interface BucketIAMBindingCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface BucketIAMMemberCondition {
        /**
         * An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
         */
        description?: string;
        /**
         * Textual representation of an expression in Common Expression Language syntax.
         */
        expression: string;
        /**
         * A title for the expression, i.e. a short string describing its purpose.
         */
        title: string;
    }

    export interface BucketLifecycleRule {
        /**
         * The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
         */
        action: outputs.storage.BucketLifecycleRuleAction;
        /**
         * The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
         */
        condition: outputs.storage.BucketLifecycleRuleCondition;
    }

    export interface BucketLifecycleRuleAction {
        /**
         * The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`.
         */
        storageClass?: string;
        /**
         * The type of the action of this Lifecycle Rule. Supported values include: `Delete` and `SetStorageClass`.
         */
        type: string;
    }

    export interface BucketLifecycleRuleCondition {
        /**
         * Minimum age of an object in days to satisfy this condition.
         */
        age?: number;
        /**
         * Creation date of an object in RFC 3339 (e.g. `2017-06-13`) to satisfy this condition.
         */
        createdBefore?: string;
        /**
         * [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `STANDARD`, `DURABLE_REDUCED_AVAILABILITY`.
         */
        matchesStorageClasses?: string[];
        /**
         * Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
         */
        numNewerVersions?: number;
        /**
         * Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
         */
        withState: string;
    }

    export interface BucketLogging {
        /**
         * The bucket that will receive log objects.
         */
        logBucket: string;
        /**
         * The object prefix for log objects. If it's not provided,
         * by default GCS sets this to this bucket's name.
         */
        logObjectPrefix: string;
    }

    export interface BucketRetentionPolicy {
        /**
         * If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
         */
        isLocked?: boolean;
        /**
         * The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.
         */
        retentionPeriod: number;
    }

    export interface BucketVersioning {
        /**
         * While set to `true`, versioning is fully enabled for this bucket.
         */
        enabled: boolean;
    }

    export interface BucketWebsite {
        /**
         * Behaves as the bucket's directory index where
         * missing objects are treated as potential directories.
         */
        mainPageSuffix?: string;
        /**
         * The custom object to return when a requested
         * resource is not found.
         */
        notFoundPage?: string;
    }

    export interface DefaultObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface ObjectAccessControlProjectTeam {
        projectNumber?: string;
        team?: string;
    }

    export interface TransferJobSchedule {
        /**
         * The last day the recurring transfer will be run. If `scheduleEndDate` is the same as `scheduleStartDate`, the transfer will be executed only once. Structure documented below.
         */
        scheduleEndDate?: outputs.storage.TransferJobScheduleScheduleEndDate;
        /**
         * The first day the recurring transfer is scheduled to run. If `scheduleStartDate` is in the past, the transfer will run for the first time on the following day. Structure documented below.
         */
        scheduleStartDate: outputs.storage.TransferJobScheduleScheduleStartDate;
        /**
         * The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
         */
        startTimeOfDay?: outputs.storage.TransferJobScheduleStartTimeOfDay;
    }

    export interface TransferJobScheduleScheduleEndDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: number;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: number;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: number;
    }

    export interface TransferJobScheduleScheduleStartDate {
        /**
         * Day of month. Must be from 1 to 31 and valid for the year and month.
         */
        day: number;
        /**
         * Month of year. Must be from 1 to 12.
         */
        month: number;
        /**
         * Year of date. Must be from 1 to 9999.
         */
        year: number;
    }

    export interface TransferJobScheduleStartTimeOfDay {
        /**
         * Hours of day in 24 hour format. Should be from 0 to 23
         */
        hours: number;
        /**
         * Minutes of hour of day. Must be from 0 to 59.
         */
        minutes: number;
        /**
         * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
         */
        nanos: number;
        /**
         * Seconds of minutes of the time. Must normally be from 0 to 59.
         */
        seconds: number;
    }

    export interface TransferJobTransferSpec {
        /**
         * An AWS S3 data source. Structure documented below.
         */
        awsS3DataSource?: outputs.storage.TransferJobTransferSpecAwsS3DataSource;
        /**
         * A Google Cloud Storage data sink. Structure documented below.
         */
        gcsDataSink?: outputs.storage.TransferJobTransferSpecGcsDataSink;
        /**
         * A Google Cloud Storage data source. Structure documented below.
         */
        gcsDataSource?: outputs.storage.TransferJobTransferSpecGcsDataSource;
        /**
         * An HTTP URL data source. Structure documented below.
         */
        httpDataSource?: outputs.storage.TransferJobTransferSpecHttpDataSource;
        /**
         * Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `lastModificationTime` do not exclude objects in a data sink. Structure documented below.
         */
        objectConditions?: outputs.storage.TransferJobTransferSpecObjectConditions;
        /**
         * Characteristics of how to treat files from datasource and sink during job. If the option `deleteObjectsUniqueInSink` is true, object conditions based on objects' `lastModificationTime` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
         */
        transferOptions?: outputs.storage.TransferJobTransferSpecTransferOptions;
    }

    export interface TransferJobTransferSpecAwsS3DataSource {
        /**
         * AWS credentials block.
         */
        awsAccessKey: outputs.storage.TransferJobTransferSpecAwsS3DataSourceAwsAccessKey;
        /**
         * S3 Bucket name.
         */
        bucketName: string;
    }

    export interface TransferJobTransferSpecAwsS3DataSourceAwsAccessKey {
        /**
         * AWS Key ID.
         */
        accessKeyId: string;
        /**
         * AWS Secret Access Key.
         */
        secretAccessKey: string;
    }

    export interface TransferJobTransferSpecGcsDataSink {
        /**
         * S3 Bucket name.
         */
        bucketName: string;
    }

    export interface TransferJobTransferSpecGcsDataSource {
        /**
         * S3 Bucket name.
         */
        bucketName: string;
    }

    export interface TransferJobTransferSpecHttpDataSource {
        /**
         * The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
         */
        listUrl: string;
    }

    export interface TransferJobTransferSpecObjectConditions {
        /**
         * `excludePrefixes` must follow the requirements described for `includePrefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        excludePrefixes?: string[];
        /**
         * If `includeRefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `includePrefixes` and that do not start with any of the `excludePrefixes`. If `includePrefixes` is not specified, all objects except those that have names starting with one of the `excludePrefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
         */
        includePrefixes?: string[];
        /**
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        maxTimeElapsedSinceLastModification?: string;
        /**
         * 
         * A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
         */
        minTimeElapsedSinceLastModification?: string;
    }

    export interface TransferJobTransferSpecTransferOptions {
        /**
         * Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `deleteObjectsUniqueInSink` are mutually exclusive.
         */
        deleteObjectsFromSourceAfterTransfer?: boolean;
        /**
         * Whether objects that exist only in the sink should be deleted. Note that this option and
         * `deleteObjectsFromSourceAfterTransfer` are mutually exclusive.
         */
        deleteObjectsUniqueInSink?: boolean;
        /**
         * Whether overwriting objects that already exist in the sink is allowed.
         */
        overwriteObjectsAlreadyExistingInSink?: boolean;
    }
}

export namespace tpu {
    export interface NodeNetworkEndpoint {
        ipAddress: string;
        port: number;
    }

    export interface NodeSchedulingConfig {
        preemptible: boolean;
    }
}
