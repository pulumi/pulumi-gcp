// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ### Active Directory Peering Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const source_network = new gcp.compute.Network("source-network", {name: "ad-network"});
 * const ad_domain = new gcp.activedirectory.Domain("ad-domain", {
 *     domainName: "ad.test.hashicorptest.com",
 *     locations: ["us-central1"],
 *     reservedIpRange: "192.168.255.0/24",
 *     authorizedNetworks: [source_network.id],
 *     deletionProtection: false,
 * });
 * const peered_project = new gcp.organizations.Project("peered-project", {
 *     name: "my-peered-project",
 *     projectId: "my-peered-project",
 *     orgId: "123456789",
 *     billingAccount: "000000-0000000-0000000-000000",
 *     deletionPolicy: "DELETE",
 * });
 * const compute = new gcp.projects.Service("compute", {
 *     project: peered_project.projectId,
 *     service: "compute.googleapis.com",
 * });
 * const peered_network = new gcp.compute.Network("peered-network", {
 *     project: compute.project,
 *     name: "ad-peered-network",
 * });
 * const ad_domain_peering = new gcp.activedirectory.Peering("ad-domain-peering", {
 *     domainResource: ad_domain.name,
 *     peeringId: "ad-domain-peering",
 *     authorizedNetwork: peered_network.id,
 *     deletionProtection: false,
 *     labels: {
 *         foo: "bar",
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * This resource does not support import.
 */
export class Peering extends pulumi.CustomResource {
    /**
     * Get an existing Peering resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PeeringState, opts?: pulumi.CustomResourceOptions): Peering {
        return new Peering(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:activedirectory/peering:Peering';

    /**
     * Returns true if the given object is an instance of Peering.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Peering {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Peering.__pulumiType;
    }

    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    declare public readonly authorizedNetwork: pulumi.Output<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    declare public readonly domainResource: pulumi.Output<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    declare public /*out*/ readonly effectiveLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
     */
    declare public /*out*/ readonly name: pulumi.Output<string>;
    /**
     * (Required)
     */
    declare public readonly peeringId: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    declare public readonly project: pulumi.Output<string>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    declare public /*out*/ readonly pulumiLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * The current state of this Peering.
     */
    declare public readonly status: pulumi.Output<string | undefined>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    declare public readonly statusMessage: pulumi.Output<string | undefined>;

    /**
     * Create a Peering resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PeeringArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PeeringArgs | PeeringState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PeeringState | undefined;
            resourceInputs["authorizedNetwork"] = state?.authorizedNetwork;
            resourceInputs["domainResource"] = state?.domainResource;
            resourceInputs["effectiveLabels"] = state?.effectiveLabels;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["name"] = state?.name;
            resourceInputs["peeringId"] = state?.peeringId;
            resourceInputs["project"] = state?.project;
            resourceInputs["pulumiLabels"] = state?.pulumiLabels;
            resourceInputs["status"] = state?.status;
            resourceInputs["statusMessage"] = state?.statusMessage;
        } else {
            const args = argsOrState as PeeringArgs | undefined;
            if (args?.authorizedNetwork === undefined && !opts.urn) {
                throw new Error("Missing required property 'authorizedNetwork'");
            }
            if (args?.domainResource === undefined && !opts.urn) {
                throw new Error("Missing required property 'domainResource'");
            }
            if (args?.peeringId === undefined && !opts.urn) {
                throw new Error("Missing required property 'peeringId'");
            }
            resourceInputs["authorizedNetwork"] = args?.authorizedNetwork;
            resourceInputs["domainResource"] = args?.domainResource;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["peeringId"] = args?.peeringId;
            resourceInputs["project"] = args?.project;
            resourceInputs["status"] = args?.status;
            resourceInputs["statusMessage"] = args?.statusMessage;
            resourceInputs["effectiveLabels"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["pulumiLabels"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["effectiveLabels", "pulumiLabels"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Peering.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Peering resources.
 */
export interface PeeringState {
    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    authorizedNetwork?: pulumi.Input<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    domainResource?: pulumi.Input<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
     */
    name?: pulumi.Input<string>;
    /**
     * (Required)
     */
    peeringId?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    pulumiLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The current state of this Peering.
     */
    status?: pulumi.Input<string>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    statusMessage?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Peering resource.
 */
export interface PeeringArgs {
    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    authorizedNetwork: pulumi.Input<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    domainResource: pulumi.Input<string>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * (Required)
     */
    peeringId: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The current state of this Peering.
     */
    status?: pulumi.Input<string>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    statusMessage?: pulumi.Input<string>;
}
