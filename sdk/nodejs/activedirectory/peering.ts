// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 * ### Active Directory Peering Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const source_network = new gcp.compute.Network("source-network", {}, {
 *     provider: google_beta,
 * });
 * const ad_domain = new gcp.activedirectory.Domain("ad-domain", {
 *     domainName: "ad.test.hashicorptest.com",
 *     locations: ["us-central1"],
 *     reservedIpRange: "192.168.255.0/24",
 *     authorizedNetworks: [source_network.id],
 * }, {
 *     provider: google_beta,
 * });
 * const peered_project = new gcp.organizations.Project("peered-project", {
 *     projectId: "my-peered-project",
 *     orgId: "123456789",
 *     billingAccount: "000000-0000000-0000000-000000",
 * }, {
 *     provider: google_beta,
 * });
 * const compute = new gcp.projects.Service("compute", {
 *     project: peered_project.projectId,
 *     service: "compute.googleapis.com",
 * }, {
 *     provider: google_beta,
 * });
 * const peered_network = new gcp.compute.Network("peered-network", {project: compute.project}, {
 *     provider: google_beta,
 * });
 * const ad_domain_peering = new gcp.activedirectory.Peering("ad-domain-peering", {
 *     domainResource: ad_domain.name,
 *     peeringId: "ad-domain-peering",
 *     authorizedNetwork: peered_network.id,
 *     labels: {
 *         foo: "bar",
 *     },
 * }, {
 *     provider: google_beta,
 * });
 * ```
 *
 * ## Import
 *
 * This resource does not support import.
 */
export class Peering extends pulumi.CustomResource {
    /**
     * Get an existing Peering resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PeeringState, opts?: pulumi.CustomResourceOptions): Peering {
        return new Peering(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:activedirectory/peering:Peering';

    /**
     * Returns true if the given object is an instance of Peering.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Peering {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Peering.__pulumiType;
    }

    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    public readonly authorizedNetwork!: pulumi.Output<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    public readonly domainResource!: pulumi.Output<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
     * clients and services.
     */
    public /*out*/ readonly effectiveLabels!: pulumi.Output<{[key: string]: string}>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    public readonly labels!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
     */
    public /*out*/ readonly name!: pulumi.Output<string>;
    /**
     * - - -
     */
    public readonly peeringId!: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    public readonly project!: pulumi.Output<string>;
    /**
     * The current state of this Peering.
     */
    public readonly status!: pulumi.Output<string | undefined>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    public readonly statusMessage!: pulumi.Output<string | undefined>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    public /*out*/ readonly terraformLabels!: pulumi.Output<{[key: string]: string}>;

    /**
     * Create a Peering resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PeeringArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PeeringArgs | PeeringState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PeeringState | undefined;
            resourceInputs["authorizedNetwork"] = state ? state.authorizedNetwork : undefined;
            resourceInputs["domainResource"] = state ? state.domainResource : undefined;
            resourceInputs["effectiveLabels"] = state ? state.effectiveLabels : undefined;
            resourceInputs["labels"] = state ? state.labels : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["peeringId"] = state ? state.peeringId : undefined;
            resourceInputs["project"] = state ? state.project : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["statusMessage"] = state ? state.statusMessage : undefined;
            resourceInputs["terraformLabels"] = state ? state.terraformLabels : undefined;
        } else {
            const args = argsOrState as PeeringArgs | undefined;
            if ((!args || args.authorizedNetwork === undefined) && !opts.urn) {
                throw new Error("Missing required property 'authorizedNetwork'");
            }
            if ((!args || args.domainResource === undefined) && !opts.urn) {
                throw new Error("Missing required property 'domainResource'");
            }
            if ((!args || args.peeringId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'peeringId'");
            }
            resourceInputs["authorizedNetwork"] = args ? args.authorizedNetwork : undefined;
            resourceInputs["domainResource"] = args ? args.domainResource : undefined;
            resourceInputs["labels"] = args ? args.labels : undefined;
            resourceInputs["peeringId"] = args ? args.peeringId : undefined;
            resourceInputs["project"] = args ? args.project : undefined;
            resourceInputs["status"] = args ? args.status : undefined;
            resourceInputs["statusMessage"] = args ? args.statusMessage : undefined;
            resourceInputs["effectiveLabels"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["terraformLabels"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Peering.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Peering resources.
 */
export interface PeeringState {
    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    authorizedNetwork?: pulumi.Input<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    domainResource?: pulumi.Input<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other
     * clients and services.
     */
    effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Unique name of the peering in this scope including projects and location using the form: projects/{projectId}/locations/global/peerings/{peeringId}.
     */
    name?: pulumi.Input<string>;
    /**
     * - - -
     */
    peeringId?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The current state of this Peering.
     */
    status?: pulumi.Input<string>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    statusMessage?: pulumi.Input<string>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    terraformLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

/**
 * The set of arguments for constructing a Peering resource.
 */
export interface PeeringArgs {
    /**
     * The full names of the Google Compute Engine networks to which the instance is connected. Caller needs to make sure that CIDR subnets do not overlap between networks, else peering creation will fail.
     */
    authorizedNetwork: pulumi.Input<string>;
    /**
     * Full domain resource path for the Managed AD Domain involved in peering. The resource path should be in the form projects/{projectId}/locations/global/domains/{domainName}
     */
    domainResource: pulumi.Input<string>;
    /**
     * Resource labels that can contain user-provided metadata
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - - -
     */
    peeringId: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The current state of this Peering.
     */
    status?: pulumi.Input<string>;
    /**
     * Additional information about the current status of this peering, if available.
     */
    statusMessage?: pulumi.Input<string>;
}
