// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * A representation of a collection of database items organized in a way that allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
 *
 * To get more information about Index, see:
 *
 * * [API documentation](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes/)
 *
 * ## Example Usage
 *
 * ### Vertex Ai Index
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const vertexaiSa = new gcp.projects.ServiceIdentity("vertexai_sa", {service: "aiplatform.googleapis.com"});
 * const bucket = new gcp.storage.Bucket("bucket", {
 *     name: "vertex-ai-index-test",
 *     location: "us-central1",
 *     uniformBucketLevelAccess: true,
 * });
 * // The sample data comes from the following link:
 * // https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
 * const data = new gcp.storage.BucketObject("data", {
 *     name: "contents/data.json",
 *     bucket: bucket.name,
 *     content: `{\\"id\\": \\"42\\", \\"embedding\\": [0.5, 1.0], \\"restricts\\": [{\\"namespace\\": \\"class\\", \\"allow\\": [\\"cat\\", \\"pet\\"]},{\\"namespace\\": \\"category\\", \\"allow\\": [\\"feline\\"]}]}
 * {\\"id\\": \\"43\\", \\"embedding\\": [0.6, 1.0], \\"restricts\\": [{\\"namespace\\": \\"class\\", \\"allow\\": [\\"dog\\", \\"pet\\"]},{\\"namespace\\": \\"category\\", \\"allow\\": [\\"canine\\"]}]}
 * `,
 * });
 * const vertexaiEncrypterdecrypter = new gcp.kms.CryptoKeyIAMMember("vertexai_encrypterdecrypter", {
 *     cryptoKeyId: "kms-name",
 *     role: "roles/cloudkms.cryptoKeyEncrypterDecrypter",
 *     member: vertexaiSa.member,
 * });
 * const index = new gcp.vertex.AiIndex("index", {
 *     labels: {
 *         foo: "bar",
 *     },
 *     region: "us-central1",
 *     displayName: "test-index",
 *     description: "index for test",
 *     metadata: {
 *         contentsDeltaUri: pulumi.interpolate`gs://${bucket.name}/contents`,
 *         config: {
 *             dimensions: 2,
 *             approximateNeighborsCount: 150,
 *             shardSize: "SHARD_SIZE_SMALL",
 *             distanceMeasureType: "DOT_PRODUCT_DISTANCE",
 *             algorithmConfig: {
 *                 treeAhConfig: {
 *                     leafNodeEmbeddingCount: 500,
 *                     leafNodesToSearchPercent: 7,
 *                 },
 *             },
 *         },
 *     },
 *     encryptionSpec: {
 *         kmsKeyName: "kms-name",
 *     },
 *     indexUpdateMethod: "BATCH_UPDATE",
 * }, {
 *     dependsOn: [vertexaiEncrypterdecrypter],
 * });
 * ```
 * ### Vertex Ai Index Streaming
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const bucket = new gcp.storage.Bucket("bucket", {
 *     name: "vertex-ai-index-test",
 *     location: "us-central1",
 *     uniformBucketLevelAccess: true,
 * });
 * // The sample data comes from the following link:
 * // https://cloud.google.com/vertex-ai/docs/matching-engine/filtering#specify-namespaces-tokens
 * const data = new gcp.storage.BucketObject("data", {
 *     name: "contents/data.json",
 *     bucket: bucket.name,
 *     content: `{\\"id\\": \\"42\\", \\"embedding\\": [0.5, 1.0], \\"restricts\\": [{\\"namespace\\": \\"class\\", \\"allow\\": [\\"cat\\", \\"pet\\"]},{\\"namespace\\": \\"category\\", \\"allow\\": [\\"feline\\"]}]}
 * {\\"id\\": \\"43\\", \\"embedding\\": [0.6, 1.0], \\"restricts\\": [{\\"namespace\\": \\"class\\", \\"allow\\": [\\"dog\\", \\"pet\\"]},{\\"namespace\\": \\"category\\", \\"allow\\": [\\"canine\\"]}]}
 * `,
 * });
 * const index = new gcp.vertex.AiIndex("index", {
 *     labels: {
 *         foo: "bar",
 *     },
 *     region: "us-central1",
 *     displayName: "test-index",
 *     description: "index for test",
 *     metadata: {
 *         contentsDeltaUri: pulumi.interpolate`gs://${bucket.name}/contents`,
 *         config: {
 *             dimensions: 2,
 *             shardSize: "SHARD_SIZE_LARGE",
 *             distanceMeasureType: "COSINE_DISTANCE",
 *             featureNormType: "UNIT_L2_NORM",
 *             algorithmConfig: {
 *                 bruteForceConfig: {},
 *             },
 *         },
 *     },
 *     indexUpdateMethod: "STREAM_UPDATE",
 * });
 * ```
 *
 * ## Import
 *
 * Index can be imported using any of these accepted formats:
 *
 * * `projects/{{project}}/locations/{{region}}/indexes/{{name}}`
 *
 * * `{{project}}/{{region}}/{{name}}`
 *
 * * `{{region}}/{{name}}`
 *
 * * `{{name}}`
 *
 * When using the `pulumi import` command, Index can be imported using one of the formats above. For example:
 *
 * ```sh
 * $ pulumi import gcp:vertex/aiIndex:AiIndex default projects/{{project}}/locations/{{region}}/indexes/{{name}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:vertex/aiIndex:AiIndex default {{project}}/{{region}}/{{name}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:vertex/aiIndex:AiIndex default {{region}}/{{name}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:vertex/aiIndex:AiIndex default {{name}}
 * ```
 */
export class AiIndex extends pulumi.CustomResource {
    /**
     * Get an existing AiIndex resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: AiIndexState, opts?: pulumi.CustomResourceOptions): AiIndex {
        return new AiIndex(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:vertex/aiIndex:AiIndex';

    /**
     * Returns true if the given object is an instance of AiIndex.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is AiIndex {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === AiIndex.__pulumiType;
    }

    /**
     * The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
     */
    declare public /*out*/ readonly createTime: pulumi.Output<string>;
    /**
     * The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
     * Structure is documented below.
     */
    declare public /*out*/ readonly deployedIndexes: pulumi.Output<outputs.vertex.AiIndexDeployedIndex[]>;
    /**
     * The description of the Index.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     */
    declare public readonly displayName: pulumi.Output<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    declare public /*out*/ readonly effectiveLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * Customer-managed encryption key spec for an Index. If set, this Index and all sub-resources of this Index will be secured by this key.
     * Structure is documented below.
     */
    declare public readonly encryptionSpec: pulumi.Output<outputs.vertex.AiIndexEncryptionSpec | undefined>;
    /**
     * Used to perform consistent read-modify-write updates.
     */
    declare public /*out*/ readonly etag: pulumi.Output<string>;
    /**
     * Stats of the index resource.
     * Structure is documented below.
     */
    declare public /*out*/ readonly indexStats: pulumi.Output<outputs.vertex.AiIndexIndexStat[]>;
    /**
     * The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
     * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
     * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     */
    declare public readonly indexUpdateMethod: pulumi.Output<string | undefined>;
    /**
     * The labels with user-defined metadata to organize your Indexes.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Additional information about the Index.
     * Although this field is not marked as required in the API specification, it is currently required when creating an Index and must be provided.
     * Attempts to create an Index without this field will result in an API error.
     * Structure is documented below.
     */
    declare public readonly metadata: pulumi.Output<outputs.vertex.AiIndexMetadata>;
    /**
     * Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
     */
    declare public /*out*/ readonly metadataSchemaUri: pulumi.Output<string>;
    /**
     * The resource name of the Index.
     */
    declare public /*out*/ readonly name: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    declare public readonly project: pulumi.Output<string>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    declare public /*out*/ readonly pulumiLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * The region of the index. eg us-central1
     */
    declare public readonly region: pulumi.Output<string | undefined>;
    /**
     * The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
     */
    declare public /*out*/ readonly updateTime: pulumi.Output<string>;

    /**
     * Create a AiIndex resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AiIndexArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: AiIndexArgs | AiIndexState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as AiIndexState | undefined;
            resourceInputs["createTime"] = state?.createTime;
            resourceInputs["deployedIndexes"] = state?.deployedIndexes;
            resourceInputs["description"] = state?.description;
            resourceInputs["displayName"] = state?.displayName;
            resourceInputs["effectiveLabels"] = state?.effectiveLabels;
            resourceInputs["encryptionSpec"] = state?.encryptionSpec;
            resourceInputs["etag"] = state?.etag;
            resourceInputs["indexStats"] = state?.indexStats;
            resourceInputs["indexUpdateMethod"] = state?.indexUpdateMethod;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["metadata"] = state?.metadata;
            resourceInputs["metadataSchemaUri"] = state?.metadataSchemaUri;
            resourceInputs["name"] = state?.name;
            resourceInputs["project"] = state?.project;
            resourceInputs["pulumiLabels"] = state?.pulumiLabels;
            resourceInputs["region"] = state?.region;
            resourceInputs["updateTime"] = state?.updateTime;
        } else {
            const args = argsOrState as AiIndexArgs | undefined;
            if (args?.displayName === undefined && !opts.urn) {
                throw new Error("Missing required property 'displayName'");
            }
            if (args?.metadata === undefined && !opts.urn) {
                throw new Error("Missing required property 'metadata'");
            }
            resourceInputs["description"] = args?.description;
            resourceInputs["displayName"] = args?.displayName;
            resourceInputs["encryptionSpec"] = args?.encryptionSpec;
            resourceInputs["indexUpdateMethod"] = args?.indexUpdateMethod;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["metadata"] = args?.metadata;
            resourceInputs["project"] = args?.project;
            resourceInputs["region"] = args?.region;
            resourceInputs["createTime"] = undefined /*out*/;
            resourceInputs["deployedIndexes"] = undefined /*out*/;
            resourceInputs["effectiveLabels"] = undefined /*out*/;
            resourceInputs["etag"] = undefined /*out*/;
            resourceInputs["indexStats"] = undefined /*out*/;
            resourceInputs["metadataSchemaUri"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["pulumiLabels"] = undefined /*out*/;
            resourceInputs["updateTime"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["effectiveLabels", "pulumiLabels"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(AiIndex.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering AiIndex resources.
 */
export interface AiIndexState {
    /**
     * The timestamp of when the Index was created in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
     */
    createTime?: pulumi.Input<string>;
    /**
     * The pointers to DeployedIndexes created from this Index. An Index can be only deleted if all its DeployedIndexes had been undeployed first.
     * Structure is documented below.
     */
    deployedIndexes?: pulumi.Input<pulumi.Input<inputs.vertex.AiIndexDeployedIndex>[]>;
    /**
     * The description of the Index.
     */
    description?: pulumi.Input<string>;
    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     */
    displayName?: pulumi.Input<string>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Customer-managed encryption key spec for an Index. If set, this Index and all sub-resources of this Index will be secured by this key.
     * Structure is documented below.
     */
    encryptionSpec?: pulumi.Input<inputs.vertex.AiIndexEncryptionSpec>;
    /**
     * Used to perform consistent read-modify-write updates.
     */
    etag?: pulumi.Input<string>;
    /**
     * Stats of the index resource.
     * Structure is documented below.
     */
    indexStats?: pulumi.Input<pulumi.Input<inputs.vertex.AiIndexIndexStat>[]>;
    /**
     * The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
     * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
     * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     */
    indexUpdateMethod?: pulumi.Input<string>;
    /**
     * The labels with user-defined metadata to organize your Indexes.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Additional information about the Index.
     * Although this field is not marked as required in the API specification, it is currently required when creating an Index and must be provided.
     * Attempts to create an Index without this field will result in an API error.
     * Structure is documented below.
     */
    metadata?: pulumi.Input<inputs.vertex.AiIndexMetadata>;
    /**
     * Points to a YAML file stored on Google Cloud Storage describing additional information about the Index, that is specific to it. Unset if the Index does not have any additional information.
     */
    metadataSchemaUri?: pulumi.Input<string>;
    /**
     * The resource name of the Index.
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    pulumiLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The region of the index. eg us-central1
     */
    region?: pulumi.Input<string>;
    /**
     * The timestamp of when the Index was last updated in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
     */
    updateTime?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a AiIndex resource.
 */
export interface AiIndexArgs {
    /**
     * The description of the Index.
     */
    description?: pulumi.Input<string>;
    /**
     * The display name of the Index. The name can be up to 128 characters long and can consist of any UTF-8 characters.
     */
    displayName: pulumi.Input<string>;
    /**
     * Customer-managed encryption key spec for an Index. If set, this Index and all sub-resources of this Index will be secured by this key.
     * Structure is documented below.
     */
    encryptionSpec?: pulumi.Input<inputs.vertex.AiIndexEncryptionSpec>;
    /**
     * The update method to use with this Index. The value must be the followings. If not set, BATCH_UPDATE will be used by default.
     * * BATCH_UPDATE: user can call indexes.patch with files on Cloud Storage of datapoints to update.
     * * STREAM_UPDATE: user can call indexes.upsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     */
    indexUpdateMethod?: pulumi.Input<string>;
    /**
     * The labels with user-defined metadata to organize your Indexes.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Additional information about the Index.
     * Although this field is not marked as required in the API specification, it is currently required when creating an Index and must be provided.
     * Attempts to create an Index without this field will result in an API error.
     * Structure is documented below.
     */
    metadata: pulumi.Input<inputs.vertex.AiIndexMetadata>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * The region of the index. eg us-central1
     */
    region?: pulumi.Input<string>;
}
