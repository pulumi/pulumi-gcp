// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ### Alloydb Cluster Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const defaultNetwork = new gcp.compute.Network("default", {name: "alloydb-cluster"});
 * const _default = new gcp.alloydb.Cluster("default", {
 *     clusterId: "alloydb-cluster",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: defaultNetwork.id,
 *     },
 *     deletionProtection: false,
 * });
 * const project = gcp.organizations.getProject({});
 * ```
 * ### Alloydb Cluster Before Upgrade
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = gcp.compute.getNetwork({
 *     name: "alloydb-network",
 * });
 * const defaultCluster = new gcp.alloydb.Cluster("default", {
 *     clusterId: "alloydb-cluster",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.then(_default => _default.id),
 *     },
 *     databaseVersion: "POSTGRES_14",
 *     initialUser: {
 *         password: "alloydb-cluster",
 *     },
 *     deletionProtection: false,
 * });
 * const defaultInstance = new gcp.alloydb.Instance("default", {
 *     cluster: defaultCluster.name,
 *     instanceId: "alloydb-instance",
 *     instanceType: "PRIMARY",
 *     machineConfig: {
 *         cpuCount: 2,
 *     },
 * });
 * ```
 * ### Alloydb Cluster After Upgrade
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = gcp.compute.getNetwork({
 *     name: "alloydb-network",
 * });
 * const defaultCluster = new gcp.alloydb.Cluster("default", {
 *     clusterId: "alloydb-cluster",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.then(_default => _default.id),
 *     },
 *     databaseVersion: "POSTGRES_15",
 *     initialUser: {
 *         password: "alloydb-cluster",
 *     },
 *     deletionProtection: false,
 * });
 * const defaultInstance = new gcp.alloydb.Instance("default", {
 *     cluster: defaultCluster.name,
 *     instanceId: "alloydb-instance",
 *     instanceType: "PRIMARY",
 *     machineConfig: {
 *         cpuCount: 2,
 *     },
 * });
 * ```
 * ### Alloydb Cluster Full
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = new gcp.compute.Network("default", {name: "alloydb-cluster-full"});
 * const full = new gcp.alloydb.Cluster("full", {
 *     clusterId: "alloydb-cluster-full",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.id,
 *     },
 *     databaseVersion: "POSTGRES_15",
 *     initialUser: {
 *         user: "alloydb-cluster-full",
 *         password: "alloydb-cluster-full",
 *     },
 *     continuousBackupConfig: {
 *         enabled: true,
 *         recoveryWindowDays: 14,
 *     },
 *     automatedBackupPolicy: {
 *         location: "us-central1",
 *         backupWindow: "1800s",
 *         enabled: true,
 *         weeklySchedule: {
 *             daysOfWeeks: ["MONDAY"],
 *             startTimes: [{
 *                 hours: 23,
 *                 minutes: 0,
 *                 seconds: 0,
 *                 nanos: 0,
 *             }],
 *         },
 *         quantityBasedRetention: {
 *             count: 1,
 *         },
 *         labels: {
 *             test: "alloydb-cluster-full",
 *         },
 *     },
 *     labels: {
 *         test: "alloydb-cluster-full",
 *     },
 *     deletionProtection: false,
 * });
 * const project = gcp.organizations.getProject({});
 * ```
 * ### Alloydb Cluster Restore
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = gcp.compute.getNetwork({
 *     name: "alloydb-network",
 * });
 * const source = new gcp.alloydb.Cluster("source", {
 *     clusterId: "alloydb-source-cluster",
 *     location: "us-central1",
 *     network: _default.then(_default => _default.id),
 *     initialUser: {
 *         password: "alloydb-source-cluster",
 *     },
 *     deletionProtection: false,
 * });
 * const privateIpAlloc = new gcp.compute.GlobalAddress("private_ip_alloc", {
 *     name: "alloydb-source-cluster",
 *     addressType: "INTERNAL",
 *     purpose: "VPC_PEERING",
 *     prefixLength: 16,
 *     network: _default.then(_default => _default.id),
 * });
 * const vpcConnection = new gcp.servicenetworking.Connection("vpc_connection", {
 *     network: _default.then(_default => _default.id),
 *     service: "servicenetworking.googleapis.com",
 *     reservedPeeringRanges: [privateIpAlloc.name],
 * });
 * const sourceInstance = new gcp.alloydb.Instance("source", {
 *     cluster: source.name,
 *     instanceId: "alloydb-instance",
 *     instanceType: "PRIMARY",
 *     machineConfig: {
 *         cpuCount: 2,
 *     },
 * }, {
 *     dependsOn: [vpcConnection],
 * });
 * const sourceBackup = new gcp.alloydb.Backup("source", {
 *     backupId: "alloydb-backup",
 *     location: "us-central1",
 *     clusterName: source.name,
 * }, {
 *     dependsOn: [sourceInstance],
 * });
 * const restoredFromBackup = new gcp.alloydb.Cluster("restored_from_backup", {
 *     clusterId: "alloydb-backup-restored",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.then(_default => _default.id),
 *     },
 *     restoreBackupSource: {
 *         backupName: sourceBackup.name,
 *     },
 *     deletionProtection: false,
 * });
 * const restoredViaPitr = new gcp.alloydb.Cluster("restored_via_pitr", {
 *     clusterId: "alloydb-pitr-restored",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.then(_default => _default.id),
 *     },
 *     restoreContinuousBackupSource: {
 *         cluster: source.name,
 *         pointInTime: "2023-08-03T19:19:00.094Z",
 *     },
 *     deletionProtection: false,
 * });
 * const project = gcp.organizations.getProject({});
 * ```
 * ### Alloydb Secondary Cluster Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = new gcp.compute.Network("default", {name: "alloydb-secondary-cluster"});
 * const primary = new gcp.alloydb.Cluster("primary", {
 *     clusterId: "alloydb-primary-cluster",
 *     location: "us-central1",
 *     networkConfig: {
 *         network: _default.id,
 *     },
 *     deletionProtection: false,
 * });
 * const privateIpAlloc = new gcp.compute.GlobalAddress("private_ip_alloc", {
 *     name: "alloydb-secondary-cluster",
 *     addressType: "INTERNAL",
 *     purpose: "VPC_PEERING",
 *     prefixLength: 16,
 *     network: _default.id,
 * });
 * const vpcConnection = new gcp.servicenetworking.Connection("vpc_connection", {
 *     network: _default.id,
 *     service: "servicenetworking.googleapis.com",
 *     reservedPeeringRanges: [privateIpAlloc.name],
 * });
 * const primaryInstance = new gcp.alloydb.Instance("primary", {
 *     cluster: primary.name,
 *     instanceId: "alloydb-primary-instance",
 *     instanceType: "PRIMARY",
 *     machineConfig: {
 *         cpuCount: 2,
 *     },
 * }, {
 *     dependsOn: [vpcConnection],
 * });
 * const secondary = new gcp.alloydb.Cluster("secondary", {
 *     clusterId: "alloydb-secondary-cluster",
 *     location: "us-east1",
 *     networkConfig: {
 *         network: _default.id,
 *     },
 *     clusterType: "SECONDARY",
 *     continuousBackupConfig: {
 *         enabled: false,
 *     },
 *     secondaryConfig: {
 *         primaryClusterName: primary.name,
 *     },
 *     deletionProtection: false,
 * }, {
 *     dependsOn: [primaryInstance],
 * });
 * const project = gcp.organizations.getProject({});
 * ```
 *
 * ## Import
 *
 * Cluster can be imported using any of these accepted formats:
 *
 * * `projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}`
 *
 * * `{{project}}/{{location}}/{{cluster_id}}`
 *
 * * `{{location}}/{{cluster_id}}`
 *
 * * `{{cluster_id}}`
 *
 * When using the `pulumi import` command, Cluster can be imported using one of the formats above. For example:
 *
 * ```sh
 * $ pulumi import gcp:alloydb/cluster:Cluster default projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:alloydb/cluster:Cluster default {{project}}/{{location}}/{{cluster_id}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:alloydb/cluster:Cluster default {{location}}/{{cluster_id}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:alloydb/cluster:Cluster default {{cluster_id}}
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:alloydb/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    /**
     * Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
     * An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
     *
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     */
    declare public readonly annotations: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
     * Structure is documented below.
     */
    declare public readonly automatedBackupPolicy: pulumi.Output<outputs.alloydb.ClusterAutomatedBackupPolicy>;
    /**
     * Cluster created from backup.
     * Structure is documented below.
     */
    declare public /*out*/ readonly backupSources: pulumi.Output<outputs.alloydb.ClusterBackupSource[]>;
    /**
     * The ID of the alloydb cluster.
     */
    declare public readonly clusterId: pulumi.Output<string>;
    /**
     * The type of cluster. If not set, defaults to PRIMARY.
     * Default value is `PRIMARY`.
     * Possible values are: `PRIMARY`, `SECONDARY`.
     */
    declare public readonly clusterType: pulumi.Output<string | undefined>;
    /**
     * The continuous backup config for this cluster.
     * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
     * Structure is documented below.
     */
    declare public readonly continuousBackupConfig: pulumi.Output<outputs.alloydb.ClusterContinuousBackupConfig>;
    /**
     * ContinuousBackupInfo describes the continuous backup properties of a cluster.
     * Structure is documented below.
     */
    declare public /*out*/ readonly continuousBackupInfos: pulumi.Output<outputs.alloydb.ClusterContinuousBackupInfo[]>;
    /**
     * The database engine major version. This is an optional field and it's populated at the Cluster creation time.
     * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
     */
    declare public readonly databaseVersion: pulumi.Output<string>;
    /**
     * Policy to determine if the cluster should be deleted forcefully.
     * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
     * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
     * Possible values: DEFAULT, FORCE
     */
    declare public readonly deletionPolicy: pulumi.Output<string | undefined>;
    declare public readonly deletionProtection: pulumi.Output<boolean | undefined>;
    /**
     * User-settable and human-readable display name for the Cluster.
     */
    declare public readonly displayName: pulumi.Output<string | undefined>;
    declare public /*out*/ readonly effectiveAnnotations: pulumi.Output<{[key: string]: string}>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    declare public /*out*/ readonly effectiveLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
     * Structure is documented below.
     */
    declare public readonly encryptionConfig: pulumi.Output<outputs.alloydb.ClusterEncryptionConfig | undefined>;
    /**
     * (Output)
     * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
     * Structure is documented below.
     */
    declare public /*out*/ readonly encryptionInfos: pulumi.Output<outputs.alloydb.ClusterEncryptionInfo[]>;
    /**
     * For Resource freshness validation (https://google.aip.dev/154)
     */
    declare public readonly etag: pulumi.Output<string | undefined>;
    /**
     * Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
     * Structure is documented below.
     */
    declare public readonly initialUser: pulumi.Output<outputs.alloydb.ClusterInitialUser | undefined>;
    /**
     * User-defined labels for the alloydb cluster.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The location where the alloydb cluster should reside.
     */
    declare public readonly location: pulumi.Output<string>;
    /**
     * MaintenanceUpdatePolicy defines the policy for system updates.
     * Structure is documented below.
     */
    declare public readonly maintenanceUpdatePolicy: pulumi.Output<outputs.alloydb.ClusterMaintenanceUpdatePolicy | undefined>;
    /**
     * Cluster created via DMS migration.
     * Structure is documented below.
     */
    declare public /*out*/ readonly migrationSources: pulumi.Output<outputs.alloydb.ClusterMigrationSource[]>;
    /**
     * The name of the cluster resource.
     */
    declare public /*out*/ readonly name: pulumi.Output<string>;
    /**
     * Metadata related to network configuration.
     * Structure is documented below.
     */
    declare public readonly networkConfig: pulumi.Output<outputs.alloydb.ClusterNetworkConfig>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    declare public readonly project: pulumi.Output<string>;
    /**
     * Configuration for Private Service Connect (PSC) for the cluster.
     * Structure is documented below.
     */
    declare public readonly pscConfig: pulumi.Output<outputs.alloydb.ClusterPscConfig | undefined>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    declare public /*out*/ readonly pulumiLabels: pulumi.Output<{[key: string]: string}>;
    /**
     * Output only. Reconciling (https://google.aip.dev/128#reconciliation).
     * Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
     * This can happen due to user-triggered updates or system actions like failover or maintenance.
     */
    declare public /*out*/ readonly reconciling: pulumi.Output<boolean>;
    /**
     * The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
     * Structure is documented below.
     */
    declare public readonly restoreBackupSource: pulumi.Output<outputs.alloydb.ClusterRestoreBackupSource | undefined>;
    /**
     * The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
     * Structure is documented below.
     */
    declare public readonly restoreContinuousBackupSource: pulumi.Output<outputs.alloydb.ClusterRestoreContinuousBackupSource | undefined>;
    /**
     * Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
     * Structure is documented below.
     */
    declare public readonly secondaryConfig: pulumi.Output<outputs.alloydb.ClusterSecondaryConfig | undefined>;
    /**
     * Set to true to skip awaiting on the major version upgrade of the cluster.
     * Possible values: true, false
     * Default value: "true"
     */
    declare public readonly skipAwaitMajorVersionUpgrade: pulumi.Output<boolean | undefined>;
    /**
     * Output only. The current serving state of the cluster.
     */
    declare public /*out*/ readonly state: pulumi.Output<string>;
    /**
     * The subscrition type of cluster.
     * Possible values are: `TRIAL`, `STANDARD`.
     */
    declare public readonly subscriptionType: pulumi.Output<string>;
    /**
     * Contains information and all metadata related to TRIAL clusters.
     * Structure is documented below.
     */
    declare public /*out*/ readonly trialMetadatas: pulumi.Output<outputs.alloydb.ClusterTrialMetadata[]>;
    /**
     * The system-generated UID of the resource.
     */
    declare public /*out*/ readonly uid: pulumi.Output<string>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["annotations"] = state?.annotations;
            resourceInputs["automatedBackupPolicy"] = state?.automatedBackupPolicy;
            resourceInputs["backupSources"] = state?.backupSources;
            resourceInputs["clusterId"] = state?.clusterId;
            resourceInputs["clusterType"] = state?.clusterType;
            resourceInputs["continuousBackupConfig"] = state?.continuousBackupConfig;
            resourceInputs["continuousBackupInfos"] = state?.continuousBackupInfos;
            resourceInputs["databaseVersion"] = state?.databaseVersion;
            resourceInputs["deletionPolicy"] = state?.deletionPolicy;
            resourceInputs["deletionProtection"] = state?.deletionProtection;
            resourceInputs["displayName"] = state?.displayName;
            resourceInputs["effectiveAnnotations"] = state?.effectiveAnnotations;
            resourceInputs["effectiveLabels"] = state?.effectiveLabels;
            resourceInputs["encryptionConfig"] = state?.encryptionConfig;
            resourceInputs["encryptionInfos"] = state?.encryptionInfos;
            resourceInputs["etag"] = state?.etag;
            resourceInputs["initialUser"] = state?.initialUser;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["location"] = state?.location;
            resourceInputs["maintenanceUpdatePolicy"] = state?.maintenanceUpdatePolicy;
            resourceInputs["migrationSources"] = state?.migrationSources;
            resourceInputs["name"] = state?.name;
            resourceInputs["networkConfig"] = state?.networkConfig;
            resourceInputs["project"] = state?.project;
            resourceInputs["pscConfig"] = state?.pscConfig;
            resourceInputs["pulumiLabels"] = state?.pulumiLabels;
            resourceInputs["reconciling"] = state?.reconciling;
            resourceInputs["restoreBackupSource"] = state?.restoreBackupSource;
            resourceInputs["restoreContinuousBackupSource"] = state?.restoreContinuousBackupSource;
            resourceInputs["secondaryConfig"] = state?.secondaryConfig;
            resourceInputs["skipAwaitMajorVersionUpgrade"] = state?.skipAwaitMajorVersionUpgrade;
            resourceInputs["state"] = state?.state;
            resourceInputs["subscriptionType"] = state?.subscriptionType;
            resourceInputs["trialMetadatas"] = state?.trialMetadatas;
            resourceInputs["uid"] = state?.uid;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if (args?.clusterId === undefined && !opts.urn) {
                throw new Error("Missing required property 'clusterId'");
            }
            if (args?.location === undefined && !opts.urn) {
                throw new Error("Missing required property 'location'");
            }
            resourceInputs["annotations"] = args?.annotations;
            resourceInputs["automatedBackupPolicy"] = args?.automatedBackupPolicy;
            resourceInputs["clusterId"] = args?.clusterId;
            resourceInputs["clusterType"] = args?.clusterType;
            resourceInputs["continuousBackupConfig"] = args?.continuousBackupConfig;
            resourceInputs["databaseVersion"] = args?.databaseVersion;
            resourceInputs["deletionPolicy"] = args?.deletionPolicy;
            resourceInputs["deletionProtection"] = args?.deletionProtection;
            resourceInputs["displayName"] = args?.displayName;
            resourceInputs["encryptionConfig"] = args?.encryptionConfig;
            resourceInputs["etag"] = args?.etag;
            resourceInputs["initialUser"] = args?.initialUser;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["location"] = args?.location;
            resourceInputs["maintenanceUpdatePolicy"] = args?.maintenanceUpdatePolicy;
            resourceInputs["networkConfig"] = args?.networkConfig;
            resourceInputs["project"] = args?.project;
            resourceInputs["pscConfig"] = args?.pscConfig;
            resourceInputs["restoreBackupSource"] = args?.restoreBackupSource;
            resourceInputs["restoreContinuousBackupSource"] = args?.restoreContinuousBackupSource;
            resourceInputs["secondaryConfig"] = args?.secondaryConfig;
            resourceInputs["skipAwaitMajorVersionUpgrade"] = args?.skipAwaitMajorVersionUpgrade;
            resourceInputs["subscriptionType"] = args?.subscriptionType;
            resourceInputs["backupSources"] = undefined /*out*/;
            resourceInputs["continuousBackupInfos"] = undefined /*out*/;
            resourceInputs["effectiveAnnotations"] = undefined /*out*/;
            resourceInputs["effectiveLabels"] = undefined /*out*/;
            resourceInputs["encryptionInfos"] = undefined /*out*/;
            resourceInputs["migrationSources"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["pulumiLabels"] = undefined /*out*/;
            resourceInputs["reconciling"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["trialMetadatas"] = undefined /*out*/;
            resourceInputs["uid"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["effectiveLabels", "pulumiLabels"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    /**
     * Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
     * An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
     *
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     */
    annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
     * Structure is documented below.
     */
    automatedBackupPolicy?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicy>;
    /**
     * Cluster created from backup.
     * Structure is documented below.
     */
    backupSources?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterBackupSource>[]>;
    /**
     * The ID of the alloydb cluster.
     */
    clusterId?: pulumi.Input<string>;
    /**
     * The type of cluster. If not set, defaults to PRIMARY.
     * Default value is `PRIMARY`.
     * Possible values are: `PRIMARY`, `SECONDARY`.
     */
    clusterType?: pulumi.Input<string>;
    /**
     * The continuous backup config for this cluster.
     * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
     * Structure is documented below.
     */
    continuousBackupConfig?: pulumi.Input<inputs.alloydb.ClusterContinuousBackupConfig>;
    /**
     * ContinuousBackupInfo describes the continuous backup properties of a cluster.
     * Structure is documented below.
     */
    continuousBackupInfos?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterContinuousBackupInfo>[]>;
    /**
     * The database engine major version. This is an optional field and it's populated at the Cluster creation time.
     * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
     */
    databaseVersion?: pulumi.Input<string>;
    /**
     * Policy to determine if the cluster should be deleted forcefully.
     * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
     * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
     * Possible values: DEFAULT, FORCE
     */
    deletionPolicy?: pulumi.Input<string>;
    deletionProtection?: pulumi.Input<boolean>;
    /**
     * User-settable and human-readable display name for the Cluster.
     */
    displayName?: pulumi.Input<string>;
    effectiveAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
     */
    effectiveLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
     * Structure is documented below.
     */
    encryptionConfig?: pulumi.Input<inputs.alloydb.ClusterEncryptionConfig>;
    /**
     * (Output)
     * Output only. The encryption information for the WALs and backups required for ContinuousBackup.
     * Structure is documented below.
     */
    encryptionInfos?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterEncryptionInfo>[]>;
    /**
     * For Resource freshness validation (https://google.aip.dev/154)
     */
    etag?: pulumi.Input<string>;
    /**
     * Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
     * Structure is documented below.
     */
    initialUser?: pulumi.Input<inputs.alloydb.ClusterInitialUser>;
    /**
     * User-defined labels for the alloydb cluster.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The location where the alloydb cluster should reside.
     */
    location?: pulumi.Input<string>;
    /**
     * MaintenanceUpdatePolicy defines the policy for system updates.
     * Structure is documented below.
     */
    maintenanceUpdatePolicy?: pulumi.Input<inputs.alloydb.ClusterMaintenanceUpdatePolicy>;
    /**
     * Cluster created via DMS migration.
     * Structure is documented below.
     */
    migrationSources?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterMigrationSource>[]>;
    /**
     * The name of the cluster resource.
     */
    name?: pulumi.Input<string>;
    /**
     * Metadata related to network configuration.
     * Structure is documented below.
     */
    networkConfig?: pulumi.Input<inputs.alloydb.ClusterNetworkConfig>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * Configuration for Private Service Connect (PSC) for the cluster.
     * Structure is documented below.
     */
    pscConfig?: pulumi.Input<inputs.alloydb.ClusterPscConfig>;
    /**
     * The combination of labels configured directly on the resource
     * and default labels configured on the provider.
     */
    pulumiLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Output only. Reconciling (https://google.aip.dev/128#reconciliation).
     * Set to true if the current state of Cluster does not match the user's intended state, and the service is actively updating the resource to reconcile them.
     * This can happen due to user-triggered updates or system actions like failover or maintenance.
     */
    reconciling?: pulumi.Input<boolean>;
    /**
     * The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
     * Structure is documented below.
     */
    restoreBackupSource?: pulumi.Input<inputs.alloydb.ClusterRestoreBackupSource>;
    /**
     * The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
     * Structure is documented below.
     */
    restoreContinuousBackupSource?: pulumi.Input<inputs.alloydb.ClusterRestoreContinuousBackupSource>;
    /**
     * Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
     * Structure is documented below.
     */
    secondaryConfig?: pulumi.Input<inputs.alloydb.ClusterSecondaryConfig>;
    /**
     * Set to true to skip awaiting on the major version upgrade of the cluster.
     * Possible values: true, false
     * Default value: "true"
     */
    skipAwaitMajorVersionUpgrade?: pulumi.Input<boolean>;
    /**
     * Output only. The current serving state of the cluster.
     */
    state?: pulumi.Input<string>;
    /**
     * The subscrition type of cluster.
     * Possible values are: `TRIAL`, `STANDARD`.
     */
    subscriptionType?: pulumi.Input<string>;
    /**
     * Contains information and all metadata related to TRIAL clusters.
     * Structure is documented below.
     */
    trialMetadatas?: pulumi.Input<pulumi.Input<inputs.alloydb.ClusterTrialMetadata>[]>;
    /**
     * The system-generated UID of the resource.
     */
    uid?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    /**
     * Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
     * An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
     *
     * **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
     * Please refer to the field `effectiveAnnotations` for all of the annotations present on the resource.
     */
    annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The automated backup policy for this cluster. AutomatedBackupPolicy is disabled by default.
     * Structure is documented below.
     */
    automatedBackupPolicy?: pulumi.Input<inputs.alloydb.ClusterAutomatedBackupPolicy>;
    /**
     * The ID of the alloydb cluster.
     */
    clusterId: pulumi.Input<string>;
    /**
     * The type of cluster. If not set, defaults to PRIMARY.
     * Default value is `PRIMARY`.
     * Possible values are: `PRIMARY`, `SECONDARY`.
     */
    clusterType?: pulumi.Input<string>;
    /**
     * The continuous backup config for this cluster.
     * If no policy is provided then the default policy will be used. The default policy takes one backup a day and retains backups for 14 days.
     * Structure is documented below.
     */
    continuousBackupConfig?: pulumi.Input<inputs.alloydb.ClusterContinuousBackupConfig>;
    /**
     * The database engine major version. This is an optional field and it's populated at the Cluster creation time.
     * Note: Changing this field to a higer version results in upgrading the AlloyDB cluster which is an irreversible change.
     */
    databaseVersion?: pulumi.Input<string>;
    /**
     * Policy to determine if the cluster should be deleted forcefully.
     * Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster.
     * Deleting a Secondary cluster with a secondary instance REQUIRES setting deletionPolicy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance.
     * Possible values: DEFAULT, FORCE
     */
    deletionPolicy?: pulumi.Input<string>;
    deletionProtection?: pulumi.Input<boolean>;
    /**
     * User-settable and human-readable display name for the Cluster.
     */
    displayName?: pulumi.Input<string>;
    /**
     * EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
     * Structure is documented below.
     */
    encryptionConfig?: pulumi.Input<inputs.alloydb.ClusterEncryptionConfig>;
    /**
     * For Resource freshness validation (https://google.aip.dev/154)
     */
    etag?: pulumi.Input<string>;
    /**
     * Initial user to setup during cluster creation. If unset for new Clusters, a postgres role with null password is created. You will need to create additional users or set the password in order to log in.
     * Structure is documented below.
     */
    initialUser?: pulumi.Input<inputs.alloydb.ClusterInitialUser>;
    /**
     * User-defined labels for the alloydb cluster.
     * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
     * Please refer to the field `effectiveLabels` for all of the labels present on the resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The location where the alloydb cluster should reside.
     */
    location: pulumi.Input<string>;
    /**
     * MaintenanceUpdatePolicy defines the policy for system updates.
     * Structure is documented below.
     */
    maintenanceUpdatePolicy?: pulumi.Input<inputs.alloydb.ClusterMaintenanceUpdatePolicy>;
    /**
     * Metadata related to network configuration.
     * Structure is documented below.
     */
    networkConfig?: pulumi.Input<inputs.alloydb.ClusterNetworkConfig>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * Configuration for Private Service Connect (PSC) for the cluster.
     * Structure is documented below.
     */
    pscConfig?: pulumi.Input<inputs.alloydb.ClusterPscConfig>;
    /**
     * The source when restoring from a backup. Conflicts with 'restore_continuous_backup_source', both can't be set together.
     * Structure is documented below.
     */
    restoreBackupSource?: pulumi.Input<inputs.alloydb.ClusterRestoreBackupSource>;
    /**
     * The source when restoring via point in time recovery (PITR). Conflicts with 'restore_backup_source', both can't be set together.
     * Structure is documented below.
     */
    restoreContinuousBackupSource?: pulumi.Input<inputs.alloydb.ClusterRestoreContinuousBackupSource>;
    /**
     * Configuration of the secondary cluster for Cross Region Replication. This should be set if and only if the cluster is of type SECONDARY.
     * Structure is documented below.
     */
    secondaryConfig?: pulumi.Input<inputs.alloydb.ClusterSecondaryConfig>;
    /**
     * Set to true to skip awaiting on the major version upgrade of the cluster.
     * Possible values: true, false
     * Default value: "true"
     */
    skipAwaitMajorVersionUpgrade?: pulumi.Input<boolean>;
    /**
     * The subscrition type of cluster.
     * Possible values are: `TRIAL`, `STANDARD`.
     */
    subscriptionType?: pulumi.Input<string>;
}
