// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ### Firebasehosting Customdomain Basic
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = new gcp.firebase.HostingCustomDomain("default", {
 *     project: "my-project-name",
 *     siteId: "site-id",
 *     customDomain: "custom.domain.com",
 * });
 * ```
 * ### Firebasehosting Customdomain Full
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = new gcp.firebase.HostingSite("default", {
 *     project: "my-project-name",
 *     siteId: "site-id-full",
 * });
 * const defaultHostingCustomDomain = new gcp.firebase.HostingCustomDomain("default", {
 *     project: "my-project-name",
 *     siteId: _default.siteId,
 *     customDomain: "source.domain.com",
 *     certPreference: "GROUPED",
 *     redirectTarget: "destination.domain.com",
 *     waitDnsVerification: false,
 * });
 * ```
 * ### Firebasehosting Customdomain Cloud Run
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 *
 * const _default = new gcp.firebase.HostingSite("default", {
 *     project: "my-project-name",
 *     siteId: "site-id",
 * });
 * const defaultService = new gcp.cloudrunv2.Service("default", {
 *     project: "my-project-name",
 *     name: "cloud-run-service-via-hosting",
 *     location: "us-central1",
 *     ingress: "INGRESS_TRAFFIC_ALL",
 *     template: {
 *         containers: [{
 *             image: "us-docker.pkg.dev/cloudrun/container/hello",
 *         }],
 *     },
 *     deletionProtection: true,
 * });
 * const defaultHostingVersion = new gcp.firebase.HostingVersion("default", {
 *     siteId: _default.siteId,
 *     config: {
 *         rewrites: [{
 *             glob: "/hello/**",
 *             run: {
 *                 serviceId: defaultService.name,
 *                 region: defaultService.location,
 *             },
 *         }],
 *     },
 * });
 * const defaultHostingRelease = new gcp.firebase.HostingRelease("default", {
 *     siteId: _default.siteId,
 *     versionName: defaultHostingVersion.name,
 *     message: "Cloud Run Integration",
 * });
 * const defaultHostingCustomDomain = new gcp.firebase.HostingCustomDomain("default", {
 *     project: "my-project-name",
 *     siteId: _default.siteId,
 *     customDomain: "run.custom.domain.com",
 *     waitDnsVerification: false,
 * });
 * ```
 *
 * ## Import
 *
 * CustomDomain can be imported using any of these accepted formats:
 *
 * * `projects/{{project}}/sites/{{site_id}}/customDomains/{{custom_domain}}`
 *
 * * `sites/{{site_id}}/customDomains/{{custom_domain}}`
 *
 * * `{{project}}/{{site_id}}/{{custom_domain}}`
 *
 * * `{{site_id}}/{{custom_domain}}`
 *
 * When using the `pulumi import` command, CustomDomain can be imported using one of the formats above. For example:
 *
 * ```sh
 * $ pulumi import gcp:firebase/hostingCustomDomain:HostingCustomDomain default projects/{{project}}/sites/{{site_id}}/customDomains/{{custom_domain}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:firebase/hostingCustomDomain:HostingCustomDomain default sites/{{site_id}}/customDomains/{{custom_domain}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:firebase/hostingCustomDomain:HostingCustomDomain default {{project}}/{{site_id}}/{{custom_domain}}
 * ```
 *
 * ```sh
 * $ pulumi import gcp:firebase/hostingCustomDomain:HostingCustomDomain default {{site_id}}/{{custom_domain}}
 * ```
 */
export class HostingCustomDomain extends pulumi.CustomResource {
    /**
     * Get an existing HostingCustomDomain resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: HostingCustomDomainState, opts?: pulumi.CustomResourceOptions): HostingCustomDomain {
        return new HostingCustomDomain(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:firebase/hostingCustomDomain:HostingCustomDomain';

    /**
     * Returns true if the given object is an instance of HostingCustomDomain.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is HostingCustomDomain {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === HostingCustomDomain.__pulumiType;
    }

    /**
     * A field that lets you specify which SSL certificate type Hosting creates
     * for your domain name. Spark plan `CustomDomain`s only have access to the
     * `GROUPED` cert type, while Blaze plan can select any option.
     * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
     */
    public readonly certPreference!: pulumi.Output<string>;
    /**
     * The SSL certificate Hosting has for this `CustomDomain`'s domain name.
     * For new `CustomDomain`s, this often represents Hosting's intent to create
     * a certificate, rather than an actual cert. Check the `state` field for
     * more.
     * Structure is documented below.
     */
    public /*out*/ readonly certs!: pulumi.Output<outputs.firebase.HostingCustomDomainCert[]>;
    /**
     * The `CustomDomain`'s create time.
     */
    public /*out*/ readonly createTime!: pulumi.Output<string>;
    /**
     * The ID of the `CustomDomain`, which is the domain name you'd like to use with Firebase Hosting.
     *
     *
     * - - -
     */
    public readonly customDomain!: pulumi.Output<string>;
    /**
     * The time the `CustomDomain` was deleted; null for `CustomDomains` that
     * haven't been deleted. Deleted `CustomDomains` persist for approximately 30
     * days, after which time Hosting removes them completely.
     */
    public /*out*/ readonly deleteTime!: pulumi.Output<string>;
    /**
     * A string that represents the current state of the `CustomDomain` and
     * allows you to confirm its initial state in requests that would modify it.
     */
    public /*out*/ readonly etag!: pulumi.Output<string>;
    /**
     * The minimum time before a soft-deleted `CustomDomain` is completely removed
     * from Hosting; null for `CustomDomains` that haven't been deleted.
     */
    public /*out*/ readonly expireTime!: pulumi.Output<string>;
    /**
     * The host state of your domain name. Host state is determined by checking each
     * IP address associated with your domain name to see if it's serving
     * Hosting content.
     * HOST_UNHOSTED:
     * Your `CustomDomain`'s domain name isn't associated with any IP addresses.
     * HOST_UNREACHABLE:
     * Your `CustomDomain`'s domain name can't be reached. Hosting services' DNS
     * queries to find your domain name's IP addresses resulted in errors. See
     * your `CustomDomain`'s `issues` field for more details.
     * HOST_MISMATCH:
     * Your `CustomDomain`'s domain name has IP addresses that don't ultimately
     * resolve to Hosting.
     * HOST_CONFLICT:
     * Your `CustomDomain`'s domain name has IP addresses that resolve to both
     * Hosting and other services. To ensure consistent results, remove `A` and
     * `AAAA` records related to non-Hosting services.
     * HOST_ACTIVE:
     * All requests against your `CustomDomain`'s domain name are served by
     * Hosting. If the `CustomDomain`'s `OwnershipState` is also `ACTIVE`, Hosting
     * serves your Hosting Site's content on the domain name.
     */
    public /*out*/ readonly hostState!: pulumi.Output<string>;
    /**
     * A set of errors Hosting systems encountered when trying to establish
     * Hosting's ability to serve secure content for your domain name. Resolve
     * these issues to ensure your `CustomDomain` behaves properly.
     * Structure is documented below.
     */
    public /*out*/ readonly issues!: pulumi.Output<outputs.firebase.HostingCustomDomainIssue[]>;
    /**
     * The fully-qualified name of the `CustomDomain`.
     */
    public /*out*/ readonly name!: pulumi.Output<string>;
    /**
     * The ownership state of your domain name. Ownership is determined at a
     * Firebase project level, and established by adding `TXT` records to your
     * domain name's DNS records.
     * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
     * also grants that project ownership over `bar.foo.com`, unless you add
     * specific `TXT` records to `bar.foo.com` that grant a different project
     * ownership.
     * If your `CustomDomain` is in an `OwnershipState` other than
     * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn't been updated in at
     * least 30 days, Hosting's ownership systems delete the `CustomDomain`.
     * OWNERSHIP_MISSING:
     * Your `CustomDomain`'s domain name has no Hosting-related ownership records;
     * no Firebase project has permission to act on the domain name's behalf.
     * OWNERSHIP_UNREACHABLE:
     * Your `CustomDomain`'s domain name can't be reached. Hosting services' DNS
     * queries to find your domain name's ownership records resulted in errors.
     * See your `CustomDomain`'s `issues` field for more details.
     * OWNERSHIP_MISMATCH:
     * Your `CustomDomain`'s domain name is owned by another Firebase project.
     * Remove the conflicting `TXT` records and replace them with project-specific
     * records for your current Firebase project.
     * OWNERSHIP_CONFLICT:
     * Your `CustomDomain`'s domain name has conflicting `TXT` records that
     * indicate ownership by both your current Firebase project and another
     * project. Remove the other project's ownership records to grant the current
     * project ownership.
     * OWNERSHIP_PENDING:
     * Your `CustomDomain`'s DNS records are configured correctly. Hosting will
     * transfer ownership of your domain to this `CustomDomain` within 24 hours.
     * OWNERSHIP_ACTIVE:
     * Your `CustomDomain`'s domain name has `TXT` records that grant its project
     * permission to act on its behalf.
     */
    public /*out*/ readonly ownershipState!: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    public readonly project!: pulumi.Output<string>;
    /**
     * if true, indicates that Hosting's systems are attempting to
     * make the `CustomDomain`'s state match your preferred state. This is most
     * frequently `true` when initially provisioning a `CustomDomain` or when creating
     * a new SSL certificate to match an updated `certPreference`
     */
    public /*out*/ readonly reconciling!: pulumi.Output<boolean>;
    /**
     * A domain name that this CustomDomain should direct traffic towards. If
     * specified, Hosting will respond to requests against this CustomDomain
     * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
     * instead.
     */
    public readonly redirectTarget!: pulumi.Output<string | undefined>;
    /**
     * A set of updates you should make to the domain name's DNS records to
     * let Hosting serve secure content on its behalf.
     * Structure is documented below.
     */
    public /*out*/ readonly requiredDnsUpdates!: pulumi.Output<outputs.firebase.HostingCustomDomainRequiredDnsUpdate[]>;
    /**
     * The ID of the site in which to create this custom domain association.
     */
    public readonly siteId!: pulumi.Output<string>;
    /**
     * The last time the `CustomDomain` was updated.
     */
    public /*out*/ readonly updateTime!: pulumi.Output<string>;
    public readonly waitDnsVerification!: pulumi.Output<boolean | undefined>;

    /**
     * Create a HostingCustomDomain resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: HostingCustomDomainArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: HostingCustomDomainArgs | HostingCustomDomainState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as HostingCustomDomainState | undefined;
            resourceInputs["certPreference"] = state ? state.certPreference : undefined;
            resourceInputs["certs"] = state ? state.certs : undefined;
            resourceInputs["createTime"] = state ? state.createTime : undefined;
            resourceInputs["customDomain"] = state ? state.customDomain : undefined;
            resourceInputs["deleteTime"] = state ? state.deleteTime : undefined;
            resourceInputs["etag"] = state ? state.etag : undefined;
            resourceInputs["expireTime"] = state ? state.expireTime : undefined;
            resourceInputs["hostState"] = state ? state.hostState : undefined;
            resourceInputs["issues"] = state ? state.issues : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["ownershipState"] = state ? state.ownershipState : undefined;
            resourceInputs["project"] = state ? state.project : undefined;
            resourceInputs["reconciling"] = state ? state.reconciling : undefined;
            resourceInputs["redirectTarget"] = state ? state.redirectTarget : undefined;
            resourceInputs["requiredDnsUpdates"] = state ? state.requiredDnsUpdates : undefined;
            resourceInputs["siteId"] = state ? state.siteId : undefined;
            resourceInputs["updateTime"] = state ? state.updateTime : undefined;
            resourceInputs["waitDnsVerification"] = state ? state.waitDnsVerification : undefined;
        } else {
            const args = argsOrState as HostingCustomDomainArgs | undefined;
            if ((!args || args.customDomain === undefined) && !opts.urn) {
                throw new Error("Missing required property 'customDomain'");
            }
            if ((!args || args.siteId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'siteId'");
            }
            resourceInputs["certPreference"] = args ? args.certPreference : undefined;
            resourceInputs["customDomain"] = args ? args.customDomain : undefined;
            resourceInputs["project"] = args ? args.project : undefined;
            resourceInputs["redirectTarget"] = args ? args.redirectTarget : undefined;
            resourceInputs["siteId"] = args ? args.siteId : undefined;
            resourceInputs["waitDnsVerification"] = args ? args.waitDnsVerification : undefined;
            resourceInputs["certs"] = undefined /*out*/;
            resourceInputs["createTime"] = undefined /*out*/;
            resourceInputs["deleteTime"] = undefined /*out*/;
            resourceInputs["etag"] = undefined /*out*/;
            resourceInputs["expireTime"] = undefined /*out*/;
            resourceInputs["hostState"] = undefined /*out*/;
            resourceInputs["issues"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["ownershipState"] = undefined /*out*/;
            resourceInputs["reconciling"] = undefined /*out*/;
            resourceInputs["requiredDnsUpdates"] = undefined /*out*/;
            resourceInputs["updateTime"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(HostingCustomDomain.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering HostingCustomDomain resources.
 */
export interface HostingCustomDomainState {
    /**
     * A field that lets you specify which SSL certificate type Hosting creates
     * for your domain name. Spark plan `CustomDomain`s only have access to the
     * `GROUPED` cert type, while Blaze plan can select any option.
     * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
     */
    certPreference?: pulumi.Input<string>;
    /**
     * The SSL certificate Hosting has for this `CustomDomain`'s domain name.
     * For new `CustomDomain`s, this often represents Hosting's intent to create
     * a certificate, rather than an actual cert. Check the `state` field for
     * more.
     * Structure is documented below.
     */
    certs?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainCert>[]>;
    /**
     * The `CustomDomain`'s create time.
     */
    createTime?: pulumi.Input<string>;
    /**
     * The ID of the `CustomDomain`, which is the domain name you'd like to use with Firebase Hosting.
     *
     *
     * - - -
     */
    customDomain?: pulumi.Input<string>;
    /**
     * The time the `CustomDomain` was deleted; null for `CustomDomains` that
     * haven't been deleted. Deleted `CustomDomains` persist for approximately 30
     * days, after which time Hosting removes them completely.
     */
    deleteTime?: pulumi.Input<string>;
    /**
     * A string that represents the current state of the `CustomDomain` and
     * allows you to confirm its initial state in requests that would modify it.
     */
    etag?: pulumi.Input<string>;
    /**
     * The minimum time before a soft-deleted `CustomDomain` is completely removed
     * from Hosting; null for `CustomDomains` that haven't been deleted.
     */
    expireTime?: pulumi.Input<string>;
    /**
     * The host state of your domain name. Host state is determined by checking each
     * IP address associated with your domain name to see if it's serving
     * Hosting content.
     * HOST_UNHOSTED:
     * Your `CustomDomain`'s domain name isn't associated with any IP addresses.
     * HOST_UNREACHABLE:
     * Your `CustomDomain`'s domain name can't be reached. Hosting services' DNS
     * queries to find your domain name's IP addresses resulted in errors. See
     * your `CustomDomain`'s `issues` field for more details.
     * HOST_MISMATCH:
     * Your `CustomDomain`'s domain name has IP addresses that don't ultimately
     * resolve to Hosting.
     * HOST_CONFLICT:
     * Your `CustomDomain`'s domain name has IP addresses that resolve to both
     * Hosting and other services. To ensure consistent results, remove `A` and
     * `AAAA` records related to non-Hosting services.
     * HOST_ACTIVE:
     * All requests against your `CustomDomain`'s domain name are served by
     * Hosting. If the `CustomDomain`'s `OwnershipState` is also `ACTIVE`, Hosting
     * serves your Hosting Site's content on the domain name.
     */
    hostState?: pulumi.Input<string>;
    /**
     * A set of errors Hosting systems encountered when trying to establish
     * Hosting's ability to serve secure content for your domain name. Resolve
     * these issues to ensure your `CustomDomain` behaves properly.
     * Structure is documented below.
     */
    issues?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainIssue>[]>;
    /**
     * The fully-qualified name of the `CustomDomain`.
     */
    name?: pulumi.Input<string>;
    /**
     * The ownership state of your domain name. Ownership is determined at a
     * Firebase project level, and established by adding `TXT` records to your
     * domain name's DNS records.
     * Ownership cascades to subdomains. Granting a project ownership of `foo.com`
     * also grants that project ownership over `bar.foo.com`, unless you add
     * specific `TXT` records to `bar.foo.com` that grant a different project
     * ownership.
     * If your `CustomDomain` is in an `OwnershipState` other than
     * `OWNERSHIP_ACTIVE` for more than 30 days and it hasn't been updated in at
     * least 30 days, Hosting's ownership systems delete the `CustomDomain`.
     * OWNERSHIP_MISSING:
     * Your `CustomDomain`'s domain name has no Hosting-related ownership records;
     * no Firebase project has permission to act on the domain name's behalf.
     * OWNERSHIP_UNREACHABLE:
     * Your `CustomDomain`'s domain name can't be reached. Hosting services' DNS
     * queries to find your domain name's ownership records resulted in errors.
     * See your `CustomDomain`'s `issues` field for more details.
     * OWNERSHIP_MISMATCH:
     * Your `CustomDomain`'s domain name is owned by another Firebase project.
     * Remove the conflicting `TXT` records and replace them with project-specific
     * records for your current Firebase project.
     * OWNERSHIP_CONFLICT:
     * Your `CustomDomain`'s domain name has conflicting `TXT` records that
     * indicate ownership by both your current Firebase project and another
     * project. Remove the other project's ownership records to grant the current
     * project ownership.
     * OWNERSHIP_PENDING:
     * Your `CustomDomain`'s DNS records are configured correctly. Hosting will
     * transfer ownership of your domain to this `CustomDomain` within 24 hours.
     * OWNERSHIP_ACTIVE:
     * Your `CustomDomain`'s domain name has `TXT` records that grant its project
     * permission to act on its behalf.
     */
    ownershipState?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * if true, indicates that Hosting's systems are attempting to
     * make the `CustomDomain`'s state match your preferred state. This is most
     * frequently `true` when initially provisioning a `CustomDomain` or when creating
     * a new SSL certificate to match an updated `certPreference`
     */
    reconciling?: pulumi.Input<boolean>;
    /**
     * A domain name that this CustomDomain should direct traffic towards. If
     * specified, Hosting will respond to requests against this CustomDomain
     * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
     * instead.
     */
    redirectTarget?: pulumi.Input<string>;
    /**
     * A set of updates you should make to the domain name's DNS records to
     * let Hosting serve secure content on its behalf.
     * Structure is documented below.
     */
    requiredDnsUpdates?: pulumi.Input<pulumi.Input<inputs.firebase.HostingCustomDomainRequiredDnsUpdate>[]>;
    /**
     * The ID of the site in which to create this custom domain association.
     */
    siteId?: pulumi.Input<string>;
    /**
     * The last time the `CustomDomain` was updated.
     */
    updateTime?: pulumi.Input<string>;
    waitDnsVerification?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a HostingCustomDomain resource.
 */
export interface HostingCustomDomainArgs {
    /**
     * A field that lets you specify which SSL certificate type Hosting creates
     * for your domain name. Spark plan `CustomDomain`s only have access to the
     * `GROUPED` cert type, while Blaze plan can select any option.
     * Possible values are: `GROUPED`, `PROJECT_GROUPED`, `DEDICATED`.
     */
    certPreference?: pulumi.Input<string>;
    /**
     * The ID of the `CustomDomain`, which is the domain name you'd like to use with Firebase Hosting.
     *
     *
     * - - -
     */
    customDomain: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * A domain name that this CustomDomain should direct traffic towards. If
     * specified, Hosting will respond to requests against this CustomDomain
     * with an HTTP 301 code, and route traffic to the specified `redirectTarget`
     * instead.
     */
    redirectTarget?: pulumi.Input<string>;
    /**
     * The ID of the site in which to create this custom domain association.
     */
    siteId: pulumi.Input<string>;
    waitDnsVerification?: pulumi.Input<boolean>;
}
