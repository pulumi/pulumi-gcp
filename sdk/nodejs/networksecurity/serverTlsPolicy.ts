// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ## Import
 *
 * ServerTlsPolicy can be imported using any of these accepted formats
 *
 * ```sh
 *  $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}
 * ```
 *
 * ```sh
 *  $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{project}}/{{location}}/{{name}}
 * ```
 *
 * ```sh
 *  $ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{location}}/{{name}}
 * ```
 */
export class ServerTlsPolicy extends pulumi.CustomResource {
    /**
     * Get an existing ServerTlsPolicy resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ServerTlsPolicyState, opts?: pulumi.CustomResourceOptions): ServerTlsPolicy {
        return new ServerTlsPolicy(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy';

    /**
     * Returns true if the given object is an instance of ServerTlsPolicy.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ServerTlsPolicy {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ServerTlsPolicy.__pulumiType;
    }

    /**
     * This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
     * Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
     * Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
     */
    public readonly allowOpen!: pulumi.Output<boolean | undefined>;
    /**
     * Time the ServerTlsPolicy was created in UTC.
     */
    public /*out*/ readonly createTime!: pulumi.Output<string>;
    /**
     * A free-text description of the resource. Max length 1024 characters.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * Set of label tags associated with the ServerTlsPolicy resource.
     */
    public readonly labels!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The location of the server tls policy.
     * The default value is `global`.
     */
    public readonly location!: pulumi.Output<string | undefined>;
    /**
     * This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
     * Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
     * Structure is documented below.
     */
    public readonly mtlsPolicy!: pulumi.Output<outputs.networksecurity.ServerTlsPolicyMtlsPolicy | undefined>;
    /**
     * Name of the ServerTlsPolicy resource.
     *
     *
     * - - -
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    public readonly project!: pulumi.Output<string>;
    /**
     * Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
     * Structure is documented below.
     */
    public readonly serverCertificate!: pulumi.Output<outputs.networksecurity.ServerTlsPolicyServerCertificate | undefined>;
    /**
     * Time the ServerTlsPolicy was updated in UTC.
     */
    public /*out*/ readonly updateTime!: pulumi.Output<string>;

    /**
     * Create a ServerTlsPolicy resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: ServerTlsPolicyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ServerTlsPolicyArgs | ServerTlsPolicyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ServerTlsPolicyState | undefined;
            resourceInputs["allowOpen"] = state ? state.allowOpen : undefined;
            resourceInputs["createTime"] = state ? state.createTime : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["labels"] = state ? state.labels : undefined;
            resourceInputs["location"] = state ? state.location : undefined;
            resourceInputs["mtlsPolicy"] = state ? state.mtlsPolicy : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["project"] = state ? state.project : undefined;
            resourceInputs["serverCertificate"] = state ? state.serverCertificate : undefined;
            resourceInputs["updateTime"] = state ? state.updateTime : undefined;
        } else {
            const args = argsOrState as ServerTlsPolicyArgs | undefined;
            resourceInputs["allowOpen"] = args ? args.allowOpen : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["labels"] = args ? args.labels : undefined;
            resourceInputs["location"] = args ? args.location : undefined;
            resourceInputs["mtlsPolicy"] = args ? args.mtlsPolicy : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["project"] = args ? args.project : undefined;
            resourceInputs["serverCertificate"] = args ? args.serverCertificate : undefined;
            resourceInputs["createTime"] = undefined /*out*/;
            resourceInputs["updateTime"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ServerTlsPolicy.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ServerTlsPolicy resources.
 */
export interface ServerTlsPolicyState {
    /**
     * This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
     * Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
     * Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
     */
    allowOpen?: pulumi.Input<boolean>;
    /**
     * Time the ServerTlsPolicy was created in UTC.
     */
    createTime?: pulumi.Input<string>;
    /**
     * A free-text description of the resource. Max length 1024 characters.
     */
    description?: pulumi.Input<string>;
    /**
     * Set of label tags associated with the ServerTlsPolicy resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The location of the server tls policy.
     * The default value is `global`.
     */
    location?: pulumi.Input<string>;
    /**
     * This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
     * Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
     * Structure is documented below.
     */
    mtlsPolicy?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyMtlsPolicy>;
    /**
     * Name of the ServerTlsPolicy resource.
     *
     *
     * - - -
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
     * Structure is documented below.
     */
    serverCertificate?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyServerCertificate>;
    /**
     * Time the ServerTlsPolicy was updated in UTC.
     */
    updateTime?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ServerTlsPolicy resource.
 */
export interface ServerTlsPolicyArgs {
    /**
     * This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
     * Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
     * Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
     */
    allowOpen?: pulumi.Input<boolean>;
    /**
     * A free-text description of the resource. Max length 1024 characters.
     */
    description?: pulumi.Input<string>;
    /**
     * Set of label tags associated with the ServerTlsPolicy resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The location of the server tls policy.
     * The default value is `global`.
     */
    location?: pulumi.Input<string>;
    /**
     * This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
     * Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
     * Structure is documented below.
     */
    mtlsPolicy?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyMtlsPolicy>;
    /**
     * Name of the ServerTlsPolicy resource.
     *
     *
     * - - -
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     */
    project?: pulumi.Input<string>;
    /**
     * Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
     * Structure is documented below.
     */
    serverCertificate?: pulumi.Input<inputs.networksecurity.ServerTlsPolicyServerCertificate>;
}
