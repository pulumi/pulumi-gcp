# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutomationRule',
    'AutomationRuleAdvanceRolloutRule',
    'AutomationRulePromoteReleaseRule',
    'AutomationRuleRepairRolloutRule',
    'AutomationRuleRepairRolloutRuleRepairPhase',
    'AutomationRuleRepairRolloutRuleRepairPhaseRetry',
    'AutomationRuleRepairRolloutRuleRepairPhaseRollback',
    'AutomationRuleTimedPromoteReleaseRule',
    'AutomationSelector',
    'AutomationSelectorTarget',
    'CustomTargetTypeCustomActions',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModule',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage',
    'CustomTargetTypeIamBindingCondition',
    'CustomTargetTypeIamMemberCondition',
    'DeliveryPipelineCondition',
    'DeliveryPipelineConditionPipelineReadyCondition',
    'DeliveryPipelineConditionTargetsPresentCondition',
    'DeliveryPipelineConditionTargetsTypeCondition',
    'DeliveryPipelineIamBindingCondition',
    'DeliveryPipelineIamMemberCondition',
    'DeliveryPipelineSerialPipeline',
    'DeliveryPipelineSerialPipelineStage',
    'DeliveryPipelineSerialPipelineStageDeployParameter',
    'DeliveryPipelineSerialPipelineStageStrategy',
    'DeliveryPipelineSerialPipelineStageStrategyCanary',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking',
    'DeliveryPipelineSerialPipelineStageStrategyStandard',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy',
    'DeployPolicyRule',
    'DeployPolicyRuleRolloutRestriction',
    'DeployPolicyRuleRolloutRestrictionTimeWindows',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime',
    'DeployPolicySelector',
    'DeployPolicySelectorDeliveryPipeline',
    'DeployPolicySelectorTarget',
    'TargetAnthosCluster',
    'TargetAssociatedEntity',
    'TargetAssociatedEntityAnthosCluster',
    'TargetAssociatedEntityGkeCluster',
    'TargetCustomTarget',
    'TargetExecutionConfig',
    'TargetGke',
    'TargetIamBindingCondition',
    'TargetIamMemberCondition',
    'TargetMultiTarget',
    'TargetRun',
]

@pulumi.output_type
class AutomationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceRolloutRule":
            suggest = "advance_rollout_rule"
        elif key == "promoteReleaseRule":
            suggest = "promote_release_rule"
        elif key == "repairRolloutRule":
            suggest = "repair_rollout_rule"
        elif key == "timedPromoteReleaseRule":
            suggest = "timed_promote_release_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_rollout_rule: Optional['outputs.AutomationRuleAdvanceRolloutRule'] = None,
                 promote_release_rule: Optional['outputs.AutomationRulePromoteReleaseRule'] = None,
                 repair_rollout_rule: Optional['outputs.AutomationRuleRepairRolloutRule'] = None,
                 timed_promote_release_rule: Optional['outputs.AutomationRuleTimedPromoteReleaseRule'] = None):
        """
        :param 'AutomationRuleAdvanceRolloutRuleArgs' advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
               Structure is documented below.
        :param 'AutomationRulePromoteReleaseRuleArgs' promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
               Structure is documented below.
        :param 'AutomationRuleRepairRolloutRuleArgs' repair_rollout_rule: Optional. The RepairRolloutRule will automatically repair a failed rollout.
               Structure is documented below.
        :param 'AutomationRuleTimedPromoteReleaseRuleArgs' timed_promote_release_rule: Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
               Structure is documented below.
        """
        if advance_rollout_rule is not None:
            pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        if promote_release_rule is not None:
            pulumi.set(__self__, "promote_release_rule", promote_release_rule)
        if repair_rollout_rule is not None:
            pulumi.set(__self__, "repair_rollout_rule", repair_rollout_rule)
        if timed_promote_release_rule is not None:
            pulumi.set(__self__, "timed_promote_release_rule", timed_promote_release_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> Optional['outputs.AutomationRuleAdvanceRolloutRule']:
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> Optional['outputs.AutomationRulePromoteReleaseRule']:
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
        return pulumi.get(self, "promote_release_rule")

    @property
    @pulumi.getter(name="repairRolloutRule")
    def repair_rollout_rule(self) -> Optional['outputs.AutomationRuleRepairRolloutRule']:
        """
        Optional. The RepairRolloutRule will automatically repair a failed rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "repair_rollout_rule")

    @property
    @pulumi.getter(name="timedPromoteReleaseRule")
    def timed_promote_release_rule(self) -> Optional['outputs.AutomationRuleTimedPromoteReleaseRule']:
        """
        Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
        Structure is documented below.
        """
        return pulumi.get(self, "timed_promote_release_rule")


@pulumi.output_type
class AutomationRuleAdvanceRolloutRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePhases":
            suggest = "source_phases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleAdvanceRolloutRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleAdvanceRolloutRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleAdvanceRolloutRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 source_phases: Optional[Sequence[builtins.str]] = None,
                 wait: Optional[builtins.str] = None):
        """
        :param builtins.str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param Sequence[builtins.str] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param builtins.str wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "id", id)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "source_phases")

    @property
    @pulumi.getter
    def wait(self) -> Optional[builtins.str]:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AutomationRulePromoteReleaseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPhase":
            suggest = "destination_phase"
        elif key == "destinationTargetId":
            suggest = "destination_target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePromoteReleaseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePromoteReleaseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePromoteReleaseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 destination_phase: Optional[builtins.str] = None,
                 destination_target_id: Optional[builtins.str] = None,
                 wait: Optional[builtins.str] = None):
        """
        :param builtins.str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param builtins.str destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param builtins.str destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param builtins.str wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "id", id)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[builtins.str]:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[builtins.str]:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @property
    @pulumi.getter
    def wait(self) -> Optional[builtins.str]:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AutomationRuleRepairRolloutRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repairPhases":
            suggest = "repair_phases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleRepairRolloutRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleRepairRolloutRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleRepairRolloutRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 jobs: Optional[Sequence[builtins.str]] = None,
                 phases: Optional[Sequence[builtins.str]] = None,
                 repair_phases: Optional[Sequence['outputs.AutomationRuleRepairRolloutRuleRepairPhase']] = None):
        """
        :param builtins.str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param Sequence[builtins.str] jobs: Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        :param Sequence[builtins.str] phases: Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        :param Sequence['AutomationRuleRepairRolloutRuleRepairPhaseArgs'] repair_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
               Structure is documented below.
        """
        pulumi.set(__self__, "id", id)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if repair_phases is not None:
            pulumi.set(__self__, "repair_phases", repair_phases)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def phases(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        return pulumi.get(self, "phases")

    @property
    @pulumi.getter(name="repairPhases")
    def repair_phases(self) -> Optional[Sequence['outputs.AutomationRuleRepairRolloutRuleRepairPhase']]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        Structure is documented below.
        """
        return pulumi.get(self, "repair_phases")


@pulumi.output_type
class AutomationRuleRepairRolloutRuleRepairPhase(dict):
    def __init__(__self__, *,
                 retry: Optional['outputs.AutomationRuleRepairRolloutRuleRepairPhaseRetry'] = None,
                 rollback: Optional['outputs.AutomationRuleRepairRolloutRuleRepairPhaseRollback'] = None):
        """
        :param 'AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs' retry: Optional. Retries a failed job.
               Structure is documented below.
        :param 'AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs' rollback: Optional. Rolls back a Rollout.
               Structure is documented below.
        """
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.AutomationRuleRepairRolloutRuleRepairPhaseRetry']:
        """
        Optional. Retries a failed job.
        Structure is documented below.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def rollback(self) -> Optional['outputs.AutomationRuleRepairRolloutRuleRepairPhaseRollback']:
        """
        Optional. Rolls back a Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class AutomationRuleRepairRolloutRuleRepairPhaseRetry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backoffMode":
            suggest = "backoff_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleRepairRolloutRuleRepairPhaseRetry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleRepairRolloutRuleRepairPhaseRetry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleRepairRolloutRuleRepairPhaseRetry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempts: builtins.str,
                 backoff_mode: Optional[builtins.str] = None,
                 wait: Optional[builtins.str] = None):
        """
        :param builtins.str attempts: Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        :param builtins.str backoff_mode: Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
               Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
        :param builtins.str wait: Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
        """
        pulumi.set(__self__, "attempts", attempts)
        if backoff_mode is not None:
            pulumi.set(__self__, "backoff_mode", backoff_mode)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def attempts(self) -> builtins.str:
        """
        Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        """
        return pulumi.get(self, "attempts")

    @property
    @pulumi.getter(name="backoffMode")
    def backoff_mode(self) -> Optional[builtins.str]:
        """
        Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
        Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
        """
        return pulumi.get(self, "backoff_mode")

    @property
    @pulumi.getter
    def wait(self) -> Optional[builtins.str]:
        """
        Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AutomationRuleRepairRolloutRuleRepairPhaseRollback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPhase":
            suggest = "destination_phase"
        elif key == "disableRollbackIfRolloutPending":
            suggest = "disable_rollback_if_rollout_pending"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleRepairRolloutRuleRepairPhaseRollback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleRepairRolloutRuleRepairPhaseRollback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleRepairRolloutRuleRepairPhaseRollback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_phase: Optional[builtins.str] = None,
                 disable_rollback_if_rollout_pending: Optional[builtins.bool] = None):
        """
        :param builtins.str destination_phase: Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
        :param builtins.bool disable_rollback_if_rollout_pending: Optional. If pending rollout exists on the target, the rollback operation will be aborted.
        """
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if disable_rollback_if_rollout_pending is not None:
            pulumi.set(__self__, "disable_rollback_if_rollout_pending", disable_rollback_if_rollout_pending)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[builtins.str]:
        """
        Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
        """
        return pulumi.get(self, "destination_phase")

    @property
    @pulumi.getter(name="disableRollbackIfRolloutPending")
    def disable_rollback_if_rollout_pending(self) -> Optional[builtins.bool]:
        """
        Optional. If pending rollout exists on the target, the rollback operation will be aborted.
        """
        return pulumi.get(self, "disable_rollback_if_rollout_pending")


@pulumi.output_type
class AutomationRuleTimedPromoteReleaseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"
        elif key == "destinationPhase":
            suggest = "destination_phase"
        elif key == "destinationTargetId":
            suggest = "destination_target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleTimedPromoteReleaseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleTimedPromoteReleaseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleTimedPromoteReleaseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 schedule: builtins.str,
                 time_zone: builtins.str,
                 destination_phase: Optional[builtins.str] = None,
                 destination_target_id: Optional[builtins.str] = None):
        """
        :param builtins.str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param builtins.str schedule: Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
        :param builtins.str time_zone: Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        :param builtins.str destination_phase: Optional. The starting phase of the rollout created by this rule. Default to the first phase.
               
               - - -
        :param builtins.str destination_target_id: Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
               - The last segment of a target name
               - "@next", the next target in the promotion sequence"
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "time_zone", time_zone)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def schedule(self) -> builtins.str:
        """
        Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> builtins.str:
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[builtins.str]:
        """
        Optional. The starting phase of the rollout created by this rule. Default to the first phase.

        - - -
        """
        return pulumi.get(self, "destination_phase")

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[builtins.str]:
        """
        Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
        - The last segment of a target name
        - "@next", the next target in the promotion sequence"
        """
        return pulumi.get(self, "destination_target_id")


@pulumi.output_type
class AutomationSelector(dict):
    def __init__(__self__, *,
                 targets: Sequence['outputs.AutomationSelectorTarget']):
        """
        :param Sequence['AutomationSelectorTargetArgs'] targets: Contains attributes about a target.
               Structure is documented below.
        """
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.AutomationSelectorTarget']:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class AutomationSelectorTarget(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param Mapping[str, builtins.str] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class CustomTargetTypeCustomActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployAction":
            suggest = "deploy_action"
        elif key == "includeSkaffoldModules":
            suggest = "include_skaffold_modules"
        elif key == "renderAction":
            suggest = "render_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTargetTypeCustomActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTargetTypeCustomActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTargetTypeCustomActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_action: builtins.str,
                 include_skaffold_modules: Optional[Sequence['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModule']] = None,
                 render_action: Optional[builtins.str] = None):
        """
        :param builtins.str deploy_action: The Skaffold custom action responsible for deploy operations.
        :param Sequence['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs'] include_skaffold_modules: List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
               Structure is documented below.
        :param builtins.str render_action: The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        pulumi.set(__self__, "deploy_action", deploy_action)
        if include_skaffold_modules is not None:
            pulumi.set(__self__, "include_skaffold_modules", include_skaffold_modules)
        if render_action is not None:
            pulumi.set(__self__, "render_action", render_action)

    @property
    @pulumi.getter(name="deployAction")
    def deploy_action(self) -> builtins.str:
        """
        The Skaffold custom action responsible for deploy operations.
        """
        return pulumi.get(self, "deploy_action")

    @property
    @pulumi.getter(name="includeSkaffoldModules")
    def include_skaffold_modules(self) -> Optional[Sequence['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModule']]:
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        return pulumi.get(self, "include_skaffold_modules")

    @property
    @pulumi.getter(name="renderAction")
    def render_action(self) -> Optional[builtins.str]:
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        return pulumi.get(self, "render_action")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "googleCloudBuildRepo":
            suggest = "google_cloud_build_repo"
        elif key == "googleCloudStorage":
            suggest = "google_cloud_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTargetTypeCustomActionsIncludeSkaffoldModule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTargetTypeCustomActionsIncludeSkaffoldModule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTargetTypeCustomActionsIncludeSkaffoldModule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configs: Optional[Sequence[builtins.str]] = None,
                 git: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit'] = None,
                 google_cloud_build_repo: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo'] = None,
                 google_cloud_storage: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage'] = None):
        """
        :param Sequence[builtins.str] configs: The Skaffold Config modules to use from the specified source.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs' git: Remote git repository containing the Skaffold Config modules.
               Structure is documented below.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs' google_cloud_build_repo: Cloud Build 2nd gen repository containing the Skaffold Config modules.
               Structure is documented below.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs' google_cloud_storage: Cloud Storage bucket containing Skaffold Config modules.
               Structure is documented below.
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if google_cloud_build_repo is not None:
            pulumi.set(__self__, "google_cloud_build_repo", google_cloud_build_repo)
        if google_cloud_storage is not None:
            pulumi.set(__self__, "google_cloud_storage", google_cloud_storage)

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence[builtins.str]]:
        """
        The Skaffold Config modules to use from the specified source.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def git(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit']:
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "git")

    @property
    @pulumi.getter(name="googleCloudBuildRepo")
    def google_cloud_build_repo(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo']:
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_build_repo")

    @property
    @pulumi.getter(name="googleCloudStorage")
    def google_cloud_storage(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage']:
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_storage")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit(dict):
    def __init__(__self__, *,
                 repo: builtins.str,
                 path: Optional[builtins.str] = None,
                 ref: Optional[builtins.str] = None):
        """
        :param builtins.str repo: Git repository the package should be cloned from.
        :param builtins.str path: Relative path from the repository root to the Skaffold file.
        :param builtins.str ref: Git ref the package should be cloned from.
        """
        pulumi.set(__self__, "repo", repo)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repo(self) -> builtins.str:
        """
        Git repository the package should be cloned from.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ref(self) -> Optional[builtins.str]:
        """
        Git ref the package should be cloned from.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo(dict):
    def __init__(__self__, *,
                 repository: builtins.str,
                 path: Optional[builtins.str] = None,
                 ref: Optional[builtins.str] = None):
        """
        :param builtins.str repository: Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        :param builtins.str path: Relative path from the repository root to the Skaffold file.
        :param builtins.str ref: Branch or tag to use when cloning the repository.
        """
        pulumi.set(__self__, "repository", repository)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repository(self) -> builtins.str:
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ref(self) -> Optional[builtins.str]:
        """
        Branch or tag to use when cloning the repository.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage(dict):
    def __init__(__self__, *,
                 source: builtins.str,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str source: Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        :param builtins.str path: Relative path from the source to the Skaffold file.
        """
        pulumi.set(__self__, "source", source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def source(self) -> builtins.str:
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Relative path from the source to the Skaffold file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class CustomTargetTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class CustomTargetTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineReadyConditions":
            suggest = "pipeline_ready_conditions"
        elif key == "targetsPresentConditions":
            suggest = "targets_present_conditions"
        elif key == "targetsTypeConditions":
            suggest = "targets_type_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_ready_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionPipelineReadyCondition']] = None,
                 targets_present_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionTargetsPresentCondition']] = None,
                 targets_type_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionTargetsTypeCondition']] = None):
        """
        :param Sequence['DeliveryPipelineConditionPipelineReadyConditionArgs'] pipeline_ready_conditions: Details around the Pipeline's overall status.
        :param Sequence['DeliveryPipelineConditionTargetsPresentConditionArgs'] targets_present_conditions: Details around targets enumerated in the pipeline.
        :param Sequence['DeliveryPipelineConditionTargetsTypeConditionArgs'] targets_type_conditions: Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        if pipeline_ready_conditions is not None:
            pulumi.set(__self__, "pipeline_ready_conditions", pipeline_ready_conditions)
        if targets_present_conditions is not None:
            pulumi.set(__self__, "targets_present_conditions", targets_present_conditions)
        if targets_type_conditions is not None:
            pulumi.set(__self__, "targets_type_conditions", targets_type_conditions)

    @property
    @pulumi.getter(name="pipelineReadyConditions")
    def pipeline_ready_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionPipelineReadyCondition']]:
        """
        Details around the Pipeline's overall status.
        """
        return pulumi.get(self, "pipeline_ready_conditions")

    @property
    @pulumi.getter(name="targetsPresentConditions")
    def targets_present_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionTargetsPresentCondition']]:
        """
        Details around targets enumerated in the pipeline.
        """
        return pulumi.get(self, "targets_present_conditions")

    @property
    @pulumi.getter(name="targetsTypeConditions")
    def targets_type_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionTargetsTypeCondition']]:
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        return pulumi.get(self, "targets_type_conditions")


@pulumi.output_type
class DeliveryPipelineConditionPipelineReadyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionPipelineReadyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionPipelineReadyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionPipelineReadyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[builtins.bool] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param builtins.bool status: True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        :param builtins.str update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.bool]:
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DeliveryPipelineConditionTargetsPresentCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingTargets":
            suggest = "missing_targets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionTargetsPresentCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionTargetsPresentCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionTargetsPresentCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_targets: Optional[Sequence[builtins.str]] = None,
                 status: Optional[builtins.bool] = None,
                 update_time: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] missing_targets: The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        :param builtins.bool status: True if there aren't any missing Targets.
        :param builtins.str update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if missing_targets is not None:
            pulumi.set(__self__, "missing_targets", missing_targets)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="missingTargets")
    def missing_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        return pulumi.get(self, "missing_targets")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.bool]:
        """
        True if there aren't any missing Targets.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[builtins.str]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DeliveryPipelineConditionTargetsTypeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionTargetsTypeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionTargetsTypeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionTargetsTypeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_details: Optional[builtins.str] = None,
                 status: Optional[builtins.bool] = None):
        """
        :param builtins.str error_details: Human readable error message.
        :param builtins.bool status: True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[builtins.str]:
        """
        Human readable error message.
        """
        return pulumi.get(self, "error_details")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.bool]:
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DeliveryPipelineIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineSerialPipeline(dict):
    def __init__(__self__, *,
                 stages: Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStage']] = None):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageArgs'] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStage']]:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployParameters":
            suggest = "deploy_parameters"
        elif key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_parameters: Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStageDeployParameter']] = None,
                 profiles: Optional[Sequence[builtins.str]] = None,
                 strategy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategy'] = None,
                 target_id: Optional[builtins.str] = None):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageDeployParameterArgs'] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param Sequence[builtins.str] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param 'DeliveryPipelineSerialPipelineStageStrategyArgs' strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param builtins.str target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        if deploy_parameters is not None:
            pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStageDeployParameter']]:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[builtins.str]]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def strategy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategy']:
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[builtins.str]:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageDeployParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchTargetLabels":
            suggest = "match_target_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageDeployParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageDeployParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageDeployParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Mapping[str, builtins.str],
                 match_target_labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Mapping[str, builtins.str] values: Required. Values are deploy parameters in key-value pairs.
        :param Mapping[str, builtins.str] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        pulumi.set(__self__, "values", values)
        if match_target_labels is not None:
            pulumi.set(__self__, "match_target_labels", match_target_labels)

    @property
    @pulumi.getter
    def values(self) -> Mapping[str, builtins.str]:
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategy(dict):
    def __init__(__self__, *,
                 canary: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanary'] = None,
                 standard: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandard'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryArgs' canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardArgs' standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        if canary is not None:
            pulumi.set(__self__, "canary", canary)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanary']:
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @property
    @pulumi.getter
    def standard(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandard']:
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canaryDeployment":
            suggest = "canary_deployment"
        elif key == "customCanaryDeployment":
            suggest = "custom_canary_deployment"
        elif key == "runtimeConfig":
            suggest = "runtime_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canary_deployment: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment'] = None,
                 custom_canary_deployment: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment'] = None,
                 runtime_config: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs' canary_deployment: Configures the progressive based deployment for a Target.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs' custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs' runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        if canary_deployment is not None:
            pulumi.set(__self__, "canary_deployment", canary_deployment)
        if custom_canary_deployment is not None:
            pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment']:
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment']:
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig']:
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment(dict):
    def __init__(__self__, *,
                 percentages: Sequence[builtins.int],
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy'] = None,
                 verify: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.int] percentages: Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs' predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        :param builtins.bool verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> Sequence[builtins.int]:
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy']:
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy']:
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> Optional[builtins.bool]:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseConfigs":
            suggest = "phase_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phase_configs: Sequence['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig']):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs'] phase_configs: Required. Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> Sequence['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig']:
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseId":
            suggest = "phase_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: builtins.int,
                 phase_id: builtins.str,
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy'] = None,
                 profiles: Optional[Sequence[builtins.str]] = None,
                 verify: Optional[builtins.bool] = None):
        """
        :param builtins.int percentage: Required. Percentage deployment for the phase.
        :param builtins.str phase_id: Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs' predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        :param Sequence[builtins.str] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param builtins.bool verify: Whether to run verify tests after the deployment.
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> builtins.int:
        """
        Required. Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> builtins.str:
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "phase_id")

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy']:
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy']:
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[builtins.str]]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def verify(self) -> Optional[builtins.bool]:
        """
        Whether to run verify tests after the deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRun":
            suggest = "cloud_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_run: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun'] = None,
                 kubernetes: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs' cloud_run: Cloud Run runtime configuration.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs' kubernetes: Kubernetes runtime configuration.
        """
        if cloud_run is not None:
            pulumi.set(__self__, "cloud_run", cloud_run)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun']:
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes']:
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticTrafficControl":
            suggest = "automatic_traffic_control"
        elif key == "canaryRevisionTags":
            suggest = "canary_revision_tags"
        elif key == "priorRevisionTags":
            suggest = "prior_revision_tags"
        elif key == "stableRevisionTags":
            suggest = "stable_revision_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_traffic_control: Optional[builtins.bool] = None,
                 canary_revision_tags: Optional[Sequence[builtins.str]] = None,
                 prior_revision_tags: Optional[Sequence[builtins.str]] = None,
                 stable_revision_tags: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        :param Sequence[builtins.str] canary_revision_tags: Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        :param Sequence[builtins.str] prior_revision_tags: Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        :param Sequence[builtins.str] stable_revision_tags: Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        if automatic_traffic_control is not None:
            pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)
        if canary_revision_tags is not None:
            pulumi.set(__self__, "canary_revision_tags", canary_revision_tags)
        if prior_revision_tags is not None:
            pulumi.set(__self__, "prior_revision_tags", prior_revision_tags)
        if stable_revision_tags is not None:
            pulumi.set(__self__, "stable_revision_tags", stable_revision_tags)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> Optional[builtins.bool]:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")

    @property
    @pulumi.getter(name="canaryRevisionTags")
    def canary_revision_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        return pulumi.get(self, "canary_revision_tags")

    @property
    @pulumi.getter(name="priorRevisionTags")
    def prior_revision_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        return pulumi.get(self, "prior_revision_tags")

    @property
    @pulumi.getter(name="stableRevisionTags")
    def stable_revision_tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        return pulumi.get(self, "stable_revision_tags")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayServiceMesh":
            suggest = "gateway_service_mesh"
        elif key == "serviceNetworking":
            suggest = "service_networking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_service_mesh: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh'] = None,
                 service_networking: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs' gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs' service_networking: Kubernetes Service networking configuration.
        """
        if gateway_service_mesh is not None:
            pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        if service_networking is not None:
            pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh']:
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking']:
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpRoute":
            suggest = "http_route"
        elif key == "podSelectorLabel":
            suggest = "pod_selector_label"
        elif key == "routeDestinations":
            suggest = "route_destinations"
        elif key == "routeUpdateWaitTime":
            suggest = "route_update_wait_time"
        elif key == "stableCutbackDuration":
            suggest = "stable_cutback_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: builtins.str,
                 http_route: builtins.str,
                 service: builtins.str,
                 pod_selector_label: Optional[builtins.str] = None,
                 route_destinations: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations'] = None,
                 route_update_wait_time: Optional[builtins.str] = None,
                 stable_cutback_duration: Optional[builtins.str] = None):
        """
        :param builtins.str deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param builtins.str http_route: Required. Name of the Gateway API HTTPRoute.
        :param builtins.str service: Required. Name of the Kubernetes Service.
        :param builtins.str pod_selector_label: Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs' route_destinations: Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
        :param builtins.str route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        :param builtins.str stable_cutback_duration: Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "service", service)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)
        if route_destinations is not None:
            pulumi.set(__self__, "route_destinations", route_destinations)
        if route_update_wait_time is not None:
            pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)
        if stable_cutback_duration is not None:
            pulumi.set(__self__, "stable_cutback_duration", stable_cutback_duration)

    @property
    @pulumi.getter
    def deployment(self) -> builtins.str:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> builtins.str:
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[builtins.str]:
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        return pulumi.get(self, "pod_selector_label")

    @property
    @pulumi.getter(name="routeDestinations")
    def route_destinations(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations']:
        """
        Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
        """
        return pulumi.get(self, "route_destinations")

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> Optional[builtins.str]:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @property
    @pulumi.getter(name="stableCutbackDuration")
    def stable_cutback_duration(self) -> Optional[builtins.str]:
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        return pulumi.get(self, "stable_cutback_duration")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationIds":
            suggest = "destination_ids"
        elif key == "propagateService":
            suggest = "propagate_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ids: Sequence[builtins.str],
                 propagate_service: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.str] destination_ids: Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
        :param builtins.bool propagate_service: Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
        """
        pulumi.set(__self__, "destination_ids", destination_ids)
        if propagate_service is not None:
            pulumi.set(__self__, "propagate_service", propagate_service)

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Sequence[builtins.str]:
        """
        Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
        """
        return pulumi.get(self, "destination_ids")

    @property
    @pulumi.getter(name="propagateService")
    def propagate_service(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
        """
        return pulumi.get(self, "propagate_service")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePodOverprovisioning":
            suggest = "disable_pod_overprovisioning"
        elif key == "podSelectorLabel":
            suggest = "pod_selector_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: builtins.str,
                 service: builtins.str,
                 disable_pod_overprovisioning: Optional[builtins.bool] = None,
                 pod_selector_label: Optional[builtins.str] = None):
        """
        :param builtins.str deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param builtins.str service: Required. Name of the Kubernetes Service.
        :param builtins.bool disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        :param builtins.str pod_selector_label: Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "service", service)
        if disable_pod_overprovisioning is not None:
            pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)

    @property
    @pulumi.getter
    def deployment(self) -> builtins.str:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def service(self) -> builtins.str:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> Optional[builtins.bool]:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[builtins.str]:
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        return pulumi.get(self, "pod_selector_label")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandard(dict):
    def __init__(__self__, *,
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy'] = None,
                 verify: Optional[builtins.bool] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs' predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param builtins.bool verify: Whether to verify a deployment.
        """
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy']:
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy']:
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> Optional[builtins.bool]:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeployPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rolloutRestriction":
            suggest = "rollout_restriction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rollout_restriction: Optional['outputs.DeployPolicyRuleRolloutRestriction'] = None):
        """
        :param 'DeployPolicyRuleRolloutRestrictionArgs' rollout_restriction: Optional. Rollout restrictions.
               Structure is documented below.
        """
        if rollout_restriction is not None:
            pulumi.set(__self__, "rollout_restriction", rollout_restriction)

    @property
    @pulumi.getter(name="rolloutRestriction")
    def rollout_restriction(self) -> Optional['outputs.DeployPolicyRuleRolloutRestriction']:
        """
        Optional. Rollout restrictions.
        Structure is documented below.
        """
        return pulumi.get(self, "rollout_restriction")


@pulumi.output_type
class DeployPolicyRuleRolloutRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindows":
            suggest = "time_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicyRuleRolloutRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicyRuleRolloutRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicyRuleRolloutRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 actions: Optional[Sequence[builtins.str]] = None,
                 invokers: Optional[Sequence[builtins.str]] = None,
                 time_windows: Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindows'] = None):
        """
        :param builtins.str id: Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param Sequence[builtins.str] actions: Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
               Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
        :param Sequence[builtins.str] invokers: Optional. What invoked the action. If left empty, all invoker types will be restricted.
               Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsArgs' time_windows: Required. Time window within which actions are restricted.
               Structure is documented below.
        """
        pulumi.set(__self__, "id", id)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if invokers is not None:
            pulumi.set(__self__, "invokers", invokers)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
        Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def invokers(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. What invoked the action. If left empty, all invoker types will be restricted.
        Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
        """
        return pulumi.get(self, "invokers")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindows']:
        """
        Required. Time window within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "time_windows")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"
        elif key == "oneTimeWindows":
            suggest = "one_time_windows"
        elif key == "weeklyWindows":
            suggest = "weekly_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicyRuleRolloutRestrictionTimeWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_zone: builtins.str,
                 one_time_windows: Optional[Sequence['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow']] = None,
                 weekly_windows: Optional[Sequence['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow']] = None):
        """
        :param builtins.str time_zone: Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        :param Sequence['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs'] one_time_windows: Optional. One-time windows within which actions are restricted.
               Structure is documented below.
        :param Sequence['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs'] weekly_windows: Optional. Recurring weekly windows within which actions are restricted.
               Structure is documented below.
        """
        pulumi.set(__self__, "time_zone", time_zone)
        if one_time_windows is not None:
            pulumi.set(__self__, "one_time_windows", one_time_windows)
        if weekly_windows is not None:
            pulumi.set(__self__, "weekly_windows", weekly_windows)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> builtins.str:
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="oneTimeWindows")
    def one_time_windows(self) -> Optional[Sequence['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow']]:
        """
        Optional. One-time windows within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "one_time_windows")

    @property
    @pulumi.getter(name="weeklyWindows")
    def weekly_windows(self) -> Optional[Sequence['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow']]:
        """
        Optional. Recurring weekly windows within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_windows")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate',
                 end_time: 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime',
                 start_date: 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate',
                 start_time: 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime'):
        """
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs' end_date: Required. End date.
               Structure is documented below.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs' end_time: Required. End time (exclusive). You may use 24:00 for the end of the day.
               Structure is documented below.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs' start_date: Required. Start date.
               Structure is documented below.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs' start_time: Required. Start time (inclusive). Use 00:00 for the beginning of the day.
               Structure is documented below.
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate':
        """
        Required. End date.
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime':
        """
        Required. End time (exclusive). You may use 24:00 for the end of the day.
        Structure is documented below.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate':
        """
        Required. Start date.
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> 'outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime':
        """
        Required. Start time (inclusive). Use 00:00 for the beginning of the day.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDate(dict):
    def __init__(__self__, *,
                 day: Optional[builtins.int] = None,
                 month: Optional[builtins.int] = None,
                 year: Optional[builtins.int] = None):
        """
        :param builtins.int day: Day of a month. Must be from 1 to 31 and valid for the year and month.
        :param builtins.int month: Month of a year. Must be from 1 to 12.
        :param builtins.int year: Year of the date. Must be from 1 to 9999.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def month(self) -> Optional[builtins.int]:
        """
        Month of a year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def year(self) -> Optional[builtins.int]:
        """
        Year of the date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTime(dict):
    def __init__(__self__, *,
                 hours: Optional[builtins.int] = None,
                 minutes: Optional[builtins.int] = None,
                 nanos: Optional[builtins.int] = None,
                 seconds: Optional[builtins.int] = None):
        """
        :param builtins.int hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param builtins.int minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param builtins.int nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
               
               - - -
        :param builtins.int seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[builtins.int]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[builtins.int]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[builtins.int]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[builtins.int]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDate(dict):
    def __init__(__self__, *,
                 day: Optional[builtins.int] = None,
                 month: Optional[builtins.int] = None,
                 year: Optional[builtins.int] = None):
        """
        :param builtins.int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param builtins.int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param builtins.int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def month(self) -> Optional[builtins.int]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def year(self) -> Optional[builtins.int]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[builtins.int] = None,
                 minutes: Optional[builtins.int] = None,
                 nanos: Optional[builtins.int] = None,
                 seconds: Optional[builtins.int] = None):
        """
        :param builtins.int hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param builtins.int minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param builtins.int nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        :param builtins.int seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[builtins.int]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[builtins.int]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[builtins.int]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[builtins.int]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[builtins.str]] = None,
                 end_time: Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime'] = None,
                 start_time: Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime'] = None):
        """
        :param Sequence[builtins.str] days_of_weeks: Optional. Days of week. If left empty, all days of the week will be included.
               Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs' end_time: Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
               Structure is documented below.
        :param 'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs' start_time: Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
               Structure is documented below.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. Days of week. If left empty, all days of the week will be included.
        Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime']:
        """
        Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional['outputs.DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime']:
        """
        Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTime(dict):
    def __init__(__self__, *,
                 hours: Optional[builtins.int] = None,
                 minutes: Optional[builtins.int] = None,
                 nanos: Optional[builtins.int] = None,
                 seconds: Optional[builtins.int] = None):
        """
        :param builtins.int hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param builtins.int minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param builtins.int nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
               
               - - -
        :param builtins.int seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[builtins.int]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[builtins.int]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[builtins.int]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[builtins.int]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[builtins.int] = None,
                 minutes: Optional[builtins.int] = None,
                 nanos: Optional[builtins.int] = None,
                 seconds: Optional[builtins.int] = None):
        """
        :param builtins.int hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param builtins.int minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param builtins.int nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        :param builtins.int seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[builtins.int]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[builtins.int]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[builtins.int]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[builtins.int]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class DeployPolicySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryPipeline":
            suggest = "delivery_pipeline"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployPolicySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployPolicySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployPolicySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_pipeline: Optional['outputs.DeployPolicySelectorDeliveryPipeline'] = None,
                 target: Optional['outputs.DeployPolicySelectorTarget'] = None):
        """
        :param 'DeployPolicySelectorDeliveryPipelineArgs' delivery_pipeline: Contains attributes about a delivery pipeline.
               Structure is documented below.
        :param 'DeployPolicySelectorTargetArgs' target: Contains attributes about a target.
               Structure is documented below.
        """
        if delivery_pipeline is not None:
            pulumi.set(__self__, "delivery_pipeline", delivery_pipeline)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="deliveryPipeline")
    def delivery_pipeline(self) -> Optional['outputs.DeployPolicySelectorDeliveryPipeline']:
        """
        Contains attributes about a delivery pipeline.
        Structure is documented below.
        """
        return pulumi.get(self, "delivery_pipeline")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.DeployPolicySelectorTarget']:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DeployPolicySelectorDeliveryPipeline(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str id: Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
               - The last segment of a pipeline name
               - "*", all delivery pipelines in a location
        :param Mapping[str, builtins.str] labels: DeliveryPipeline labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
        - The last segment of a pipeline name
        - "*", all delivery pipelines in a location
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        DeliveryPipeline labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class DeployPolicySelectorTarget(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param Mapping[str, builtins.str] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class TargetAnthosCluster(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class TargetAssociatedEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "anthosClusters":
            suggest = "anthos_clusters"
        elif key == "gkeClusters":
            suggest = "gke_clusters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetAssociatedEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetAssociatedEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetAssociatedEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: builtins.str,
                 anthos_clusters: Optional[Sequence['outputs.TargetAssociatedEntityAnthosCluster']] = None,
                 gke_clusters: Optional[Sequence['outputs.TargetAssociatedEntityGkeCluster']] = None):
        """
        :param builtins.str entity_id: The name for the key in the map for which this object is mapped to in the API
        :param Sequence['TargetAssociatedEntityAnthosClusterArgs'] anthos_clusters: Optional. Information specifying Anthos clusters as associated entities.
        :param Sequence['TargetAssociatedEntityGkeClusterArgs'] gke_clusters: Optional. Information specifying GKE clusters as associated entities.
        """
        pulumi.set(__self__, "entity_id", entity_id)
        if anthos_clusters is not None:
            pulumi.set(__self__, "anthos_clusters", anthos_clusters)
        if gke_clusters is not None:
            pulumi.set(__self__, "gke_clusters", gke_clusters)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> builtins.str:
        """
        The name for the key in the map for which this object is mapped to in the API
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="anthosClusters")
    def anthos_clusters(self) -> Optional[Sequence['outputs.TargetAssociatedEntityAnthosCluster']]:
        """
        Optional. Information specifying Anthos clusters as associated entities.
        """
        return pulumi.get(self, "anthos_clusters")

    @property
    @pulumi.getter(name="gkeClusters")
    def gke_clusters(self) -> Optional[Sequence['outputs.TargetAssociatedEntityGkeCluster']]:
        """
        Optional. Information specifying GKE clusters as associated entities.
        """
        return pulumi.get(self, "gke_clusters")


@pulumi.output_type
class TargetAssociatedEntityAnthosCluster(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class TargetAssociatedEntityGkeCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetAssociatedEntityGkeCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetAssociatedEntityGkeCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetAssociatedEntityGkeCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[builtins.str] = None,
                 internal_ip: Optional[builtins.bool] = None,
                 proxy_url: Optional[builtins.str] = None):
        """
        :param builtins.str cluster: Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        :param builtins.bool internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param builtins.str proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[builtins.str]:
        """
        Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[builtins.bool]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[builtins.str]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")


@pulumi.output_type
class TargetCustomTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTargetType":
            suggest = "custom_target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetCustomTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetCustomTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetCustomTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_target_type: builtins.str):
        """
        :param builtins.str custom_target_type: Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        pulumi.set(__self__, "custom_target_type", custom_target_type)

    @property
    @pulumi.getter(name="customTargetType")
    def custom_target_type(self) -> builtins.str:
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        return pulumi.get(self, "custom_target_type")


@pulumi.output_type
class TargetExecutionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorage":
            suggest = "artifact_storage"
        elif key == "executionTimeout":
            suggest = "execution_timeout"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "workerPool":
            suggest = "worker_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetExecutionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetExecutionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetExecutionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usages: Sequence[builtins.str],
                 artifact_storage: Optional[builtins.str] = None,
                 execution_timeout: Optional[builtins.str] = None,
                 service_account: Optional[builtins.str] = None,
                 verbose: Optional[builtins.bool] = None,
                 worker_pool: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] usages: Required. Usages when this configuration should be applied.
        :param builtins.str artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param builtins.str execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param builtins.str service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param builtins.bool verbose: Optional. If true, additional logging will be enabled when running builds in this execution environment.
        :param builtins.str worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "usages", usages)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if execution_timeout is not None:
            pulumi.set(__self__, "execution_timeout", execution_timeout)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)
        if worker_pool is not None:
            pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter
    def usages(self) -> Sequence[builtins.str]:
        """
        Required. Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[builtins.str]:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[builtins.str]:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[builtins.str]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[builtins.bool]:
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        return pulumi.get(self, "verbose")

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> Optional[builtins.str]:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")


@pulumi.output_type
class TargetGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsEndpoint":
            suggest = "dns_endpoint"
        elif key == "internalIp":
            suggest = "internal_ip"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[builtins.str] = None,
                 dns_endpoint: Optional[builtins.bool] = None,
                 internal_ip: Optional[builtins.bool] = None,
                 proxy_url: Optional[builtins.str] = None):
        """
        :param builtins.str cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        :param builtins.bool dns_endpoint: Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dns_endpoint` and `internal_ip` cannot be set to true.
        :param builtins.bool internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param builtins.str proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if dns_endpoint is not None:
            pulumi.set(__self__, "dns_endpoint", dns_endpoint)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[builtins.str]:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="dnsEndpoint")
    def dns_endpoint(self) -> Optional[builtins.bool]:
        """
        Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dns_endpoint` and `internal_ip` cannot be set to true.
        """
        return pulumi.get(self, "dns_endpoint")

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[builtins.bool]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[builtins.str]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")


@pulumi.output_type
class TargetIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TargetIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 title: builtins.str,
                 description: Optional[builtins.str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> builtins.str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TargetMultiTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetIds":
            suggest = "target_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetMultiTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetMultiTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetMultiTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_ids: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] target_ids: Required. The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[builtins.str]:
        """
        Required. The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")


@pulumi.output_type
class TargetRun(dict):
    def __init__(__self__, *,
                 location: builtins.str):
        """
        :param builtins.str location: Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")


