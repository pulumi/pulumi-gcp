# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutomationRule',
    'AutomationRuleAdvanceRolloutRule',
    'AutomationRulePromoteReleaseRule',
    'AutomationSelector',
    'AutomationSelectorTarget',
    'CustomTargetTypeCustomActions',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModule',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage',
    'CustomTargetTypeIamBindingCondition',
    'CustomTargetTypeIamMemberCondition',
    'DeliveryPipelineCondition',
    'DeliveryPipelineConditionPipelineReadyCondition',
    'DeliveryPipelineConditionTargetsPresentCondition',
    'DeliveryPipelineConditionTargetsTypeCondition',
    'DeliveryPipelineIamBindingCondition',
    'DeliveryPipelineIamMemberCondition',
    'DeliveryPipelineSerialPipeline',
    'DeliveryPipelineSerialPipelineStage',
    'DeliveryPipelineSerialPipelineStageDeployParameter',
    'DeliveryPipelineSerialPipelineStageStrategy',
    'DeliveryPipelineSerialPipelineStageStrategyCanary',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking',
    'DeliveryPipelineSerialPipelineStageStrategyStandard',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy',
    'TargetAnthosCluster',
    'TargetCustomTarget',
    'TargetExecutionConfig',
    'TargetGke',
    'TargetIamBindingCondition',
    'TargetIamMemberCondition',
    'TargetMultiTarget',
    'TargetRun',
]

@pulumi.output_type
class AutomationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceRolloutRule":
            suggest = "advance_rollout_rule"
        elif key == "promoteReleaseRule":
            suggest = "promote_release_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_rollout_rule: Optional['outputs.AutomationRuleAdvanceRolloutRule'] = None,
                 promote_release_rule: Optional['outputs.AutomationRulePromoteReleaseRule'] = None):
        """
        :param 'AutomationRuleAdvanceRolloutRuleArgs' advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
               Structure is documented below.
        :param 'AutomationRulePromoteReleaseRuleArgs' promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
               Structure is documented below.
        """
        if advance_rollout_rule is not None:
            pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        if promote_release_rule is not None:
            pulumi.set(__self__, "promote_release_rule", promote_release_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> Optional['outputs.AutomationRuleAdvanceRolloutRule']:
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> Optional['outputs.AutomationRulePromoteReleaseRule']:
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
        return pulumi.get(self, "promote_release_rule")


@pulumi.output_type
class AutomationRuleAdvanceRolloutRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePhases":
            suggest = "source_phases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleAdvanceRolloutRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleAdvanceRolloutRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleAdvanceRolloutRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 source_phases: Optional[Sequence[str]] = None,
                 wait: Optional[str] = None):
        """
        :param str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param Sequence[str] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
               
               - - -
        :param str wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "id", id)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[Sequence[str]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.

        - - -
        """
        return pulumi.get(self, "source_phases")

    @property
    @pulumi.getter
    def wait(self) -> Optional[str]:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AutomationRulePromoteReleaseRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPhase":
            suggest = "destination_phase"
        elif key == "destinationTargetId":
            suggest = "destination_target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePromoteReleaseRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePromoteReleaseRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePromoteReleaseRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 destination_phase: Optional[str] = None,
                 destination_target_id: Optional[str] = None,
                 wait: Optional[str] = None):
        """
        :param str id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param str destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param str destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param str wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "id", id)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[str]:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[str]:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @property
    @pulumi.getter
    def wait(self) -> Optional[str]:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AutomationSelector(dict):
    def __init__(__self__, *,
                 targets: Sequence['outputs.AutomationSelectorTarget']):
        """
        :param Sequence['AutomationSelectorTargetArgs'] targets: Contains attributes about a target.
               Structure is documented below.
        """
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.AutomationSelectorTarget']:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class AutomationSelectorTarget(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        :param str id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param Mapping[str, str] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class CustomTargetTypeCustomActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployAction":
            suggest = "deploy_action"
        elif key == "includeSkaffoldModules":
            suggest = "include_skaffold_modules"
        elif key == "renderAction":
            suggest = "render_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTargetTypeCustomActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTargetTypeCustomActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTargetTypeCustomActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_action: str,
                 include_skaffold_modules: Optional[Sequence['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModule']] = None,
                 render_action: Optional[str] = None):
        """
        :param str deploy_action: The Skaffold custom action responsible for deploy operations.
        :param Sequence['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs'] include_skaffold_modules: List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
               Structure is documented below.
        :param str render_action: The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        pulumi.set(__self__, "deploy_action", deploy_action)
        if include_skaffold_modules is not None:
            pulumi.set(__self__, "include_skaffold_modules", include_skaffold_modules)
        if render_action is not None:
            pulumi.set(__self__, "render_action", render_action)

    @property
    @pulumi.getter(name="deployAction")
    def deploy_action(self) -> str:
        """
        The Skaffold custom action responsible for deploy operations.
        """
        return pulumi.get(self, "deploy_action")

    @property
    @pulumi.getter(name="includeSkaffoldModules")
    def include_skaffold_modules(self) -> Optional[Sequence['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModule']]:
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        return pulumi.get(self, "include_skaffold_modules")

    @property
    @pulumi.getter(name="renderAction")
    def render_action(self) -> Optional[str]:
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        return pulumi.get(self, "render_action")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "googleCloudBuildRepo":
            suggest = "google_cloud_build_repo"
        elif key == "googleCloudStorage":
            suggest = "google_cloud_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTargetTypeCustomActionsIncludeSkaffoldModule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTargetTypeCustomActionsIncludeSkaffoldModule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTargetTypeCustomActionsIncludeSkaffoldModule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configs: Optional[Sequence[str]] = None,
                 git: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit'] = None,
                 google_cloud_build_repo: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo'] = None,
                 google_cloud_storage: Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage'] = None):
        """
        :param Sequence[str] configs: The Skaffold Config modules to use from the specified source.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs' git: Remote git repository containing the Skaffold Config modules.
               Structure is documented below.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs' google_cloud_build_repo: Cloud Build 2nd gen repository containing the Skaffold Config modules.
               Structure is documented below.
        :param 'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs' google_cloud_storage: Cloud Storage bucket containing Skaffold Config modules.
               Structure is documented below.
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if google_cloud_build_repo is not None:
            pulumi.set(__self__, "google_cloud_build_repo", google_cloud_build_repo)
        if google_cloud_storage is not None:
            pulumi.set(__self__, "google_cloud_storage", google_cloud_storage)

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence[str]]:
        """
        The Skaffold Config modules to use from the specified source.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def git(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit']:
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "git")

    @property
    @pulumi.getter(name="googleCloudBuildRepo")
    def google_cloud_build_repo(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo']:
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_build_repo")

    @property
    @pulumi.getter(name="googleCloudStorage")
    def google_cloud_storage(self) -> Optional['outputs.CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage']:
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_storage")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGit(dict):
    def __init__(__self__, *,
                 repo: str,
                 path: Optional[str] = None,
                 ref: Optional[str] = None):
        """
        :param str repo: Git repository the package should be cloned from.
        :param str path: Relative path from the repository root to the Skaffold file.
        :param str ref: Git ref the package should be cloned from.
        """
        pulumi.set(__self__, "repo", repo)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repo(self) -> str:
        """
        Git repository the package should be cloned from.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        Git ref the package should be cloned from.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepo(dict):
    def __init__(__self__, *,
                 repository: str,
                 path: Optional[str] = None,
                 ref: Optional[str] = None):
        """
        :param str repository: Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        :param str path: Relative path from the repository root to the Skaffold file.
        :param str ref: Branch or tag to use when cloning the repository.
        """
        pulumi.set(__self__, "repository", repository)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        Branch or tag to use when cloning the repository.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorage(dict):
    def __init__(__self__, *,
                 source: str,
                 path: Optional[str] = None):
        """
        :param str source: Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        :param str path: Relative path from the source to the Skaffold file.
        """
        pulumi.set(__self__, "source", source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Relative path from the source to the Skaffold file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class CustomTargetTypeIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class CustomTargetTypeIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineReadyConditions":
            suggest = "pipeline_ready_conditions"
        elif key == "targetsPresentConditions":
            suggest = "targets_present_conditions"
        elif key == "targetsTypeConditions":
            suggest = "targets_type_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_ready_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionPipelineReadyCondition']] = None,
                 targets_present_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionTargetsPresentCondition']] = None,
                 targets_type_conditions: Optional[Sequence['outputs.DeliveryPipelineConditionTargetsTypeCondition']] = None):
        """
        :param Sequence['DeliveryPipelineConditionPipelineReadyConditionArgs'] pipeline_ready_conditions: Details around the Pipeline's overall status.
        :param Sequence['DeliveryPipelineConditionTargetsPresentConditionArgs'] targets_present_conditions: Details around targets enumerated in the pipeline.
        :param Sequence['DeliveryPipelineConditionTargetsTypeConditionArgs'] targets_type_conditions: Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        if pipeline_ready_conditions is not None:
            pulumi.set(__self__, "pipeline_ready_conditions", pipeline_ready_conditions)
        if targets_present_conditions is not None:
            pulumi.set(__self__, "targets_present_conditions", targets_present_conditions)
        if targets_type_conditions is not None:
            pulumi.set(__self__, "targets_type_conditions", targets_type_conditions)

    @property
    @pulumi.getter(name="pipelineReadyConditions")
    def pipeline_ready_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionPipelineReadyCondition']]:
        """
        Details around the Pipeline's overall status.
        """
        return pulumi.get(self, "pipeline_ready_conditions")

    @property
    @pulumi.getter(name="targetsPresentConditions")
    def targets_present_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionTargetsPresentCondition']]:
        """
        Details around targets enumerated in the pipeline.
        """
        return pulumi.get(self, "targets_present_conditions")

    @property
    @pulumi.getter(name="targetsTypeConditions")
    def targets_type_conditions(self) -> Optional[Sequence['outputs.DeliveryPipelineConditionTargetsTypeCondition']]:
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        return pulumi.get(self, "targets_type_conditions")


@pulumi.output_type
class DeliveryPipelineConditionPipelineReadyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionPipelineReadyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionPipelineReadyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionPipelineReadyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[bool] = None,
                 update_time: Optional[str] = None):
        """
        :param bool status: True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        :param str update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def status(self) -> Optional[bool]:
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[str]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DeliveryPipelineConditionTargetsPresentCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingTargets":
            suggest = "missing_targets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionTargetsPresentCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionTargetsPresentCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionTargetsPresentCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_targets: Optional[Sequence[str]] = None,
                 status: Optional[bool] = None,
                 update_time: Optional[str] = None):
        """
        :param Sequence[str] missing_targets: The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        :param bool status: True if there aren't any missing Targets.
        :param str update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if missing_targets is not None:
            pulumi.set(__self__, "missing_targets", missing_targets)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="missingTargets")
    def missing_targets(self) -> Optional[Sequence[str]]:
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        return pulumi.get(self, "missing_targets")

    @property
    @pulumi.getter
    def status(self) -> Optional[bool]:
        """
        True if there aren't any missing Targets.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[str]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DeliveryPipelineConditionTargetsTypeCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineConditionTargetsTypeCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineConditionTargetsTypeCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineConditionTargetsTypeCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_details: Optional[str] = None,
                 status: Optional[bool] = None):
        """
        :param str error_details: Human readable error message.
        :param bool status: True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[str]:
        """
        Human readable error message.
        """
        return pulumi.get(self, "error_details")

    @property
    @pulumi.getter
    def status(self) -> Optional[bool]:
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DeliveryPipelineIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class DeliveryPipelineSerialPipeline(dict):
    def __init__(__self__, *,
                 stages: Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStage']] = None):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageArgs'] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStage']]:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployParameters":
            suggest = "deploy_parameters"
        elif key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_parameters: Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStageDeployParameter']] = None,
                 profiles: Optional[Sequence[str]] = None,
                 strategy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategy'] = None,
                 target_id: Optional[str] = None):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageDeployParameterArgs'] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param Sequence[str] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param 'DeliveryPipelineSerialPipelineStageStrategyArgs' strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param str target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        if deploy_parameters is not None:
            pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Optional[Sequence['outputs.DeliveryPipelineSerialPipelineStageDeployParameter']]:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[str]]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def strategy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategy']:
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[str]:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageDeployParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchTargetLabels":
            suggest = "match_target_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageDeployParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageDeployParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageDeployParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Mapping[str, str],
                 match_target_labels: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] values: Required. Values are deploy parameters in key-value pairs.
        :param Mapping[str, str] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        pulumi.set(__self__, "values", values)
        if match_target_labels is not None:
            pulumi.set(__self__, "match_target_labels", match_target_labels)

    @property
    @pulumi.getter
    def values(self) -> Mapping[str, str]:
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Optional[Mapping[str, str]]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategy(dict):
    def __init__(__self__, *,
                 canary: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanary'] = None,
                 standard: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandard'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryArgs' canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardArgs' standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        if canary is not None:
            pulumi.set(__self__, "canary", canary)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanary']:
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @property
    @pulumi.getter
    def standard(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandard']:
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canaryDeployment":
            suggest = "canary_deployment"
        elif key == "customCanaryDeployment":
            suggest = "custom_canary_deployment"
        elif key == "runtimeConfig":
            suggest = "runtime_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canary_deployment: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment'] = None,
                 custom_canary_deployment: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment'] = None,
                 runtime_config: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs' canary_deployment: Configures the progressive based deployment for a Target.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs' custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs' runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        if canary_deployment is not None:
            pulumi.set(__self__, "canary_deployment", canary_deployment)
        if custom_canary_deployment is not None:
            pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment']:
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment']:
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig']:
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeployment(dict):
    def __init__(__self__, *,
                 percentages: Sequence[int],
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy'] = None,
                 verify: Optional[bool] = None):
        """
        :param Sequence[int] percentages: Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs' predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        :param bool verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> Sequence[int]:
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy']:
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy']:
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> Optional[bool]:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseConfigs":
            suggest = "phase_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phase_configs: Sequence['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig']):
        """
        :param Sequence['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs'] phase_configs: Required. Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> Sequence['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig']:
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseId":
            suggest = "phase_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: int,
                 phase_id: str,
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy'] = None,
                 profiles: Optional[Sequence[str]] = None,
                 verify: Optional[bool] = None):
        """
        :param int percentage: Required. Percentage deployment for the phase.
        :param str phase_id: Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs' predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        :param Sequence[str] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param bool verify: Whether to run verify tests after the deployment.
               
               - - -
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        """
        Required. Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> str:
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "phase_id")

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy']:
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy']:
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[str]]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def verify(self) -> Optional[bool]:
        """
        Whether to run verify tests after the deployment.

        - - -
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRun":
            suggest = "cloud_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_run: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun'] = None,
                 kubernetes: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs' cloud_run: Cloud Run runtime configuration.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs' kubernetes: Kubernetes runtime configuration.
        """
        if cloud_run is not None:
            pulumi.set(__self__, "cloud_run", cloud_run)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun']:
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes']:
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticTrafficControl":
            suggest = "automatic_traffic_control"
        elif key == "canaryRevisionTags":
            suggest = "canary_revision_tags"
        elif key == "priorRevisionTags":
            suggest = "prior_revision_tags"
        elif key == "stableRevisionTags":
            suggest = "stable_revision_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRun.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_traffic_control: Optional[bool] = None,
                 canary_revision_tags: Optional[Sequence[str]] = None,
                 prior_revision_tags: Optional[Sequence[str]] = None,
                 stable_revision_tags: Optional[Sequence[str]] = None):
        """
        :param bool automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        :param Sequence[str] canary_revision_tags: Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        :param Sequence[str] prior_revision_tags: Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        :param Sequence[str] stable_revision_tags: Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        if automatic_traffic_control is not None:
            pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)
        if canary_revision_tags is not None:
            pulumi.set(__self__, "canary_revision_tags", canary_revision_tags)
        if prior_revision_tags is not None:
            pulumi.set(__self__, "prior_revision_tags", prior_revision_tags)
        if stable_revision_tags is not None:
            pulumi.set(__self__, "stable_revision_tags", stable_revision_tags)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> Optional[bool]:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")

    @property
    @pulumi.getter(name="canaryRevisionTags")
    def canary_revision_tags(self) -> Optional[Sequence[str]]:
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        return pulumi.get(self, "canary_revision_tags")

    @property
    @pulumi.getter(name="priorRevisionTags")
    def prior_revision_tags(self) -> Optional[Sequence[str]]:
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        return pulumi.get(self, "prior_revision_tags")

    @property
    @pulumi.getter(name="stableRevisionTags")
    def stable_revision_tags(self) -> Optional[Sequence[str]]:
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        return pulumi.get(self, "stable_revision_tags")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayServiceMesh":
            suggest = "gateway_service_mesh"
        elif key == "serviceNetworking":
            suggest = "service_networking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_service_mesh: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh'] = None,
                 service_networking: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking'] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs' gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param 'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs' service_networking: Kubernetes Service networking configuration.
        """
        if gateway_service_mesh is not None:
            pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        if service_networking is not None:
            pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh']:
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking']:
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpRoute":
            suggest = "http_route"
        elif key == "podSelectorLabel":
            suggest = "pod_selector_label"
        elif key == "routeUpdateWaitTime":
            suggest = "route_update_wait_time"
        elif key == "stableCutbackDuration":
            suggest = "stable_cutback_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMesh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: str,
                 http_route: str,
                 service: str,
                 pod_selector_label: Optional[str] = None,
                 route_update_wait_time: Optional[str] = None,
                 stable_cutback_duration: Optional[str] = None):
        """
        :param str deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param str http_route: Required. Name of the Gateway API HTTPRoute.
        :param str service: Required. Name of the Kubernetes Service.
        :param str pod_selector_label: Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        :param str route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        :param str stable_cutback_duration: Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "service", service)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)
        if route_update_wait_time is not None:
            pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)
        if stable_cutback_duration is not None:
            pulumi.set(__self__, "stable_cutback_duration", stable_cutback_duration)

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> str:
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[str]:
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        return pulumi.get(self, "pod_selector_label")

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> Optional[str]:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @property
    @pulumi.getter(name="stableCutbackDuration")
    def stable_cutback_duration(self) -> Optional[str]:
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        return pulumi.get(self, "stable_cutback_duration")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePodOverprovisioning":
            suggest = "disable_pod_overprovisioning"
        elif key == "podSelectorLabel":
            suggest = "pod_selector_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: str,
                 service: str,
                 disable_pod_overprovisioning: Optional[bool] = None,
                 pod_selector_label: Optional[str] = None):
        """
        :param str deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param str service: Required. Name of the Kubernetes Service.
        :param bool disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        :param str pod_selector_label: Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "service", service)
        if disable_pod_overprovisioning is not None:
            pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> Optional[bool]:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[str]:
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        return pulumi.get(self, "pod_selector_label")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandard(dict):
    def __init__(__self__, *,
                 postdeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy'] = None,
                 predeploy: Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy'] = None,
                 verify: Optional[bool] = None):
        """
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs' postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param 'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs' predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param bool verify: Whether to verify a deployment.
        """
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy']:
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> Optional['outputs.DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy']:
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> Optional[bool]:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPredeploy(dict):
    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class TargetAnthosCluster(dict):
    def __init__(__self__, *,
                 membership: Optional[str] = None):
        """
        :param str membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[str]:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class TargetCustomTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTargetType":
            suggest = "custom_target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetCustomTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetCustomTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetCustomTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_target_type: str):
        """
        :param str custom_target_type: Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        pulumi.set(__self__, "custom_target_type", custom_target_type)

    @property
    @pulumi.getter(name="customTargetType")
    def custom_target_type(self) -> str:
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        return pulumi.get(self, "custom_target_type")


@pulumi.output_type
class TargetExecutionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorage":
            suggest = "artifact_storage"
        elif key == "executionTimeout":
            suggest = "execution_timeout"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "workerPool":
            suggest = "worker_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetExecutionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetExecutionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetExecutionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usages: Sequence[str],
                 artifact_storage: Optional[str] = None,
                 execution_timeout: Optional[str] = None,
                 service_account: Optional[str] = None,
                 verbose: Optional[bool] = None,
                 worker_pool: Optional[str] = None):
        """
        :param Sequence[str] usages: Required. Usages when this configuration should be applied.
        :param str artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param str execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param str service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param bool verbose: Optional. If true, additional logging will be enabled when running builds in this execution environment.
        :param str worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "usages", usages)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if execution_timeout is not None:
            pulumi.set(__self__, "execution_timeout", execution_timeout)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)
        if worker_pool is not None:
            pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter
    def usages(self) -> Sequence[str]:
        """
        Required. Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[str]:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[str]:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[bool]:
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        return pulumi.get(self, "verbose")

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> Optional[str]:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")


@pulumi.output_type
class TargetGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[str] = None,
                 internal_ip: Optional[bool] = None,
                 proxy_url: Optional[str] = None):
        """
        :param str cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        :param bool internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param str proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[bool]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")


@pulumi.output_type
class TargetIamBindingCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TargetIamMemberCondition(dict):
    def __init__(__self__, *,
                 expression: str,
                 title: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class TargetMultiTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetIds":
            suggest = "target_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetMultiTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetMultiTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetMultiTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_ids: Sequence[str]):
        """
        :param Sequence[str] target_ids: Required. The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        Required. The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")


@pulumi.output_type
class TargetRun(dict):
    def __init__(__self__, *,
                 location: str):
        """
        :param str location: Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")


