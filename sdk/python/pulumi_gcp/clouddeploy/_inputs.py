# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AutomationRuleArgs',
    'AutomationRuleArgsDict',
    'AutomationRuleAdvanceRolloutRuleArgs',
    'AutomationRuleAdvanceRolloutRuleArgsDict',
    'AutomationRulePromoteReleaseRuleArgs',
    'AutomationRulePromoteReleaseRuleArgsDict',
    'AutomationRuleRepairRolloutRuleArgs',
    'AutomationRuleRepairRolloutRuleArgsDict',
    'AutomationRuleRepairRolloutRuleRepairPhaseArgs',
    'AutomationRuleRepairRolloutRuleRepairPhaseArgsDict',
    'AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs',
    'AutomationRuleRepairRolloutRuleRepairPhaseRetryArgsDict',
    'AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs',
    'AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgsDict',
    'AutomationRuleTimedPromoteReleaseRuleArgs',
    'AutomationRuleTimedPromoteReleaseRuleArgsDict',
    'AutomationSelectorArgs',
    'AutomationSelectorArgsDict',
    'AutomationSelectorTargetArgs',
    'AutomationSelectorTargetArgsDict',
    'CustomTargetTypeCustomActionsArgs',
    'CustomTargetTypeCustomActionsArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict',
    'CustomTargetTypeIamBindingConditionArgs',
    'CustomTargetTypeIamBindingConditionArgsDict',
    'CustomTargetTypeIamMemberConditionArgs',
    'CustomTargetTypeIamMemberConditionArgsDict',
    'DeliveryPipelineConditionArgs',
    'DeliveryPipelineConditionArgsDict',
    'DeliveryPipelineConditionPipelineReadyConditionArgs',
    'DeliveryPipelineConditionPipelineReadyConditionArgsDict',
    'DeliveryPipelineConditionTargetsPresentConditionArgs',
    'DeliveryPipelineConditionTargetsPresentConditionArgsDict',
    'DeliveryPipelineConditionTargetsTypeConditionArgs',
    'DeliveryPipelineConditionTargetsTypeConditionArgsDict',
    'DeliveryPipelineIamBindingConditionArgs',
    'DeliveryPipelineIamBindingConditionArgsDict',
    'DeliveryPipelineIamMemberConditionArgs',
    'DeliveryPipelineIamMemberConditionArgsDict',
    'DeliveryPipelineSerialPipelineArgs',
    'DeliveryPipelineSerialPipelineArgsDict',
    'DeliveryPipelineSerialPipelineStageArgs',
    'DeliveryPipelineSerialPipelineStageArgsDict',
    'DeliveryPipelineSerialPipelineStageDeployParameterArgs',
    'DeliveryPipelineSerialPipelineStageDeployParameterArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyArgs',
    'DeliveryPipelineSerialPipelineStageStrategyArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict',
    'DeployPolicyRuleArgs',
    'DeployPolicyRuleArgsDict',
    'DeployPolicyRuleRolloutRestrictionArgs',
    'DeployPolicyRuleRolloutRestrictionArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgsDict',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs',
    'DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgsDict',
    'DeployPolicySelectorArgs',
    'DeployPolicySelectorArgsDict',
    'DeployPolicySelectorDeliveryPipelineArgs',
    'DeployPolicySelectorDeliveryPipelineArgsDict',
    'DeployPolicySelectorTargetArgs',
    'DeployPolicySelectorTargetArgsDict',
    'TargetAnthosClusterArgs',
    'TargetAnthosClusterArgsDict',
    'TargetAssociatedEntityArgs',
    'TargetAssociatedEntityArgsDict',
    'TargetAssociatedEntityAnthosClusterArgs',
    'TargetAssociatedEntityAnthosClusterArgsDict',
    'TargetAssociatedEntityGkeClusterArgs',
    'TargetAssociatedEntityGkeClusterArgsDict',
    'TargetCustomTargetArgs',
    'TargetCustomTargetArgsDict',
    'TargetExecutionConfigArgs',
    'TargetExecutionConfigArgsDict',
    'TargetGkeArgs',
    'TargetGkeArgsDict',
    'TargetIamBindingConditionArgs',
    'TargetIamBindingConditionArgsDict',
    'TargetIamMemberConditionArgs',
    'TargetIamMemberConditionArgsDict',
    'TargetMultiTargetArgs',
    'TargetMultiTargetArgsDict',
    'TargetRunArgs',
    'TargetRunArgsDict',
]

MYPY = False

if not MYPY:
    class AutomationRuleArgsDict(TypedDict):
        advance_rollout_rule: NotRequired[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgsDict']]
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        promote_release_rule: NotRequired[pulumi.Input['AutomationRulePromoteReleaseRuleArgsDict']]
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
        repair_rollout_rule: NotRequired[pulumi.Input['AutomationRuleRepairRolloutRuleArgsDict']]
        """
        Optional. The RepairRolloutRule will automatically repair a failed rollout.
        Structure is documented below.
        """
        timed_promote_release_rule: NotRequired[pulumi.Input['AutomationRuleTimedPromoteReleaseRuleArgsDict']]
        """
        Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
        Structure is documented below.
        """
elif False:
    AutomationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleArgs:
    def __init__(__self__, *,
                 advance_rollout_rule: Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']] = None,
                 promote_release_rule: Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']] = None,
                 repair_rollout_rule: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleArgs']] = None,
                 timed_promote_release_rule: Optional[pulumi.Input['AutomationRuleTimedPromoteReleaseRuleArgs']] = None):
        """
        :param pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs'] advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
               Structure is documented below.
        :param pulumi.Input['AutomationRulePromoteReleaseRuleArgs'] promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
               Structure is documented below.
        :param pulumi.Input['AutomationRuleRepairRolloutRuleArgs'] repair_rollout_rule: Optional. The RepairRolloutRule will automatically repair a failed rollout.
               Structure is documented below.
        :param pulumi.Input['AutomationRuleTimedPromoteReleaseRuleArgs'] timed_promote_release_rule: Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
               Structure is documented below.
        """
        if advance_rollout_rule is not None:
            pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        if promote_release_rule is not None:
            pulumi.set(__self__, "promote_release_rule", promote_release_rule)
        if repair_rollout_rule is not None:
            pulumi.set(__self__, "repair_rollout_rule", repair_rollout_rule)
        if timed_promote_release_rule is not None:
            pulumi.set(__self__, "timed_promote_release_rule", timed_promote_release_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']]:
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @advance_rollout_rule.setter
    def advance_rollout_rule(self, value: Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']]):
        pulumi.set(self, "advance_rollout_rule", value)

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']]:
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
        return pulumi.get(self, "promote_release_rule")

    @promote_release_rule.setter
    def promote_release_rule(self, value: Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']]):
        pulumi.set(self, "promote_release_rule", value)

    @property
    @pulumi.getter(name="repairRolloutRule")
    def repair_rollout_rule(self) -> Optional[pulumi.Input['AutomationRuleRepairRolloutRuleArgs']]:
        """
        Optional. The RepairRolloutRule will automatically repair a failed rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "repair_rollout_rule")

    @repair_rollout_rule.setter
    def repair_rollout_rule(self, value: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleArgs']]):
        pulumi.set(self, "repair_rollout_rule", value)

    @property
    @pulumi.getter(name="timedPromoteReleaseRule")
    def timed_promote_release_rule(self) -> Optional[pulumi.Input['AutomationRuleTimedPromoteReleaseRuleArgs']]:
        """
        Optional. The `TimedPromoteReleaseRule` will automatically promote a release from the current target(s) to the specified target(s) on a configured schedule.
        Structure is documented below.
        """
        return pulumi.get(self, "timed_promote_release_rule")

    @timed_promote_release_rule.setter
    def timed_promote_release_rule(self, value: Optional[pulumi.Input['AutomationRuleTimedPromoteReleaseRuleArgs']]):
        pulumi.set(self, "timed_promote_release_rule", value)


if not MYPY:
    class AutomationRuleAdvanceRolloutRuleArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        source_phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        wait: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. How long to wait after a rollout is finished.
        """
elif False:
    AutomationRuleAdvanceRolloutRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleAdvanceRolloutRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 source_phases: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wait: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param pulumi.Input[builtins.str] wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "id", id)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "source_phases")

    @source_phases.setter
    def source_phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "source_phases", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wait", value)


if not MYPY:
    class AutomationRulePromoteReleaseRuleArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        destination_phase: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        destination_target_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        wait: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
elif False:
    AutomationRulePromoteReleaseRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePromoteReleaseRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 destination_phase: Optional[pulumi.Input[builtins.str]] = None,
                 destination_target_id: Optional[pulumi.Input[builtins.str]] = None,
                 wait: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[builtins.str] destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param pulumi.Input[builtins.str] destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param pulumi.Input[builtins.str] wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "id", id)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_phase", value)

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @destination_target_id.setter
    def destination_target_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_target_id", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wait", value)


if not MYPY:
    class AutomationRuleRepairRolloutRuleArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        repair_phases: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseArgsDict']]]]
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        Structure is documented below.
        """
elif False:
    AutomationRuleRepairRolloutRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRepairRolloutRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 repair_phases: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] jobs: Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] phases: Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        :param pulumi.Input[Sequence[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseArgs']]] repair_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
               Structure is documented below.
        """
        pulumi.set(__self__, "id", id)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if repair_phases is not None:
            pulumi.set(__self__, "repair_phases", repair_phases)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in sourcePhase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: ^a-z?$.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "phases", value)

    @property
    @pulumi.getter(name="repairPhases")
    def repair_phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseArgs']]]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        Structure is documented below.
        """
        return pulumi.get(self, "repair_phases")

    @repair_phases.setter
    def repair_phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseArgs']]]]):
        pulumi.set(self, "repair_phases", value)


if not MYPY:
    class AutomationRuleRepairRolloutRuleRepairPhaseArgsDict(TypedDict):
        retry: NotRequired[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRetryArgsDict']]
        """
        Optional. Retries a failed job.
        Structure is documented below.
        """
        rollback: NotRequired[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgsDict']]
        """
        Optional. Rolls back a Rollout.
        Structure is documented below.
        """
elif False:
    AutomationRuleRepairRolloutRuleRepairPhaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRepairRolloutRuleRepairPhaseArgs:
    def __init__(__self__, *,
                 retry: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs']] = None,
                 rollback: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs']] = None):
        """
        :param pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs'] retry: Optional. Retries a failed job.
               Structure is documented below.
        :param pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs'] rollback: Optional. Rolls back a Rollout.
               Structure is documented below.
        """
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs']]:
        """
        Optional. Retries a failed job.
        Structure is documented below.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs']]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def rollback(self) -> Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs']]:
        """
        Optional. Rolls back a Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "rollback")

    @rollback.setter
    def rollback(self, value: Optional[pulumi.Input['AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs']]):
        pulumi.set(self, "rollback", value)


if not MYPY:
    class AutomationRuleRepairRolloutRuleRepairPhaseRetryArgsDict(TypedDict):
        attempts: pulumi.Input[builtins.str]
        """
        Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        """
        backoff_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
        Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
        """
        wait: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
        """
elif False:
    AutomationRuleRepairRolloutRuleRepairPhaseRetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRepairRolloutRuleRepairPhaseRetryArgs:
    def __init__(__self__, *,
                 attempts: pulumi.Input[builtins.str],
                 backoff_mode: Optional[pulumi.Input[builtins.str]] = None,
                 wait: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] attempts: Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        :param pulumi.Input[builtins.str] backoff_mode: Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
               Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
        :param pulumi.Input[builtins.str] wait: Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
        """
        pulumi.set(__self__, "attempts", attempts)
        if backoff_mode is not None:
            pulumi.set(__self__, "backoff_mode", backoff_mode)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def attempts(self) -> pulumi.Input[builtins.str]:
        """
        Required. Total number of retries. Retry is skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        """
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "attempts", value)

    @property
    @pulumi.getter(name="backoffMode")
    def backoff_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if wait is 0.
        Possible values are: `BACKOFF_MODE_UNSPECIFIED`, `BACKOFF_MODE_LINEAR`, `BACKOFF_MODE_EXPONENTIAL`.
        """
        return pulumi.get(self, "backoff_mode")

    @backoff_mode.setter
    def backoff_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backoff_mode", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d. A duration in seconds with up to nine fractional digits, ending with 's'. Example: `3.5s`.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wait", value)


if not MYPY:
    class AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgsDict(TypedDict):
        destination_phase: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
        """
        disable_rollback_if_rollout_pending: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. If pending rollout exists on the target, the rollback operation will be aborted.
        """
elif False:
    AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRepairRolloutRuleRepairPhaseRollbackArgs:
    def __init__(__self__, *,
                 destination_phase: Optional[pulumi.Input[builtins.str]] = None,
                 disable_rollback_if_rollout_pending: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] destination_phase: Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
        :param pulumi.Input[builtins.bool] disable_rollback_if_rollout_pending: Optional. If pending rollout exists on the target, the rollback operation will be aborted.
        """
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if disable_rollback_if_rollout_pending is not None:
            pulumi.set(__self__, "disable_rollback_if_rollout_pending", disable_rollback_if_rollout_pending)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The starting phase ID for the Rollout. If unspecified, the Rollout will start in the stable phase.
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_phase", value)

    @property
    @pulumi.getter(name="disableRollbackIfRolloutPending")
    def disable_rollback_if_rollout_pending(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. If pending rollout exists on the target, the rollback operation will be aborted.
        """
        return pulumi.get(self, "disable_rollback_if_rollout_pending")

    @disable_rollback_if_rollout_pending.setter
    def disable_rollback_if_rollout_pending(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_rollback_if_rollout_pending", value)


if not MYPY:
    class AutomationRuleTimedPromoteReleaseRuleArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        schedule: pulumi.Input[builtins.str]
        """
        Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
        """
        time_zone: pulumi.Input[builtins.str]
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        destination_phase: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The starting phase of the rollout created by this rule. Default to the first phase.

        - - -
        """
        destination_target_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
        - The last segment of a target name
        - "@next", the next target in the promotion sequence"
        """
elif False:
    AutomationRuleTimedPromoteReleaseRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleTimedPromoteReleaseRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 schedule: pulumi.Input[builtins.str],
                 time_zone: pulumi.Input[builtins.str],
                 destination_phase: Optional[pulumi.Input[builtins.str]] = None,
                 destination_target_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[builtins.str] schedule: Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
        :param pulumi.Input[builtins.str] time_zone: Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        :param pulumi.Input[builtins.str] destination_phase: Optional. The starting phase of the rollout created by this rule. Default to the first phase.
               
               - - -
        :param pulumi.Input[builtins.str] destination_target_id: Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
               - The last segment of a target name
               - "@next", the next target in the promotion sequence"
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "time_zone", time_zone)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[builtins.str]:
        """
        Required. Schedule in crontab format. e.g. `0 9 * * 1` for every Monday at 9am.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[builtins.str]:
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The starting phase of the rollout created by this rule. Default to the first phase.

        - - -
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_phase", value)

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The ID of the stage in the pipeline to which this Release is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following:
        - The last segment of a target name
        - "@next", the next target in the promotion sequence"
        """
        return pulumi.get(self, "destination_target_id")

    @destination_target_id.setter
    def destination_target_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_target_id", value)


if not MYPY:
    class AutomationSelectorArgsDict(TypedDict):
        targets: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgsDict']]]
        """
        Contains attributes about a target.
        Structure is documented below.
        """
elif False:
    AutomationSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationSelectorArgs:
    def __init__(__self__, *,
                 targets: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]] targets: Contains attributes about a target.
               Structure is documented below.
        """
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class AutomationSelectorTargetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Target labels.
        """
elif False:
    AutomationSelectorTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationSelectorTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class CustomTargetTypeCustomActionsArgsDict(TypedDict):
        deploy_action: pulumi.Input[builtins.str]
        """
        The Skaffold custom action responsible for deploy operations.
        """
        include_skaffold_modules: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict']]]]
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        render_action: NotRequired[pulumi.Input[builtins.str]]
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
elif False:
    CustomTargetTypeCustomActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsArgs:
    def __init__(__self__, *,
                 deploy_action: pulumi.Input[builtins.str],
                 include_skaffold_modules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]] = None,
                 render_action: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] deploy_action: The Skaffold custom action responsible for deploy operations.
        :param pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]] include_skaffold_modules: List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
               Structure is documented below.
        :param pulumi.Input[builtins.str] render_action: The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        pulumi.set(__self__, "deploy_action", deploy_action)
        if include_skaffold_modules is not None:
            pulumi.set(__self__, "include_skaffold_modules", include_skaffold_modules)
        if render_action is not None:
            pulumi.set(__self__, "render_action", render_action)

    @property
    @pulumi.getter(name="deployAction")
    def deploy_action(self) -> pulumi.Input[builtins.str]:
        """
        The Skaffold custom action responsible for deploy operations.
        """
        return pulumi.get(self, "deploy_action")

    @deploy_action.setter
    def deploy_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "deploy_action", value)

    @property
    @pulumi.getter(name="includeSkaffoldModules")
    def include_skaffold_modules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]]:
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        return pulumi.get(self, "include_skaffold_modules")

    @include_skaffold_modules.setter
    def include_skaffold_modules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]]):
        pulumi.set(self, "include_skaffold_modules", value)

    @property
    @pulumi.getter(name="renderAction")
    def render_action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        return pulumi.get(self, "render_action")

    @render_action.setter
    def render_action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "render_action", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The Skaffold Config modules to use from the specified source.
        """
        git: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict']]
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        google_cloud_build_repo: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict']]
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        google_cloud_storage: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict']]
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 git: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']] = None,
                 google_cloud_build_repo: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']] = None,
                 google_cloud_storage: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] configs: The Skaffold Config modules to use from the specified source.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs'] git: Remote git repository containing the Skaffold Config modules.
               Structure is documented below.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs'] google_cloud_build_repo: Cloud Build 2nd gen repository containing the Skaffold Config modules.
               Structure is documented below.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs'] google_cloud_storage: Cloud Storage bucket containing Skaffold Config modules.
               Structure is documented below.
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if google_cloud_build_repo is not None:
            pulumi.set(__self__, "google_cloud_build_repo", google_cloud_build_repo)
        if google_cloud_storage is not None:
            pulumi.set(__self__, "google_cloud_storage", google_cloud_storage)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The Skaffold Config modules to use from the specified source.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']]:
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter(name="googleCloudBuildRepo")
    def google_cloud_build_repo(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']]:
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_build_repo")

    @google_cloud_build_repo.setter
    def google_cloud_build_repo(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']]):
        pulumi.set(self, "google_cloud_build_repo", value)

    @property
    @pulumi.getter(name="googleCloudStorage")
    def google_cloud_storage(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']]:
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_storage")

    @google_cloud_storage.setter
    def google_cloud_storage(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']]):
        pulumi.set(self, "google_cloud_storage", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict(TypedDict):
        repo: pulumi.Input[builtins.str]
        """
        Git repository the package should be cloned from.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Relative path from the repository root to the Skaffold file.
        """
        ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Git ref the package should be cloned from.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs:
    def __init__(__self__, *,
                 repo: pulumi.Input[builtins.str],
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repo: Git repository the package should be cloned from.
        :param pulumi.Input[builtins.str] path: Relative path from the repository root to the Skaffold file.
        :param pulumi.Input[builtins.str] ref: Git ref the package should be cloned from.
        """
        pulumi.set(__self__, "repo", repo)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repo(self) -> pulumi.Input[builtins.str]:
        """
        Git repository the package should be cloned from.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Git ref the package should be cloned from.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict(TypedDict):
        repository: pulumi.Input[builtins.str]
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Relative path from the repository root to the Skaffold file.
        """
        ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Branch or tag to use when cloning the repository.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[builtins.str],
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repository: Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        :param pulumi.Input[builtins.str] path: Relative path from the repository root to the Skaffold file.
        :param pulumi.Input[builtins.str] ref: Branch or tag to use when cloning the repository.
        """
        pulumi.set(__self__, "repository", repository)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[builtins.str]:
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Branch or tag to use when cloning the repository.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict(TypedDict):
        source: pulumi.Input[builtins.str]
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Relative path from the source to the Skaffold file.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[builtins.str],
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] source: Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        :param pulumi.Input[builtins.str] path: Relative path from the source to the Skaffold file.
        """
        pulumi.set(__self__, "source", source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[builtins.str]:
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Relative path from the source to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class CustomTargetTypeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CustomTargetTypeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class CustomTargetTypeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CustomTargetTypeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineConditionArgsDict(TypedDict):
        pipeline_ready_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgsDict']]]]
        """
        Details around the Pipeline's overall status.
        """
        targets_present_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgsDict']]]]
        """
        Details around targets enumerated in the pipeline.
        """
        targets_type_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgsDict']]]]
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
elif False:
    DeliveryPipelineConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionArgs:
    def __init__(__self__, *,
                 pipeline_ready_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]] = None,
                 targets_present_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]] = None,
                 targets_type_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]] pipeline_ready_conditions: Details around the Pipeline's overall status.
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]] targets_present_conditions: Details around targets enumerated in the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]] targets_type_conditions: Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        if pipeline_ready_conditions is not None:
            pulumi.set(__self__, "pipeline_ready_conditions", pipeline_ready_conditions)
        if targets_present_conditions is not None:
            pulumi.set(__self__, "targets_present_conditions", targets_present_conditions)
        if targets_type_conditions is not None:
            pulumi.set(__self__, "targets_type_conditions", targets_type_conditions)

    @property
    @pulumi.getter(name="pipelineReadyConditions")
    def pipeline_ready_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]]:
        """
        Details around the Pipeline's overall status.
        """
        return pulumi.get(self, "pipeline_ready_conditions")

    @pipeline_ready_conditions.setter
    def pipeline_ready_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]]):
        pulumi.set(self, "pipeline_ready_conditions", value)

    @property
    @pulumi.getter(name="targetsPresentConditions")
    def targets_present_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]]:
        """
        Details around targets enumerated in the pipeline.
        """
        return pulumi.get(self, "targets_present_conditions")

    @targets_present_conditions.setter
    def targets_present_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]]):
        pulumi.set(self, "targets_present_conditions", value)

    @property
    @pulumi.getter(name="targetsTypeConditions")
    def targets_type_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]]:
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        return pulumi.get(self, "targets_type_conditions")

    @targets_type_conditions.setter
    def targets_type_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]]):
        pulumi.set(self, "targets_type_conditions", value)


if not MYPY:
    class DeliveryPipelineConditionPipelineReadyConditionArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Output only. Most recent time at which the pipeline was updated.
        """
elif False:
    DeliveryPipelineConditionPipelineReadyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionPipelineReadyConditionArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[builtins.bool]] = None,
                 update_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] status: True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        :param pulumi.Input[builtins.str] update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class DeliveryPipelineConditionTargetsPresentConditionArgsDict(TypedDict):
        missing_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        status: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if there aren't any missing Targets.
        """
        update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Output only. Most recent time at which the pipeline was updated.
        """
elif False:
    DeliveryPipelineConditionTargetsPresentConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionTargetsPresentConditionArgs:
    def __init__(__self__, *,
                 missing_targets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 status: Optional[pulumi.Input[builtins.bool]] = None,
                 update_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] missing_targets: The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        :param pulumi.Input[builtins.bool] status: True if there aren't any missing Targets.
        :param pulumi.Input[builtins.str] update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if missing_targets is not None:
            pulumi.set(__self__, "missing_targets", missing_targets)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="missingTargets")
    def missing_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        return pulumi.get(self, "missing_targets")

    @missing_targets.setter
    def missing_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "missing_targets", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if there aren't any missing Targets.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class DeliveryPipelineConditionTargetsTypeConditionArgsDict(TypedDict):
        error_details: NotRequired[pulumi.Input[builtins.str]]
        """
        Human readable error message.
        """
        status: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
elif False:
    DeliveryPipelineConditionTargetsTypeConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionTargetsTypeConditionArgs:
    def __init__(__self__, *,
                 error_details: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] error_details: Human readable error message.
        :param pulumi.Input[builtins.bool] status: True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Human readable error message.
        """
        return pulumi.get(self, "error_details")

    @error_details.setter
    def error_details(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "error_details", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DeliveryPipelineIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeliveryPipelineIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeliveryPipelineIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineArgsDict(TypedDict):
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgsDict']]]]
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
elif False:
    DeliveryPipelineSerialPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineArgs:
    def __init__(__self__, *,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]]:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageArgsDict(TypedDict):
        deploy_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgsDict']]]]
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        strategy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgsDict']]
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        target_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
elif False:
    DeliveryPipelineSerialPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageArgs:
    def __init__(__self__, *,
                 deploy_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 strategy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']] = None,
                 target_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs'] strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param pulumi.Input[builtins.str] target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        if deploy_parameters is not None:
            pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]]:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @deploy_parameters.setter
    def deploy_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]]):
        pulumi.set(self, "deploy_parameters", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']]:
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_id", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageDeployParameterArgsDict(TypedDict):
        values: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        match_target_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
elif False:
    DeliveryPipelineSerialPipelineStageDeployParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageDeployParameterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]],
                 match_target_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] values: Required. Values are deploy parameters in key-value pairs.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        pulumi.set(__self__, "values", values)
        if match_target_labels is not None:
            pulumi.set(__self__, "match_target_labels", match_target_labels)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]:
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")

    @match_target_labels.setter
    def match_target_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "match_target_labels", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyArgsDict(TypedDict):
        canary: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict']]
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        standard: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict']]
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyArgs:
    def __init__(__self__, *,
                 canary: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']] = None,
                 standard: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs'] canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs'] standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        if canary is not None:
            pulumi.set(__self__, "canary", canary)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']]:
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @canary.setter
    def canary(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']]):
        pulumi.set(self, "canary", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']]:
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']]):
        pulumi.set(self, "standard", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict(TypedDict):
        canary_deployment: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict']]
        """
        Configures the progressive based deployment for a Target.
        """
        custom_canary_deployment: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict']]
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        runtime_config: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict']]
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryArgs:
    def __init__(__self__, *,
                 canary_deployment: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']] = None,
                 custom_canary_deployment: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']] = None,
                 runtime_config: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs'] canary_deployment: Configures the progressive based deployment for a Target.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs'] custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs'] runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        if canary_deployment is not None:
            pulumi.set(__self__, "canary_deployment", canary_deployment)
        if custom_canary_deployment is not None:
            pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @canary_deployment.setter
    def canary_deployment(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']]):
        pulumi.set(self, "canary_deployment", value)

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @custom_canary_deployment.setter
    def custom_canary_deployment(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']]):
        pulumi.set(self, "custom_canary_deployment", value)

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']]:
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")

    @runtime_config.setter
    def runtime_config(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']]):
        pulumi.set(self, "runtime_config", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict(TypedDict):
        percentages: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to run verify tests after each percentage deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs:
    def __init__(__self__, *,
                 percentages: pulumi.Input[Sequence[pulumi.Input[builtins.int]]],
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']] = None,
                 verify: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] percentages: Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs'] predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        :param pulumi.Input[builtins.bool] verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @percentages.setter
    def percentages(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "percentages", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict(TypedDict):
        phase_configs: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict']]]
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs:
    def __init__(__self__, *,
                 phase_configs: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]] phase_configs: Required. Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]:
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")

    @phase_configs.setter
    def phase_configs(self, value: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]):
        pulumi.set(self, "phase_configs", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict(TypedDict):
        percentage: pulumi.Input[builtins.int]
        """
        Required. Percentage deployment for the phase.
        """
        phase_id: pulumi.Input[builtins.str]
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to run verify tests after the deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs:
    def __init__(__self__, *,
                 percentage: pulumi.Input[builtins.int],
                 phase_id: pulumi.Input[builtins.str],
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 verify: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] percentage: Required. Percentage deployment for the phase.
        :param pulumi.Input[builtins.str] phase_id: Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs'] predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param pulumi.Input[builtins.bool] verify: Whether to run verify tests after the deployment.
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[builtins.int]:
        """
        Required. Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> pulumi.Input[builtins.str]:
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "phase_id")

    @phase_id.setter
    def phase_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "phase_id", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to run verify tests after the deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict(TypedDict):
        cloud_run: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict']]
        """
        Cloud Run runtime configuration.
        """
        kubernetes: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict']]
        """
        Kubernetes runtime configuration.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs:
    def __init__(__self__, *,
                 cloud_run: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']] = None,
                 kubernetes: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs'] cloud_run: Cloud Run runtime configuration.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs'] kubernetes: Kubernetes runtime configuration.
        """
        if cloud_run is not None:
            pulumi.set(__self__, "cloud_run", cloud_run)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']]:
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @cloud_run.setter
    def cloud_run(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']]):
        pulumi.set(self, "cloud_run", value)

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']]:
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']]):
        pulumi.set(self, "kubernetes", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict(TypedDict):
        automatic_traffic_control: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        canary_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        prior_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        stable_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs:
    def __init__(__self__, *,
                 automatic_traffic_control: Optional[pulumi.Input[builtins.bool]] = None,
                 canary_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 prior_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 stable_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] canary_revision_tags: Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prior_revision_tags: Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] stable_revision_tags: Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        if automatic_traffic_control is not None:
            pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)
        if canary_revision_tags is not None:
            pulumi.set(__self__, "canary_revision_tags", canary_revision_tags)
        if prior_revision_tags is not None:
            pulumi.set(__self__, "prior_revision_tags", prior_revision_tags)
        if stable_revision_tags is not None:
            pulumi.set(__self__, "stable_revision_tags", stable_revision_tags)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")

    @automatic_traffic_control.setter
    def automatic_traffic_control(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_traffic_control", value)

    @property
    @pulumi.getter(name="canaryRevisionTags")
    def canary_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        return pulumi.get(self, "canary_revision_tags")

    @canary_revision_tags.setter
    def canary_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "canary_revision_tags", value)

    @property
    @pulumi.getter(name="priorRevisionTags")
    def prior_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        return pulumi.get(self, "prior_revision_tags")

    @prior_revision_tags.setter
    def prior_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prior_revision_tags", value)

    @property
    @pulumi.getter(name="stableRevisionTags")
    def stable_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        return pulumi.get(self, "stable_revision_tags")

    @stable_revision_tags.setter
    def stable_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "stable_revision_tags", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict(TypedDict):
        gateway_service_mesh: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict']]
        """
        Kubernetes Gateway API service mesh configuration.
        """
        service_networking: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict']]
        """
        Kubernetes Service networking configuration.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs:
    def __init__(__self__, *,
                 gateway_service_mesh: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']] = None,
                 service_networking: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs'] gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs'] service_networking: Kubernetes Service networking configuration.
        """
        if gateway_service_mesh is not None:
            pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        if service_networking is not None:
            pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']]:
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @gateway_service_mesh.setter
    def gateway_service_mesh(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']]):
        pulumi.set(self, "gateway_service_mesh", value)

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']]:
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")

    @service_networking.setter
    def service_networking(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']]):
        pulumi.set(self, "service_networking", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict(TypedDict):
        deployment: pulumi.Input[builtins.str]
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        http_route: pulumi.Input[builtins.str]
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        service: pulumi.Input[builtins.str]
        """
        Required. Name of the Kubernetes Service.
        """
        pod_selector_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        route_destinations: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgsDict']]
        """
        Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
        """
        route_update_wait_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        stable_cutback_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[builtins.str],
                 http_route: pulumi.Input[builtins.str],
                 service: pulumi.Input[builtins.str],
                 pod_selector_label: Optional[pulumi.Input[builtins.str]] = None,
                 route_destinations: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs']] = None,
                 route_update_wait_time: Optional[pulumi.Input[builtins.str]] = None,
                 stable_cutback_duration: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param pulumi.Input[builtins.str] http_route: Required. Name of the Gateway API HTTPRoute.
        :param pulumi.Input[builtins.str] service: Required. Name of the Kubernetes Service.
        :param pulumi.Input[builtins.str] pod_selector_label: Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs'] route_destinations: Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
        :param pulumi.Input[builtins.str] route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        :param pulumi.Input[builtins.str] stable_cutback_duration: Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "service", service)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)
        if route_destinations is not None:
            pulumi.set(__self__, "route_destinations", route_destinations)
        if route_update_wait_time is not None:
            pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)
        if stable_cutback_duration is not None:
            pulumi.set(__self__, "stable_cutback_duration", stable_cutback_duration)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[builtins.str]:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> pulumi.Input[builtins.str]:
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[builtins.str]:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        return pulumi.get(self, "pod_selector_label")

    @pod_selector_label.setter
    def pod_selector_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pod_selector_label", value)

    @property
    @pulumi.getter(name="routeDestinations")
    def route_destinations(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs']]:
        """
        Optional. Route destinations allow configuring the Gateway API HTTPRoute to be deployed to additional clusters. This option is available for multi-cluster service mesh set ups that require the route to exist in the clusters that call the service. If unspecified, the HTTPRoute will only be deployed to the Target cluster.
        """
        return pulumi.get(self, "route_destinations")

    @route_destinations.setter
    def route_destinations(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs']]):
        pulumi.set(self, "route_destinations", value)

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @route_update_wait_time.setter
    def route_update_wait_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route_update_wait_time", value)

    @property
    @pulumi.getter(name="stableCutbackDuration")
    def stable_cutback_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        return pulumi.get(self, "stable_cutback_duration")

    @stable_cutback_duration.setter
    def stable_cutback_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "stable_cutback_duration", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgsDict(TypedDict):
        destination_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
        """
        propagate_service: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshRouteDestinationsArgs:
    def __init__(__self__, *,
                 destination_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 propagate_service: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] destination_ids: Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
        :param pulumi.Input[builtins.bool] propagate_service: Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
        """
        pulumi.set(__self__, "destination_ids", destination_ids)
        if propagate_service is not None:
            pulumi.set(__self__, "propagate_service", propagate_service)

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Required. The clusters where the Gateway API HTTPRoute resource will be deployed to. Valid entries include the associated entities IDs configured in the Target resource and "@self" to include the Target cluster.
        """
        return pulumi.get(self, "destination_ids")

    @destination_ids.setter
    def destination_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "destination_ids", value)

    @property
    @pulumi.getter(name="propagateService")
    def propagate_service(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. Whether to propagate the Kubernetes Service to the route destination clusters. The Service will always be deployed to the Target cluster even if the HTTPRoute is not. This option may be used to facilitiate successful DNS lookup in the route destination clusters. Can only be set to true if destinations are specified.
        """
        return pulumi.get(self, "propagate_service")

    @propagate_service.setter
    def propagate_service(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "propagate_service", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict(TypedDict):
        deployment: pulumi.Input[builtins.str]
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        service: pulumi.Input[builtins.str]
        """
        Required. Name of the Kubernetes Service.
        """
        disable_pod_overprovisioning: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        pod_selector_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[builtins.str],
                 service: pulumi.Input[builtins.str],
                 disable_pod_overprovisioning: Optional[pulumi.Input[builtins.bool]] = None,
                 pod_selector_label: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param pulumi.Input[builtins.str] service: Required. Name of the Kubernetes Service.
        :param pulumi.Input[builtins.bool] disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        :param pulumi.Input[builtins.str] pod_selector_label: Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "service", service)
        if disable_pod_overprovisioning is not None:
            pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[builtins.str]:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[builtins.str]:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @disable_pod_overprovisioning.setter
    def disable_pod_overprovisioning(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_pod_overprovisioning", value)

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        return pulumi.get(self, "pod_selector_label")

    @pod_selector_label.setter
    def pod_selector_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pod_selector_label", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict(TypedDict):
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to verify a deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardArgs:
    def __init__(__self__, *,
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']] = None,
                 verify: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs'] predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param pulumi.Input[builtins.bool] verify: Whether to verify a deployment.
        """
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeployPolicyRuleArgsDict(TypedDict):
        rollout_restriction: NotRequired[pulumi.Input['DeployPolicyRuleRolloutRestrictionArgsDict']]
        """
        Optional. Rollout restrictions.
        Structure is documented below.
        """
elif False:
    DeployPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleArgs:
    def __init__(__self__, *,
                 rollout_restriction: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionArgs']] = None):
        """
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionArgs'] rollout_restriction: Optional. Rollout restrictions.
               Structure is documented below.
        """
        if rollout_restriction is not None:
            pulumi.set(__self__, "rollout_restriction", rollout_restriction)

    @property
    @pulumi.getter(name="rolloutRestriction")
    def rollout_restriction(self) -> Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionArgs']]:
        """
        Optional. Rollout restrictions.
        Structure is documented below.
        """
        return pulumi.get(self, "rollout_restriction")

    @rollout_restriction.setter
    def rollout_restriction(self, value: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionArgs']]):
        pulumi.set(self, "rollout_restriction", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
        Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
        """
        invokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. What invoked the action. If left empty, all invoker types will be restricted.
        Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
        """
        time_windows: NotRequired[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsArgsDict']]
        """
        Required. Time window within which actions are restricted.
        Structure is documented below.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 invokers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 time_windows: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsArgs']] = None):
        """
        :param pulumi.Input[builtins.str] id: Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
               Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] invokers: Optional. What invoked the action. If left empty, all invoker types will be restricted.
               Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsArgs'] time_windows: Required. Time window within which actions are restricted.
               Structure is documented below.
        """
        pulumi.set(__self__, "id", id)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if invokers is not None:
            pulumi.set(__self__, "invokers", invokers)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Required. ID of the rule. This id must be unique in the `DeployPolicy` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. Rollout actions to be restricted as part of the policy. If left empty, all actions will be restricted.
        Each value may be one of: `ADVANCE`, `APPROVE`, `CANCEL`, `CREATE`, `IGNORE_JOB`, `RETRY_JOB`, `ROLLBACK`, `TERMINATE_JOBRUN`.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def invokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. What invoked the action. If left empty, all invoker types will be restricted.
        Each value may be one of: `USER`, `DEPLOY_AUTOMATION`.
        """
        return pulumi.get(self, "invokers")

    @invokers.setter
    def invokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "invokers", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsArgs']]:
        """
        Required. Time window within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsArgsDict(TypedDict):
        time_zone: pulumi.Input[builtins.str]
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        one_time_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgsDict']]]]
        """
        Optional. One-time windows within which actions are restricted.
        Structure is documented below.
        """
        weekly_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgsDict']]]]
        """
        Optional. Recurring weekly windows within which actions are restricted.
        Structure is documented below.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsArgs:
    def __init__(__self__, *,
                 time_zone: pulumi.Input[builtins.str],
                 one_time_windows: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs']]]] = None,
                 weekly_windows: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] time_zone: Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        :param pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs']]] one_time_windows: Optional. One-time windows within which actions are restricted.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs']]] weekly_windows: Optional. Recurring weekly windows within which actions are restricted.
               Structure is documented below.
        """
        pulumi.set(__self__, "time_zone", time_zone)
        if one_time_windows is not None:
            pulumi.set(__self__, "one_time_windows", one_time_windows)
        if weekly_windows is not None:
            pulumi.set(__self__, "weekly_windows", weekly_windows)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[builtins.str]:
        """
        Required. The time zone in IANA format IANA Time Zone Database (e.g. America/New_York).
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="oneTimeWindows")
    def one_time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs']]]]:
        """
        Optional. One-time windows within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "one_time_windows")

    @one_time_windows.setter
    def one_time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs']]]]):
        pulumi.set(self, "one_time_windows", value)

    @property
    @pulumi.getter(name="weeklyWindows")
    def weekly_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs']]]]:
        """
        Optional. Recurring weekly windows within which actions are restricted.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_windows")

    @weekly_windows.setter
    def weekly_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs']]]]):
        pulumi.set(self, "weekly_windows", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgsDict(TypedDict):
        end_date: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgsDict']
        """
        Required. End date.
        Structure is documented below.
        """
        end_time: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgsDict']
        """
        Required. End time (exclusive). You may use 24:00 for the end of the day.
        Structure is documented below.
        """
        start_date: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgsDict']
        """
        Required. Start date.
        Structure is documented below.
        """
        start_time: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgsDict']
        """
        Required. Start time (inclusive). Use 00:00 for the beginning of the day.
        Structure is documented below.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowArgs:
    def __init__(__self__, *,
                 end_date: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs'],
                 end_time: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs'],
                 start_date: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs'],
                 start_time: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs']):
        """
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs'] end_date: Required. End date.
               Structure is documented below.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs'] end_time: Required. End time (exclusive). You may use 24:00 for the end of the day.
               Structure is documented below.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs'] start_date: Required. Start date.
               Structure is documented below.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs'] start_time: Required. Start time (inclusive). Use 00:00 for the beginning of the day.
               Structure is documented below.
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs']:
        """
        Required. End date.
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs']):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs']:
        """
        Required. End time (exclusive). You may use 24:00 for the end of the day.
        Structure is documented below.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs']):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs']:
        """
        Required. Start date.
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs']):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs']:
        """
        Required. Start time (inclusive). Use 00:00 for the beginning of the day.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[builtins.int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        month: NotRequired[pulumi.Input[builtins.int]]
        """
        Month of a year. Must be from 1 to 12.
        """
        year: NotRequired[pulumi.Input[builtins.int]]
        """
        Year of the date. Must be from 1 to 9999.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[builtins.int]] = None,
                 month: Optional[pulumi.Input[builtins.int]] = None,
                 year: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] day: Day of a month. Must be from 1 to 31 and valid for the year and month.
        :param pulumi.Input[builtins.int] month: Month of a year. Must be from 1 to 12.
        :param pulumi.Input[builtins.int] year: Year of the date. Must be from 1 to 9999.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Month of a year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Year of the date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowEndTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[builtins.int]] = None,
                 minutes: Optional[pulumi.Input[builtins.int]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[builtins.int] minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param pulumi.Input[builtins.int] nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
               
               - - -
        :param pulumi.Input[builtins.int] seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[builtins.int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        month: NotRequired[pulumi.Input[builtins.int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[builtins.int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[builtins.int]] = None,
                 month: Optional[pulumi.Input[builtins.int]] = None,
                 year: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[builtins.int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[builtins.int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsOneTimeWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[builtins.int]] = None,
                 minutes: Optional[pulumi.Input[builtins.int]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[builtins.int] minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param pulumi.Input[builtins.int] nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        :param pulumi.Input[builtins.int] seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgsDict(TypedDict):
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. Days of week. If left empty, all days of the week will be included.
        Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        end_time: NotRequired[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgsDict']]
        """
        Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
        start_time: NotRequired[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgsDict']]
        """
        Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 end_time: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs']] = None,
                 start_time: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] days_of_weeks: Optional. Days of week. If left empty, all days of the week will be included.
               Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs'] end_time: Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
               Structure is documented below.
        :param pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs'] start_time: Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
               Structure is documented below.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. Days of week. If left empty, all days of the week will be included.
        Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs']]:
        """
        Optional. End time (exclusive). Use 24:00 to indicate midnight. If you specify endTime you must also specify startTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs']]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs']]:
        """
        Optional. Start time (inclusive). Use 00:00 for the beginning of the day. If you specify startTime you must also specify endTime. If left empty, this will block for the entire day for the days specified in daysOfWeek.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input['DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs']]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowEndTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[builtins.int]] = None,
                 minutes: Optional[pulumi.Input[builtins.int]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[builtins.int] minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param pulumi.Input[builtins.int] nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
               
               - - -
        :param pulumi.Input[builtins.int] seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.

        - - -
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicyRuleRolloutRestrictionTimeWindowsWeeklyWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[builtins.int]] = None,
                 minutes: Optional[pulumi.Input[builtins.int]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] hours: Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[builtins.int] minutes: Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        :param pulumi.Input[builtins.int] nanos: Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        :param pulumi.Input[builtins.int] seconds: Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or equal to 0 and less than or equal to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and typically must be less than or equal to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class DeployPolicySelectorArgsDict(TypedDict):
        delivery_pipeline: NotRequired[pulumi.Input['DeployPolicySelectorDeliveryPipelineArgsDict']]
        """
        Contains attributes about a delivery pipeline.
        Structure is documented below.
        """
        target: NotRequired[pulumi.Input['DeployPolicySelectorTargetArgsDict']]
        """
        Contains attributes about a target.
        Structure is documented below.
        """
elif False:
    DeployPolicySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicySelectorArgs:
    def __init__(__self__, *,
                 delivery_pipeline: Optional[pulumi.Input['DeployPolicySelectorDeliveryPipelineArgs']] = None,
                 target: Optional[pulumi.Input['DeployPolicySelectorTargetArgs']] = None):
        """
        :param pulumi.Input['DeployPolicySelectorDeliveryPipelineArgs'] delivery_pipeline: Contains attributes about a delivery pipeline.
               Structure is documented below.
        :param pulumi.Input['DeployPolicySelectorTargetArgs'] target: Contains attributes about a target.
               Structure is documented below.
        """
        if delivery_pipeline is not None:
            pulumi.set(__self__, "delivery_pipeline", delivery_pipeline)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="deliveryPipeline")
    def delivery_pipeline(self) -> Optional[pulumi.Input['DeployPolicySelectorDeliveryPipelineArgs']]:
        """
        Contains attributes about a delivery pipeline.
        Structure is documented below.
        """
        return pulumi.get(self, "delivery_pipeline")

    @delivery_pipeline.setter
    def delivery_pipeline(self, value: Optional[pulumi.Input['DeployPolicySelectorDeliveryPipelineArgs']]):
        pulumi.set(self, "delivery_pipeline", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['DeployPolicySelectorTargetArgs']]:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['DeployPolicySelectorTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class DeployPolicySelectorDeliveryPipelineArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
        - The last segment of a pipeline name
        - "*", all delivery pipelines in a location
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        DeliveryPipeline labels.
        """
elif False:
    DeployPolicySelectorDeliveryPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicySelectorDeliveryPipelineArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] id: Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
               - The last segment of a pipeline name
               - "*", all delivery pipelines in a location
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: DeliveryPipeline labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. ID of the DeliveryPipeline. The value of this field could be one of the following:
        - The last segment of a pipeline name
        - "*", all delivery pipelines in a location
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        DeliveryPipeline labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class DeployPolicySelectorTargetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Target labels.
        """
elif False:
    DeployPolicySelectorTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployPolicySelectorTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class TargetAnthosClusterArgsDict(TypedDict):
        membership: NotRequired[pulumi.Input[builtins.str]]
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
elif False:
    TargetAnthosClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetAnthosClusterArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "membership", value)


if not MYPY:
    class TargetAssociatedEntityArgsDict(TypedDict):
        entity_id: pulumi.Input[builtins.str]
        """
        The name for the key in the map for which this object is mapped to in the API
        """
        anthos_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityAnthosClusterArgsDict']]]]
        """
        Optional. Information specifying Anthos clusters as associated entities.
        """
        gke_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityGkeClusterArgsDict']]]]
        """
        Optional. Information specifying GKE clusters as associated entities.
        """
elif False:
    TargetAssociatedEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetAssociatedEntityArgs:
    def __init__(__self__, *,
                 entity_id: pulumi.Input[builtins.str],
                 anthos_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityAnthosClusterArgs']]]] = None,
                 gke_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityGkeClusterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] entity_id: The name for the key in the map for which this object is mapped to in the API
        :param pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityAnthosClusterArgs']]] anthos_clusters: Optional. Information specifying Anthos clusters as associated entities.
        :param pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityGkeClusterArgs']]] gke_clusters: Optional. Information specifying GKE clusters as associated entities.
        """
        pulumi.set(__self__, "entity_id", entity_id)
        if anthos_clusters is not None:
            pulumi.set(__self__, "anthos_clusters", anthos_clusters)
        if gke_clusters is not None:
            pulumi.set(__self__, "gke_clusters", gke_clusters)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[builtins.str]:
        """
        The name for the key in the map for which this object is mapped to in the API
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="anthosClusters")
    def anthos_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityAnthosClusterArgs']]]]:
        """
        Optional. Information specifying Anthos clusters as associated entities.
        """
        return pulumi.get(self, "anthos_clusters")

    @anthos_clusters.setter
    def anthos_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityAnthosClusterArgs']]]]):
        pulumi.set(self, "anthos_clusters", value)

    @property
    @pulumi.getter(name="gkeClusters")
    def gke_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityGkeClusterArgs']]]]:
        """
        Optional. Information specifying GKE clusters as associated entities.
        """
        return pulumi.get(self, "gke_clusters")

    @gke_clusters.setter
    def gke_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAssociatedEntityGkeClusterArgs']]]]):
        pulumi.set(self, "gke_clusters", value)


if not MYPY:
    class TargetAssociatedEntityAnthosClusterArgsDict(TypedDict):
        membership: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
elif False:
    TargetAssociatedEntityAnthosClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetAssociatedEntityAnthosClusterArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] membership: Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "membership", value)


if not MYPY:
    class TargetAssociatedEntityGkeClusterArgsDict(TypedDict):
        cluster: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        """
        internal_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        proxy_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
elif False:
    TargetAssociatedEntityGkeClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetAssociatedEntityGkeClusterArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[builtins.str]] = None,
                 internal_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 proxy_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cluster: Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        :param pulumi.Input[builtins.bool] internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param pulumi.Input[builtins.str] proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proxy_url", value)


if not MYPY:
    class TargetCustomTargetArgsDict(TypedDict):
        custom_target_type: pulumi.Input[builtins.str]
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
elif False:
    TargetCustomTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetCustomTargetArgs:
    def __init__(__self__, *,
                 custom_target_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] custom_target_type: Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        pulumi.set(__self__, "custom_target_type", custom_target_type)

    @property
    @pulumi.getter(name="customTargetType")
    def custom_target_type(self) -> pulumi.Input[builtins.str]:
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        return pulumi.get(self, "custom_target_type")

    @custom_target_type.setter
    def custom_target_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "custom_target_type", value)


if not MYPY:
    class TargetExecutionConfigArgsDict(TypedDict):
        usages: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Required. Usages when this configuration should be applied.
        """
        artifact_storage: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        execution_timeout: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        service_account: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        verbose: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        worker_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
elif False:
    TargetExecutionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetExecutionConfigArgs:
    def __init__(__self__, *,
                 usages: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 artifact_storage: Optional[pulumi.Input[builtins.str]] = None,
                 execution_timeout: Optional[pulumi.Input[builtins.str]] = None,
                 service_account: Optional[pulumi.Input[builtins.str]] = None,
                 verbose: Optional[pulumi.Input[builtins.bool]] = None,
                 worker_pool: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] usages: Required. Usages when this configuration should be applied.
        :param pulumi.Input[builtins.str] artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param pulumi.Input[builtins.str] execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param pulumi.Input[builtins.str] service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param pulumi.Input[builtins.bool] verbose: Optional. If true, additional logging will be enabled when running builds in this execution environment.
        :param pulumi.Input[builtins.str] worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "usages", usages)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if execution_timeout is not None:
            pulumi.set(__self__, "execution_timeout", execution_timeout)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)
        if worker_pool is not None:
            pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter
    def usages(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Required. Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "usages", value)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @artifact_storage.setter
    def artifact_storage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "artifact_storage", value)

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @execution_timeout.setter
    def execution_timeout(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "execution_timeout", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def verbose(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        return pulumi.get(self, "verbose")

    @verbose.setter
    def verbose(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verbose", value)

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")

    @worker_pool.setter
    def worker_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "worker_pool", value)


if not MYPY:
    class TargetGkeArgsDict(TypedDict):
        cluster: NotRequired[pulumi.Input[builtins.str]]
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        dns_endpoint: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dns_endpoint` and `internal_ip` cannot be set to true.
        """
        internal_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        proxy_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
elif False:
    TargetGkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGkeArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[builtins.str]] = None,
                 dns_endpoint: Optional[pulumi.Input[builtins.bool]] = None,
                 internal_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 proxy_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        :param pulumi.Input[builtins.bool] dns_endpoint: Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dns_endpoint` and `internal_ip` cannot be set to true.
        :param pulumi.Input[builtins.bool] internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param pulumi.Input[builtins.str] proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if dns_endpoint is not None:
            pulumi.set(__self__, "dns_endpoint", dns_endpoint)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="dnsEndpoint")
    def dns_endpoint(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. If set, the cluster will be accessed using the DNS endpoint. Note that both `dns_endpoint` and `internal_ip` cannot be set to true.
        """
        return pulumi.get(self, "dns_endpoint")

    @dns_endpoint.setter
    def dns_endpoint(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dns_endpoint", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proxy_url", value)


if not MYPY:
    class TargetIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TargetIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TargetIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TargetIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TargetMultiTargetArgsDict(TypedDict):
        target_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Required. The target_ids of this multiTarget.
        """
elif False:
    TargetMultiTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetMultiTargetArgs:
    def __init__(__self__, *,
                 target_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_ids: Required. The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Required. The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "target_ids", value)


if not MYPY:
    class TargetRunArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
elif False:
    TargetRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetRunArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] location: Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)


