# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AutomationRuleArgs',
    'AutomationRuleArgsDict',
    'AutomationRuleAdvanceRolloutRuleArgs',
    'AutomationRuleAdvanceRolloutRuleArgsDict',
    'AutomationRulePromoteReleaseRuleArgs',
    'AutomationRulePromoteReleaseRuleArgsDict',
    'AutomationSelectorArgs',
    'AutomationSelectorArgsDict',
    'AutomationSelectorTargetArgs',
    'AutomationSelectorTargetArgsDict',
    'CustomTargetTypeCustomActionsArgs',
    'CustomTargetTypeCustomActionsArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs',
    'CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict',
    'CustomTargetTypeIamBindingConditionArgs',
    'CustomTargetTypeIamBindingConditionArgsDict',
    'CustomTargetTypeIamMemberConditionArgs',
    'CustomTargetTypeIamMemberConditionArgsDict',
    'DeliveryPipelineConditionArgs',
    'DeliveryPipelineConditionArgsDict',
    'DeliveryPipelineConditionPipelineReadyConditionArgs',
    'DeliveryPipelineConditionPipelineReadyConditionArgsDict',
    'DeliveryPipelineConditionTargetsPresentConditionArgs',
    'DeliveryPipelineConditionTargetsPresentConditionArgsDict',
    'DeliveryPipelineConditionTargetsTypeConditionArgs',
    'DeliveryPipelineConditionTargetsTypeConditionArgsDict',
    'DeliveryPipelineIamBindingConditionArgs',
    'DeliveryPipelineIamBindingConditionArgsDict',
    'DeliveryPipelineIamMemberConditionArgs',
    'DeliveryPipelineIamMemberConditionArgsDict',
    'DeliveryPipelineSerialPipelineArgs',
    'DeliveryPipelineSerialPipelineArgsDict',
    'DeliveryPipelineSerialPipelineStageArgs',
    'DeliveryPipelineSerialPipelineStageArgsDict',
    'DeliveryPipelineSerialPipelineStageDeployParameterArgs',
    'DeliveryPipelineSerialPipelineStageDeployParameterArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyArgs',
    'DeliveryPipelineSerialPipelineStageStrategyArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs',
    'DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs',
    'DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict',
    'TargetAnthosClusterArgs',
    'TargetAnthosClusterArgsDict',
    'TargetCustomTargetArgs',
    'TargetCustomTargetArgsDict',
    'TargetExecutionConfigArgs',
    'TargetExecutionConfigArgsDict',
    'TargetGkeArgs',
    'TargetGkeArgsDict',
    'TargetIamBindingConditionArgs',
    'TargetIamBindingConditionArgsDict',
    'TargetIamMemberConditionArgs',
    'TargetIamMemberConditionArgsDict',
    'TargetMultiTargetArgs',
    'TargetMultiTargetArgsDict',
    'TargetRunArgs',
    'TargetRunArgsDict',
]

MYPY = False

if not MYPY:
    class AutomationRuleArgsDict(TypedDict):
        advance_rollout_rule: NotRequired[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgsDict']]
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        promote_release_rule: NotRequired[pulumi.Input['AutomationRulePromoteReleaseRuleArgsDict']]
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
elif False:
    AutomationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleArgs:
    def __init__(__self__, *,
                 advance_rollout_rule: Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']] = None,
                 promote_release_rule: Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']] = None):
        """
        :param pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs'] advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
               Structure is documented below.
        :param pulumi.Input['AutomationRulePromoteReleaseRuleArgs'] promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
               Structure is documented below.
        """
        if advance_rollout_rule is not None:
            pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        if promote_release_rule is not None:
            pulumi.set(__self__, "promote_release_rule", promote_release_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']]:
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        Structure is documented below.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @advance_rollout_rule.setter
    def advance_rollout_rule(self, value: Optional[pulumi.Input['AutomationRuleAdvanceRolloutRuleArgs']]):
        pulumi.set(self, "advance_rollout_rule", value)

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']]:
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        Structure is documented below.
        """
        return pulumi.get(self, "promote_release_rule")

    @promote_release_rule.setter
    def promote_release_rule(self, value: Optional[pulumi.Input['AutomationRulePromoteReleaseRuleArgs']]):
        pulumi.set(self, "promote_release_rule", value)


if not MYPY:
    class AutomationRuleAdvanceRolloutRuleArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        source_phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.

        - - -
        """
        wait: NotRequired[pulumi.Input[str]]
        """
        Optional. How long to wait after a rollout is finished.
        """
elif False:
    AutomationRuleAdvanceRolloutRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleAdvanceRolloutRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 source_phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wait: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
               
               - - -
        :param pulumi.Input[str] wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "id", id)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.

        - - -
        """
        return pulumi.get(self, "source_phases")

    @source_phases.setter
    def source_phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_phases", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wait", value)


if not MYPY:
    class AutomationRulePromoteReleaseRuleArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        destination_phase: NotRequired[pulumi.Input[str]]
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        destination_target_id: NotRequired[pulumi.Input[str]]
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        wait: NotRequired[pulumi.Input[str]]
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
elif False:
    AutomationRulePromoteReleaseRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePromoteReleaseRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 destination_phase: Optional[pulumi.Input[str]] = None,
                 destination_target_id: Optional[pulumi.Input[str]] = None,
                 wait: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[str] destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param pulumi.Input[str] destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param pulumi.Input[str] wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "id", id)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_phase", value)

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @destination_target_id.setter
    def destination_target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_target_id", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wait", value)


if not MYPY:
    class AutomationSelectorArgsDict(TypedDict):
        targets: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgsDict']]]
        """
        Contains attributes about a target.
        Structure is documented below.
        """
elif False:
    AutomationSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationSelectorArgs:
    def __init__(__self__, *,
                 targets: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]] targets: Contains attributes about a target.
               Structure is documented below.
        """
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]:
        """
        Contains attributes about a target.
        Structure is documented below.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['AutomationSelectorTargetArgs']]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class AutomationSelectorTargetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Target labels.
        """
elif False:
    AutomationSelectorTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationSelectorTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class CustomTargetTypeCustomActionsArgsDict(TypedDict):
        deploy_action: pulumi.Input[str]
        """
        The Skaffold custom action responsible for deploy operations.
        """
        include_skaffold_modules: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict']]]]
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        render_action: NotRequired[pulumi.Input[str]]
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
elif False:
    CustomTargetTypeCustomActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsArgs:
    def __init__(__self__, *,
                 deploy_action: pulumi.Input[str],
                 include_skaffold_modules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]] = None,
                 render_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_action: The Skaffold custom action responsible for deploy operations.
        :param pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]] include_skaffold_modules: List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
               Structure is documented below.
        :param pulumi.Input[str] render_action: The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        pulumi.set(__self__, "deploy_action", deploy_action)
        if include_skaffold_modules is not None:
            pulumi.set(__self__, "include_skaffold_modules", include_skaffold_modules)
        if render_action is not None:
            pulumi.set(__self__, "render_action", render_action)

    @property
    @pulumi.getter(name="deployAction")
    def deploy_action(self) -> pulumi.Input[str]:
        """
        The Skaffold custom action responsible for deploy operations.
        """
        return pulumi.get(self, "deploy_action")

    @deploy_action.setter
    def deploy_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "deploy_action", value)

    @property
    @pulumi.getter(name="includeSkaffoldModules")
    def include_skaffold_modules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]]:
        """
        List of Skaffold modules Cloud Deploy will include in the Skaffold Config as required before performing diagnose.
        Structure is documented below.
        """
        return pulumi.get(self, "include_skaffold_modules")

    @include_skaffold_modules.setter
    def include_skaffold_modules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs']]]]):
        pulumi.set(self, "include_skaffold_modules", value)

    @property
    @pulumi.getter(name="renderAction")
    def render_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Skaffold custom action responsible for render operations. If not provided then Cloud Deploy will perform the render operations via `skaffold render`.
        """
        return pulumi.get(self, "render_action")

    @render_action.setter
    def render_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "render_action", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Skaffold Config modules to use from the specified source.
        """
        git: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict']]
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        google_cloud_build_repo: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict']]
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        google_cloud_storage: NotRequired[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict']]
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 git: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']] = None,
                 google_cloud_build_repo: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']] = None,
                 google_cloud_storage: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] configs: The Skaffold Config modules to use from the specified source.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs'] git: Remote git repository containing the Skaffold Config modules.
               Structure is documented below.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs'] google_cloud_build_repo: Cloud Build 2nd gen repository containing the Skaffold Config modules.
               Structure is documented below.
        :param pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs'] google_cloud_storage: Cloud Storage bucket containing Skaffold Config modules.
               Structure is documented below.
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if google_cloud_build_repo is not None:
            pulumi.set(__self__, "google_cloud_build_repo", google_cloud_build_repo)
        if google_cloud_storage is not None:
            pulumi.set(__self__, "google_cloud_storage", google_cloud_storage)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Skaffold Config modules to use from the specified source.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']]:
        """
        Remote git repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter(name="googleCloudBuildRepo")
    def google_cloud_build_repo(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']]:
        """
        Cloud Build 2nd gen repository containing the Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_build_repo")

    @google_cloud_build_repo.setter
    def google_cloud_build_repo(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs']]):
        pulumi.set(self, "google_cloud_build_repo", value)

    @property
    @pulumi.getter(name="googleCloudStorage")
    def google_cloud_storage(self) -> Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']]:
        """
        Cloud Storage bucket containing Skaffold Config modules.
        Structure is documented below.
        """
        return pulumi.get(self, "google_cloud_storage")

    @google_cloud_storage.setter
    def google_cloud_storage(self, value: Optional[pulumi.Input['CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs']]):
        pulumi.set(self, "google_cloud_storage", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict(TypedDict):
        repo: pulumi.Input[str]
        """
        Git repository the package should be cloned from.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Relative path from the repository root to the Skaffold file.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        Git ref the package should be cloned from.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGitArgs:
    def __init__(__self__, *,
                 repo: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repo: Git repository the package should be cloned from.
        :param pulumi.Input[str] path: Relative path from the repository root to the Skaffold file.
        :param pulumi.Input[str] ref: Git ref the package should be cloned from.
        """
        pulumi.set(__self__, "repo", repo)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repo(self) -> pulumi.Input[str]:
        """
        Git repository the package should be cloned from.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        Git ref the package should be cloned from.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict(TypedDict):
        repository: pulumi.Input[str]
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Relative path from the repository root to the Skaffold file.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        Branch or tag to use when cloning the repository.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudBuildRepoArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] repository: Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        :param pulumi.Input[str] path: Relative path from the repository root to the Skaffold file.
        :param pulumi.Input[str] ref: Branch or tag to use when cloning the repository.
        """
        pulumi.set(__self__, "repository", repository)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        Cloud Build 2nd gen repository in the format of 'projects/<project>/locations/<location>/connections/<connection>/repositories/<repository>'.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path from the repository root to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        Branch or tag to use when cloning the repository.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict(TypedDict):
        source: pulumi.Input[str]
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Relative path from the source to the Skaffold file.
        """
elif False:
    CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeCustomActionsIncludeSkaffoldModuleGoogleCloudStorageArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source: Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        :param pulumi.Input[str] path: Relative path from the source to the Skaffold file.
        """
        pulumi.set(__self__, "source", source)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Cloud Storage source paths to copy recursively. For example, providing `gs://my-bucket/dir/configs/*` will result in Skaffold copying all files within the `dir/configs` directory in the bucket `my-bucket`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path from the source to the Skaffold file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class CustomTargetTypeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    CustomTargetTypeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class CustomTargetTypeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    CustomTargetTypeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTargetTypeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineConditionArgsDict(TypedDict):
        pipeline_ready_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgsDict']]]]
        """
        Details around the Pipeline's overall status.
        """
        targets_present_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgsDict']]]]
        """
        Details around targets enumerated in the pipeline.
        """
        targets_type_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgsDict']]]]
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
elif False:
    DeliveryPipelineConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionArgs:
    def __init__(__self__, *,
                 pipeline_ready_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]] = None,
                 targets_present_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]] = None,
                 targets_type_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]] pipeline_ready_conditions: Details around the Pipeline's overall status.
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]] targets_present_conditions: Details around targets enumerated in the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]] targets_type_conditions: Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        if pipeline_ready_conditions is not None:
            pulumi.set(__self__, "pipeline_ready_conditions", pipeline_ready_conditions)
        if targets_present_conditions is not None:
            pulumi.set(__self__, "targets_present_conditions", targets_present_conditions)
        if targets_type_conditions is not None:
            pulumi.set(__self__, "targets_type_conditions", targets_type_conditions)

    @property
    @pulumi.getter(name="pipelineReadyConditions")
    def pipeline_ready_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]]:
        """
        Details around the Pipeline's overall status.
        """
        return pulumi.get(self, "pipeline_ready_conditions")

    @pipeline_ready_conditions.setter
    def pipeline_ready_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionPipelineReadyConditionArgs']]]]):
        pulumi.set(self, "pipeline_ready_conditions", value)

    @property
    @pulumi.getter(name="targetsPresentConditions")
    def targets_present_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]]:
        """
        Details around targets enumerated in the pipeline.
        """
        return pulumi.get(self, "targets_present_conditions")

    @targets_present_conditions.setter
    def targets_present_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsPresentConditionArgs']]]]):
        pulumi.set(self, "targets_present_conditions", value)

    @property
    @pulumi.getter(name="targetsTypeConditions")
    def targets_type_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]]:
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        return pulumi.get(self, "targets_type_conditions")

    @targets_type_conditions.setter
    def targets_type_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineConditionTargetsTypeConditionArgs']]]]):
        pulumi.set(self, "targets_type_conditions", value)


if not MYPY:
    class DeliveryPipelineConditionPipelineReadyConditionArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[bool]]
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. Most recent time at which the pipeline was updated.
        """
elif False:
    DeliveryPipelineConditionPipelineReadyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionPipelineReadyConditionArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[bool]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] status: True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        :param pulumi.Input[str] update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class DeliveryPipelineConditionTargetsPresentConditionArgsDict(TypedDict):
        missing_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        status: NotRequired[pulumi.Input[bool]]
        """
        True if there aren't any missing Targets.
        """
        update_time: NotRequired[pulumi.Input[str]]
        """
        Output only. Most recent time at which the pipeline was updated.
        """
elif False:
    DeliveryPipelineConditionTargetsPresentConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionTargetsPresentConditionArgs:
    def __init__(__self__, *,
                 missing_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[bool]] = None,
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] missing_targets: The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        :param pulumi.Input[bool] status: True if there aren't any missing Targets.
        :param pulumi.Input[str] update_time: Output only. Most recent time at which the pipeline was updated.
        """
        if missing_targets is not None:
            pulumi.set(__self__, "missing_targets", missing_targets)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="missingTargets")
    def missing_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Target names that are missing. For example, projects/{project_id}/locations/{location_name}/targets/{target_name}.
        """
        return pulumi.get(self, "missing_targets")

    @missing_targets.setter
    def missing_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "missing_targets", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[bool]]:
        """
        True if there aren't any missing Targets.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class DeliveryPipelineConditionTargetsTypeConditionArgsDict(TypedDict):
        error_details: NotRequired[pulumi.Input[str]]
        """
        Human readable error message.
        """
        status: NotRequired[pulumi.Input[bool]]
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
elif False:
    DeliveryPipelineConditionTargetsTypeConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineConditionTargetsTypeConditionArgs:
    def __init__(__self__, *,
                 error_details: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] error_details: Human readable error message.
        :param pulumi.Input[bool] status: True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable error message.
        """
        return pulumi.get(self, "error_details")

    @error_details.setter
    def error_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_details", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DeliveryPipelineIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DeliveryPipelineIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DeliveryPipelineIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineArgsDict(TypedDict):
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgsDict']]]]
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
elif False:
    DeliveryPipelineSerialPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineArgs:
    def __init__(__self__, *,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]]:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageArgs']]]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageArgsDict(TypedDict):
        deploy_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgsDict']]]]
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        strategy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgsDict']]
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        target_id: NotRequired[pulumi.Input[str]]
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
elif False:
    DeliveryPipelineSerialPipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageArgs:
    def __init__(__self__, *,
                 deploy_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']] = None,
                 target_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs'] strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param pulumi.Input[str] target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        if deploy_parameters is not None:
            pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]]:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @deploy_parameters.setter
    def deploy_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageDeployParameterArgs']]]]):
        pulumi.set(self, "deploy_parameters", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']]:
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[str]]:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_id", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageDeployParameterArgsDict(TypedDict):
        values: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        match_target_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
elif False:
    DeliveryPipelineSerialPipelineStageDeployParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageDeployParameterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 match_target_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Required. Values are deploy parameters in key-value pairs.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        pulumi.set(__self__, "values", values)
        if match_target_labels is not None:
            pulumi.set(__self__, "match_target_labels", match_target_labels)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Required. Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")

    @match_target_labels.setter
    def match_target_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_target_labels", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyArgsDict(TypedDict):
        canary: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict']]
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        standard: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict']]
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyArgs:
    def __init__(__self__, *,
                 canary: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']] = None,
                 standard: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs'] canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs'] standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        if canary is not None:
            pulumi.set(__self__, "canary", canary)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']]:
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @canary.setter
    def canary(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryArgs']]):
        pulumi.set(self, "canary", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']]:
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardArgs']]):
        pulumi.set(self, "standard", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict(TypedDict):
        canary_deployment: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict']]
        """
        Configures the progressive based deployment for a Target.
        """
        custom_canary_deployment: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict']]
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        runtime_config: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict']]
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryArgs:
    def __init__(__self__, *,
                 canary_deployment: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']] = None,
                 custom_canary_deployment: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']] = None,
                 runtime_config: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs'] canary_deployment: Configures the progressive based deployment for a Target.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs'] custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs'] runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        if canary_deployment is not None:
            pulumi.set(__self__, "canary_deployment", canary_deployment)
        if custom_canary_deployment is not None:
            pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @canary_deployment.setter
    def canary_deployment(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs']]):
        pulumi.set(self, "canary_deployment", value)

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @custom_canary_deployment.setter
    def custom_canary_deployment(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs']]):
        pulumi.set(self, "custom_canary_deployment", value)

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']]:
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")

    @runtime_config.setter
    def runtime_config(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs']]):
        pulumi.set(self, "runtime_config", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict(TypedDict):
        percentages: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        verify: NotRequired[pulumi.Input[bool]]
        """
        Whether to run verify tests after each percentage deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentArgs:
    def __init__(__self__, *,
                 percentages: pulumi.Input[Sequence[pulumi.Input[int]]],
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] percentages: Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs'] predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        :param pulumi.Input[bool] verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Required. The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @percentages.setter
    def percentages(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "percentages", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCanaryDeploymentPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict(TypedDict):
        phase_configs: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict']]]
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentArgs:
    def __init__(__self__, *,
                 phase_configs: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]] phase_configs: Required. Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]:
        """
        Required. Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")

    @phase_configs.setter
    def phase_configs(self, value: pulumi.Input[Sequence[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs']]]):
        pulumi.set(self, "phase_configs", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict(TypedDict):
        percentage: pulumi.Input[int]
        """
        Required. Percentage deployment for the phase.
        """
        phase_id: pulumi.Input[str]
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        verify: NotRequired[pulumi.Input[bool]]
        """
        Whether to run verify tests after the deployment.

        - - -
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigArgs:
    def __init__(__self__, *,
                 percentage: pulumi.Input[int],
                 phase_id: pulumi.Input[str],
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] percentage: Required. Percentage deployment for the phase.
        :param pulumi.Input[str] phase_id: Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs'] predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param pulumi.Input[bool] verify: Whether to run verify tests after the deployment.
               
               - - -
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[int]:
        """
        Required. Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> pulumi.Input[str]:
        """
        Required. The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^a-z?$`.
        """
        return pulumi.get(self, "phase_id")

    @phase_id.setter
    def phase_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "phase_id", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, postdeploy job will not be present for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, predeploy job will not be present for this phase.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to run verify tests after the deployment.

        - - -
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryCustomCanaryDeploymentPhaseConfigPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict(TypedDict):
        cloud_run: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict']]
        """
        Cloud Run runtime configuration.
        """
        kubernetes: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict']]
        """
        Kubernetes runtime configuration.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigArgs:
    def __init__(__self__, *,
                 cloud_run: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']] = None,
                 kubernetes: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs'] cloud_run: Cloud Run runtime configuration.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs'] kubernetes: Kubernetes runtime configuration.
        """
        if cloud_run is not None:
            pulumi.set(__self__, "cloud_run", cloud_run)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']]:
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @cloud_run.setter
    def cloud_run(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs']]):
        pulumi.set(self, "cloud_run", value)

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']]:
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs']]):
        pulumi.set(self, "kubernetes", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict(TypedDict):
        automatic_traffic_control: NotRequired[pulumi.Input[bool]]
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        canary_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        prior_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        stable_revision_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigCloudRunArgs:
    def __init__(__self__, *,
                 automatic_traffic_control: Optional[pulumi.Input[bool]] = None,
                 canary_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prior_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stable_revision_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] canary_revision_tags: Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prior_revision_tags: Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stable_revision_tags: Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        if automatic_traffic_control is not None:
            pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)
        if canary_revision_tags is not None:
            pulumi.set(__self__, "canary_revision_tags", canary_revision_tags)
        if prior_revision_tags is not None:
            pulumi.set(__self__, "prior_revision_tags", prior_revision_tags)
        if stable_revision_tags is not None:
            pulumi.set(__self__, "stable_revision_tags", stable_revision_tags)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")

    @automatic_traffic_control.setter
    def automatic_traffic_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_traffic_control", value)

    @property
    @pulumi.getter(name="canaryRevisionTags")
    def canary_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of tags that are added to the canary revision while the canary phase is in progress.
        """
        return pulumi.get(self, "canary_revision_tags")

    @canary_revision_tags.setter
    def canary_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "canary_revision_tags", value)

    @property
    @pulumi.getter(name="priorRevisionTags")
    def prior_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of tags that are added to the prior revision while the canary phase is in progress.
        """
        return pulumi.get(self, "prior_revision_tags")

    @prior_revision_tags.setter
    def prior_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prior_revision_tags", value)

    @property
    @pulumi.getter(name="stableRevisionTags")
    def stable_revision_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of tags that are added to the final stable revision when the stable phase is applied.
        """
        return pulumi.get(self, "stable_revision_tags")

    @stable_revision_tags.setter
    def stable_revision_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stable_revision_tags", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict(TypedDict):
        gateway_service_mesh: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict']]
        """
        Kubernetes Gateway API service mesh configuration.
        """
        service_networking: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict']]
        """
        Kubernetes Service networking configuration.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesArgs:
    def __init__(__self__, *,
                 gateway_service_mesh: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']] = None,
                 service_networking: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs'] gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs'] service_networking: Kubernetes Service networking configuration.
        """
        if gateway_service_mesh is not None:
            pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        if service_networking is not None:
            pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']]:
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @gateway_service_mesh.setter
    def gateway_service_mesh(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs']]):
        pulumi.set(self, "gateway_service_mesh", value)

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']]:
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")

    @service_networking.setter
    def service_networking(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs']]):
        pulumi.set(self, "service_networking", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict(TypedDict):
        deployment: pulumi.Input[str]
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        http_route: pulumi.Input[str]
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        service: pulumi.Input[str]
        """
        Required. Name of the Kubernetes Service.
        """
        pod_selector_label: NotRequired[pulumi.Input[str]]
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        route_update_wait_time: NotRequired[pulumi.Input[str]]
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        stable_cutback_duration: NotRequired[pulumi.Input[str]]
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesGatewayServiceMeshArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[str],
                 http_route: pulumi.Input[str],
                 service: pulumi.Input[str],
                 pod_selector_label: Optional[pulumi.Input[str]] = None,
                 route_update_wait_time: Optional[pulumi.Input[str]] = None,
                 stable_cutback_duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param pulumi.Input[str] http_route: Required. Name of the Gateway API HTTPRoute.
        :param pulumi.Input[str] service: Required. Name of the Kubernetes Service.
        :param pulumi.Input[str] pod_selector_label: Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        :param pulumi.Input[str] route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        :param pulumi.Input[str] stable_cutback_duration: Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "service", service)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)
        if route_update_wait_time is not None:
            pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)
        if stable_cutback_duration is not None:
            pulumi.set(__self__, "stable_cutback_duration", stable_cutback_duration)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> pulumi.Input[str]:
        """
        Required. Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The label to use when selecting Pods for the Deployment and Service resources. This label must already be present in both resources.
        """
        return pulumi.get(self, "pod_selector_label")

    @pod_selector_label.setter
    def pod_selector_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_selector_label", value)

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @route_update_wait_time.setter
    def route_update_wait_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_update_wait_time", value)

    @property
    @pulumi.getter(name="stableCutbackDuration")
    def stable_cutback_duration(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The amount of time to migrate traffic back from the canary Service to the original Service during the stable phase deployment. If specified, must be between 15s and 3600s. If unspecified, there is no cutback time.
        """
        return pulumi.get(self, "stable_cutback_duration")

    @stable_cutback_duration.setter
    def stable_cutback_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stable_cutback_duration", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict(TypedDict):
        deployment: pulumi.Input[str]
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        service: pulumi.Input[str]
        """
        Required. Name of the Kubernetes Service.
        """
        disable_pod_overprovisioning: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        pod_selector_label: NotRequired[pulumi.Input[str]]
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyCanaryRuntimeConfigKubernetesServiceNetworkingArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[str],
                 service: pulumi.Input[str],
                 disable_pod_overprovisioning: Optional[pulumi.Input[bool]] = None,
                 pod_selector_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deployment: Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param pulumi.Input[str] service: Required. Name of the Kubernetes Service.
        :param pulumi.Input[bool] disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        :param pulumi.Input[str] pod_selector_label: Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "service", service)
        if disable_pod_overprovisioning is not None:
            pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)
        if pod_selector_label is not None:
            pulumi.set(__self__, "pod_selector_label", pod_selector_label)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        Required. Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Required. Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @disable_pod_overprovisioning.setter
    def disable_pod_overprovisioning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_pod_overprovisioning", value)

    @property
    @pulumi.getter(name="podSelectorLabel")
    def pod_selector_label(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The label to use when selecting Pods for the Deployment resource. This label must already be present in the Deployment.
        """
        return pulumi.get(self, "pod_selector_label")

    @pod_selector_label.setter
    def pod_selector_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_selector_label", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict(TypedDict):
        postdeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict']]
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        predeploy: NotRequired[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict']]
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        verify: NotRequired[pulumi.Input[bool]]
        """
        Whether to verify a deployment.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardArgs:
    def __init__(__self__, *,
                 postdeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs'] predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param pulumi.Input[bool] verify: Whether to verify a deployment.
        """
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']]:
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
elif False:
    DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryPipelineSerialPipelineStageStrategyStandardPredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


if not MYPY:
    class TargetAnthosClusterArgsDict(TypedDict):
        membership: NotRequired[pulumi.Input[str]]
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
elif False:
    TargetAnthosClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetAnthosClusterArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[str]]:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "membership", value)


if not MYPY:
    class TargetCustomTargetArgsDict(TypedDict):
        custom_target_type: pulumi.Input[str]
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
elif False:
    TargetCustomTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetCustomTargetArgs:
    def __init__(__self__, *,
                 custom_target_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] custom_target_type: Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        pulumi.set(__self__, "custom_target_type", custom_target_type)

    @property
    @pulumi.getter(name="customTargetType")
    def custom_target_type(self) -> pulumi.Input[str]:
        """
        Required. The name of the CustomTargetType. Format must be `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
        """
        return pulumi.get(self, "custom_target_type")

    @custom_target_type.setter
    def custom_target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_target_type", value)


if not MYPY:
    class TargetExecutionConfigArgsDict(TypedDict):
        usages: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Required. Usages when this configuration should be applied.
        """
        artifact_storage: NotRequired[pulumi.Input[str]]
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        execution_timeout: NotRequired[pulumi.Input[str]]
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        service_account: NotRequired[pulumi.Input[str]]
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        verbose: NotRequired[pulumi.Input[bool]]
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        worker_pool: NotRequired[pulumi.Input[str]]
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
elif False:
    TargetExecutionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetExecutionConfigArgs:
    def __init__(__self__, *,
                 usages: pulumi.Input[Sequence[pulumi.Input[str]]],
                 artifact_storage: Optional[pulumi.Input[str]] = None,
                 execution_timeout: Optional[pulumi.Input[str]] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 verbose: Optional[pulumi.Input[bool]] = None,
                 worker_pool: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usages: Required. Usages when this configuration should be applied.
        :param pulumi.Input[str] artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param pulumi.Input[str] execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param pulumi.Input[str] service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param pulumi.Input[bool] verbose: Optional. If true, additional logging will be enabled when running builds in this execution environment.
        :param pulumi.Input[str] worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "usages", usages)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if execution_timeout is not None:
            pulumi.set(__self__, "execution_timeout", execution_timeout)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)
        if worker_pool is not None:
            pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter
    def usages(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required. Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "usages", value)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @artifact_storage.setter
    def artifact_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_storage", value)

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @execution_timeout.setter
    def execution_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_timeout", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def verbose(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If true, additional logging will be enabled when running builds in this execution environment.
        """
        return pulumi.get(self, "verbose")

    @verbose.setter
    def verbose(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verbose", value)

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")

    @worker_pool.setter
    def worker_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "worker_pool", value)


if not MYPY:
    class TargetGkeArgsDict(TypedDict):
        cluster: NotRequired[pulumi.Input[str]]
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        internal_ip: NotRequired[pulumi.Input[bool]]
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        proxy_url: NotRequired[pulumi.Input[str]]
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
elif False:
    TargetGkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGkeArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[str]] = None,
                 internal_ip: Optional[pulumi.Input[bool]] = None,
                 proxy_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        :param pulumi.Input[bool] internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        :param pulumi.Input[str] proxy_url: Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. If set, used to configure a [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy) to the Kubernetes server.
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_url", value)


if not MYPY:
    class TargetIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    TargetIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TargetIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    TargetIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TargetMultiTargetArgsDict(TypedDict):
        target_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Required. The target_ids of this multiTarget.
        """
elif False:
    TargetMultiTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetMultiTargetArgs:
    def __init__(__self__, *,
                 target_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ids: Required. The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required. The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_ids", value)


if not MYPY:
    class TargetRunArgsDict(TypedDict):
        location: pulumi.Input[str]
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
elif False:
    TargetRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetRunArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str]):
        """
        :param pulumi.Input[str] location: Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        Required. The location where the Cloud Run Service should be located. Format is `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)


