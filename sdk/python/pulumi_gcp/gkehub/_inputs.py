# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FeatureFleetDefaultMemberConfigArgs',
    'FeatureFleetDefaultMemberConfigArgsDict',
    'FeatureFleetDefaultMemberConfigConfigmanagementArgs',
    'FeatureFleetDefaultMemberConfigConfigmanagementArgsDict',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgsDict',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgsDict',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs',
    'FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgsDict',
    'FeatureFleetDefaultMemberConfigMeshArgs',
    'FeatureFleetDefaultMemberConfigMeshArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs',
    'FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict',
    'FeatureIamBindingConditionArgs',
    'FeatureIamBindingConditionArgsDict',
    'FeatureIamMemberConditionArgs',
    'FeatureIamMemberConditionArgsDict',
    'FeatureMembershipConfigmanagementArgs',
    'FeatureMembershipConfigmanagementArgsDict',
    'FeatureMembershipConfigmanagementBinauthzArgs',
    'FeatureMembershipConfigmanagementBinauthzArgsDict',
    'FeatureMembershipConfigmanagementConfigSyncArgs',
    'FeatureMembershipConfigmanagementConfigSyncArgsDict',
    'FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs',
    'FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgsDict',
    'FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs',
    'FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgsDict',
    'FeatureMembershipConfigmanagementConfigSyncGitArgs',
    'FeatureMembershipConfigmanagementConfigSyncGitArgsDict',
    'FeatureMembershipConfigmanagementConfigSyncOciArgs',
    'FeatureMembershipConfigmanagementConfigSyncOciArgsDict',
    'FeatureMembershipConfigmanagementHierarchyControllerArgs',
    'FeatureMembershipConfigmanagementHierarchyControllerArgsDict',
    'FeatureMembershipConfigmanagementPolicyControllerArgs',
    'FeatureMembershipConfigmanagementPolicyControllerArgsDict',
    'FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs',
    'FeatureMembershipConfigmanagementPolicyControllerMonitoringArgsDict',
    'FeatureMembershipMeshArgs',
    'FeatureMembershipMeshArgsDict',
    'FeatureMembershipPolicycontrollerArgs',
    'FeatureMembershipPolicycontrollerArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs',
    'FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict',
    'FeatureResourceStateArgs',
    'FeatureResourceStateArgsDict',
    'FeatureSpecArgs',
    'FeatureSpecArgsDict',
    'FeatureSpecClusterupgradeArgs',
    'FeatureSpecClusterupgradeArgsDict',
    'FeatureSpecClusterupgradeGkeUpgradeOverrideArgs',
    'FeatureSpecClusterupgradeGkeUpgradeOverrideArgsDict',
    'FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs',
    'FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgsDict',
    'FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs',
    'FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgsDict',
    'FeatureSpecClusterupgradePostConditionsArgs',
    'FeatureSpecClusterupgradePostConditionsArgsDict',
    'FeatureSpecFleetobservabilityArgs',
    'FeatureSpecFleetobservabilityArgsDict',
    'FeatureSpecFleetobservabilityLoggingConfigArgs',
    'FeatureSpecFleetobservabilityLoggingConfigArgsDict',
    'FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs',
    'FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgsDict',
    'FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs',
    'FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgsDict',
    'FeatureSpecMulticlusteringressArgs',
    'FeatureSpecMulticlusteringressArgsDict',
    'FeatureStateArgs',
    'FeatureStateArgsDict',
    'FeatureStateStateArgs',
    'FeatureStateStateArgsDict',
    'FleetDefaultClusterConfigArgs',
    'FleetDefaultClusterConfigArgsDict',
    'FleetDefaultClusterConfigBinaryAuthorizationConfigArgs',
    'FleetDefaultClusterConfigBinaryAuthorizationConfigArgsDict',
    'FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs',
    'FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgsDict',
    'FleetDefaultClusterConfigSecurityPostureConfigArgs',
    'FleetDefaultClusterConfigSecurityPostureConfigArgsDict',
    'FleetStateArgs',
    'FleetStateArgsDict',
    'MembershipAuthorityArgs',
    'MembershipAuthorityArgsDict',
    'MembershipBindingStateArgs',
    'MembershipBindingStateArgsDict',
    'MembershipEndpointArgs',
    'MembershipEndpointArgsDict',
    'MembershipEndpointGkeClusterArgs',
    'MembershipEndpointGkeClusterArgsDict',
    'MembershipIamBindingConditionArgs',
    'MembershipIamBindingConditionArgsDict',
    'MembershipIamMemberConditionArgs',
    'MembershipIamMemberConditionArgsDict',
    'MembershipRbacRoleBindingRoleArgs',
    'MembershipRbacRoleBindingRoleArgsDict',
    'MembershipRbacRoleBindingStateArgs',
    'MembershipRbacRoleBindingStateArgsDict',
    'NamespaceStateArgs',
    'NamespaceStateArgsDict',
    'ScopeIamBindingConditionArgs',
    'ScopeIamBindingConditionArgsDict',
    'ScopeIamMemberConditionArgs',
    'ScopeIamMemberConditionArgsDict',
    'ScopeRbacRoleBindingRoleArgs',
    'ScopeRbacRoleBindingRoleArgsDict',
    'ScopeRbacRoleBindingStateArgs',
    'ScopeRbacRoleBindingStateArgsDict',
    'ScopeStateArgs',
    'ScopeStateArgsDict',
]

MYPY = False

if not MYPY:
    class FeatureFleetDefaultMemberConfigArgsDict(TypedDict):
        configmanagement: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementArgsDict']]
        """
        Config Management spec
        Structure is documented below.
        """
        mesh: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigMeshArgsDict']]
        """
        Service Mesh spec
        Structure is documented below.
        """
        policycontroller: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerArgsDict']]
        """
        Policy Controller spec
        Structure is documented below.
        """
elif False:
    FeatureFleetDefaultMemberConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigArgs:
    def __init__(__self__, *,
                 configmanagement: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementArgs']] = None,
                 mesh: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigMeshArgs']] = None,
                 policycontroller: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerArgs']] = None):
        """
        :param pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementArgs'] configmanagement: Config Management spec
               Structure is documented below.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigMeshArgs'] mesh: Service Mesh spec
               Structure is documented below.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerArgs'] policycontroller: Policy Controller spec
               Structure is documented below.
        """
        if configmanagement is not None:
            pulumi.set(__self__, "configmanagement", configmanagement)
        if mesh is not None:
            pulumi.set(__self__, "mesh", mesh)
        if policycontroller is not None:
            pulumi.set(__self__, "policycontroller", policycontroller)

    @property
    @pulumi.getter
    def configmanagement(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementArgs']]:
        """
        Config Management spec
        Structure is documented below.
        """
        return pulumi.get(self, "configmanagement")

    @configmanagement.setter
    def configmanagement(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementArgs']]):
        pulumi.set(self, "configmanagement", value)

    @property
    @pulumi.getter
    def mesh(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigMeshArgs']]:
        """
        Service Mesh spec
        Structure is documented below.
        """
        return pulumi.get(self, "mesh")

    @mesh.setter
    def mesh(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigMeshArgs']]):
        pulumi.set(self, "mesh", value)

    @property
    @pulumi.getter
    def policycontroller(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerArgs']]:
        """
        Policy Controller spec
        Structure is documented below.
        """
        return pulumi.get(self, "policycontroller")

    @policycontroller.setter
    def policycontroller(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerArgs']]):
        pulumi.set(self, "policycontroller", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigConfigmanagementArgsDict(TypedDict):
        config_sync: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgsDict']]
        """
        ConfigSync configuration for the cluster
        Structure is documented below.
        """
        management: NotRequired[pulumi.Input[builtins.str]]
        """
        Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
        Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of Config Sync installed
        """
elif False:
    FeatureFleetDefaultMemberConfigConfigmanagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigConfigmanagementArgs:
    def __init__(__self__, *,
                 config_sync: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs']] = None,
                 management: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs'] config_sync: ConfigSync configuration for the cluster
               Structure is documented below.
        :param pulumi.Input[builtins.str] management: Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
               Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        :param pulumi.Input[builtins.str] version: Version of Config Sync installed
        """
        if config_sync is not None:
            pulumi.set(__self__, "config_sync", config_sync)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="configSync")
    def config_sync(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs']]:
        """
        ConfigSync configuration for the cluster
        Structure is documented below.
        """
        return pulumi.get(self, "config_sync")

    @config_sync.setter
    def config_sync(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs']]):
        pulumi.set(self, "config_sync", value)

    @property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
        Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "management", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of Config Sync installed
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        """
        git: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgsDict']]
        """
        Git repo configuration for the cluster
        Structure is documented below.
        """
        metrics_gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The Email of the Google Cloud Service Account (GSA) used for exporting Config Sync metrics to Cloud Monitoring. The GSA should have the Monitoring Metric Writer(roles/monitoring.metricWriter) IAM role. The Kubernetes ServiceAccount `default` in the namespace `config-management-monitoring` should be bound to the GSA.
        """
        oci: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgsDict']]
        """
        OCI repo configuration for the cluster
        Structure is documented below.
        """
        prevent_drift: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to true to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        """
        source_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Config Sync Repo is in hierarchical or unstructured mode
        """
elif False:
    FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 git: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs']] = None,
                 metrics_gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 oci: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs']] = None,
                 prevent_drift: Optional[pulumi.Input[builtins.bool]] = None,
                 source_format: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs'] git: Git repo configuration for the cluster
               Structure is documented below.
        :param pulumi.Input[builtins.str] metrics_gcp_service_account_email: The Email of the Google Cloud Service Account (GSA) used for exporting Config Sync metrics to Cloud Monitoring. The GSA should have the Monitoring Metric Writer(roles/monitoring.metricWriter) IAM role. The Kubernetes ServiceAccount `default` in the namespace `config-management-monitoring` should be bound to the GSA.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs'] oci: OCI repo configuration for the cluster
               Structure is documented below.
        :param pulumi.Input[builtins.bool] prevent_drift: Set to true to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        :param pulumi.Input[builtins.str] source_format: Specifies whether the Config Sync Repo is in hierarchical or unstructured mode
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if metrics_gcp_service_account_email is not None:
            pulumi.set(__self__, "metrics_gcp_service_account_email", metrics_gcp_service_account_email)
        if oci is not None:
            pulumi.set(__self__, "oci", oci)
        if prevent_drift is not None:
            pulumi.set(__self__, "prevent_drift", prevent_drift)
        if source_format is not None:
            pulumi.set(__self__, "source_format", source_format)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs']]:
        """
        Git repo configuration for the cluster
        Structure is documented below.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter(name="metricsGcpServiceAccountEmail")
    def metrics_gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Email of the Google Cloud Service Account (GSA) used for exporting Config Sync metrics to Cloud Monitoring. The GSA should have the Monitoring Metric Writer(roles/monitoring.metricWriter) IAM role. The Kubernetes ServiceAccount `default` in the namespace `config-management-monitoring` should be bound to the GSA.
        """
        return pulumi.get(self, "metrics_gcp_service_account_email")

    @metrics_gcp_service_account_email.setter
    def metrics_gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metrics_gcp_service_account_email", value)

    @property
    @pulumi.getter
    def oci(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs']]:
        """
        OCI repo configuration for the cluster
        Structure is documented below.
        """
        return pulumi.get(self, "oci")

    @oci.setter
    def oci(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs']]):
        pulumi.set(self, "oci", value)

    @property
    @pulumi.getter(name="preventDrift")
    def prevent_drift(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to true to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        """
        return pulumi.get(self, "prevent_drift")

    @prevent_drift.setter
    def prevent_drift(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "prevent_drift", value)

    @property
    @pulumi.getter(name="sourceFormat")
    def source_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Config Sync Repo is in hierarchical or unstructured mode
        """
        return pulumi.get(self, "source_format")

    @source_format.setter
    def source_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_format", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgsDict(TypedDict):
        secret_type: pulumi.Input[builtins.str]
        """
        Type of secret configured for access to the Git repo
        """
        gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        """
        https_proxy: NotRequired[pulumi.Input[builtins.str]]
        """
        URL for the HTTPS Proxy to be used when communicating with the Git repo
        """
        policy_dir: NotRequired[pulumi.Input[builtins.str]]
        """
        The path within the Git repository that represents the top level of the repo to sync
        """
        sync_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        The branch of the repository to sync from. Default: master
        """
        sync_repo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the Git repository to use as the source of truth
        """
        sync_rev: NotRequired[pulumi.Input[builtins.str]]
        """
        Git revision (tag or hash) to check out. Default HEAD
        """
        sync_wait_secs: NotRequired[pulumi.Input[builtins.str]]
        """
        Period in seconds between consecutive syncs. Default: 15
        """
elif False:
    FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncGitArgs:
    def __init__(__self__, *,
                 secret_type: pulumi.Input[builtins.str],
                 gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 https_proxy: Optional[pulumi.Input[builtins.str]] = None,
                 policy_dir: Optional[pulumi.Input[builtins.str]] = None,
                 sync_branch: Optional[pulumi.Input[builtins.str]] = None,
                 sync_repo: Optional[pulumi.Input[builtins.str]] = None,
                 sync_rev: Optional[pulumi.Input[builtins.str]] = None,
                 sync_wait_secs: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] secret_type: Type of secret configured for access to the Git repo
        :param pulumi.Input[builtins.str] gcp_service_account_email: The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        :param pulumi.Input[builtins.str] https_proxy: URL for the HTTPS Proxy to be used when communicating with the Git repo
        :param pulumi.Input[builtins.str] policy_dir: The path within the Git repository that represents the top level of the repo to sync
        :param pulumi.Input[builtins.str] sync_branch: The branch of the repository to sync from. Default: master
        :param pulumi.Input[builtins.str] sync_repo: The URL of the Git repository to use as the source of truth
        :param pulumi.Input[builtins.str] sync_rev: Git revision (tag or hash) to check out. Default HEAD
        :param pulumi.Input[builtins.str] sync_wait_secs: Period in seconds between consecutive syncs. Default: 15
        """
        pulumi.set(__self__, "secret_type", secret_type)
        if gcp_service_account_email is not None:
            pulumi.set(__self__, "gcp_service_account_email", gcp_service_account_email)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if policy_dir is not None:
            pulumi.set(__self__, "policy_dir", policy_dir)
        if sync_branch is not None:
            pulumi.set(__self__, "sync_branch", sync_branch)
        if sync_repo is not None:
            pulumi.set(__self__, "sync_repo", sync_repo)
        if sync_rev is not None:
            pulumi.set(__self__, "sync_rev", sync_rev)
        if sync_wait_secs is not None:
            pulumi.set(__self__, "sync_wait_secs", sync_wait_secs)

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of secret configured for access to the Git repo
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_type", value)

    @property
    @pulumi.getter(name="gcpServiceAccountEmail")
    def gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        """
        return pulumi.get(self, "gcp_service_account_email")

    @gcp_service_account_email.setter
    def gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gcp_service_account_email", value)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL for the HTTPS Proxy to be used when communicating with the Git repo
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "https_proxy", value)

    @property
    @pulumi.getter(name="policyDir")
    def policy_dir(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path within the Git repository that represents the top level of the repo to sync
        """
        return pulumi.get(self, "policy_dir")

    @policy_dir.setter
    def policy_dir(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_dir", value)

    @property
    @pulumi.getter(name="syncBranch")
    def sync_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The branch of the repository to sync from. Default: master
        """
        return pulumi.get(self, "sync_branch")

    @sync_branch.setter
    def sync_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_branch", value)

    @property
    @pulumi.getter(name="syncRepo")
    def sync_repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the Git repository to use as the source of truth
        """
        return pulumi.get(self, "sync_repo")

    @sync_repo.setter
    def sync_repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_repo", value)

    @property
    @pulumi.getter(name="syncRev")
    def sync_rev(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Git revision (tag or hash) to check out. Default HEAD
        """
        return pulumi.get(self, "sync_rev")

    @sync_rev.setter
    def sync_rev(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_rev", value)

    @property
    @pulumi.getter(name="syncWaitSecs")
    def sync_wait_secs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Period in seconds between consecutive syncs. Default: 15
        """
        return pulumi.get(self, "sync_wait_secs")

    @sync_wait_secs.setter
    def sync_wait_secs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_wait_secs", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgsDict(TypedDict):
        secret_type: pulumi.Input[builtins.str]
        """
        Type of secret configured for access to the Git repo
        """
        gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        """
        policy_dir: NotRequired[pulumi.Input[builtins.str]]
        """
        The absolute path of the directory that contains the local resources. Default: the root directory of the image
        """
        sync_repo: NotRequired[pulumi.Input[builtins.str]]
        """
        The OCI image repository URL for the package to sync from
        """
        sync_wait_secs: NotRequired[pulumi.Input[builtins.str]]
        """
        Period in seconds between consecutive syncs. Default: 15
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        (Optional, Deprecated)
        Version of Config Sync installed

        > **Warning:** The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.
        """
elif False:
    FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigConfigmanagementConfigSyncOciArgs:
    def __init__(__self__, *,
                 secret_type: pulumi.Input[builtins.str],
                 gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 policy_dir: Optional[pulumi.Input[builtins.str]] = None,
                 sync_repo: Optional[pulumi.Input[builtins.str]] = None,
                 sync_wait_secs: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] secret_type: Type of secret configured for access to the Git repo
        :param pulumi.Input[builtins.str] gcp_service_account_email: The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        :param pulumi.Input[builtins.str] policy_dir: The absolute path of the directory that contains the local resources. Default: the root directory of the image
        :param pulumi.Input[builtins.str] sync_repo: The OCI image repository URL for the package to sync from
        :param pulumi.Input[builtins.str] sync_wait_secs: Period in seconds between consecutive syncs. Default: 15
        :param pulumi.Input[builtins.str] version: (Optional, Deprecated)
               Version of Config Sync installed
               
               > **Warning:** The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.
        """
        pulumi.set(__self__, "secret_type", secret_type)
        if gcp_service_account_email is not None:
            pulumi.set(__self__, "gcp_service_account_email", gcp_service_account_email)
        if policy_dir is not None:
            pulumi.set(__self__, "policy_dir", policy_dir)
        if sync_repo is not None:
            pulumi.set(__self__, "sync_repo", sync_repo)
        if sync_wait_secs is not None:
            pulumi.set(__self__, "sync_wait_secs", sync_wait_secs)
        if version is not None:
            warnings.warn("""The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.""", DeprecationWarning)
            pulumi.log.warn("""version is deprecated: The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.""")
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of secret configured for access to the Git repo
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_type", value)

    @property
    @pulumi.getter(name="gcpServiceAccountEmail")
    def gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Google Cloud Service Account Email used for auth when secretType is gcpServiceAccount
        """
        return pulumi.get(self, "gcp_service_account_email")

    @gcp_service_account_email.setter
    def gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gcp_service_account_email", value)

    @property
    @pulumi.getter(name="policyDir")
    def policy_dir(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The absolute path of the directory that contains the local resources. Default: the root directory of the image
        """
        return pulumi.get(self, "policy_dir")

    @policy_dir.setter
    def policy_dir(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_dir", value)

    @property
    @pulumi.getter(name="syncRepo")
    def sync_repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OCI image repository URL for the package to sync from
        """
        return pulumi.get(self, "sync_repo")

    @sync_repo.setter
    def sync_repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_repo", value)

    @property
    @pulumi.getter(name="syncWaitSecs")
    def sync_wait_secs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Period in seconds between consecutive syncs. Default: 15
        """
        return pulumi.get(self, "sync_wait_secs")

    @sync_wait_secs.setter
    def sync_wait_secs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_wait_secs", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.""")
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Optional, Deprecated)
        Version of Config Sync installed

        > **Warning:** The `configmanagement.config_sync.oci.version` field is deprecated and will be removed in a future major release. Please use `configmanagement.version` field to specify the version of Config Sync installed instead.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigMeshArgsDict(TypedDict):
        management: pulumi.Input[builtins.str]
        """
        Whether to automatically manage Service Mesh
        Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        """
elif False:
    FeatureFleetDefaultMemberConfigMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigMeshArgs:
    def __init__(__self__, *,
                 management: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] management: Whether to automatically manage Service Mesh
               Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        """
        pulumi.set(__self__, "management", management)

    @property
    @pulumi.getter
    def management(self) -> pulumi.Input[builtins.str]:
        """
        Whether to automatically manage Service Mesh
        Possible values are: `MANAGEMENT_UNSPECIFIED`, `MANAGEMENT_AUTOMATIC`, `MANAGEMENT_MANUAL`.
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "management", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerArgsDict(TypedDict):
        policy_controller_hub_config: pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgsDict']
        """
        Configuration of Policy Controller
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures the version of Policy Controller
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerArgs:
    def __init__(__self__, *,
                 policy_controller_hub_config: pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs'],
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs'] policy_controller_hub_config: Configuration of Policy Controller
               Structure is documented below.
        :param pulumi.Input[builtins.str] version: Configures the version of Policy Controller
        """
        pulumi.set(__self__, "policy_controller_hub_config", policy_controller_hub_config)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="policyControllerHubConfig")
    def policy_controller_hub_config(self) -> pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs']:
        """
        Configuration of Policy Controller
        Structure is documented below.
        """
        return pulumi.get(self, "policy_controller_hub_config")

    @policy_controller_hub_config.setter
    def policy_controller_hub_config(self, value: pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs']):
        pulumi.set(self, "policy_controller_hub_config", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures the version of Policy Controller
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgsDict(TypedDict):
        install_spec: pulumi.Input[builtins.str]
        """
        Configures the mode of the Policy Controller installation
        Possible values are: `INSTALL_SPEC_UNSPECIFIED`, `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED`, `INSTALL_SPEC_DETACHED`.
        """
        audit_interval_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Interval for Policy Controller Audit scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        constraint_violation_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of audit violations to be stored in a constraint. If not set, the internal default of 20 will be used.
        """
        deployment_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict']]]]
        """
        Map of deployment configs to deployments ("admission", "audit", "mutation").
        Structure is documented below.
        """
        exemptable_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        log_denies_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Logs all denies and dry run failures.
        """
        monitoring: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict']]
        """
        Monitoring specifies the configuration of monitoring Policy Controller.
        Structure is documented below.
        """
        mutation_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the ability to mutate resources using Policy Controller.
        """
        policy_content: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict']]
        """
        Specifies the desired policy content on the cluster.
        Structure is documented below.
        """
        referential_rules_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigArgs:
    def __init__(__self__, *,
                 install_spec: pulumi.Input[builtins.str],
                 audit_interval_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 constraint_violation_limit: Optional[pulumi.Input[builtins.int]] = None,
                 deployment_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]] = None,
                 exemptable_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 log_denies_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 monitoring: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs']] = None,
                 mutation_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 policy_content: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']] = None,
                 referential_rules_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] install_spec: Configures the mode of the Policy Controller installation
               Possible values are: `INSTALL_SPEC_UNSPECIFIED`, `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED`, `INSTALL_SPEC_DETACHED`.
        :param pulumi.Input[builtins.int] audit_interval_seconds: Interval for Policy Controller Audit scans (in seconds). When set to 0, this disables audit functionality altogether.
        :param pulumi.Input[builtins.int] constraint_violation_limit: The maximum number of audit violations to be stored in a constraint. If not set, the internal default of 20 will be used.
        :param pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]] deployment_configs: Map of deployment configs to deployments ("admission", "audit", "mutation").
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exemptable_namespaces: The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        :param pulumi.Input[builtins.bool] log_denies_enabled: Logs all denies and dry run failures.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs'] monitoring: Monitoring specifies the configuration of monitoring Policy Controller.
               Structure is documented below.
        :param pulumi.Input[builtins.bool] mutation_enabled: Enables the ability to mutate resources using Policy Controller.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs'] policy_content: Specifies the desired policy content on the cluster.
               Structure is documented below.
        :param pulumi.Input[builtins.bool] referential_rules_enabled: Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        pulumi.set(__self__, "install_spec", install_spec)
        if audit_interval_seconds is not None:
            pulumi.set(__self__, "audit_interval_seconds", audit_interval_seconds)
        if constraint_violation_limit is not None:
            pulumi.set(__self__, "constraint_violation_limit", constraint_violation_limit)
        if deployment_configs is not None:
            pulumi.set(__self__, "deployment_configs", deployment_configs)
        if exemptable_namespaces is not None:
            pulumi.set(__self__, "exemptable_namespaces", exemptable_namespaces)
        if log_denies_enabled is not None:
            pulumi.set(__self__, "log_denies_enabled", log_denies_enabled)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if mutation_enabled is not None:
            pulumi.set(__self__, "mutation_enabled", mutation_enabled)
        if policy_content is not None:
            pulumi.set(__self__, "policy_content", policy_content)
        if referential_rules_enabled is not None:
            pulumi.set(__self__, "referential_rules_enabled", referential_rules_enabled)

    @property
    @pulumi.getter(name="installSpec")
    def install_spec(self) -> pulumi.Input[builtins.str]:
        """
        Configures the mode of the Policy Controller installation
        Possible values are: `INSTALL_SPEC_UNSPECIFIED`, `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED`, `INSTALL_SPEC_DETACHED`.
        """
        return pulumi.get(self, "install_spec")

    @install_spec.setter
    def install_spec(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "install_spec", value)

    @property
    @pulumi.getter(name="auditIntervalSeconds")
    def audit_interval_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interval for Policy Controller Audit scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        return pulumi.get(self, "audit_interval_seconds")

    @audit_interval_seconds.setter
    def audit_interval_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "audit_interval_seconds", value)

    @property
    @pulumi.getter(name="constraintViolationLimit")
    def constraint_violation_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of audit violations to be stored in a constraint. If not set, the internal default of 20 will be used.
        """
        return pulumi.get(self, "constraint_violation_limit")

    @constraint_violation_limit.setter
    def constraint_violation_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "constraint_violation_limit", value)

    @property
    @pulumi.getter(name="deploymentConfigs")
    def deployment_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]]:
        """
        Map of deployment configs to deployments ("admission", "audit", "mutation").
        Structure is documented below.
        """
        return pulumi.get(self, "deployment_configs")

    @deployment_configs.setter
    def deployment_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]]):
        pulumi.set(self, "deployment_configs", value)

    @property
    @pulumi.getter(name="exemptableNamespaces")
    def exemptable_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        return pulumi.get(self, "exemptable_namespaces")

    @exemptable_namespaces.setter
    def exemptable_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exemptable_namespaces", value)

    @property
    @pulumi.getter(name="logDeniesEnabled")
    def log_denies_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Logs all denies and dry run failures.
        """
        return pulumi.get(self, "log_denies_enabled")

    @log_denies_enabled.setter
    def log_denies_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_denies_enabled", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs']]:
        """
        Monitoring specifies the configuration of monitoring Policy Controller.
        Structure is documented below.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="mutationEnabled")
    def mutation_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the ability to mutate resources using Policy Controller.
        """
        return pulumi.get(self, "mutation_enabled")

    @mutation_enabled.setter
    def mutation_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mutation_enabled", value)

    @property
    @pulumi.getter(name="policyContent")
    def policy_content(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']]:
        """
        Specifies the desired policy content on the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "policy_content")

    @policy_content.setter
    def policy_content(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']]):
        pulumi.set(self, "policy_content", value)

    @property
    @pulumi.getter(name="referentialRulesEnabled")
    def referential_rules_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        return pulumi.get(self, "referential_rules_enabled")

    @referential_rules_enabled.setter
    def referential_rules_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "referential_rules_enabled", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict(TypedDict):
        component: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        container_resources: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict']]
        """
        Container resource requirements.
        Structure is documented below.
        """
        pod_affinity: NotRequired[pulumi.Input[builtins.str]]
        """
        Pod affinity configuration.
        Possible values are: `AFFINITY_UNSPECIFIED`, `NO_AFFINITY`, `ANTI_AFFINITY`.
        """
        pod_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict']]]]
        """
        Pod tolerations of node taints.
        Structure is documented below.
        """
        replica_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Pod replica count.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[builtins.str],
                 container_resources: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']] = None,
                 pod_affinity: Optional[pulumi.Input[builtins.str]] = None,
                 pod_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]] = None,
                 replica_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] component: The identifier for this object. Format specified above.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs'] container_resources: Container resource requirements.
               Structure is documented below.
        :param pulumi.Input[builtins.str] pod_affinity: Pod affinity configuration.
               Possible values are: `AFFINITY_UNSPECIFIED`, `NO_AFFINITY`, `ANTI_AFFINITY`.
        :param pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]] pod_tolerations: Pod tolerations of node taints.
               Structure is documented below.
        :param pulumi.Input[builtins.int] replica_count: Pod replica count.
        """
        pulumi.set(__self__, "component", component)
        if container_resources is not None:
            pulumi.set(__self__, "container_resources", container_resources)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_tolerations is not None:
            pulumi.set(__self__, "pod_tolerations", pod_tolerations)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter(name="containerResources")
    def container_resources(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']]:
        """
        Container resource requirements.
        Structure is documented below.
        """
        return pulumi.get(self, "container_resources")

    @container_resources.setter
    def container_resources(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']]):
        pulumi.set(self, "container_resources", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pod affinity configuration.
        Possible values are: `AFFINITY_UNSPECIFIED`, `NO_AFFINITY`, `ANTI_AFFINITY`.
        """
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podTolerations")
    def pod_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]]:
        """
        Pod tolerations of node taints.
        Structure is documented below.
        """
        return pulumi.get(self, "pod_tolerations")

    @pod_tolerations.setter
    def pod_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]]):
        pulumi.set(self, "pod_tolerations", value)

    @property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Pod replica count.
        """
        return pulumi.get(self, "replica_count")

    @replica_count.setter
    def replica_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_count", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict']]
        """
        Limits describes the maximum amount of compute resources allowed for use by the running container.
        Structure is documented below.
        """
        requests: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict']]
        """
        Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
        Structure is documented below.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']] = None,
                 requests: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']] = None):
        """
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed for use by the running container.
               Structure is documented below.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs'] requests: Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
               Structure is documented below.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']]:
        """
        Limits describes the maximum amount of compute resources allowed for use by the running container.
        Structure is documented below.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']]:
        """
        Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
        Structure is documented below.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[builtins.str]]
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Memory requirement expressed in Kubernetes resource units.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.str]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: CPU requirement expressed in Kubernetes resource units.
        :param pulumi.Input[builtins.str] memory: Memory requirement expressed in Kubernetes resource units.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Memory requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[builtins.str]]
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Memory requirement expressed in Kubernetes resource units.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.str]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: CPU requirement expressed in Kubernetes resource units.
        :param pulumi.Input[builtins.str] memory: Memory requirement expressed in Kubernetes resource units.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Memory requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint effect.
        """
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint key (not necessarily unique).
        """
        operator: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint value.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[builtins.str]] = None,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 operator: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] effect: Matches a taint effect.
        :param pulumi.Input[builtins.str] key: Matches a taint key (not necessarily unique).
        :param pulumi.Input[builtins.str] operator: Matches a taint operator.
        :param pulumi.Input[builtins.str] value: Matches a taint value.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint key (not necessarily unique).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict(TypedDict):
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the list of backends Policy Controller will export to. An empty list would effectively disable metrics export.
        Each value may be one of: `MONITORING_BACKEND_UNSPECIFIED`, `PROMETHEUS`, `CLOUD_MONITORING`.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigMonitoringArgs:
    def __init__(__self__, *,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] backends: Specifies the list of backends Policy Controller will export to. An empty list would effectively disable metrics export.
               Each value may be one of: `MONITORING_BACKEND_UNSPECIFIED`, `PROMETHEUS`, `CLOUD_MONITORING`.
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the list of backends Policy Controller will export to. An empty list would effectively disable metrics export.
        Each value may be one of: `MONITORING_BACKEND_UNSPECIFIED`, `PROMETHEUS`, `CLOUD_MONITORING`.
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "backends", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict(TypedDict):
        bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict']]]]
        """
        Configures which bundles to install and their corresponding install specs.
        Structure is documented below.
        """
        template_library: NotRequired[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict']]
        """
        Configures the installation of the Template Library.
        Structure is documented below.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentArgs:
    def __init__(__self__, *,
                 bundles: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]] = None,
                 template_library: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]] bundles: Configures which bundles to install and their corresponding install specs.
               Structure is documented below.
        :param pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs'] template_library: Configures the installation of the Template Library.
               Structure is documented below.
        """
        if bundles is not None:
            pulumi.set(__self__, "bundles", bundles)
        if template_library is not None:
            pulumi.set(__self__, "template_library", template_library)

    @property
    @pulumi.getter
    def bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]]:
        """
        Configures which bundles to install and their corresponding install specs.
        Structure is documented below.
        """
        return pulumi.get(self, "bundles")

    @bundles.setter
    def bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]]):
        pulumi.set(self, "bundles", value)

    @property
    @pulumi.getter(name="templateLibrary")
    def template_library(self) -> Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']]:
        """
        Configures the installation of the Template Library.
        Structure is documented below.
        """
        return pulumi.get(self, "template_library")

    @template_library.setter
    def template_library(self, value: Optional[pulumi.Input['FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']]):
        pulumi.set(self, "template_library", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict(TypedDict):
        bundle: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        exempted_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of namespaces to be exempted from the bundle.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs:
    def __init__(__self__, *,
                 bundle: pulumi.Input[builtins.str],
                 exempted_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] bundle: The identifier for this object. Format specified above.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exempted_namespaces: The set of namespaces to be exempted from the bundle.
        """
        pulumi.set(__self__, "bundle", bundle)
        if exempted_namespaces is not None:
            pulumi.set(__self__, "exempted_namespaces", exempted_namespaces)

    @property
    @pulumi.getter
    def bundle(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "bundle")

    @bundle.setter
    def bundle(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bundle", value)

    @property
    @pulumi.getter(name="exemptedNamespaces")
    def exempted_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of namespaces to be exempted from the bundle.
        """
        return pulumi.get(self, "exempted_namespaces")

    @exempted_namespaces.setter
    def exempted_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exempted_namespaces", value)


if not MYPY:
    class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict(TypedDict):
        installation: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures the manner in which the template library is installed on the cluster.
        Possible values are: `INSTALLATION_UNSPECIFIED`, `NOT_INSTALLED`, `ALL`.
        """
elif False:
    FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFleetDefaultMemberConfigPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs:
    def __init__(__self__, *,
                 installation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] installation: Configures the manner in which the template library is installed on the cluster.
               Possible values are: `INSTALLATION_UNSPECIFIED`, `NOT_INSTALLED`, `ALL`.
        """
        if installation is not None:
            pulumi.set(__self__, "installation", installation)

    @property
    @pulumi.getter
    def installation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures the manner in which the template library is installed on the cluster.
        Possible values are: `INSTALLATION_UNSPECIFIED`, `NOT_INSTALLED`, `ALL`.
        """
        return pulumi.get(self, "installation")

    @installation.setter
    def installation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation", value)


if not MYPY:
    class FeatureIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    FeatureIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FeatureIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    FeatureIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FeatureMembershipConfigmanagementArgsDict(TypedDict):
        binauthz: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementBinauthzArgsDict']]
        """
        (Optional, Deprecated)
        Binauthz configuration for the cluster. Structure is documented below.
        This field will be ignored and should not be set.
        """
        config_sync: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncArgsDict']]
        """
        Config Sync configuration for the cluster. Structure is documented below.
        """
        hierarchy_controller: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementHierarchyControllerArgsDict']]
        """
        Hierarchy Controller configuration for the cluster. Structure is documented below.
        Configuring Hierarchy Controller through the configmanagement feature is no longer recommended.
        Use open source Kubernetes [Hierarchical Namespace Controller (HNC)](https://github.com/kubernetes-sigs/hierarchical-namespaces) instead.
        Follow the [instructions](https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/migrate-hierarchy-controller)
        to migrate from Hierarchy Controller to HNC.
        """
        management: NotRequired[pulumi.Input[builtins.str]]
        """
        Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
        """
        policy_controller: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerArgsDict']]
        """
        Policy Controller configuration for the cluster. Structure is documented below.
        Configuring Policy Controller through the configmanagement feature is no longer recommended.
        Use the policycontroller feature instead.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of Config Sync installed.
        """
elif False:
    FeatureMembershipConfigmanagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementArgs:
    def __init__(__self__, *,
                 binauthz: Optional[pulumi.Input['FeatureMembershipConfigmanagementBinauthzArgs']] = None,
                 config_sync: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncArgs']] = None,
                 hierarchy_controller: Optional[pulumi.Input['FeatureMembershipConfigmanagementHierarchyControllerArgs']] = None,
                 management: Optional[pulumi.Input[builtins.str]] = None,
                 policy_controller: Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerArgs']] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['FeatureMembershipConfigmanagementBinauthzArgs'] binauthz: (Optional, Deprecated)
               Binauthz configuration for the cluster. Structure is documented below.
               This field will be ignored and should not be set.
        :param pulumi.Input['FeatureMembershipConfigmanagementConfigSyncArgs'] config_sync: Config Sync configuration for the cluster. Structure is documented below.
        :param pulumi.Input['FeatureMembershipConfigmanagementHierarchyControllerArgs'] hierarchy_controller: Hierarchy Controller configuration for the cluster. Structure is documented below.
               Configuring Hierarchy Controller through the configmanagement feature is no longer recommended.
               Use open source Kubernetes [Hierarchical Namespace Controller (HNC)](https://github.com/kubernetes-sigs/hierarchical-namespaces) instead.
               Follow the [instructions](https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/migrate-hierarchy-controller)
               to migrate from Hierarchy Controller to HNC.
        :param pulumi.Input[builtins.str] management: Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
        :param pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerArgs'] policy_controller: Policy Controller configuration for the cluster. Structure is documented below.
               Configuring Policy Controller through the configmanagement feature is no longer recommended.
               Use the policycontroller feature instead.
        :param pulumi.Input[builtins.str] version: Version of Config Sync installed.
        """
        if binauthz is not None:
            pulumi.set(__self__, "binauthz", binauthz)
        if config_sync is not None:
            pulumi.set(__self__, "config_sync", config_sync)
        if hierarchy_controller is not None:
            pulumi.set(__self__, "hierarchy_controller", hierarchy_controller)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if policy_controller is not None:
            pulumi.set(__self__, "policy_controller", policy_controller)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def binauthz(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementBinauthzArgs']]:
        """
        (Optional, Deprecated)
        Binauthz configuration for the cluster. Structure is documented below.
        This field will be ignored and should not be set.
        """
        return pulumi.get(self, "binauthz")

    @binauthz.setter
    def binauthz(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementBinauthzArgs']]):
        pulumi.set(self, "binauthz", value)

    @property
    @pulumi.getter(name="configSync")
    def config_sync(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncArgs']]:
        """
        Config Sync configuration for the cluster. Structure is documented below.
        """
        return pulumi.get(self, "config_sync")

    @config_sync.setter
    def config_sync(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncArgs']]):
        pulumi.set(self, "config_sync", value)

    @property
    @pulumi.getter(name="hierarchyController")
    def hierarchy_controller(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementHierarchyControllerArgs']]:
        """
        Hierarchy Controller configuration for the cluster. Structure is documented below.
        Configuring Hierarchy Controller through the configmanagement feature is no longer recommended.
        Use open source Kubernetes [Hierarchical Namespace Controller (HNC)](https://github.com/kubernetes-sigs/hierarchical-namespaces) instead.
        Follow the [instructions](https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/migrate-hierarchy-controller)
        to migrate from Hierarchy Controller to HNC.
        """
        return pulumi.get(self, "hierarchy_controller")

    @hierarchy_controller.setter
    def hierarchy_controller(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementHierarchyControllerArgs']]):
        pulumi.set(self, "hierarchy_controller", value)

    @property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set this field to MANAGEMENT_AUTOMATIC to enable Config Sync auto-upgrades, and set this field to MANAGEMENT_MANUAL or MANAGEMENT_UNSPECIFIED to disable Config Sync auto-upgrades.
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "management", value)

    @property
    @pulumi.getter(name="policyController")
    def policy_controller(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerArgs']]:
        """
        Policy Controller configuration for the cluster. Structure is documented below.
        Configuring Policy Controller through the configmanagement feature is no longer recommended.
        Use the policycontroller feature instead.
        """
        return pulumi.get(self, "policy_controller")

    @policy_controller.setter
    def policy_controller(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerArgs']]):
        pulumi.set(self, "policy_controller", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of Config Sync installed.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureMembershipConfigmanagementBinauthzArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether binauthz is enabled in this cluster.
        """
elif False:
    FeatureMembershipConfigmanagementBinauthzArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementBinauthzArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether binauthz is enabled in this cluster.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether binauthz is enabled in this cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class FeatureMembershipConfigmanagementConfigSyncArgsDict(TypedDict):
        deployment_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgsDict']]]]
        """
        The override configurations for the Config Sync Deployments. Structure is documented below. The field is only available on Config Sync version 1.20.1 or later.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        """
        git: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncGitArgsDict']]
        """
        (Optional) Structure is documented below.
        """
        metrics_gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Deprecated: If Workload Identity Federation for GKE is enabled, Google Cloud Service Account is no longer needed for exporting Config Sync metrics: https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/monitor-config-sync-cloud-monitoring#custom-monitoring.
        """
        oci: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncOciArgsDict']]
        """
        (Optional) Supported from Config Sync versions 1.12.0 onwards. Structure is documented below.

        Use either `git` or `oci` config option.
        """
        prevent_drift: NotRequired[pulumi.Input[builtins.bool]]
        """
        Supported from Config Sync versions 1.10.0 onwards. Set to `true` to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        """
        source_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Config Sync Repo is in "hierarchical" or "unstructured" mode.
        """
        stop_syncing: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to `true` to stop syncing configurations for a single cluster. This field is only available on clusters using Config Sync [auto-upgrades](http://cloud/kubernetes-engine/enterprise/config-sync/docs/how-to/upgrade-config-sync#auto-upgrade-config) or on Config Sync version 1.20.0 or later. Defaults: `false`.
        """
elif False:
    FeatureMembershipConfigmanagementConfigSyncArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementConfigSyncArgs:
    def __init__(__self__, *,
                 deployment_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 git: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncGitArgs']] = None,
                 metrics_gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 oci: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncOciArgs']] = None,
                 prevent_drift: Optional[pulumi.Input[builtins.bool]] = None,
                 source_format: Optional[pulumi.Input[builtins.str]] = None,
                 stop_syncing: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs']]] deployment_overrides: The override configurations for the Config Sync Deployments. Structure is documented below. The field is only available on Config Sync version 1.20.1 or later.
        :param pulumi.Input[builtins.bool] enabled: Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        :param pulumi.Input['FeatureMembershipConfigmanagementConfigSyncGitArgs'] git: (Optional) Structure is documented below.
        :param pulumi.Input[builtins.str] metrics_gcp_service_account_email: Deprecated: If Workload Identity Federation for GKE is enabled, Google Cloud Service Account is no longer needed for exporting Config Sync metrics: https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/monitor-config-sync-cloud-monitoring#custom-monitoring.
        :param pulumi.Input['FeatureMembershipConfigmanagementConfigSyncOciArgs'] oci: (Optional) Supported from Config Sync versions 1.12.0 onwards. Structure is documented below.
               
               Use either `git` or `oci` config option.
        :param pulumi.Input[builtins.bool] prevent_drift: Supported from Config Sync versions 1.10.0 onwards. Set to `true` to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        :param pulumi.Input[builtins.str] source_format: Specifies whether the Config Sync Repo is in "hierarchical" or "unstructured" mode.
        :param pulumi.Input[builtins.bool] stop_syncing: Set to `true` to stop syncing configurations for a single cluster. This field is only available on clusters using Config Sync [auto-upgrades](http://cloud/kubernetes-engine/enterprise/config-sync/docs/how-to/upgrade-config-sync#auto-upgrade-config) or on Config Sync version 1.20.0 or later. Defaults: `false`.
        """
        if deployment_overrides is not None:
            pulumi.set(__self__, "deployment_overrides", deployment_overrides)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if metrics_gcp_service_account_email is not None:
            pulumi.set(__self__, "metrics_gcp_service_account_email", metrics_gcp_service_account_email)
        if oci is not None:
            pulumi.set(__self__, "oci", oci)
        if prevent_drift is not None:
            pulumi.set(__self__, "prevent_drift", prevent_drift)
        if source_format is not None:
            pulumi.set(__self__, "source_format", source_format)
        if stop_syncing is not None:
            pulumi.set(__self__, "stop_syncing", stop_syncing)

    @property
    @pulumi.getter(name="deploymentOverrides")
    def deployment_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs']]]]:
        """
        The override configurations for the Config Sync Deployments. Structure is documented below. The field is only available on Config Sync version 1.20.1 or later.
        """
        return pulumi.get(self, "deployment_overrides")

    @deployment_overrides.setter
    def deployment_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs']]]]):
        pulumi.set(self, "deployment_overrides", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the installation of ConfigSync. If set to true, ConfigSync resources will be created and the other ConfigSync fields will be applied if exist. If set to false, all other ConfigSync fields will be ignored, ConfigSync resources will be deleted. If omitted, ConfigSync resources will be managed depends on the presence of the git or oci field.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncGitArgs']]:
        """
        (Optional) Structure is documented below.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter(name="metricsGcpServiceAccountEmail")
    def metrics_gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deprecated: If Workload Identity Federation for GKE is enabled, Google Cloud Service Account is no longer needed for exporting Config Sync metrics: https://cloud.google.com/kubernetes-engine/enterprise/config-sync/docs/how-to/monitor-config-sync-cloud-monitoring#custom-monitoring.
        """
        return pulumi.get(self, "metrics_gcp_service_account_email")

    @metrics_gcp_service_account_email.setter
    def metrics_gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metrics_gcp_service_account_email", value)

    @property
    @pulumi.getter
    def oci(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncOciArgs']]:
        """
        (Optional) Supported from Config Sync versions 1.12.0 onwards. Structure is documented below.

        Use either `git` or `oci` config option.
        """
        return pulumi.get(self, "oci")

    @oci.setter
    def oci(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncOciArgs']]):
        pulumi.set(self, "oci", value)

    @property
    @pulumi.getter(name="preventDrift")
    def prevent_drift(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Supported from Config Sync versions 1.10.0 onwards. Set to `true` to enable the Config Sync admission webhook to prevent drifts. If set to `false`, disables the Config Sync admission webhook and does not prevent drifts.
        """
        return pulumi.get(self, "prevent_drift")

    @prevent_drift.setter
    def prevent_drift(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "prevent_drift", value)

    @property
    @pulumi.getter(name="sourceFormat")
    def source_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Config Sync Repo is in "hierarchical" or "unstructured" mode.
        """
        return pulumi.get(self, "source_format")

    @source_format.setter
    def source_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_format", value)

    @property
    @pulumi.getter(name="stopSyncing")
    def stop_syncing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to `true` to stop syncing configurations for a single cluster. This field is only available on clusters using Config Sync [auto-upgrades](http://cloud/kubernetes-engine/enterprise/config-sync/docs/how-to/upgrade-config-sync#auto-upgrade-config) or on Config Sync version 1.20.0 or later. Defaults: `false`.
        """
        return pulumi.get(self, "stop_syncing")

    @stop_syncing.setter
    def stop_syncing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "stop_syncing", value)


if not MYPY:
    class FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgsDict(TypedDict):
        containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgsDict']]]]
        """
        The override configurations for the containers in the Deployment. Structure is documented below.
        """
        deployment_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the Deployment.
        """
        deployment_namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The namespace of the Deployment.
        """
elif False:
    FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs']]]] = None,
                 deployment_name: Optional[pulumi.Input[builtins.str]] = None,
                 deployment_namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs']]] containers: The override configurations for the containers in the Deployment. Structure is documented below.
        :param pulumi.Input[builtins.str] deployment_name: The name of the Deployment.
        :param pulumi.Input[builtins.str] deployment_namespace: The namespace of the Deployment.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if deployment_name is not None:
            pulumi.set(__self__, "deployment_name", deployment_name)
        if deployment_namespace is not None:
            pulumi.set(__self__, "deployment_namespace", deployment_namespace)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs']]]]:
        """
        The override configurations for the containers in the Deployment. Structure is documented below.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the Deployment.
        """
        return pulumi.get(self, "deployment_name")

    @deployment_name.setter
    def deployment_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deployment_name", value)

    @property
    @pulumi.getter(name="deploymentNamespace")
    def deployment_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The namespace of the Deployment.
        """
        return pulumi.get(self, "deployment_namespace")

    @deployment_namespace.setter
    def deployment_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deployment_namespace", value)


if not MYPY:
    class FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgsDict(TypedDict):
        container_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the container.
        """
        cpu_limit: NotRequired[pulumi.Input[builtins.str]]
        """
        The CPU limit of the container.
        """
        cpu_request: NotRequired[pulumi.Input[builtins.str]]
        """
        The CPU request of the container.
        """
        memory_limit: NotRequired[pulumi.Input[builtins.str]]
        """
        The memory limit of the container.
        """
        memory_request: NotRequired[pulumi.Input[builtins.str]]
        """
        The memory request of the container.
        """
elif False:
    FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementConfigSyncDeploymentOverrideContainerArgs:
    def __init__(__self__, *,
                 container_name: Optional[pulumi.Input[builtins.str]] = None,
                 cpu_limit: Optional[pulumi.Input[builtins.str]] = None,
                 cpu_request: Optional[pulumi.Input[builtins.str]] = None,
                 memory_limit: Optional[pulumi.Input[builtins.str]] = None,
                 memory_request: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] container_name: The name of the container.
        :param pulumi.Input[builtins.str] cpu_limit: The CPU limit of the container.
        :param pulumi.Input[builtins.str] cpu_request: The CPU request of the container.
        :param pulumi.Input[builtins.str] memory_limit: The memory limit of the container.
        :param pulumi.Input[builtins.str] memory_request: The memory request of the container.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the container.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The CPU limit of the container.
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The CPU request of the container.
        """
        return pulumi.get(self, "cpu_request")

    @cpu_request.setter
    def cpu_request(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu_request", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The memory limit of the container.
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The memory request of the container.
        """
        return pulumi.get(self, "memory_request")

    @memory_request.setter
    def memory_request(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory_request", value)


if not MYPY:
    class FeatureMembershipConfigmanagementConfigSyncGitArgsDict(TypedDict):
        gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The GCP Service Account Email used for auth when secretType is gcpServiceAccount.
        """
        https_proxy: NotRequired[pulumi.Input[builtins.str]]
        """
        URL for the HTTPS proxy to be used when communicating with the Git repo.
        """
        policy_dir: NotRequired[pulumi.Input[builtins.str]]
        """
        The path within the Git repository that represents the top level of the repo to sync. Default: the root directory of the repository.
        """
        secret_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of secret configured for access to the Git repo.
        """
        sync_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        The branch of the repository to sync from. Default: master.
        """
        sync_repo: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the Git repository to use as the source of truth.
        """
        sync_rev: NotRequired[pulumi.Input[builtins.str]]
        """
        Git revision (tag or hash) to check out. Default HEAD.
        """
        sync_wait_secs: NotRequired[pulumi.Input[builtins.str]]
        """
        Period in seconds between consecutive syncs. Default: 15.
        """
elif False:
    FeatureMembershipConfigmanagementConfigSyncGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementConfigSyncGitArgs:
    def __init__(__self__, *,
                 gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 https_proxy: Optional[pulumi.Input[builtins.str]] = None,
                 policy_dir: Optional[pulumi.Input[builtins.str]] = None,
                 secret_type: Optional[pulumi.Input[builtins.str]] = None,
                 sync_branch: Optional[pulumi.Input[builtins.str]] = None,
                 sync_repo: Optional[pulumi.Input[builtins.str]] = None,
                 sync_rev: Optional[pulumi.Input[builtins.str]] = None,
                 sync_wait_secs: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gcp_service_account_email: The GCP Service Account Email used for auth when secretType is gcpServiceAccount.
        :param pulumi.Input[builtins.str] https_proxy: URL for the HTTPS proxy to be used when communicating with the Git repo.
        :param pulumi.Input[builtins.str] policy_dir: The path within the Git repository that represents the top level of the repo to sync. Default: the root directory of the repository.
        :param pulumi.Input[builtins.str] secret_type: Type of secret configured for access to the Git repo.
        :param pulumi.Input[builtins.str] sync_branch: The branch of the repository to sync from. Default: master.
        :param pulumi.Input[builtins.str] sync_repo: The URL of the Git repository to use as the source of truth.
        :param pulumi.Input[builtins.str] sync_rev: Git revision (tag or hash) to check out. Default HEAD.
        :param pulumi.Input[builtins.str] sync_wait_secs: Period in seconds between consecutive syncs. Default: 15.
        """
        if gcp_service_account_email is not None:
            pulumi.set(__self__, "gcp_service_account_email", gcp_service_account_email)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if policy_dir is not None:
            pulumi.set(__self__, "policy_dir", policy_dir)
        if secret_type is not None:
            pulumi.set(__self__, "secret_type", secret_type)
        if sync_branch is not None:
            pulumi.set(__self__, "sync_branch", sync_branch)
        if sync_repo is not None:
            pulumi.set(__self__, "sync_repo", sync_repo)
        if sync_rev is not None:
            pulumi.set(__self__, "sync_rev", sync_rev)
        if sync_wait_secs is not None:
            pulumi.set(__self__, "sync_wait_secs", sync_wait_secs)

    @property
    @pulumi.getter(name="gcpServiceAccountEmail")
    def gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The GCP Service Account Email used for auth when secretType is gcpServiceAccount.
        """
        return pulumi.get(self, "gcp_service_account_email")

    @gcp_service_account_email.setter
    def gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gcp_service_account_email", value)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL for the HTTPS proxy to be used when communicating with the Git repo.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "https_proxy", value)

    @property
    @pulumi.getter(name="policyDir")
    def policy_dir(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path within the Git repository that represents the top level of the repo to sync. Default: the root directory of the repository.
        """
        return pulumi.get(self, "policy_dir")

    @policy_dir.setter
    def policy_dir(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_dir", value)

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of secret configured for access to the Git repo.
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_type", value)

    @property
    @pulumi.getter(name="syncBranch")
    def sync_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The branch of the repository to sync from. Default: master.
        """
        return pulumi.get(self, "sync_branch")

    @sync_branch.setter
    def sync_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_branch", value)

    @property
    @pulumi.getter(name="syncRepo")
    def sync_repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the Git repository to use as the source of truth.
        """
        return pulumi.get(self, "sync_repo")

    @sync_repo.setter
    def sync_repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_repo", value)

    @property
    @pulumi.getter(name="syncRev")
    def sync_rev(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Git revision (tag or hash) to check out. Default HEAD.
        """
        return pulumi.get(self, "sync_rev")

    @sync_rev.setter
    def sync_rev(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_rev", value)

    @property
    @pulumi.getter(name="syncWaitSecs")
    def sync_wait_secs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Period in seconds between consecutive syncs. Default: 15.
        """
        return pulumi.get(self, "sync_wait_secs")

    @sync_wait_secs.setter
    def sync_wait_secs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_wait_secs", value)


if not MYPY:
    class FeatureMembershipConfigmanagementConfigSyncOciArgsDict(TypedDict):
        gcp_service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The GCP Service Account Email used for auth when secret_type is gcpserviceaccount.
        """
        policy_dir: NotRequired[pulumi.Input[builtins.str]]
        """
        The absolute path of the directory that contains the local resources. Default: the root directory of the image.
        """
        secret_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of secret configured for access to the OCI Image. Must be one of gcenode, gcpserviceaccount or none.
        """
        sync_repo: NotRequired[pulumi.Input[builtins.str]]
        """
        The OCI image repository URL for the package to sync from. e.g. LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME.
        """
        sync_wait_secs: NotRequired[pulumi.Input[builtins.str]]
        """
        Period in seconds(int64 format) between consecutive syncs. Default: 15.
        """
elif False:
    FeatureMembershipConfigmanagementConfigSyncOciArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementConfigSyncOciArgs:
    def __init__(__self__, *,
                 gcp_service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 policy_dir: Optional[pulumi.Input[builtins.str]] = None,
                 secret_type: Optional[pulumi.Input[builtins.str]] = None,
                 sync_repo: Optional[pulumi.Input[builtins.str]] = None,
                 sync_wait_secs: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gcp_service_account_email: The GCP Service Account Email used for auth when secret_type is gcpserviceaccount.
        :param pulumi.Input[builtins.str] policy_dir: The absolute path of the directory that contains the local resources. Default: the root directory of the image.
        :param pulumi.Input[builtins.str] secret_type: Type of secret configured for access to the OCI Image. Must be one of gcenode, gcpserviceaccount or none.
        :param pulumi.Input[builtins.str] sync_repo: The OCI image repository URL for the package to sync from. e.g. LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME.
        :param pulumi.Input[builtins.str] sync_wait_secs: Period in seconds(int64 format) between consecutive syncs. Default: 15.
        """
        if gcp_service_account_email is not None:
            pulumi.set(__self__, "gcp_service_account_email", gcp_service_account_email)
        if policy_dir is not None:
            pulumi.set(__self__, "policy_dir", policy_dir)
        if secret_type is not None:
            pulumi.set(__self__, "secret_type", secret_type)
        if sync_repo is not None:
            pulumi.set(__self__, "sync_repo", sync_repo)
        if sync_wait_secs is not None:
            pulumi.set(__self__, "sync_wait_secs", sync_wait_secs)

    @property
    @pulumi.getter(name="gcpServiceAccountEmail")
    def gcp_service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The GCP Service Account Email used for auth when secret_type is gcpserviceaccount.
        """
        return pulumi.get(self, "gcp_service_account_email")

    @gcp_service_account_email.setter
    def gcp_service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gcp_service_account_email", value)

    @property
    @pulumi.getter(name="policyDir")
    def policy_dir(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The absolute path of the directory that contains the local resources. Default: the root directory of the image.
        """
        return pulumi.get(self, "policy_dir")

    @policy_dir.setter
    def policy_dir(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_dir", value)

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of secret configured for access to the OCI Image. Must be one of gcenode, gcpserviceaccount or none.
        """
        return pulumi.get(self, "secret_type")

    @secret_type.setter
    def secret_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_type", value)

    @property
    @pulumi.getter(name="syncRepo")
    def sync_repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OCI image repository URL for the package to sync from. e.g. LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME.
        """
        return pulumi.get(self, "sync_repo")

    @sync_repo.setter
    def sync_repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_repo", value)

    @property
    @pulumi.getter(name="syncWaitSecs")
    def sync_wait_secs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Period in seconds(int64 format) between consecutive syncs. Default: 15.
        """
        return pulumi.get(self, "sync_wait_secs")

    @sync_wait_secs.setter
    def sync_wait_secs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sync_wait_secs", value)


if not MYPY:
    class FeatureMembershipConfigmanagementHierarchyControllerArgsDict(TypedDict):
        enable_hierarchical_resource_quota: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether hierarchical resource quota is enabled in this cluster.
        """
        enable_pod_tree_labels: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether pod tree labels are enabled in this cluster.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Hierarchy Controller is enabled in this cluster.
        """
elif False:
    FeatureMembershipConfigmanagementHierarchyControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementHierarchyControllerArgs:
    def __init__(__self__, *,
                 enable_hierarchical_resource_quota: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_pod_tree_labels: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_hierarchical_resource_quota: Whether hierarchical resource quota is enabled in this cluster.
        :param pulumi.Input[builtins.bool] enable_pod_tree_labels: Whether pod tree labels are enabled in this cluster.
        :param pulumi.Input[builtins.bool] enabled: Whether Hierarchy Controller is enabled in this cluster.
        """
        if enable_hierarchical_resource_quota is not None:
            pulumi.set(__self__, "enable_hierarchical_resource_quota", enable_hierarchical_resource_quota)
        if enable_pod_tree_labels is not None:
            pulumi.set(__self__, "enable_pod_tree_labels", enable_pod_tree_labels)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="enableHierarchicalResourceQuota")
    def enable_hierarchical_resource_quota(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether hierarchical resource quota is enabled in this cluster.
        """
        return pulumi.get(self, "enable_hierarchical_resource_quota")

    @enable_hierarchical_resource_quota.setter
    def enable_hierarchical_resource_quota(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_hierarchical_resource_quota", value)

    @property
    @pulumi.getter(name="enablePodTreeLabels")
    def enable_pod_tree_labels(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether pod tree labels are enabled in this cluster.
        """
        return pulumi.get(self, "enable_pod_tree_labels")

    @enable_pod_tree_labels.setter
    def enable_pod_tree_labels(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_pod_tree_labels", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Hierarchy Controller is enabled in this cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class FeatureMembershipConfigmanagementPolicyControllerArgsDict(TypedDict):
        audit_interval_seconds: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the installation of Policy Controller. If false, the rest of PolicyController fields take no effect.
        """
        exemptable_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        log_denies_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Logs all denies and dry run failures.
        """
        monitoring: NotRequired[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerMonitoringArgsDict']]
        """
        Specifies the backends Policy Controller should export metrics to. For example, to specify metrics should be exported to Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring", "prometheus"]. Default: ["cloudmonitoring", "prometheus"]
        """
        mutation_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        """
        referential_rules_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        template_library_installed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Installs the default template library along with Policy Controller.
        """
elif False:
    FeatureMembershipConfigmanagementPolicyControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementPolicyControllerArgs:
    def __init__(__self__, *,
                 audit_interval_seconds: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 exemptable_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 log_denies_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 monitoring: Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs']] = None,
                 mutation_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 referential_rules_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 template_library_installed: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] audit_interval_seconds: Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        :param pulumi.Input[builtins.bool] enabled: Enables the installation of Policy Controller. If false, the rest of PolicyController fields take no effect.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exemptable_namespaces: The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        :param pulumi.Input[builtins.bool] log_denies_enabled: Logs all denies and dry run failures.
        :param pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs'] monitoring: Specifies the backends Policy Controller should export metrics to. For example, to specify metrics should be exported to Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring", "prometheus"]. Default: ["cloudmonitoring", "prometheus"]
        :param pulumi.Input[builtins.bool] mutation_enabled: Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        :param pulumi.Input[builtins.bool] referential_rules_enabled: Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        :param pulumi.Input[builtins.bool] template_library_installed: Installs the default template library along with Policy Controller.
        """
        if audit_interval_seconds is not None:
            pulumi.set(__self__, "audit_interval_seconds", audit_interval_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exemptable_namespaces is not None:
            pulumi.set(__self__, "exemptable_namespaces", exemptable_namespaces)
        if log_denies_enabled is not None:
            pulumi.set(__self__, "log_denies_enabled", log_denies_enabled)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if mutation_enabled is not None:
            pulumi.set(__self__, "mutation_enabled", mutation_enabled)
        if referential_rules_enabled is not None:
            pulumi.set(__self__, "referential_rules_enabled", referential_rules_enabled)
        if template_library_installed is not None:
            pulumi.set(__self__, "template_library_installed", template_library_installed)

    @property
    @pulumi.getter(name="auditIntervalSeconds")
    def audit_interval_seconds(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        return pulumi.get(self, "audit_interval_seconds")

    @audit_interval_seconds.setter
    def audit_interval_seconds(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "audit_interval_seconds", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the installation of Policy Controller. If false, the rest of PolicyController fields take no effect.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="exemptableNamespaces")
    def exemptable_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        return pulumi.get(self, "exemptable_namespaces")

    @exemptable_namespaces.setter
    def exemptable_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exemptable_namespaces", value)

    @property
    @pulumi.getter(name="logDeniesEnabled")
    def log_denies_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Logs all denies and dry run failures.
        """
        return pulumi.get(self, "log_denies_enabled")

    @log_denies_enabled.setter
    def log_denies_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_denies_enabled", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs']]:
        """
        Specifies the backends Policy Controller should export metrics to. For example, to specify metrics should be exported to Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring", "prometheus"]. Default: ["cloudmonitoring", "prometheus"]
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="mutationEnabled")
    def mutation_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        """
        return pulumi.get(self, "mutation_enabled")

    @mutation_enabled.setter
    def mutation_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mutation_enabled", value)

    @property
    @pulumi.getter(name="referentialRulesEnabled")
    def referential_rules_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        return pulumi.get(self, "referential_rules_enabled")

    @referential_rules_enabled.setter
    def referential_rules_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "referential_rules_enabled", value)

    @property
    @pulumi.getter(name="templateLibraryInstalled")
    def template_library_installed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Installs the default template library along with Policy Controller.
        """
        return pulumi.get(self, "template_library_installed")

    @template_library_installed.setter
    def template_library_installed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "template_library_installed", value)


if not MYPY:
    class FeatureMembershipConfigmanagementPolicyControllerMonitoringArgsDict(TypedDict):
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
elif False:
    FeatureMembershipConfigmanagementPolicyControllerMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipConfigmanagementPolicyControllerMonitoringArgs:
    def __init__(__self__, *,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] backends: Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "backends", value)


if not MYPY:
    class FeatureMembershipMeshArgsDict(TypedDict):
        control_plane: NotRequired[pulumi.Input[builtins.str]]
        """
        **DEPRECATED** Whether to automatically manage Service Mesh control planes. Possible values: CONTROL_PLANE_MANAGEMENT_UNSPECIFIED, AUTOMATIC, MANUAL
        """
        management: NotRequired[pulumi.Input[builtins.str]]
        """
        Whether to automatically manage Service Mesh. Can either be `MANAGEMENT_AUTOMATIC` or `MANAGEMENT_MANUAL`.
        """
elif False:
    FeatureMembershipMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipMeshArgs:
    def __init__(__self__, *,
                 control_plane: Optional[pulumi.Input[builtins.str]] = None,
                 management: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] control_plane: **DEPRECATED** Whether to automatically manage Service Mesh control planes. Possible values: CONTROL_PLANE_MANAGEMENT_UNSPECIFIED, AUTOMATIC, MANUAL
        :param pulumi.Input[builtins.str] management: Whether to automatically manage Service Mesh. Can either be `MANAGEMENT_AUTOMATIC` or `MANAGEMENT_MANUAL`.
        """
        if control_plane is not None:
            warnings.warn("""Deprecated in favor of the `management` field""", DeprecationWarning)
            pulumi.log.warn("""control_plane is deprecated: Deprecated in favor of the `management` field""")
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if management is not None:
            pulumi.set(__self__, "management", management)

    @property
    @pulumi.getter(name="controlPlane")
    @_utilities.deprecated("""Deprecated in favor of the `management` field""")
    def control_plane(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        **DEPRECATED** Whether to automatically manage Service Mesh control planes. Possible values: CONTROL_PLANE_MANAGEMENT_UNSPECIFIED, AUTOMATIC, MANUAL
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether to automatically manage Service Mesh. Can either be `MANAGEMENT_AUTOMATIC` or `MANAGEMENT_MANUAL`.
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "management", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerArgsDict(TypedDict):
        policy_controller_hub_config: pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgsDict']
        """
        Policy Controller configuration for the cluster. Structure is documented below.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of Policy Controller to install. Defaults to the latest version.
        """
elif False:
    FeatureMembershipPolicycontrollerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerArgs:
    def __init__(__self__, *,
                 policy_controller_hub_config: pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs'],
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs'] policy_controller_hub_config: Policy Controller configuration for the cluster. Structure is documented below.
        :param pulumi.Input[builtins.str] version: Version of Policy Controller to install. Defaults to the latest version.
        """
        pulumi.set(__self__, "policy_controller_hub_config", policy_controller_hub_config)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="policyControllerHubConfig")
    def policy_controller_hub_config(self) -> pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs']:
        """
        Policy Controller configuration for the cluster. Structure is documented below.
        """
        return pulumi.get(self, "policy_controller_hub_config")

    @policy_controller_hub_config.setter
    def policy_controller_hub_config(self, value: pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs']):
        pulumi.set(self, "policy_controller_hub_config", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of Policy Controller to install. Defaults to the latest version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgsDict(TypedDict):
        audit_interval_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        constraint_violation_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of audit violations to be stored in a constraint. If not set, the  default of 20 will be used.
        """
        deployment_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict']]]]
        """
        Map of deployment configs to deployments ("admission", "audit", "mutation").
        """
        exemptable_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        install_spec: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures the mode of the Policy Controller installation. Must be one of `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED` or `INSTALL_SPEC_DETACHED`.
        """
        log_denies_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Logs all denies and dry run failures.
        """
        monitoring: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict']]
        """
        Specifies the backends Policy Controller should export metrics to. Structure is documented below.
        """
        mutation_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        """
        policy_content: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict']]
        """
        Specifies the desired policy content on the cluster. Structure is documented below.
        """
        referential_rules_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigArgs:
    def __init__(__self__, *,
                 audit_interval_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 constraint_violation_limit: Optional[pulumi.Input[builtins.int]] = None,
                 deployment_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]] = None,
                 exemptable_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 install_spec: Optional[pulumi.Input[builtins.str]] = None,
                 log_denies_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 monitoring: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs']] = None,
                 mutation_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 policy_content: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']] = None,
                 referential_rules_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] audit_interval_seconds: Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        :param pulumi.Input[builtins.int] constraint_violation_limit: The maximum number of audit violations to be stored in a constraint. If not set, the  default of 20 will be used.
        :param pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]] deployment_configs: Map of deployment configs to deployments ("admission", "audit", "mutation").
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exemptable_namespaces: The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        :param pulumi.Input[builtins.str] install_spec: Configures the mode of the Policy Controller installation. Must be one of `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED` or `INSTALL_SPEC_DETACHED`.
        :param pulumi.Input[builtins.bool] log_denies_enabled: Logs all denies and dry run failures.
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs'] monitoring: Specifies the backends Policy Controller should export metrics to. Structure is documented below.
        :param pulumi.Input[builtins.bool] mutation_enabled: Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs'] policy_content: Specifies the desired policy content on the cluster. Structure is documented below.
        :param pulumi.Input[builtins.bool] referential_rules_enabled: Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        if audit_interval_seconds is not None:
            pulumi.set(__self__, "audit_interval_seconds", audit_interval_seconds)
        if constraint_violation_limit is not None:
            pulumi.set(__self__, "constraint_violation_limit", constraint_violation_limit)
        if deployment_configs is not None:
            pulumi.set(__self__, "deployment_configs", deployment_configs)
        if exemptable_namespaces is not None:
            pulumi.set(__self__, "exemptable_namespaces", exemptable_namespaces)
        if install_spec is not None:
            pulumi.set(__self__, "install_spec", install_spec)
        if log_denies_enabled is not None:
            pulumi.set(__self__, "log_denies_enabled", log_denies_enabled)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if mutation_enabled is not None:
            pulumi.set(__self__, "mutation_enabled", mutation_enabled)
        if policy_content is not None:
            pulumi.set(__self__, "policy_content", policy_content)
        if referential_rules_enabled is not None:
            pulumi.set(__self__, "referential_rules_enabled", referential_rules_enabled)

    @property
    @pulumi.getter(name="auditIntervalSeconds")
    def audit_interval_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
        """
        return pulumi.get(self, "audit_interval_seconds")

    @audit_interval_seconds.setter
    def audit_interval_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "audit_interval_seconds", value)

    @property
    @pulumi.getter(name="constraintViolationLimit")
    def constraint_violation_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of audit violations to be stored in a constraint. If not set, the  default of 20 will be used.
        """
        return pulumi.get(self, "constraint_violation_limit")

    @constraint_violation_limit.setter
    def constraint_violation_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "constraint_violation_limit", value)

    @property
    @pulumi.getter(name="deploymentConfigs")
    def deployment_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]]:
        """
        Map of deployment configs to deployments ("admission", "audit", "mutation").
        """
        return pulumi.get(self, "deployment_configs")

    @deployment_configs.setter
    def deployment_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs']]]]):
        pulumi.set(self, "deployment_configs", value)

    @property
    @pulumi.getter(name="exemptableNamespaces")
    def exemptable_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
        """
        return pulumi.get(self, "exemptable_namespaces")

    @exemptable_namespaces.setter
    def exemptable_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exemptable_namespaces", value)

    @property
    @pulumi.getter(name="installSpec")
    def install_spec(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures the mode of the Policy Controller installation. Must be one of `INSTALL_SPEC_NOT_INSTALLED`, `INSTALL_SPEC_ENABLED`, `INSTALL_SPEC_SUSPENDED` or `INSTALL_SPEC_DETACHED`.
        """
        return pulumi.get(self, "install_spec")

    @install_spec.setter
    def install_spec(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "install_spec", value)

    @property
    @pulumi.getter(name="logDeniesEnabled")
    def log_denies_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Logs all denies and dry run failures.
        """
        return pulumi.get(self, "log_denies_enabled")

    @log_denies_enabled.setter
    def log_denies_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_denies_enabled", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs']]:
        """
        Specifies the backends Policy Controller should export metrics to. Structure is documented below.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="mutationEnabled")
    def mutation_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables mutation in policy controller. If true, mutation CRDs, webhook, and controller deployment will be deployed to the cluster.
        """
        return pulumi.get(self, "mutation_enabled")

    @mutation_enabled.setter
    def mutation_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mutation_enabled", value)

    @property
    @pulumi.getter(name="policyContent")
    def policy_content(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']]:
        """
        Specifies the desired policy content on the cluster. Structure is documented below.
        """
        return pulumi.get(self, "policy_content")

    @policy_content.setter
    def policy_content(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs']]):
        pulumi.set(self, "policy_content", value)

    @property
    @pulumi.getter(name="referentialRulesEnabled")
    def referential_rules_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
        """
        return pulumi.get(self, "referential_rules_enabled")

    @referential_rules_enabled.setter
    def referential_rules_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "referential_rules_enabled", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict(TypedDict):
        component_name: pulumi.Input[builtins.str]
        """
        The name of the component. One of `admission` `audit` or `mutation`
        """
        container_resources: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
        pod_affinity: NotRequired[pulumi.Input[builtins.str]]
        """
        Pod affinity configuration. Possible values: AFFINITY_UNSPECIFIED, NO_AFFINITY, ANTI_AFFINITY
        """
        pod_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict']]]]
        """
        Pod tolerations of node taints.
        """
        replica_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Pod replica count.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigArgs:
    def __init__(__self__, *,
                 component_name: pulumi.Input[builtins.str],
                 container_resources: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']] = None,
                 pod_affinity: Optional[pulumi.Input[builtins.str]] = None,
                 pod_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]] = None,
                 replica_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] component_name: The name of the component. One of `admission` `audit` or `mutation`
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs'] container_resources: Container resource requirements.
        :param pulumi.Input[builtins.str] pod_affinity: Pod affinity configuration. Possible values: AFFINITY_UNSPECIFIED, NO_AFFINITY, ANTI_AFFINITY
        :param pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]] pod_tolerations: Pod tolerations of node taints.
        :param pulumi.Input[builtins.int] replica_count: Pod replica count.
        """
        pulumi.set(__self__, "component_name", component_name)
        if container_resources is not None:
            pulumi.set(__self__, "container_resources", container_resources)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_tolerations is not None:
            pulumi.set(__self__, "pod_tolerations", pod_tolerations)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)

    @property
    @pulumi.getter(name="componentName")
    def component_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the component. One of `admission` `audit` or `mutation`
        """
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_name", value)

    @property
    @pulumi.getter(name="containerResources")
    def container_resources(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "container_resources")

    @container_resources.setter
    def container_resources(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs']]):
        pulumi.set(self, "container_resources", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pod affinity configuration. Possible values: AFFINITY_UNSPECIFIED, NO_AFFINITY, ANTI_AFFINITY
        """
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podTolerations")
    def pod_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]]:
        """
        Pod tolerations of node taints.
        """
        return pulumi.get(self, "pod_tolerations")

    @pod_tolerations.setter
    def pod_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs']]]]):
        pulumi.set(self, "pod_tolerations", value)

    @property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Pod replica count.
        """
        return pulumi.get(self, "replica_count")

    @replica_count.setter
    def replica_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_count", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict']]
        """
        Limits describes the maximum amount of compute resources allowed for use by the running container.
        """
        requests: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict']]
        """
        Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']] = None,
                 requests: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']] = None):
        """
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed for use by the running container.
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs'] requests: Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']]:
        """
        Limits describes the maximum amount of compute resources allowed for use by the running container.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']]:
        """
        Requests describes the amount of compute resources reserved for the container by the kube-scheduler.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs']]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[builtins.str]]
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Memory requirement expressed in Kubernetes resource units.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesLimitsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.str]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: CPU requirement expressed in Kubernetes resource units.
        :param pulumi.Input[builtins.str] memory: Memory requirement expressed in Kubernetes resource units.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Memory requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[builtins.str]]
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Memory requirement expressed in Kubernetes resource units.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigContainerResourcesRequestsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.str]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: CPU requirement expressed in Kubernetes resource units.
        :param pulumi.Input[builtins.str] memory: Memory requirement expressed in Kubernetes resource units.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CPU requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Memory requirement expressed in Kubernetes resource units.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint effect.
        """
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint key (not necessarily unique).
        """
        operator: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Matches a taint value.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigDeploymentConfigPodTolerationArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[builtins.str]] = None,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 operator: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] effect: Matches a taint effect.
        :param pulumi.Input[builtins.str] key: Matches a taint key (not necessarily unique).
        :param pulumi.Input[builtins.str] operator: Matches a taint operator.
        :param pulumi.Input[builtins.str] value: Matches a taint value.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint key (not necessarily unique).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matches a taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict(TypedDict):
        backends: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigMonitoringArgs:
    def __init__(__self__, *,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] backends: Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the list of backends Policy Controller will export to. Must be one of `CLOUD_MONITORING` or `PROMETHEUS`. Defaults to [`CLOUD_MONITORING`, `PROMETHEUS`]. Specifying an empty value `[]` disables metrics export.
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "backends", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict(TypedDict):
        bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict']]]]
        """
        map of bundle name to BundleInstallSpec. The bundle name maps to the `bundleName` key in the `policycontroller.gke.io/constraintData` annotation on a constraint.
        """
        template_library: NotRequired[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict']]
        """
        Configures the installation of the Template Library. Structure is documented below.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentArgs:
    def __init__(__self__, *,
                 bundles: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]] = None,
                 template_library: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]] bundles: map of bundle name to BundleInstallSpec. The bundle name maps to the `bundleName` key in the `policycontroller.gke.io/constraintData` annotation on a constraint.
        :param pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs'] template_library: Configures the installation of the Template Library. Structure is documented below.
        """
        if bundles is not None:
            pulumi.set(__self__, "bundles", bundles)
        if template_library is not None:
            pulumi.set(__self__, "template_library", template_library)

    @property
    @pulumi.getter
    def bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]]:
        """
        map of bundle name to BundleInstallSpec. The bundle name maps to the `bundleName` key in the `policycontroller.gke.io/constraintData` annotation on a constraint.
        """
        return pulumi.get(self, "bundles")

    @bundles.setter
    def bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs']]]]):
        pulumi.set(self, "bundles", value)

    @property
    @pulumi.getter(name="templateLibrary")
    def template_library(self) -> Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']]:
        """
        Configures the installation of the Template Library. Structure is documented below.
        """
        return pulumi.get(self, "template_library")

    @template_library.setter
    def template_library(self, value: Optional[pulumi.Input['FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs']]):
        pulumi.set(self, "template_library", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict(TypedDict):
        bundle_name: pulumi.Input[builtins.str]
        """
        The name of the bundle.
        """
        exempted_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of namespaces to be exempted from the bundle.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentBundleArgs:
    def __init__(__self__, *,
                 bundle_name: pulumi.Input[builtins.str],
                 exempted_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] bundle_name: The name of the bundle.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exempted_namespaces: The set of namespaces to be exempted from the bundle.
        """
        pulumi.set(__self__, "bundle_name", bundle_name)
        if exempted_namespaces is not None:
            pulumi.set(__self__, "exempted_namespaces", exempted_namespaces)

    @property
    @pulumi.getter(name="bundleName")
    def bundle_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the bundle.
        """
        return pulumi.get(self, "bundle_name")

    @bundle_name.setter
    def bundle_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bundle_name", value)

    @property
    @pulumi.getter(name="exemptedNamespaces")
    def exempted_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of namespaces to be exempted from the bundle.
        """
        return pulumi.get(self, "exempted_namespaces")

    @exempted_namespaces.setter
    def exempted_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exempted_namespaces", value)


if not MYPY:
    class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict(TypedDict):
        installation: NotRequired[pulumi.Input[builtins.str]]
        """
        Configures the manner in which the template library is installed on the cluster. Must be one of `ALL`, `NOT_INSTALLED` or `INSTALLATION_UNSPECIFIED`. Defaults to `ALL`.
        """
elif False:
    FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureMembershipPolicycontrollerPolicyControllerHubConfigPolicyContentTemplateLibraryArgs:
    def __init__(__self__, *,
                 installation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] installation: Configures the manner in which the template library is installed on the cluster. Must be one of `ALL`, `NOT_INSTALLED` or `INSTALLATION_UNSPECIFIED`. Defaults to `ALL`.
        """
        if installation is not None:
            pulumi.set(__self__, "installation", installation)

    @property
    @pulumi.getter
    def installation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Configures the manner in which the template library is installed on the cluster. Must be one of `ALL`, `NOT_INSTALLED` or `INSTALLATION_UNSPECIFIED`. Defaults to `ALL`.
        """
        return pulumi.get(self, "installation")

    @installation.setter
    def installation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation", value)


if not MYPY:
    class FeatureResourceStateArgsDict(TypedDict):
        has_resources: NotRequired[pulumi.Input[builtins.bool]]
        """
        (Output)
        Whether this Feature has outstanding resources that need to be cleaned up before it can be disabled.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The "running state" of the Feature in this Hub.
        Structure is documented below.
        """
elif False:
    FeatureResourceStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureResourceStateArgs:
    def __init__(__self__, *,
                 has_resources: Optional[pulumi.Input[builtins.bool]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] has_resources: (Output)
               Whether this Feature has outstanding resources that need to be cleaned up before it can be disabled.
        :param pulumi.Input[builtins.str] state: (Output)
               Output only. The "running state" of the Feature in this Hub.
               Structure is documented below.
        """
        if has_resources is not None:
            pulumi.set(__self__, "has_resources", has_resources)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="hasResources")
    def has_resources(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        (Output)
        Whether this Feature has outstanding resources that need to be cleaned up before it can be disabled.
        """
        return pulumi.get(self, "has_resources")

    @has_resources.setter
    def has_resources(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "has_resources", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The "running state" of the Feature in this Hub.
        Structure is documented below.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class FeatureSpecArgsDict(TypedDict):
        clusterupgrade: NotRequired[pulumi.Input['FeatureSpecClusterupgradeArgsDict']]
        """
        Clusterupgrade feature spec.
        Structure is documented below.
        """
        fleetobservability: NotRequired[pulumi.Input['FeatureSpecFleetobservabilityArgsDict']]
        """
        Fleet Observability feature spec.
        Structure is documented below.
        """
        multiclusteringress: NotRequired[pulumi.Input['FeatureSpecMulticlusteringressArgsDict']]
        """
        Multicluster Ingress-specific spec.
        Structure is documented below.
        """
elif False:
    FeatureSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecArgs:
    def __init__(__self__, *,
                 clusterupgrade: Optional[pulumi.Input['FeatureSpecClusterupgradeArgs']] = None,
                 fleetobservability: Optional[pulumi.Input['FeatureSpecFleetobservabilityArgs']] = None,
                 multiclusteringress: Optional[pulumi.Input['FeatureSpecMulticlusteringressArgs']] = None):
        """
        :param pulumi.Input['FeatureSpecClusterupgradeArgs'] clusterupgrade: Clusterupgrade feature spec.
               Structure is documented below.
        :param pulumi.Input['FeatureSpecFleetobservabilityArgs'] fleetobservability: Fleet Observability feature spec.
               Structure is documented below.
        :param pulumi.Input['FeatureSpecMulticlusteringressArgs'] multiclusteringress: Multicluster Ingress-specific spec.
               Structure is documented below.
        """
        if clusterupgrade is not None:
            pulumi.set(__self__, "clusterupgrade", clusterupgrade)
        if fleetobservability is not None:
            pulumi.set(__self__, "fleetobservability", fleetobservability)
        if multiclusteringress is not None:
            pulumi.set(__self__, "multiclusteringress", multiclusteringress)

    @property
    @pulumi.getter
    def clusterupgrade(self) -> Optional[pulumi.Input['FeatureSpecClusterupgradeArgs']]:
        """
        Clusterupgrade feature spec.
        Structure is documented below.
        """
        return pulumi.get(self, "clusterupgrade")

    @clusterupgrade.setter
    def clusterupgrade(self, value: Optional[pulumi.Input['FeatureSpecClusterupgradeArgs']]):
        pulumi.set(self, "clusterupgrade", value)

    @property
    @pulumi.getter
    def fleetobservability(self) -> Optional[pulumi.Input['FeatureSpecFleetobservabilityArgs']]:
        """
        Fleet Observability feature spec.
        Structure is documented below.
        """
        return pulumi.get(self, "fleetobservability")

    @fleetobservability.setter
    def fleetobservability(self, value: Optional[pulumi.Input['FeatureSpecFleetobservabilityArgs']]):
        pulumi.set(self, "fleetobservability", value)

    @property
    @pulumi.getter
    def multiclusteringress(self) -> Optional[pulumi.Input['FeatureSpecMulticlusteringressArgs']]:
        """
        Multicluster Ingress-specific spec.
        Structure is documented below.
        """
        return pulumi.get(self, "multiclusteringress")

    @multiclusteringress.setter
    def multiclusteringress(self, value: Optional[pulumi.Input['FeatureSpecMulticlusteringressArgs']]):
        pulumi.set(self, "multiclusteringress", value)


if not MYPY:
    class FeatureSpecClusterupgradeArgsDict(TypedDict):
        upstream_fleets: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Specified if other fleet should be considered as a source of upgrades. Currently, at most one upstream fleet is allowed. The fleet name should be either fleet project number or id.
        """
        gke_upgrade_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideArgsDict']]]]
        """
        Configuration overrides for individual upgrades.
        Structure is documented below.
        """
        post_conditions: NotRequired[pulumi.Input['FeatureSpecClusterupgradePostConditionsArgsDict']]
        """
        Post conditions to override for the specified upgrade.
        Structure is documented below.
        """
elif False:
    FeatureSpecClusterupgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecClusterupgradeArgs:
    def __init__(__self__, *,
                 upstream_fleets: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 gke_upgrade_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideArgs']]]] = None,
                 post_conditions: Optional[pulumi.Input['FeatureSpecClusterupgradePostConditionsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] upstream_fleets: Specified if other fleet should be considered as a source of upgrades. Currently, at most one upstream fleet is allowed. The fleet name should be either fleet project number or id.
        :param pulumi.Input[Sequence[pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideArgs']]] gke_upgrade_overrides: Configuration overrides for individual upgrades.
               Structure is documented below.
        :param pulumi.Input['FeatureSpecClusterupgradePostConditionsArgs'] post_conditions: Post conditions to override for the specified upgrade.
               Structure is documented below.
        """
        pulumi.set(__self__, "upstream_fleets", upstream_fleets)
        if gke_upgrade_overrides is not None:
            pulumi.set(__self__, "gke_upgrade_overrides", gke_upgrade_overrides)
        if post_conditions is not None:
            pulumi.set(__self__, "post_conditions", post_conditions)

    @property
    @pulumi.getter(name="upstreamFleets")
    def upstream_fleets(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Specified if other fleet should be considered as a source of upgrades. Currently, at most one upstream fleet is allowed. The fleet name should be either fleet project number or id.
        """
        return pulumi.get(self, "upstream_fleets")

    @upstream_fleets.setter
    def upstream_fleets(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "upstream_fleets", value)

    @property
    @pulumi.getter(name="gkeUpgradeOverrides")
    def gke_upgrade_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideArgs']]]]:
        """
        Configuration overrides for individual upgrades.
        Structure is documented below.
        """
        return pulumi.get(self, "gke_upgrade_overrides")

    @gke_upgrade_overrides.setter
    def gke_upgrade_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideArgs']]]]):
        pulumi.set(self, "gke_upgrade_overrides", value)

    @property
    @pulumi.getter(name="postConditions")
    def post_conditions(self) -> Optional[pulumi.Input['FeatureSpecClusterupgradePostConditionsArgs']]:
        """
        Post conditions to override for the specified upgrade.
        Structure is documented below.
        """
        return pulumi.get(self, "post_conditions")

    @post_conditions.setter
    def post_conditions(self, value: Optional[pulumi.Input['FeatureSpecClusterupgradePostConditionsArgs']]):
        pulumi.set(self, "post_conditions", value)


if not MYPY:
    class FeatureSpecClusterupgradeGkeUpgradeOverrideArgsDict(TypedDict):
        post_conditions: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgsDict']
        """
        Post conditions to override for the specified upgrade.
        Structure is documented below.
        """
        upgrade: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgsDict']
        """
        Which upgrade to override.
        Structure is documented below.
        """
elif False:
    FeatureSpecClusterupgradeGkeUpgradeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecClusterupgradeGkeUpgradeOverrideArgs:
    def __init__(__self__, *,
                 post_conditions: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs'],
                 upgrade: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs']):
        """
        :param pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs'] post_conditions: Post conditions to override for the specified upgrade.
               Structure is documented below.
        :param pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs'] upgrade: Which upgrade to override.
               Structure is documented below.
        """
        pulumi.set(__self__, "post_conditions", post_conditions)
        pulumi.set(__self__, "upgrade", upgrade)

    @property
    @pulumi.getter(name="postConditions")
    def post_conditions(self) -> pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs']:
        """
        Post conditions to override for the specified upgrade.
        Structure is documented below.
        """
        return pulumi.get(self, "post_conditions")

    @post_conditions.setter
    def post_conditions(self, value: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs']):
        pulumi.set(self, "post_conditions", value)

    @property
    @pulumi.getter
    def upgrade(self) -> pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs']:
        """
        Which upgrade to override.
        Structure is documented below.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: pulumi.Input['FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs']):
        pulumi.set(self, "upgrade", value)


if not MYPY:
    class FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgsDict(TypedDict):
        soaking: pulumi.Input[builtins.str]
        """
        Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
elif False:
    FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecClusterupgradeGkeUpgradeOverridePostConditionsArgs:
    def __init__(__self__, *,
                 soaking: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] soaking: Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
        pulumi.set(__self__, "soaking", soaking)

    @property
    @pulumi.getter
    def soaking(self) -> pulumi.Input[builtins.str]:
        """
        Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
        return pulumi.get(self, "soaking")

    @soaking.setter
    def soaking(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "soaking", value)


if not MYPY:
    class FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the upgrade, e.g., "k8s_control_plane". It should be a valid upgrade name. It must not exceet 99 characters.
        """
        version: pulumi.Input[builtins.str]
        """
        Version of the upgrade, e.g., "1.22.1-gke.100". It should be a valid version. It must not exceet 99 characters.
        """
elif False:
    FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecClusterupgradeGkeUpgradeOverrideUpgradeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of the upgrade, e.g., "k8s_control_plane". It should be a valid upgrade name. It must not exceet 99 characters.
        :param pulumi.Input[builtins.str] version: Version of the upgrade, e.g., "1.22.1-gke.100". It should be a valid version. It must not exceet 99 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the upgrade, e.g., "k8s_control_plane". It should be a valid upgrade name. It must not exceet 99 characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        """
        Version of the upgrade, e.g., "1.22.1-gke.100". It should be a valid version. It must not exceet 99 characters.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FeatureSpecClusterupgradePostConditionsArgsDict(TypedDict):
        soaking: pulumi.Input[builtins.str]
        """
        Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
elif False:
    FeatureSpecClusterupgradePostConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecClusterupgradePostConditionsArgs:
    def __init__(__self__, *,
                 soaking: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] soaking: Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
        pulumi.set(__self__, "soaking", soaking)

    @property
    @pulumi.getter
    def soaking(self) -> pulumi.Input[builtins.str]:
        """
        Amount of time to "soak" after a rollout has been finished before marking it COMPLETE. Cannot exceed 30 days.
        """
        return pulumi.get(self, "soaking")

    @soaking.setter
    def soaking(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "soaking", value)


if not MYPY:
    class FeatureSpecFleetobservabilityArgsDict(TypedDict):
        logging_config: NotRequired[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigArgsDict']]
        """
        Specified if fleet logging feature is enabled for the entire fleet. If UNSPECIFIED, fleet logging feature is disabled for the entire fleet.
        Structure is documented below.
        """
elif False:
    FeatureSpecFleetobservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecFleetobservabilityArgs:
    def __init__(__self__, *,
                 logging_config: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigArgs']] = None):
        """
        :param pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigArgs'] logging_config: Specified if fleet logging feature is enabled for the entire fleet. If UNSPECIFIED, fleet logging feature is disabled for the entire fleet.
               Structure is documented below.
        """
        if logging_config is not None:
            pulumi.set(__self__, "logging_config", logging_config)

    @property
    @pulumi.getter(name="loggingConfig")
    def logging_config(self) -> Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigArgs']]:
        """
        Specified if fleet logging feature is enabled for the entire fleet. If UNSPECIFIED, fleet logging feature is disabled for the entire fleet.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_config")

    @logging_config.setter
    def logging_config(self, value: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigArgs']]):
        pulumi.set(self, "logging_config", value)


if not MYPY:
    class FeatureSpecFleetobservabilityLoggingConfigArgsDict(TypedDict):
        default_config: NotRequired[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgsDict']]
        """
        Specified if applying the default routing config to logs not specified in other configs.
        Structure is documented below.
        """
        fleet_scope_logs_config: NotRequired[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgsDict']]
        """
        Specified if applying the routing config to all logs for all fleet scopes.
        Structure is documented below.
        """
elif False:
    FeatureSpecFleetobservabilityLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecFleetobservabilityLoggingConfigArgs:
    def __init__(__self__, *,
                 default_config: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs']] = None,
                 fleet_scope_logs_config: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs']] = None):
        """
        :param pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs'] default_config: Specified if applying the default routing config to logs not specified in other configs.
               Structure is documented below.
        :param pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs'] fleet_scope_logs_config: Specified if applying the routing config to all logs for all fleet scopes.
               Structure is documented below.
        """
        if default_config is not None:
            pulumi.set(__self__, "default_config", default_config)
        if fleet_scope_logs_config is not None:
            pulumi.set(__self__, "fleet_scope_logs_config", fleet_scope_logs_config)

    @property
    @pulumi.getter(name="defaultConfig")
    def default_config(self) -> Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs']]:
        """
        Specified if applying the default routing config to logs not specified in other configs.
        Structure is documented below.
        """
        return pulumi.get(self, "default_config")

    @default_config.setter
    def default_config(self, value: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs']]):
        pulumi.set(self, "default_config", value)

    @property
    @pulumi.getter(name="fleetScopeLogsConfig")
    def fleet_scope_logs_config(self) -> Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs']]:
        """
        Specified if applying the routing config to all logs for all fleet scopes.
        Structure is documented below.
        """
        return pulumi.get(self, "fleet_scope_logs_config")

    @fleet_scope_logs_config.setter
    def fleet_scope_logs_config(self, value: Optional[pulumi.Input['FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs']]):
        pulumi.set(self, "fleet_scope_logs_config", value)


if not MYPY:
    class FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Specified if fleet logging feature is enabled.
        Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
elif False:
    FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecFleetobservabilityLoggingConfigDefaultConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] mode: Specified if fleet logging feature is enabled.
               Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specified if fleet logging feature is enabled.
        Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Specified if fleet logging feature is enabled.
        Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
elif False:
    FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecFleetobservabilityLoggingConfigFleetScopeLogsConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] mode: Specified if fleet logging feature is enabled.
               Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specified if fleet logging feature is enabled.
        Possible values are: `MODE_UNSPECIFIED`, `COPY`, `MOVE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FeatureSpecMulticlusteringressArgsDict(TypedDict):
        config_membership: pulumi.Input[builtins.str]
        """
        Fully-qualified Membership name which hosts the MultiClusterIngress CRD. Example: `projects/foo-proj/locations/global/memberships/bar`
        """
elif False:
    FeatureSpecMulticlusteringressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSpecMulticlusteringressArgs:
    def __init__(__self__, *,
                 config_membership: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] config_membership: Fully-qualified Membership name which hosts the MultiClusterIngress CRD. Example: `projects/foo-proj/locations/global/memberships/bar`
        """
        pulumi.set(__self__, "config_membership", config_membership)

    @property
    @pulumi.getter(name="configMembership")
    def config_membership(self) -> pulumi.Input[builtins.str]:
        """
        Fully-qualified Membership name which hosts the MultiClusterIngress CRD. Example: `projects/foo-proj/locations/global/memberships/bar`
        """
        return pulumi.get(self, "config_membership")

    @config_membership.setter
    def config_membership(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "config_membership", value)


if not MYPY:
    class FeatureStateArgsDict(TypedDict):
        states: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureStateStateArgsDict']]]]
        """
        (Output)
        Output only. The "running state" of the Feature in this Hub.
        Structure is documented below.
        """
elif False:
    FeatureStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureStateArgs:
    def __init__(__self__, *,
                 states: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureStateStateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FeatureStateStateArgs']]] states: (Output)
               Output only. The "running state" of the Feature in this Hub.
               Structure is documented below.
        """
        if states is not None:
            pulumi.set(__self__, "states", states)

    @property
    @pulumi.getter
    def states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureStateStateArgs']]]]:
        """
        (Output)
        Output only. The "running state" of the Feature in this Hub.
        Structure is documented below.
        """
        return pulumi.get(self, "states")

    @states.setter
    def states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureStateStateArgs']]]]):
        pulumi.set(self, "states", value)


if not MYPY:
    class FeatureStateStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The high-level, machine-readable status of this Feature.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        A human-readable description of the current status.
        """
        update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The time this status and any related Feature-specific details were updated. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
        """
elif False:
    FeatureStateStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureStateStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 update_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               The high-level, machine-readable status of this Feature.
        :param pulumi.Input[builtins.str] description: (Output)
               A human-readable description of the current status.
        :param pulumi.Input[builtins.str] update_time: (Output)
               The time this status and any related Feature-specific details were updated. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The high-level, machine-readable status of this Feature.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        A human-readable description of the current status.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The time this status and any related Feature-specific details were updated. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class FleetDefaultClusterConfigArgsDict(TypedDict):
        binary_authorization_config: NotRequired[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigArgsDict']]
        """
        Enable/Disable binary authorization features for the cluster.
        Structure is documented below.
        """
        security_posture_config: NotRequired[pulumi.Input['FleetDefaultClusterConfigSecurityPostureConfigArgsDict']]
        """
        Enable/Disable Security Posture features for the cluster.
        Structure is documented below.
        """
elif False:
    FleetDefaultClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDefaultClusterConfigArgs:
    def __init__(__self__, *,
                 binary_authorization_config: Optional[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigArgs']] = None,
                 security_posture_config: Optional[pulumi.Input['FleetDefaultClusterConfigSecurityPostureConfigArgs']] = None):
        """
        :param pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigArgs'] binary_authorization_config: Enable/Disable binary authorization features for the cluster.
               Structure is documented below.
        :param pulumi.Input['FleetDefaultClusterConfigSecurityPostureConfigArgs'] security_posture_config: Enable/Disable Security Posture features for the cluster.
               Structure is documented below.
        """
        if binary_authorization_config is not None:
            pulumi.set(__self__, "binary_authorization_config", binary_authorization_config)
        if security_posture_config is not None:
            pulumi.set(__self__, "security_posture_config", security_posture_config)

    @property
    @pulumi.getter(name="binaryAuthorizationConfig")
    def binary_authorization_config(self) -> Optional[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigArgs']]:
        """
        Enable/Disable binary authorization features for the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "binary_authorization_config")

    @binary_authorization_config.setter
    def binary_authorization_config(self, value: Optional[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigArgs']]):
        pulumi.set(self, "binary_authorization_config", value)

    @property
    @pulumi.getter(name="securityPostureConfig")
    def security_posture_config(self) -> Optional[pulumi.Input['FleetDefaultClusterConfigSecurityPostureConfigArgs']]:
        """
        Enable/Disable Security Posture features for the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "security_posture_config")

    @security_posture_config.setter
    def security_posture_config(self, value: Optional[pulumi.Input['FleetDefaultClusterConfigSecurityPostureConfigArgs']]):
        pulumi.set(self, "security_posture_config", value)


if not MYPY:
    class FleetDefaultClusterConfigBinaryAuthorizationConfigArgsDict(TypedDict):
        evaluation_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Mode of operation for binauthz policy evaluation.
        Possible values are: `DISABLED`, `POLICY_BINDINGS`.
        """
        policy_bindings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgsDict']]]]
        """
        Binauthz policies that apply to this cluster.
        Structure is documented below.
        """
elif False:
    FleetDefaultClusterConfigBinaryAuthorizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDefaultClusterConfigBinaryAuthorizationConfigArgs:
    def __init__(__self__, *,
                 evaluation_mode: Optional[pulumi.Input[builtins.str]] = None,
                 policy_bindings: Optional[pulumi.Input[Sequence[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] evaluation_mode: Mode of operation for binauthz policy evaluation.
               Possible values are: `DISABLED`, `POLICY_BINDINGS`.
        :param pulumi.Input[Sequence[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs']]] policy_bindings: Binauthz policies that apply to this cluster.
               Structure is documented below.
        """
        if evaluation_mode is not None:
            pulumi.set(__self__, "evaluation_mode", evaluation_mode)
        if policy_bindings is not None:
            pulumi.set(__self__, "policy_bindings", policy_bindings)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Mode of operation for binauthz policy evaluation.
        Possible values are: `DISABLED`, `POLICY_BINDINGS`.
        """
        return pulumi.get(self, "evaluation_mode")

    @evaluation_mode.setter
    def evaluation_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "evaluation_mode", value)

    @property
    @pulumi.getter(name="policyBindings")
    def policy_bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs']]]]:
        """
        Binauthz policies that apply to this cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "policy_bindings")

    @policy_bindings.setter
    def policy_bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs']]]]):
        pulumi.set(self, "policy_bindings", value)


if not MYPY:
    class FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The relative resource name of the binauthz platform policy to audit. GKE
        platform policies have the following format:
        `projects/{project_number}/platforms/gke/policies/{policy_id}`.
        """
elif False:
    FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDefaultClusterConfigBinaryAuthorizationConfigPolicyBindingArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The relative resource name of the binauthz platform policy to audit. GKE
               platform policies have the following format:
               `projects/{project_number}/platforms/gke/policies/{policy_id}`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The relative resource name of the binauthz platform policy to audit. GKE
        platform policies have the following format:
        `projects/{project_number}/platforms/gke/policies/{policy_id}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FleetDefaultClusterConfigSecurityPostureConfigArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets which mode to use for Security Posture features.
        Possible values are: `DISABLED`, `BASIC`, `ENTERPRISE`.
        """
        vulnerability_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets which mode to use for vulnerability scanning.
        Possible values are: `VULNERABILITY_DISABLED`, `VULNERABILITY_BASIC`, `VULNERABILITY_ENTERPRISE`.
        """
elif False:
    FleetDefaultClusterConfigSecurityPostureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDefaultClusterConfigSecurityPostureConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 vulnerability_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] mode: Sets which mode to use for Security Posture features.
               Possible values are: `DISABLED`, `BASIC`, `ENTERPRISE`.
        :param pulumi.Input[builtins.str] vulnerability_mode: Sets which mode to use for vulnerability scanning.
               Possible values are: `VULNERABILITY_DISABLED`, `VULNERABILITY_BASIC`, `VULNERABILITY_ENTERPRISE`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if vulnerability_mode is not None:
            pulumi.set(__self__, "vulnerability_mode", vulnerability_mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets which mode to use for Security Posture features.
        Possible values are: `DISABLED`, `BASIC`, `ENTERPRISE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="vulnerabilityMode")
    def vulnerability_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets which mode to use for vulnerability scanning.
        Possible values are: `VULNERABILITY_DISABLED`, `VULNERABILITY_BASIC`, `VULNERABILITY_ENTERPRISE`.
        """
        return pulumi.get(self, "vulnerability_mode")

    @vulnerability_mode.setter
    def vulnerability_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vulnerability_mode", value)


if not MYPY:
    class FleetStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Describes the state of a Fleet resource.
        """
elif False:
    FleetStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Describes the state of a Fleet resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Describes the state of a Fleet resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class MembershipAuthorityArgsDict(TypedDict):
        issuer: pulumi.Input[builtins.str]
elif False:
    MembershipAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipAuthorityArgs:
    def __init__(__self__, *,
                 issuer: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "issuer", issuer)

    @property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "issuer", value)


if not MYPY:
    class MembershipBindingStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Code describes the state of a MembershipBinding resource.
        """
elif False:
    MembershipBindingStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipBindingStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Code describes the state of a MembershipBinding resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Code describes the state of a MembershipBinding resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class MembershipEndpointArgsDict(TypedDict):
        gke_cluster: NotRequired[pulumi.Input['MembershipEndpointGkeClusterArgsDict']]
        """
        If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource.
        Structure is documented below.
        """
elif False:
    MembershipEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipEndpointArgs:
    def __init__(__self__, *,
                 gke_cluster: Optional[pulumi.Input['MembershipEndpointGkeClusterArgs']] = None):
        """
        :param pulumi.Input['MembershipEndpointGkeClusterArgs'] gke_cluster: If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource.
               Structure is documented below.
        """
        if gke_cluster is not None:
            pulumi.set(__self__, "gke_cluster", gke_cluster)

    @property
    @pulumi.getter(name="gkeCluster")
    def gke_cluster(self) -> Optional[pulumi.Input['MembershipEndpointGkeClusterArgs']]:
        """
        If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource.
        Structure is documented below.
        """
        return pulumi.get(self, "gke_cluster")

    @gke_cluster.setter
    def gke_cluster(self, value: Optional[pulumi.Input['MembershipEndpointGkeClusterArgs']]):
        pulumi.set(self, "gke_cluster", value)


if not MYPY:
    class MembershipEndpointGkeClusterArgsDict(TypedDict):
        resource_link: pulumi.Input[builtins.str]
elif False:
    MembershipEndpointGkeClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipEndpointGkeClusterArgs:
    def __init__(__self__, *,
                 resource_link: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "resource_link", resource_link)

    @property
    @pulumi.getter(name="resourceLink")
    def resource_link(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "resource_link")

    @resource_link.setter
    def resource_link(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_link", value)


if not MYPY:
    class MembershipIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    MembershipIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class MembershipIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    MembershipIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class MembershipRbacRoleBindingRoleArgsDict(TypedDict):
        predefined_role: pulumi.Input[builtins.str]
        """
        PredefinedRole is an ENUM representation of the default Kubernetes Roles
        Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`, `ANTHOS_SUPPORT`.

        - - -
        """
elif False:
    MembershipRbacRoleBindingRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipRbacRoleBindingRoleArgs:
    def __init__(__self__, *,
                 predefined_role: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] predefined_role: PredefinedRole is an ENUM representation of the default Kubernetes Roles
               Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`, `ANTHOS_SUPPORT`.
               
               - - -
        """
        pulumi.set(__self__, "predefined_role", predefined_role)

    @property
    @pulumi.getter(name="predefinedRole")
    def predefined_role(self) -> pulumi.Input[builtins.str]:
        """
        PredefinedRole is an ENUM representation of the default Kubernetes Roles
        Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`, `ANTHOS_SUPPORT`.

        - - -
        """
        return pulumi.get(self, "predefined_role")

    @predefined_role.setter
    def predefined_role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "predefined_role", value)


if not MYPY:
    class MembershipRbacRoleBindingStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Code describes the state of a RBAC Role Binding resource.
        """
elif False:
    MembershipRbacRoleBindingStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MembershipRbacRoleBindingStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Code describes the state of a RBAC Role Binding resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Code describes the state of a RBAC Role Binding resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class NamespaceStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Code describes the state of a Namespace resource.
        """
elif False:
    NamespaceStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Code describes the state of a Namespace resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Code describes the state of a Namespace resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class ScopeIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ScopeIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ScopeIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ScopeIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ScopeRbacRoleBindingRoleArgsDict(TypedDict):
        predefined_role: NotRequired[pulumi.Input[builtins.str]]
        """
        PredefinedRole is an ENUM representation of the default Kubernetes Roles
        Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`.

        - - -
        """
elif False:
    ScopeRbacRoleBindingRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeRbacRoleBindingRoleArgs:
    def __init__(__self__, *,
                 predefined_role: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] predefined_role: PredefinedRole is an ENUM representation of the default Kubernetes Roles
               Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`.
               
               - - -
        """
        if predefined_role is not None:
            pulumi.set(__self__, "predefined_role", predefined_role)

    @property
    @pulumi.getter(name="predefinedRole")
    def predefined_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PredefinedRole is an ENUM representation of the default Kubernetes Roles
        Possible values are: `UNKNOWN`, `ADMIN`, `EDIT`, `VIEW`.

        - - -
        """
        return pulumi.get(self, "predefined_role")

    @predefined_role.setter
    def predefined_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "predefined_role", value)


if not MYPY:
    class ScopeRbacRoleBindingStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Code describes the state of a RBAC Role Binding resource.
        """
elif False:
    ScopeRbacRoleBindingStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeRbacRoleBindingStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Code describes the state of a RBAC Role Binding resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Code describes the state of a RBAC Role Binding resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


if not MYPY:
    class ScopeStateArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Code describes the state of a Scope resource.
        """
elif False:
    ScopeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeStateArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] code: (Output)
               Code describes the state of a Scope resource.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Code describes the state of a Scope resource.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)


