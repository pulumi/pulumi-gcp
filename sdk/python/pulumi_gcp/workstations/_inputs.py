# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'WorkstationClusterConditionArgs',
    'WorkstationClusterConditionArgsDict',
    'WorkstationClusterDomainConfigArgs',
    'WorkstationClusterDomainConfigArgsDict',
    'WorkstationClusterPrivateClusterConfigArgs',
    'WorkstationClusterPrivateClusterConfigArgsDict',
    'WorkstationConfigConditionArgs',
    'WorkstationConfigConditionArgsDict',
    'WorkstationConfigContainerArgs',
    'WorkstationConfigContainerArgsDict',
    'WorkstationConfigEncryptionKeyArgs',
    'WorkstationConfigEncryptionKeyArgsDict',
    'WorkstationConfigEphemeralDirectoryArgs',
    'WorkstationConfigEphemeralDirectoryArgsDict',
    'WorkstationConfigEphemeralDirectoryGcePdArgs',
    'WorkstationConfigEphemeralDirectoryGcePdArgsDict',
    'WorkstationConfigHostArgs',
    'WorkstationConfigHostArgsDict',
    'WorkstationConfigHostGceInstanceArgs',
    'WorkstationConfigHostGceInstanceArgsDict',
    'WorkstationConfigHostGceInstanceAcceleratorArgs',
    'WorkstationConfigHostGceInstanceAcceleratorArgsDict',
    'WorkstationConfigHostGceInstanceBoostConfigArgs',
    'WorkstationConfigHostGceInstanceBoostConfigArgsDict',
    'WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs',
    'WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgsDict',
    'WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs',
    'WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgsDict',
    'WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs',
    'WorkstationConfigHostGceInstanceShieldedInstanceConfigArgsDict',
    'WorkstationConfigIamBindingConditionArgs',
    'WorkstationConfigIamBindingConditionArgsDict',
    'WorkstationConfigIamMemberConditionArgs',
    'WorkstationConfigIamMemberConditionArgsDict',
    'WorkstationConfigPersistentDirectoryArgs',
    'WorkstationConfigPersistentDirectoryArgsDict',
    'WorkstationConfigPersistentDirectoryGcePdArgs',
    'WorkstationConfigPersistentDirectoryGcePdArgsDict',
    'WorkstationConfigReadinessCheckArgs',
    'WorkstationConfigReadinessCheckArgsDict',
    'WorkstationIamBindingConditionArgs',
    'WorkstationIamBindingConditionArgsDict',
    'WorkstationIamMemberConditionArgs',
    'WorkstationIamMemberConditionArgsDict',
]

MYPY = False

if not MYPY:
    class WorkstationClusterConditionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The status code, which should be an enum value of google.rpc.Code.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]
        """
        (Output)
        A list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Human readable message indicating details about the current status.
        """
elif False:
    WorkstationClusterConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationClusterConditionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: (Output)
               The status code, which should be an enum value of google.rpc.Code.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] details: (Output)
               A list of messages that carry the error details.
        :param pulumi.Input[str] message: (Output)
               Human readable message indicating details about the current status.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        (Output)
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human readable message indicating details about the current status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class WorkstationClusterDomainConfigArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        Domain used by Workstations for HTTP ingress.
        """
elif False:
    WorkstationClusterDomainConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationClusterDomainConfigArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: Domain used by Workstations for HTTP ingress.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Domain used by Workstations for HTTP ingress.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class WorkstationClusterPrivateClusterConfigArgsDict(TypedDict):
        enable_private_endpoint: pulumi.Input[bool]
        """
        Whether Workstations endpoint is private.
        """
        allowed_projects: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Additional project IDs that are allowed to attach to the workstation cluster's service attachment.
        By default, the workstation cluster's project and the VPC host project (if different) are allowed.
        """
        cluster_hostname: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Hostname for the workstation cluster.
        This field will be populated only when private endpoint is enabled.
        To access workstations in the cluster, create a new DNS zone mapping this domain name to an internal IP address and a forwarding rule mapping that address to the service attachment.
        """
        service_attachment_uri: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Service attachment URI for the workstation cluster.
        The service attachment is created when private endpoint is enabled.
        To access workstations in the cluster, configure access to the managed service using (Private Service Connect)[https://cloud.google.com/vpc/docs/configure-private-service-connect-services].
        """
elif False:
    WorkstationClusterPrivateClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationClusterPrivateClusterConfigArgs:
    def __init__(__self__, *,
                 enable_private_endpoint: pulumi.Input[bool],
                 allowed_projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cluster_hostname: Optional[pulumi.Input[str]] = None,
                 service_attachment_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_private_endpoint: Whether Workstations endpoint is private.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_projects: Additional project IDs that are allowed to attach to the workstation cluster's service attachment.
               By default, the workstation cluster's project and the VPC host project (if different) are allowed.
        :param pulumi.Input[str] cluster_hostname: (Output)
               Hostname for the workstation cluster.
               This field will be populated only when private endpoint is enabled.
               To access workstations in the cluster, create a new DNS zone mapping this domain name to an internal IP address and a forwarding rule mapping that address to the service attachment.
        :param pulumi.Input[str] service_attachment_uri: (Output)
               Service attachment URI for the workstation cluster.
               The service attachment is created when private endpoint is enabled.
               To access workstations in the cluster, configure access to the managed service using (Private Service Connect)[https://cloud.google.com/vpc/docs/configure-private-service-connect-services].
        """
        pulumi.set(__self__, "enable_private_endpoint", enable_private_endpoint)
        if allowed_projects is not None:
            pulumi.set(__self__, "allowed_projects", allowed_projects)
        if cluster_hostname is not None:
            pulumi.set(__self__, "cluster_hostname", cluster_hostname)
        if service_attachment_uri is not None:
            pulumi.set(__self__, "service_attachment_uri", service_attachment_uri)

    @property
    @pulumi.getter(name="enablePrivateEndpoint")
    def enable_private_endpoint(self) -> pulumi.Input[bool]:
        """
        Whether Workstations endpoint is private.
        """
        return pulumi.get(self, "enable_private_endpoint")

    @enable_private_endpoint.setter
    def enable_private_endpoint(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_private_endpoint", value)

    @property
    @pulumi.getter(name="allowedProjects")
    def allowed_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Additional project IDs that are allowed to attach to the workstation cluster's service attachment.
        By default, the workstation cluster's project and the VPC host project (if different) are allowed.
        """
        return pulumi.get(self, "allowed_projects")

    @allowed_projects.setter
    def allowed_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_projects", value)

    @property
    @pulumi.getter(name="clusterHostname")
    def cluster_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Hostname for the workstation cluster.
        This field will be populated only when private endpoint is enabled.
        To access workstations in the cluster, create a new DNS zone mapping this domain name to an internal IP address and a forwarding rule mapping that address to the service attachment.
        """
        return pulumi.get(self, "cluster_hostname")

    @cluster_hostname.setter
    def cluster_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_hostname", value)

    @property
    @pulumi.getter(name="serviceAttachmentUri")
    def service_attachment_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Service attachment URI for the workstation cluster.
        The service attachment is created when private endpoint is enabled.
        To access workstations in the cluster, configure access to the managed service using (Private Service Connect)[https://cloud.google.com/vpc/docs/configure-private-service-connect-services].
        """
        return pulumi.get(self, "service_attachment_uri")

    @service_attachment_uri.setter
    def service_attachment_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_attachment_uri", value)


if not MYPY:
    class WorkstationConfigConditionArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The status code, which should be an enum value of google.rpc.Code.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]
        """
        (Output)
        A list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Human readable message indicating details about the current status.
        """
elif False:
    WorkstationConfigConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigConditionArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: (Output)
               The status code, which should be an enum value of google.rpc.Code.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] details: (Output)
               A list of messages that carry the error details.
        :param pulumi.Input[str] message: (Output)
               Human readable message indicating details about the current status.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        (Output)
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human readable message indicating details about the current status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class WorkstationConfigContainerArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Arguments passed to the entrypoint.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If set, overrides the default ENTRYPOINT specified by the image.
        """
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Environment variables passed to the container.
        The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image defining the container. This image must be accessible by the config's service account.
        """
        run_as_user: NotRequired[pulumi.Input[int]]
        """
        If set, overrides the USER specified in the image with the given uid.
        """
        working_dir: NotRequired[pulumi.Input[str]]
        """
        If set, overrides the default DIR specified by the image.
        """
elif False:
    WorkstationConfigContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 working_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments passed to the entrypoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: If set, overrides the default ENTRYPOINT specified by the image.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env: Environment variables passed to the container.
               The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
        :param pulumi.Input[str] image: Docker image defining the container. This image must be accessible by the config's service account.
        :param pulumi.Input[int] run_as_user: If set, overrides the USER specified in the image with the given uid.
        :param pulumi.Input[str] working_dir: If set, overrides the default DIR specified by the image.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments passed to the entrypoint.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If set, overrides the default ENTRYPOINT specified by the image.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Environment variables passed to the container.
        The elements are of the form "KEY=VALUE" for the environment variable "KEY" being given the value "VALUE".
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image defining the container. This image must be accessible by the config's service account.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        """
        If set, overrides the USER specified in the image with the given uid.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[str]]:
        """
        If set, overrides the default DIR specified by the image.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class WorkstationConfigEncryptionKeyArgsDict(TypedDict):
        kms_key: pulumi.Input[str]
        """
        The name of the Google Cloud KMS encryption key.
        """
        kms_key_service_account: pulumi.Input[str]
        """
        The service account to use with the specified KMS key.
        """
elif False:
    WorkstationConfigEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigEncryptionKeyArgs:
    def __init__(__self__, *,
                 kms_key: pulumi.Input[str],
                 kms_key_service_account: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key: The name of the Google Cloud KMS encryption key.
        :param pulumi.Input[str] kms_key_service_account: The service account to use with the specified KMS key.
        """
        pulumi.set(__self__, "kms_key", kms_key)
        pulumi.set(__self__, "kms_key_service_account", kms_key_service_account)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> pulumi.Input[str]:
        """
        The name of the Google Cloud KMS encryption key.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter(name="kmsKeyServiceAccount")
    def kms_key_service_account(self) -> pulumi.Input[str]:
        """
        The service account to use with the specified KMS key.
        """
        return pulumi.get(self, "kms_key_service_account")

    @kms_key_service_account.setter
    def kms_key_service_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_service_account", value)


if not MYPY:
    class WorkstationConfigEphemeralDirectoryArgsDict(TypedDict):
        gce_pd: NotRequired[pulumi.Input['WorkstationConfigEphemeralDirectoryGcePdArgsDict']]
        """
        An EphemeralDirectory backed by a Compute Engine persistent disk.
        Structure is documented below.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        Location of this directory in the running workstation.
        """
elif False:
    WorkstationConfigEphemeralDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigEphemeralDirectoryArgs:
    def __init__(__self__, *,
                 gce_pd: Optional[pulumi.Input['WorkstationConfigEphemeralDirectoryGcePdArgs']] = None,
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkstationConfigEphemeralDirectoryGcePdArgs'] gce_pd: An EphemeralDirectory backed by a Compute Engine persistent disk.
               Structure is documented below.
        :param pulumi.Input[str] mount_path: Location of this directory in the running workstation.
        """
        if gce_pd is not None:
            pulumi.set(__self__, "gce_pd", gce_pd)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="gcePd")
    def gce_pd(self) -> Optional[pulumi.Input['WorkstationConfigEphemeralDirectoryGcePdArgs']]:
        """
        An EphemeralDirectory backed by a Compute Engine persistent disk.
        Structure is documented below.
        """
        return pulumi.get(self, "gce_pd")

    @gce_pd.setter
    def gce_pd(self, value: Optional[pulumi.Input['WorkstationConfigEphemeralDirectoryGcePdArgs']]):
        pulumi.set(self, "gce_pd", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Location of this directory in the running workstation.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class WorkstationConfigEphemeralDirectoryGcePdArgsDict(TypedDict):
        disk_type: NotRequired[pulumi.Input[str]]
        """
        Type of the disk to use. Defaults to `"pd-standard"`.
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Whether the disk is read only. If true, the disk may be shared by multiple VMs and `sourceSnapshot` must be set.
        """
        source_image: NotRequired[pulumi.Input[str]]
        """
        Name of the disk image to use as the source for the disk.
        Must be empty `sourceSnapshot` is set.
        Updating `sourceImage` will update content in the ephemeral directory after the workstation is restarted.
        """
        source_snapshot: NotRequired[pulumi.Input[str]]
        """
        Name of the snapshot to use as the source for the disk.
        Must be empty if `sourceImage` is set.
        Must be empty if `read_only` is false.
        Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
elif False:
    WorkstationConfigEphemeralDirectoryGcePdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigEphemeralDirectoryGcePdArgs:
    def __init__(__self__, *,
                 disk_type: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 source_image: Optional[pulumi.Input[str]] = None,
                 source_snapshot: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disk_type: Type of the disk to use. Defaults to `"pd-standard"`.
        :param pulumi.Input[bool] read_only: Whether the disk is read only. If true, the disk may be shared by multiple VMs and `sourceSnapshot` must be set.
        :param pulumi.Input[str] source_image: Name of the disk image to use as the source for the disk.
               Must be empty `sourceSnapshot` is set.
               Updating `sourceImage` will update content in the ephemeral directory after the workstation is restarted.
        :param pulumi.Input[str] source_snapshot: Name of the snapshot to use as the source for the disk.
               Must be empty if `sourceImage` is set.
               Must be empty if `read_only` is false.
               Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)
        if source_snapshot is not None:
            pulumi.set(__self__, "source_snapshot", source_snapshot)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the disk to use. Defaults to `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the disk is read only. If true, the disk may be shared by multiple VMs and `sourceSnapshot` must be set.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the disk image to use as the source for the disk.
        Must be empty `sourceSnapshot` is set.
        Updating `sourceImage` will update content in the ephemeral directory after the workstation is restarted.
        """
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_image", value)

    @property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the snapshot to use as the source for the disk.
        Must be empty if `sourceImage` is set.
        Must be empty if `read_only` is false.
        Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
        return pulumi.get(self, "source_snapshot")

    @source_snapshot.setter
    def source_snapshot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_snapshot", value)


if not MYPY:
    class WorkstationConfigHostArgsDict(TypedDict):
        gce_instance: NotRequired[pulumi.Input['WorkstationConfigHostGceInstanceArgsDict']]
        """
        A runtime using a Compute Engine instance.
        Structure is documented below.
        """
elif False:
    WorkstationConfigHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostArgs:
    def __init__(__self__, *,
                 gce_instance: Optional[pulumi.Input['WorkstationConfigHostGceInstanceArgs']] = None):
        """
        :param pulumi.Input['WorkstationConfigHostGceInstanceArgs'] gce_instance: A runtime using a Compute Engine instance.
               Structure is documented below.
        """
        if gce_instance is not None:
            pulumi.set(__self__, "gce_instance", gce_instance)

    @property
    @pulumi.getter(name="gceInstance")
    def gce_instance(self) -> Optional[pulumi.Input['WorkstationConfigHostGceInstanceArgs']]:
        """
        A runtime using a Compute Engine instance.
        Structure is documented below.
        """
        return pulumi.get(self, "gce_instance")

    @gce_instance.setter
    def gce_instance(self, value: Optional[pulumi.Input['WorkstationConfigHostGceInstanceArgs']]):
        pulumi.set(self, "gce_instance", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceArgsDict(TypedDict):
        accelerators: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceAcceleratorArgsDict']]]]
        """
        An accelerator card attached to the instance.
        Structure is documented below.
        """
        boost_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigArgsDict']]]]
        """
        A list of the boost configurations that workstations created using this workstation configuration are allowed to use.
        Structure is documented below.
        """
        boot_disk_size_gb: NotRequired[pulumi.Input[int]]
        """
        Size of the boot disk in GB.
        """
        confidential_instance_config: NotRequired[pulumi.Input['WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgsDict']]
        """
        A set of Compute Engine Confidential VM instance options.
        Structure is documented below.
        """
        disable_public_ip_addresses: NotRequired[pulumi.Input[bool]]
        """
        Whether instances have no public IP address.
        """
        disable_ssh: NotRequired[pulumi.Input[bool]]
        """
        Whether to disable SSH access to the VM.
        """
        enable_nested_virtualization: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable nested virtualization on the Compute Engine VMs backing the Workstations.
        See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        """
        machine_type: NotRequired[pulumi.Input[str]]
        """
        The name of a Compute Engine machine type.
        """
        pool_size: NotRequired[pulumi.Input[int]]
        """
        Number of instances to pool for faster workstation startup.
        """
        service_account: NotRequired[pulumi.Input[str]]
        """
        Email address of the service account that will be used on VM instances used to support this config. This service account must have permission to pull the specified container image. If not set, VMs will run without a service account, in which case the image must be publicly accessible.
        """
        service_account_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Scopes to grant to the service_account. Various scopes are automatically added based on feature usage. When specified, users of workstations under this configuration must have `iam.serviceAccounts.actAs` on the service account.
        """
        shielded_instance_config: NotRequired[pulumi.Input['WorkstationConfigHostGceInstanceShieldedInstanceConfigArgsDict']]
        """
        A set of Compute Engine Shielded instance options.
        Structure is documented below.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Network tags to add to the Compute Engine machines backing the Workstations.
        """
elif False:
    WorkstationConfigHostGceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceArgs:
    def __init__(__self__, *,
                 accelerators: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceAcceleratorArgs']]]] = None,
                 boost_configs: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigArgs']]]] = None,
                 boot_disk_size_gb: Optional[pulumi.Input[int]] = None,
                 confidential_instance_config: Optional[pulumi.Input['WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs']] = None,
                 disable_public_ip_addresses: Optional[pulumi.Input[bool]] = None,
                 disable_ssh: Optional[pulumi.Input[bool]] = None,
                 enable_nested_virtualization: Optional[pulumi.Input[bool]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 pool_size: Optional[pulumi.Input[int]] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 service_account_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 shielded_instance_config: Optional[pulumi.Input['WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceAcceleratorArgs']]] accelerators: An accelerator card attached to the instance.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigArgs']]] boost_configs: A list of the boost configurations that workstations created using this workstation configuration are allowed to use.
               Structure is documented below.
        :param pulumi.Input[int] boot_disk_size_gb: Size of the boot disk in GB.
        :param pulumi.Input['WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs'] confidential_instance_config: A set of Compute Engine Confidential VM instance options.
               Structure is documented below.
        :param pulumi.Input[bool] disable_public_ip_addresses: Whether instances have no public IP address.
        :param pulumi.Input[bool] disable_ssh: Whether to disable SSH access to the VM.
        :param pulumi.Input[bool] enable_nested_virtualization: Whether to enable nested virtualization on the Compute Engine VMs backing the Workstations.
               See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        :param pulumi.Input[str] machine_type: The name of a Compute Engine machine type.
        :param pulumi.Input[int] pool_size: Number of instances to pool for faster workstation startup.
        :param pulumi.Input[str] service_account: Email address of the service account that will be used on VM instances used to support this config. This service account must have permission to pull the specified container image. If not set, VMs will run without a service account, in which case the image must be publicly accessible.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_account_scopes: Scopes to grant to the service_account. Various scopes are automatically added based on feature usage. When specified, users of workstations under this configuration must have `iam.serviceAccounts.actAs` on the service account.
        :param pulumi.Input['WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs'] shielded_instance_config: A set of Compute Engine Shielded instance options.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Network tags to add to the Compute Engine machines backing the Workstations.
        """
        if accelerators is not None:
            pulumi.set(__self__, "accelerators", accelerators)
        if boost_configs is not None:
            pulumi.set(__self__, "boost_configs", boost_configs)
        if boot_disk_size_gb is not None:
            pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        if confidential_instance_config is not None:
            pulumi.set(__self__, "confidential_instance_config", confidential_instance_config)
        if disable_public_ip_addresses is not None:
            pulumi.set(__self__, "disable_public_ip_addresses", disable_public_ip_addresses)
        if disable_ssh is not None:
            pulumi.set(__self__, "disable_ssh", disable_ssh)
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if service_account_scopes is not None:
            pulumi.set(__self__, "service_account_scopes", service_account_scopes)
        if shielded_instance_config is not None:
            pulumi.set(__self__, "shielded_instance_config", shielded_instance_config)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def accelerators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceAcceleratorArgs']]]]:
        """
        An accelerator card attached to the instance.
        Structure is documented below.
        """
        return pulumi.get(self, "accelerators")

    @accelerators.setter
    def accelerators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceAcceleratorArgs']]]]):
        pulumi.set(self, "accelerators", value)

    @property
    @pulumi.getter(name="boostConfigs")
    def boost_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigArgs']]]]:
        """
        A list of the boost configurations that workstations created using this workstation configuration are allowed to use.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_configs")

    @boost_configs.setter
    def boost_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigArgs']]]]):
        pulumi.set(self, "boost_configs", value)

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the boot disk in GB.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @boot_disk_size_gb.setter
    def boot_disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size_gb", value)

    @property
    @pulumi.getter(name="confidentialInstanceConfig")
    def confidential_instance_config(self) -> Optional[pulumi.Input['WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs']]:
        """
        A set of Compute Engine Confidential VM instance options.
        Structure is documented below.
        """
        return pulumi.get(self, "confidential_instance_config")

    @confidential_instance_config.setter
    def confidential_instance_config(self, value: Optional[pulumi.Input['WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs']]):
        pulumi.set(self, "confidential_instance_config", value)

    @property
    @pulumi.getter(name="disablePublicIpAddresses")
    def disable_public_ip_addresses(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether instances have no public IP address.
        """
        return pulumi.get(self, "disable_public_ip_addresses")

    @disable_public_ip_addresses.setter
    def disable_public_ip_addresses(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_public_ip_addresses", value)

    @property
    @pulumi.getter(name="disableSsh")
    def disable_ssh(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable SSH access to the VM.
        """
        return pulumi.get(self, "disable_ssh")

    @disable_ssh.setter
    def disable_ssh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_ssh", value)

    @property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable nested virtualization on the Compute Engine VMs backing the Workstations.
        See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @enable_nested_virtualization.setter
    def enable_nested_virtualization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_nested_virtualization", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Compute Engine machine type.
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        Number of instances to pool for faster workstation startup.
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_size", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Email address of the service account that will be used on VM instances used to support this config. This service account must have permission to pull the specified container image. If not set, VMs will run without a service account, in which case the image must be publicly accessible.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter(name="serviceAccountScopes")
    def service_account_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Scopes to grant to the service_account. Various scopes are automatically added based on feature usage. When specified, users of workstations under this configuration must have `iam.serviceAccounts.actAs` on the service account.
        """
        return pulumi.get(self, "service_account_scopes")

    @service_account_scopes.setter
    def service_account_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_account_scopes", value)

    @property
    @pulumi.getter(name="shieldedInstanceConfig")
    def shielded_instance_config(self) -> Optional[pulumi.Input['WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs']]:
        """
        A set of Compute Engine Shielded instance options.
        Structure is documented below.
        """
        return pulumi.get(self, "shielded_instance_config")

    @shielded_instance_config.setter
    def shielded_instance_config(self, value: Optional[pulumi.Input['WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs']]):
        pulumi.set(self, "shielded_instance_config", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Network tags to add to the Compute Engine machines backing the Workstations.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceAcceleratorArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        Number of accelerator cards exposed to the instance.
        """
        type: pulumi.Input[str]
        """
        Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
elif False:
    WorkstationConfigHostGceInstanceAcceleratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceAcceleratorArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: Number of accelerator cards exposed to the instance.
        :param pulumi.Input[str] type: Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Number of accelerator cards exposed to the instance.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceBoostConfigArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The id to be used for the boost config.
        """
        accelerators: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgsDict']]]]
        """
        An accelerator card attached to the boost instance.
        Structure is documented below.
        """
        boot_disk_size_gb: NotRequired[pulumi.Input[int]]
        """
        Size of the boot disk in GB. The minimum boot disk size is `30` GB. Defaults to `50` GB.
        """
        enable_nested_virtualization: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable nested virtualization on the Compute Engine VMs backing boosted Workstations.
        See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        """
        machine_type: NotRequired[pulumi.Input[str]]
        """
        The type of machine that boosted VM instances will useâ€”for example, e2-standard-4. For more information about machine types that Cloud Workstations supports, see the list of available machine types https://cloud.google.com/workstations/docs/available-machine-types. Defaults to e2-standard-4.
        """
        pool_size: NotRequired[pulumi.Input[int]]
        """
        Number of instances to pool for faster workstation boosting.
        """
elif False:
    WorkstationConfigHostGceInstanceBoostConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceBoostConfigArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 accelerators: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs']]]] = None,
                 boot_disk_size_gb: Optional[pulumi.Input[int]] = None,
                 enable_nested_virtualization: Optional[pulumi.Input[bool]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 pool_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The id to be used for the boost config.
        :param pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs']]] accelerators: An accelerator card attached to the boost instance.
               Structure is documented below.
        :param pulumi.Input[int] boot_disk_size_gb: Size of the boot disk in GB. The minimum boot disk size is `30` GB. Defaults to `50` GB.
        :param pulumi.Input[bool] enable_nested_virtualization: Whether to enable nested virtualization on the Compute Engine VMs backing boosted Workstations.
               See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        :param pulumi.Input[str] machine_type: The type of machine that boosted VM instances will useâ€”for example, e2-standard-4. For more information about machine types that Cloud Workstations supports, see the list of available machine types https://cloud.google.com/workstations/docs/available-machine-types. Defaults to e2-standard-4.
        :param pulumi.Input[int] pool_size: Number of instances to pool for faster workstation boosting.
        """
        pulumi.set(__self__, "id", id)
        if accelerators is not None:
            pulumi.set(__self__, "accelerators", accelerators)
        if boot_disk_size_gb is not None:
            pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        if enable_nested_virtualization is not None:
            pulumi.set(__self__, "enable_nested_virtualization", enable_nested_virtualization)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id to be used for the boost config.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def accelerators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs']]]]:
        """
        An accelerator card attached to the boost instance.
        Structure is documented below.
        """
        return pulumi.get(self, "accelerators")

    @accelerators.setter
    def accelerators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs']]]]):
        pulumi.set(self, "accelerators", value)

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the boot disk in GB. The minimum boot disk size is `30` GB. Defaults to `50` GB.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @boot_disk_size_gb.setter
    def boot_disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size_gb", value)

    @property
    @pulumi.getter(name="enableNestedVirtualization")
    def enable_nested_virtualization(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable nested virtualization on the Compute Engine VMs backing boosted Workstations.
        See https://cloud.google.com/workstations/docs/reference/rest/v1beta/projects.locations.workstationClusters.workstationConfigs#GceInstance.FIELDS.enable_nested_virtualization
        """
        return pulumi.get(self, "enable_nested_virtualization")

    @enable_nested_virtualization.setter
    def enable_nested_virtualization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_nested_virtualization", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of machine that boosted VM instances will useâ€”for example, e2-standard-4. For more information about machine types that Cloud Workstations supports, see the list of available machine types https://cloud.google.com/workstations/docs/available-machine-types. Defaults to e2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        Number of instances to pool for faster workstation boosting.
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_size", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        Number of accelerator cards exposed to the instance.
        """
        type: pulumi.Input[str]
        """
        Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
elif False:
    WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceBoostConfigAcceleratorArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: Number of accelerator cards exposed to the instance.
        :param pulumi.Input[str] type: Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Number of accelerator cards exposed to the instance.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of accelerator resource to attach to the instance, for example, "nvidia-tesla-p100".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgsDict(TypedDict):
        enable_confidential_compute: NotRequired[pulumi.Input[bool]]
        """
        Whether the instance has confidential compute enabled.
        """
elif False:
    WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceConfidentialInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_confidential_compute: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_confidential_compute: Whether the instance has confidential compute enabled.
        """
        if enable_confidential_compute is not None:
            pulumi.set(__self__, "enable_confidential_compute", enable_confidential_compute)

    @property
    @pulumi.getter(name="enableConfidentialCompute")
    def enable_confidential_compute(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance has confidential compute enabled.
        """
        return pulumi.get(self, "enable_confidential_compute")

    @enable_confidential_compute.setter
    def enable_confidential_compute(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_confidential_compute", value)


if not MYPY:
    class WorkstationConfigHostGceInstanceShieldedInstanceConfigArgsDict(TypedDict):
        enable_integrity_monitoring: NotRequired[pulumi.Input[bool]]
        """
        Whether the instance has integrity monitoring enabled.
        """
        enable_secure_boot: NotRequired[pulumi.Input[bool]]
        """
        Whether the instance has Secure Boot enabled.
        """
        enable_vtpm: NotRequired[pulumi.Input[bool]]
        """
        Whether the instance has the vTPM enabled.
        """
elif False:
    WorkstationConfigHostGceInstanceShieldedInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigHostGceInstanceShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[bool]] = None,
                 enable_vtpm: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_integrity_monitoring: Whether the instance has integrity monitoring enabled.
        :param pulumi.Input[bool] enable_secure_boot: Whether the instance has Secure Boot enabled.
        :param pulumi.Input[bool] enable_vtpm: Whether the instance has the vTPM enabled.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance has integrity monitoring enabled.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance has Secure Boot enabled.
        """
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_secure_boot", value)

    @property
    @pulumi.getter(name="enableVtpm")
    def enable_vtpm(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance has the vTPM enabled.
        """
        return pulumi.get(self, "enable_vtpm")

    @enable_vtpm.setter
    def enable_vtpm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_vtpm", value)


if not MYPY:
    class WorkstationConfigIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    WorkstationConfigIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WorkstationConfigIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    WorkstationConfigIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WorkstationConfigPersistentDirectoryArgsDict(TypedDict):
        gce_pd: NotRequired[pulumi.Input['WorkstationConfigPersistentDirectoryGcePdArgsDict']]
        """
        A directory to persist across workstation sessions, backed by a Compute Engine regional persistent disk. Can only be updated if not empty during creation.
        Structure is documented below.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        Location of this directory in the running workstation.
        """
elif False:
    WorkstationConfigPersistentDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigPersistentDirectoryArgs:
    def __init__(__self__, *,
                 gce_pd: Optional[pulumi.Input['WorkstationConfigPersistentDirectoryGcePdArgs']] = None,
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkstationConfigPersistentDirectoryGcePdArgs'] gce_pd: A directory to persist across workstation sessions, backed by a Compute Engine regional persistent disk. Can only be updated if not empty during creation.
               Structure is documented below.
        :param pulumi.Input[str] mount_path: Location of this directory in the running workstation.
        """
        if gce_pd is not None:
            pulumi.set(__self__, "gce_pd", gce_pd)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="gcePd")
    def gce_pd(self) -> Optional[pulumi.Input['WorkstationConfigPersistentDirectoryGcePdArgs']]:
        """
        A directory to persist across workstation sessions, backed by a Compute Engine regional persistent disk. Can only be updated if not empty during creation.
        Structure is documented below.
        """
        return pulumi.get(self, "gce_pd")

    @gce_pd.setter
    def gce_pd(self, value: Optional[pulumi.Input['WorkstationConfigPersistentDirectoryGcePdArgs']]):
        pulumi.set(self, "gce_pd", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Location of this directory in the running workstation.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class WorkstationConfigPersistentDirectoryGcePdArgsDict(TypedDict):
        disk_type: NotRequired[pulumi.Input[str]]
        """
        Type of the disk to use. Defaults to `"pd-standard"`.
        """
        fs_type: NotRequired[pulumi.Input[str]]
        """
        Type of file system that the disk should be formatted with. The workstation image must support this file system type. Must be empty if `sourceSnapshot` is set. Defaults to `ext4`.
        """
        reclaim_policy: NotRequired[pulumi.Input[str]]
        """
        Whether the persistent disk should be deleted when the workstation is deleted. Valid values are `DELETE` and `RETAIN`. Defaults to `DELETE`.
        Possible values are: `DELETE`, `RETAIN`.
        """
        size_gb: NotRequired[pulumi.Input[int]]
        """
        The GB capacity of a persistent home directory for each workstation created with this configuration. Must be empty if `sourceSnapshot` is set.
        Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`. Defaults to `200`. If less than `200` GB, the `diskType` must be `pd-balanced` or `pd-ssd`.
        """
        source_snapshot: NotRequired[pulumi.Input[str]]
        """
        Name of the snapshot to use as the source for the disk.
        Must be empty if `sourceImage` is set.
        Must be empty if `read_only` is false.
        Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
elif False:
    WorkstationConfigPersistentDirectoryGcePdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigPersistentDirectoryGcePdArgs:
    def __init__(__self__, *,
                 disk_type: Optional[pulumi.Input[str]] = None,
                 fs_type: Optional[pulumi.Input[str]] = None,
                 reclaim_policy: Optional[pulumi.Input[str]] = None,
                 size_gb: Optional[pulumi.Input[int]] = None,
                 source_snapshot: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disk_type: Type of the disk to use. Defaults to `"pd-standard"`.
        :param pulumi.Input[str] fs_type: Type of file system that the disk should be formatted with. The workstation image must support this file system type. Must be empty if `sourceSnapshot` is set. Defaults to `ext4`.
        :param pulumi.Input[str] reclaim_policy: Whether the persistent disk should be deleted when the workstation is deleted. Valid values are `DELETE` and `RETAIN`. Defaults to `DELETE`.
               Possible values are: `DELETE`, `RETAIN`.
        :param pulumi.Input[int] size_gb: The GB capacity of a persistent home directory for each workstation created with this configuration. Must be empty if `sourceSnapshot` is set.
               Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`. Defaults to `200`. If less than `200` GB, the `diskType` must be `pd-balanced` or `pd-ssd`.
        :param pulumi.Input[str] source_snapshot: Name of the snapshot to use as the source for the disk.
               Must be empty if `sourceImage` is set.
               Must be empty if `read_only` is false.
               Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if reclaim_policy is not None:
            pulumi.set(__self__, "reclaim_policy", reclaim_policy)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)
        if source_snapshot is not None:
            pulumi.set(__self__, "source_snapshot", source_snapshot)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the disk to use. Defaults to `"pd-standard"`.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of file system that the disk should be formatted with. The workstation image must support this file system type. Must be empty if `sourceSnapshot` is set. Defaults to `ext4`.
        """
        return pulumi.get(self, "fs_type")

    @fs_type.setter
    def fs_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_type", value)

    @property
    @pulumi.getter(name="reclaimPolicy")
    def reclaim_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the persistent disk should be deleted when the workstation is deleted. Valid values are `DELETE` and `RETAIN`. Defaults to `DELETE`.
        Possible values are: `DELETE`, `RETAIN`.
        """
        return pulumi.get(self, "reclaim_policy")

    @reclaim_policy.setter
    def reclaim_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reclaim_policy", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The GB capacity of a persistent home directory for each workstation created with this configuration. Must be empty if `sourceSnapshot` is set.
        Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`. Defaults to `200`. If less than `200` GB, the `diskType` must be `pd-balanced` or `pd-ssd`.
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_gb", value)

    @property
    @pulumi.getter(name="sourceSnapshot")
    def source_snapshot(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the snapshot to use as the source for the disk.
        Must be empty if `sourceImage` is set.
        Must be empty if `read_only` is false.
        Updating `source_snapshot` will update content in the ephemeral directory after the workstation is restarted.
        """
        return pulumi.get(self, "source_snapshot")

    @source_snapshot.setter
    def source_snapshot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_snapshot", value)


if not MYPY:
    class WorkstationConfigReadinessCheckArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        Path to which the request should be sent.
        """
        port: pulumi.Input[int]
        """
        Port to which the request should be sent.
        """
elif False:
    WorkstationConfigReadinessCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationConfigReadinessCheckArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] path: Path to which the request should be sent.
        :param pulumi.Input[int] port: Port to which the request should be sent.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to which the request should be sent.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port to which the request should be sent.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WorkstationIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    WorkstationIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WorkstationIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    WorkstationIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkstationIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


