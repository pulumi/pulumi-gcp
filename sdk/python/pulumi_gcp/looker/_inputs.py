# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceAdminSettingsArgs',
    'InstanceAdminSettingsArgsDict',
    'InstanceCustomDomainArgs',
    'InstanceCustomDomainArgsDict',
    'InstanceDenyMaintenancePeriodArgs',
    'InstanceDenyMaintenancePeriodArgsDict',
    'InstanceDenyMaintenancePeriodEndDateArgs',
    'InstanceDenyMaintenancePeriodEndDateArgsDict',
    'InstanceDenyMaintenancePeriodStartDateArgs',
    'InstanceDenyMaintenancePeriodStartDateArgsDict',
    'InstanceDenyMaintenancePeriodTimeArgs',
    'InstanceDenyMaintenancePeriodTimeArgsDict',
    'InstanceEncryptionConfigArgs',
    'InstanceEncryptionConfigArgsDict',
    'InstanceMaintenanceWindowArgs',
    'InstanceMaintenanceWindowArgsDict',
    'InstanceMaintenanceWindowStartTimeArgs',
    'InstanceMaintenanceWindowStartTimeArgsDict',
    'InstanceOauthConfigArgs',
    'InstanceOauthConfigArgsDict',
    'InstancePscConfigArgs',
    'InstancePscConfigArgsDict',
    'InstancePscConfigServiceAttachmentArgs',
    'InstancePscConfigServiceAttachmentArgsDict',
    'InstanceUserMetadataArgs',
    'InstanceUserMetadataArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceAdminSettingsArgsDict(TypedDict):
        allowed_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    InstanceAdminSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAdminSettingsArgs:
    def __init__(__self__, *,
                 allowed_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allowed_email_domains is not None:
            pulumi.set(__self__, "allowed_email_domains", allowed_email_domains)

    @property
    @pulumi.getter(name="allowedEmailDomains")
    def allowed_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_email_domains")

    @allowed_email_domains.setter
    def allowed_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_email_domains", value)


if not MYPY:
    class InstanceCustomDomainArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[str]]
        """
        Domain name
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Status of the custom domain.
        """
elif False:
    InstanceCustomDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCustomDomainArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain name
        :param pulumi.Input[str] state: (Output)
               Status of the custom domain.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Status of the custom domain.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodArgsDict(TypedDict):
        end_date: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgsDict']
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        start_date: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgsDict']
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        time: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgsDict']
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
elif False:
    InstanceDenyMaintenancePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodArgs:
    def __init__(__self__, *,
                 end_date: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs'],
                 start_date: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs'],
                 time: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']):
        """
        :param pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs'] end_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs'] start_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs'] time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs']:
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs']):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs']:
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs']):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']:
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']):
        pulumi.set(self, "time", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodEndDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
elif False:
    InstanceDenyMaintenancePeriodEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodEndDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodStartDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
elif False:
    InstanceDenyMaintenancePeriodStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodStartDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
elif False:
    InstanceDenyMaintenancePeriodTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class InstanceEncryptionConfigArgsDict(TypedDict):
        kms_key_name: NotRequired[pulumi.Input[str]]
        """
        Name of the customer managed encryption key (CMEK) in KMS.
        """
        kms_key_name_version: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Full name and version of the CMEK key currently in use to encrypt Looker data.
        """
        kms_key_state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Status of the customer managed encryption key (CMEK) in KMS.
        """
elif False:
    InstanceEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None,
                 kms_key_name_version: Optional[pulumi.Input[str]] = None,
                 kms_key_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: Name of the customer managed encryption key (CMEK) in KMS.
        :param pulumi.Input[str] kms_key_name_version: (Output)
               Full name and version of the CMEK key currently in use to encrypt Looker data.
        :param pulumi.Input[str] kms_key_state: (Output)
               Status of the customer managed encryption key (CMEK) in KMS.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_name_version is not None:
            pulumi.set(__self__, "kms_key_name_version", kms_key_name_version)
        if kms_key_state is not None:
            pulumi.set(__self__, "kms_key_state", kms_key_state)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyNameVersion")
    def kms_key_name_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Full name and version of the CMEK key currently in use to encrypt Looker data.
        """
        return pulumi.get(self, "kms_key_name_version")

    @kms_key_name_version.setter
    def kms_key_name_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name_version", value)

    @property
    @pulumi.getter(name="kmsKeyState")
    def kms_key_state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Status of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_state")

    @kms_key_state.setter
    def kms_key_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_state", value)


if not MYPY:
    class InstanceMaintenanceWindowArgsDict(TypedDict):
        day_of_week: pulumi.Input[str]
        """
        Required. Day of the week for this MaintenanceWindow (in UTC).
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        start_time: pulumi.Input['InstanceMaintenanceWindowStartTimeArgsDict']
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
elif False:
    InstanceMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 start_time: pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']):
        """
        :param pulumi.Input[str] day_of_week: Required. Day of the week for this MaintenanceWindow (in UTC).
               - MONDAY: Monday
               - TUESDAY: Tuesday
               - WEDNESDAY: Wednesday
               - THURSDAY: Thursday
               - FRIDAY: Friday
               - SATURDAY: Saturday
               - SUNDAY: Sunday
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input['InstanceMaintenanceWindowStartTimeArgs'] start_time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        """
        Required. Day of the week for this MaintenanceWindow (in UTC).
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']:
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class InstanceMaintenanceWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
elif False:
    InstanceMaintenanceWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenanceWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class InstanceOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The client ID for the Oauth config.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret for the Oauth config.
        """
elif False:
    InstanceOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The client ID for the Oauth config.
        :param pulumi.Input[str] client_secret: The client secret for the Oauth config.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID for the Oauth config.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret for the Oauth config.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class InstancePscConfigArgsDict(TypedDict):
        allowed_vpcs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of VPCs that are allowed ingress into the Looker instance.
        """
        looker_service_attachment_uri: NotRequired[pulumi.Input[str]]
        """
        (Output)
        URI of the Looker service attachment.
        """
        service_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstancePscConfigServiceAttachmentArgsDict']]]]
        """
        List of egress service attachment configurations.
        Structure is documented below.
        """
elif False:
    InstancePscConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePscConfigArgs:
    def __init__(__self__, *,
                 allowed_vpcs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 looker_service_attachment_uri: Optional[pulumi.Input[str]] = None,
                 service_attachments: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePscConfigServiceAttachmentArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_vpcs: List of VPCs that are allowed ingress into the Looker instance.
        :param pulumi.Input[str] looker_service_attachment_uri: (Output)
               URI of the Looker service attachment.
        :param pulumi.Input[Sequence[pulumi.Input['InstancePscConfigServiceAttachmentArgs']]] service_attachments: List of egress service attachment configurations.
               Structure is documented below.
        """
        if allowed_vpcs is not None:
            pulumi.set(__self__, "allowed_vpcs", allowed_vpcs)
        if looker_service_attachment_uri is not None:
            pulumi.set(__self__, "looker_service_attachment_uri", looker_service_attachment_uri)
        if service_attachments is not None:
            pulumi.set(__self__, "service_attachments", service_attachments)

    @property
    @pulumi.getter(name="allowedVpcs")
    def allowed_vpcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of VPCs that are allowed ingress into the Looker instance.
        """
        return pulumi.get(self, "allowed_vpcs")

    @allowed_vpcs.setter
    def allowed_vpcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_vpcs", value)

    @property
    @pulumi.getter(name="lookerServiceAttachmentUri")
    def looker_service_attachment_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        URI of the Looker service attachment.
        """
        return pulumi.get(self, "looker_service_attachment_uri")

    @looker_service_attachment_uri.setter
    def looker_service_attachment_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "looker_service_attachment_uri", value)

    @property
    @pulumi.getter(name="serviceAttachments")
    def service_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstancePscConfigServiceAttachmentArgs']]]]:
        """
        List of egress service attachment configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "service_attachments")

    @service_attachments.setter
    def service_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePscConfigServiceAttachmentArgs']]]]):
        pulumi.set(self, "service_attachments", value)


if not MYPY:
    class InstancePscConfigServiceAttachmentArgsDict(TypedDict):
        connection_status: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Status of the service attachment connection.
        """
        local_fqdn: NotRequired[pulumi.Input[str]]
        """
        Fully qualified domain name that will be used in the private DNS record created for the service attachment.
        """
        target_service_attachment_uri: NotRequired[pulumi.Input[str]]
        """
        URI of the service attachment to connect to.
        """
elif False:
    InstancePscConfigServiceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePscConfigServiceAttachmentArgs:
    def __init__(__self__, *,
                 connection_status: Optional[pulumi.Input[str]] = None,
                 local_fqdn: Optional[pulumi.Input[str]] = None,
                 target_service_attachment_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_status: (Output)
               Status of the service attachment connection.
        :param pulumi.Input[str] local_fqdn: Fully qualified domain name that will be used in the private DNS record created for the service attachment.
        :param pulumi.Input[str] target_service_attachment_uri: URI of the service attachment to connect to.
        """
        if connection_status is not None:
            pulumi.set(__self__, "connection_status", connection_status)
        if local_fqdn is not None:
            pulumi.set(__self__, "local_fqdn", local_fqdn)
        if target_service_attachment_uri is not None:
            pulumi.set(__self__, "target_service_attachment_uri", target_service_attachment_uri)

    @property
    @pulumi.getter(name="connectionStatus")
    def connection_status(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Status of the service attachment connection.
        """
        return pulumi.get(self, "connection_status")

    @connection_status.setter
    def connection_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_status", value)

    @property
    @pulumi.getter(name="localFqdn")
    def local_fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified domain name that will be used in the private DNS record created for the service attachment.
        """
        return pulumi.get(self, "local_fqdn")

    @local_fqdn.setter
    def local_fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_fqdn", value)

    @property
    @pulumi.getter(name="targetServiceAttachmentUri")
    def target_service_attachment_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the service attachment to connect to.
        """
        return pulumi.get(self, "target_service_attachment_uri")

    @target_service_attachment_uri.setter
    def target_service_attachment_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_service_attachment_uri", value)


if not MYPY:
    class InstanceUserMetadataArgsDict(TypedDict):
        additional_developer_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Developer Users to allocate to the Looker Instance.
        """
        additional_standard_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Standard Users to allocate to the Looker Instance.
        """
        additional_viewer_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Viewer Users to allocate to the Looker Instance.
        """
elif False:
    InstanceUserMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceUserMetadataArgs:
    def __init__(__self__, *,
                 additional_developer_user_count: Optional[pulumi.Input[int]] = None,
                 additional_standard_user_count: Optional[pulumi.Input[int]] = None,
                 additional_viewer_user_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] additional_developer_user_count: Number of additional Developer Users to allocate to the Looker Instance.
        :param pulumi.Input[int] additional_standard_user_count: Number of additional Standard Users to allocate to the Looker Instance.
        :param pulumi.Input[int] additional_viewer_user_count: Number of additional Viewer Users to allocate to the Looker Instance.
        """
        if additional_developer_user_count is not None:
            pulumi.set(__self__, "additional_developer_user_count", additional_developer_user_count)
        if additional_standard_user_count is not None:
            pulumi.set(__self__, "additional_standard_user_count", additional_standard_user_count)
        if additional_viewer_user_count is not None:
            pulumi.set(__self__, "additional_viewer_user_count", additional_viewer_user_count)

    @property
    @pulumi.getter(name="additionalDeveloperUserCount")
    def additional_developer_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Developer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_developer_user_count")

    @additional_developer_user_count.setter
    def additional_developer_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_developer_user_count", value)

    @property
    @pulumi.getter(name="additionalStandardUserCount")
    def additional_standard_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Standard Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_standard_user_count")

    @additional_standard_user_count.setter
    def additional_standard_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_standard_user_count", value)

    @property
    @pulumi.getter(name="additionalViewerUserCount")
    def additional_viewer_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Viewer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_viewer_user_count")

    @additional_viewer_user_count.setter
    def additional_viewer_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_viewer_user_count", value)


