# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceAdminSettingsArgs',
    'InstanceAdminSettingsArgsDict',
    'InstanceCustomDomainArgs',
    'InstanceCustomDomainArgsDict',
    'InstanceDenyMaintenancePeriodArgs',
    'InstanceDenyMaintenancePeriodArgsDict',
    'InstanceDenyMaintenancePeriodEndDateArgs',
    'InstanceDenyMaintenancePeriodEndDateArgsDict',
    'InstanceDenyMaintenancePeriodStartDateArgs',
    'InstanceDenyMaintenancePeriodStartDateArgsDict',
    'InstanceDenyMaintenancePeriodTimeArgs',
    'InstanceDenyMaintenancePeriodTimeArgsDict',
    'InstanceEncryptionConfigArgs',
    'InstanceEncryptionConfigArgsDict',
    'InstanceMaintenanceWindowArgs',
    'InstanceMaintenanceWindowArgsDict',
    'InstanceMaintenanceWindowStartTimeArgs',
    'InstanceMaintenanceWindowStartTimeArgsDict',
    'InstanceOauthConfigArgs',
    'InstanceOauthConfigArgsDict',
    'InstanceUserMetadataArgs',
    'InstanceUserMetadataArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceAdminSettingsArgsDict(TypedDict):
        allowed_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    InstanceAdminSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAdminSettingsArgs:
    def __init__(__self__, *,
                 allowed_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allowed_email_domains is not None:
            pulumi.set(__self__, "allowed_email_domains", allowed_email_domains)

    @property
    @pulumi.getter(name="allowedEmailDomains")
    def allowed_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_email_domains")

    @allowed_email_domains.setter
    def allowed_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_email_domains", value)


if not MYPY:
    class InstanceCustomDomainArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[str]]
        """
        Domain name
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Status of the custom domain.
        """
elif False:
    InstanceCustomDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCustomDomainArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain name
        :param pulumi.Input[str] state: (Output)
               Status of the custom domain.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Status of the custom domain.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodArgsDict(TypedDict):
        end_date: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgsDict']
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        start_date: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgsDict']
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        time: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgsDict']
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
elif False:
    InstanceDenyMaintenancePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodArgs:
    def __init__(__self__, *,
                 end_date: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs'],
                 start_date: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs'],
                 time: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']):
        """
        :param pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs'] end_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs'] start_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs'] time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs']:
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input['InstanceDenyMaintenancePeriodEndDateArgs']):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs']:
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input['InstanceDenyMaintenancePeriodStartDateArgs']):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']:
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input['InstanceDenyMaintenancePeriodTimeArgs']):
        pulumi.set(self, "time", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodEndDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
elif False:
    InstanceDenyMaintenancePeriodEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodEndDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodStartDateArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
elif False:
    InstanceDenyMaintenancePeriodStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodStartDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InstanceDenyMaintenancePeriodTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
elif False:
    InstanceDenyMaintenancePeriodTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDenyMaintenancePeriodTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class InstanceEncryptionConfigArgsDict(TypedDict):
        kms_key_name: NotRequired[pulumi.Input[str]]
        """
        Name of the customer managed encryption key (CMEK) in KMS.
        """
        kms_key_name_version: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Full name and version of the CMEK key currently in use to encrypt Looker data.
        """
        kms_key_state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Status of the customer managed encryption key (CMEK) in KMS.
        """
elif False:
    InstanceEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None,
                 kms_key_name_version: Optional[pulumi.Input[str]] = None,
                 kms_key_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: Name of the customer managed encryption key (CMEK) in KMS.
        :param pulumi.Input[str] kms_key_name_version: (Output)
               Full name and version of the CMEK key currently in use to encrypt Looker data.
        :param pulumi.Input[str] kms_key_state: (Output)
               Status of the customer managed encryption key (CMEK) in KMS.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_name_version is not None:
            pulumi.set(__self__, "kms_key_name_version", kms_key_name_version)
        if kms_key_state is not None:
            pulumi.set(__self__, "kms_key_state", kms_key_state)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyNameVersion")
    def kms_key_name_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Full name and version of the CMEK key currently in use to encrypt Looker data.
        """
        return pulumi.get(self, "kms_key_name_version")

    @kms_key_name_version.setter
    def kms_key_name_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name_version", value)

    @property
    @pulumi.getter(name="kmsKeyState")
    def kms_key_state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Status of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_state")

    @kms_key_state.setter
    def kms_key_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_state", value)


if not MYPY:
    class InstanceMaintenanceWindowArgsDict(TypedDict):
        day_of_week: pulumi.Input[str]
        """
        Required. Day of the week for this MaintenanceWindow (in UTC).
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        start_time: pulumi.Input['InstanceMaintenanceWindowStartTimeArgsDict']
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
elif False:
    InstanceMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 start_time: pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']):
        """
        :param pulumi.Input[str] day_of_week: Required. Day of the week for this MaintenanceWindow (in UTC).
               - MONDAY: Monday
               - TUESDAY: Tuesday
               - WEDNESDAY: Wednesday
               - THURSDAY: Thursday
               - FRIDAY: Friday
               - SATURDAY: Saturday
               - SUNDAY: Sunday
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input['InstanceMaintenanceWindowStartTimeArgs'] start_time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        """
        Required. Day of the week for this MaintenanceWindow (in UTC).
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']:
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['InstanceMaintenanceWindowStartTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class InstanceMaintenanceWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
elif False:
    InstanceMaintenanceWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenanceWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class InstanceOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The client ID for the Oauth config.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret for the Oauth config.
        """
elif False:
    InstanceOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The client ID for the Oauth config.
        :param pulumi.Input[str] client_secret: The client secret for the Oauth config.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID for the Oauth config.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret for the Oauth config.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class InstanceUserMetadataArgsDict(TypedDict):
        additional_developer_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Developer Users to allocate to the Looker Instance.
        """
        additional_standard_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Standard Users to allocate to the Looker Instance.
        """
        additional_viewer_user_count: NotRequired[pulumi.Input[int]]
        """
        Number of additional Viewer Users to allocate to the Looker Instance.
        """
elif False:
    InstanceUserMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceUserMetadataArgs:
    def __init__(__self__, *,
                 additional_developer_user_count: Optional[pulumi.Input[int]] = None,
                 additional_standard_user_count: Optional[pulumi.Input[int]] = None,
                 additional_viewer_user_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] additional_developer_user_count: Number of additional Developer Users to allocate to the Looker Instance.
        :param pulumi.Input[int] additional_standard_user_count: Number of additional Standard Users to allocate to the Looker Instance.
        :param pulumi.Input[int] additional_viewer_user_count: Number of additional Viewer Users to allocate to the Looker Instance.
        """
        if additional_developer_user_count is not None:
            pulumi.set(__self__, "additional_developer_user_count", additional_developer_user_count)
        if additional_standard_user_count is not None:
            pulumi.set(__self__, "additional_standard_user_count", additional_standard_user_count)
        if additional_viewer_user_count is not None:
            pulumi.set(__self__, "additional_viewer_user_count", additional_viewer_user_count)

    @property
    @pulumi.getter(name="additionalDeveloperUserCount")
    def additional_developer_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Developer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_developer_user_count")

    @additional_developer_user_count.setter
    def additional_developer_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_developer_user_count", value)

    @property
    @pulumi.getter(name="additionalStandardUserCount")
    def additional_standard_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Standard Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_standard_user_count")

    @additional_standard_user_count.setter
    def additional_standard_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_standard_user_count", value)

    @property
    @pulumi.getter(name="additionalViewerUserCount")
    def additional_viewer_user_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of additional Viewer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_viewer_user_count")

    @additional_viewer_user_count.setter
    def additional_viewer_user_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_viewer_user_count", value)


