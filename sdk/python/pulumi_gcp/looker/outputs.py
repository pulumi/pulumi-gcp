# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'InstanceAdminSettings',
    'InstanceDenyMaintenancePeriod',
    'InstanceDenyMaintenancePeriodEndDate',
    'InstanceDenyMaintenancePeriodStartDate',
    'InstanceDenyMaintenancePeriodTime',
    'InstanceEncryptionConfig',
    'InstanceMaintenanceWindow',
    'InstanceMaintenanceWindowStartTime',
    'InstanceOauthConfig',
    'InstanceUserMetadata',
]

@pulumi.output_type
class InstanceAdminSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedEmailDomains":
            suggest = "allowed_email_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAdminSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAdminSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAdminSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_email_domains: Optional[Sequence[str]] = None):
        InstanceAdminSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_email_domains=allowed_email_domains,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_email_domains: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allowed_email_domains is not None:
            _setter("allowed_email_domains", allowed_email_domains)

    @property
    @pulumi.getter(name="allowedEmailDomains")
    def allowed_email_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_email_domains")


@pulumi.output_type
class InstanceDenyMaintenancePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDenyMaintenancePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDenyMaintenancePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDenyMaintenancePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: 'outputs.InstanceDenyMaintenancePeriodEndDate',
                 start_date: 'outputs.InstanceDenyMaintenancePeriodStartDate',
                 time: 'outputs.InstanceDenyMaintenancePeriodTime'):
        """
        :param 'InstanceDenyMaintenancePeriodEndDateArgs' end_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param 'InstanceDenyMaintenancePeriodStartDateArgs' start_date: Required. Start date of the deny maintenance period
               Structure is documented below.
        :param 'InstanceDenyMaintenancePeriodTimeArgs' time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        InstanceDenyMaintenancePeriod._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date=end_date,
            start_date=start_date,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date: 'outputs.InstanceDenyMaintenancePeriodEndDate',
             start_date: 'outputs.InstanceDenyMaintenancePeriodStartDate',
             time: 'outputs.InstanceDenyMaintenancePeriodTime',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_date", end_date)
        _setter("start_date", start_date)
        _setter("time", time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> 'outputs.InstanceDenyMaintenancePeriodEndDate':
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> 'outputs.InstanceDenyMaintenancePeriodStartDate':
        """
        Required. Start date of the deny maintenance period
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def time(self) -> 'outputs.InstanceDenyMaintenancePeriodTime':
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class InstanceDenyMaintenancePeriodEndDate(dict):
    def __init__(__self__, *,
                 day: Optional[int] = None,
                 month: Optional[int] = None,
                 year: Optional[int] = None):
        """
        :param int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        InstanceDenyMaintenancePeriodEndDate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day=day,
            month=month,
            year=year,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day: Optional[int] = None,
             month: Optional[int] = None,
             year: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if day is not None:
            _setter("day", day)
        if month is not None:
            _setter("month", month)
        if year is not None:
            _setter("year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def month(self) -> Optional[int]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def year(self) -> Optional[int]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class InstanceDenyMaintenancePeriodStartDate(dict):
    def __init__(__self__, *,
                 day: Optional[int] = None,
                 month: Optional[int] = None,
                 year: Optional[int] = None):
        """
        :param int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
               to specify a year by itself or a year and month where the day isn't significant.
        :param int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a
               month and day.
        :param int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without
               a year.
        """
        InstanceDenyMaintenancePeriodStartDate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day=day,
            month=month,
            year=year,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day: Optional[int] = None,
             month: Optional[int] = None,
             year: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if day is not None:
            _setter("day", day)
        if month is not None:
            _setter("month", month)
        if year is not None:
            _setter("year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
        to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def month(self) -> Optional[int]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a
        month and day.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def year(self) -> Optional[int]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without
        a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class InstanceDenyMaintenancePeriodTime(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None,
                 nanos: Optional[int] = None,
                 seconds: Optional[int] = None):
        """
        :param int hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param int minutes: Minutes of hour of day. Must be from 0 to 59.
        :param int nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param int seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        InstanceDenyMaintenancePeriodTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
            nanos=nanos,
            seconds=seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[int] = None,
             minutes: Optional[int] = None,
             nanos: Optional[int] = None,
             seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hours is not None:
            _setter("hours", hours)
        if minutes is not None:
            _setter("minutes", minutes)
        if nanos is not None:
            _setter("nanos", nanos)
        if seconds is not None:
            _setter("seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[int]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class InstanceEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"
        elif key == "kmsKeyNameVersion":
            suggest = "kms_key_name_version"
        elif key == "kmsKeyState":
            suggest = "kms_key_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: Optional[str] = None,
                 kms_key_name_version: Optional[str] = None,
                 kms_key_state: Optional[str] = None):
        """
        :param str kms_key_name: Name of the customer managed encryption key (CMEK) in KMS.
        :param str kms_key_name_version: (Output)
               Full name and version of the CMEK key currently in use to encrypt Looker data.
        :param str kms_key_state: (Output)
               Status of the customer managed encryption key (CMEK) in KMS.
        """
        InstanceEncryptionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kms_key_name=kms_key_name,
            kms_key_name_version=kms_key_name_version,
            kms_key_state=kms_key_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kms_key_name: Optional[str] = None,
             kms_key_name_version: Optional[str] = None,
             kms_key_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if kms_key_name is not None:
            _setter("kms_key_name", kms_key_name)
        if kms_key_name_version is not None:
            _setter("kms_key_name_version", kms_key_name_version)
        if kms_key_state is not None:
            _setter("kms_key_state", kms_key_state)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        Name of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_name")

    @property
    @pulumi.getter(name="kmsKeyNameVersion")
    def kms_key_name_version(self) -> Optional[str]:
        """
        (Output)
        Full name and version of the CMEK key currently in use to encrypt Looker data.
        """
        return pulumi.get(self, "kms_key_name_version")

    @property
    @pulumi.getter(name="kmsKeyState")
    def kms_key_state(self) -> Optional[str]:
        """
        (Output)
        Status of the customer managed encryption key (CMEK) in KMS.
        """
        return pulumi.get(self, "kms_key_state")


@pulumi.output_type
class InstanceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: str,
                 start_time: 'outputs.InstanceMaintenanceWindowStartTime'):
        """
        :param str day_of_week: Required. Day of the week for this MaintenanceWindow (in UTC).
               - MONDAY: Monday
               - TUESDAY: Tuesday
               - WEDNESDAY: Wednesday
               - THURSDAY: Thursday
               - FRIDAY: Friday
               - SATURDAY: Saturday
               - SUNDAY: Sunday
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param 'InstanceMaintenanceWindowStartTimeArgs' start_time: Required. Start time of the window in UTC time.
               Structure is documented below.
        """
        InstanceMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: str,
             start_time: 'outputs.InstanceMaintenanceWindowStartTime',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_week", day_of_week)
        _setter("start_time", start_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> str:
        """
        Required. Day of the week for this MaintenanceWindow (in UTC).
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> 'outputs.InstanceMaintenanceWindowStartTime':
        """
        Required. Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class InstanceMaintenanceWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None,
                 nanos: Optional[int] = None,
                 seconds: Optional[int] = None):
        """
        :param int hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param int minutes: Minutes of hour of day. Must be from 0 to 59.
        :param int nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param int seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        InstanceMaintenanceWindowStartTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
            nanos=nanos,
            seconds=seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[int] = None,
             minutes: Optional[int] = None,
             nanos: Optional[int] = None,
             seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hours is not None:
            _setter("hours", hours)
        if minutes is not None:
            _setter("minutes", minutes)
        if nanos is not None:
            _setter("nanos", nanos)
        if seconds is not None:
            _setter("seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[int]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class InstanceOauthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceOauthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceOauthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceOauthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str):
        """
        :param str client_id: The client ID for the Oauth config.
        :param str client_secret: The client secret for the Oauth config.
        """
        InstanceOauthConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             client_secret: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_id", client_id)
        _setter("client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID for the Oauth config.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret for the Oauth config.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class InstanceUserMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDeveloperUserCount":
            suggest = "additional_developer_user_count"
        elif key == "additionalStandardUserCount":
            suggest = "additional_standard_user_count"
        elif key == "additionalViewerUserCount":
            suggest = "additional_viewer_user_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceUserMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceUserMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceUserMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_developer_user_count: Optional[int] = None,
                 additional_standard_user_count: Optional[int] = None,
                 additional_viewer_user_count: Optional[int] = None):
        """
        :param int additional_developer_user_count: Number of additional Developer Users to allocate to the Looker Instance.
        :param int additional_standard_user_count: Number of additional Standard Users to allocate to the Looker Instance.
        :param int additional_viewer_user_count: Number of additional Viewer Users to allocate to the Looker Instance.
        """
        InstanceUserMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_developer_user_count=additional_developer_user_count,
            additional_standard_user_count=additional_standard_user_count,
            additional_viewer_user_count=additional_viewer_user_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_developer_user_count: Optional[int] = None,
             additional_standard_user_count: Optional[int] = None,
             additional_viewer_user_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_developer_user_count is not None:
            _setter("additional_developer_user_count", additional_developer_user_count)
        if additional_standard_user_count is not None:
            _setter("additional_standard_user_count", additional_standard_user_count)
        if additional_viewer_user_count is not None:
            _setter("additional_viewer_user_count", additional_viewer_user_count)

    @property
    @pulumi.getter(name="additionalDeveloperUserCount")
    def additional_developer_user_count(self) -> Optional[int]:
        """
        Number of additional Developer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_developer_user_count")

    @property
    @pulumi.getter(name="additionalStandardUserCount")
    def additional_standard_user_count(self) -> Optional[int]:
        """
        Number of additional Standard Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_standard_user_count")

    @property
    @pulumi.getter(name="additionalViewerUserCount")
    def additional_viewer_user_count(self) -> Optional[int]:
        """
        Number of additional Viewer Users to allocate to the Looker Instance.
        """
        return pulumi.get(self, "additional_viewer_user_count")


