# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ReleaseBlueprint',
    'ReleaseInputVariable',
    'ReleaseInputVariableDefault',
    'ReleaseOutputVariable',
    'ReleaseReleaseRequirements',
    'RolloutKindErrorBudget',
    'SaaSLocation',
    'UnitKindDependency',
    'UnitKindInputVariableMapping',
    'UnitKindInputVariableMappingFrom',
    'UnitKindInputVariableMappingTo',
    'UnitKindOutputVariableMapping',
    'UnitKindOutputVariableMappingFrom',
    'UnitKindOutputVariableMappingTo',
]

@pulumi.output_type
class ReleaseBlueprint(dict):
    def __init__(__self__, *,
                 engine: Optional[_builtins.str] = None,
                 package: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str package: URI to a blueprint used by the Unit (required unless unitKind or release is
               set).
        :param _builtins.str version: (Output)
               Version metadata if present on the blueprint.
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if package is not None:
            pulumi.set(__self__, "package", package)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[_builtins.str]:
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        (Output)
        Version metadata if present on the blueprint.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ReleaseInputVariable(dict):
    def __init__(__self__, *,
                 variable: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str variable: Name of the variable from actuation configs.
        :param _builtins.str type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param _builtins.str value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReleaseInputVariableDefault(dict):
    def __init__(__self__, *,
                 variable: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str variable: Name of the variable from actuation configs.
        :param _builtins.str type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param _builtins.str value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReleaseOutputVariable(dict):
    def __init__(__self__, *,
                 variable: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str variable: Name of the variable from actuation configs.
        :param _builtins.str type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param _builtins.str value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReleaseReleaseRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upgradeableFromReleases":
            suggest = "upgradeable_from_releases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseReleaseRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseReleaseRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseReleaseRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upgradeable_from_releases: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] upgradeable_from_releases: A list of releases from which a unit can be upgraded to this one
               (optional). If left empty no constraints will be applied. When provided,
               unit upgrade requests to this release will check and enforce this
               constraint.
        """
        if upgradeable_from_releases is not None:
            pulumi.set(__self__, "upgradeable_from_releases", upgradeable_from_releases)

    @_builtins.property
    @pulumi.getter(name="upgradeableFromReleases")
    def upgradeable_from_releases(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
        return pulumi.get(self, "upgradeable_from_releases")


@pulumi.output_type
class RolloutKindErrorBudget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedCount":
            suggest = "allowed_count"
        elif key == "allowedPercentage":
            suggest = "allowed_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RolloutKindErrorBudget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RolloutKindErrorBudget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RolloutKindErrorBudget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_count: Optional[_builtins.int] = None,
                 allowed_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int allowed_count: The maximum number of failed units allowed in a location without pausing
               the rollout.
        :param _builtins.int allowed_percentage: The maximum percentage of units allowed to fail (0, 100] within a location
               without pausing the rollout.
        """
        if allowed_count is not None:
            pulumi.set(__self__, "allowed_count", allowed_count)
        if allowed_percentage is not None:
            pulumi.set(__self__, "allowed_percentage", allowed_percentage)

    @_builtins.property
    @pulumi.getter(name="allowedCount")
    def allowed_count(self) -> Optional[_builtins.int]:
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        return pulumi.get(self, "allowed_count")

    @_builtins.property
    @pulumi.getter(name="allowedPercentage")
    def allowed_percentage(self) -> Optional[_builtins.int]:
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
        return pulumi.get(self, "allowed_percentage")


@pulumi.output_type
class SaaSLocation(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of location.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class UnitKindDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitKind":
            suggest = "unit_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: _builtins.str,
                 unit_kind: _builtins.str):
        """
        :param _builtins.str alias: An alias for the dependency. Used for input variable mapping.
        :param _builtins.str unit_kind: The unit kind of the dependency.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "unit_kind", unit_kind)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        An alias for the dependency. Used for input variable mapping.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="unitKind")
    def unit_kind(self) -> _builtins.str:
        """
        The unit kind of the dependency.
        """
        return pulumi.get(self, "unit_kind")


@pulumi.output_type
class UnitKindInputVariableMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindInputVariableMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindInputVariableMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindInputVariableMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 variable: _builtins.str,
                 from_: Optional['outputs.UnitKindInputVariableMappingFrom'] = None,
                 to: Optional['outputs.UnitKindInputVariableMappingTo'] = None):
        """
        :param _builtins.str variable: name of the variable
        :param 'UnitKindInputVariableMappingFromArgs' from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param 'UnitKindInputVariableMappingToArgs' to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional['outputs.UnitKindInputVariableMappingFrom']:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional['outputs.UnitKindInputVariableMappingTo']:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class UnitKindInputVariableMappingFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputVariable":
            suggest = "output_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindInputVariableMappingFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindInputVariableMappingFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindInputVariableMappingFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency: _builtins.str,
                 output_variable: _builtins.str):
        """
        :param _builtins.str dependency: Alias of the dependency that the outputVariable will pass its value to
        :param _builtins.str output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> _builtins.str:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> _builtins.str:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")


@pulumi.output_type
class UnitKindInputVariableMappingTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariable":
            suggest = "input_variable"
        elif key == "ignoreForLookup":
            suggest = "ignore_for_lookup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindInputVariableMappingTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindInputVariableMappingTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindInputVariableMappingTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency: _builtins.str,
                 input_variable: _builtins.str,
                 ignore_for_lookup: Optional[_builtins.bool] = None):
        """
        :param _builtins.str dependency: Alias of the dependency that the inputVariable will pass its value to
        :param _builtins.str input_variable: Name of the inputVariable on the dependency
        :param _builtins.bool ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> _builtins.str:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> _builtins.str:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[_builtins.bool]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")


@pulumi.output_type
class UnitKindOutputVariableMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindOutputVariableMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindOutputVariableMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindOutputVariableMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 variable: _builtins.str,
                 from_: Optional['outputs.UnitKindOutputVariableMappingFrom'] = None,
                 to: Optional['outputs.UnitKindOutputVariableMappingTo'] = None):
        """
        :param _builtins.str variable: name of the variable
        :param 'UnitKindOutputVariableMappingFromArgs' from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param 'UnitKindOutputVariableMappingToArgs' to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional['outputs.UnitKindOutputVariableMappingFrom']:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional['outputs.UnitKindOutputVariableMappingTo']:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class UnitKindOutputVariableMappingFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputVariable":
            suggest = "output_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindOutputVariableMappingFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindOutputVariableMappingFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindOutputVariableMappingFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency: _builtins.str,
                 output_variable: _builtins.str):
        """
        :param _builtins.str dependency: Alias of the dependency that the outputVariable will pass its value to
        :param _builtins.str output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> _builtins.str:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> _builtins.str:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")


@pulumi.output_type
class UnitKindOutputVariableMappingTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariable":
            suggest = "input_variable"
        elif key == "ignoreForLookup":
            suggest = "ignore_for_lookup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnitKindOutputVariableMappingTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnitKindOutputVariableMappingTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnitKindOutputVariableMappingTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency: _builtins.str,
                 input_variable: _builtins.str,
                 ignore_for_lookup: Optional[_builtins.bool] = None):
        """
        :param _builtins.str dependency: Alias of the dependency that the inputVariable will pass its value to
        :param _builtins.str input_variable: Name of the inputVariable on the dependency
        :param _builtins.bool ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> _builtins.str:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> _builtins.str:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[_builtins.bool]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")


