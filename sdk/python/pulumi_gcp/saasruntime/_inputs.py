# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ReleaseBlueprintArgs',
    'ReleaseBlueprintArgsDict',
    'ReleaseInputVariableArgs',
    'ReleaseInputVariableArgsDict',
    'ReleaseInputVariableDefaultArgs',
    'ReleaseInputVariableDefaultArgsDict',
    'ReleaseOutputVariableArgs',
    'ReleaseOutputVariableArgsDict',
    'ReleaseReleaseRequirementsArgs',
    'ReleaseReleaseRequirementsArgsDict',
    'RolloutKindErrorBudgetArgs',
    'RolloutKindErrorBudgetArgsDict',
    'SaaSLocationArgs',
    'SaaSLocationArgsDict',
    'UnitConditionArgs',
    'UnitConditionArgsDict',
    'UnitDependencyArgs',
    'UnitDependencyArgsDict',
    'UnitDependentArgs',
    'UnitDependentArgsDict',
    'UnitInputVariableArgs',
    'UnitInputVariableArgsDict',
    'UnitKindDependencyArgs',
    'UnitKindDependencyArgsDict',
    'UnitKindInputVariableMappingArgs',
    'UnitKindInputVariableMappingArgsDict',
    'UnitKindInputVariableMappingFromArgs',
    'UnitKindInputVariableMappingFromArgsDict',
    'UnitKindInputVariableMappingToArgs',
    'UnitKindInputVariableMappingToArgsDict',
    'UnitKindOutputVariableMappingArgs',
    'UnitKindOutputVariableMappingArgsDict',
    'UnitKindOutputVariableMappingFromArgs',
    'UnitKindOutputVariableMappingFromArgsDict',
    'UnitKindOutputVariableMappingToArgs',
    'UnitKindOutputVariableMappingToArgsDict',
    'UnitMaintenanceArgs',
    'UnitMaintenanceArgsDict',
    'UnitOperationConditionArgs',
    'UnitOperationConditionArgsDict',
    'UnitOperationDeprovisionArgs',
    'UnitOperationDeprovisionArgsDict',
    'UnitOperationProvisionArgs',
    'UnitOperationProvisionArgsDict',
    'UnitOperationProvisionInputVariableArgs',
    'UnitOperationProvisionInputVariableArgsDict',
    'UnitOperationUpgradeArgs',
    'UnitOperationUpgradeArgsDict',
    'UnitOperationUpgradeInputVariableArgs',
    'UnitOperationUpgradeInputVariableArgsDict',
    'UnitOutputVariableArgs',
    'UnitOutputVariableArgsDict',
]

class ReleaseBlueprintArgsDict(TypedDict):
    engine: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Type of the engine used to actuate the blueprint. e.g. terraform, helm etc.
    """
    package: NotRequired[pulumi.Input[_builtins.str]]
    """
    URI to a blueprint used by the Unit (required unless unitKind or release is
    set).
    """
    version: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Version metadata if present on the blueprint.
    """

@pulumi.input_type
class ReleaseBlueprintArgs:
    def __init__(__self__, *,
                 engine: Optional[pulumi.Input[_builtins.str]] = None,
                 package: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] engine: (Output)
               Type of the engine used to actuate the blueprint. e.g. terraform, helm etc.
        :param pulumi.Input[_builtins.str] package: URI to a blueprint used by the Unit (required unless unitKind or release is
               set).
        :param pulumi.Input[_builtins.str] version: (Output)
               Version metadata if present on the blueprint.
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if package is not None:
            pulumi.set(__self__, "package", package)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Type of the engine used to actuate the blueprint. e.g. terraform, helm etc.
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Version metadata if present on the blueprint.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


class ReleaseInputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are STRING, INT, BOOL.
    Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class ReleaseInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class ReleaseInputVariableDefaultArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are STRING, INT, BOOL.
    Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class ReleaseInputVariableDefaultArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class ReleaseOutputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are STRING, INT, BOOL.
    Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class ReleaseOutputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class ReleaseReleaseRequirementsArgsDict(TypedDict):
    upgradeable_from_releases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
    """
    A list of releases from which a unit can be upgraded to this one
    (optional). If left empty no constraints will be applied. When provided,
    unit upgrade requests to this release will check and enforce this
    constraint.
    """

@pulumi.input_type
class ReleaseReleaseRequirementsArgs:
    def __init__(__self__, *,
                 upgradeable_from_releases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] upgradeable_from_releases: A list of releases from which a unit can be upgraded to this one
               (optional). If left empty no constraints will be applied. When provided,
               unit upgrade requests to this release will check and enforce this
               constraint.
        """
        if upgradeable_from_releases is not None:
            pulumi.set(__self__, "upgradeable_from_releases", upgradeable_from_releases)

    @_builtins.property
    @pulumi.getter(name="upgradeableFromReleases")
    def upgradeable_from_releases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
        return pulumi.get(self, "upgradeable_from_releases")

    @upgradeable_from_releases.setter
    def upgradeable_from_releases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "upgradeable_from_releases", value)


class RolloutKindErrorBudgetArgsDict(TypedDict):
    allowed_count: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum number of failed units allowed in a location without pausing
    the rollout.
    """
    allowed_percentage: NotRequired[pulumi.Input[_builtins.int]]
    """
    The maximum percentage of units allowed to fail (0, 100] within a location
    without pausing the rollout.
    """

@pulumi.input_type
class RolloutKindErrorBudgetArgs:
    def __init__(__self__, *,
                 allowed_count: Optional[pulumi.Input[_builtins.int]] = None,
                 allowed_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] allowed_count: The maximum number of failed units allowed in a location without pausing
               the rollout.
        :param pulumi.Input[_builtins.int] allowed_percentage: The maximum percentage of units allowed to fail (0, 100] within a location
               without pausing the rollout.
        """
        if allowed_count is not None:
            pulumi.set(__self__, "allowed_count", allowed_count)
        if allowed_percentage is not None:
            pulumi.set(__self__, "allowed_percentage", allowed_percentage)

    @_builtins.property
    @pulumi.getter(name="allowedCount")
    def allowed_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        return pulumi.get(self, "allowed_count")

    @allowed_count.setter
    def allowed_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_count", value)

    @_builtins.property
    @pulumi.getter(name="allowedPercentage")
    def allowed_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
        return pulumi.get(self, "allowed_percentage")

    @allowed_percentage.setter
    def allowed_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_percentage", value)


class SaaSLocationArgsDict(TypedDict):
    name: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of location.
    """

@pulumi.input_type
class SaaSLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


class UnitConditionArgsDict(TypedDict):
    last_transition_time: pulumi.Input[_builtins.str]
    """
    Last time the condition transited from one status to another.
    """
    message: pulumi.Input[_builtins.str]
    """
    Human readable message indicating details about the last transition.
    """
    reason: pulumi.Input[_builtins.str]
    """
    Brief reason for the condition's last transition.
    """
    status: pulumi.Input[_builtins.str]
    """
    Status of the condition.
    Possible values:
    STATUS_UNKNOWN
    STATUS_TRUE
    STATUS_FALSE
    """
    type: pulumi.Input[_builtins.str]
    """
    Name of a supported variable type. Supported types are string, int, bool.
    Possible values:
    STRING
    INT
    BOOL
    """

@pulumi.input_type
class UnitConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[_builtins.str],
                 message: pulumi.Input[_builtins.str],
                 reason: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: Last time the condition transited from one status to another.
        :param pulumi.Input[_builtins.str] message: Human readable message indicating details about the last transition.
        :param pulumi.Input[_builtins.str] reason: Brief reason for the condition's last transition.
        :param pulumi.Input[_builtins.str] status: Status of the condition.
               Possible values:
               STATUS_UNKNOWN
               STATUS_TRUE
               STATUS_FALSE
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[_builtins.str]:
        """
        Last time the condition transited from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        Human readable message indicating details about the last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> pulumi.Input[_builtins.str]:
        """
        Brief reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the condition.
        Possible values:
        STATUS_UNKNOWN
        STATUS_TRUE
        STATUS_FALSE
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


class UnitDependencyArgsDict(TypedDict):
    alias: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Alias for the name of the dependency.
    """
    unit: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    A reference to the Unit object.
    """

@pulumi.input_type
class UnitDependencyArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alias: (Output)
               Alias for the name of the dependency.
        :param pulumi.Input[_builtins.str] unit: (Output)
               A reference to the Unit object.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Alias for the name of the dependency.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A reference to the Unit object.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


class UnitDependentArgsDict(TypedDict):
    alias: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Alias for the name of the dependency.
    """
    unit: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    A reference to the Unit object.
    """

@pulumi.input_type
class UnitDependentArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alias: (Output)
               Alias for the name of the dependency.
        :param pulumi.Input[_builtins.str] unit: (Output)
               A reference to the Unit object.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Alias for the name of the dependency.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A reference to the Unit object.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


class UnitInputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are string, int, bool.
    Possible values:
    STRING
    INT
    BOOL
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class UnitInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class UnitKindDependencyArgsDict(TypedDict):
    alias: pulumi.Input[_builtins.str]
    """
    An alias for the dependency. Used for input variable mapping.
    """
    unit_kind: pulumi.Input[_builtins.str]
    """
    The unit kind of the dependency.
    """

@pulumi.input_type
class UnitKindDependencyArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[_builtins.str],
                 unit_kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias: An alias for the dependency. Used for input variable mapping.
        :param pulumi.Input[_builtins.str] unit_kind: The unit kind of the dependency.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "unit_kind", unit_kind)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> pulumi.Input[_builtins.str]:
        """
        An alias for the dependency. Used for input variable mapping.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter(name="unitKind")
    def unit_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The unit kind of the dependency.
        """
        return pulumi.get(self, "unit_kind")

    @unit_kind.setter
    def unit_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit_kind", value)


class UnitKindInputVariableMappingArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    name of the variable
    """
    from_: NotRequired[pulumi.Input['UnitKindInputVariableMappingFromArgsDict']]
    """
    Output variables whose values will be passed on to dependencies
    Structure is documented below.
    """
    to: NotRequired[pulumi.Input['UnitKindInputVariableMappingToArgsDict']]
    """
    Input variables whose values will be passed on to dependencies
    Structure is documented below.
    """

@pulumi.input_type
class UnitKindInputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindInputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindInputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


class UnitKindInputVariableMappingFromArgsDict(TypedDict):
    dependency: pulumi.Input[_builtins.str]
    """
    Alias of the dependency that the outputVariable will pass its value to
    """
    output_variable: pulumi.Input[_builtins.str]
    """
    Name of the outputVariable on the dependency
    """

@pulumi.input_type
class UnitKindInputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


class UnitKindInputVariableMappingToArgsDict(TypedDict):
    dependency: pulumi.Input[_builtins.str]
    """
    Alias of the dependency that the inputVariable will pass its value to
    """
    input_variable: pulumi.Input[_builtins.str]
    """
    Name of the inputVariable on the dependency
    """
    ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
    """
    Tells SaaS Runtime if this mapping should be used during lookup or not
    """

@pulumi.input_type
class UnitKindInputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


class UnitKindOutputVariableMappingArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    name of the variable
    """
    from_: NotRequired[pulumi.Input['UnitKindOutputVariableMappingFromArgsDict']]
    """
    Output variables whose values will be passed on to dependencies
    Structure is documented below.
    """
    to: NotRequired[pulumi.Input['UnitKindOutputVariableMappingToArgsDict']]
    """
    Input variables whose values will be passed on to dependencies
    Structure is documented below.
    """

@pulumi.input_type
class UnitKindOutputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindOutputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindOutputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


class UnitKindOutputVariableMappingFromArgsDict(TypedDict):
    dependency: pulumi.Input[_builtins.str]
    """
    Alias of the dependency that the outputVariable will pass its value to
    """
    output_variable: pulumi.Input[_builtins.str]
    """
    Name of the outputVariable on the dependency
    """

@pulumi.input_type
class UnitKindOutputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


class UnitKindOutputVariableMappingToArgsDict(TypedDict):
    dependency: pulumi.Input[_builtins.str]
    """
    Alias of the dependency that the inputVariable will pass its value to
    """
    input_variable: pulumi.Input[_builtins.str]
    """
    Name of the inputVariable on the dependency
    """
    ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
    """
    Tells SaaS Runtime if this mapping should be used during lookup or not
    """

@pulumi.input_type
class UnitKindOutputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


class UnitMaintenanceArgsDict(TypedDict):
    pinned_until_time: NotRequired[pulumi.Input[_builtins.str]]
    """
    If present, it fixes the release on the unit until the given time; i.e.
    changes to the release field will be rejected. Rollouts should and will
    also respect this by not requesting an upgrade in the first place.
    """

@pulumi.input_type
class UnitMaintenanceArgs:
    def __init__(__self__, *,
                 pinned_until_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pinned_until_time: If present, it fixes the release on the unit until the given time; i.e.
               changes to the release field will be rejected. Rollouts should and will
               also respect this by not requesting an upgrade in the first place.
        """
        if pinned_until_time is not None:
            pulumi.set(__self__, "pinned_until_time", pinned_until_time)

    @_builtins.property
    @pulumi.getter(name="pinnedUntilTime")
    def pinned_until_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, it fixes the release on the unit until the given time; i.e.
        changes to the release field will be rejected. Rollouts should and will
        also respect this by not requesting an upgrade in the first place.
        """
        return pulumi.get(self, "pinned_until_time")

    @pinned_until_time.setter
    def pinned_until_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pinned_until_time", value)


class UnitOperationConditionArgsDict(TypedDict):
    last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Last time the condition transited from one status to another.
    """
    message: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Human readable message indicating details about the last transition.
    """
    reason: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Brief reason for the condition's last transition.
    """
    status: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Status of the condition.
    Possible values:
    STATUS_UNKNOWN
    STATUS_TRUE
    STATUS_FALSE
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    (Output)
    Type of the condition.
    Possible values:
    TYPE_SCHEDULED
    TYPE_RUNNING
    TYPE_SUCCEEDED
    TYPE_CANCELLED
    """

@pulumi.input_type
class UnitOperationConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: (Output)
               Last time the condition transited from one status to another.
        :param pulumi.Input[_builtins.str] message: (Output)
               Human readable message indicating details about the last transition.
        :param pulumi.Input[_builtins.str] reason: (Output)
               Brief reason for the condition's last transition.
        :param pulumi.Input[_builtins.str] status: (Output)
               Status of the condition.
               Possible values:
               STATUS_UNKNOWN
               STATUS_TRUE
               STATUS_FALSE
        :param pulumi.Input[_builtins.str] type: (Output)
               Type of the condition.
               Possible values:
               TYPE_SCHEDULED
               TYPE_RUNNING
               TYPE_SUCCEEDED
               TYPE_CANCELLED
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Last time the condition transited from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Human readable message indicating details about the last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Brief reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Status of the condition.
        Possible values:
        STATUS_UNKNOWN
        STATUS_TRUE
        STATUS_FALSE
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Type of the condition.
        Possible values:
        TYPE_SCHEDULED
        TYPE_RUNNING
        TYPE_SUCCEEDED
        TYPE_CANCELLED
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


class UnitOperationDeprovisionArgsDict(TypedDict):
    pass

@pulumi.input_type
class UnitOperationDeprovisionArgs:
    def __init__(__self__):
        pass


class UnitOperationProvisionArgsDict(TypedDict):
    input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['UnitOperationProvisionInputVariableArgsDict']]]]
    """
    Set of input variables. Maximum 100. (optional)
    Structure is documented below.
    """
    release: NotRequired[pulumi.Input[_builtins.str]]
    """
    Reference to the Release object to use for the Unit. (optional).
    """

@pulumi.input_type
class UnitOperationProvisionArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationProvisionInputVariableArgs']]]] = None,
                 release: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UnitOperationProvisionInputVariableArgs']]] input_variables: Set of input variables. Maximum 100. (optional)
               Structure is documented below.
        :param pulumi.Input[_builtins.str] release: Reference to the Release object to use for the Unit. (optional).
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if release is not None:
            pulumi.set(__self__, "release", release)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationProvisionInputVariableArgs']]]]:
        """
        Set of input variables. Maximum 100. (optional)
        Structure is documented below.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationProvisionInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def release(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the Release object to use for the Unit. (optional).
        """
        return pulumi.get(self, "release")

    @release.setter
    def release(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release", value)


class UnitOperationProvisionInputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are string, int, bool.
    Possible values:
    STRING
    INT
    BOOL
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class UnitOperationProvisionInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class UnitOperationUpgradeArgsDict(TypedDict):
    input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['UnitOperationUpgradeInputVariableArgsDict']]]]
    """
    Set of input variables. Maximum 100. (optional)
    Structure is documented below.
    """
    release: NotRequired[pulumi.Input[_builtins.str]]
    """
    Reference to the Release object to use for the Unit. (optional).
    """

@pulumi.input_type
class UnitOperationUpgradeArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationUpgradeInputVariableArgs']]]] = None,
                 release: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UnitOperationUpgradeInputVariableArgs']]] input_variables: Set of input variables. Maximum 100. (optional)
               Structure is documented below.
        :param pulumi.Input[_builtins.str] release: Reference to the Release object to use for the Unit. (optional).
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if release is not None:
            pulumi.set(__self__, "release", release)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationUpgradeInputVariableArgs']]]]:
        """
        Set of input variables. Maximum 100. (optional)
        Structure is documented below.
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UnitOperationUpgradeInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def release(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the Release object to use for the Unit. (optional).
        """
        return pulumi.get(self, "release")

    @release.setter
    def release(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "release", value)


class UnitOperationUpgradeInputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are string, int, bool.
    Possible values:
    STRING
    INT
    BOOL
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class UnitOperationUpgradeInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


class UnitOutputVariableArgsDict(TypedDict):
    variable: pulumi.Input[_builtins.str]
    """
    Name of the variable from actuation configs.
    """
    type: NotRequired[pulumi.Input[_builtins.str]]
    """
    Name of a supported variable type. Supported types are string, int, bool.
    Possible values:
    STRING
    INT
    BOOL
    """
    value: NotRequired[pulumi.Input[_builtins.str]]
    """
    String encoded value for the variable.
    """

@pulumi.input_type
class UnitOutputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


