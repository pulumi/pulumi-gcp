# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ReleaseBlueprintArgs',
    'ReleaseBlueprintArgsDict',
    'ReleaseInputVariableArgs',
    'ReleaseInputVariableArgsDict',
    'ReleaseInputVariableDefaultArgs',
    'ReleaseInputVariableDefaultArgsDict',
    'ReleaseOutputVariableArgs',
    'ReleaseOutputVariableArgsDict',
    'ReleaseReleaseRequirementsArgs',
    'ReleaseReleaseRequirementsArgsDict',
    'RolloutKindErrorBudgetArgs',
    'RolloutKindErrorBudgetArgsDict',
    'SaaSLocationArgs',
    'SaaSLocationArgsDict',
    'UnitConditionArgs',
    'UnitConditionArgsDict',
    'UnitDependencyArgs',
    'UnitDependencyArgsDict',
    'UnitDependentArgs',
    'UnitDependentArgsDict',
    'UnitInputVariableArgs',
    'UnitInputVariableArgsDict',
    'UnitKindDependencyArgs',
    'UnitKindDependencyArgsDict',
    'UnitKindInputVariableMappingArgs',
    'UnitKindInputVariableMappingArgsDict',
    'UnitKindInputVariableMappingFromArgs',
    'UnitKindInputVariableMappingFromArgsDict',
    'UnitKindInputVariableMappingToArgs',
    'UnitKindInputVariableMappingToArgsDict',
    'UnitKindOutputVariableMappingArgs',
    'UnitKindOutputVariableMappingArgsDict',
    'UnitKindOutputVariableMappingFromArgs',
    'UnitKindOutputVariableMappingFromArgsDict',
    'UnitKindOutputVariableMappingToArgs',
    'UnitKindOutputVariableMappingToArgsDict',
    'UnitMaintenanceArgs',
    'UnitMaintenanceArgsDict',
    'UnitOutputVariableArgs',
    'UnitOutputVariableArgsDict',
]

MYPY = False

if not MYPY:
    class ReleaseBlueprintArgsDict(TypedDict):
        engine: NotRequired[pulumi.Input[_builtins.str]]
        package: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Version metadata if present on the blueprint.
        """
elif False:
    ReleaseBlueprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBlueprintArgs:
    def __init__(__self__, *,
                 engine: Optional[pulumi.Input[_builtins.str]] = None,
                 package: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] package: URI to a blueprint used by the Unit (required unless unitKind or release is
               set).
        :param pulumi.Input[_builtins.str] version: (Output)
               Version metadata if present on the blueprint.
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if package is not None:
            pulumi.set(__self__, "package", package)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Version metadata if present on the blueprint.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ReleaseInputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseInputVariableDefaultArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseInputVariableDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseInputVariableDefaultArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseOutputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseOutputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseOutputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseReleaseRequirementsArgsDict(TypedDict):
        upgradeable_from_releases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
elif False:
    ReleaseReleaseRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseReleaseRequirementsArgs:
    def __init__(__self__, *,
                 upgradeable_from_releases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] upgradeable_from_releases: A list of releases from which a unit can be upgraded to this one
               (optional). If left empty no constraints will be applied. When provided,
               unit upgrade requests to this release will check and enforce this
               constraint.
        """
        if upgradeable_from_releases is not None:
            pulumi.set(__self__, "upgradeable_from_releases", upgradeable_from_releases)

    @_builtins.property
    @pulumi.getter(name="upgradeableFromReleases")
    def upgradeable_from_releases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
        return pulumi.get(self, "upgradeable_from_releases")

    @upgradeable_from_releases.setter
    def upgradeable_from_releases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "upgradeable_from_releases", value)


if not MYPY:
    class RolloutKindErrorBudgetArgsDict(TypedDict):
        allowed_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        allowed_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
elif False:
    RolloutKindErrorBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolloutKindErrorBudgetArgs:
    def __init__(__self__, *,
                 allowed_count: Optional[pulumi.Input[_builtins.int]] = None,
                 allowed_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] allowed_count: The maximum number of failed units allowed in a location without pausing
               the rollout.
        :param pulumi.Input[_builtins.int] allowed_percentage: The maximum percentage of units allowed to fail (0, 100] within a location
               without pausing the rollout.
        """
        if allowed_count is not None:
            pulumi.set(__self__, "allowed_count", allowed_count)
        if allowed_percentage is not None:
            pulumi.set(__self__, "allowed_percentage", allowed_percentage)

    @_builtins.property
    @pulumi.getter(name="allowedCount")
    def allowed_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        return pulumi.get(self, "allowed_count")

    @allowed_count.setter
    def allowed_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_count", value)

    @_builtins.property
    @pulumi.getter(name="allowedPercentage")
    def allowed_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
        return pulumi.get(self, "allowed_percentage")

    @allowed_percentage.setter
    def allowed_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_percentage", value)


if not MYPY:
    class SaaSLocationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of location.
        """
elif False:
    SaaSLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SaaSLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UnitConditionArgsDict(TypedDict):
        last_transition_time: pulumi.Input[_builtins.str]
        """
        Last time the condition transited from one status to another.
        """
        message: pulumi.Input[_builtins.str]
        """
        Human readable message indicating details about the last transition.
        """
        reason: pulumi.Input[_builtins.str]
        """
        Brief reason for the condition's last transition.
        """
        status: pulumi.Input[_builtins.str]
        """
        Status of the condition.
        Possible values:
        STATUS_UNKNOWN
        STATUS_TRUE
        STATUS_FALSE
        """
        type: pulumi.Input[_builtins.str]
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
elif False:
    UnitConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[_builtins.str],
                 message: pulumi.Input[_builtins.str],
                 reason: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: Last time the condition transited from one status to another.
        :param pulumi.Input[_builtins.str] message: Human readable message indicating details about the last transition.
        :param pulumi.Input[_builtins.str] reason: Brief reason for the condition's last transition.
        :param pulumi.Input[_builtins.str] status: Status of the condition.
               Possible values:
               STATUS_UNKNOWN
               STATUS_TRUE
               STATUS_FALSE
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[_builtins.str]:
        """
        Last time the condition transited from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        Human readable message indicating details about the last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> pulumi.Input[_builtins.str]:
        """
        Brief reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the condition.
        Possible values:
        STATUS_UNKNOWN
        STATUS_TRUE
        STATUS_FALSE
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UnitDependencyArgsDict(TypedDict):
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Alias for the name of the dependency.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A reference to the Unit object.
        """
elif False:
    UnitDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitDependencyArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alias: (Output)
               Alias for the name of the dependency.
        :param pulumi.Input[_builtins.str] unit: (Output)
               A reference to the Unit object.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Alias for the name of the dependency.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A reference to the Unit object.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class UnitDependentArgsDict(TypedDict):
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Alias for the name of the dependency.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A reference to the Unit object.
        """
elif False:
    UnitDependentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitDependentArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] alias: (Output)
               Alias for the name of the dependency.
        :param pulumi.Input[_builtins.str] unit: (Output)
               A reference to the Unit object.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Alias for the name of the dependency.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A reference to the Unit object.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class UnitInputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    UnitInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UnitKindDependencyArgsDict(TypedDict):
        alias: pulumi.Input[_builtins.str]
        """
        An alias for the dependency. Used for input variable mapping.
        """
        unit_kind: pulumi.Input[_builtins.str]
        """
        The unit kind of the dependency.
        """
elif False:
    UnitKindDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindDependencyArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[_builtins.str],
                 unit_kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias: An alias for the dependency. Used for input variable mapping.
        :param pulumi.Input[_builtins.str] unit_kind: The unit kind of the dependency.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "unit_kind", unit_kind)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> pulumi.Input[_builtins.str]:
        """
        An alias for the dependency. Used for input variable mapping.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter(name="unitKind")
    def unit_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The unit kind of the dependency.
        """
        return pulumi.get(self, "unit_kind")

    @unit_kind.setter
    def unit_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit_kind", value)


if not MYPY:
    class UnitKindInputVariableMappingArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        name of the variable
        """
        from_: NotRequired[pulumi.Input['UnitKindInputVariableMappingFromArgsDict']]
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        to: NotRequired[pulumi.Input['UnitKindInputVariableMappingToArgsDict']]
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
elif False:
    UnitKindInputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindInputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindInputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class UnitKindInputVariableMappingFromArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        output_variable: pulumi.Input[_builtins.str]
        """
        Name of the outputVariable on the dependency
        """
elif False:
    UnitKindInputVariableMappingFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


if not MYPY:
    class UnitKindInputVariableMappingToArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        input_variable: pulumi.Input[_builtins.str]
        """
        Name of the inputVariable on the dependency
        """
        ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
elif False:
    UnitKindInputVariableMappingToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


if not MYPY:
    class UnitKindOutputVariableMappingArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        name of the variable
        """
        from_: NotRequired[pulumi.Input['UnitKindOutputVariableMappingFromArgsDict']]
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        to: NotRequired[pulumi.Input['UnitKindOutputVariableMappingToArgsDict']]
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
elif False:
    UnitKindOutputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindOutputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindOutputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class UnitKindOutputVariableMappingFromArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        output_variable: pulumi.Input[_builtins.str]
        """
        Name of the outputVariable on the dependency
        """
elif False:
    UnitKindOutputVariableMappingFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


if not MYPY:
    class UnitKindOutputVariableMappingToArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        input_variable: pulumi.Input[_builtins.str]
        """
        Name of the inputVariable on the dependency
        """
        ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
elif False:
    UnitKindOutputVariableMappingToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


if not MYPY:
    class UnitMaintenanceArgsDict(TypedDict):
        pinned_until_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        If present, it fixes the release on the unit until the given time; i.e.
        changes to the release field will be rejected. Rollouts should and will
        also respect this by not requesting an upgrade in the first place.
        """
elif False:
    UnitMaintenanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitMaintenanceArgs:
    def __init__(__self__, *,
                 pinned_until_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pinned_until_time: If present, it fixes the release on the unit until the given time; i.e.
               changes to the release field will be rejected. Rollouts should and will
               also respect this by not requesting an upgrade in the first place.
        """
        if pinned_until_time is not None:
            pulumi.set(__self__, "pinned_until_time", pinned_until_time)

    @_builtins.property
    @pulumi.getter(name="pinnedUntilTime")
    def pinned_until_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, it fixes the release on the unit until the given time; i.e.
        changes to the release field will be rejected. Rollouts should and will
        also respect this by not requesting an upgrade in the first place.
        """
        return pulumi.get(self, "pinned_until_time")

    @pinned_until_time.setter
    def pinned_until_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pinned_until_time", value)


if not MYPY:
    class UnitOutputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    UnitOutputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitOutputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are string, int, bool.
               Possible values:
               STRING
               INT
               BOOL
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are string, int, bool.
        Possible values:
        STRING
        INT
        BOOL
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


