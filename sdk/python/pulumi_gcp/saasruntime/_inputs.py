# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ReleaseBlueprintArgs',
    'ReleaseBlueprintArgsDict',
    'ReleaseInputVariableArgs',
    'ReleaseInputVariableArgsDict',
    'ReleaseInputVariableDefaultArgs',
    'ReleaseInputVariableDefaultArgsDict',
    'ReleaseOutputVariableArgs',
    'ReleaseOutputVariableArgsDict',
    'ReleaseReleaseRequirementsArgs',
    'ReleaseReleaseRequirementsArgsDict',
    'RolloutKindErrorBudgetArgs',
    'RolloutKindErrorBudgetArgsDict',
    'SaaSLocationArgs',
    'SaaSLocationArgsDict',
    'UnitKindDependencyArgs',
    'UnitKindDependencyArgsDict',
    'UnitKindInputVariableMappingArgs',
    'UnitKindInputVariableMappingArgsDict',
    'UnitKindInputVariableMappingFromArgs',
    'UnitKindInputVariableMappingFromArgsDict',
    'UnitKindInputVariableMappingToArgs',
    'UnitKindInputVariableMappingToArgsDict',
    'UnitKindOutputVariableMappingArgs',
    'UnitKindOutputVariableMappingArgsDict',
    'UnitKindOutputVariableMappingFromArgs',
    'UnitKindOutputVariableMappingFromArgsDict',
    'UnitKindOutputVariableMappingToArgs',
    'UnitKindOutputVariableMappingToArgsDict',
]

MYPY = False

if not MYPY:
    class ReleaseBlueprintArgsDict(TypedDict):
        engine: NotRequired[pulumi.Input[_builtins.str]]
        package: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Version metadata if present on the blueprint.
        """
elif False:
    ReleaseBlueprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBlueprintArgs:
    def __init__(__self__, *,
                 engine: Optional[pulumi.Input[_builtins.str]] = None,
                 package: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] package: URI to a blueprint used by the Unit (required unless unitKind or release is
               set).
        :param pulumi.Input[_builtins.str] version: (Output)
               Version metadata if present on the blueprint.
        """
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if package is not None:
            pulumi.set(__self__, "package", package)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI to a blueprint used by the Unit (required unless unitKind or release is
        set).
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Version metadata if present on the blueprint.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ReleaseInputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseInputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseInputVariableDefaultArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseInputVariableDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseInputVariableDefaultArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseOutputVariableArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        Name of the variable from actuation configs.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        String encoded value for the variable.
        """
elif False:
    ReleaseOutputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseOutputVariableArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] variable: Name of the variable from actuation configs.
        :param pulumi.Input[_builtins.str] type: Name of a supported variable type. Supported types are STRING, INT, BOOL.
               Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        :param pulumi.Input[_builtins.str] value: String encoded value for the variable.
        """
        pulumi.set(__self__, "variable", variable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the variable from actuation configs.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a supported variable type. Supported types are STRING, INT, BOOL.
        Possible values are: `TYPE_UNSPECIFIED`, `STRING`, `INT`, `BOOL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String encoded value for the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReleaseReleaseRequirementsArgsDict(TypedDict):
        upgradeable_from_releases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
elif False:
    ReleaseReleaseRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseReleaseRequirementsArgs:
    def __init__(__self__, *,
                 upgradeable_from_releases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] upgradeable_from_releases: A list of releases from which a unit can be upgraded to this one
               (optional). If left empty no constraints will be applied. When provided,
               unit upgrade requests to this release will check and enforce this
               constraint.
        """
        if upgradeable_from_releases is not None:
            pulumi.set(__self__, "upgradeable_from_releases", upgradeable_from_releases)

    @_builtins.property
    @pulumi.getter(name="upgradeableFromReleases")
    def upgradeable_from_releases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of releases from which a unit can be upgraded to this one
        (optional). If left empty no constraints will be applied. When provided,
        unit upgrade requests to this release will check and enforce this
        constraint.
        """
        return pulumi.get(self, "upgradeable_from_releases")

    @upgradeable_from_releases.setter
    def upgradeable_from_releases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "upgradeable_from_releases", value)


if not MYPY:
    class RolloutKindErrorBudgetArgsDict(TypedDict):
        allowed_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        allowed_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
elif False:
    RolloutKindErrorBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolloutKindErrorBudgetArgs:
    def __init__(__self__, *,
                 allowed_count: Optional[pulumi.Input[_builtins.int]] = None,
                 allowed_percentage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] allowed_count: The maximum number of failed units allowed in a location without pausing
               the rollout.
        :param pulumi.Input[_builtins.int] allowed_percentage: The maximum percentage of units allowed to fail (0, 100] within a location
               without pausing the rollout.
        """
        if allowed_count is not None:
            pulumi.set(__self__, "allowed_count", allowed_count)
        if allowed_percentage is not None:
            pulumi.set(__self__, "allowed_percentage", allowed_percentage)

    @_builtins.property
    @pulumi.getter(name="allowedCount")
    def allowed_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of failed units allowed in a location without pausing
        the rollout.
        """
        return pulumi.get(self, "allowed_count")

    @allowed_count.setter
    def allowed_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_count", value)

    @_builtins.property
    @pulumi.getter(name="allowedPercentage")
    def allowed_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum percentage of units allowed to fail (0, 100] within a location
        without pausing the rollout.
        """
        return pulumi.get(self, "allowed_percentage")

    @allowed_percentage.setter
    def allowed_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "allowed_percentage", value)


if not MYPY:
    class SaaSLocationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of location.
        """
elif False:
    SaaSLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SaaSLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UnitKindDependencyArgsDict(TypedDict):
        alias: pulumi.Input[_builtins.str]
        """
        An alias for the dependency. Used for input variable mapping.
        """
        unit_kind: pulumi.Input[_builtins.str]
        """
        The unit kind of the dependency.
        """
elif False:
    UnitKindDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindDependencyArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[_builtins.str],
                 unit_kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias: An alias for the dependency. Used for input variable mapping.
        :param pulumi.Input[_builtins.str] unit_kind: The unit kind of the dependency.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "unit_kind", unit_kind)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> pulumi.Input[_builtins.str]:
        """
        An alias for the dependency. Used for input variable mapping.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter(name="unitKind")
    def unit_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The unit kind of the dependency.
        """
        return pulumi.get(self, "unit_kind")

    @unit_kind.setter
    def unit_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit_kind", value)


if not MYPY:
    class UnitKindInputVariableMappingArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        name of the variable
        """
        from_: NotRequired[pulumi.Input['UnitKindInputVariableMappingFromArgsDict']]
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        to: NotRequired[pulumi.Input['UnitKindInputVariableMappingToArgsDict']]
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
elif False:
    UnitKindInputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindInputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindInputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindInputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class UnitKindInputVariableMappingFromArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        output_variable: pulumi.Input[_builtins.str]
        """
        Name of the outputVariable on the dependency
        """
elif False:
    UnitKindInputVariableMappingFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


if not MYPY:
    class UnitKindInputVariableMappingToArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        input_variable: pulumi.Input[_builtins.str]
        """
        Name of the inputVariable on the dependency
        """
        ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
elif False:
    UnitKindInputVariableMappingToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindInputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


if not MYPY:
    class UnitKindOutputVariableMappingArgsDict(TypedDict):
        variable: pulumi.Input[_builtins.str]
        """
        name of the variable
        """
        from_: NotRequired[pulumi.Input['UnitKindOutputVariableMappingFromArgsDict']]
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        to: NotRequired[pulumi.Input['UnitKindOutputVariableMappingToArgsDict']]
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
elif False:
    UnitKindOutputVariableMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingArgs:
    def __init__(__self__, *,
                 variable: pulumi.Input[_builtins.str],
                 from_: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']] = None,
                 to: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] variable: name of the variable
        :param pulumi.Input['UnitKindOutputVariableMappingFromArgs'] from_: Output variables whose values will be passed on to dependencies
               Structure is documented below.
        :param pulumi.Input['UnitKindOutputVariableMappingToArgs'] to: Input variables whose values will be passed on to dependencies
               Structure is documented below.
        """
        pulumi.set(__self__, "variable", variable)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter
    def variable(self) -> pulumi.Input[_builtins.str]:
        """
        name of the variable
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variable", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]:
        """
        Output variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]:
        """
        Input variables whose values will be passed on to dependencies
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['UnitKindOutputVariableMappingToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class UnitKindOutputVariableMappingFromArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        output_variable: pulumi.Input[_builtins.str]
        """
        Name of the outputVariable on the dependency
        """
elif False:
    UnitKindOutputVariableMappingFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingFromArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 output_variable: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the outputVariable will pass its value to
        :param pulumi.Input[_builtins.str] output_variable: Name of the outputVariable on the dependency
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "output_variable", output_variable)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the outputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="outputVariable")
    def output_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the outputVariable on the dependency
        """
        return pulumi.get(self, "output_variable")

    @output_variable.setter
    def output_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_variable", value)


if not MYPY:
    class UnitKindOutputVariableMappingToArgsDict(TypedDict):
        dependency: pulumi.Input[_builtins.str]
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        input_variable: pulumi.Input[_builtins.str]
        """
        Name of the inputVariable on the dependency
        """
        ignore_for_lookup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
elif False:
    UnitKindOutputVariableMappingToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnitKindOutputVariableMappingToArgs:
    def __init__(__self__, *,
                 dependency: pulumi.Input[_builtins.str],
                 input_variable: pulumi.Input[_builtins.str],
                 ignore_for_lookup: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dependency: Alias of the dependency that the inputVariable will pass its value to
        :param pulumi.Input[_builtins.str] input_variable: Name of the inputVariable on the dependency
        :param pulumi.Input[_builtins.bool] ignore_for_lookup: Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        pulumi.set(__self__, "dependency", dependency)
        pulumi.set(__self__, "input_variable", input_variable)
        if ignore_for_lookup is not None:
            pulumi.set(__self__, "ignore_for_lookup", ignore_for_lookup)

    @_builtins.property
    @pulumi.getter
    def dependency(self) -> pulumi.Input[_builtins.str]:
        """
        Alias of the dependency that the inputVariable will pass its value to
        """
        return pulumi.get(self, "dependency")

    @dependency.setter
    def dependency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dependency", value)

    @_builtins.property
    @pulumi.getter(name="inputVariable")
    def input_variable(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the inputVariable on the dependency
        """
        return pulumi.get(self, "input_variable")

    @input_variable.setter
    def input_variable(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_variable", value)

    @_builtins.property
    @pulumi.getter(name="ignoreForLookup")
    def ignore_for_lookup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Tells SaaS Runtime if this mapping should be used during lookup or not
        """
        return pulumi.get(self, "ignore_for_lookup")

    @ignore_for_lookup.setter
    def ignore_for_lookup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_for_lookup", value)


