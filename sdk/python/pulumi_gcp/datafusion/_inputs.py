# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceAcceleratorArgs',
    'InstanceAcceleratorArgsDict',
    'InstanceCryptoKeyConfigArgs',
    'InstanceCryptoKeyConfigArgsDict',
    'InstanceEventPublishConfigArgs',
    'InstanceEventPublishConfigArgsDict',
    'InstanceNetworkConfigArgs',
    'InstanceNetworkConfigArgsDict',
    'InstanceNetworkConfigPrivateServiceConnectConfigArgs',
    'InstanceNetworkConfigPrivateServiceConnectConfigArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceAcceleratorArgsDict(TypedDict):
        accelerator_type: pulumi.Input[str]
        """
        The type of an accelator for a CDF instance.
        Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
        """
        state: pulumi.Input[str]
        """
        The type of an accelator for a CDF instance.
        Possible values are: `ENABLED`, `DISABLED`.
        """
elif False:
    InstanceAcceleratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAcceleratorArgs:
    def __init__(__self__, *,
                 accelerator_type: pulumi.Input[str],
                 state: pulumi.Input[str]):
        """
        :param pulumi.Input[str] accelerator_type: The type of an accelator for a CDF instance.
               Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
        :param pulumi.Input[str] state: The type of an accelator for a CDF instance.
               Possible values are: `ENABLED`, `DISABLED`.
        """
        pulumi.set(__self__, "accelerator_type", accelerator_type)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> pulumi.Input[str]:
        """
        The type of an accelator for a CDF instance.
        Possible values are: `CDC`, `HEALTHCARE`, `CCAI_INSIGHTS`.
        """
        return pulumi.get(self, "accelerator_type")

    @accelerator_type.setter
    def accelerator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "accelerator_type", value)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        """
        The type of an accelator for a CDF instance.
        Possible values are: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InstanceCryptoKeyConfigArgsDict(TypedDict):
        key_reference: pulumi.Input[str]
        """
        The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
        """
elif False:
    InstanceCryptoKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCryptoKeyConfigArgs:
    def __init__(__self__, *,
                 key_reference: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_reference: The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
        """
        pulumi.set(__self__, "key_reference", key_reference)

    @property
    @pulumi.getter(name="keyReference")
    def key_reference(self) -> pulumi.Input[str]:
        """
        The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects/*/locations/*/keyRings/*/cryptoKeys/*.
        """
        return pulumi.get(self, "key_reference")

    @key_reference.setter
    def key_reference(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_reference", value)


if not MYPY:
    class InstanceEventPublishConfigArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Option to enable Event Publishing.
        """
        topic: pulumi.Input[str]
        """
        The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
        """
elif False:
    InstanceEventPublishConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEventPublishConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 topic: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Option to enable Event Publishing.
        :param pulumi.Input[str] topic: The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Option to enable Event Publishing.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class InstanceNetworkConfigArgsDict(TypedDict):
        connection_type: NotRequired[pulumi.Input[str]]
        """
        Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
        the corresponding tenant project from a predefined list of available connection modes.
        If this field is unspecified for a private instance, VPC peering is used.
        Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
        """
        ip_allocation: NotRequired[pulumi.Input[str]]
        """
        The IP range in CIDR notation to use for the managed Data Fusion instance
        nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
        """
        network: NotRequired[pulumi.Input[str]]
        """
        Name of the network in the project with which the tenant project
        will be peered for executing pipelines. In case of shared VPC where the network resides in another host
        project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
        """
        private_service_connect_config: NotRequired[pulumi.Input['InstanceNetworkConfigPrivateServiceConnectConfigArgsDict']]
        """
        Optional. Configuration for Private Service Connect.
        This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
        Structure is documented below.
        """
elif False:
    InstanceNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkConfigArgs:
    def __init__(__self__, *,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 ip_allocation: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 private_service_connect_config: Optional[pulumi.Input['InstanceNetworkConfigPrivateServiceConnectConfigArgs']] = None):
        """
        :param pulumi.Input[str] connection_type: Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
               the corresponding tenant project from a predefined list of available connection modes.
               If this field is unspecified for a private instance, VPC peering is used.
               Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
        :param pulumi.Input[str] ip_allocation: The IP range in CIDR notation to use for the managed Data Fusion instance
               nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
        :param pulumi.Input[str] network: Name of the network in the project with which the tenant project
               will be peered for executing pipelines. In case of shared VPC where the network resides in another host
               project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
        :param pulumi.Input['InstanceNetworkConfigPrivateServiceConnectConfigArgs'] private_service_connect_config: Optional. Configuration for Private Service Connect.
               This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
               Structure is documented below.
        """
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if ip_allocation is not None:
            pulumi.set(__self__, "ip_allocation", ip_allocation)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if private_service_connect_config is not None:
            pulumi.set(__self__, "private_service_connect_config", private_service_connect_config)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Type of connection for establishing private IP connectivity between the Data Fusion customer project VPC and
        the corresponding tenant project from a predefined list of available connection modes.
        If this field is unspecified for a private instance, VPC peering is used.
        Possible values are: `VPC_PEERING`, `PRIVATE_SERVICE_CONNECT_INTERFACES`.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="ipAllocation")
    def ip_allocation(self) -> Optional[pulumi.Input[str]]:
        """
        The IP range in CIDR notation to use for the managed Data Fusion instance
        nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
        """
        return pulumi.get(self, "ip_allocation")

    @ip_allocation.setter
    def ip_allocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_allocation", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the network in the project with which the tenant project
        will be peered for executing pipelines. In case of shared VPC where the network resides in another host
        project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="privateServiceConnectConfig")
    def private_service_connect_config(self) -> Optional[pulumi.Input['InstanceNetworkConfigPrivateServiceConnectConfigArgs']]:
        """
        Optional. Configuration for Private Service Connect.
        This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
        Structure is documented below.
        """
        return pulumi.get(self, "private_service_connect_config")

    @private_service_connect_config.setter
    def private_service_connect_config(self, value: Optional[pulumi.Input['InstanceNetworkConfigPrivateServiceConnectConfigArgs']]):
        pulumi.set(self, "private_service_connect_config", value)


if not MYPY:
    class InstanceNetworkConfigPrivateServiceConnectConfigArgsDict(TypedDict):
        effective_unreachable_cidr_block: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
        The size of this block is /25. The format of this field is governed by RFC 4632.
        """
        network_attachment: NotRequired[pulumi.Input[str]]
        """
        Optional. The reference to the network attachment used to establish private connectivity.
        It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
        This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
        """
        unreachable_cidr_block: NotRequired[pulumi.Input[str]]
        """
        Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
        The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
        This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
        If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
        """
elif False:
    InstanceNetworkConfigPrivateServiceConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkConfigPrivateServiceConnectConfigArgs:
    def __init__(__self__, *,
                 effective_unreachable_cidr_block: Optional[pulumi.Input[str]] = None,
                 network_attachment: Optional[pulumi.Input[str]] = None,
                 unreachable_cidr_block: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective_unreachable_cidr_block: (Output)
               Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
               The size of this block is /25. The format of this field is governed by RFC 4632.
        :param pulumi.Input[str] network_attachment: Optional. The reference to the network attachment used to establish private connectivity.
               It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
               This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
        :param pulumi.Input[str] unreachable_cidr_block: Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
               The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
               This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
               If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
        """
        if effective_unreachable_cidr_block is not None:
            pulumi.set(__self__, "effective_unreachable_cidr_block", effective_unreachable_cidr_block)
        if network_attachment is not None:
            pulumi.set(__self__, "network_attachment", network_attachment)
        if unreachable_cidr_block is not None:
            pulumi.set(__self__, "unreachable_cidr_block", unreachable_cidr_block)

    @property
    @pulumi.getter(name="effectiveUnreachableCidrBlock")
    def effective_unreachable_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
        The size of this block is /25. The format of this field is governed by RFC 4632.
        """
        return pulumi.get(self, "effective_unreachable_cidr_block")

    @effective_unreachable_cidr_block.setter
    def effective_unreachable_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_unreachable_cidr_block", value)

    @property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The reference to the network attachment used to establish private connectivity.
        It will be of the form projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
        This is required only when using connection type PRIVATE_SERVICE_CONNECT_INTERFACES.
        """
        return pulumi.get(self, "network_attachment")

    @network_attachment.setter
    def network_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_attachment", value)

    @property
    @pulumi.getter(name="unreachableCidrBlock")
    def unreachable_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Input only. The CIDR block to which the CDF instance can't route traffic to in the consumer project VPC.
        The size of this block should be at least /25. This range should not overlap with the primary address range of any subnetwork used by the network attachment.
        This range can be used for other purposes in the consumer VPC as long as there is no requirement for CDF to reach destinations using these addresses.
        If this value is not provided, the server chooses a non RFC 1918 address range. The format of this field is governed by RFC 4632.
        """
        return pulumi.get(self, "unreachable_cidr_block")

    @unreachable_cidr_block.setter
    def unreachable_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unreachable_cidr_block", value)


