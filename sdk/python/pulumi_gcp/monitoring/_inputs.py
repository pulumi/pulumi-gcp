# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlertPolicyAlertStrategyArgs',
    'AlertPolicyAlertStrategyArgsDict',
    'AlertPolicyAlertStrategyNotificationChannelStrategyArgs',
    'AlertPolicyAlertStrategyNotificationChannelStrategyArgsDict',
    'AlertPolicyAlertStrategyNotificationRateLimitArgs',
    'AlertPolicyAlertStrategyNotificationRateLimitArgsDict',
    'AlertPolicyConditionArgs',
    'AlertPolicyConditionArgsDict',
    'AlertPolicyConditionConditionAbsentArgs',
    'AlertPolicyConditionConditionAbsentArgsDict',
    'AlertPolicyConditionConditionAbsentAggregationArgs',
    'AlertPolicyConditionConditionAbsentAggregationArgsDict',
    'AlertPolicyConditionConditionAbsentTriggerArgs',
    'AlertPolicyConditionConditionAbsentTriggerArgsDict',
    'AlertPolicyConditionConditionMatchedLogArgs',
    'AlertPolicyConditionConditionMatchedLogArgsDict',
    'AlertPolicyConditionConditionMonitoringQueryLanguageArgs',
    'AlertPolicyConditionConditionMonitoringQueryLanguageArgsDict',
    'AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs',
    'AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgsDict',
    'AlertPolicyConditionConditionPrometheusQueryLanguageArgs',
    'AlertPolicyConditionConditionPrometheusQueryLanguageArgsDict',
    'AlertPolicyConditionConditionSqlArgs',
    'AlertPolicyConditionConditionSqlArgsDict',
    'AlertPolicyConditionConditionSqlBooleanTestArgs',
    'AlertPolicyConditionConditionSqlBooleanTestArgsDict',
    'AlertPolicyConditionConditionSqlDailyArgs',
    'AlertPolicyConditionConditionSqlDailyArgsDict',
    'AlertPolicyConditionConditionSqlDailyExecutionTimeArgs',
    'AlertPolicyConditionConditionSqlDailyExecutionTimeArgsDict',
    'AlertPolicyConditionConditionSqlHourlyArgs',
    'AlertPolicyConditionConditionSqlHourlyArgsDict',
    'AlertPolicyConditionConditionSqlMinutesArgs',
    'AlertPolicyConditionConditionSqlMinutesArgsDict',
    'AlertPolicyConditionConditionSqlRowCountTestArgs',
    'AlertPolicyConditionConditionSqlRowCountTestArgsDict',
    'AlertPolicyConditionConditionThresholdArgs',
    'AlertPolicyConditionConditionThresholdArgsDict',
    'AlertPolicyConditionConditionThresholdAggregationArgs',
    'AlertPolicyConditionConditionThresholdAggregationArgsDict',
    'AlertPolicyConditionConditionThresholdDenominatorAggregationArgs',
    'AlertPolicyConditionConditionThresholdDenominatorAggregationArgsDict',
    'AlertPolicyConditionConditionThresholdForecastOptionsArgs',
    'AlertPolicyConditionConditionThresholdForecastOptionsArgsDict',
    'AlertPolicyConditionConditionThresholdTriggerArgs',
    'AlertPolicyConditionConditionThresholdTriggerArgsDict',
    'AlertPolicyCreationRecordArgs',
    'AlertPolicyCreationRecordArgsDict',
    'AlertPolicyDocumentationArgs',
    'AlertPolicyDocumentationArgsDict',
    'AlertPolicyDocumentationLinkArgs',
    'AlertPolicyDocumentationLinkArgsDict',
    'CustomServiceTelemetryArgs',
    'CustomServiceTelemetryArgsDict',
    'GenericServiceBasicServiceArgs',
    'GenericServiceBasicServiceArgsDict',
    'GenericServiceTelemetryArgs',
    'GenericServiceTelemetryArgsDict',
    'MetricDescriptorLabelArgs',
    'MetricDescriptorLabelArgsDict',
    'MetricDescriptorMetadataArgs',
    'MetricDescriptorMetadataArgsDict',
    'NotificationChannelSensitiveLabelsArgs',
    'NotificationChannelSensitiveLabelsArgsDict',
    'SloBasicSliArgs',
    'SloBasicSliArgsDict',
    'SloBasicSliAvailabilityArgs',
    'SloBasicSliAvailabilityArgsDict',
    'SloBasicSliLatencyArgs',
    'SloBasicSliLatencyArgsDict',
    'SloRequestBasedSliArgs',
    'SloRequestBasedSliArgsDict',
    'SloRequestBasedSliDistributionCutArgs',
    'SloRequestBasedSliDistributionCutArgsDict',
    'SloRequestBasedSliDistributionCutRangeArgs',
    'SloRequestBasedSliDistributionCutRangeArgsDict',
    'SloRequestBasedSliGoodTotalRatioArgs',
    'SloRequestBasedSliGoodTotalRatioArgsDict',
    'SloWindowsBasedSliArgs',
    'SloWindowsBasedSliArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgsDict',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs',
    'SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgsDict',
    'SloWindowsBasedSliMetricMeanInRangeArgs',
    'SloWindowsBasedSliMetricMeanInRangeArgsDict',
    'SloWindowsBasedSliMetricMeanInRangeRangeArgs',
    'SloWindowsBasedSliMetricMeanInRangeRangeArgsDict',
    'SloWindowsBasedSliMetricSumInRangeArgs',
    'SloWindowsBasedSliMetricSumInRangeArgsDict',
    'SloWindowsBasedSliMetricSumInRangeRangeArgs',
    'SloWindowsBasedSliMetricSumInRangeRangeArgsDict',
    'UptimeCheckConfigContentMatcherArgs',
    'UptimeCheckConfigContentMatcherArgsDict',
    'UptimeCheckConfigContentMatcherJsonPathMatcherArgs',
    'UptimeCheckConfigContentMatcherJsonPathMatcherArgsDict',
    'UptimeCheckConfigHttpCheckArgs',
    'UptimeCheckConfigHttpCheckArgsDict',
    'UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs',
    'UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgsDict',
    'UptimeCheckConfigHttpCheckAuthInfoArgs',
    'UptimeCheckConfigHttpCheckAuthInfoArgsDict',
    'UptimeCheckConfigHttpCheckPingConfigArgs',
    'UptimeCheckConfigHttpCheckPingConfigArgsDict',
    'UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs',
    'UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgsDict',
    'UptimeCheckConfigMonitoredResourceArgs',
    'UptimeCheckConfigMonitoredResourceArgsDict',
    'UptimeCheckConfigResourceGroupArgs',
    'UptimeCheckConfigResourceGroupArgsDict',
    'UptimeCheckConfigSyntheticMonitorArgs',
    'UptimeCheckConfigSyntheticMonitorArgsDict',
    'UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args',
    'UptimeCheckConfigSyntheticMonitorCloudFunctionV2ArgsDict',
    'UptimeCheckConfigTcpCheckArgs',
    'UptimeCheckConfigTcpCheckArgsDict',
    'UptimeCheckConfigTcpCheckPingConfigArgs',
    'UptimeCheckConfigTcpCheckPingConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AlertPolicyAlertStrategyArgsDict(TypedDict):
        auto_close: NotRequired[pulumi.Input[str]]
        """
        If an alert policy that was active has no data for this long, any open incidents will close.
        """
        notification_channel_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPolicyAlertStrategyNotificationChannelStrategyArgsDict']]]]
        """
        Control over how the notification channels in `notification_channels`
        are notified when this alert fires, on a per-channel basis.
        Structure is documented below.
        """
        notification_prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Control when notifications will be sent out.
        Each value may be one of: `NOTIFICATION_PROMPT_UNSPECIFIED`, `OPENED`, `CLOSED`.
        """
        notification_rate_limit: NotRequired[pulumi.Input['AlertPolicyAlertStrategyNotificationRateLimitArgsDict']]
        """
        Required for alert policies with a LogMatch condition.
        This limit is not implemented for alert policies that are not log-based.
        Structure is documented below.
        """
elif False:
    AlertPolicyAlertStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyAlertStrategyArgs:
    def __init__(__self__, *,
                 auto_close: Optional[pulumi.Input[str]] = None,
                 notification_channel_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyAlertStrategyNotificationChannelStrategyArgs']]]] = None,
                 notification_prompts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 notification_rate_limit: Optional[pulumi.Input['AlertPolicyAlertStrategyNotificationRateLimitArgs']] = None):
        """
        :param pulumi.Input[str] auto_close: If an alert policy that was active has no data for this long, any open incidents will close.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyAlertStrategyNotificationChannelStrategyArgs']]] notification_channel_strategies: Control over how the notification channels in `notification_channels`
               are notified when this alert fires, on a per-channel basis.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_prompts: Control when notifications will be sent out.
               Each value may be one of: `NOTIFICATION_PROMPT_UNSPECIFIED`, `OPENED`, `CLOSED`.
        :param pulumi.Input['AlertPolicyAlertStrategyNotificationRateLimitArgs'] notification_rate_limit: Required for alert policies with a LogMatch condition.
               This limit is not implemented for alert policies that are not log-based.
               Structure is documented below.
        """
        if auto_close is not None:
            pulumi.set(__self__, "auto_close", auto_close)
        if notification_channel_strategies is not None:
            pulumi.set(__self__, "notification_channel_strategies", notification_channel_strategies)
        if notification_prompts is not None:
            pulumi.set(__self__, "notification_prompts", notification_prompts)
        if notification_rate_limit is not None:
            pulumi.set(__self__, "notification_rate_limit", notification_rate_limit)

    @property
    @pulumi.getter(name="autoClose")
    def auto_close(self) -> Optional[pulumi.Input[str]]:
        """
        If an alert policy that was active has no data for this long, any open incidents will close.
        """
        return pulumi.get(self, "auto_close")

    @auto_close.setter
    def auto_close(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_close", value)

    @property
    @pulumi.getter(name="notificationChannelStrategies")
    def notification_channel_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyAlertStrategyNotificationChannelStrategyArgs']]]]:
        """
        Control over how the notification channels in `notification_channels`
        are notified when this alert fires, on a per-channel basis.
        Structure is documented below.
        """
        return pulumi.get(self, "notification_channel_strategies")

    @notification_channel_strategies.setter
    def notification_channel_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyAlertStrategyNotificationChannelStrategyArgs']]]]):
        pulumi.set(self, "notification_channel_strategies", value)

    @property
    @pulumi.getter(name="notificationPrompts")
    def notification_prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Control when notifications will be sent out.
        Each value may be one of: `NOTIFICATION_PROMPT_UNSPECIFIED`, `OPENED`, `CLOSED`.
        """
        return pulumi.get(self, "notification_prompts")

    @notification_prompts.setter
    def notification_prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notification_prompts", value)

    @property
    @pulumi.getter(name="notificationRateLimit")
    def notification_rate_limit(self) -> Optional[pulumi.Input['AlertPolicyAlertStrategyNotificationRateLimitArgs']]:
        """
        Required for alert policies with a LogMatch condition.
        This limit is not implemented for alert policies that are not log-based.
        Structure is documented below.
        """
        return pulumi.get(self, "notification_rate_limit")

    @notification_rate_limit.setter
    def notification_rate_limit(self, value: Optional[pulumi.Input['AlertPolicyAlertStrategyNotificationRateLimitArgs']]):
        pulumi.set(self, "notification_rate_limit", value)


if not MYPY:
    class AlertPolicyAlertStrategyNotificationChannelStrategyArgsDict(TypedDict):
        notification_channel_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The notification channels that these settings apply to. Each of these
        correspond to the name field in one of the NotificationChannel objects
        referenced in the notification_channels field of this AlertPolicy. The format is
        `projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]`
        """
        renotify_interval: NotRequired[pulumi.Input[str]]
        """
        The frequency at which to send reminder notifications for open incidents.
        """
elif False:
    AlertPolicyAlertStrategyNotificationChannelStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyAlertStrategyNotificationChannelStrategyArgs:
    def __init__(__self__, *,
                 notification_channel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 renotify_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_channel_names: The notification channels that these settings apply to. Each of these
               correspond to the name field in one of the NotificationChannel objects
               referenced in the notification_channels field of this AlertPolicy. The format is
               `projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]`
        :param pulumi.Input[str] renotify_interval: The frequency at which to send reminder notifications for open incidents.
        """
        if notification_channel_names is not None:
            pulumi.set(__self__, "notification_channel_names", notification_channel_names)
        if renotify_interval is not None:
            pulumi.set(__self__, "renotify_interval", renotify_interval)

    @property
    @pulumi.getter(name="notificationChannelNames")
    def notification_channel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The notification channels that these settings apply to. Each of these
        correspond to the name field in one of the NotificationChannel objects
        referenced in the notification_channels field of this AlertPolicy. The format is
        `projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]`
        """
        return pulumi.get(self, "notification_channel_names")

    @notification_channel_names.setter
    def notification_channel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notification_channel_names", value)

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[pulumi.Input[str]]:
        """
        The frequency at which to send reminder notifications for open incidents.
        """
        return pulumi.get(self, "renotify_interval")

    @renotify_interval.setter
    def renotify_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "renotify_interval", value)


if not MYPY:
    class AlertPolicyAlertStrategyNotificationRateLimitArgsDict(TypedDict):
        period: NotRequired[pulumi.Input[str]]
        """
        Not more than one notification per period.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
        """
elif False:
    AlertPolicyAlertStrategyNotificationRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyAlertStrategyNotificationRateLimitArgs:
    def __init__(__self__, *,
                 period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] period: Not more than one notification per period.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
        """
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[str]]:
        """
        Not more than one notification per period.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class AlertPolicyConditionArgsDict(TypedDict):
        display_name: pulumi.Input[str]
        """
        A short name or phrase used to identify the
        condition in dashboards, notifications, and
        incidents. To avoid confusion, don't use the same
        display name for multiple conditions in the same
        policy.
        """
        condition_absent: NotRequired[pulumi.Input['AlertPolicyConditionConditionAbsentArgsDict']]
        """
        A condition that checks that a time series
        continues to receive new data points.
        Structure is documented below.
        """
        condition_matched_log: NotRequired[pulumi.Input['AlertPolicyConditionConditionMatchedLogArgsDict']]
        """
        A condition that checks for log messages matching given constraints.
        If set, no other conditions can be present.
        Structure is documented below.
        """
        condition_monitoring_query_language: NotRequired[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageArgsDict']]
        """
        A Monitoring Query Language query that outputs a boolean stream
        Structure is documented below.
        """
        condition_prometheus_query_language: NotRequired[pulumi.Input['AlertPolicyConditionConditionPrometheusQueryLanguageArgsDict']]
        """
        A condition type that allows alert policies to be defined using
        Prometheus Query Language (PromQL).
        The PrometheusQueryLanguageCondition message contains information
        from a Prometheus alerting rule and its associated rule group.
        Structure is documented below.
        """
        condition_sql: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlArgsDict']]
        """
        A condition that allows alerting policies to be defined using GoogleSQL.
        SQL conditions examine a sliding window of logs using GoogleSQL.
        Alert policies with SQL conditions may incur additional billing.
        Structure is documented below.
        """
        condition_threshold: NotRequired[pulumi.Input['AlertPolicyConditionConditionThresholdArgsDict']]
        """
        A condition that compares a time series against a
        threshold.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The unique resource name for this condition.
        Its syntax is:
        projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        [CONDITION_ID] is assigned by Stackdriver Monitoring when
        the condition is created as part of a new or updated alerting
        policy.
        """
elif False:
    AlertPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 condition_absent: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentArgs']] = None,
                 condition_matched_log: Optional[pulumi.Input['AlertPolicyConditionConditionMatchedLogArgs']] = None,
                 condition_monitoring_query_language: Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageArgs']] = None,
                 condition_prometheus_query_language: Optional[pulumi.Input['AlertPolicyConditionConditionPrometheusQueryLanguageArgs']] = None,
                 condition_sql: Optional[pulumi.Input['AlertPolicyConditionConditionSqlArgs']] = None,
                 condition_threshold: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: A short name or phrase used to identify the
               condition in dashboards, notifications, and
               incidents. To avoid confusion, don't use the same
               display name for multiple conditions in the same
               policy.
        :param pulumi.Input['AlertPolicyConditionConditionAbsentArgs'] condition_absent: A condition that checks that a time series
               continues to receive new data points.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionMatchedLogArgs'] condition_matched_log: A condition that checks for log messages matching given constraints.
               If set, no other conditions can be present.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageArgs'] condition_monitoring_query_language: A Monitoring Query Language query that outputs a boolean stream
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionPrometheusQueryLanguageArgs'] condition_prometheus_query_language: A condition type that allows alert policies to be defined using
               Prometheus Query Language (PromQL).
               The PrometheusQueryLanguageCondition message contains information
               from a Prometheus alerting rule and its associated rule group.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionSqlArgs'] condition_sql: A condition that allows alerting policies to be defined using GoogleSQL.
               SQL conditions examine a sliding window of logs using GoogleSQL.
               Alert policies with SQL conditions may incur additional billing.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionThresholdArgs'] condition_threshold: A condition that compares a time series against a
               threshold.
               Structure is documented below.
        :param pulumi.Input[str] name: (Output)
               The unique resource name for this condition.
               Its syntax is:
               projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
               [CONDITION_ID] is assigned by Stackdriver Monitoring when
               the condition is created as part of a new or updated alerting
               policy.
        """
        pulumi.set(__self__, "display_name", display_name)
        if condition_absent is not None:
            pulumi.set(__self__, "condition_absent", condition_absent)
        if condition_matched_log is not None:
            pulumi.set(__self__, "condition_matched_log", condition_matched_log)
        if condition_monitoring_query_language is not None:
            pulumi.set(__self__, "condition_monitoring_query_language", condition_monitoring_query_language)
        if condition_prometheus_query_language is not None:
            pulumi.set(__self__, "condition_prometheus_query_language", condition_prometheus_query_language)
        if condition_sql is not None:
            pulumi.set(__self__, "condition_sql", condition_sql)
        if condition_threshold is not None:
            pulumi.set(__self__, "condition_threshold", condition_threshold)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        A short name or phrase used to identify the
        condition in dashboards, notifications, and
        incidents. To avoid confusion, don't use the same
        display name for multiple conditions in the same
        policy.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="conditionAbsent")
    def condition_absent(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionAbsentArgs']]:
        """
        A condition that checks that a time series
        continues to receive new data points.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_absent")

    @condition_absent.setter
    def condition_absent(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentArgs']]):
        pulumi.set(self, "condition_absent", value)

    @property
    @pulumi.getter(name="conditionMatchedLog")
    def condition_matched_log(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionMatchedLogArgs']]:
        """
        A condition that checks for log messages matching given constraints.
        If set, no other conditions can be present.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_matched_log")

    @condition_matched_log.setter
    def condition_matched_log(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionMatchedLogArgs']]):
        pulumi.set(self, "condition_matched_log", value)

    @property
    @pulumi.getter(name="conditionMonitoringQueryLanguage")
    def condition_monitoring_query_language(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageArgs']]:
        """
        A Monitoring Query Language query that outputs a boolean stream
        Structure is documented below.
        """
        return pulumi.get(self, "condition_monitoring_query_language")

    @condition_monitoring_query_language.setter
    def condition_monitoring_query_language(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageArgs']]):
        pulumi.set(self, "condition_monitoring_query_language", value)

    @property
    @pulumi.getter(name="conditionPrometheusQueryLanguage")
    def condition_prometheus_query_language(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionPrometheusQueryLanguageArgs']]:
        """
        A condition type that allows alert policies to be defined using
        Prometheus Query Language (PromQL).
        The PrometheusQueryLanguageCondition message contains information
        from a Prometheus alerting rule and its associated rule group.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_prometheus_query_language")

    @condition_prometheus_query_language.setter
    def condition_prometheus_query_language(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionPrometheusQueryLanguageArgs']]):
        pulumi.set(self, "condition_prometheus_query_language", value)

    @property
    @pulumi.getter(name="conditionSql")
    def condition_sql(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlArgs']]:
        """
        A condition that allows alerting policies to be defined using GoogleSQL.
        SQL conditions examine a sliding window of logs using GoogleSQL.
        Alert policies with SQL conditions may incur additional billing.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_sql")

    @condition_sql.setter
    def condition_sql(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlArgs']]):
        pulumi.set(self, "condition_sql", value)

    @property
    @pulumi.getter(name="conditionThreshold")
    def condition_threshold(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionThresholdArgs']]:
        """
        A condition that compares a time series against a
        threshold.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_threshold")

    @condition_threshold.setter
    def condition_threshold(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdArgs']]):
        pulumi.set(self, "condition_threshold", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The unique resource name for this condition.
        Its syntax is:
        projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
        [CONDITION_ID] is assigned by Stackdriver Monitoring when
        the condition is created as part of a new or updated alerting
        policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AlertPolicyConditionConditionAbsentArgsDict(TypedDict):
        duration: pulumi.Input[str]
        """
        The amount of time that a time series must
        fail to report new data to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g. 60s, 120s, or 300s
        --are supported.
        """
        aggregations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgsDict']]]]
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[str]]
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        trigger: NotRequired[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgsDict']]
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations.
        Structure is documented below.
        """
elif False:
    AlertPolicyConditionConditionAbsentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionAbsentArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 aggregations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 trigger: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs']] = None):
        """
        :param pulumi.Input[str] duration: The amount of time that a time series must
               fail to report new data to be considered
               failing. Currently, only values that are a
               multiple of a minute--e.g. 60s, 120s, or 300s
               --are supported.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]] aggregations: Specifies the alignment of data points in
               individual time series as well as how to
               combine the retrieved time series together
               (such as when aggregating multiple streams
               on each resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).
               Multiple aggregations are applied in the
               order specified.
               Structure is documented below.
        :param pulumi.Input[str] filter: A filter that identifies which time series
               should be compared with the threshold.The
               filter is similar to the one that is
               specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs'] trigger: The number/percent of time series for which
               the comparison must hold in order for the
               condition to trigger. If unspecified, then
               the condition will trigger if the comparison
               is true for any of the time series that have
               been identified by filter and aggregations.
               Structure is documented below.
        """
        pulumi.set(__self__, "duration", duration)
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        The amount of time that a time series must
        fail to report new data to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g. 60s, 120s, or 300s
        --are supported.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]]]:
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.
        Structure is documented below.
        """
        return pulumi.get(self, "aggregations")

    @aggregations.setter
    def aggregations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionAbsentAggregationArgs']]]]):
        pulumi.set(self, "aggregations", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs']]:
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionAbsentTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class AlertPolicyConditionConditionAbsentAggregationArgsDict(TypedDict):
        alignment_period: NotRequired[pulumi.Input[str]]
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        cross_series_reducer: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        group_by_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        per_series_aligner: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
elif False:
    AlertPolicyConditionConditionAbsentAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionAbsentAggregationArgs:
    def __init__(__self__, *,
                 alignment_period: Optional[pulumi.Input[str]] = None,
                 cross_series_reducer: Optional[pulumi.Input[str]] = None,
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 per_series_aligner: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        if alignment_period is not None:
            pulumi.set(__self__, "alignment_period", alignment_period)
        if cross_series_reducer is not None:
            pulumi.set(__self__, "cross_series_reducer", cross_series_reducer)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if per_series_aligner is not None:
            pulumi.set(__self__, "per_series_aligner", per_series_aligner)

    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        return pulumi.get(self, "alignment_period")

    @alignment_period.setter
    def alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment_period", value)

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        return pulumi.get(self, "cross_series_reducer")

    @cross_series_reducer.setter
    def cross_series_reducer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_series_reducer", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        return pulumi.get(self, "per_series_aligner")

    @per_series_aligner.setter
    def per_series_aligner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_series_aligner", value)


if not MYPY:
    class AlertPolicyConditionConditionAbsentTriggerArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[int]]
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
elif False:
    AlertPolicyConditionConditionAbsentTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionAbsentTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] count: The absolute number of time series
               that must fail the predicate for the
               condition to be triggered.
        :param pulumi.Input[float] percent: The percentage of time series that
               must fail the predicate for the
               condition to be triggered.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AlertPolicyConditionConditionMatchedLogArgsDict(TypedDict):
        filter: pulumi.Input[str]
        """
        A logs-based filter.
        """
        label_extractors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map from a label key to an extractor expression, which is used to
        extract the value for this label key. Each entry in this map is
        a specification for how data should be extracted from log entries that
        match filter. Each combination of extracted values is treated as
        a separate rule for the purposes of triggering notifications.
        Label keys and corresponding values can be used in notifications
        generated by this condition.
        """
elif False:
    AlertPolicyConditionConditionMatchedLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionMatchedLogArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[str],
                 label_extractors: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] filter: A logs-based filter.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] label_extractors: A map from a label key to an extractor expression, which is used to
               extract the value for this label key. Each entry in this map is
               a specification for how data should be extracted from log entries that
               match filter. Each combination of extracted values is treated as
               a separate rule for the purposes of triggering notifications.
               Label keys and corresponding values can be used in notifications
               generated by this condition.
        """
        pulumi.set(__self__, "filter", filter)
        if label_extractors is not None:
            pulumi.set(__self__, "label_extractors", label_extractors)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[str]:
        """
        A logs-based filter.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="labelExtractors")
    def label_extractors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map from a label key to an extractor expression, which is used to
        extract the value for this label key. Each entry in this map is
        a specification for how data should be extracted from log entries that
        match filter. Each combination of extracted values is treated as
        a separate rule for the purposes of triggering notifications.
        Label keys and corresponding values can be used in notifications
        generated by this condition.
        """
        return pulumi.get(self, "label_extractors")

    @label_extractors.setter
    def label_extractors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "label_extractors", value)


if not MYPY:
    class AlertPolicyConditionConditionMonitoringQueryLanguageArgsDict(TypedDict):
        duration: pulumi.Input[str]
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        query: pulumi.Input[str]
        """
        Monitoring Query Language query that outputs a boolean stream.
        """
        evaluation_missing_data: NotRequired[pulumi.Input[str]]
        """
        A condition control that determines how
        metric-threshold conditions are evaluated when
        data stops arriving.
        Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        """
        trigger: NotRequired[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgsDict']]
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
elif False:
    AlertPolicyConditionConditionMonitoringQueryLanguageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionMonitoringQueryLanguageArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 query: pulumi.Input[str],
                 evaluation_missing_data: Optional[pulumi.Input[str]] = None,
                 trigger: Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs']] = None):
        """
        :param pulumi.Input[str] duration: The amount of time that a time series must
               violate the threshold to be considered
               failing. Currently, only values that are a
               multiple of a minute--e.g., 0, 60, 120, or
               300 seconds--are supported. If an invalid
               value is given, an error will be returned.
               When choosing a duration, it is useful to
               keep in mind the frequency of the underlying
               time series data (which may also be affected
               by any alignments specified in the
               aggregations field); a good duration is long
               enough so that a single outlier does not
               generate spurious alerts, but short enough
               that unhealthy states are detected and
               alerted on quickly.
        :param pulumi.Input[str] query: Monitoring Query Language query that outputs a boolean stream.
        :param pulumi.Input[str] evaluation_missing_data: A condition control that determines how
               metric-threshold conditions are evaluated when
               data stops arriving.
               Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        :param pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs'] trigger: The number/percent of time series for which
               the comparison must hold in order for the
               condition to trigger. If unspecified, then
               the condition will trigger if the comparison
               is true for any of the time series that have
               been identified by filter and aggregations,
               or by the ratio, if denominator_filter and
               denominator_aggregations are specified.
               Structure is documented below.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "query", query)
        if evaluation_missing_data is not None:
            pulumi.set(__self__, "evaluation_missing_data", evaluation_missing_data)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Monitoring Query Language query that outputs a boolean stream.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="evaluationMissingData")
    def evaluation_missing_data(self) -> Optional[pulumi.Input[str]]:
        """
        A condition control that determines how
        metric-threshold conditions are evaluated when
        data stops arriving.
        Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        """
        return pulumi.get(self, "evaluation_missing_data")

    @evaluation_missing_data.setter
    def evaluation_missing_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_missing_data", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs']]:
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[int]]
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
elif False:
    AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionMonitoringQueryLanguageTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] count: The absolute number of time series
               that must fail the predicate for the
               condition to be triggered.
        :param pulumi.Input[float] percent: The percentage of time series that
               must fail the predicate for the
               condition to be triggered.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AlertPolicyConditionConditionPrometheusQueryLanguageArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        The PromQL expression to evaluate. Every evaluation cycle this
        expression is evaluated at the current time, and all resultant time
        series become pending/firing alerts. This field must not be empty.
        """
        alert_rule: NotRequired[pulumi.Input[str]]
        """
        The alerting rule name of this alert in the corresponding Prometheus
        configuration file.
        Some external tools may require this field to be populated correctly
        in order to refer to the original Prometheus configuration file.
        The rule group name and the alert name are necessary to update the
        relevant AlertPolicies in case the definition of the rule group changes
        in the future.
        This field is optional. If this field is not empty, then it must be a
        valid Prometheus label name.
        """
        disable_metric_validation: NotRequired[pulumi.Input[bool]]
        duration: NotRequired[pulumi.Input[str]]
        """
        Alerts are considered firing once their PromQL expression evaluated
        to be "true" for this long. Alerts whose PromQL expression was not
        evaluated to be "true" for long enough are considered pending. The
        default value is zero. Must be zero or positive.
        """
        evaluation_interval: NotRequired[pulumi.Input[str]]
        """
        How often this rule should be evaluated. Must be a positive multiple
        of 30 seconds or missing. The default value is 30 seconds. If this
        PrometheusQueryLanguageCondition was generated from a Prometheus
        alerting rule, then this value should be taken from the enclosing
        rule group.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels to add to or overwrite in the PromQL query result. Label names
        must be valid.
        Label values can be templatized by using variables. The only available
        variable names are the names of the labels in the PromQL result,
        although label names beginning with \\_\\_ (two "\\_") are reserved for
        internal use. "labels" may be empty. This field is intended to be used
        for organizing and identifying the AlertPolicy.
        """
        rule_group: NotRequired[pulumi.Input[str]]
        """
        The rule group name of this alert in the corresponding Prometheus
        configuration file.
        Some external tools may require this field to be populated correctly
        in order to refer to the original Prometheus configuration file.
        The rule group name and the alert name are necessary to update the
        relevant AlertPolicies in case the definition of the rule group changes
        in the future. This field is optional.
        """
elif False:
    AlertPolicyConditionConditionPrometheusQueryLanguageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionPrometheusQueryLanguageArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 alert_rule: Optional[pulumi.Input[str]] = None,
                 disable_metric_validation: Optional[pulumi.Input[bool]] = None,
                 duration: Optional[pulumi.Input[str]] = None,
                 evaluation_interval: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 rule_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The PromQL expression to evaluate. Every evaluation cycle this
               expression is evaluated at the current time, and all resultant time
               series become pending/firing alerts. This field must not be empty.
        :param pulumi.Input[str] alert_rule: The alerting rule name of this alert in the corresponding Prometheus
               configuration file.
               Some external tools may require this field to be populated correctly
               in order to refer to the original Prometheus configuration file.
               The rule group name and the alert name are necessary to update the
               relevant AlertPolicies in case the definition of the rule group changes
               in the future.
               This field is optional. If this field is not empty, then it must be a
               valid Prometheus label name.
        :param pulumi.Input[str] duration: Alerts are considered firing once their PromQL expression evaluated
               to be "true" for this long. Alerts whose PromQL expression was not
               evaluated to be "true" for long enough are considered pending. The
               default value is zero. Must be zero or positive.
        :param pulumi.Input[str] evaluation_interval: How often this rule should be evaluated. Must be a positive multiple
               of 30 seconds or missing. The default value is 30 seconds. If this
               PrometheusQueryLanguageCondition was generated from a Prometheus
               alerting rule, then this value should be taken from the enclosing
               rule group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to add to or overwrite in the PromQL query result. Label names
               must be valid.
               Label values can be templatized by using variables. The only available
               variable names are the names of the labels in the PromQL result,
               although label names beginning with \\_\\_ (two "\\_") are reserved for
               internal use. "labels" may be empty. This field is intended to be used
               for organizing and identifying the AlertPolicy.
        :param pulumi.Input[str] rule_group: The rule group name of this alert in the corresponding Prometheus
               configuration file.
               Some external tools may require this field to be populated correctly
               in order to refer to the original Prometheus configuration file.
               The rule group name and the alert name are necessary to update the
               relevant AlertPolicies in case the definition of the rule group changes
               in the future. This field is optional.
        """
        pulumi.set(__self__, "query", query)
        if alert_rule is not None:
            pulumi.set(__self__, "alert_rule", alert_rule)
        if disable_metric_validation is not None:
            pulumi.set(__self__, "disable_metric_validation", disable_metric_validation)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if evaluation_interval is not None:
            pulumi.set(__self__, "evaluation_interval", evaluation_interval)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if rule_group is not None:
            pulumi.set(__self__, "rule_group", rule_group)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The PromQL expression to evaluate. Every evaluation cycle this
        expression is evaluated at the current time, and all resultant time
        series become pending/firing alerts. This field must not be empty.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="alertRule")
    def alert_rule(self) -> Optional[pulumi.Input[str]]:
        """
        The alerting rule name of this alert in the corresponding Prometheus
        configuration file.
        Some external tools may require this field to be populated correctly
        in order to refer to the original Prometheus configuration file.
        The rule group name and the alert name are necessary to update the
        relevant AlertPolicies in case the definition of the rule group changes
        in the future.
        This field is optional. If this field is not empty, then it must be a
        valid Prometheus label name.
        """
        return pulumi.get(self, "alert_rule")

    @alert_rule.setter
    def alert_rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_rule", value)

    @property
    @pulumi.getter(name="disableMetricValidation")
    def disable_metric_validation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_metric_validation")

    @disable_metric_validation.setter
    def disable_metric_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_metric_validation", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Alerts are considered firing once their PromQL expression evaluated
        to be "true" for this long. Alerts whose PromQL expression was not
        evaluated to be "true" for long enough are considered pending. The
        default value is zero. Must be zero or positive.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[pulumi.Input[str]]:
        """
        How often this rule should be evaluated. Must be a positive multiple
        of 30 seconds or missing. The default value is 30 seconds. If this
        PrometheusQueryLanguageCondition was generated from a Prometheus
        alerting rule, then this value should be taken from the enclosing
        rule group.
        """
        return pulumi.get(self, "evaluation_interval")

    @evaluation_interval.setter
    def evaluation_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_interval", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to add to or overwrite in the PromQL query result. Label names
        must be valid.
        Label values can be templatized by using variables. The only available
        variable names are the names of the labels in the PromQL result,
        although label names beginning with \\_\\_ (two "\\_") are reserved for
        internal use. "labels" may be empty. This field is intended to be used
        for organizing and identifying the AlertPolicy.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="ruleGroup")
    def rule_group(self) -> Optional[pulumi.Input[str]]:
        """
        The rule group name of this alert in the corresponding Prometheus
        configuration file.
        Some external tools may require this field to be populated correctly
        in order to refer to the original Prometheus configuration file.
        The rule group name and the alert name are necessary to update the
        relevant AlertPolicies in case the definition of the rule group changes
        in the future. This field is optional.
        """
        return pulumi.get(self, "rule_group")

    @rule_group.setter
    def rule_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_group", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        The Log Analytics SQL query to run, as a string.  The query must
        conform to the required shape. Specifically, the query must not try to
        filter the input by time.  A filter will automatically be applied
        to filter the input so that the query receives all rows received
        since the last time the query was run.
        """
        boolean_test: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlBooleanTestArgsDict']]
        """
        A test that uses an alerting result in a boolean column produced by the SQL query.
        Structure is documented below.
        """
        daily: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlDailyArgsDict']]
        """
        Used to schedule the query to run every so many days.
        Structure is documented below.
        """
        hourly: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlHourlyArgsDict']]
        """
        Used to schedule the query to run every so many hours.
        Structure is documented below.
        """
        minutes: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlMinutesArgsDict']]
        """
        Used to schedule the query to run every so many minutes.
        Structure is documented below.
        """
        row_count_test: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlRowCountTestArgsDict']]
        """
        A test that checks if the number of rows in the result set violates some threshold.
        Structure is documented below.
        """
elif False:
    AlertPolicyConditionConditionSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 boolean_test: Optional[pulumi.Input['AlertPolicyConditionConditionSqlBooleanTestArgs']] = None,
                 daily: Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyArgs']] = None,
                 hourly: Optional[pulumi.Input['AlertPolicyConditionConditionSqlHourlyArgs']] = None,
                 minutes: Optional[pulumi.Input['AlertPolicyConditionConditionSqlMinutesArgs']] = None,
                 row_count_test: Optional[pulumi.Input['AlertPolicyConditionConditionSqlRowCountTestArgs']] = None):
        """
        :param pulumi.Input[str] query: The Log Analytics SQL query to run, as a string.  The query must
               conform to the required shape. Specifically, the query must not try to
               filter the input by time.  A filter will automatically be applied
               to filter the input so that the query receives all rows received
               since the last time the query was run.
        :param pulumi.Input['AlertPolicyConditionConditionSqlBooleanTestArgs'] boolean_test: A test that uses an alerting result in a boolean column produced by the SQL query.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionSqlDailyArgs'] daily: Used to schedule the query to run every so many days.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionSqlHourlyArgs'] hourly: Used to schedule the query to run every so many hours.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionSqlMinutesArgs'] minutes: Used to schedule the query to run every so many minutes.
               Structure is documented below.
        :param pulumi.Input['AlertPolicyConditionConditionSqlRowCountTestArgs'] row_count_test: A test that checks if the number of rows in the result set violates some threshold.
               Structure is documented below.
        """
        pulumi.set(__self__, "query", query)
        if boolean_test is not None:
            pulumi.set(__self__, "boolean_test", boolean_test)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if hourly is not None:
            pulumi.set(__self__, "hourly", hourly)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if row_count_test is not None:
            pulumi.set(__self__, "row_count_test", row_count_test)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The Log Analytics SQL query to run, as a string.  The query must
        conform to the required shape. Specifically, the query must not try to
        filter the input by time.  A filter will automatically be applied
        to filter the input so that the query receives all rows received
        since the last time the query was run.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="booleanTest")
    def boolean_test(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlBooleanTestArgs']]:
        """
        A test that uses an alerting result in a boolean column produced by the SQL query.
        Structure is documented below.
        """
        return pulumi.get(self, "boolean_test")

    @boolean_test.setter
    def boolean_test(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlBooleanTestArgs']]):
        pulumi.set(self, "boolean_test", value)

    @property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyArgs']]:
        """
        Used to schedule the query to run every so many days.
        Structure is documented below.
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyArgs']]):
        pulumi.set(self, "daily", value)

    @property
    @pulumi.getter
    def hourly(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlHourlyArgs']]:
        """
        Used to schedule the query to run every so many hours.
        Structure is documented below.
        """
        return pulumi.get(self, "hourly")

    @hourly.setter
    def hourly(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlHourlyArgs']]):
        pulumi.set(self, "hourly", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlMinutesArgs']]:
        """
        Used to schedule the query to run every so many minutes.
        Structure is documented below.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlMinutesArgs']]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter(name="rowCountTest")
    def row_count_test(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlRowCountTestArgs']]:
        """
        A test that checks if the number of rows in the result set violates some threshold.
        Structure is documented below.
        """
        return pulumi.get(self, "row_count_test")

    @row_count_test.setter
    def row_count_test(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlRowCountTestArgs']]):
        pulumi.set(self, "row_count_test", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlBooleanTestArgsDict(TypedDict):
        column: pulumi.Input[str]
        """
        The name of the column containing the boolean value. If the value in a row is
        NULL, that row is ignored.

        - - -
        """
elif False:
    AlertPolicyConditionConditionSqlBooleanTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlBooleanTestArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The name of the column containing the boolean value. If the value in a row is
               NULL, that row is ignored.
               
               - - -
        """
        pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The name of the column containing the boolean value. If the value in a row is
        NULL, that row is ignored.

        - - -
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlDailyArgsDict(TypedDict):
        periodicity: pulumi.Input[int]
        """
        The number of days between runs. Must be greater than or equal
        to 1 day and less than or equal to 30 days.
        """
        execution_time: NotRequired[pulumi.Input['AlertPolicyConditionConditionSqlDailyExecutionTimeArgsDict']]
        """
        The time of day (in UTC) at which the query should run. If left
        unspecified, the server picks an arbitrary time of day and runs
        the query at the same time each day.
        Structure is documented below.
        """
elif False:
    AlertPolicyConditionConditionSqlDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlDailyArgs:
    def __init__(__self__, *,
                 periodicity: pulumi.Input[int],
                 execution_time: Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyExecutionTimeArgs']] = None):
        """
        :param pulumi.Input[int] periodicity: The number of days between runs. Must be greater than or equal
               to 1 day and less than or equal to 30 days.
        :param pulumi.Input['AlertPolicyConditionConditionSqlDailyExecutionTimeArgs'] execution_time: The time of day (in UTC) at which the query should run. If left
               unspecified, the server picks an arbitrary time of day and runs
               the query at the same time each day.
               Structure is documented below.
        """
        pulumi.set(__self__, "periodicity", periodicity)
        if execution_time is not None:
            pulumi.set(__self__, "execution_time", execution_time)

    @property
    @pulumi.getter
    def periodicity(self) -> pulumi.Input[int]:
        """
        The number of days between runs. Must be greater than or equal
        to 1 day and less than or equal to 30 days.
        """
        return pulumi.get(self, "periodicity")

    @periodicity.setter
    def periodicity(self, value: pulumi.Input[int]):
        pulumi.set(self, "periodicity", value)

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyExecutionTimeArgs']]:
        """
        The time of day (in UTC) at which the query should run. If left
        unspecified, the server picks an arbitrary time of day and runs
        the query at the same time each day.
        Structure is documented below.
        """
        return pulumi.get(self, "execution_time")

    @execution_time.setter
    def execution_time(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionSqlDailyExecutionTimeArgs']]):
        pulumi.set(self, "execution_time", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlDailyExecutionTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of a day in 24 hour format. Must be greater than or equal
        to 0 and typically must be less than or equal to 23. An API may
        choose to allow the value "24:00:00" for scenarios like business
        closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of an hour. Must be greater than or equal to 0 and
        less than or equal to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds, in nanoseconds. Must be greater than or
        equal to 0 and less than or equal to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of a minute. Must be greater than or equal to 0 and
        typically must be less than or equal to 59. An API may allow the
        value 60 if it allows leap-seconds.
        """
elif False:
    AlertPolicyConditionConditionSqlDailyExecutionTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlDailyExecutionTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of a day in 24 hour format. Must be greater than or equal
               to 0 and typically must be less than or equal to 23. An API may
               choose to allow the value "24:00:00" for scenarios like business
               closing time.
        :param pulumi.Input[int] minutes: Minutes of an hour. Must be greater than or equal to 0 and
               less than or equal to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds, in nanoseconds. Must be greater than or
               equal to 0 and less than or equal to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of a minute. Must be greater than or equal to 0 and
               typically must be less than or equal to 59. An API may allow the
               value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of a day in 24 hour format. Must be greater than or equal
        to 0 and typically must be less than or equal to 23. An API may
        choose to allow the value "24:00:00" for scenarios like business
        closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of an hour. Must be greater than or equal to 0 and
        less than or equal to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds, in nanoseconds. Must be greater than or
        equal to 0 and less than or equal to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of a minute. Must be greater than or equal to 0 and
        typically must be less than or equal to 59. An API may allow the
        value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlHourlyArgsDict(TypedDict):
        periodicity: pulumi.Input[int]
        """
        Number of hours between runs. The interval must be greater than or
        equal to 1 hour and less than or equal to 48 hours.
        """
        minute_offset: NotRequired[pulumi.Input[int]]
        """
        The number of minutes after the hour (in UTC) to run the query.
        Must be greater than or equal to 0 minutes and less than or equal to
        59 minutes.  If left unspecified, then an arbitrary offset is used.
        """
elif False:
    AlertPolicyConditionConditionSqlHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlHourlyArgs:
    def __init__(__self__, *,
                 periodicity: pulumi.Input[int],
                 minute_offset: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] periodicity: Number of hours between runs. The interval must be greater than or
               equal to 1 hour and less than or equal to 48 hours.
        :param pulumi.Input[int] minute_offset: The number of minutes after the hour (in UTC) to run the query.
               Must be greater than or equal to 0 minutes and less than or equal to
               59 minutes.  If left unspecified, then an arbitrary offset is used.
        """
        pulumi.set(__self__, "periodicity", periodicity)
        if minute_offset is not None:
            pulumi.set(__self__, "minute_offset", minute_offset)

    @property
    @pulumi.getter
    def periodicity(self) -> pulumi.Input[int]:
        """
        Number of hours between runs. The interval must be greater than or
        equal to 1 hour and less than or equal to 48 hours.
        """
        return pulumi.get(self, "periodicity")

    @periodicity.setter
    def periodicity(self, value: pulumi.Input[int]):
        pulumi.set(self, "periodicity", value)

    @property
    @pulumi.getter(name="minuteOffset")
    def minute_offset(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes after the hour (in UTC) to run the query.
        Must be greater than or equal to 0 minutes and less than or equal to
        59 minutes.  If left unspecified, then an arbitrary offset is used.
        """
        return pulumi.get(self, "minute_offset")

    @minute_offset.setter
    def minute_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute_offset", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlMinutesArgsDict(TypedDict):
        periodicity: pulumi.Input[int]
        """
        Number of minutes between runs. The interval must be greater than or
        equal to 5 minutes and less than or equal to 1440 minutes.
        """
elif False:
    AlertPolicyConditionConditionSqlMinutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlMinutesArgs:
    def __init__(__self__, *,
                 periodicity: pulumi.Input[int]):
        """
        :param pulumi.Input[int] periodicity: Number of minutes between runs. The interval must be greater than or
               equal to 5 minutes and less than or equal to 1440 minutes.
        """
        pulumi.set(__self__, "periodicity", periodicity)

    @property
    @pulumi.getter
    def periodicity(self) -> pulumi.Input[int]:
        """
        Number of minutes between runs. The interval must be greater than or
        equal to 5 minutes and less than or equal to 1440 minutes.
        """
        return pulumi.get(self, "periodicity")

    @periodicity.setter
    def periodicity(self, value: pulumi.Input[int]):
        pulumi.set(self, "periodicity", value)


if not MYPY:
    class AlertPolicyConditionConditionSqlRowCountTestArgsDict(TypedDict):
        comparison: pulumi.Input[str]
        """
        The comparison to apply between the time
        series (indicated by filter and aggregation)
        and the threshold (indicated by
        threshold_value). The comparison is applied
        on each time series, with the time series on
        the left-hand side and the threshold on the
        right-hand side. Only COMPARISON_LT and
        COMPARISON_GT are supported currently.
        Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        """
        threshold: pulumi.Input[int]
        """
        The value against which to compare the row count.
        """
elif False:
    AlertPolicyConditionConditionSqlRowCountTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionSqlRowCountTestArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 threshold: pulumi.Input[int]):
        """
        :param pulumi.Input[str] comparison: The comparison to apply between the time
               series (indicated by filter and aggregation)
               and the threshold (indicated by
               threshold_value). The comparison is applied
               on each time series, with the time series on
               the left-hand side and the threshold on the
               right-hand side. Only COMPARISON_LT and
               COMPARISON_GT are supported currently.
               Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        :param pulumi.Input[int] threshold: The value against which to compare the row count.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        """
        The comparison to apply between the time
        series (indicated by filter and aggregation)
        and the threshold (indicated by
        threshold_value). The comparison is applied
        on each time series, with the time series on
        the left-hand side and the threshold on the
        right-hand side. Only COMPARISON_LT and
        COMPARISON_GT are supported currently.
        Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        """
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        """
        The value against which to compare the row count.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class AlertPolicyConditionConditionThresholdArgsDict(TypedDict):
        comparison: pulumi.Input[str]
        """
        The comparison to apply between the time
        series (indicated by filter and aggregation)
        and the threshold (indicated by
        threshold_value). The comparison is applied
        on each time series, with the time series on
        the left-hand side and the threshold on the
        right-hand side. Only COMPARISON_LT and
        COMPARISON_GT are supported currently.
        Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        """
        duration: pulumi.Input[str]
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        aggregations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgsDict']]]]
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.This field is similar to the
        one in the MetricService.ListTimeSeries
        request. It is advisable to use the
        ListTimeSeries method when debugging this
        field.
        Structure is documented below.
        """
        denominator_aggregations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgsDict']]]]
        """
        Specifies the alignment of data points in
        individual time series selected by
        denominatorFilter as well as how to combine
        the retrieved time series together (such as
        when aggregating multiple streams on each
        resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).When
        computing ratios, the aggregations and
        denominator_aggregations fields must use the
        same alignment period and produce time
        series that have the same periodicity and
        labels.This field is similar to the one in
        the MetricService.ListTimeSeries request. It
        is advisable to use the ListTimeSeries
        method when debugging this field.
        Structure is documented below.
        """
        denominator_filter: NotRequired[pulumi.Input[str]]
        """
        A filter that identifies a time series that
        should be used as the denominator of a ratio
        that will be compared with the threshold. If
        a denominator_filter is specified, the time
        series specified by the filter field will be
        used as the numerator.The filter is similar
        to the one that is specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        evaluation_missing_data: NotRequired[pulumi.Input[str]]
        """
        A condition control that determines how
        metric-threshold conditions are evaluated when
        data stops arriving.
        Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        """
        filter: NotRequired[pulumi.Input[str]]
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        forecast_options: NotRequired[pulumi.Input['AlertPolicyConditionConditionThresholdForecastOptionsArgsDict']]
        """
        When this field is present, the `MetricThreshold`
        condition forecasts whether the time series is
        predicted to violate the threshold within the
        `forecastHorizon`. When this field is not set, the
        `MetricThreshold` tests the current value of the
        timeseries against the threshold.
        Structure is documented below.
        """
        threshold_value: NotRequired[pulumi.Input[float]]
        """
        A value against which to compare the time
        series.
        """
        trigger: NotRequired[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgsDict']]
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
elif False:
    AlertPolicyConditionConditionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionThresholdArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input[str],
                 duration: pulumi.Input[str],
                 aggregations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]]] = None,
                 denominator_aggregations: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]]] = None,
                 denominator_filter: Optional[pulumi.Input[str]] = None,
                 evaluation_missing_data: Optional[pulumi.Input[str]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 forecast_options: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdForecastOptionsArgs']] = None,
                 threshold_value: Optional[pulumi.Input[float]] = None,
                 trigger: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs']] = None):
        """
        :param pulumi.Input[str] comparison: The comparison to apply between the time
               series (indicated by filter and aggregation)
               and the threshold (indicated by
               threshold_value). The comparison is applied
               on each time series, with the time series on
               the left-hand side and the threshold on the
               right-hand side. Only COMPARISON_LT and
               COMPARISON_GT are supported currently.
               Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        :param pulumi.Input[str] duration: The amount of time that a time series must
               violate the threshold to be considered
               failing. Currently, only values that are a
               multiple of a minute--e.g., 0, 60, 120, or
               300 seconds--are supported. If an invalid
               value is given, an error will be returned.
               When choosing a duration, it is useful to
               keep in mind the frequency of the underlying
               time series data (which may also be affected
               by any alignments specified in the
               aggregations field); a good duration is long
               enough so that a single outlier does not
               generate spurious alerts, but short enough
               that unhealthy states are detected and
               alerted on quickly.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]] aggregations: Specifies the alignment of data points in
               individual time series as well as how to
               combine the retrieved time series together
               (such as when aggregating multiple streams
               on each resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).
               Multiple aggregations are applied in the
               order specified.This field is similar to the
               one in the MetricService.ListTimeSeries
               request. It is advisable to use the
               ListTimeSeries method when debugging this
               field.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]] denominator_aggregations: Specifies the alignment of data points in
               individual time series selected by
               denominatorFilter as well as how to combine
               the retrieved time series together (such as
               when aggregating multiple streams on each
               resource to a single stream for each
               resource or when aggregating streams across
               all members of a group of resources).When
               computing ratios, the aggregations and
               denominator_aggregations fields must use the
               same alignment period and produce time
               series that have the same periodicity and
               labels.This field is similar to the one in
               the MetricService.ListTimeSeries request. It
               is advisable to use the ListTimeSeries
               method when debugging this field.
               Structure is documented below.
        :param pulumi.Input[str] denominator_filter: A filter that identifies a time series that
               should be used as the denominator of a ratio
               that will be compared with the threshold. If
               a denominator_filter is specified, the time
               series specified by the filter field will be
               used as the numerator.The filter is similar
               to the one that is specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input[str] evaluation_missing_data: A condition control that determines how
               metric-threshold conditions are evaluated when
               data stops arriving.
               Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        :param pulumi.Input[str] filter: A filter that identifies which time series
               should be compared with the threshold.The
               filter is similar to the one that is
               specified in the
               MetricService.ListTimeSeries request (that
               call is useful to verify the time series
               that will be retrieved / processed) and must
               specify the metric type and optionally may
               contain restrictions on resource type,
               resource labels, and metric labels. This
               field may not exceed 2048 Unicode characters
               in length.
        :param pulumi.Input['AlertPolicyConditionConditionThresholdForecastOptionsArgs'] forecast_options: When this field is present, the `MetricThreshold`
               condition forecasts whether the time series is
               predicted to violate the threshold within the
               `forecastHorizon`. When this field is not set, the
               `MetricThreshold` tests the current value of the
               timeseries against the threshold.
               Structure is documented below.
        :param pulumi.Input[float] threshold_value: A value against which to compare the time
               series.
        :param pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs'] trigger: The number/percent of time series for which
               the comparison must hold in order for the
               condition to trigger. If unspecified, then
               the condition will trigger if the comparison
               is true for any of the time series that have
               been identified by filter and aggregations,
               or by the ratio, if denominator_filter and
               denominator_aggregations are specified.
               Structure is documented below.
        """
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "duration", duration)
        if aggregations is not None:
            pulumi.set(__self__, "aggregations", aggregations)
        if denominator_aggregations is not None:
            pulumi.set(__self__, "denominator_aggregations", denominator_aggregations)
        if denominator_filter is not None:
            pulumi.set(__self__, "denominator_filter", denominator_filter)
        if evaluation_missing_data is not None:
            pulumi.set(__self__, "evaluation_missing_data", evaluation_missing_data)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if forecast_options is not None:
            pulumi.set(__self__, "forecast_options", forecast_options)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def comparison(self) -> pulumi.Input[str]:
        """
        The comparison to apply between the time
        series (indicated by filter and aggregation)
        and the threshold (indicated by
        threshold_value). The comparison is applied
        on each time series, with the time series on
        the left-hand side and the threshold on the
        right-hand side. Only COMPARISON_LT and
        COMPARISON_GT are supported currently.
        Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
        """
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison", value)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        The amount of time that a time series must
        violate the threshold to be considered
        failing. Currently, only values that are a
        multiple of a minute--e.g., 0, 60, 120, or
        300 seconds--are supported. If an invalid
        value is given, an error will be returned.
        When choosing a duration, it is useful to
        keep in mind the frequency of the underlying
        time series data (which may also be affected
        by any alignments specified in the
        aggregations field); a good duration is long
        enough so that a single outlier does not
        generate spurious alerts, but short enough
        that unhealthy states are detected and
        alerted on quickly.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def aggregations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]]]:
        """
        Specifies the alignment of data points in
        individual time series as well as how to
        combine the retrieved time series together
        (such as when aggregating multiple streams
        on each resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).
        Multiple aggregations are applied in the
        order specified.This field is similar to the
        one in the MetricService.ListTimeSeries
        request. It is advisable to use the
        ListTimeSeries method when debugging this
        field.
        Structure is documented below.
        """
        return pulumi.get(self, "aggregations")

    @aggregations.setter
    def aggregations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdAggregationArgs']]]]):
        pulumi.set(self, "aggregations", value)

    @property
    @pulumi.getter(name="denominatorAggregations")
    def denominator_aggregations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]]]:
        """
        Specifies the alignment of data points in
        individual time series selected by
        denominatorFilter as well as how to combine
        the retrieved time series together (such as
        when aggregating multiple streams on each
        resource to a single stream for each
        resource or when aggregating streams across
        all members of a group of resources).When
        computing ratios, the aggregations and
        denominator_aggregations fields must use the
        same alignment period and produce time
        series that have the same periodicity and
        labels.This field is similar to the one in
        the MetricService.ListTimeSeries request. It
        is advisable to use the ListTimeSeries
        method when debugging this field.
        Structure is documented below.
        """
        return pulumi.get(self, "denominator_aggregations")

    @denominator_aggregations.setter
    def denominator_aggregations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyConditionConditionThresholdDenominatorAggregationArgs']]]]):
        pulumi.set(self, "denominator_aggregations", value)

    @property
    @pulumi.getter(name="denominatorFilter")
    def denominator_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter that identifies a time series that
        should be used as the denominator of a ratio
        that will be compared with the threshold. If
        a denominator_filter is specified, the time
        series specified by the filter field will be
        used as the numerator.The filter is similar
        to the one that is specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        return pulumi.get(self, "denominator_filter")

    @denominator_filter.setter
    def denominator_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "denominator_filter", value)

    @property
    @pulumi.getter(name="evaluationMissingData")
    def evaluation_missing_data(self) -> Optional[pulumi.Input[str]]:
        """
        A condition control that determines how
        metric-threshold conditions are evaluated when
        data stops arriving.
        Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
        """
        return pulumi.get(self, "evaluation_missing_data")

    @evaluation_missing_data.setter
    def evaluation_missing_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_missing_data", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter that identifies which time series
        should be compared with the threshold.The
        filter is similar to the one that is
        specified in the
        MetricService.ListTimeSeries request (that
        call is useful to verify the time series
        that will be retrieved / processed) and must
        specify the metric type and optionally may
        contain restrictions on resource type,
        resource labels, and metric labels. This
        field may not exceed 2048 Unicode characters
        in length.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="forecastOptions")
    def forecast_options(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionThresholdForecastOptionsArgs']]:
        """
        When this field is present, the `MetricThreshold`
        condition forecasts whether the time series is
        predicted to violate the threshold within the
        `forecastHorizon`. When this field is not set, the
        `MetricThreshold` tests the current value of the
        timeseries against the threshold.
        Structure is documented below.
        """
        return pulumi.get(self, "forecast_options")

    @forecast_options.setter
    def forecast_options(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdForecastOptionsArgs']]):
        pulumi.set(self, "forecast_options", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[float]]:
        """
        A value against which to compare the time
        series.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs']]:
        """
        The number/percent of time series for which
        the comparison must hold in order for the
        condition to trigger. If unspecified, then
        the condition will trigger if the comparison
        is true for any of the time series that have
        been identified by filter and aggregations,
        or by the ratio, if denominator_filter and
        denominator_aggregations are specified.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['AlertPolicyConditionConditionThresholdTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class AlertPolicyConditionConditionThresholdAggregationArgsDict(TypedDict):
        alignment_period: NotRequired[pulumi.Input[str]]
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        cross_series_reducer: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        group_by_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        per_series_aligner: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
elif False:
    AlertPolicyConditionConditionThresholdAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionThresholdAggregationArgs:
    def __init__(__self__, *,
                 alignment_period: Optional[pulumi.Input[str]] = None,
                 cross_series_reducer: Optional[pulumi.Input[str]] = None,
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 per_series_aligner: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        if alignment_period is not None:
            pulumi.set(__self__, "alignment_period", alignment_period)
        if cross_series_reducer is not None:
            pulumi.set(__self__, "cross_series_reducer", cross_series_reducer)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if per_series_aligner is not None:
            pulumi.set(__self__, "per_series_aligner", per_series_aligner)

    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        return pulumi.get(self, "alignment_period")

    @alignment_period.setter
    def alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment_period", value)

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        return pulumi.get(self, "cross_series_reducer")

    @cross_series_reducer.setter
    def cross_series_reducer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_series_reducer", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        return pulumi.get(self, "per_series_aligner")

    @per_series_aligner.setter
    def per_series_aligner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_series_aligner", value)


if not MYPY:
    class AlertPolicyConditionConditionThresholdDenominatorAggregationArgsDict(TypedDict):
        alignment_period: NotRequired[pulumi.Input[str]]
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        cross_series_reducer: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        group_by_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        per_series_aligner: NotRequired[pulumi.Input[str]]
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
elif False:
    AlertPolicyConditionConditionThresholdDenominatorAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionThresholdDenominatorAggregationArgs:
    def __init__(__self__, *,
                 alignment_period: Optional[pulumi.Input[str]] = None,
                 cross_series_reducer: Optional[pulumi.Input[str]] = None,
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 per_series_aligner: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alignment_period: The alignment period for per-time
               series alignment. If present,
               alignmentPeriod must be at least
               60 seconds. After per-time series
               alignment, each time series will
               contain data points only on the
               period boundaries. If
               perSeriesAligner is not specified
               or equals ALIGN_NONE, then this
               field is ignored. If
               perSeriesAligner is specified and
               does not equal ALIGN_NONE, then
               this field must be defined;
               otherwise an error is returned.
        :param pulumi.Input[str] cross_series_reducer: The approach to be used to combine
               time series. Not all reducer
               functions may be applied to all
               time series, depending on the
               metric type and the value type of
               the original time series.
               Reduction may change the metric
               type of value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when
               crossSeriesReducer is specified.
               The groupByFields determine how
               the time series are partitioned
               into subsets prior to applying the
               aggregation function. Each subset
               contains time series that have the
               same value for each of the
               grouping fields. Each individual
               time series is a member of exactly
               one subset. The crossSeriesReducer
               is applied to each subset of time
               series. It is not possible to
               reduce across different resource
               types, so this field implicitly
               contains resource.type. Fields not
               specified in groupByFields are
               aggregated away. If groupByFields
               is not specified and all the time
               series have the same resource
               type, then the time series are
               aggregated into a single output
               time series. If crossSeriesReducer
               is not defined, this field is
               ignored.
        :param pulumi.Input[str] per_series_aligner: The approach to be used to align
               individual time series. Not all
               alignment functions may be applied
               to all time series, depending on
               the metric type and value type of
               the original time series.
               Alignment may change the metric
               type or the value type of the time
               series.Time series data must be
               aligned in order to perform cross-
               time series reduction. If
               crossSeriesReducer is specified,
               then perSeriesAligner must be
               specified and not equal ALIGN_NONE
               and alignmentPeriod must be
               specified; otherwise, an error is
               returned.
               Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        if alignment_period is not None:
            pulumi.set(__self__, "alignment_period", alignment_period)
        if cross_series_reducer is not None:
            pulumi.set(__self__, "cross_series_reducer", cross_series_reducer)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if per_series_aligner is not None:
            pulumi.set(__self__, "per_series_aligner", per_series_aligner)

    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment period for per-time
        series alignment. If present,
        alignmentPeriod must be at least
        60 seconds. After per-time series
        alignment, each time series will
        contain data points only on the
        period boundaries. If
        perSeriesAligner is not specified
        or equals ALIGN_NONE, then this
        field is ignored. If
        perSeriesAligner is specified and
        does not equal ALIGN_NONE, then
        this field must be defined;
        otherwise an error is returned.
        """
        return pulumi.get(self, "alignment_period")

    @alignment_period.setter
    def alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment_period", value)

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to combine
        time series. Not all reducer
        functions may be applied to all
        time series, depending on the
        metric type and the value type of
        the original time series.
        Reduction may change the metric
        type of value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
        """
        return pulumi.get(self, "cross_series_reducer")

    @cross_series_reducer.setter
    def cross_series_reducer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_series_reducer", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of fields to preserve when
        crossSeriesReducer is specified.
        The groupByFields determine how
        the time series are partitioned
        into subsets prior to applying the
        aggregation function. Each subset
        contains time series that have the
        same value for each of the
        grouping fields. Each individual
        time series is a member of exactly
        one subset. The crossSeriesReducer
        is applied to each subset of time
        series. It is not possible to
        reduce across different resource
        types, so this field implicitly
        contains resource.type. Fields not
        specified in groupByFields are
        aggregated away. If groupByFields
        is not specified and all the time
        series have the same resource
        type, then the time series are
        aggregated into a single output
        time series. If crossSeriesReducer
        is not defined, this field is
        ignored.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[pulumi.Input[str]]:
        """
        The approach to be used to align
        individual time series. Not all
        alignment functions may be applied
        to all time series, depending on
        the metric type and value type of
        the original time series.
        Alignment may change the metric
        type or the value type of the time
        series.Time series data must be
        aligned in order to perform cross-
        time series reduction. If
        crossSeriesReducer is specified,
        then perSeriesAligner must be
        specified and not equal ALIGN_NONE
        and alignmentPeriod must be
        specified; otherwise, an error is
        returned.
        Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
        """
        return pulumi.get(self, "per_series_aligner")

    @per_series_aligner.setter
    def per_series_aligner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_series_aligner", value)


if not MYPY:
    class AlertPolicyConditionConditionThresholdForecastOptionsArgsDict(TypedDict):
        forecast_horizon: pulumi.Input[str]
        """
        The length of time into the future to forecast
        whether a timeseries will violate the threshold.
        If the predicted value is found to violate the
        threshold, and the violation is observed in all
        forecasts made for the Configured `duration`,
        then the timeseries is considered to be failing.
        """
elif False:
    AlertPolicyConditionConditionThresholdForecastOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionThresholdForecastOptionsArgs:
    def __init__(__self__, *,
                 forecast_horizon: pulumi.Input[str]):
        """
        :param pulumi.Input[str] forecast_horizon: The length of time into the future to forecast
               whether a timeseries will violate the threshold.
               If the predicted value is found to violate the
               threshold, and the violation is observed in all
               forecasts made for the Configured `duration`,
               then the timeseries is considered to be failing.
        """
        pulumi.set(__self__, "forecast_horizon", forecast_horizon)

    @property
    @pulumi.getter(name="forecastHorizon")
    def forecast_horizon(self) -> pulumi.Input[str]:
        """
        The length of time into the future to forecast
        whether a timeseries will violate the threshold.
        If the predicted value is found to violate the
        threshold, and the violation is observed in all
        forecasts made for the Configured `duration`,
        then the timeseries is considered to be failing.
        """
        return pulumi.get(self, "forecast_horizon")

    @forecast_horizon.setter
    def forecast_horizon(self, value: pulumi.Input[str]):
        pulumi.set(self, "forecast_horizon", value)


if not MYPY:
    class AlertPolicyConditionConditionThresholdTriggerArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[int]]
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
elif False:
    AlertPolicyConditionConditionThresholdTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyConditionConditionThresholdTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] count: The absolute number of time series
               that must fail the predicate for the
               condition to be triggered.
        :param pulumi.Input[float] percent: The percentage of time series that
               must fail the predicate for the
               condition to be triggered.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The absolute number of time series
        that must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percentage of time series that
        must fail the predicate for the
        condition to be triggered.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AlertPolicyCreationRecordArgsDict(TypedDict):
        mutate_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        When the change occurred.
        """
        mutated_by: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The email address of the user making the change.
        """
elif False:
    AlertPolicyCreationRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyCreationRecordArgs:
    def __init__(__self__, *,
                 mutate_time: Optional[pulumi.Input[str]] = None,
                 mutated_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mutate_time: (Output)
               When the change occurred.
        :param pulumi.Input[str] mutated_by: (Output)
               The email address of the user making the change.
        """
        if mutate_time is not None:
            pulumi.set(__self__, "mutate_time", mutate_time)
        if mutated_by is not None:
            pulumi.set(__self__, "mutated_by", mutated_by)

    @property
    @pulumi.getter(name="mutateTime")
    def mutate_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        When the change occurred.
        """
        return pulumi.get(self, "mutate_time")

    @mutate_time.setter
    def mutate_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mutate_time", value)

    @property
    @pulumi.getter(name="mutatedBy")
    def mutated_by(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The email address of the user making the change.
        """
        return pulumi.get(self, "mutated_by")

    @mutated_by.setter
    def mutated_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mutated_by", value)


if not MYPY:
    class AlertPolicyDocumentationArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        """
        The text of the documentation, interpreted according to mimeType.
        The content may not exceed 8,192 Unicode characters and may not
        exceed more than 10,240 bytes when encoded in UTF-8 format,
        whichever is smaller.
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPolicyDocumentationLinkArgsDict']]]]
        """
        Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
        Structure is documented below.
        """
        mime_type: NotRequired[pulumi.Input[str]]
        """
        The format of the content field. Presently, only the value
        "text/markdown" is supported.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        The subject line of the notification. The subject line may not
        exceed 10,240 bytes. In notifications generated by this policy the contents
        of the subject line after variable expansion will be truncated to 255 bytes
        or shorter at the latest UTF-8 character boundary.
        """
elif False:
    AlertPolicyDocumentationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyDocumentationArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyDocumentationLinkArgs']]]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The text of the documentation, interpreted according to mimeType.
               The content may not exceed 8,192 Unicode characters and may not
               exceed more than 10,240 bytes when encoded in UTF-8 format,
               whichever is smaller.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPolicyDocumentationLinkArgs']]] links: Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
               Structure is documented below.
        :param pulumi.Input[str] mime_type: The format of the content field. Presently, only the value
               "text/markdown" is supported.
        :param pulumi.Input[str] subject: The subject line of the notification. The subject line may not
               exceed 10,240 bytes. In notifications generated by this policy the contents
               of the subject line after variable expansion will be truncated to 255 bytes
               or shorter at the latest UTF-8 character boundary.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        The text of the documentation, interpreted according to mimeType.
        The content may not exceed 8,192 Unicode characters and may not
        exceed more than 10,240 bytes when encoded in UTF-8 format,
        whichever is smaller.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyDocumentationLinkArgs']]]]:
        """
        Links to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
        Structure is documented below.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPolicyDocumentationLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the content field. Presently, only the value
        "text/markdown" is supported.
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mime_type", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        The subject line of the notification. The subject line may not
        exceed 10,240 bytes. In notifications generated by this policy the contents
        of the subject line after variable expansion will be truncated to 255 bytes
        or shorter at the latest UTF-8 character boundary.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class AlertPolicyDocumentationLinkArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
        """
elif False:
    AlertPolicyDocumentationLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPolicyDocumentationLinkArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
        :param pulumi.Input[str] url: The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class CustomServiceTelemetryArgsDict(TypedDict):
        resource_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the resource that defines this service.
        Formatted as described in
        https://cloud.google.com/apis/design/resource_names.
        """
elif False:
    CustomServiceTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomServiceTelemetryArgs:
    def __init__(__self__, *,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_name: The full name of the resource that defines this service.
               Formatted as described in
               https://cloud.google.com/apis/design/resource_names.
        """
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the resource that defines this service.
        Formatted as described in
        https://cloud.google.com/apis/design/resource_names.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


if not MYPY:
    class GenericServiceBasicServiceArgsDict(TypedDict):
        service_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels that specify the resource that emits the monitoring data
        which is used for SLO reporting of this `Service`.
        """
        service_type: NotRequired[pulumi.Input[str]]
        """
        The type of service that this basic service defines, e.g.
        APP_ENGINE service type
        """
elif False:
    GenericServiceBasicServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenericServiceBasicServiceArgs:
    def __init__(__self__, *,
                 service_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 service_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] service_labels: Labels that specify the resource that emits the monitoring data
               which is used for SLO reporting of this `Service`.
        :param pulumi.Input[str] service_type: The type of service that this basic service defines, e.g.
               APP_ENGINE service type
        """
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels that specify the resource that emits the monitoring data
        which is used for SLO reporting of this `Service`.
        """
        return pulumi.get(self, "service_labels")

    @service_labels.setter
    def service_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "service_labels", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of service that this basic service defines, e.g.
        APP_ENGINE service type
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)


if not MYPY:
    class GenericServiceTelemetryArgsDict(TypedDict):
        resource_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the resource that defines this service.
        Formatted as described in
        https://cloud.google.com/apis/design/resource_names.
        """
elif False:
    GenericServiceTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenericServiceTelemetryArgs:
    def __init__(__self__, *,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_name: The full name of the resource that defines this service.
               Formatted as described in
               https://cloud.google.com/apis/design/resource_names.
        """
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the resource that defines this service.
        Formatted as described in
        https://cloud.google.com/apis/design/resource_names.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


if not MYPY:
    class MetricDescriptorLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A human-readable description for the label.
        """
        value_type: NotRequired[pulumi.Input[str]]
        """
        The type of data that can be assigned to the label.
        Default value is `STRING`.
        Possible values are: `STRING`, `BOOL`, `INT64`.
        """
elif False:
    MetricDescriptorLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricDescriptorLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
        :param pulumi.Input[str] description: A human-readable description for the label.
        :param pulumi.Input[str] value_type: The type of data that can be assigned to the label.
               Default value is `STRING`.
               Possible values are: `STRING`, `BOOL`, `INT64`.
        """
        pulumi.set(__self__, "key", key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human-readable description for the label.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of data that can be assigned to the label.
        Default value is `STRING`.
        Possible values are: `STRING`, `BOOL`, `INT64`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class MetricDescriptorMetadataArgsDict(TypedDict):
        ingest_delay: NotRequired[pulumi.Input[str]]
        """
        The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        sample_period: NotRequired[pulumi.Input[str]]
        """
        The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
elif False:
    MetricDescriptorMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricDescriptorMetadataArgs:
    def __init__(__self__, *,
                 ingest_delay: Optional[pulumi.Input[str]] = None,
                 sample_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ingest_delay: The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        :param pulumi.Input[str] sample_period: The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        if ingest_delay is not None:
            pulumi.set(__self__, "ingest_delay", ingest_delay)
        if sample_period is not None:
            pulumi.set(__self__, "sample_period", sample_period)

    @property
    @pulumi.getter(name="ingestDelay")
    def ingest_delay(self) -> Optional[pulumi.Input[str]]:
        """
        The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        return pulumi.get(self, "ingest_delay")

    @ingest_delay.setter
    def ingest_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingest_delay", value)

    @property
    @pulumi.getter(name="samplePeriod")
    def sample_period(self) -> Optional[pulumi.Input[str]]:
        """
        The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
        """
        return pulumi.get(self, "sample_period")

    @sample_period.setter
    def sample_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sample_period", value)


if not MYPY:
    class NotificationChannelSensitiveLabelsArgsDict(TypedDict):
        auth_token: NotRequired[pulumi.Input[str]]
        """
        An authorization token for a notification channel. Channel types that support this field include: slack
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        An password for a notification channel. Channel types that support this field include: webhook_basicauth
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        service_key: NotRequired[pulumi.Input[str]]
        """
        An servicekey token for a notification channel. Channel types that support this field include: pagerduty
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    NotificationChannelSensitiveLabelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationChannelSensitiveLabelsArgs:
    def __init__(__self__, *,
                 auth_token: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 service_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_token: An authorization token for a notification channel. Channel types that support this field include: slack
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] password: An password for a notification channel. Channel types that support this field include: webhook_basicauth
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] service_key: An servicekey token for a notification channel. Channel types that support this field include: pagerduty
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[str]]:
        """
        An authorization token for a notification channel. Channel types that support this field include: slack
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        An password for a notification channel. Channel types that support this field include: webhook_basicauth
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[pulumi.Input[str]]:
        """
        An servicekey token for a notification channel. Channel types that support this field include: pagerduty
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "service_key")

    @service_key.setter
    def service_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_key", value)


if not MYPY:
    class SloBasicSliArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input['SloBasicSliAvailabilityArgsDict']]
        """
        Availability based SLI, dervied from count of requests made to this service that return successfully.
        Structure is documented below.
        """
        latency: NotRequired[pulumi.Input['SloBasicSliLatencyArgsDict']]
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
elif False:
    SloBasicSliArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloBasicSliArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input['SloBasicSliAvailabilityArgs']] = None,
                 latency: Optional[pulumi.Input['SloBasicSliLatencyArgs']] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['SloBasicSliAvailabilityArgs'] availability: Availability based SLI, dervied from count of requests made to this service that return successfully.
               Structure is documented below.
        :param pulumi.Input['SloBasicSliLatencyArgs'] latency: Parameters for a latency threshold SLI.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An optional set of locations to which this SLI is relevant.
               Telemetry from other locations will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               locations in which the Service has activity. For service types
               that don't support breaking down by location, setting this
               field will result in an error.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: An optional set of RPCs to which this SLI is relevant.
               Telemetry from other methods will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               the Service's methods. For service types that don't support
               breaking down by method, setting this field will result in an
               error.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: The set of API versions to which this SLI is relevant.
               Telemetry from other API versions will not be used to
               calculate performance for this SLI. If omitted,
               this SLI applies to all API versions. For service types
               that don't support breaking down by version, setting this
               field will result in an error.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input['SloBasicSliAvailabilityArgs']]:
        """
        Availability based SLI, dervied from count of requests made to this service that return successfully.
        Structure is documented below.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input['SloBasicSliAvailabilityArgs']]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input['SloBasicSliLatencyArgs']]:
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input['SloBasicSliLatencyArgs']]):
        pulumi.set(self, "latency", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class SloBasicSliAvailabilityArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
elif False:
    SloBasicSliAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloBasicSliAvailabilityArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SloBasicSliLatencyArgsDict(TypedDict):
        threshold: pulumi.Input[str]
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
elif False:
    SloBasicSliLatencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloBasicSliLatencyArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[str]):
        """
        :param pulumi.Input[str] threshold: A duration string, e.g. 10s.
               Good service is defined to be the count of requests made to
               this service that return in no more than threshold.
        """
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[str]:
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SloRequestBasedSliArgsDict(TypedDict):
        distribution_cut: NotRequired[pulumi.Input['SloRequestBasedSliDistributionCutArgsDict']]
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Exactly one of `distribution_cut` or `good_total_ratio` can be set.
        Structure is documented below.
        """
        good_total_ratio: NotRequired[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgsDict']]
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Exactly one of `distribution_cut` or `good_total_ratio` can be set.
        Structure is documented below.
        """
elif False:
    SloRequestBasedSliArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestBasedSliArgs:
    def __init__(__self__, *,
                 distribution_cut: Optional[pulumi.Input['SloRequestBasedSliDistributionCutArgs']] = None,
                 good_total_ratio: Optional[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs']] = None):
        """
        :param pulumi.Input['SloRequestBasedSliDistributionCutArgs'] distribution_cut: Used when good_service is defined by a count of values aggregated in a
               Distribution that fall into a good range. The total_service is the
               total count of all values aggregated in the Distribution.
               Defines a distribution TimeSeries filter and thresholds used for
               measuring good service and total service.
               Exactly one of `distribution_cut` or `good_total_ratio` can be set.
               Structure is documented below.
        :param pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs'] good_total_ratio: A means to compute a ratio of `good_service` to `total_service`.
               Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
               Must specify exactly two of good, bad, and total service filters.
               The relationship good_service + bad_service = total_service
               will be assumed.
               Exactly one of `distribution_cut` or `good_total_ratio` can be set.
               Structure is documented below.
        """
        if distribution_cut is not None:
            pulumi.set(__self__, "distribution_cut", distribution_cut)
        if good_total_ratio is not None:
            pulumi.set(__self__, "good_total_ratio", good_total_ratio)

    @property
    @pulumi.getter(name="distributionCut")
    def distribution_cut(self) -> Optional[pulumi.Input['SloRequestBasedSliDistributionCutArgs']]:
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Exactly one of `distribution_cut` or `good_total_ratio` can be set.
        Structure is documented below.
        """
        return pulumi.get(self, "distribution_cut")

    @distribution_cut.setter
    def distribution_cut(self, value: Optional[pulumi.Input['SloRequestBasedSliDistributionCutArgs']]):
        pulumi.set(self, "distribution_cut", value)

    @property
    @pulumi.getter(name="goodTotalRatio")
    def good_total_ratio(self) -> Optional[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs']]:
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Exactly one of `distribution_cut` or `good_total_ratio` can be set.
        Structure is documented below.
        """
        return pulumi.get(self, "good_total_ratio")

    @good_total_ratio.setter
    def good_total_ratio(self, value: Optional[pulumi.Input['SloRequestBasedSliGoodTotalRatioArgs']]):
        pulumi.set(self, "good_total_ratio", value)


if not MYPY:
    class SloRequestBasedSliDistributionCutArgsDict(TypedDict):
        distribution_filter: pulumi.Input[str]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        range: pulumi.Input['SloRequestBasedSliDistributionCutRangeArgsDict']
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max.
        Structure is documented below.
        """
elif False:
    SloRequestBasedSliDistributionCutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestBasedSliDistributionCutArgs:
    def __init__(__self__, *,
                 distribution_filter: pulumi.Input[str],
                 range: pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs']):
        """
        :param pulumi.Input[str] distribution_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               aggregating values to quantify the good service provided.
               Must have ValueType = DISTRIBUTION and
               MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x <= range.max. inclusive of min and
               max. Open ranges can be defined by setting
               just one of min or max.
               Structure is documented below.
        """
        pulumi.set(__self__, "distribution_filter", distribution_filter)
        pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter(name="distributionFilter")
    def distribution_filter(self) -> pulumi.Input[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "distribution_filter")

    @distribution_filter.setter
    def distribution_filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "distribution_filter", value)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs']:
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max.
        Structure is documented below.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input['SloRequestBasedSliDistributionCutRangeArgs']):
        pulumi.set(self, "range", value)


if not MYPY:
    class SloRequestBasedSliDistributionCutRangeArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[float]]
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        min: NotRequired[pulumi.Input[float]]
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
elif False:
    SloRequestBasedSliDistributionCutRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestBasedSliDistributionCutRangeArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SloRequestBasedSliGoodTotalRatioArgsDict(TypedDict):
        bad_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        good_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        total_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
elif False:
    SloRequestBasedSliGoodTotalRatioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestBasedSliGoodTotalRatioArgs:
    def __init__(__self__, *,
                 bad_service_filter: Optional[pulumi.Input[str]] = None,
                 good_service_filter: Optional[pulumi.Input[str]] = None,
                 total_service_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bad_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying bad service provided, either demanded service that
               was not provided or demanded service that was of inadequate
               quality. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] good_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying good service provided. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] total_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying total demanded service. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        if bad_service_filter is not None:
            pulumi.set(__self__, "bad_service_filter", bad_service_filter)
        if good_service_filter is not None:
            pulumi.set(__self__, "good_service_filter", good_service_filter)
        if total_service_filter is not None:
            pulumi.set(__self__, "total_service_filter", total_service_filter)

    @property
    @pulumi.getter(name="badServiceFilter")
    def bad_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "bad_service_filter")

    @bad_service_filter.setter
    def bad_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bad_service_filter", value)

    @property
    @pulumi.getter(name="goodServiceFilter")
    def good_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "good_service_filter")

    @good_service_filter.setter
    def good_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "good_service_filter", value)

    @property
    @pulumi.getter(name="totalServiceFilter")
    def total_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "total_service_filter")

    @total_service_filter.setter
    def total_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "total_service_filter", value)


if not MYPY:
    class SloWindowsBasedSliArgsDict(TypedDict):
        good_bad_metric_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        with ValueType = BOOL. The window is good if any true values
        appear in the window. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        """
        good_total_ratio_threshold: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgsDict']]
        """
        Criterion that describes a window as good if its performance is
        high enough. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        metric_mean_in_range: NotRequired[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgsDict']]
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *averaged* across returned streams.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Average value X of `time_series` should satisfy
        `range.min <= X <= range.max` for a good window.
        Structure is documented below.
        """
        metric_sum_in_range: NotRequired[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgsDict']]
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *summed* across returned streams.
        Summed value `X` of `time_series` should satisfy
        `range.min <= X <= range.max` for a good window.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        window_period: NotRequired[pulumi.Input[str]]
        """
        Duration over which window quality is evaluated, given as a
        duration string "{X}s" representing X seconds. Must be an
        integer fraction of a day and at least 60s.
        """
elif False:
    SloWindowsBasedSliArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliArgs:
    def __init__(__self__, *,
                 good_bad_metric_filter: Optional[pulumi.Input[str]] = None,
                 good_total_ratio_threshold: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs']] = None,
                 metric_mean_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs']] = None,
                 metric_sum_in_range: Optional[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs']] = None,
                 window_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] good_bad_metric_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               with ValueType = BOOL. The window is good if any true values
               appear in the window. One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs'] good_total_ratio_threshold: Criterion that describes a window as good if its performance is
               high enough. One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
               Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs'] metric_mean_in_range: Criterion that describes a window as good if the metric's value
               is in a good range, *averaged* across returned streams.
               One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
               Average value X of `time_series` should satisfy
               `range.min <= X <= range.max` for a good window.
               Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs'] metric_sum_in_range: Criterion that describes a window as good if the metric's value
               is in a good range, *summed* across returned streams.
               Summed value `X` of `time_series` should satisfy
               `range.min <= X <= range.max` for a good window.
               One of `good_bad_metric_filter`,
               `good_total_ratio_threshold`, `metric_mean_in_range`,
               `metric_sum_in_range` must be set for `windows_based_sli`.
               Structure is documented below.
        :param pulumi.Input[str] window_period: Duration over which window quality is evaluated, given as a
               duration string "{X}s" representing X seconds. Must be an
               integer fraction of a day and at least 60s.
        """
        if good_bad_metric_filter is not None:
            pulumi.set(__self__, "good_bad_metric_filter", good_bad_metric_filter)
        if good_total_ratio_threshold is not None:
            pulumi.set(__self__, "good_total_ratio_threshold", good_total_ratio_threshold)
        if metric_mean_in_range is not None:
            pulumi.set(__self__, "metric_mean_in_range", metric_mean_in_range)
        if metric_sum_in_range is not None:
            pulumi.set(__self__, "metric_sum_in_range", metric_sum_in_range)
        if window_period is not None:
            pulumi.set(__self__, "window_period", window_period)

    @property
    @pulumi.getter(name="goodBadMetricFilter")
    def good_bad_metric_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        with ValueType = BOOL. The window is good if any true values
        appear in the window. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        """
        return pulumi.get(self, "good_bad_metric_filter")

    @good_bad_metric_filter.setter
    def good_bad_metric_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "good_bad_metric_filter", value)

    @property
    @pulumi.getter(name="goodTotalRatioThreshold")
    def good_total_ratio_threshold(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs']]:
        """
        Criterion that describes a window as good if its performance is
        high enough. One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        return pulumi.get(self, "good_total_ratio_threshold")

    @good_total_ratio_threshold.setter
    def good_total_ratio_threshold(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdArgs']]):
        pulumi.set(self, "good_total_ratio_threshold", value)

    @property
    @pulumi.getter(name="metricMeanInRange")
    def metric_mean_in_range(self) -> Optional[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs']]:
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *averaged* across returned streams.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Average value X of `time_series` should satisfy
        `range.min <= X <= range.max` for a good window.
        Structure is documented below.
        """
        return pulumi.get(self, "metric_mean_in_range")

    @metric_mean_in_range.setter
    def metric_mean_in_range(self, value: Optional[pulumi.Input['SloWindowsBasedSliMetricMeanInRangeArgs']]):
        pulumi.set(self, "metric_mean_in_range", value)

    @property
    @pulumi.getter(name="metricSumInRange")
    def metric_sum_in_range(self) -> Optional[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs']]:
        """
        Criterion that describes a window as good if the metric's value
        is in a good range, *summed* across returned streams.
        Summed value `X` of `time_series` should satisfy
        `range.min <= X <= range.max` for a good window.
        One of `good_bad_metric_filter`,
        `good_total_ratio_threshold`, `metric_mean_in_range`,
        `metric_sum_in_range` must be set for `windows_based_sli`.
        Structure is documented below.
        """
        return pulumi.get(self, "metric_sum_in_range")

    @metric_sum_in_range.setter
    def metric_sum_in_range(self, value: Optional[pulumi.Input['SloWindowsBasedSliMetricSumInRangeArgs']]):
        pulumi.set(self, "metric_sum_in_range", value)

    @property
    @pulumi.getter(name="windowPeriod")
    def window_period(self) -> Optional[pulumi.Input[str]]:
        """
        Duration over which window quality is evaluated, given as a
        duration string "{X}s" representing X seconds. Must be an
        integer fraction of a day and at least 60s.
        """
        return pulumi.get(self, "window_period")

    @window_period.setter
    def window_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "window_period", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdArgsDict(TypedDict):
        basic_sli_performance: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgsDict']]
        """
        Basic SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        performance: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgsDict']]
        """
        Request-based SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        threshold: NotRequired[pulumi.Input[float]]
        """
        If window performance >= threshold, the window is counted
        as good.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdArgs:
    def __init__(__self__, *,
                 basic_sli_performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs']] = None,
                 performance: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs']] = None,
                 threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs'] basic_sli_performance: Basic SLI to evaluate to judge window quality.
               Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs'] performance: Request-based SLI to evaluate to judge window quality.
               Structure is documented below.
        :param pulumi.Input[float] threshold: If window performance >= threshold, the window is counted
               as good.
        """
        if basic_sli_performance is not None:
            pulumi.set(__self__, "basic_sli_performance", basic_sli_performance)
        if performance is not None:
            pulumi.set(__self__, "performance", performance)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="basicSliPerformance")
    def basic_sli_performance(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs']]:
        """
        Basic SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        return pulumi.get(self, "basic_sli_performance")

    @basic_sli_performance.setter
    def basic_sli_performance(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs']]):
        pulumi.set(self, "basic_sli_performance", value)

    @property
    @pulumi.getter
    def performance(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs']]:
        """
        Request-based SLI to evaluate to judge window quality.
        Structure is documented below.
        """
        return pulumi.get(self, "performance")

    @performance.setter
    def performance(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs']]):
        pulumi.set(self, "performance", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        If window performance >= threshold, the window is counted
        as good.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgsDict']]
        """
        Availability based SLI, dervied from count of requests made to this service that return successfully.
        Structure is documented below.
        """
        latency: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgsDict']]
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs']] = None,
                 latency: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs']] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs'] availability: Availability based SLI, dervied from count of requests made to this service that return successfully.
               Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs'] latency: Parameters for a latency threshold SLI.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: An optional set of locations to which this SLI is relevant.
               Telemetry from other locations will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               locations in which the Service has activity. For service types
               that don't support breaking down by location, setting this
               field will result in an error.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: An optional set of RPCs to which this SLI is relevant.
               Telemetry from other methods will not be used to calculate
               performance for this SLI. If omitted, this SLI applies to all
               the Service's methods. For service types that don't support
               breaking down by method, setting this field will result in an
               error.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: The set of API versions to which this SLI is relevant.
               Telemetry from other API versions will not be used to
               calculate performance for this SLI. If omitted,
               this SLI applies to all API versions. For service types
               that don't support breaking down by version, setting this
               field will result in an error.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs']]:
        """
        Availability based SLI, dervied from count of requests made to this service that return successfully.
        Structure is documented below.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs']]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs']]:
        """
        Parameters for a latency threshold SLI.
        Structure is documented below.
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs']]):
        pulumi.set(self, "latency", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of locations to which this SLI is relevant.
        Telemetry from other locations will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        locations in which the Service has activity. For service types
        that don't support breaking down by location, setting this
        field will result in an error.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An optional set of RPCs to which this SLI is relevant.
        Telemetry from other methods will not be used to calculate
        performance for this SLI. If omitted, this SLI applies to all
        the Service's methods. For service types that don't support
        breaking down by method, setting this field will result in an
        error.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of API versions to which this SLI is relevant.
        Telemetry from other API versions will not be used to
        calculate performance for this SLI. If omitted,
        this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this
        field will result in an error.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgsDict(TypedDict):
        threshold: pulumi.Input[str]
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[str]):
        """
        :param pulumi.Input[str] threshold: A duration string, e.g. 10s.
               Good service is defined to be the count of requests made to
               this service that return in no more than threshold.
        """
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[str]:
        """
        A duration string, e.g. 10s.
        Good service is defined to be the count of requests made to
        this service that return in no more than threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgsDict(TypedDict):
        distribution_cut: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgsDict']]
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Structure is documented below.
        """
        good_total_ratio: NotRequired[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgsDict']]
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Structure is documented below.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs:
    def __init__(__self__, *,
                 distribution_cut: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs']] = None,
                 good_total_ratio: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs']] = None):
        """
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs'] distribution_cut: Used when good_service is defined by a count of values aggregated in a
               Distribution that fall into a good range. The total_service is the
               total count of all values aggregated in the Distribution.
               Defines a distribution TimeSeries filter and thresholds used for
               measuring good service and total service.
               Structure is documented below.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs'] good_total_ratio: A means to compute a ratio of `good_service` to `total_service`.
               Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
               Must specify exactly two of good, bad, and total service filters.
               The relationship good_service + bad_service = total_service
               will be assumed.
               Structure is documented below.
        """
        if distribution_cut is not None:
            pulumi.set(__self__, "distribution_cut", distribution_cut)
        if good_total_ratio is not None:
            pulumi.set(__self__, "good_total_ratio", good_total_ratio)

    @property
    @pulumi.getter(name="distributionCut")
    def distribution_cut(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs']]:
        """
        Used when good_service is defined by a count of values aggregated in a
        Distribution that fall into a good range. The total_service is the
        total count of all values aggregated in the Distribution.
        Defines a distribution TimeSeries filter and thresholds used for
        measuring good service and total service.
        Structure is documented below.
        """
        return pulumi.get(self, "distribution_cut")

    @distribution_cut.setter
    def distribution_cut(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs']]):
        pulumi.set(self, "distribution_cut", value)

    @property
    @pulumi.getter(name="goodTotalRatio")
    def good_total_ratio(self) -> Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs']]:
        """
        A means to compute a ratio of `good_service` to `total_service`.
        Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
        Must specify exactly two of good, bad, and total service filters.
        The relationship good_service + bad_service = total_service
        will be assumed.
        Structure is documented below.
        """
        return pulumi.get(self, "good_total_ratio")

    @good_total_ratio.setter
    def good_total_ratio(self, value: Optional[pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs']]):
        pulumi.set(self, "good_total_ratio", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgsDict(TypedDict):
        distribution_filter: pulumi.Input[str]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        range: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgsDict']
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max.
        Structure is documented below.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs:
    def __init__(__self__, *,
                 distribution_filter: pulumi.Input[str],
                 range: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs']):
        """
        :param pulumi.Input[str] distribution_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               aggregating values to quantify the good service provided.
               Must have ValueType = DISTRIBUTION and
               MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x <= range.max. inclusive of min and
               max. Open ranges can be defined by setting
               just one of min or max.
               Structure is documented below.
        """
        pulumi.set(__self__, "distribution_filter", distribution_filter)
        pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter(name="distributionFilter")
    def distribution_filter(self) -> pulumi.Input[str]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        aggregating values to quantify the good service provided.
        Must have ValueType = DISTRIBUTION and
        MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "distribution_filter")

    @distribution_filter.setter
    def distribution_filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "distribution_filter", value)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs']:
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max.
        Structure is documented below.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input['SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs']):
        pulumi.set(self, "range", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[float]]
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        min: NotRequired[pulumi.Input[float]]
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgsDict(TypedDict):
        bad_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        good_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        total_service_filter: NotRequired[pulumi.Input[str]]
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
elif False:
    SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioArgs:
    def __init__(__self__, *,
                 bad_service_filter: Optional[pulumi.Input[str]] = None,
                 good_service_filter: Optional[pulumi.Input[str]] = None,
                 total_service_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bad_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying bad service provided, either demanded service that
               was not provided or demanded service that was of inadequate
               quality. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] good_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying good service provided. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        :param pulumi.Input[str] total_service_filter: A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               quantifying total demanded service. Exactly two of
               good, bad, or total service filter must be defined (where
               good + bad = total is assumed)
               Must have ValueType = DOUBLE or ValueType = INT64 and
               must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        if bad_service_filter is not None:
            pulumi.set(__self__, "bad_service_filter", bad_service_filter)
        if good_service_filter is not None:
            pulumi.set(__self__, "good_service_filter", good_service_filter)
        if total_service_filter is not None:
            pulumi.set(__self__, "total_service_filter", total_service_filter)

    @property
    @pulumi.getter(name="badServiceFilter")
    def bad_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying bad service provided, either demanded service that
        was not provided or demanded service that was of inadequate
        quality. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "bad_service_filter")

    @bad_service_filter.setter
    def bad_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bad_service_filter", value)

    @property
    @pulumi.getter(name="goodServiceFilter")
    def good_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying good service provided. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "good_service_filter")

    @good_service_filter.setter
    def good_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "good_service_filter", value)

    @property
    @pulumi.getter(name="totalServiceFilter")
    def total_service_filter(self) -> Optional[pulumi.Input[str]]:
        """
        A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        quantifying total demanded service. Exactly two of
        good, bad, or total service filter must be defined (where
        good + bad = total is assumed)
        Must have ValueType = DOUBLE or ValueType = INT64 and
        must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        """
        return pulumi.get(self, "total_service_filter")

    @total_service_filter.setter
    def total_service_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "total_service_filter", value)


if not MYPY:
    class SloWindowsBasedSliMetricMeanInRangeArgsDict(TypedDict):
        range: pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgsDict']
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max. Mean value `X` of `time_series`
        values should satisfy `range.min <= X <= range.max` for a
        good service.
        Structure is documented below.
        """
        time_series: pulumi.Input[str]
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        The provided TimeSeries must have ValueType = INT64 or
        ValueType = DOUBLE and MetricKind = GAUGE. Mean value `X`
        should satisfy `range.min <= X <= range.max`
        under good service.
        """
elif False:
    SloWindowsBasedSliMetricMeanInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliMetricMeanInRangeArgs:
    def __init__(__self__, *,
                 range: pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs'],
                 time_series: pulumi.Input[str]):
        """
        :param pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x <= range.max. inclusive of min and
               max. Open ranges can be defined by setting
               just one of min or max. Mean value `X` of `time_series`
               values should satisfy `range.min <= X <= range.max` for a
               good service.
               Structure is documented below.
        :param pulumi.Input[str] time_series: A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               specifying the TimeSeries to use for evaluating window
               The provided TimeSeries must have ValueType = INT64 or
               ValueType = DOUBLE and MetricKind = GAUGE. Mean value `X`
               should satisfy `range.min <= X <= range.max`
               under good service.
        """
        pulumi.set(__self__, "range", range)
        pulumi.set(__self__, "time_series", time_series)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs']:
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max. Mean value `X` of `time_series`
        values should satisfy `range.min <= X <= range.max` for a
        good service.
        Structure is documented below.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input['SloWindowsBasedSliMetricMeanInRangeRangeArgs']):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> pulumi.Input[str]:
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        The provided TimeSeries must have ValueType = INT64 or
        ValueType = DOUBLE and MetricKind = GAUGE. Mean value `X`
        should satisfy `range.min <= X <= range.max`
        under good service.
        """
        return pulumi.get(self, "time_series")

    @time_series.setter
    def time_series(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_series", value)


if not MYPY:
    class SloWindowsBasedSliMetricMeanInRangeRangeArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[float]]
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        min: NotRequired[pulumi.Input[float]]
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
elif False:
    SloWindowsBasedSliMetricMeanInRangeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliMetricMeanInRangeRangeArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SloWindowsBasedSliMetricSumInRangeArgsDict(TypedDict):
        range: pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgsDict']
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X <= range.max` for a good window.
        Structure is documented below.
        """
        time_series: pulumi.Input[str]
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        quality. The provided TimeSeries must have
        ValueType = INT64 or ValueType = DOUBLE and
        MetricKind = GAUGE.
        Summed value `X` should satisfy
        `range.min <= X <= range.max` for a good window.
        """
elif False:
    SloWindowsBasedSliMetricSumInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliMetricSumInRangeArgs:
    def __init__(__self__, *,
                 range: pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs'],
                 time_series: pulumi.Input[str]):
        """
        :param pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs'] range: Range of numerical values. The computed good_service
               will be the count of values x in the Distribution such
               that range.min <= x <= range.max. inclusive of min and
               max. Open ranges can be defined by setting
               just one of min or max. Summed value `X` should satisfy
               `range.min <= X <= range.max` for a good window.
               Structure is documented below.
        :param pulumi.Input[str] time_series: A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
               specifying the TimeSeries to use for evaluating window
               quality. The provided TimeSeries must have
               ValueType = INT64 or ValueType = DOUBLE and
               MetricKind = GAUGE.
               Summed value `X` should satisfy
               `range.min <= X <= range.max` for a good window.
        """
        pulumi.set(__self__, "range", range)
        pulumi.set(__self__, "time_series", time_series)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs']:
        """
        Range of numerical values. The computed good_service
        will be the count of values x in the Distribution such
        that range.min <= x <= range.max. inclusive of min and
        max. Open ranges can be defined by setting
        just one of min or max. Summed value `X` should satisfy
        `range.min <= X <= range.max` for a good window.
        Structure is documented below.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input['SloWindowsBasedSliMetricSumInRangeRangeArgs']):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> pulumi.Input[str]:
        """
        A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the TimeSeries to use for evaluating window
        quality. The provided TimeSeries must have
        ValueType = INT64 or ValueType = DOUBLE and
        MetricKind = GAUGE.
        Summed value `X` should satisfy
        `range.min <= X <= range.max` for a good window.
        """
        return pulumi.get(self, "time_series")

    @time_series.setter
    def time_series(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_series", value)


if not MYPY:
    class SloWindowsBasedSliMetricSumInRangeRangeArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[float]]
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        min: NotRequired[pulumi.Input[float]]
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
elif False:
    SloWindowsBasedSliMetricSumInRangeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloWindowsBasedSliMetricSumInRangeRangeArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max: max value for the range (inclusive). If not given,
               will be set to "infinity", defining an open range
               ">= range.min"
        :param pulumi.Input[float] min: Min value for the range (inclusive). If not given,
               will be set to "-infinity", defining an open range
               "< range.max"
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        """
        max value for the range (inclusive). If not given,
        will be set to "infinity", defining an open range
        ">= range.min"
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        """
        Min value for the range (inclusive). If not given,
        will be set to "-infinity", defining an open range
        "< range.max"
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class UptimeCheckConfigContentMatcherArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        String or regex content to match (max 1024 bytes)
        """
        json_path_matcher: NotRequired[pulumi.Input['UptimeCheckConfigContentMatcherJsonPathMatcherArgsDict']]
        """
        Information needed to perform a JSONPath content match. Used for `ContentMatcherOption::MATCHES_JSON_PATH` and `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
        Structure is documented below.
        """
        matcher: NotRequired[pulumi.Input[str]]
        """
        The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
        Default value is `CONTAINS_STRING`.
        Possible values are: `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, `NOT_MATCHES_REGEX`, `MATCHES_JSON_PATH`, `NOT_MATCHES_JSON_PATH`.
        """
elif False:
    UptimeCheckConfigContentMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigContentMatcherArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 json_path_matcher: Optional[pulumi.Input['UptimeCheckConfigContentMatcherJsonPathMatcherArgs']] = None,
                 matcher: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: String or regex content to match (max 1024 bytes)
        :param pulumi.Input['UptimeCheckConfigContentMatcherJsonPathMatcherArgs'] json_path_matcher: Information needed to perform a JSONPath content match. Used for `ContentMatcherOption::MATCHES_JSON_PATH` and `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
               Structure is documented below.
        :param pulumi.Input[str] matcher: The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
               Default value is `CONTAINS_STRING`.
               Possible values are: `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, `NOT_MATCHES_REGEX`, `MATCHES_JSON_PATH`, `NOT_MATCHES_JSON_PATH`.
        """
        pulumi.set(__self__, "content", content)
        if json_path_matcher is not None:
            pulumi.set(__self__, "json_path_matcher", json_path_matcher)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        String or regex content to match (max 1024 bytes)
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="jsonPathMatcher")
    def json_path_matcher(self) -> Optional[pulumi.Input['UptimeCheckConfigContentMatcherJsonPathMatcherArgs']]:
        """
        Information needed to perform a JSONPath content match. Used for `ContentMatcherOption::MATCHES_JSON_PATH` and `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
        Structure is documented below.
        """
        return pulumi.get(self, "json_path_matcher")

    @json_path_matcher.setter
    def json_path_matcher(self, value: Optional[pulumi.Input['UptimeCheckConfigContentMatcherJsonPathMatcherArgs']]):
        pulumi.set(self, "json_path_matcher", value)

    @property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input[str]]:
        """
        The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
        Default value is `CONTAINS_STRING`.
        Possible values are: `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, `NOT_MATCHES_REGEX`, `MATCHES_JSON_PATH`, `NOT_MATCHES_JSON_PATH`.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "matcher", value)


if not MYPY:
    class UptimeCheckConfigContentMatcherJsonPathMatcherArgsDict(TypedDict):
        json_path: pulumi.Input[str]
        """
        JSONPath within the response output pointing to the expected `ContentMatcher::content` to match against.
        """
        json_matcher: NotRequired[pulumi.Input[str]]
        """
        Options to perform JSONPath content matching.
        Default value is `EXACT_MATCH`.
        Possible values are: `EXACT_MATCH`, `REGEX_MATCH`.
        """
elif False:
    UptimeCheckConfigContentMatcherJsonPathMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigContentMatcherJsonPathMatcherArgs:
    def __init__(__self__, *,
                 json_path: pulumi.Input[str],
                 json_matcher: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] json_path: JSONPath within the response output pointing to the expected `ContentMatcher::content` to match against.
        :param pulumi.Input[str] json_matcher: Options to perform JSONPath content matching.
               Default value is `EXACT_MATCH`.
               Possible values are: `EXACT_MATCH`, `REGEX_MATCH`.
        """
        pulumi.set(__self__, "json_path", json_path)
        if json_matcher is not None:
            pulumi.set(__self__, "json_matcher", json_matcher)

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> pulumi.Input[str]:
        """
        JSONPath within the response output pointing to the expected `ContentMatcher::content` to match against.
        """
        return pulumi.get(self, "json_path")

    @json_path.setter
    def json_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "json_path", value)

    @property
    @pulumi.getter(name="jsonMatcher")
    def json_matcher(self) -> Optional[pulumi.Input[str]]:
        """
        Options to perform JSONPath content matching.
        Default value is `EXACT_MATCH`.
        Possible values are: `EXACT_MATCH`, `REGEX_MATCH`.
        """
        return pulumi.get(self, "json_matcher")

    @json_matcher.setter
    def json_matcher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_matcher", value)


if not MYPY:
    class UptimeCheckConfigHttpCheckArgsDict(TypedDict):
        accepted_response_status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgsDict']]]]
        """
        If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
        Structure is documented below.
        """
        auth_info: NotRequired[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgsDict']]
        """
        The authentication information using username and password. Optional when creating an HTTP check; defaults to empty. Do not use with other authentication fields.
        Structure is documented below.
        """
        body: NotRequired[pulumi.Input[str]]
        """
        The request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. `foo=bar` in URL-encoded form is `foo%3Dbar` and in base64 encoding is `Zm9vJTI1M0RiYXI=`.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type to use for the check.
        Possible values are: `TYPE_UNSPECIFIED`, `URL_ENCODED`, `USER_PROVIDED`.
        """
        custom_content_type: NotRequired[pulumi.Input[str]]
        """
        A user provided content type header to use for the check. The invalid configurations outlined in the `content_type` field apply to custom_content_type`, as well as the following 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set. 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not set.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described in [RFC 2616 (page 31)](https://www.w3.org/Protocols/rfc2616/rfc2616.txt). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
        """
        mask_headers: NotRequired[pulumi.Input[bool]]
        """
        Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with `/`, a `/` will be prepended automatically. Optional (defaults to `/`).
        """
        ping_config: NotRequired[pulumi.Input['UptimeCheckConfigHttpCheckPingConfigArgsDict']]
        """
        Contains information needed to add pings to an HTTP check.
        Structure is documented below.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to the page to run the check against. Will be combined with `host` (specified within the `monitored_resource`) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
        """
        request_method: NotRequired[pulumi.Input[str]]
        """
        The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
        Default value is `GET`.
        Possible values are: `METHOD_UNSPECIFIED`, `GET`, `POST`.
        """
        service_agent_authentication: NotRequired[pulumi.Input['UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgsDict']]
        """
        The authentication information using the Monitoring Service Agent. Optional when creating an HTTPS check; defaults to empty. Do not use with other authentication fields.
        Structure is documented below.
        """
        use_ssl: NotRequired[pulumi.Input[bool]]
        """
        If true, use HTTPS instead of HTTP to run the check.
        """
        validate_ssl: NotRequired[pulumi.Input[bool]]
        """
        Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.
        """
elif False:
    UptimeCheckConfigHttpCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigHttpCheckArgs:
    def __init__(__self__, *,
                 accepted_response_status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs']]]] = None,
                 auth_info: Optional[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs']] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 custom_content_type: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mask_headers: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 ping_config: Optional[pulumi.Input['UptimeCheckConfigHttpCheckPingConfigArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 request_method: Optional[pulumi.Input[str]] = None,
                 service_agent_authentication: Optional[pulumi.Input['UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs']] = None,
                 use_ssl: Optional[pulumi.Input[bool]] = None,
                 validate_ssl: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs']]] accepted_response_status_codes: If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
               Structure is documented below.
        :param pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs'] auth_info: The authentication information using username and password. Optional when creating an HTTP check; defaults to empty. Do not use with other authentication fields.
               Structure is documented below.
        :param pulumi.Input[str] body: The request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. `foo=bar` in URL-encoded form is `foo%3Dbar` and in base64 encoding is `Zm9vJTI1M0RiYXI=`.
        :param pulumi.Input[str] content_type: The content type to use for the check.
               Possible values are: `TYPE_UNSPECIFIED`, `URL_ENCODED`, `USER_PROVIDED`.
        :param pulumi.Input[str] custom_content_type: A user provided content type header to use for the check. The invalid configurations outlined in the `content_type` field apply to custom_content_type`, as well as the following 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set. 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not set.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described in [RFC 2616 (page 31)](https://www.w3.org/Protocols/rfc2616/rfc2616.txt). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
        :param pulumi.Input[bool] mask_headers: Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******`.
        :param pulumi.Input[str] path: The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with `/`, a `/` will be prepended automatically. Optional (defaults to `/`).
        :param pulumi.Input['UptimeCheckConfigHttpCheckPingConfigArgs'] ping_config: Contains information needed to add pings to an HTTP check.
               Structure is documented below.
        :param pulumi.Input[int] port: The port to the page to run the check against. Will be combined with `host` (specified within the `monitored_resource`) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
        :param pulumi.Input[str] request_method: The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
               Default value is `GET`.
               Possible values are: `METHOD_UNSPECIFIED`, `GET`, `POST`.
        :param pulumi.Input['UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs'] service_agent_authentication: The authentication information using the Monitoring Service Agent. Optional when creating an HTTPS check; defaults to empty. Do not use with other authentication fields.
               Structure is documented below.
        :param pulumi.Input[bool] use_ssl: If true, use HTTPS instead of HTTP to run the check.
        :param pulumi.Input[bool] validate_ssl: Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.
        """
        if accepted_response_status_codes is not None:
            pulumi.set(__self__, "accepted_response_status_codes", accepted_response_status_codes)
        if auth_info is not None:
            pulumi.set(__self__, "auth_info", auth_info)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_content_type is not None:
            pulumi.set(__self__, "custom_content_type", custom_content_type)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if mask_headers is not None:
            pulumi.set(__self__, "mask_headers", mask_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if ping_config is not None:
            pulumi.set(__self__, "ping_config", ping_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if service_agent_authentication is not None:
            pulumi.set(__self__, "service_agent_authentication", service_agent_authentication)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)
        if validate_ssl is not None:
            pulumi.set(__self__, "validate_ssl", validate_ssl)

    @property
    @pulumi.getter(name="acceptedResponseStatusCodes")
    def accepted_response_status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs']]]]:
        """
        If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
        Structure is documented below.
        """
        return pulumi.get(self, "accepted_response_status_codes")

    @accepted_response_status_codes.setter
    def accepted_response_status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs']]]]):
        pulumi.set(self, "accepted_response_status_codes", value)

    @property
    @pulumi.getter(name="authInfo")
    def auth_info(self) -> Optional[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs']]:
        """
        The authentication information using username and password. Optional when creating an HTTP check; defaults to empty. Do not use with other authentication fields.
        Structure is documented below.
        """
        return pulumi.get(self, "auth_info")

    @auth_info.setter
    def auth_info(self, value: Optional[pulumi.Input['UptimeCheckConfigHttpCheckAuthInfoArgs']]):
        pulumi.set(self, "auth_info", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. `foo=bar` in URL-encoded form is `foo%3Dbar` and in base64 encoding is `Zm9vJTI1M0RiYXI=`.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type to use for the check.
        Possible values are: `TYPE_UNSPECIFIED`, `URL_ENCODED`, `USER_PROVIDED`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="customContentType")
    def custom_content_type(self) -> Optional[pulumi.Input[str]]:
        """
        A user provided content type header to use for the check. The invalid configurations outlined in the `content_type` field apply to custom_content_type`, as well as the following 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set. 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not set.
        """
        return pulumi.get(self, "custom_content_type")

    @custom_content_type.setter
    def custom_content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_content_type", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described in [RFC 2616 (page 31)](https://www.w3.org/Protocols/rfc2616/rfc2616.txt). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="maskHeaders")
    def mask_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******`.
        """
        return pulumi.get(self, "mask_headers")

    @mask_headers.setter
    def mask_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mask_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with `/`, a `/` will be prepended automatically. Optional (defaults to `/`).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="pingConfig")
    def ping_config(self) -> Optional[pulumi.Input['UptimeCheckConfigHttpCheckPingConfigArgs']]:
        """
        Contains information needed to add pings to an HTTP check.
        Structure is documented below.
        """
        return pulumi.get(self, "ping_config")

    @ping_config.setter
    def ping_config(self, value: Optional[pulumi.Input['UptimeCheckConfigHttpCheckPingConfigArgs']]):
        pulumi.set(self, "ping_config", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to the page to run the check against. Will be combined with `host` (specified within the `monitored_resource`) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
        Default value is `GET`.
        Possible values are: `METHOD_UNSPECIFIED`, `GET`, `POST`.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="serviceAgentAuthentication")
    def service_agent_authentication(self) -> Optional[pulumi.Input['UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs']]:
        """
        The authentication information using the Monitoring Service Agent. Optional when creating an HTTPS check; defaults to empty. Do not use with other authentication fields.
        Structure is documented below.
        """
        return pulumi.get(self, "service_agent_authentication")

    @service_agent_authentication.setter
    def service_agent_authentication(self, value: Optional[pulumi.Input['UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs']]):
        pulumi.set(self, "service_agent_authentication", value)

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, use HTTPS instead of HTTP to run the check.
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ssl", value)

    @property
    @pulumi.getter(name="validateSsl")
    def validate_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.
        """
        return pulumi.get(self, "validate_ssl")

    @validate_ssl.setter
    def validate_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_ssl", value)


if not MYPY:
    class UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgsDict(TypedDict):
        status_class: NotRequired[pulumi.Input[str]]
        """
        A class of status codes to accept.
        Possible values are: `STATUS_CLASS_1XX`, `STATUS_CLASS_2XX`, `STATUS_CLASS_3XX`, `STATUS_CLASS_4XX`, `STATUS_CLASS_5XX`, `STATUS_CLASS_ANY`.
        """
        status_value: NotRequired[pulumi.Input[int]]
        """
        A status code to accept.
        """
elif False:
    UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs:
    def __init__(__self__, *,
                 status_class: Optional[pulumi.Input[str]] = None,
                 status_value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] status_class: A class of status codes to accept.
               Possible values are: `STATUS_CLASS_1XX`, `STATUS_CLASS_2XX`, `STATUS_CLASS_3XX`, `STATUS_CLASS_4XX`, `STATUS_CLASS_5XX`, `STATUS_CLASS_ANY`.
        :param pulumi.Input[int] status_value: A status code to accept.
        """
        if status_class is not None:
            pulumi.set(__self__, "status_class", status_class)
        if status_value is not None:
            pulumi.set(__self__, "status_value", status_value)

    @property
    @pulumi.getter(name="statusClass")
    def status_class(self) -> Optional[pulumi.Input[str]]:
        """
        A class of status codes to accept.
        Possible values are: `STATUS_CLASS_1XX`, `STATUS_CLASS_2XX`, `STATUS_CLASS_3XX`, `STATUS_CLASS_4XX`, `STATUS_CLASS_5XX`, `STATUS_CLASS_ANY`.
        """
        return pulumi.get(self, "status_class")

    @status_class.setter
    def status_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_class", value)

    @property
    @pulumi.getter(name="statusValue")
    def status_value(self) -> Optional[pulumi.Input[int]]:
        """
        A status code to accept.
        """
        return pulumi.get(self, "status_value")

    @status_value.setter
    def status_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_value", value)


if not MYPY:
    class UptimeCheckConfigHttpCheckAuthInfoArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The password to authenticate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        The username to authenticate.
        """
elif False:
    UptimeCheckConfigHttpCheckAuthInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigHttpCheckAuthInfoArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password to authenticate.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: The username to authenticate.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password to authenticate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username to authenticate.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class UptimeCheckConfigHttpCheckPingConfigArgsDict(TypedDict):
        pings_count: pulumi.Input[int]
        """
        Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
elif False:
    UptimeCheckConfigHttpCheckPingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigHttpCheckPingConfigArgs:
    def __init__(__self__, *,
                 pings_count: pulumi.Input[int]):
        """
        :param pulumi.Input[int] pings_count: Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
        pulumi.set(__self__, "pings_count", pings_count)

    @property
    @pulumi.getter(name="pingsCount")
    def pings_count(self) -> pulumi.Input[int]:
        """
        Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
        return pulumi.get(self, "pings_count")

    @pings_count.setter
    def pings_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "pings_count", value)


if not MYPY:
    class UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of authentication to use.
        Possible values are: `SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED`, `OIDC_TOKEN`.
        """
elif False:
    UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of authentication to use.
               Possible values are: `SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED`, `OIDC_TOKEN`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of authentication to use.
        Possible values are: `SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED`, `OIDC_TOKEN`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UptimeCheckConfigMonitoredResourceArgsDict(TypedDict):
        labels: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels `project_id`, `instance_id`, and `zone`.
        """
        type: pulumi.Input[str]
        """
        The monitored resource type. This field must match the type field of a [`MonitoredResourceDescriptor`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is `gce_instance`. For a list of types, see [Monitoring resource types](https://cloud.google.com/monitoring/api/resources) and [Logging resource types](https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
elif False:
    UptimeCheckConfigMonitoredResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigMonitoredResourceArgs:
    def __init__(__self__, *,
                 labels: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels `project_id`, `instance_id`, and `zone`.
        :param pulumi.Input[str] type: The monitored resource type. This field must match the type field of a [`MonitoredResourceDescriptor`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is `gce_instance`. For a list of types, see [Monitoring resource types](https://cloud.google.com/monitoring/api/resources) and [Logging resource types](https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels `project_id`, `instance_id`, and `zone`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The monitored resource type. This field must match the type field of a [`MonitoredResourceDescriptor`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is `gce_instance`. For a list of types, see [Monitoring resource types](https://cloud.google.com/monitoring/api/resources) and [Logging resource types](https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UptimeCheckConfigResourceGroupArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[str]]
        """
        The group of resources being monitored. Should be the `name` of a group
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        The resource type of the group members.
        Possible values are: `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, `AWS_ELB_LOAD_BALANCER`.
        """
elif False:
    UptimeCheckConfigResourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigResourceGroupArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group_id: The group of resources being monitored. Should be the `name` of a group
        :param pulumi.Input[str] resource_type: The resource type of the group members.
               Possible values are: `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, `AWS_ELB_LOAD_BALANCER`.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The group of resources being monitored. Should be the `name` of a group
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The resource type of the group members.
        Possible values are: `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, `AWS_ELB_LOAD_BALANCER`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class UptimeCheckConfigSyntheticMonitorArgsDict(TypedDict):
        cloud_function_v2: pulumi.Input['UptimeCheckConfigSyntheticMonitorCloudFunctionV2ArgsDict']
        """
        Target a Synthetic Monitor GCFv2 Instance
        Structure is documented below.


        <a name="nested_synthetic_monitor_cloud_function_v2"></a>The `cloud_function_v2` block supports:
        """
elif False:
    UptimeCheckConfigSyntheticMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigSyntheticMonitorArgs:
    def __init__(__self__, *,
                 cloud_function_v2: pulumi.Input['UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args']):
        """
        :param pulumi.Input['UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args'] cloud_function_v2: Target a Synthetic Monitor GCFv2 Instance
               Structure is documented below.
               
               
               <a name="nested_synthetic_monitor_cloud_function_v2"></a>The `cloud_function_v2` block supports:
        """
        pulumi.set(__self__, "cloud_function_v2", cloud_function_v2)

    @property
    @pulumi.getter(name="cloudFunctionV2")
    def cloud_function_v2(self) -> pulumi.Input['UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args']:
        """
        Target a Synthetic Monitor GCFv2 Instance
        Structure is documented below.


        <a name="nested_synthetic_monitor_cloud_function_v2"></a>The `cloud_function_v2` block supports:
        """
        return pulumi.get(self, "cloud_function_v2")

    @cloud_function_v2.setter
    def cloud_function_v2(self, value: pulumi.Input['UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args']):
        pulumi.set(self, "cloud_function_v2", value)


if not MYPY:
    class UptimeCheckConfigSyntheticMonitorCloudFunctionV2ArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
        """
elif False:
    UptimeCheckConfigSyntheticMonitorCloudFunctionV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UptimeCheckConfigTcpCheckArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port to the page to run the check against. Will be combined with host (specified within the `monitored_resource`) to construct the full URL.
        """
        ping_config: NotRequired[pulumi.Input['UptimeCheckConfigTcpCheckPingConfigArgsDict']]
        """
        Contains information needed to add pings to a TCP check.
        Structure is documented below.
        """
elif False:
    UptimeCheckConfigTcpCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigTcpCheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 ping_config: Optional[pulumi.Input['UptimeCheckConfigTcpCheckPingConfigArgs']] = None):
        """
        :param pulumi.Input[int] port: The port to the page to run the check against. Will be combined with host (specified within the `monitored_resource`) to construct the full URL.
        :param pulumi.Input['UptimeCheckConfigTcpCheckPingConfigArgs'] ping_config: Contains information needed to add pings to a TCP check.
               Structure is documented below.
        """
        pulumi.set(__self__, "port", port)
        if ping_config is not None:
            pulumi.set(__self__, "ping_config", ping_config)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port to the page to run the check against. Will be combined with host (specified within the `monitored_resource`) to construct the full URL.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="pingConfig")
    def ping_config(self) -> Optional[pulumi.Input['UptimeCheckConfigTcpCheckPingConfigArgs']]:
        """
        Contains information needed to add pings to a TCP check.
        Structure is documented below.
        """
        return pulumi.get(self, "ping_config")

    @ping_config.setter
    def ping_config(self, value: Optional[pulumi.Input['UptimeCheckConfigTcpCheckPingConfigArgs']]):
        pulumi.set(self, "ping_config", value)


if not MYPY:
    class UptimeCheckConfigTcpCheckPingConfigArgsDict(TypedDict):
        pings_count: pulumi.Input[int]
        """
        Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
elif False:
    UptimeCheckConfigTcpCheckPingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckConfigTcpCheckPingConfigArgs:
    def __init__(__self__, *,
                 pings_count: pulumi.Input[int]):
        """
        :param pulumi.Input[int] pings_count: Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
        pulumi.set(__self__, "pings_count", pings_count)

    @property
    @pulumi.getter(name="pingsCount")
    def pings_count(self) -> pulumi.Input[int]:
        """
        Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
        """
        return pulumi.get(self, "pings_count")

    @pings_count.setter
    def pings_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "pings_count", value)


