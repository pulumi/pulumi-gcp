# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CxAgentAdvancedSettings',
    'CxAgentAdvancedSettingsAudioExportGcsDestination',
    'CxAgentAdvancedSettingsDtmfSettings',
    'CxAgentGitIntegrationSettings',
    'CxAgentGitIntegrationSettingsGithubSettings',
    'CxAgentSpeechToTextSettings',
    'CxAgentTextToSpeechSettings',
    'CxEntityTypeEntity',
    'CxEntityTypeExcludedPhrase',
    'CxEnvironmentVersionConfig',
    'CxFlowAdvancedSettings',
    'CxFlowAdvancedSettingsAudioExportGcsDestination',
    'CxFlowAdvancedSettingsDtmfSettings',
    'CxFlowEventHandler',
    'CxFlowEventHandlerTriggerFulfillment',
    'CxFlowEventHandlerTriggerFulfillmentConditionalCase',
    'CxFlowEventHandlerTriggerFulfillmentMessage',
    'CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess',
    'CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff',
    'CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText',
    'CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio',
    'CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall',
    'CxFlowEventHandlerTriggerFulfillmentMessageText',
    'CxFlowEventHandlerTriggerFulfillmentSetParameterAction',
    'CxFlowNluSettings',
    'CxFlowTransitionRoute',
    'CxFlowTransitionRouteTriggerFulfillment',
    'CxFlowTransitionRouteTriggerFulfillmentConditionalCase',
    'CxFlowTransitionRouteTriggerFulfillmentMessage',
    'CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess',
    'CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff',
    'CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText',
    'CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio',
    'CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall',
    'CxFlowTransitionRouteTriggerFulfillmentMessageText',
    'CxFlowTransitionRouteTriggerFulfillmentSetParameterAction',
    'CxIntentParameter',
    'CxIntentTrainingPhrase',
    'CxIntentTrainingPhrasePart',
    'CxPageAdvancedSettings',
    'CxPageAdvancedSettingsDtmfSettings',
    'CxPageEntryFulfillment',
    'CxPageEntryFulfillmentConditionalCase',
    'CxPageEntryFulfillmentMessage',
    'CxPageEntryFulfillmentMessageConversationSuccess',
    'CxPageEntryFulfillmentMessageLiveAgentHandoff',
    'CxPageEntryFulfillmentMessageOutputAudioText',
    'CxPageEntryFulfillmentMessagePlayAudio',
    'CxPageEntryFulfillmentMessageTelephonyTransferCall',
    'CxPageEntryFulfillmentMessageText',
    'CxPageEntryFulfillmentSetParameterAction',
    'CxPageEventHandler',
    'CxPageEventHandlerTriggerFulfillment',
    'CxPageEventHandlerTriggerFulfillmentConditionalCase',
    'CxPageEventHandlerTriggerFulfillmentMessage',
    'CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess',
    'CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff',
    'CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText',
    'CxPageEventHandlerTriggerFulfillmentMessagePlayAudio',
    'CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall',
    'CxPageEventHandlerTriggerFulfillmentMessageText',
    'CxPageEventHandlerTriggerFulfillmentSetParameterAction',
    'CxPageForm',
    'CxPageFormParameter',
    'CxPageFormParameterAdvancedSettings',
    'CxPageFormParameterAdvancedSettingsDtmfSettings',
    'CxPageFormParameterFillBehavior',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillment',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction',
    'CxPageFormParameterFillBehaviorRepromptEventHandler',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction',
    'CxPageTransitionRoute',
    'CxPageTransitionRouteTriggerFulfillment',
    'CxPageTransitionRouteTriggerFulfillmentConditionalCase',
    'CxPageTransitionRouteTriggerFulfillmentMessage',
    'CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess',
    'CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff',
    'CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText',
    'CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio',
    'CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall',
    'CxPageTransitionRouteTriggerFulfillmentMessageText',
    'CxPageTransitionRouteTriggerFulfillmentSetParameterAction',
    'CxSecuritySettingsAudioExportSettings',
    'CxSecuritySettingsInsightsExportSettings',
    'CxTestCaseLastTestResult',
    'CxTestCaseLastTestResultConversationTurn',
    'CxTestCaseLastTestResultConversationTurnUserInput',
    'CxTestCaseLastTestResultConversationTurnUserInputInput',
    'CxTestCaseLastTestResultConversationTurnUserInputInputDtmf',
    'CxTestCaseLastTestResultConversationTurnUserInputInputEvent',
    'CxTestCaseLastTestResultConversationTurnUserInputInputText',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutput',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent',
    'CxTestCaseTestCaseConversationTurn',
    'CxTestCaseTestCaseConversationTurnUserInput',
    'CxTestCaseTestCaseConversationTurnUserInputInput',
    'CxTestCaseTestCaseConversationTurnUserInputInputDtmf',
    'CxTestCaseTestCaseConversationTurnUserInputInputEvent',
    'CxTestCaseTestCaseConversationTurnUserInputInputText',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutput',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent',
    'CxTestCaseTestConfig',
    'CxVersionNluSetting',
    'CxWebhookGenericWebService',
    'CxWebhookServiceDirectory',
    'CxWebhookServiceDirectoryGenericWebService',
    'EntityTypeEntity',
    'FulfillmentFeature',
    'FulfillmentGenericWebService',
    'IntentFollowupIntentInfo',
]

@pulumi.output_type
class CxAgentAdvancedSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioExportGcsDestination":
            suggest = "audio_export_gcs_destination"
        elif key == "dtmfSettings":
            suggest = "dtmf_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentAdvancedSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentAdvancedSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentAdvancedSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_export_gcs_destination: Optional['outputs.CxAgentAdvancedSettingsAudioExportGcsDestination'] = None,
                 dtmf_settings: Optional['outputs.CxAgentAdvancedSettingsDtmfSettings'] = None):
        """
        :param 'CxAgentAdvancedSettingsAudioExportGcsDestinationArgs' audio_export_gcs_destination: If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
               * Agent level
               * Flow level
               Structure is documented below.
        :param 'CxAgentAdvancedSettingsDtmfSettingsArgs' dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if audio_export_gcs_destination is not None:
            pulumi.set(__self__, "audio_export_gcs_destination", audio_export_gcs_destination)
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @property
    @pulumi.getter(name="audioExportGcsDestination")
    def audio_export_gcs_destination(self) -> Optional['outputs.CxAgentAdvancedSettingsAudioExportGcsDestination']:
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        return pulumi.get(self, "audio_export_gcs_destination")

    @property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional['outputs.CxAgentAdvancedSettingsDtmfSettings']:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")


@pulumi.output_type
class CxAgentAdvancedSettingsAudioExportGcsDestination(dict):
    def __init__(__self__, *,
                 uri: Optional[str] = None):
        """
        :param str uri: The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
               Format: gs://bucket/object-name-or-prefix
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class CxAgentAdvancedSettingsDtmfSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"
        elif key == "maxDigits":
            suggest = "max_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentAdvancedSettingsDtmfSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 finish_digit: Optional[str] = None,
                 max_digits: Optional[int] = None):
        """
        :param bool enabled: If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param str finish_digit: The digit that terminates a DTMF digit sequence.
        :param int max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[int]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")


@pulumi.output_type
class CxAgentGitIntegrationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "githubSettings":
            suggest = "github_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentGitIntegrationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentGitIntegrationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentGitIntegrationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 github_settings: Optional['outputs.CxAgentGitIntegrationSettingsGithubSettings'] = None):
        """
        :param 'CxAgentGitIntegrationSettingsGithubSettingsArgs' github_settings: Settings of integration with GitHub.
               Structure is documented below.
        """
        if github_settings is not None:
            pulumi.set(__self__, "github_settings", github_settings)

    @property
    @pulumi.getter(name="githubSettings")
    def github_settings(self) -> Optional['outputs.CxAgentGitIntegrationSettingsGithubSettings']:
        """
        Settings of integration with GitHub.
        Structure is documented below.
        """
        return pulumi.get(self, "github_settings")


@pulumi.output_type
class CxAgentGitIntegrationSettingsGithubSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "repositoryUri":
            suggest = "repository_uri"
        elif key == "trackingBranch":
            suggest = "tracking_branch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentGitIntegrationSettingsGithubSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentGitIntegrationSettingsGithubSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentGitIntegrationSettingsGithubSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 branches: Optional[Sequence[str]] = None,
                 display_name: Optional[str] = None,
                 repository_uri: Optional[str] = None,
                 tracking_branch: Optional[str] = None):
        """
        :param str access_token: The access token used to authenticate the access to the GitHub repository.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param Sequence[str] branches: A list of branches configured to be used from Dialogflow.
        :param str display_name: The unique repository display name for the GitHub repository.
        :param str repository_uri: The GitHub repository URI related to the agent.
        :param str tracking_branch: The branch of the GitHub repository tracked for this agent.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if repository_uri is not None:
            pulumi.set(__self__, "repository_uri", repository_uri)
        if tracking_branch is not None:
            pulumi.set(__self__, "tracking_branch", tracking_branch)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The access token used to authenticate the access to the GitHub repository.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[str]]:
        """
        A list of branches configured to be used from Dialogflow.
        """
        return pulumi.get(self, "branches")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The unique repository display name for the GitHub repository.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="repositoryUri")
    def repository_uri(self) -> Optional[str]:
        """
        The GitHub repository URI related to the agent.
        """
        return pulumi.get(self, "repository_uri")

    @property
    @pulumi.getter(name="trackingBranch")
    def tracking_branch(self) -> Optional[str]:
        """
        The branch of the GitHub repository tracked for this agent.
        """
        return pulumi.get(self, "tracking_branch")


@pulumi.output_type
class CxAgentSpeechToTextSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSpeechAdaptation":
            suggest = "enable_speech_adaptation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentSpeechToTextSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentSpeechToTextSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentSpeechToTextSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_speech_adaptation: Optional[bool] = None):
        """
        :param bool enable_speech_adaptation: Whether to use speech adaptation for speech recognition.
        """
        if enable_speech_adaptation is not None:
            pulumi.set(__self__, "enable_speech_adaptation", enable_speech_adaptation)

    @property
    @pulumi.getter(name="enableSpeechAdaptation")
    def enable_speech_adaptation(self) -> Optional[bool]:
        """
        Whether to use speech adaptation for speech recognition.
        """
        return pulumi.get(self, "enable_speech_adaptation")


@pulumi.output_type
class CxAgentTextToSpeechSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "synthesizeSpeechConfigs":
            suggest = "synthesize_speech_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxAgentTextToSpeechSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxAgentTextToSpeechSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxAgentTextToSpeechSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 synthesize_speech_configs: Optional[str] = None):
        """
        :param str synthesize_speech_configs: Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
               These settings affect:
               * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
               * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
        """
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[str]:
        """
        Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
        These settings affect:
        * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
        * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
        """
        return pulumi.get(self, "synthesize_speech_configs")


@pulumi.output_type
class CxEntityTypeEntity(dict):
    def __init__(__self__, *,
                 synonyms: Optional[Sequence[str]] = None,
                 value: Optional[str] = None):
        """
        :param Sequence[str] synonyms: A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
               For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
               
               - - -
        :param str value: The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
               For KIND_MAP entity types: A canonical value to be used in place of synonyms.
               For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
        """
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def synonyms(self) -> Optional[Sequence[str]]:
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
        For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.

        - - -
        """
        return pulumi.get(self, "synonyms")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
        For KIND_MAP entity types: A canonical value to be used in place of synonyms.
        For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxEntityTypeExcludedPhrase(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: The word or phrase to be excluded.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The word or phrase to be excluded.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxEnvironmentVersionConfig(dict):
    def __init__(__self__, *,
                 version: str):
        """
        :param str version: Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
               
               - - -
        """
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.

        - - -
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class CxFlowAdvancedSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioExportGcsDestination":
            suggest = "audio_export_gcs_destination"
        elif key == "dtmfSettings":
            suggest = "dtmf_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowAdvancedSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowAdvancedSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowAdvancedSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_export_gcs_destination: Optional['outputs.CxFlowAdvancedSettingsAudioExportGcsDestination'] = None,
                 dtmf_settings: Optional['outputs.CxFlowAdvancedSettingsDtmfSettings'] = None):
        """
        :param 'CxFlowAdvancedSettingsAudioExportGcsDestinationArgs' audio_export_gcs_destination: If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
               * Agent level
               * Flow level
               Structure is documented below.
        :param 'CxFlowAdvancedSettingsDtmfSettingsArgs' dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if audio_export_gcs_destination is not None:
            pulumi.set(__self__, "audio_export_gcs_destination", audio_export_gcs_destination)
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @property
    @pulumi.getter(name="audioExportGcsDestination")
    def audio_export_gcs_destination(self) -> Optional['outputs.CxFlowAdvancedSettingsAudioExportGcsDestination']:
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        return pulumi.get(self, "audio_export_gcs_destination")

    @property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional['outputs.CxFlowAdvancedSettingsDtmfSettings']:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")


@pulumi.output_type
class CxFlowAdvancedSettingsAudioExportGcsDestination(dict):
    def __init__(__self__, *,
                 uri: Optional[str] = None):
        """
        :param str uri: The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
               Format: gs://bucket/object-name-or-prefix
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class CxFlowAdvancedSettingsDtmfSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"
        elif key == "maxDigits":
            suggest = "max_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowAdvancedSettingsDtmfSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 finish_digit: Optional[str] = None,
                 max_digits: Optional[int] = None):
        """
        :param bool enabled: If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param str finish_digit: The digit that terminates a DTMF digit sequence.
        :param int max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[int]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")


@pulumi.output_type
class CxFlowEventHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFlow":
            suggest = "target_flow"
        elif key == "targetPage":
            suggest = "target_page"
        elif key == "triggerFulfillment":
            suggest = "trigger_fulfillment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: Optional[str] = None,
                 name: Optional[str] = None,
                 target_flow: Optional[str] = None,
                 target_page: Optional[str] = None,
                 trigger_fulfillment: Optional['outputs.CxFlowEventHandlerTriggerFulfillment'] = None):
        """
        :param str event: The name of the event to handle.
        :param str name: (Output)
               The unique identifier of this event handler.
        :param str target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param str target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param 'CxFlowEventHandlerTriggerFulfillmentArgs' trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[str]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[str]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillment']:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxFlowEventHandlerTriggerFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxFlowEventHandlerTriggerFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxFlowEventHandlerTriggerFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxFlowEventHandlerTriggerFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowEventHandlerTriggerFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxFlowEventHandlerTriggerFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxFlowNluSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationThreshold":
            suggest = "classification_threshold"
        elif key == "modelTrainingMode":
            suggest = "model_training_mode"
        elif key == "modelType":
            suggest = "model_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowNluSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowNluSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowNluSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification_threshold: Optional[float] = None,
                 model_training_mode: Optional[str] = None,
                 model_type: Optional[str] = None):
        """
        :param float classification_threshold: To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
               If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        :param str model_training_mode: Indicates NLU model training mode.
               * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
               * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
               Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        :param str model_type: Indicates the type of NLU model.
               * MODEL_TYPE_STANDARD: Use standard NLU model.
               * MODEL_TYPE_ADVANCED: Use advanced NLU model.
               Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        if classification_threshold is not None:
            pulumi.set(__self__, "classification_threshold", classification_threshold)
        if model_training_mode is not None:
            pulumi.set(__self__, "model_training_mode", model_training_mode)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @property
    @pulumi.getter(name="classificationThreshold")
    def classification_threshold(self) -> Optional[float]:
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
        If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        return pulumi.get(self, "classification_threshold")

    @property
    @pulumi.getter(name="modelTrainingMode")
    def model_training_mode(self) -> Optional[str]:
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        return pulumi.get(self, "model_training_mode")

    @property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[str]:
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class CxFlowTransitionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFlow":
            suggest = "target_flow"
        elif key == "targetPage":
            suggest = "target_page"
        elif key == "triggerFulfillment":
            suggest = "trigger_fulfillment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 intent: Optional[str] = None,
                 name: Optional[str] = None,
                 target_flow: Optional[str] = None,
                 target_page: Optional[str] = None,
                 trigger_fulfillment: Optional['outputs.CxFlowTransitionRouteTriggerFulfillment'] = None):
        """
        :param str condition: The condition to evaluate against form parameters or session parameters.
               At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param str intent: The unique identifier of an Intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param str name: (Output)
               The unique identifier of this transition route.
        :param str target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param str target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param 'CxFlowTransitionRouteTriggerFulfillmentArgs' trigger_fulfillment: The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def intent(self) -> Optional[str]:
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of this transition route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[str]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[str]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillment']:
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxFlowTransitionRouteTriggerFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxFlowTransitionRouteTriggerFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxFlowTransitionRouteTriggerFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxFlowTransitionRouteTriggerFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxFlowTransitionRouteTriggerFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxFlowTransitionRouteTriggerFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxIntentParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "isList":
            suggest = "is_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxIntentParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxIntentParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxIntentParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 id: str,
                 is_list: Optional[bool] = None,
                 redact: Optional[bool] = None):
        """
        :param str entity_type: The entity type of the parameter.
               Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        :param str id: The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
        :param bool is_list: Indicates whether the parameter represents a list of values.
        :param bool redact: Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
               Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "id", id)
        if is_list is not None:
            pulumi.set(__self__, "is_list", is_list)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isList")
    def is_list(self) -> Optional[bool]:
        """
        Indicates whether the parameter represents a list of values.
        """
        return pulumi.get(self, "is_list")

    @property
    @pulumi.getter
    def redact(self) -> Optional[bool]:
        """
        Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
        Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        return pulumi.get(self, "redact")


@pulumi.output_type
class CxIntentTrainingPhrase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatCount":
            suggest = "repeat_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxIntentTrainingPhrase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxIntentTrainingPhrase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxIntentTrainingPhrase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parts: Sequence['outputs.CxIntentTrainingPhrasePart'],
                 id: Optional[str] = None,
                 repeat_count: Optional[int] = None):
        """
        :param Sequence['CxIntentTrainingPhrasePartArgs'] parts: The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
               Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
               Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
               If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
               If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
               Part.text is set to a part of the phrase that has no parameters.
               Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
               Structure is documented below.
        :param str id: (Output)
               The unique identifier of the training phrase.
        :param int repeat_count: Indicates how many times this example was added to the intent.
        """
        pulumi.set(__self__, "parts", parts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)

    @property
    @pulumi.getter
    def parts(self) -> Sequence['outputs.CxIntentTrainingPhrasePart']:
        """
        The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
        Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
        Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
        If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
        If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
        Part.text is set to a part of the phrase that has no parameters.
        Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
        Structure is documented below.
        """
        return pulumi.get(self, "parts")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of the training phrase.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[int]:
        """
        Indicates how many times this example was added to the intent.
        """
        return pulumi.get(self, "repeat_count")


@pulumi.output_type
class CxIntentTrainingPhrasePart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterId":
            suggest = "parameter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxIntentTrainingPhrasePart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxIntentTrainingPhrasePart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxIntentTrainingPhrasePart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 parameter_id: Optional[str] = None):
        """
        :param str text: The text for this part.
        :param str parameter_id: The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
        """
        pulumi.set(__self__, "text", text)
        if parameter_id is not None:
            pulumi.set(__self__, "parameter_id", parameter_id)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text for this part.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="parameterId")
    def parameter_id(self) -> Optional[str]:
        """
        The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
        """
        return pulumi.get(self, "parameter_id")


@pulumi.output_type
class CxPageAdvancedSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dtmfSettings":
            suggest = "dtmf_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageAdvancedSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageAdvancedSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageAdvancedSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dtmf_settings: Optional['outputs.CxPageAdvancedSettingsDtmfSettings'] = None):
        """
        :param 'CxPageAdvancedSettingsDtmfSettingsArgs' dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional['outputs.CxPageAdvancedSettingsDtmfSettings']:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")


@pulumi.output_type
class CxPageAdvancedSettingsDtmfSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"
        elif key == "maxDigits":
            suggest = "max_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageAdvancedSettingsDtmfSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 finish_digit: Optional[str] = None,
                 max_digits: Optional[int] = None):
        """
        :param bool enabled: If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param str finish_digit: The digit that terminates a DTMF digit sequence.
        :param int max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[int]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")


@pulumi.output_type
class CxPageEntryFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxPageEntryFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxPageEntryFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxPageEntryFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxPageEntryFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxPageEntryFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxPageEntryFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxPageEntryFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxPageEntryFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxPageEntryFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxPageEntryFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxPageEntryFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxPageEntryFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxPageEntryFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxPageEntryFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxPageEntryFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxPageEntryFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxPageEntryFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxPageEntryFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxPageEntryFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxPageEntryFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxPageEntryFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxPageEntryFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxPageEntryFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxPageEntryFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxPageEntryFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxPageEntryFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxPageEntryFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxPageEntryFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxPageEntryFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageEntryFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageEntryFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageEntryFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageEntryFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxPageEntryFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxPageEntryFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEntryFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEntryFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEntryFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxPageEntryFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxPageEventHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFlow":
            suggest = "target_flow"
        elif key == "targetPage":
            suggest = "target_page"
        elif key == "triggerFulfillment":
            suggest = "trigger_fulfillment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: Optional[str] = None,
                 name: Optional[str] = None,
                 target_flow: Optional[str] = None,
                 target_page: Optional[str] = None,
                 trigger_fulfillment: Optional['outputs.CxPageEventHandlerTriggerFulfillment'] = None):
        """
        :param str event: The name of the event to handle.
        :param str name: (Output)
               The unique identifier of this event handler.
        :param str target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param str target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param 'CxPageEventHandlerTriggerFulfillmentArgs' trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[str]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[str]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillment']:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxPageEventHandlerTriggerFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxPageEventHandlerTriggerFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxPageEventHandlerTriggerFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxPageEventHandlerTriggerFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageEventHandlerTriggerFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxPageEventHandlerTriggerFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxPageForm(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence['outputs.CxPageFormParameter']] = None):
        """
        :param Sequence['CxPageFormParameterArgs'] parameters: Parameters to collect from the user.
               Structure is documented below.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.CxPageFormParameter']]:
        """
        Parameters to collect from the user.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CxPageFormParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSettings":
            suggest = "advanced_settings"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "fillBehavior":
            suggest = "fill_behavior"
        elif key == "isList":
            suggest = "is_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_settings: Optional['outputs.CxPageFormParameterAdvancedSettings'] = None,
                 default_value: Optional[str] = None,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 fill_behavior: Optional['outputs.CxPageFormParameterFillBehavior'] = None,
                 is_list: Optional[bool] = None,
                 redact: Optional[bool] = None,
                 required: Optional[bool] = None):
        """
        :param 'CxPageFormParameterAdvancedSettingsArgs' advanced_settings: Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
               Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
               Structure is documented below.
        :param str default_value: The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        :param str display_name: The human-readable name of the parameter, unique within the form.
        :param str entity_type: The entity type of the parameter.
               Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        :param 'CxPageFormParameterFillBehaviorArgs' fill_behavior: Defines fill behavior for the parameter.
               Structure is documented below.
        :param bool is_list: Indicates whether the parameter represents a list of values.
        :param bool redact: Indicates whether the parameter content should be redacted in log.
               If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        :param bool required: Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
               Required parameters must be filled before form filling concludes.
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if fill_behavior is not None:
            pulumi.set(__self__, "fill_behavior", fill_behavior)
        if is_list is not None:
            pulumi.set(__self__, "is_list", is_list)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional['outputs.CxPageFormParameterAdvancedSettings']:
        """
        Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "advanced_settings")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        """
        The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The human-readable name of the parameter, unique within the form.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="fillBehavior")
    def fill_behavior(self) -> Optional['outputs.CxPageFormParameterFillBehavior']:
        """
        Defines fill behavior for the parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "fill_behavior")

    @property
    @pulumi.getter(name="isList")
    def is_list(self) -> Optional[bool]:
        """
        Indicates whether the parameter represents a list of values.
        """
        return pulumi.get(self, "is_list")

    @property
    @pulumi.getter
    def redact(self) -> Optional[bool]:
        """
        Indicates whether the parameter content should be redacted in log.
        If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        return pulumi.get(self, "redact")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
        Required parameters must be filled before form filling concludes.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class CxPageFormParameterAdvancedSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dtmfSettings":
            suggest = "dtmf_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterAdvancedSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterAdvancedSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterAdvancedSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dtmf_settings: Optional['outputs.CxPageFormParameterAdvancedSettingsDtmfSettings'] = None):
        """
        :param 'CxPageFormParameterAdvancedSettingsDtmfSettingsArgs' dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional['outputs.CxPageFormParameterAdvancedSettingsDtmfSettings']:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")


@pulumi.output_type
class CxPageFormParameterAdvancedSettingsDtmfSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"
        elif key == "maxDigits":
            suggest = "max_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterAdvancedSettingsDtmfSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterAdvancedSettingsDtmfSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 finish_digit: Optional[str] = None,
                 max_digits: Optional[int] = None):
        """
        :param bool enabled: If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param str finish_digit: The digit that terminates a DTMF digit sequence.
        :param int max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[int]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")


@pulumi.output_type
class CxPageFormParameterFillBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialPromptFulfillment":
            suggest = "initial_prompt_fulfillment"
        elif key == "repromptEventHandlers":
            suggest = "reprompt_event_handlers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_prompt_fulfillment: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillment'] = None,
                 reprompt_event_handlers: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandler']] = None):
        """
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs' initial_prompt_fulfillment: The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
               Structure is documented below.
        :param Sequence['CxPageFormParameterFillBehaviorRepromptEventHandlerArgs'] reprompt_event_handlers: The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
               * sys.no-match-<N>, where N can be from 1 to 6
               * sys.no-match-default
               * sys.no-input-<N>, where N can be from 1 to 6
               * sys.no-input-default
               * sys.invalid-parameter
               [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
               If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
               A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
               A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
               If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
               Structure is documented below.
        """
        if initial_prompt_fulfillment is not None:
            pulumi.set(__self__, "initial_prompt_fulfillment", initial_prompt_fulfillment)
        if reprompt_event_handlers is not None:
            pulumi.set(__self__, "reprompt_event_handlers", reprompt_event_handlers)

    @property
    @pulumi.getter(name="initialPromptFulfillment")
    def initial_prompt_fulfillment(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillment']:
        """
        The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "initial_prompt_fulfillment")

    @property
    @pulumi.getter(name="repromptEventHandlers")
    def reprompt_event_handlers(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandler']]:
        """
        The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
        * sys.no-match-<N>, where N can be from 1 to 6
        * sys.no-match-default
        * sys.no-input-<N>, where N can be from 1 to 6
        * sys.no-input-default
        * sys.invalid-parameter
        [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
        If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
        A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
        A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
        If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
        Structure is documented below.
        """
        return pulumi.get(self, "reprompt_event_handlers")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFlow":
            suggest = "target_flow"
        elif key == "targetPage":
            suggest = "target_page"
        elif key == "triggerFulfillment":
            suggest = "trigger_fulfillment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: Optional[str] = None,
                 name: Optional[str] = None,
                 target_flow: Optional[str] = None,
                 target_page: Optional[str] = None,
                 trigger_fulfillment: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment'] = None):
        """
        :param str event: The name of the event to handle.
        :param str name: (Output)
               The unique identifier of this event handler.
        :param str target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param str target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs' trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[str]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[str]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment']:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxPageTransitionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFlow":
            suggest = "target_flow"
        elif key == "targetPage":
            suggest = "target_page"
        elif key == "triggerFulfillment":
            suggest = "trigger_fulfillment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 intent: Optional[str] = None,
                 name: Optional[str] = None,
                 target_flow: Optional[str] = None,
                 target_page: Optional[str] = None,
                 trigger_fulfillment: Optional['outputs.CxPageTransitionRouteTriggerFulfillment'] = None):
        """
        :param str condition: The condition to evaluate against form parameters or session parameters.
               At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param str intent: The unique identifier of an Intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param str name: (Output)
               The unique identifier of this transition route.
        :param str target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param str target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param 'CxPageTransitionRouteTriggerFulfillmentArgs' trigger_fulfillment: The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def intent(self) -> Optional[str]:
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Output)
        The unique identifier of this transition route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[str]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[str]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillment']:
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionalCases":
            suggest = "conditional_cases"
        elif key == "returnPartialResponses":
            suggest = "return_partial_responses"
        elif key == "setParameterActions":
            suggest = "set_parameter_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditional_cases: Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentConditionalCase']] = None,
                 messages: Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentMessage']] = None,
                 return_partial_responses: Optional[bool] = None,
                 set_parameter_actions: Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentSetParameterAction']] = None,
                 tag: Optional[str] = None,
                 webhook: Optional[str] = None):
        """
        :param Sequence['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs'] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param Sequence['CxPageTransitionRouteTriggerFulfillmentMessageArgs'] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param bool return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param Sequence['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs'] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param str tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param str webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentConditionalCase']]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentMessage']]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[bool]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[Sequence['outputs.CxPageTransitionRouteTriggerFulfillmentSetParameterAction']]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def webhook(self) -> Optional[str]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentConditionalCase(dict):
    def __init__(__self__, *,
                 cases: Optional[str] = None):
        """
        :param str cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @property
    @pulumi.getter
    def cases(self) -> Optional[str]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationSuccess":
            suggest = "conversation_success"
        elif key == "liveAgentHandoff":
            suggest = "live_agent_handoff"
        elif key == "outputAudioText":
            suggest = "output_audio_text"
        elif key == "playAudio":
            suggest = "play_audio"
        elif key == "telephonyTransferCall":
            suggest = "telephony_transfer_call"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillmentMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel: Optional[str] = None,
                 conversation_success: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess'] = None,
                 live_agent_handoff: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff'] = None,
                 output_audio_text: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText'] = None,
                 payload: Optional[str] = None,
                 play_audio: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio'] = None,
                 telephony_transfer_call: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall'] = None,
                 text: Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageText'] = None):
        """
        :param str channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs' conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               Structure is documented below.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs' live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               Structure is documented below.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs' output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               Structure is documented below.
        :param str payload: A custom, platform-specific payload.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs' play_audio: Specifies an audio clip to be played by the client as part of the response.
               Structure is documented below.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs' telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               Structure is documented below.
        :param 'CxPageTransitionRouteTriggerFulfillmentMessageTextArgs' text: The text response message.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def channel(self) -> Optional[str]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess']:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff']:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText']:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        A custom, platform-specific payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio']:
        """
        Specifies an audio clip to be played by the client as part of the response.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall']:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxPageTransitionRouteTriggerFulfillmentMessageText']:
        """
        The text response message.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccess(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoff(dict):
    def __init__(__self__, *,
                 metadata: Optional[str] = None):
        """
        :param str metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 ssml: Optional[str] = None,
                 text: Optional[str] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param str ssml: The SSML text to be synthesized. For more information, see SSML.
        :param str text: The raw text to be synthesized.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def ssml(self) -> Optional[str]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        """
        return pulumi.get(self, "ssml")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The raw text to be synthesized.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioUri":
            suggest = "audio_uri"
        elif key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessagePlayAudio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_uri: str,
                 allow_playback_interruption: Optional[bool] = None):
        """
        :param str audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> str:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phone_number: str):
        """
        :param str phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentMessageText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPlaybackInterruption":
            suggest = "allow_playback_interruption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxPageTransitionRouteTriggerFulfillmentMessageText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxPageTransitionRouteTriggerFulfillmentMessageText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_playback_interruption: Optional[bool] = None,
                 texts: Optional[Sequence[str]] = None):
        """
        :param bool allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param Sequence[str] texts: A collection of text responses.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[bool]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxPageTransitionRouteTriggerFulfillmentSetParameterAction(dict):
    def __init__(__self__, *,
                 parameter: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str parameter: Display name of the parameter.
        :param str value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def parameter(self) -> Optional[str]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CxSecuritySettingsAudioExportSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioExportPattern":
            suggest = "audio_export_pattern"
        elif key == "audioFormat":
            suggest = "audio_format"
        elif key == "enableAudioRedaction":
            suggest = "enable_audio_redaction"
        elif key == "gcsBucket":
            suggest = "gcs_bucket"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxSecuritySettingsAudioExportSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxSecuritySettingsAudioExportSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxSecuritySettingsAudioExportSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_export_pattern: Optional[str] = None,
                 audio_format: Optional[str] = None,
                 enable_audio_redaction: Optional[bool] = None,
                 gcs_bucket: Optional[str] = None):
        """
        :param str audio_export_pattern: Filename pattern for exported audio.
        :param str audio_format: File format for exported audio file. Currently only in telephony recordings.
               * MULAW: G.711 mu-law PCM with 8kHz sample rate.
               * MP3: MP3 file format.
               * OGG: OGG Vorbis.
               Possible values are: `MULAW`, `MP3`, `OGG`.
        :param bool enable_audio_redaction: Enable audio redaction if it is true.
        :param str gcs_bucket: Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
        """
        if audio_export_pattern is not None:
            pulumi.set(__self__, "audio_export_pattern", audio_export_pattern)
        if audio_format is not None:
            pulumi.set(__self__, "audio_format", audio_format)
        if enable_audio_redaction is not None:
            pulumi.set(__self__, "enable_audio_redaction", enable_audio_redaction)
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)

    @property
    @pulumi.getter(name="audioExportPattern")
    def audio_export_pattern(self) -> Optional[str]:
        """
        Filename pattern for exported audio.
        """
        return pulumi.get(self, "audio_export_pattern")

    @property
    @pulumi.getter(name="audioFormat")
    def audio_format(self) -> Optional[str]:
        """
        File format for exported audio file. Currently only in telephony recordings.
        * MULAW: G.711 mu-law PCM with 8kHz sample rate.
        * MP3: MP3 file format.
        * OGG: OGG Vorbis.
        Possible values are: `MULAW`, `MP3`, `OGG`.
        """
        return pulumi.get(self, "audio_format")

    @property
    @pulumi.getter(name="enableAudioRedaction")
    def enable_audio_redaction(self) -> Optional[bool]:
        """
        Enable audio redaction if it is true.
        """
        return pulumi.get(self, "enable_audio_redaction")

    @property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[str]:
        """
        Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
        """
        return pulumi.get(self, "gcs_bucket")


@pulumi.output_type
class CxSecuritySettingsInsightsExportSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableInsightsExport":
            suggest = "enable_insights_export"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxSecuritySettingsInsightsExportSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxSecuritySettingsInsightsExportSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxSecuritySettingsInsightsExportSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_insights_export: bool):
        """
        :param bool enable_insights_export: If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
        """
        pulumi.set(__self__, "enable_insights_export", enable_insights_export)

    @property
    @pulumi.getter(name="enableInsightsExport")
    def enable_insights_export(self) -> bool:
        """
        If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
        """
        return pulumi.get(self, "enable_insights_export")


@pulumi.output_type
class CxTestCaseLastTestResult(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversationTurns":
            suggest = "conversation_turns"
        elif key == "testResult":
            suggest = "test_result"
        elif key == "testTime":
            suggest = "test_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResult. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResult.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResult.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conversation_turns: Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurn']] = None,
                 environment: Optional[str] = None,
                 name: Optional[str] = None,
                 test_result: Optional[str] = None,
                 test_time: Optional[str] = None):
        """
        :param Sequence['CxTestCaseLastTestResultConversationTurnArgs'] conversation_turns: The conversation turns uttered during the test case replay in chronological order.
               Structure is documented below.
        :param str environment: Environment where the test was run. If not set, it indicates the draft environment.
        :param str name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param str test_result: Whether the test case passed in the agent environment.
               * PASSED: The test passed.
               * FAILED: The test did not pass.
               Possible values are: `PASSED`, `FAILED`.
        :param str test_time: The time that the test was run. A timestamp in RFC3339 text format.
        """
        if conversation_turns is not None:
            pulumi.set(__self__, "conversation_turns", conversation_turns)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if test_result is not None:
            pulumi.set(__self__, "test_result", test_result)
        if test_time is not None:
            pulumi.set(__self__, "test_time", test_time)

    @property
    @pulumi.getter(name="conversationTurns")
    def conversation_turns(self) -> Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurn']]:
        """
        The conversation turns uttered during the test case replay in chronological order.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_turns")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Environment where the test was run. If not set, it indicates the draft environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="testResult")
    def test_result(self) -> Optional[str]:
        """
        Whether the test case passed in the agent environment.
        * PASSED: The test passed.
        * FAILED: The test did not pass.
        Possible values are: `PASSED`, `FAILED`.
        """
        return pulumi.get(self, "test_result")

    @property
    @pulumi.getter(name="testTime")
    def test_time(self) -> Optional[str]:
        """
        The time that the test was run. A timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "test_time")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInput":
            suggest = "user_input"
        elif key == "virtualAgentOutput":
            suggest = "virtual_agent_output"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_input: Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInput'] = None,
                 virtual_agent_output: Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutput'] = None):
        """
        :param 'CxTestCaseLastTestResultConversationTurnUserInputArgs' user_input: The user input.
               Structure is documented below.
        :param 'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs' virtual_agent_output: The virtual agent output.
               Structure is documented below.
        """
        if user_input is not None:
            pulumi.set(__self__, "user_input", user_input)
        if virtual_agent_output is not None:
            pulumi.set(__self__, "virtual_agent_output", virtual_agent_output)

    @property
    @pulumi.getter(name="userInput")
    def user_input(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInput']:
        """
        The user input.
        Structure is documented below.
        """
        return pulumi.get(self, "user_input")

    @property
    @pulumi.getter(name="virtualAgentOutput")
    def virtual_agent_output(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutput']:
        """
        The virtual agent output.
        Structure is documented below.
        """
        return pulumi.get(self, "virtual_agent_output")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnUserInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSentimentAnalysis":
            suggest = "enable_sentiment_analysis"
        elif key == "injectedParameters":
            suggest = "injected_parameters"
        elif key == "isWebhookEnabled":
            suggest = "is_webhook_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnUserInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_sentiment_analysis: Optional[bool] = None,
                 injected_parameters: Optional[str] = None,
                 input: Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInput'] = None,
                 is_webhook_enabled: Optional[bool] = None):
        """
        :param bool enable_sentiment_analysis: Whether sentiment analysis is enabled.
        :param str injected_parameters: Parameters that need to be injected into the conversation during intent detection.
        :param 'CxTestCaseLastTestResultConversationTurnUserInputInputArgs' input: User input. Supports text input, event input, dtmf input in the test case.
               Structure is documented below.
        :param bool is_webhook_enabled: If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        if enable_sentiment_analysis is not None:
            pulumi.set(__self__, "enable_sentiment_analysis", enable_sentiment_analysis)
        if injected_parameters is not None:
            pulumi.set(__self__, "injected_parameters", injected_parameters)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if is_webhook_enabled is not None:
            pulumi.set(__self__, "is_webhook_enabled", is_webhook_enabled)

    @property
    @pulumi.getter(name="enableSentimentAnalysis")
    def enable_sentiment_analysis(self) -> Optional[bool]:
        """
        Whether sentiment analysis is enabled.
        """
        return pulumi.get(self, "enable_sentiment_analysis")

    @property
    @pulumi.getter(name="injectedParameters")
    def injected_parameters(self) -> Optional[str]:
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        return pulumi.get(self, "injected_parameters")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInput']:
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isWebhookEnabled")
    def is_webhook_enabled(self) -> Optional[bool]:
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        return pulumi.get(self, "is_webhook_enabled")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnUserInputInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnUserInputInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInputInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInputInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dtmf: Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputDtmf'] = None,
                 event: Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputEvent'] = None,
                 language_code: Optional[str] = None,
                 text: Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputText'] = None):
        """
        :param 'CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs' dtmf: The DTMF event to be handled.
               Structure is documented below.
        :param 'CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs' event: The event to be triggered.
               Structure is documented below.
        :param str language_code: The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
               Note that queries in the same session do not necessarily need to specify the same language.
        :param 'CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs' text: The natural language text to be processed.
               Structure is documented below.
        """
        if dtmf is not None:
            pulumi.set(__self__, "dtmf", dtmf)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def dtmf(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputDtmf']:
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf")

    @property
    @pulumi.getter
    def event(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputEvent']:
        """
        The event to be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnUserInputInputText']:
        """
        The natural language text to be processed.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnUserInputInputDtmf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnUserInputInputDtmf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInputInputDtmf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnUserInputInputDtmf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digits: Optional[str] = None,
                 finish_digit: Optional[str] = None):
        """
        :param str digits: The dtmf digits.
        :param str finish_digit: The finish digit (if any).
        """
        if digits is not None:
            pulumi.set(__self__, "digits", digits)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)

    @property
    @pulumi.getter
    def digits(self) -> Optional[str]:
        """
        The dtmf digits.
        """
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The finish digit (if any).
        """
        return pulumi.get(self, "finish_digit")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnUserInputInputEvent(dict):
    def __init__(__self__, *,
                 event: str):
        """
        :param str event: Name of the event.
        """
        pulumi.set(__self__, "event", event)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Name of the event.
        """
        return pulumi.get(self, "event")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnUserInputInputText(dict):
    def __init__(__self__, *,
                 text: str):
        """
        :param str text: The natural language text to be processed. Text length must not exceed 256 characters.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentPage":
            suggest = "current_page"
        elif key == "sessionParameters":
            suggest = "session_parameters"
        elif key == "textResponses":
            suggest = "text_responses"
        elif key == "triggeredIntent":
            suggest = "triggered_intent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnVirtualAgentOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_page: Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage'] = None,
                 differences: Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference']] = None,
                 session_parameters: Optional[str] = None,
                 status: Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus'] = None,
                 text_responses: Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse']] = None,
                 triggered_intent: Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent'] = None):
        """
        :param 'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs' current_page: The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
               Structure is documented below.
        :param Sequence['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs'] differences: The list of differences between the original run and the replay for this output, if any.
               Structure is documented below.
        :param str session_parameters: The session parameters available to the bot at this point.
        :param 'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs' status: Response error from the agent in the test result. If set, other output is empty.
               Structure is documented below.
        :param Sequence['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs'] text_responses: The text responses from the agent for the turn.
               Structure is documented below.
        :param 'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs' triggered_intent: The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
               Structure is documented below.
        """
        if current_page is not None:
            pulumi.set(__self__, "current_page", current_page)
        if differences is not None:
            pulumi.set(__self__, "differences", differences)
        if session_parameters is not None:
            pulumi.set(__self__, "session_parameters", session_parameters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if text_responses is not None:
            pulumi.set(__self__, "text_responses", text_responses)
        if triggered_intent is not None:
            pulumi.set(__self__, "triggered_intent", triggered_intent)

    @property
    @pulumi.getter(name="currentPage")
    def current_page(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage']:
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        return pulumi.get(self, "current_page")

    @property
    @pulumi.getter
    def differences(self) -> Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference']]:
        """
        The list of differences between the original run and the replay for this output, if any.
        Structure is documented below.
        """
        return pulumi.get(self, "differences")

    @property
    @pulumi.getter(name="sessionParameters")
    def session_parameters(self) -> Optional[str]:
        """
        The session parameters available to the bot at this point.
        """
        return pulumi.get(self, "session_parameters")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus']:
        """
        Response error from the agent in the test result. If set, other output is empty.
        Structure is documented below.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="textResponses")
    def text_responses(self) -> Optional[Sequence['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse']]:
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        return pulumi.get(self, "text_responses")

    @property
    @pulumi.getter(name="triggeredIntent")
    def triggered_intent(self) -> Optional['outputs.CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent']:
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
        return pulumi.get(self, "triggered_intent")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str display_name: (Output)
               The human-readable name of the page, unique within the flow.
        :param str name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifference(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str description: A human readable description of the diff, showing the actual output vs expected output.
        :param str type: The type of diff.
               * INTENT: The intent.
               * PAGE: The page.
               * PARAMETERS: The parameters.
               * UTTERANCE: The message utterance.
               * FLOW: The flow.
               Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A human readable description of the diff, showing the actual output vs expected output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of diff.
        * INTENT: The intent.
        * PAGE: The page.
        * PARAMETERS: The parameters.
        * UTTERANCE: The message utterance.
        * FLOW: The flow.
        Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatus(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 details: Optional[str] = None,
                 message: Optional[str] = None):
        """
        :param int code: The status code, which should be an enum value of google.rpc.Code.
        :param str details: A JSON encoded list of messages that carry the error details.
        :param str message: A developer-facing error message.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        A JSON encoded list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A developer-facing error message.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponse(dict):
    def __init__(__self__, *,
                 texts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] texts: A collection of text responses.
        """
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str display_name: (Output)
               The human-readable name of the intent, unique within the agent.
        :param str name: The unique identifier of the intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInput":
            suggest = "user_input"
        elif key == "virtualAgentOutput":
            suggest = "virtual_agent_output"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_input: Optional['outputs.CxTestCaseTestCaseConversationTurnUserInput'] = None,
                 virtual_agent_output: Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutput'] = None):
        """
        :param 'CxTestCaseTestCaseConversationTurnUserInputArgs' user_input: The user input.
               Structure is documented below.
        :param 'CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs' virtual_agent_output: The virtual agent output.
               Structure is documented below.
        """
        if user_input is not None:
            pulumi.set(__self__, "user_input", user_input)
        if virtual_agent_output is not None:
            pulumi.set(__self__, "virtual_agent_output", virtual_agent_output)

    @property
    @pulumi.getter(name="userInput")
    def user_input(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnUserInput']:
        """
        The user input.
        Structure is documented below.
        """
        return pulumi.get(self, "user_input")

    @property
    @pulumi.getter(name="virtualAgentOutput")
    def virtual_agent_output(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutput']:
        """
        The virtual agent output.
        Structure is documented below.
        """
        return pulumi.get(self, "virtual_agent_output")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnUserInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSentimentAnalysis":
            suggest = "enable_sentiment_analysis"
        elif key == "injectedParameters":
            suggest = "injected_parameters"
        elif key == "isWebhookEnabled":
            suggest = "is_webhook_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnUserInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnUserInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnUserInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_sentiment_analysis: Optional[bool] = None,
                 injected_parameters: Optional[str] = None,
                 input: Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInput'] = None,
                 is_webhook_enabled: Optional[bool] = None):
        """
        :param bool enable_sentiment_analysis: Whether sentiment analysis is enabled.
        :param str injected_parameters: Parameters that need to be injected into the conversation during intent detection.
        :param 'CxTestCaseTestCaseConversationTurnUserInputInputArgs' input: User input. Supports text input, event input, dtmf input in the test case.
               Structure is documented below.
        :param bool is_webhook_enabled: If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        if enable_sentiment_analysis is not None:
            pulumi.set(__self__, "enable_sentiment_analysis", enable_sentiment_analysis)
        if injected_parameters is not None:
            pulumi.set(__self__, "injected_parameters", injected_parameters)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if is_webhook_enabled is not None:
            pulumi.set(__self__, "is_webhook_enabled", is_webhook_enabled)

    @property
    @pulumi.getter(name="enableSentimentAnalysis")
    def enable_sentiment_analysis(self) -> Optional[bool]:
        """
        Whether sentiment analysis is enabled.
        """
        return pulumi.get(self, "enable_sentiment_analysis")

    @property
    @pulumi.getter(name="injectedParameters")
    def injected_parameters(self) -> Optional[str]:
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        return pulumi.get(self, "injected_parameters")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInput']:
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isWebhookEnabled")
    def is_webhook_enabled(self) -> Optional[bool]:
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        return pulumi.get(self, "is_webhook_enabled")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnUserInputInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnUserInputInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnUserInputInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnUserInputInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dtmf: Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputDtmf'] = None,
                 event: Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputEvent'] = None,
                 language_code: Optional[str] = None,
                 text: Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputText'] = None):
        """
        :param 'CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs' dtmf: The DTMF event to be handled.
               Structure is documented below.
        :param 'CxTestCaseTestCaseConversationTurnUserInputInputEventArgs' event: The event to be triggered.
               Structure is documented below.
        :param str language_code: The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
               Note that queries in the same session do not necessarily need to specify the same language.
        :param 'CxTestCaseTestCaseConversationTurnUserInputInputTextArgs' text: The natural language text to be processed.
               Structure is documented below.
        """
        if dtmf is not None:
            pulumi.set(__self__, "dtmf", dtmf)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def dtmf(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputDtmf']:
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf")

    @property
    @pulumi.getter
    def event(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputEvent']:
        """
        The event to be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnUserInputInputText']:
        """
        The natural language text to be processed.
        Structure is documented below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnUserInputInputDtmf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "finishDigit":
            suggest = "finish_digit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnUserInputInputDtmf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnUserInputInputDtmf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnUserInputInputDtmf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digits: Optional[str] = None,
                 finish_digit: Optional[str] = None):
        """
        :param str digits: The dtmf digits.
        :param str finish_digit: The finish digit (if any).
        """
        if digits is not None:
            pulumi.set(__self__, "digits", digits)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)

    @property
    @pulumi.getter
    def digits(self) -> Optional[str]:
        """
        The dtmf digits.
        """
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[str]:
        """
        The finish digit (if any).
        """
        return pulumi.get(self, "finish_digit")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnUserInputInputEvent(dict):
    def __init__(__self__, *,
                 event: str):
        """
        :param str event: Name of the event.
        """
        pulumi.set(__self__, "event", event)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Name of the event.
        """
        return pulumi.get(self, "event")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnUserInputInputText(dict):
    def __init__(__self__, *,
                 text: str):
        """
        :param str text: The natural language text to be processed. Text length must not exceed 256 characters.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentPage":
            suggest = "current_page"
        elif key == "sessionParameters":
            suggest = "session_parameters"
        elif key == "textResponses":
            suggest = "text_responses"
        elif key == "triggeredIntent":
            suggest = "triggered_intent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnVirtualAgentOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_page: Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage'] = None,
                 session_parameters: Optional[str] = None,
                 text_responses: Optional[Sequence['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse']] = None,
                 triggered_intent: Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent'] = None):
        """
        :param 'CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs' current_page: The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
               Structure is documented below.
        :param str session_parameters: The session parameters available to the bot at this point.
        :param Sequence['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs'] text_responses: The text responses from the agent for the turn.
               Structure is documented below.
        :param 'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs' triggered_intent: The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
               Structure is documented below.
        """
        if current_page is not None:
            pulumi.set(__self__, "current_page", current_page)
        if session_parameters is not None:
            pulumi.set(__self__, "session_parameters", session_parameters)
        if text_responses is not None:
            pulumi.set(__self__, "text_responses", text_responses)
        if triggered_intent is not None:
            pulumi.set(__self__, "triggered_intent", triggered_intent)

    @property
    @pulumi.getter(name="currentPage")
    def current_page(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage']:
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        return pulumi.get(self, "current_page")

    @property
    @pulumi.getter(name="sessionParameters")
    def session_parameters(self) -> Optional[str]:
        """
        The session parameters available to the bot at this point.
        """
        return pulumi.get(self, "session_parameters")

    @property
    @pulumi.getter(name="textResponses")
    def text_responses(self) -> Optional[Sequence['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse']]:
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        return pulumi.get(self, "text_responses")

    @property
    @pulumi.getter(name="triggeredIntent")
    def triggered_intent(self) -> Optional['outputs.CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent']:
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
        return pulumi.get(self, "triggered_intent")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str display_name: (Output)
               The human-readable name of the page, unique within the flow.
        :param str name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponse(dict):
    def __init__(__self__, *,
                 texts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] texts: A collection of text responses.
        """
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter
    def texts(self) -> Optional[Sequence[str]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str display_name: (Output)
               The human-readable name of the intent, unique within the agent.
        :param str name: The unique identifier of the intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CxTestCaseTestConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trackingParameters":
            suggest = "tracking_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxTestCaseTestConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxTestCaseTestConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxTestCaseTestConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow: Optional[str] = None,
                 page: Optional[str] = None,
                 tracking_parameters: Optional[Sequence[str]] = None):
        """
        :param str flow: Flow name to start the test case with.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
               Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        :param str page: The page to start the test case with.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
               Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        :param Sequence[str] tracking_parameters: Session parameters to be compared when calculating differences.
        """
        if flow is not None:
            pulumi.set(__self__, "flow", flow)
        if page is not None:
            pulumi.set(__self__, "page", page)
        if tracking_parameters is not None:
            pulumi.set(__self__, "tracking_parameters", tracking_parameters)

    @property
    @pulumi.getter
    def flow(self) -> Optional[str]:
        """
        Flow name to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        return pulumi.get(self, "flow")

    @property
    @pulumi.getter
    def page(self) -> Optional[str]:
        """
        The page to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        return pulumi.get(self, "page")

    @property
    @pulumi.getter(name="trackingParameters")
    def tracking_parameters(self) -> Optional[Sequence[str]]:
        """
        Session parameters to be compared when calculating differences.
        """
        return pulumi.get(self, "tracking_parameters")


@pulumi.output_type
class CxVersionNluSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationThreshold":
            suggest = "classification_threshold"
        elif key == "modelTrainingMode":
            suggest = "model_training_mode"
        elif key == "modelType":
            suggest = "model_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxVersionNluSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxVersionNluSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxVersionNluSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification_threshold: Optional[float] = None,
                 model_training_mode: Optional[str] = None,
                 model_type: Optional[str] = None):
        """
        :param float classification_threshold: To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
               The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        :param str model_training_mode: Indicates NLU model training mode.
               * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
               * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
               Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        :param str model_type: Indicates the type of NLU model.
               * MODEL_TYPE_STANDARD: Use standard NLU model.
               * MODEL_TYPE_ADVANCED: Use advanced NLU model.
               Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        if classification_threshold is not None:
            pulumi.set(__self__, "classification_threshold", classification_threshold)
        if model_training_mode is not None:
            pulumi.set(__self__, "model_training_mode", model_training_mode)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @property
    @pulumi.getter(name="classificationThreshold")
    def classification_threshold(self) -> Optional[float]:
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
        The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        return pulumi.get(self, "classification_threshold")

    @property
    @pulumi.getter(name="modelTrainingMode")
    def model_training_mode(self) -> Optional[str]:
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        return pulumi.get(self, "model_training_mode")

    @property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[str]:
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class CxWebhookGenericWebService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedCaCerts":
            suggest = "allowed_ca_certs"
        elif key == "requestHeaders":
            suggest = "request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxWebhookGenericWebService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxWebhookGenericWebService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxWebhookGenericWebService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 allowed_ca_certs: Optional[Sequence[str]] = None,
                 request_headers: Optional[Mapping[str, str]] = None):
        """
        :param str uri: Whether to use speech adaptation for speech recognition.
        :param Sequence[str] allowed_ca_certs: Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
        :param Mapping[str, str] request_headers: The HTTP request headers to send together with webhook requests.
        """
        pulumi.set(__self__, "uri", uri)
        if allowed_ca_certs is not None:
            pulumi.set(__self__, "allowed_ca_certs", allowed_ca_certs)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Whether to use speech adaptation for speech recognition.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="allowedCaCerts")
    def allowed_ca_certs(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
        """
        return pulumi.get(self, "allowed_ca_certs")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, str]]:
        """
        The HTTP request headers to send together with webhook requests.
        """
        return pulumi.get(self, "request_headers")


@pulumi.output_type
class CxWebhookServiceDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genericWebService":
            suggest = "generic_web_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxWebhookServiceDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxWebhookServiceDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxWebhookServiceDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generic_web_service: 'outputs.CxWebhookServiceDirectoryGenericWebService',
                 service: str):
        """
        :param 'CxWebhookServiceDirectoryGenericWebServiceArgs' generic_web_service: The name of Service Directory service.
               Structure is documented below.
        :param str service: The name of Service Directory service.
        """
        pulumi.set(__self__, "generic_web_service", generic_web_service)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="genericWebService")
    def generic_web_service(self) -> 'outputs.CxWebhookServiceDirectoryGenericWebService':
        """
        The name of Service Directory service.
        Structure is documented below.
        """
        return pulumi.get(self, "generic_web_service")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of Service Directory service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class CxWebhookServiceDirectoryGenericWebService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedCaCerts":
            suggest = "allowed_ca_certs"
        elif key == "requestHeaders":
            suggest = "request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CxWebhookServiceDirectoryGenericWebService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CxWebhookServiceDirectoryGenericWebService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CxWebhookServiceDirectoryGenericWebService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 allowed_ca_certs: Optional[Sequence[str]] = None,
                 request_headers: Optional[Mapping[str, str]] = None):
        """
        :param str uri: Whether to use speech adaptation for speech recognition.
        :param Sequence[str] allowed_ca_certs: Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
        :param Mapping[str, str] request_headers: The HTTP request headers to send together with webhook requests.
        """
        pulumi.set(__self__, "uri", uri)
        if allowed_ca_certs is not None:
            pulumi.set(__self__, "allowed_ca_certs", allowed_ca_certs)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Whether to use speech adaptation for speech recognition.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="allowedCaCerts")
    def allowed_ca_certs(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of allowed custom CA certificates (in DER format) for HTTPS verification.
        """
        return pulumi.get(self, "allowed_ca_certs")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, str]]:
        """
        The HTTP request headers to send together with webhook requests.
        """
        return pulumi.get(self, "request_headers")


@pulumi.output_type
class EntityTypeEntity(dict):
    def __init__(__self__, *,
                 synonyms: Sequence[str],
                 value: str):
        """
        :param Sequence[str] synonyms: A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
               could be green onions.
               For KIND_LIST entity types:
               * This collection must contain exactly one synonym equal to value.
        :param str value: The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
               could be scallions.
               For KIND_MAP entity types:
               * A reference value to be used in place of synonyms.
               For KIND_LIST entity types:
               * A string that can contain references to other entity types (with or without aliases).
        """
        pulumi.set(__self__, "synonyms", synonyms)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def synonyms(self) -> Sequence[str]:
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
        could be green onions.
        For KIND_LIST entity types:
        * This collection must contain exactly one synonym equal to value.
        """
        return pulumi.get(self, "synonyms")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
        could be scallions.
        For KIND_MAP entity types:
        * A reference value to be used in place of synonyms.
        For KIND_LIST entity types:
        * A string that can contain references to other entity types (with or without aliases).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FulfillmentFeature(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The type of the feature that enabled for fulfillment.
               * SMALLTALK: Fulfillment is enabled for SmallTalk.
               Possible values are: `SMALLTALK`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the feature that enabled for fulfillment.
        * SMALLTALK: Fulfillment is enabled for SmallTalk.
        Possible values are: `SMALLTALK`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FulfillmentGenericWebService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeaders":
            suggest = "request_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FulfillmentGenericWebService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FulfillmentGenericWebService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FulfillmentGenericWebService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 password: Optional[str] = None,
                 request_headers: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str uri: The fulfillment URI for receiving POST requests. It must use https protocol.
        :param str password: The password for HTTP Basic authentication.
        :param Mapping[str, str] request_headers: The HTTP request headers to send together with fulfillment requests.
        :param str username: The user name for HTTP Basic authentication.
        """
        pulumi.set(__self__, "uri", uri)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The fulfillment URI for receiving POST requests. It must use https protocol.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for HTTP Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, str]]:
        """
        The HTTP request headers to send together with fulfillment requests.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The user name for HTTP Basic authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class IntentFollowupIntentInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followupIntentName":
            suggest = "followup_intent_name"
        elif key == "parentFollowupIntentName":
            suggest = "parent_followup_intent_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntentFollowupIntentInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntentFollowupIntentInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntentFollowupIntentInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 followup_intent_name: Optional[str] = None,
                 parent_followup_intent_name: Optional[str] = None):
        """
        :param str followup_intent_name: The unique identifier of the followup intent.
               Format: projects/<Project ID>/agent/intents/<Intent ID>.
        :param str parent_followup_intent_name: The unique identifier of the parent intent in the chain of followup intents.
               Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        if followup_intent_name is not None:
            pulumi.set(__self__, "followup_intent_name", followup_intent_name)
        if parent_followup_intent_name is not None:
            pulumi.set(__self__, "parent_followup_intent_name", parent_followup_intent_name)

    @property
    @pulumi.getter(name="followupIntentName")
    def followup_intent_name(self) -> Optional[str]:
        """
        The unique identifier of the followup intent.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        return pulumi.get(self, "followup_intent_name")

    @property
    @pulumi.getter(name="parentFollowupIntentName")
    def parent_followup_intent_name(self) -> Optional[str]:
        """
        The unique identifier of the parent intent in the chain of followup intents.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        return pulumi.get(self, "parent_followup_intent_name")


